{"0": {
    "doc": "1 Sistemas gestores de contenido (CMS)",
    "title": "1 Sistemas gestores de contenido (CMS)",
    "content": "# 1. CMS: Sistemas gestores de contenido {:toc} Vamos a empezar con algo que no tiene nada que ver con la programación: **los CMS**. Los **Sistemas Gestores de Conentido** (CMS = Content Management Systems) son aplicaciones web que permiten montar sitios web sin necesidad de programar una sola línea de código. Así que, sí, **los CMS son tus enemigos**. Y al enemigo hay que conocerlo. Cuando termines este tema, deberías ser capaz de instalar, configurar y utilizar algunos de los CMS más populares, como Wordpress y Prestashop, para publicar tus propios sitios web. En el caso concreto de Wordpress, también veremos cómo meterle mano al código fuente desarrollando nuestras propias plantillas y plugins (o modificando los que ya existen). ",
    "url": "/docs/dwes/_site/cms/",
    "relUrl": "/cms/"
  },"1": {
    "doc": "2.1 Programación cliente-servidor",
    "title": "2.1 Programación cliente-servidor",
    "content": "## 2.1. Programación cliente-servidor {: .no_toc } - TOC {:toc} En los primeros tiempos de Internet, no se ejecutaban programas en el servidor. Solo se pedían páginas estáticas (escritas en HTML) más o menos elaboradas que había sido guardadas en el servidor por un administrador de sistemas. A esto se le denominó **web 1.0**. A alguien se le ocurrió la idea de que **los propios visitantes podrían también crear contenido**. Ese contenido se guardaría en el servidor (en archivos o en una base de datos) y posteriormente podría recuperarse para generar con él páginas dinámicas, generadas sobre la marcha. Es decir, documentos HTML que no existieran previamente y que nadie, en realidad, hubiera tecleado, sino que se creasen a partir del contenido almacenado en esos archivos o esa base de datos. Esa web dinámica estaría generada por un programa ejecutado en el servidor, un programa cuya salida sería HTML válido, comprensible por el navegador que la reciba. A esto se le denominó **web 2.0** y supuso una revolución tan grande como el propio nacimiento de Internet. ### 2.1.1. Un poco de jerga informática Antes de continuar, tienes que asegurarte de que comprendes bien el significado de algunos términos básicos: * Un **servidor** es **un programa** que se ejecuta en una máquina conectada a una red y que permanece dormido hasta que una petición procedente de la red lo despierta. Entonces, el programa hace algo (consulta datos, elabora un cálculo, lo que sea) y devuelve su resultado por la red. Por extensión, un servidor también es **cualquier ordenador donde se ejecute un programa servidor**. Es decir, usamos la misma palabra para referirnos a un programa y al ordenador donde se ejecuta ese programa. Mala idea, ya lo sé, pero es lo que hay. * El **cliente** es **un programa** que envía peticiones al servidor para despertarlo. También es el programa que recoge el resultado devuelto por el servidor. ¿Y sabes qué? Que, por extensión, **la máquina** donde se ejecuta un programa cliente también se llama cliente. Pues bien, en programación web, nuestro cliente es el **navegador web** (también llamado cliente web). Cualquier navegador del universo conocido entra en esta categoría. Excepto, tal vez, Internet Explorer (sí, esto es un chiste informático). Y un servidor es cualquier máquina de la red donde se esté ejecutando un programa servidor web como Apache, Nginx, Tomcat, IIS y otros cuando viejos amigos que irás conociendo a lo largo de este curso. ### 2.1.2. Una petición web en la época 1.0 Ahora que tienes claro qué es un servidor y un cliente web, puedes comprender el siguiente esquema. En él, se ilustra lo que ocurre cuando un cliente web (recuerda: tu navegador) envía al servidor la petición de una **página estática**. El servidor, en este caso, se limita a enviar al cliente el documento HTML tal cual está almacenado en su disco duro, sin cambiar una sola coma. ![Ejemplo de servicio www](/docs/dwes/_site/assets/images/02-servicio-www-1.jpg) ### 2.1.3. Una petición web en la época 2.0 Con la web 2.0 la cosa cambia bastante porque aparecen las **páginas dinámicas**, aunque tendrás que fijarte bien en el esquema para apreciar la diferencia. Quédate con lo importante: en este esquema, el cliente web no pide un documento HTML, sino *un programa*, que puede estar escrito en PHP o algún otro lenguaje. Eso es lo de menos. Ese programa se ejecuta en el servidor, y *el resultado de esa ejecución* es lo que recibe el cliente, *no el programa en sí*. ![Ejemplo de servicio www](/docs/dwes/_site/assets/images/02-servicio-www-2.jpg) Pues bien: si un sitio web funciona del primer modo, no es una aplicación web, sino una página web estática. Para que sea considerado una aplicación web, debe funcionar del segundo modo. ",
    "url": "/docs/dwes/_site/php/programacion-cliente-servidor.html",
    "relUrl": "/php/programacion-cliente-servidor.html"
  },"2": {
    "doc": "2.2 Caja de herramientas",
    "title": "2.2 Caja de herramientas",
    "content": "## 2.2. Caja de herramientas para desarrollar de aplicaciones web {: .no_toc } - TOC {:toc} Para desarrollar apliaciones web necesitamos una caja de herramientas bastante completa. Algunas herramientas son fundamentales, como el martillo o el destornillador de una caja de herramientas convencional. Otras, en cambio, son optativas y dependerán del trabajo que vayamos a realizar y de nuestras propias preferencias como desarrolladores. En esta sección vamos a hacer un repaso de las herramientas fundamentales, las que no pueden faltar en tu caja de herramientas. Algunas ya las conoces y otras las aprenderemos a manejar a lo largo de este curso. Se trata de: * DHTML (HTML, CSS y Javascript) * PHP u otro lenguaje de script de servidor (Python, Ruby, Perl, etc) * MySQL / MariaDB u otro SGBD que permita acceso remoto. ### 2.2.1. HTML ![Logo de HTML5](/docs/dwes/_site/assets/images/02-logo-html.png) **DHTML** (Dynamic HTML) no es un lenguaje como tal, sino que, como probablemente sabes ya, es la conjunción de tres lenguajes: * HTML * CSS * JavaScript DHTML, en conjunción con, PHP son los lenguajes que nos van a permitir ejecutar programas en el servidor y acceder a sus recursos a través de páginas web, pero existen otras posibles combinaciones como: * DHTML con ASP * DHTML con JSP * DHTML con Python, Ruby, Perl, etc. HTML significa *\"HyperText Markup Language\"* (Lenguaje de Etiquetas de Hipertexto). Como sin duda sabrás, se trata de un lenguaje para formatear documentos: * Permite definir el tipo de letra, tamaño, formato y color de los textos. * Permite insertar imágenes y otro contenido multimedia. * Permite crear listas, tablas, enumeraciones... * Permite crear enlaces entre secciones del mismo documento, o enlaces con otros documentos (hipertexto) A lo largo de este texto supondremos que tú, lector o lectora, estás familiarizado con HTML. Tampoco es que necesites un nivel profesional para entenderlo todo, pero conocerlo con cierta profundidad te ayudará. Y, desde luego, si no conoces HTML en absoluto, no comprenderás nada de lo que ocurra a partir de ahora. Por lo tanto, si HTML es para ti un desconocido, es mejor que pares aquí y busques un poco de información al respecto antes de continuar. Te sorprenderá ver que HTML es bastante sencillo de comprender. Recuerda que **HTML *NO* es un lenguaje de programación**: no permite programar algoritmos. Pero sí permite incrustar otros lenguajes de programación en su interior, como enseguida veremos. Esos trozos de código incrustados dentro de HTML se denominan ***scripts***. #### Brevísima historia de HTML * En 1990 se crea HTML (procedente de un lenguaje anterior, SGML) junto con la World Wide Web, para formatear los documentos de la www. * Se amplía en sucesivas versiones hasta la 3.0, que no consiguió éxito debido a las limitaciones de los navegadores de la época. * Comienza la guerra de navegadores: Microsoft y Netscape sacan sus propios “dialectos” de HTML y destrozan en estándar. * A partir de HTML 4, los navegadores intentan unir las características de los dos, pero el resultado es demasiado confuso y complejo. * Se hace evidente que hay que hacer una “limpieza” de HTML. Así surge XHTML, la versión XML de HTML, mucho más estricta y formal, con menos añadidos pero igual de potente. Después de esta accidentada historia, nos encontramos que, en la situación actual, las versiones de HTML que puedes encontrarte pululando por la www son: * **HTML 4.01 transicional**: HTML clásico, con todos los elementos del HTML antiguo. En la actualidad está obsoleto, pero aún quedan muchas páginas antiguas que lo utilizan. * **HTML 4.01 estricto**: también llamado XHTML, no permite usar los elementos HTML desaprobados, tales como definición de formatos. También se considera obsoleto. * **HTML5**: elimina definitivamente los elementos antiguos del lenguaje e incorpora algunos nuevos para completar la asimilación con XML. Es el estándar actual. * La especificación para **HTML6** (o HTML Next) está actualmente en desarrollo. ### 2.2.3. CSS ![Logo de CSS3](/docs/dwes/_site/assets/images/02-logo-css.jpg) **CSS** significa ***\"Cascade Style Sheet\"*** (Hojas de estilo en cascada). CSS, como sin duda ya sabes, es un lenguaje para la definición de los formatos utilizados en una página web. Sólo permite definir el formato (es decir, el aspecto: colores, tipografías, disposición de los elementos...) de la página, no su contenido. Al definir los formatos en otra parte, se pueden reutilizar a lo largo de una o incluso de varias páginas: si cambiamos la definición CSS del formato, se cambian automáticamente los formatos de todas las páginas que usen esa definición. El objetivo último de CSS es **separar completamente el formato de la página de su contenido**. CSS 2.1 se usaba con HTML 4. **CSS3 se usa con HTML5 y se considera el estándar actual**. Está soportado universalmente, aunque, como sin duda habrás sufrido en tus carnes, los diferentes navegadores pueden interpretar de forma ligeramente distinta algunas definiciones CSS. Si todo esto te suena tan raro como el idioma Kinglon, deberías aprender un poco de CSS antes de continuar. Explicar los fundamentos de CSS excede a los propósitos de este texto. Si aún los desconoces, encontrarás muchos recursos sobre CSS en la red. Tampoco es necesario que te conviertas en un experto/a en CSS de la noche a la mañana, ni mucho menos: con que comprendas su sintaxis básica es suficiente. El resto puede consultarse en cualquier manual online de referencia y ya mejorarás con el tiempo y la experiencia. ### 2.2.4. Javascript ![Logo de Javascript](/docs/dwes/_site/assets/images/02-logo-js.jpg) JavaScript es un lenguaje interpretado que puede ser incrustado dentro del código HTML de una página web. El código JavaScript puede **interactuar y modificar cualquier parte del documento HTML**, por lo que dota a las páginas web de **dinamismo e interactividad**. ***JavaScript no es Java***, por mucho que su nombre se parezca. También su sintaxis puede recordar un poco a Java en algunas ocasiones. Pero déjame que te lo repita de nuevo: *Javascript no es Java*. Se parecen tanto como un euro y un yen japonés. Las dos son monedas de curso legal, pero ahí terminan sus semejanzas. La implementación de JavaScript de cada navegador es distinta, obteniéndose resultados que no siempre son iguales, por desgracia para los desarrolladores. Por ejemplo, el motor Javascript de Chrome se llama *V8*, mientras que el de Firefox es *Rhino* y el de Safari y Microsoft Edge es *WebKit*. Este texto tampoco es un manual de Javascript. Nuevamente, si no sabes nada de Javascript, debes detenerte aquí y aprender los fundamentos antes de continuar, o te perderás una parte importante de lo que sigue. Y, nuevamente, no es necesario que te conviertas en un fuera de serie del lenguaje. De momento, basta con que lo comprendas y hayas hecho unas cuantas prácticas con él. Irás mejorando con la experiencia. Porque déjame que te cuente un secreto: no se puede programar una aplicación web solo con PHP. Cualquier aplicación web lleva parte de su código en el servidor (PHP u otro lenguaje de servidor) y parte en el cliente (ya sabes: HTML, CSS y Javascript), si bien es cierto que muchos programadores se especializan más en una parte que en la otra. Pero *debes conocer ambas caras de la moneda para poder participar con éxito en el desarrollo de una aplicación web completa*. Por último, ten en cuenta que son muy pocos los desarrollos que, en la actualidad, se hacen directamente con Javascript clásico en el lado del cliente. Lo más habitual es utilizar librerías más o menos simples, o incluso completísimos frameworks, que ocultan el Javascript que existe debajo. Algunas de las librerías más populares son: **Prototype, jQuery, Angular, Vue.js o React**. ### 2.2.5. PHP ![Logo de PHP](/docs/dwes/_site/assets/images/02-logo-php.jpg) **PHP** es un acrónimo recursivo. Significa ***“PHP Hypertext Preprocessor”***. Sí, así es el sentido del humor de los informáticos. Qué le vamos a hacer. PHP es un lenguaje de programación de propósito general. De hecho, junto con librerías como PHP-Qt o PHP-GTK, puedes programar con él cualquier aplicación de escritorio con sus ventanitas, sus botoncitos y toda la pesca. Pero, por circunstancias más debidas al azar que a otra cosa, se empezó a usar para desarrollo web al comienzo de la web 2.0, y hoy en día se utiliza casi exclusivamente para ese propósito. Que es el propósito que a nosotros nos interesa, claro. Cuando se usa en desarrollo web, PHP aparece embebido dentro de documentos HTML. Enseguida veremos cómo se hace eso. Igual que sucedía con Javascript, pocos proyectos nuevos se desarrollan con PHP clásico. Lo normal es usar un framework (o colección compleja de librerías) que ocultan en todo o en parte el funcionamiento de PHP, que sigue corriendo debajo. Por supuesto, cualquier desarrollador/a web debe conocer tanto PHP como el funcionamiento de los frameworks que corren sobre PHP. Nosotros nos centraremos primero en PHP clásico, y más adelante veremos los frameworks para PHP, centrándonos en uno de los más populares y potentes que existen en la actualidad: **Laravel**. #### Características de PHP * PHP permite conectarse con múltiples bases de datos: MySQL, MariaDB, Oracle, PostgreSQL, SQL Server, DB2, etc. También puede conectar por ODBC. * Se parece mucho a otros lenguajes de tercera generación y orientados a objeto (en particular a C/C++ y, por tanto, a Java). Su curva de aprendizaje para los que ya saben programar es muy plana. * Es un lenguaje con tipado dinámico y débil. Es decir, los tipos de datos se asignan en tiempo de ejecución y pueden mezclarse tipos de datos con bastante libertad. Esto tiene ventajas e inconvenientes que descubrirás en tus carnes cuando empieces a programar con PHP. * Es un lenguaje orientado a objetos, pero conserva todas las características de los lenguajes estructurados, es decir: se puede programar sin recurrir a los objetos. Un punto a su favor para nostálgicos, aunque lo recomendable es programar con objetos *siempre*. * Es un lenguaje tremendamente flexible. Casi todo se puede hacer de tres o cuatro formas diferentes. Eso le permite adaptarse a los gustos personales de cada programador/a. #### Brevísima historia de PHP * Surge en 1995 como extensión de CGI (otro lenguaje para acceso a funciones del servidor) * PHP3 (1998) tuvo un gran éxito comercial. * PHP4 (2000) es la versión más extendida (por desgracia): la mayoría de los scripts en PHP que circulan por la red están escritos en esta versión obsoleta. * PHP5 (2004) tiene soporte para orientación a objetos y una biblioteca de clases bastante bien diseñada. Por lo tanto, desde esta versión PHP pasa de ser un lenguaje estructurado (3GL) a ser un lenguaje orientado a objetos. * PHP6 empezó a desarrollarse en 2007 y se canceló en 2014. * PHP7 introdujo novedades menores y estuvo vigente hasta 2020. En el momento de escribi esto (junio de 2021) es la versión dominante en la mayoría de los servidores web. * PHP8 es la última versión (8.0.7 en junio de 2021). Las versiones PHP4 y PHP5 se consideran obsoletas e inseguras, aunque muchas aplicaciones existentes aún las utilicen. Sigue habiendo soporte para PHP7, pero todas las nuevas aplicaciones se deberían escribir pensando en PHP8. #### Lo nuevo en PHP8 PHP8 no tiene demasiadas novedades con respecto a PHP7, como este no las tenía con respecto a PHP5. Debes tener en cuenta que el mayor salto evolutivo se produjo entre PHP 4 y PHP 5. A partir de ahí, y para principiantes como nosotros, la cosa no ha cambiado demasiado. Algunas de las novedades más destacables de PHP8 son de este calibre: * Mejoras importantes de rendimiento, con la aparición de JIT (Just in Time Compiler), un compilador de PHP que trabaja de forma transparente al programador para incrementar la velocidad de ejecución. * Mejoras menores en el manejo de las clases y métodos abstractos. * Simplificación en la declaración de atributos. * Posibilidad de usar arrays con índices negativos. Como ves, nada que vaya a revolucionar la forma de trabajar con PHP. #### Ventajas de PHP sobre otros lenguajes PHP es el líder indiscutible en el desarrollo de aplicaciones web del lado del servidor. Hace años (¡muchos!) que algunos se empeñan en decir que está muerto o que está destinado a desaparecer, pero sigue ahí, obstinadamente en el número uno. Por algo será. Algunas de las ventajas que han hecho de PHP el líder de los lenguajes del lado del servidor durante tanto tiempo son: * Es un lenguaje libre y abierto. * Es muy eficiente (comparado con otros lenguajes del lado del servidor). * Es ejecutable en (casi) cualquier servidor. * Cuenta con una excelente documentación y miles de foros y sitios donde consultar dudas. * La curva de aprendizaje es baja si ya sabes programar. * Existen mogollón de entornos de desarrollo para PHP, para todos los gustos. * Ofrece fácil interoperatibilidad con otros sistemas, en particular con bases de datos. * Comunidad muuuy grande. * Su sintaxis, estabilidad y seguridad han mejorado enormemente desde los tiempos algo caóticos de PHP4. #### Inconvenientes de PHP PHP también presenta algunos inconvenientes, por supuesto. No hay nada perfecto. Entre ellos, podemos destacar: * Fallos de diseño (corregidos en su mayoría a partir de PHP5), como: * Los métodos para acceso a bases de datos cambian según el SGBD usado. * Nombres de funciones inconsistentes. * No es completamente orientado a objetos. * Tipado confuso y, a veces, impredecible. * Grandes (e incompatibles) cambios entre versiones. * Pérdida lenta pero constante de cuota de mercado. * Pésima relación señal/ruido en la web: ¡hay demasiados *malos* desarrolladores en PHP! ### 2.2.6. MariaDB ![Logo de MariaDB](/docs/dwes/_site/assets/images/02-logo-mariadb.jpg) Otra de las herramientas básicas de nuestra caja de herramientas es el **gestor de bases de datos relacionales** (SGBD). **MariaDB** es el SGBD líder del mercado de las aplicaciones web. Nos permitirá conectarnos a una base de datos en red y ejecutar sentencias SQL de forma remota al visitar una aplicación web. Existen otras posibilidades, desde luego. Entre las más populares están: * MySQL * SQL Server * Oracle * PostgreSQL * SQLite También está la posibilidad de usar base de datos no relacionales, como *MongoDB*, *Cassandra* o *Redis*. PHP puede conectarse también a estos sistemas, pero la forma de trabajar es diferente que con bases de datos relacionales. Como estas últimas son, de lejos, las predominantes en el mercado, nos centraremos en ellas. A partir de ahora, cuando hablemos de bases de datos, siempre nos estaremos refiriendo a MariaDB o MySQL indistintamente (ya que, en la práctica, son indistinguibles para el desarrollador), pero cualquier otra base de datos relacional puede usarse del mismo modo con mínimos cambios en el código fuente. #### Características de MariaDB * MariaDB es un gestor de bases de datos relacional multiusuario y multiplataforma. * Permite mútiples conexiones remotas. * Es software libre. * Existen librerías para acceder a MariaDB desde muchos lenguajes: C/C++, Java, PHP, Perl, Pascal... Además, hay drivers ODBC. * Está muy extendida en aplicaciones web, generalmente en combinación con PHP. * Cuenta un interfaz gráfico programado en PHP, llamado PHPMyAdmin, que se ejecuta en el navegador web. Por supuesto, se puede usar cualquier otro cliente compatible con MySQL, como MySQL Workbench. #### Brevísima historia de MariaDB * MySQL surgió como un proyecto OpenSource en Suecia en 1995. * El objetivo era lograr un SGBD rápido y fiable que cumpliera con el estándar SQL. * Las primeras versiones (que se denominaron mSQL) eran muy ineficientes. * La popularización de PHP y su ganancia en eficiencia a partir de la versión 3 la han hecho muy popular en la actualidad. * Tras su adquisición por Oracle, se intentó relegar al segmento medio-bajo en el mercado de los SGBD y surgió un fork: MariaDB (traducción para los recién llegados: \"fork\" significa \"proyecto nuevo surgido a partir de otro proyecto ya existente\"). * La versión más reciente (actualizado en junio de 2021) es MariaDB 10.5.10 ",
    "url": "/docs/dwes/_site/php/caja-de-herramientas.html",
    "relUrl": "/php/caja-de-herramientas.html"
  },"3": {
    "doc": "2.3 Sintaxis de PHP",
    "title": "2.3 Sintaxis de PHP",
    "content": "## 2.3. La sintaxis de PHP {: .no_toc } - TOC {:toc} ### 2.3.1. Cómo incrustar PHP dentro de HTML El código PHP se escribe incrustado dentro de un documento de texto mediante estas etiquetas: ```html ``` **Este archivo debe tener *SIEMPRE* extensión .php, *NO* .html** Cuando el servidor web encuentre un archivo con extensión .html, lo enviará al cliente sin mirar ni siquiera lo que hay en su interior. En cambio, cuando el servidor web encuentre un archivo con extensión .php, lo abrirá y buscará las etiquetas , y ejecutará el código que haya dentro antes de enviar el resultado al cliente. El resto del archivo, es decir, lo que esté fuera de las etiquetas de PHP, se enviará al cliente sin modificar. ### 2.3.2. Comentarios Los comentarios de PHP se pueden escribir de varias formas: ```php // Comentario de una línea # Comentario de una línea /* Comentario de una o varias líneas */ ``` ### 2.3.3. Operadores Los operadores en PHP son iguales que los de Java, que, a su vez, los heredó de C/C++: * Asignación: $a = 3; * Comparación: ==, =, !=, , etc. * Operadores aritméticos: +, -, *, /, %... * Operadores lógicos: &&, \\|\\|, ! ### 2.3.4. Variables Las variables de una función/clase/método PHP son siempre **locales**, es decir, sólo están disponibles en esa función/clase/método, salvo que se indique otra cosa. Si se definen variables fuera de una función, serán **globales** a todo el fichero actual, pero no pueden usarse en el código ubicado en otros ficheros. Existen maneras de lograr que una variable sea global a todo el código, pero, vamos... ¿en serio quieres hacer eso? (Nota anticipatoria: hay ciertas situaciones en las que una aplicación web *necesita* variables globales, pero ya lo veremos en su momento. Por ahora, solo recuerda que usar variables globales es una pésima práctica de programación). El **identificador** de variable siempre debe empezar por $. Esta es una peculiaridad de PHP que al principio descoloca un poco. En PHP, no es necesario declarar las variables: al inicializarlas queda especificado el tipo. A partir de PHP7 pueden indicarse los tipos predefinidos (int, float, string...), pero solo es algo optativo. Ejemplos: ```php $a = 4; // Variable entera (PHP5+) int $a = 4; // Variable entera (PHP7+) $media = 52.75; // Variable real $texto = \"Hoy es lunes\"; // Variable string ``` Cualquier variable puede **cambiarse de tipo** con la función **setType()**: ```php $a = \"10\"; // a es una cadena setType($a, \"integer\"); // a se convierte a entero ``` **El tipado de PHP es débil**, así que puedes encontrarte expresiones donde **se mezclen tipos**. PHP hará las conversiones que le parezca oportunas, con resultados a veces imprevisibles, por lo que no es buena idea recurrir a estas estratagemas a menos que sepas muy bien lo que estás haciendo y el resultado que obtendrás. Por ejemplo: ```php $a = 3; // a es un integer $b = \"Hoy es lunes\"; // b es un string $c = $a + $b; // ¡Esto funciona, pero ¿a que no predices bien el resultado? ``` Los **tipos de datos** predefinidos en PHP son: * integer (entero) * double (real) * bool (booleano) * string (cadena) * array (pues eso) ### 2.3.5. Arrays Los arrays en PHP son colecciones de variables del mismo o de distinto tipo identificadas por un índice. Se parecen más a los ArrayList de Java que a los arrays clásicos propiamente dichos. ```php $a[1] = \"lunes\"; $a[2] = 1; // El array de PHP puede contener datos de diferente tipo en cada elemento $a[3] = \"martes\"; $a[4] = 2; etc. ``` El índice no tiene por qué ser un número entero: puede ser un String (array asociativo): ```php $a[\"ESP\"] = \"España\"; $a[\"FRA\"] = \"Francia\"; $a[\"POR\"] = \"Portugal\"; ``` ### 2.3.6. Estructuras de control Vamos a hacer un repaso muy rápido por las estructuras de control de PHP. Si ya conoces otros lenguajes como Java, todas te resultarán familiares. #### Condicionales El condicional doble tiene la sintaxis habitual: ```php if (condición) { acciones-1; } else { acciones-2; } ``` Por supuesto, la parte del ```else``` puede eliminarse si no la necesitas, y obtendrías un condicional simple. #### Bucle while El bucle de *tipo while* tiene este aspecto: ```php while (condición) { acciones; } ``` #### Bucle repeat El bucle de *tipo repeat*, es decir, con la condición al final, tiene esta sintaxis: ```php do { acciones; } while (condición); ``` #### Bucles for y foreach El bucle *for* controlado por contador es idéntico a C/C++ y Java: ```php for (inicialización; condición; incremento) { acciones; } ``` Hay una variedad de bucle *for* muy interesante: el bucle *foreach* para recorrido de arrays asociativos: ```php foreach ($array as $índice=>$var) { acciones; } ``` El bucle *foreach* se repite una vez para cada valor guardado en el array. Ese valor se asigna a la variable *$var* en cada repetición. Por ejemplo: ```php $a[\"ESP\"] = \"España\"; $a[\"FRA\"] = \"Francia\"; $a[\"POR\"] = \"Portugal\"; foreach ($a as $pais=>$codigo) { echo \"Nombre del país: $pais - Código: $codigo\"; } ``` La salida de este programa será: ``` Nombre del país: España - Código: ESP Nombre del país: Francia - Código: FRA Nombre del país: Portugal - Código: POR ``` ### 2.3.7. Funciones y procedimientos Los subprogramas (funciones y procedimientos) se escriben en PHP del mismo modo: con la palabra *function*. * Las **funciones** deben devolver un valor en su última línea con *return*. Si necesitas devolver varios valores, puedes empaquetarlos en un array o en un objeto. Ten en cuenta que, después de un *return*, la función terminará de forma inmediata y devolverá el control de ejecución al código desde la que fue invocada. Es decir: cualquier línea de código de la función que esté por debajo del *return* nunca se ejecutará. * Los **procedimientos** no tienen *return*. Realizan su función y terminan. Los **argumentos** de las funciones o procedimientos en PHP siembre se pasan ***por valor***. Por si hay algún despistado/a: pasar argumentos por valor significa que PHP copiará en el parámetro de la función el *valor* de la variable con la que se invoca a dicha función, pero serán dos variables distintas. Si modificamos un parámetro dentro del código de la función, la variable con la que fue invocada no se verá afectada. Veámoslo con un ejempolo. Esta es una función con dos argumentos: ```php function calcular_iva($base, $porcentaje) { $total = $base * $porcentaje / 100; return $total; } ``` Para invocar a esta función, haremos algo como esto en algún otro punto del código fuente: ```php $iva = $calcular_iva($precio_del_articulo, 21); ``` En esta ocasión, hemos invocado a la función $calcular_iva() con dos parámetros: una variable ($precio_del_articulo) y una constante literal (21). Ambos parámetros se pasan por valor a la función. Eso significa que el valor de $precio_del_articulo se copia en el parámetro $base, y el valor del literal 21 se copia en $porcentaje. Cualquier modificación de $base o $porcentaje que pudiera producirse dentro del código de la función, no afectaría para nada a las variables originales ($precio_del_articulo y el literal 21). Por último, la función devuelve un valor mediante su *return* y ese valor se asigna a la varible $iva. Si esto del paso de parámetros por valor sigue sonándote a chino, quizá deberías repasar tus conocimientos sobre fundamentos de programación. Busca en internet algo como \"paso de parametros por valor y por referencia\" y dedica un rato a desentrañar los misterios del paso de parámetros antes de continuar. ### 2.3.8. Clases y objetos (¡solo en PHP5 y PHP7!) Las clases, métodos y atributos se declaran de forma muy semejante a C++ y Java. Esto es una clase en PHP: ```php class MiClase extends ClaseMadre { // Declaración de propiedades (atributos) public $var1 = 'soy una variable pública de instancia'; private $var2 = 'y yo soy otra variable de instancia, pero privada'; // Método constructor (siempre se llama __construct) public function __construct($valor) { $var = $valor; } // Declaración de métodos public function mostrarVar() { echo $this->var; } private function resetVar() { $this->var = ''; } public function otroMetodo() { // ...etc... } } ``` Para instanciar un objeto de una clase, se usa la palabra *new*. El constructor puede llevar parámetros o no, como en Java. En el ejemplo anterior, el constructor tenía un argumento, así que *new* se usará así: ```php $miObjeto = new miClase('Estoy aprendiendo PHP'); $miObjeto->mostrarVar(); ``` La salida de este programa sería \"Estoy aprendiendo PHP\". ### 2.3.9. Salida de datos PHP puede hacer salidas de datos como cualquier otro lenguaje de programación: puede enviar texto a una impresora p datos a un fichero. O puede dibujar ventanas y componentes en un entorno gráfico de usuario. Pero cuando PHP se ejecuta como parte de una aplicación web, nada de eso tiene sentido: esa salida se produciría en el servidor, y nosotros no estamos allí para verla. Nosotros estamos en nuestro cliente (navegador web), pidiendo al servidor que ejecute un programa PHP. En este contexto, la salida PHP *tiene que ser siempre código HTML válido*. Ese código HTML será recibido por tu navegador, interpretado y mostrado. Observa el uso de *echo* para producir una salida HTML desde este pequeño script PHP: ```html esto en negrita\" ?> ``` Si guardas este archivo en tu servidor web y lo cargas desde un navegador web (escribiendo la dirección https://tu-servidor/nombre-del-archivo.php), encontrarás que el navegador web recibe el siguiente código como resultado: ```html Soy un script de PHP y estoy generando código HTML. Para demostrarlo voy a escribir esto en negrita ``` Es decir, han desaparecido las etiquetas de PHP, así como el *echo*, y lo que recibe el navegador es código HTML limpio e impoluto. De hecho, el navegador no sabe si ese código HTML lo ha escrito una persona o lo ha generado un programa en PHP, como es el caso. Y ese será tu objetivo: escribir programas capaces de generar código HTML que el navegador pueda recibir e interpretar. ### 2.3.10. Paso de parámetros por la URL Las aplicaciones web pueden recibir parámetros a través de la propia URL de invocación del servidor. Imagina que tenemos este link en un documento HTML: ```html ``` Al hacer clic en él, pediremos al servidor que ejecute el programa cuyo código fuente está en el archivo *pagina.php*, ¿verdad? Pues bien, ese programa *pagina.php* tendrá a su disposición unas variables llamadas *\"*variable1*, *variable2*, etc, que son las que han viajado hasta el servidor en la URL. Para acceder a esas variables, PHP utiliza un array global llamado **$_GET**, que se indexa con el nombre de las variables. Así: ```php \"; ?> ``` Observa el uso del carácter punto (.) para concatenar strings en la salida de *echo*. Esto, en Java y muchos otros lenguajes, se haría con el carácter más (+). PHP es un poquito especial en este detalle. ### 2.3.11. Entrada de datos a través de formulario (1) Como PHP se ejecuta dentro de HTML, sólo puede recibir datos del usuario de la aplicación a través del navegador web. Y sólo hay una forma de introducir datos en una página web: *a través de un formulario*. Veámoslo con un ejemplo. Supongamos que hemos definido en HTML este sencillo formulario: ```html Nombre Apellidos ``` Al pulsar el botón \"Enviar\", se cargará el script *destino.php* en el servidor. Ese script recibirá dos variables HTML llamadas *nombre* y *apellido*, con el valor que el usuario haya introducido en el formulario. Para acceder a las variables HTML, se usa el array del sistema **$_POST**, indexándolo con el nombre de la variable: ```php \" ?> ``` Observa que *$_POST* es una variable semejante a *$_GET*. Puedes utilizar una u otra según el valor del atributo *method* de tu formulario HTML. La variable **$_REQUEST** sirve tanto para POST como para GET. **Por eso será la que nosotros usaremos preferentemente en nuestros programas**. ",
    "url": "/docs/dwes/_site/php/sintaxis-de-php.html",
    "relUrl": "/php/sintaxis-de-php.html"
  },"4": {
    "doc": "2.4 Interacción con la base de datos",
    "title": "2.4 Interacción con la base de datos",
    "content": "## 2.4. Interacción entre MariaDB y PHP {: .no_toc } - TOC {:toc} A partir de ahora, vamos a referirnos a MySQL/MariaDB indistintamente. Este será el gestor de bases de datos relacionales que vamos a usar a lo largo del curso. La adaptación a otros gestores, en cualquier caso, es muy simple. MySQL/MariaDB, como ya hemos visto, es un SGBD relacional de probada eficacia. La interacción con él resulta eficiente y segura para casi cualquier aplicación web que podamos concebir. Hay básicamente tres métodos de utilizar MySQL/MariaDB: * **A través de la línea de comandos:** Iniciamos una sesión en MySQL con: ``` $ mysql -h servidor -u nombre_usuario -p ``` Y luego tenemos a nuestra disposición montones de comandos para hacer cosas con la base de datos, incluyendo ejecutar cualquier instrucción válida en SQL. * **A través de una aplicación con interfaz gráfico**, como PHPMyAdmin, una aplicación web escrita en PHP que proporciona un interfaz muy cómodo para trabajar con MySQL o MariaDB. Si no la conoces, te recomiendo que la uses a partir de ahora porque te la vas a encontrar en casi todos los servidores web. * **A través de un programa escrito en PHP** o algún otro lenguaje con posibilidad de acceso a MySQL. Este método de acceso será el que nosotros usaremos en nuestros programas para convertirlos en auténticas aplicaciones web. En esta sección, vamos a ver lo fundamental para usar MySQL desde un programa en PHP. Iremos perfeccionando nuestras habilidades al respecto a lo largo del resto del curso. ### 2.4.1. MySQL/MariaDB con PHP4 Si PHP4 está obsoleto, ¿por qué hay un apartado dedicado al acceso a MySQL desde PHP4? Buena pregunta. La respuesta es simple: *para que sepas lo que **NO** tienes que hacer*. El hecho es que encontrarás aún mucho código PHP4 pululando por internet. Los sitios donde haya código de ese estilo deben ser evitados. Suele tratarse de blogs antiguos, tutoriales obsoletos o, simplemente, gente ignorante con ganas de ayudar pero que anda bastante perdida. #### Acceso a MySQL con PHP4 (¡OBSOLETO!) El modo en que se accedía a bases de datos en PHP4 era mediante **bibliotecas de funciones diferentes para cada SGBD**. Lo digo otra vez: *esta forma de programar está obsoleta y se desaconseja su uso*. No tiene soporte oficial. Si aparecen problemas de seguridad o estabilidad, nadie los va a resolver. Si encuentras código de este estilo en internet, lárgate de ese sitio, porque no vas a aprender nada útil. PHP4 utilizaba una biblioteca de funciones PHP cuyo nombre empiezaba por las letras *mysql_*. Por ejemplo, para insertar un registro en una BD MySQL, se hacía así: ```php ``` Y para ejecutar consultas (SELECT), se hacía más o menos como en este ejemplo. No es necesario que lo entiendas todo. Basta con que te hagas una idea de la manera en la que trabajaba PHP4 para que sepas identificarlo si te lo encuentras por ahí: ```php | Nombre | Teléfono | . | '.$registro[\"nombre\"].' | '; echo ' | '.$registro[\"telefono\"].' | . '; } mysql_free_result($result) ?> ``` ### 2.4.2. MySQL/MariaDB con PHP5+ Desde PHP5, se utiliza **una biblioteca de clases para acceder a los diferentes SGBDs**. Todos los nuevos desarrollos deberían usar las bibliotecas de clases y prescindir de las viejas librerías de funciones. *Vuelvo a repetirlo: mucho código de ejemplo de PHP que circula por la red es PHP4 y DEBE SER EVITADO.* #### Formas de acceder a bases de datos en PHP PHP proporciona varios mecanismos para acceder a bases de datos (ya te lo dije antes: en PHP, casi todo se puede hacer de varias maneras distintas): * **Forma 1: Usar la extensión mysqli en su forma procedimental.** Esta forma recuerda mucho a PHP4, pero cambiando la palabra “mysql” por “mysqli”. Por ejemplo, la función *mysql_connect()* ahora se llama *mysqli_connect()* (la \"i\" significa \"improved\", es decir, \"mejorado\"). Esta forma es apta para programadores/as perezosos y anticuados, que no quieren pasarse a la programación orientada a objetos y se sienten cómodos con la forma de codificación tradicional. Pero ese no es tu caso, ¿verdad? Así que nunca utilizaremos la forma procedimental. * **Forma 2: Usar la extensión mysqli en su forma orientada a objetos.** Se accede a la base de datos a través de un objeto de la clase *mysqli*. Es decir, se crea una instancia (con ```new mysqli()```) y, a través de ella, se tiene acceso a todos los métodos para interactuar con la base de datos. Si en lugar de una base de datos MySQL, trabajamos con otro gestor de base de datos, hay que crear un objeto de otro tipo. Por ejemplo, la clase *SQLite3* sirve para conectar con bases de datos SQLite. Hay otros gestores que solo ofrecen la forma procedimental. Nosotros, como somos muy modernos, usaremos esta forma de conectar a MySQL durante el resto de este texto. * **Forma 3: Usar la extensión PDO.** A partir de PHP 5.1, existe una clase genérica, llamada *PDO*, que permite acceder a cualquier gestor de bases de datos mediante el mismo conjunto de métodos. Es lo que se llama una *capa de abstracción de acceso a datos* Esto significa que, independientemente de la base de datos que se esté utilizando, PDO permite utilizar los mismos métodos para realizar consultas y obtener datos, por lo que es una forma de trabajo perfectamente válida y que podríamos haber usado en lugar de la extensión mysqli. #### Inserción, modificación y borrado de datos con PHP5+ Vamos a ver cómo funciona la clase *mysqli* mediante unos cuantos ejemplos. En primer lugar, lanzaremos una inserción de datos. Imagina que tenemos una base de datos MySQL o MariaDB llamada *mi-base-de-datos* que contiene una tabla de clientes donde guardamos, entre otras cosas, los nombres y los teléfonos de los clientes. Insertar un registro en esa tabla desde PHP se logra en solo dos pasos: ```php query(\"INSERT INTO clientes (nombre,telefono) VALUES ('$nombre','$telefono')\"); ?> ``` Si sustituyes la sentencia INSERT por cualquier otra instrucción SQL válida, también funcionará. Con una excepción: SELECT se ejecuta de otra manera que enseguida veremos. Por lo tanto, el código anterior te puede servir de base para ejecutar cualquier INSERT, UPDATE o DELETE sobre tu base de datos. O incluso sentencias de definición de la base de datos, como CREATE TABLE o ALTER TABLE (siempre que el usuario con el que te estés conectando tenga permisos para ejecutarlas, claro) #### Consultas con PHP5+ Hemos dicho que las sentencias SELECT se lanzan desde PHP de un modo diferente al resto. ¿Por qué será? La respuesta es sencilla de entender: la ejecución de consultas (SELECT) produce la devolución de un conjunto de registros, mientras que cualquier otra instucción (INSERT, UPDATE, DELETE o lo que sea) no devuelve ningún registro. Los registros obtenidos como resultado de un SELECT se manejan en PHP con un objeto denominado **cursor**. Un cursor no es más que un puntero al conjunto de resultados que señala al registro que se va a procesar a continuación. Es decir: se parece al cursor de tu procesador de textos, que te indica el lugar en el que vas a insertar o borrar caracteres. En el caso de los cursores MySQL, no te permiten borrar nada. El cursor solo señala un registro concreto dentro de los resultados del SELECT. Observa cómo se hace un SELECT en este ejemplo: ```php connect_error){ die(\"Error en la conexion : \".$db->connect_error); } //Ejecutamos la consulta SQL $result=$db->query(\"SELECT * FROM Clientes\"); ?> | Nombre | Teléfono | . fetch_array()) { echo ' | '.$registro[\"nombre\"].' | '; echo ' | '.$registro[\"telefono\"].' | . '; } $db->free($result); // Libera memoria usada por cursor $db->close(); // Cierra la conexión con el servidor ?> ``` Probablemente ya lo hayas captado sin necesidad de explicaciones adicionales, pero, por si acaso no es así, ahí va una explicación adicional gratuita. Cuando se lanza una consulta contra una base de datos desde PHP, la base de datos nos devuelve el resultado en un *cursor*, como hemos dicho. Ese objeto de tipo cursor lo almacenamos en una variable que, en este ejemplo, hemos llamado *$result*. Recuerda que un cursor es un apuntador a un conjunto de resultados. Cuando un cursor está recién abierto, *siempre apunta al primer registro de ese conjunto de resultados*. Nuestra variable *result* es un objeto (su clase se llama *mysqli_result*, por cierto). Y, como cualquier objeto, contiene una serie de métodos. Entre esos métodos, cualquier cursor siempre nos ofrecerá un método importantísimo llamado ***fetch()*** o algo semejante. El método *fetch()* hace lo siguiente: nos devuelve el siguiente dato almacenado en el cursor (en nuestro caso, un registro completo) y hace avanzar al cursor para que apunte al siguiente dato (en nuestro caso, el siguiente registro). Así, lo deja preparado para recuperar otro registro en la siguiente iteración. Por eso hemos colocado la instrucción *fetch()* en un bucle. Ahora todo empieza a encajar, ¿verdad? Cuando el cursor está recién abierto, el primer *fetch()* nos devuelve el primer registro del resultado. Es decir, el primer cliente. Podemos acceder a los campos de ese registro (como \"nombre\" o \"teléfono\") accediendo al registro como si fuera un array ($registro[\"nomnre\"], $registro[\"telefono\"], etc). Por eso el método no se llama solo *fetch()*, sino *fetch_array()*. Pero *fetch()* no solo recupera el primer registro, sino que hace avanzar el cursor para que se quede apuntando al segundo. De este modo, en la siguiente iteración del bucle, *fetch_array()* nos recupera *el segundo* registro (el segundo cliente), y el cursor queda apuntando al tercero, listo para la siguiente iteración. Cuando no quedan más registros que procesar, *fetch()* devuelve *false* y el bucle termina. De ese modo, habremos procesado fácilmente todo el conjunto de resultados devueltos por la consulta. El método *fetch()* tiene varias formas. Nosotros usaremos sobre todo estas dos: * ***fetch_array()***, como en el ejemplo anterior. Cada registro del resultado tiene forma de array. Para acceder, por ejemplo, al nombre de un cliente, escribimos algo como ```$registro[\"nombre\"]```. * ***fetch_object()***, que funciona igual, pero cada registro del resultado tiene forma de objeto. Para acceder, por ejemplo, al nombre de un cliente, escribimos algo como ```$registro->nombre```. ",
    "url": "/docs/dwes/_site/php/interaccion-con-php.html",
    "relUrl": "/php/interaccion-con-php.html"
  },"5": {
    "doc": "2.5 Ejercicios resueltos",
    "title": "Biblioteca",
    "content": "\"; // Buscamos todos los libros de la biblioteca if ($result = $db->query(\"SELECT * FROM libros INNER JOIN escriben ON libros.idLibro = escriben.idLibro INNER JOIN personas ON escriben.idPersona = personas.idPersona ORDER BY libros.titulo\")) { // La consulta se ha ejecutado con éxito. Vamos a ver si contiene registros if ($result->num_rows != 0) { // La consulta ha devuelto registros: vamos a mostrarlos // Primero, el formulario de búsqueda echo \" \"; // Ahora, la tabla con los datos de los libros echo \"\"; while ($fila = $result->fetch_object()) { echo \"\"; echo \" | \" . $fila->titulo . \" | \"; echo \" | \" . $fila->genero . \" | \"; echo \" | \" . $fila->numPaginas . \" | \"; echo \" | \" . $fila->nombre . \" | \"; echo \" | \" . $fila->apellido . \" | \"; echo \" | idLibro . \"'>Modificar | \"; echo \" | idLibro . \"'>Borrar | \"; echo \" . \"; } echo \"\"; } else { // La consulta no contiene registros echo \"No se encontraron datos\"; } } else { // La consulta ha fallado echo \"Error al tratar de recuperar los datos de la base de datos. Por favor, inténtelo más tarde\"; } echo \"Nuevo . \"; break; // --------------------------------- FORMULARIO ALTA DE LIBROS ---------------------------------------- case \"formularioInsertarLibros\": echo \" ",
    "url": "/docs/dwes/_site/php/ejercicios-resueltos.html",
    "relUrl": "/php/ejercicios-resueltos.html"
  },"6": {
    "doc": "2.5 Ejercicios resueltos",
    "title": "Modificación de libros",
    "content": "\"; // Creamos el formulario con los campos del libro echo \" Título: Género: País: Año: Número de páginas:\"; // Añadimos un selector para el id del autor o autores $result = $db->query(\"SELECT * FROM personas\"); echo \"Autores: \"; while ($fila = $result->fetch_object()) { echo \"idPersona . \"'>\" . $fila->nombre . \" \" . $fila->apellido . \"\"; } echo \"\"; echo \"Añadir nuevo\"; // Finalizamos el formulario echo \" \"; echo \"Volver . \"; break; // --------------------------------- INSERTAR LIBROS ---------------------------------------- case \"insertarLibro\": echo \" ",
    "url": "/docs/dwes/_site/php/ejercicios-resueltos.html",
    "relUrl": "/php/ejercicios-resueltos.html"
  },"7": {
    "doc": "2.5 Ejercicios resueltos",
    "title": "Alta de libros",
    "content": "\"; // Vamos a procesar el formulario de alta de libros // Primero, recuperamos todos los datos del formulario $titulo = $_REQUEST[\"titulo\"]; $genero = $_REQUEST[\"genero\"]; $pais = $_REQUEST[\"pais\"]; $ano = $_REQUEST[\"ano\"]; $numPaginas = $_REQUEST[\"numPaginas\"]; $autores = $_REQUEST[\"autor\"]; // Lanzamos el INSERT contra la BD. echo \"INSERT INTO libros (titulo,genero,pais,ano,numPaginas) VALUES ('$titulo','$genero', '$pais', '$ano', '$numPaginas')\"; $db->query(\"INSERT INTO libros (titulo,genero,pais,ano,numPaginas) VALUES ('$titulo','$genero', '$pais', '$ano', '$numPaginas')\"); if ($db->affected_rows == 1) { // Si la inserción del libro ha funcionado, continuamos insertando en la tabla \"escriben\" // Tenemos que averiguar qué idLibro se ha asignado al libro que acabamos de insertar $result = $db->query(\"SELECT MAX(idLibro) AS ultimoIdLibro FROM libros\"); $idLibro = $result->fetch_object()->ultimoIdLibro; // Ya podemos insertar todos los autores junto con el libro en \"escriben\" foreach ($autores as $idAutor) { $db->query(\"INSERT INTO escriben(idLibro, idPersona) VALUES('$idLibro', '$idAutor')\"); } echo \"Libro insertado con éxito\"; } else { // Si la inserción del libro ha fallado, mostramos mensaje de error echo \"Ha ocurrido un error al insertar el libro. Por favor, inténtelo más tarde.\"; } echo \"Volver . \"; break; // --------------------------------- BORRAR LIBROS ---------------------------------------- case \"borrarLibro\": echo \" ",
    "url": "/docs/dwes/_site/php/ejercicios-resueltos.html",
    "relUrl": "/php/ejercicios-resueltos.html"
  },"8": {
    "doc": "2.5 Ejercicios resueltos",
    "title": "Borrar libros",
    "content": "\"; // Recuperamos el id del libro y lanzamos el DELETE contra la BD $idLibro = $_REQUEST[\"idLibro\"]; $db->query(\"DELETE FROM libros WHERE idLibro = '$idLibro'\"); // Mostramos mensaje con el resultado de la operación if ($db->affected_rows == 0) { echo \"Ha ocurrido un error al borrar el libro. Por favor, inténtelo de nuevo\"; } else { echo \"Libro borrado con éxito\"; } echo \"Volver . \"; break; // --------------------------------- FORMULARIO MODIFICAR LIBROS ---------------------------------------- case \"formularioModificarLibro\": echo \" ",
    "url": "/docs/dwes/_site/php/ejercicios-resueltos.html",
    "relUrl": "/php/ejercicios-resueltos.html"
  },"9": {
    "doc": "2.5 Ejercicios resueltos",
    "title": "Modificación de libros",
    "content": "\"; // Recuperamos el id del libro que vamos a modificar y sacamos el resto de sus datos de la BD $idLibro = $_REQUEST[\"idLibro\"]; $result = $db->query(\"SELECT * FROM libros WHERE libros.idLibro = '$idLibro'\"); $libro = $result->fetch_object(); // Creamos el formulario con los campos del libro // y lo rellenamos con los datos que hemos recuperado de la BD echo \" Título:titulo'> Género:genero'> País:pais'> Año:ano'> Número de páginas:numPaginas'>\"; // Vamos a añadir un selector para el id del autor o autores. // Para que salgan preseleccionados los autores del libro que estamos modificando, vamos a buscar // también a esos autores. $todosLosAutores = $db->query(\"SELECT * FROM personas\"); // Obtener todos los autores $autoresLibro = $db->query(\"SELECT idPersona FROM escriben WHERE idLibro = '$idLibro'\"); // Obtener solo los autores del libro que estamos buscando // Vamos a convertir esa lista de autores del libro en un array de ids de personas $listaAutoresLibro = array(); while ($autor = $autoresLibro->fetch_object()) { $listaAutoresLibro[] = $autor->idPersona; } // Ya tenemos todos los datos para añadir el selector de autores al formulario echo \"Autores: \"; while ($fila = $todosLosAutores->fetch_object()) { if (in_array($fila->idPersona, $listaAutoresLibro)) echo \"idPersona' selected>$fila->nombre $fila->apellido\"; else echo \"idPersona'>$fila->nombre $fila->apellido\"; } echo \"\"; // Por último, un enlace para crear un nuevo autor echo \"Añadir nuevo\"; // Finalizamos el formulario echo \" \"; echo \"Volver . \"; break; // --------------------------------- MODIFICAR LIBROS ---------------------------------------- case \"modificarLibro\": echo \" ",
    "url": "/docs/dwes/_site/php/ejercicios-resueltos.html",
    "relUrl": "/php/ejercicios-resueltos.html"
  },"10": {
    "doc": "2.5 Ejercicios resueltos",
    "title": "Modificación de libros",
    "content": "\"; // Vamos a procesar el formulario de modificación de libros // Primero, recuperamos todos los datos del formulario $idLibro = $_REQUEST[\"idLibro\"]; $titulo = $_REQUEST[\"titulo\"]; $genero = $_REQUEST[\"genero\"]; $pais = $_REQUEST[\"pais\"]; $ano = $_REQUEST[\"ano\"]; $numPaginas = $_REQUEST[\"numPaginas\"]; $autores = $_REQUEST[\"autor\"]; // Lanzamos el UPDATE contra la base de datos. $db->query(\"UPDATE libros SET titulo = '$titulo', genero = '$genero', pais = '$pais', ano = '$ano', numPaginas = '$numPaginas' WHERE idLibro = '$idLibro'\"); if ($db->affected_rows == 1) { // Si la modificación del libro ha funcionado, continuamos actualizando la tabla \"escriben\". // Primero borraremos todos los registros del libro actual y luego los insertaremos de nuevo $db->query(\"DELETE FROM escriben WHERE idLibro = '$idLibro'\"); // Ya podemos insertar todos los autores junto con el libro en \"escriben\" foreach ($autores as $idAutor) { $db->query(\"INSERT INTO escriben(idLibro, idPersona) VALUES('$idLibro', '$idAutor')\"); } echo \"Libro actualizado con éxito\"; } else { // Si la modificación del libro ha fallado, mostramos mensaje de error echo \"Ha ocurrido un error al modificar el libro. Por favor, inténtelo más tarde.\"; } echo \"Volver . \"; break; // --------------------------------- BUSCAR LIBROS ---------------------------------------- case \"buscarLibros\": // Recuperamos el texto de búsqueda de la variable de formulario $textoBusqueda = $_REQUEST[\"textoBusqueda\"]; echo \" ",
    "url": "/docs/dwes/_site/php/ejercicios-resueltos.html",
    "relUrl": "/php/ejercicios-resueltos.html"
  },"11": {
    "doc": "2.5 Ejercicios resueltos",
    "title": "Resultados de la búsqueda: \\\"$textoBusqueda\\\"",
    "content": "\"; // Buscamos los libros de la biblioteca que coincidan con el texto de búsqueda if ($result = $db->query(\"SELECT * FROM libros INNER JOIN escriben ON libros.idLibro = escriben.idLibro INNER JOIN personas ON escriben.idPersona = personas.idPersona WHERE libros.titulo LIKE '%$textoBusqueda%' OR libros.genero LIKE '%$textoBusqueda%' OR personas.nombre LIKE '%$textoBusqueda%' OR personas.apellido LIKE '%$textoBusqueda%' ORDER BY libros.titulo\")) { // La consulta se ha ejecutado con éxito. Vamos a ver si contiene registros if ($result->num_rows != 0) { // La consulta ha devuelto registros: vamos a mostrarlos // Primero, el formulario de búsqueda echo \" \"; // Después, la tabla con los datos echo \"\"; while ($fila = $result->fetch_object()) { echo \"\"; echo \" | \" . $fila->titulo . \" | \"; echo \" | \" . $fila->genero . \" | \"; echo \" | \" . $fila->numPaginas . \" | \"; echo \" | \" . $fila->nombre . \" | \"; echo \" | \" . $fila->apellido . \" | \"; echo \" | idLibro . \"'>Modificar | \"; echo \" | idLibro . \"'>Borrar | \"; echo \" . \"; } echo \"\"; } else { // La consulta no contiene registros echo \"No se encontraron datos\"; } } else { // La consulta ha fallado echo \"Error al tratar de recuperar los datos de la base de datos. Por favor, inténtelo más tarde\"; } echo \"Nuevo . \"; echo \"Volver . \"; break; // --------------------------------- ACTION NO ENCONTRADA ---------------------------------------- default: echo \" ",
    "url": "/docs/dwes/_site/php/ejercicios-resueltos.html",
    "relUrl": "/php/ejercicios-resueltos.html"
  },"12": {
    "doc": "2.5 Ejercicios resueltos",
    "title": "Error 404: página no encontrada",
    "content": "\"; echo \"Volver\"; break; } // switch ?> . ``` ``` ",
    "url": "/docs/dwes/_site/php/ejercicios-resueltos.html",
    "relUrl": "/php/ejercicios-resueltos.html"
  },"13": {
    "doc": "2.5 Ejercicios resueltos",
    "title": "2.5 Ejercicios resueltos",
    "content": "## 2.5. Ejercicios resueltos {: .no_toc } - TOC {:toc} Ya hemos visto muy superficialmente cómo es el lenguaje PHP y cómo se puede acceder desde él a una base de datos externa para almacenar o recuperar información de ella. Ahora nos queda poner eso en práctica antes de poder profundizar más en el desarrollo de aplicaciones web complejas. En esta sección vamos a mostrar algunos ejemplos sencillos de aplicaciones web muy, muy básicas programadas con PHP. La última de ellas incluye un acceso a una base de datos. Mira con detenimiento el código y asegúrate de comprenderlo. Para empezar a programar con PHP, no hay nada mejor que echar un vistazo a algunos programas fáciles que luego puedas utilizar como plantilla para los tuyos. Eso sí, es imprescindible que, después, dediques un tiempo a tratar de escribir tú mismo/a tus propios programas sencillos. Al final de esta sección te propondremos algunos, aunque tú puedes cambiarlos por otros que te apetezcan más. Lo importante es que recuerdes siempre algo que parece obvio pero que, a menudo, la gente olvida: *a programar solo puede aprenderse programando*. ### 2.5.1. Tabla de multiplicar Vamos a escribir un programa en PHP que pida un número al usuario y muestre su tabla de multiplicar hasta el 25 en una tabla HTML de 5 por 5 casillas. El usuario escribirá el número en un formulario HTML. #### Solución 1: con dos archivos fuente Esta primera solución la vamos a plantear con dos archivos: * ***index.php***: contendrá el formulario en el que vamos a pedir al usuario que escriba un número. En el action del formulario, pondremos el nombre del segundo archivo para enviarle el número. * ***tabla.php***: recibirá el número escrito en el formulario y calculará la tabla de multiplicar, escribiendo la salida en formato HTML. **ARCHIVO *index.php*** ```php Tabla de multiplicar - Versión 1 . Introduce un número: . ``` **ARCHIVO *tabla.php*** ```php Tabla de multiplicar - Versión 1 . \"; echo \" | Tabla de multiplicar del número $n | . \"; echo \"\"; for ($i = 1; $i \"; echo \" | $n x $i = \" . $n * $i . \" | \"; } echo \" . \"; echo \"\"; ?> . ``` #### Solución 2: con un solo archivo Vamos a mejorar la solución anterior **uniendo todo el código en un solo archivo**, que podemos llamar *index.php*. Eso signfica que, ahora, en el *action* del formulario, escribiremos *index.php*, de modo que, al pulsar submit, el número se enviará al mismo programa. Es decir, *index.php* se ejecutará dos veces: una para mostrar el formulario y otra para calcular la tabla de multiplicar. Observa como se usa la ***función isset()*** para averiguar en cuál de esas dos ejecuciones estamos. Esta función recibe como parámetro una variable y nos dice si esa variable existe o, por el contrario, si no ha sido declarada ni inicializada aún. ```php Tabla de multiplicar - Versión 2 . Introduce un número: \"; } else { // Ya tenemos número pasado por GET. Vamos a calcular su tabla de multiplicar. $n = $_REQUEST[\"numero\"]; echo \"\"; echo \" | Tabla de multiplicar del número $n | . \"; echo \"\"; for ($i = 1; $i \"; echo \" | $n x $i = \" . $n * $i . \" | \"; } echo \" . \"; echo \"\"; } ?> . ``` ### 2.5.2. Juego del número secreto Vamos a escribir una aplicación web en PHP para jugar al *juego del número secreto*. Es un juego clásico que consiste en lo siguiente: el ordenador elegirá un número al azar entre 1 y 100 y el jugador tendrá que averiguarlo. Cada vez que el jugador haga un intento, la aplicación le indicará si el número secreto es mayor o menor que el número introducido. Cuando el jugador por fin acierte, la aplicación le dará la enhorabuena y le indicará cuántos intentos ha necesitado para averiguar el número secreto. Vamos a ver dos soluciones para este programa. En la primera, utilizaremos las variables de la URL para mantener vivos los datos del programa. En la segunda, utilizaremos **variables de sesión** para lograr el mismo efecto de forma mucho más limpia. #### Juego del número secreto: solución sin variables de sesión Este juego necesita que algunas variables, como el número secreto (variable *$aleatorio*) o el número de intentos (variable *$intentos*) persistan entre una solicitud al servidor y la siguiente. Para lograrlo, haremos que el script se envíe a sí mismo el valor de esas variables en la última línea. Supondremos que el archivo se llama *index.php*. Esta es **una solución muy poco elegante**, un estilo de programación de aplicaciones web que se dejó de usar hace años, pero que ilustra perfectamente cuál es el primer problema al que nos enfrentamos al desarrollar aplicaciones web: *que se ejecutan en el servidor \"a tirones\", un trozo cada vez, y para el servidor cada uno de esos trozos es un programa independiente, aunque el usuario tenga la sensación de que forman una aplicación coherente*. ```php Juego del número secreto . Adivina mi número: \"; // ¿Y el número aleatorio? Si aún no existe, significa que es LA PRIMERA ejecución y aún tenemos que elegirlo. // En cambio, si ya existe, tendremos que recuperarlo para seguir usando el mismo aleatorio y no uno nuevo cada vez. if (!isset($_REQUEST['aleatorio'])) { $intentos = 0; $aleatorio = rand(1,100); } else { $aleatorio = $_REQUEST['aleatorio']; $intentos = $_REQUEST['intentos']; } } else { // La variable \"numero\" existe. Eso indica que el usuario escribió un número en el formulario. // Vamos a recuperar ese número y a compararlo con el aleatorio. $n = $_REQUEST['numero']; $aleatorio = $_REQUEST['aleatorio']; $intentos = $_REQUEST['intentos']; $intentos++; echo \"Tu número es: $n\"; if ($n > $aleatorio) { echo \"Mi número es MENOR\"; } else if ($n ENHORABUENA, HAS ACERTADO . \"; echo \"Has necesitado $intentos intentos\"; } // Volvemos a llamar a este mismo programa, pasándole como variables de URL el aleatorio // y el número de intentos, para seguir jugando con el mismo número secreto. echo \"Sigue jugando...\"; } ?> ``` #### Juego del número secreto: solución con variables de sesión En esta solución, se ha sustituido la chapuza de las variables pasadas por URL por **variables de sesión**. Aunque las veremos con más detalle en el siguiente tema, te puedo adelantar que las variables de sesión permiten almacenar datos persistentes entre sucesivas ejecuciones de scripts desde el mismo cliente. Es decir, *el servidor **recuerda** el valor de determinadas variables* para que ese programa ejecutado a tirones se comporte como un todo unificado de cara al usuario. Observa detenidamente cómo se usan las variables de sesión con PHP mediante el array global $_SESSION para obtener una solución más elegante que la anterior. ```php Juego del número secreto . Adivina mi número: \"; // ¿Será la primera ejecución? Vamos a ver si ya existe la variable \"aleatorio\". // Si no existe, la creamos, pero esta vez como variable de sesión, no de URL. // Esa variable quedará almacenada en el servidor y seguirá existiendo hasta que // cerremos la sesión. if (!isset($_SESSION['aleatorio'])) { $_SESSION['aleatorio'] = rand(1,100); $_SESSION['intentos'] = 0; } } else { // Existe la variable \"numero\": significa que el usuario rellenó el formulario y pulsó \"submit\". // Vamos a compararla con el aleatorio. // Guardaremos \"numero\" y \"aleatorio\" en variable locales // para manejarlas con más comodidad, pero no es imprescindible hacerlo. $n = $_REQUEST['numero']; $aleatorio = $_SESSION['aleatorio']; $_SESSION['intentos']++; echo \"Tu número es: $n\"; if ($n > $aleatorio) { echo \"Mi número es MENOR\"; echo \"Sigue jugando...\"; } else if ($n Sigue jugando...\"; } else { echo \"ENHORABUENA, HAS ACERTADO . \"; echo \"Has necesitado \".$_SESSION['intentos'].\" intentos\"; unset($_SESSION['aleatorio']); // Esto destruye la variable de sesión echo \"Jugar de nuevo\"; } } ?> . ``` ### 2.5.3. Biblioteca Este es un caso práctico muy importante por dos razones: 1. Porque es nuestra primera aplicación web \"de verdad\", con una base de datos detrás. 2. Porque volveremos sobre ella varias veces a lo largo de las siguientes secciones para hacerle sucesivas mejoras, hasta dejarla presentable. El código fuente es más largo, pero fácil de seguir. No te desesperes ni intentes leerlo en dos minutos para marcharte a hacer otra cosa. Tómatelo con calma, como si leer el código fuente fuera como leer un manual de instrucciones de un electrodoméstico nuevo que aún no tienes ni idea de cómo se usa. **Se trata de escribir una aplicación web en PHP que gestione, de forma muy simplificada, una biblioteca**. La aplicación trabajará con una base de datos compuesta de solo dos tablas (ya te dije que estaría muy simplificada): *libros* y *autores*. Esta aplicación nos permitirá, en principio, ver la lista de todos los libros disponibles, así como dar de alta libros nuevos y modificar o borrar los libros existentes. De momento no trabajaremos con los autores, pero sería fácil extenderla para que también nos dejase hacer altas, bajas y modificaciones de los autores. Al leer el código, observa cómo utilizamos una variable muy especial llamada ***$action*** para saber qué tiene que hacer la aplicación en cada momento. Esa variable es el germen de la *arquitectura modelo-vista-controlador* con la que trabajaremos una y otra vez más adelante. ```php . <?php $db = new mysqli(\"servidor-de-base-de-datos\", \"usuario\", \"password\", \"nombre-base-de-datos\"); // Miramos el valor de la variable \"action\", si existe. Si no, le asignamos una acción por defecto if (isset($_REQUEST[\"action\"])) { $action = $_REQUEST[\"action\"]; } else { $action = \"mostrarListaLibros\"; // Acción por defecto } // CONTROL DE FLUJO PRINCIPAL // El programa saltará a la sección del switch indicada por la variable \"action\" switch ($action) { // --------------------------------- MOSTRAR LISTA DE LIBROS ---------------------------------------- case \"mostrarListaLibros\": echo \" ",
    "url": "/docs/dwes/_site/php/ejercicios-resueltos.html",
    "relUrl": "/php/ejercicios-resueltos.html"
  },"14": {
    "doc": "2.6 Ejercicios propuestos",
    "title": "2.6 Ejercicios propuestos",
    "content": "## 2.6. Ejercicios propuestos {: .no_toc } - TOC {:toc} Los siguientes son una colección de ejercicios de programación que funcionan exactamente igual que los ejercicios en el gimnasio: para fortalecer tu musculatura como programador o programadora. Está ordenados por orden creciente de complejidad, y no es necesario que los hagas todos. Por ejemplo, si los primeros te resultan demasiado fáciles, salta hasta alguno que suponga algún reto para ti. Por el contrario, si hasta los primeros te cuestan trabajo, deberías ir intentándolos todos o casi todos en orden. También puedes escribir tus propios programas si los que aparecen aquí no te interesan demasiado: siempre es bueno que el programa que estás desarrollando, aunque sea sencillo, te resulte motivador. No te asustes si el programa que intentas escribir parece muy complejo, no llegas a terminarlo o incluso no te funciona en absoluto: todo el tiempo dedicado a programar es tiempo bien aprovechado para un aprendiz de programación. Estos ejercicios requerirán de ti dedicación, esfuerzo y constancia. Como ir al gimnasio, vamos. Pero por eso estás aquí, ¿no es cierto? Y recuerda lo que ya hemos dicho varias veces antes: ***a programar solo se aprende programando***. ### 2.6.1. Ejercicios sin acceso a bases de datos #### Ejercicio 1: positivo, negativo Diseña un formulario con un campo de texto en el que puedas escribir números. Al pulsar el botón de enviar, debe llamar a un script escrito en PHP que debe decirnos si el número enviado fue positivo, cero o negativo. #### Ejercicio 2: anagramas Una palabra es un anagrama de otra si contiene las mismas letras colocadas en orden diferente. Por ejemplo, \"CAVA\" es un anagrama de \"VACA\", y viceversa. El ejercicio consiste en escribir un programa en PHP que pida dos palabras y compruebe si la primera es un anagrama de la segunda. #### Ejercicio 3: función potencia Escribe una función PHP que reciba dos parámetros (A y B) y devuelva el valor de la potencia de A elevado a B (AB). Escribe también un programa PHP que haga uso de esa función para calcular potencias. #### Ejercicio 4: devolución de arrays Escribe un programa PHP que pida cinco números al usuario y los guarde en un array. Luego debe llamar a una función pasándole el array como parámetro, y la función calculará cuál de los cinco números es el mayor, cuál el menor y cuánto vale la media, devolviendo esos tres valores en otro array. Por último, se mostrarán en la pantalla el mayor, el menor y la media. #### Ejercicio 5: Simon dice \"Simon dice\" es un clásico juego de memoria que consiste en componer secuencias de cuatro colores cada vez más largas, y el jugador tiene que recordarlas y reproducirlas. Puedes encontrar muchas versiones de Simon en internet. Nosotros vamos a construir una versión simplificada que muestre secuencias de números (aunque podríamos hacerlo con colores sólo complicándolo un poco). El programa mostrará un número entre 1 y 4 durante un instante, y luego borrará la pantalla y pedirá al usuario que lo repita. Después mostrará dos números aleatorios entre 1 y 4 (por ejemplo, 3 – 1), y luego el usuario los tendrá que repetir, y así hasta que el usuario falle al introducir los números. ### 2.6.2. Ejercicios con acceso a bases de datos #### Ejercicio 6: videoclub simplificado En esta sección, en lugar de ejercicios independientes, vamos a plantear una aplicación más larga que iremos montando paso a paso. Al final, tendrás una aplicación web simple pero plenamente funcional: *tu primera aplicación web*. **Importante**: puedes (y te aconsejo que así lo hagas) utilizar como base para esta aplicación la Biblioteca que aparecía en la sección de \"Ejercicios resueltos\". Conéctate a tu servidor de MySQL con el cliente que prefieras (te recomiendo *PhpMyAdmin*, que viene de serie con XAMPP) y crea una base de datos vacía a la que debes añadir estas tablas: * Películas (id#, titulo, genero, pais, anyo, cartel) * Personas (id#, nombre, apellidos, fotografia) * Actúan (idPelicula#, idPersona#) Inserta algunos datos en las tablas para que no estén vacías. Las imágenes deben ser cadenas de caracteres con la ruta del archivo que realmente contiene la imagen. Este archivo debe estar almacenado en una subcarpeta de la aplicación (por ejemplo, \"images\"). A continuación, y utilizando como base el código fuente de la Biblioteca, haz que tu aplicación web sea capaz de: 1. **Mostrar una lista de las películas** que hay en la base de datos (con su reparto). Junto a cada película, debe aparecer dos enlaces con el texto \"Modificar\" y \"Borrar\". Y, antes o después de la lista, debe aparecer un enlace para \"Añadir\" una película y otro para \"Buscar\". 2. **Borrar una película**. Se accede a esta funcionalidad desde la lista de películas. 3. **Buscar una película**. Se accede a esta funcionalidad desde la lista de películas. 4. **Insertar una película nueva**. Se accede a esta funcionalidad desde la lista de películas. No trates de insertar, de momento, el reparto de la película: solo los datos de la tabla \"Películas\". 5. **Modificar una película existente**. Se accede a esta funcionalidad desde la lista de películas. No modifiques el reparto, solo los datos de la película. Programa esas operaciones en ese orden, porque van de la más sencilla a la más complicada de desarrollar, y básate en el caso resuelto \"Biblioteca\" que vimos en la sección anterior. #### Ejercicio 7: ampliación indefinida del videoclub Si terminas antes de tiempo, puedes ir ampliando esta aplicación indefinidamente en varias direcciones: * Añadir el mantenimiento de la tabla de Personas: búsquedas, inserciones, modificaciones y borrados. * Asignar el reparto a cada película, es decir, hacer inserciones y borrados en la tabla Actuan, tanto al crear una película como al modificarla. * Crear nuevas tablas para relacionar Personas y Películas, de manera que la base de datos pueda contener también las personas que dirigen, escriben o producen las películas, y añadir todo esto a la aplicación. * Incluir enlaces a trailers de cada película en Youtube. * Añadir un sistema de votaciones de los visitantes para cada película. * ¡Y todo lo que se te ocurra! ",
    "url": "/docs/dwes/_site/php/ejercicios-propuestos.html",
    "relUrl": "/php/ejercicios-propuestos.html"
  },"15": {
    "doc": "2 Introducción a PHP",
    "title": "2 Introducción a PHP",
    "content": "# 2. Introducción a PHP {:toc} En este capítulo te voy a presentar a un amigo íntimo: **el lenguaje PHP**. Veremos la sintaxis básica y cómo este lenguaje trabaja **en el lado del servidor** para ayudarnos a crear aplicaciones web dinámicas, es decir, aplicaciones que generan un HTML distinto según los datos de entrada y el estado del servidor. También conoceremos el **kit de herramientas** básico que vamos a necesitar para convertirnos en desarrolladores/as web y nos conectaremos a una base de datos remota para enviar y recuperar información. Por último, veremos algunos **ejemplos de aplicaciones web** sencillas que puedes utilizar como base para tus propios desarrollos. Esta será una práctica habitual a lo largo de todo este curso de programación: siempre ofreceremos ejemplos de código real para comprender y aplicar la parte más \"teórica\". Y, por supuesto, no te escaparás sin desarrollar tus primeras aplicaciones web. ",
    "url": "/docs/dwes/_site/php/",
    "relUrl": "/php/"
  },"16": {
    "doc": "3.1 Cookies",
    "title": "3.1 Cookies",
    "content": "## 3.1. Cookies {: .no_toc } - TOC {:toc} En esta sección vamos a ver qué son las *cookies* y cómo podemos acceder a ellas para crearlas o manipularlas desde PHP. ### 3.1.1. ¿Qué son las cookies? Las ***cookies*** son pequeños archivos de texto enviados desde el servidor que se almacenan en el lado del cliente. Es decir, en el navegador. Permiten guardar información de forma persistente, de manera que se mantenga entre una petición al servidor y otra. Una *cookie* puede estar viva durante minutos, horas, días o incluso indefinidamente. Desde PHP, se pueden usar las *cookies* usando la función ***setcookie()*** y el array global ***$_COOKIE***. Vamos a ver cómo. ### 3.1.2. Manejando cookies con PHP #### Enviar una cookie: setcookie() Esta función define una *cookie* que se enviará al cliente junto con el resto de las cabeceras de HTTP. Devuelve *true* si la cookie se envía con éxito o *false* en caso contrario. Su sintaxis es: ```php bool setcookie ( string $name [, string $value [, int $expire = 0 [, string $path [, string $domain [, bool $secure = false [, bool $httponly = false ]]]]]] ) ``` Las *cookies* deben enviarse **antes de que el programa genere ninguna salida**. Esto no es un capricho de PHP, sino una restricción del protocolo http. Por lo tanto, debes llamar a esta función antes de hacer *cualquier* salida, incluidos espacios en blanco. En caso contrario, la *cookie* no estará disponible hasta que la página se recargue. La función *setcookie()* admite un montón de parámetros, la mayor parte de ellos optativos: * **name**: El nombre de la *cookie*. Este es el único obligatorio. * **value**: El valor de la *cookie*. * **expire**: El tiempo que la *cookie* tardará en expirar. Se trata de una fecha expresada en [formato Unix](https://es.wikipedia.org/wiki/Tiempo_Unix). * **path**: La ruta del servidor para la que la *cookie* estará disponible. Si se utiliza '/', la *cookie* estará disponible en la totalidad del dominio. * **domain**: El dominio para el cual la *cookie* está disponible. * **secure**: Si la *cookie* solo debería enviarse en caso de conexión https, pon este argument a *true*. * **httponly**: Esta *cookie* solo será accesible a través de http. Es decir, no podrá accederse a la *cookie* desde Javascript. Aquí tienes tres ejemplos de envío de la misma cookie: ```php ``` #### Recuperar una cookie: $_COOKIES[] Para ver el contenido de una *cookie*, simplemente hay que acceder al array global *$_COOKIES*. Por ejemplo: ```php ``` #### Borrar una cookie Para forzar el borrado de una cookie en el cliente basta con enviarla con una fecha de expiración anterior a la fecha actual. Por ejemplo: ```php ``` ",
    "url": "/docs/dwes/_site/cookies-sesiones-seguridad/cookies.html",
    "relUrl": "/cookies-sesiones-seguridad/cookies.html"
  },"17": {
    "doc": "3.2 Sesiones",
    "title": "3.2 Sesiones",
    "content": "## 3.2. Sesiones {: .no_toc } - TOC {:toc} En esta sección vamos a aprenderlo todo (bueno, o casi todo) sobre las variables de sesión en PHP. ### 3.2.1. ¿Qué es eso de las variables de sesión? Las **sesiones** de PHP son un mecanismo para que un script almacene variables (llamadas **variables de sesión**) en el servidor de manera persistente, de modo que posteriores ejecuciones de programas en el servidor solicitadas desde el mismo cliente pueden acceder a esas variables. Es decir: en la práctica, **las variables de sesión se comportan como si fueran variables globales a toda la aplicación web**. Seguro que te habían dicho que usar variables globales es una mala idea y una pésima práctica de programación. Eso es cierto y, al mismo tiempo, usarlas resulta inevitable. *Bienvenido/a al extravagante mundo de las aplicaciones web*. Por ese motivo, debe reducirse el uso de las variables de sesión a lo estrictamente imprescindible. ¿Qué cosas resulta útil guardar en variables de sesión? Cosas como el ID o el nombre de un usuario logueado en un sistema o el estado de la aplicación. Poco más. Cosas pequeñas pero tremendamente importantes. Cada cliente tiene su propio espacio de variables de sesión en el servidor, de manera que no se mezclan unas con otras, ni un cliente puede acceder a las variables de otro cliente. La forma en la que PHP logra distinguir a los clientes entre sí es enviándoles, de forma transparente, una *cookie* con un valor aleatorio distinto para cada cliente. \"De forma transparente\" significa que ni el programador ni el usuario se enteran de que esa *cookie* existe: PHP se encarga de hacerlo por su cuenta. En el archivo *php.ini* se puede configurar la manera en la que PHP almacenará las variables de sesión (en memoria, en un fichero, etc), pero esto es irrelevante de cara a su funcionamiento y compete más al administrador del sistema que al programador. Lo que a nosotros nos interesa es aprender a crear variables de sesión, asignarles valor y recuperarlo posteriormente. ### 3.2.2. Abrir sesiones: session_start() Antes de acceder a cualquier variable de sesión (ya sea para crearla, para modificarla o para eliminarla) necesitamos indicarle a PHP que queremos usar variables de sesión en ese programa. La función ***session_start()*** se usa para eso: habilita el acceso a las variables de sesión, es decir, crea una nueva sesión o reanuda una sesión preexistente. Las sesiones admiten un nombre, por si necesitas crear sesiones separadas para el mismo cliente. No obstante, la mayor parte de las veces te bastará con crear sesiones sin nombre, sin necesidad de pasar ningún argumento a *session_start()*. ### 3.2.3. Usar variables de sesión: $_SESSION Las variables de sesión se manipulan a través del array superglobal ***$_SESSION***. Si necesitas una variable de sesión llamada, por ejemplo, *nombre_usuario*, simplemente haz esto: ```php session_start(); $_SESSION['nombre_usuario'] = \"valor-de-la-variable\"; ``` Por supuesto, el valor de esa posición del array $_SESSION puede consultarse o modificarse cuando lo necesitemos, porque se trata de un array como otro cualquiera... salvo que es *superglobal*, es decir, es accesible desde cualquier punto del programa. ### 3.2.4. Eliminar variables de sesión: unset() y session_destroy() La función **unset()** se utiliza para destruir cualquier variable, incluidas las de sesión: ```php unset($_SESSION['nombre_usuario']); ``` Si lo que deseas es destruir *todas* las variables de sesión, es preferible recurrir a ***session_destroy()***. Ahora bien, session_destroy() destruye la información asociada a la sesión actual, pero no elimina realmente las variables de la memoria del servidor ni borra la *cookie* de sesión del cliente. Si eres un fanático de la seguridad y quieres asegurarte de destruir todas las variables de sesión, puedes usar la función ***session_unset()***. Y, para borrar la cookie de sesión, debes usar ***setcookie()***, como en este ejemplo: ```php ``` ",
    "url": "/docs/dwes/_site/cookies-sesiones-seguridad/sesiones.html",
    "relUrl": "/cookies-sesiones-seguridad/sesiones.html"
  },"18": {
    "doc": "3.3. Sesiones, cookies y control de acceso",
    "title": "3.3. Sesiones, cookies y control de acceso",
    "content": "## 3.3. Control de acceso a las aplicaciones web {: .no_toc } *Cookies* y variables de sesión se usan a menudo, por separado o de forma combinada, para controlar el acceso a una aplicación web. Es decir, para hacer el *login*. En este punto conviene que te hagas esta pregunta: ¿qué significa \"loguearse\" en una aplicación? Piénsalo un momento. ¿Qué significa eso *realmente*? Por supuesto, implica superar un formulario donde se nos pregunta nuestro nombre de usuario (o nuestro email, o alguna otra identificación) y una contraseña. Pero, si lo superamos, ¿qué sucede entonces? **Autenticarse o \"loguearse\" en una aplicación significa que esa aplicación *cambia de estado* y pasa a reconocernos como usuarios registrados**. *Algo* tiene que cambiar dentro de la aplicación, porque a partir de ese momento, y solo para nosotros, se comportará de un modo distinto. Ese \"algo\" implica que la aplicación recordará quiénes somos nosotros y cuales son nuestros privilegios en la aplicación hasta que cerremos la sesión. Y sobre nosotros puede recordar muchas cosas: el nombre, los apellidos, nuestra foto de perfil... Pero, sobre todas esas cosas, hay una fundamental: nuestro ID de usuario. Todos los usuarios registrados tienen un ID en todos los sistemas. A la aplicación le basta con conocer nuestro ID para recordar quiénes somos. ¿Y cómo \"recuerda\" una aplicación web un dato como ese? Muy fácil: almacenándolo en una *cookie* o en una variable de sesión, que son persistentes hasta que el programa decide destruirlas. Es decir, cuando el usuario abandona la aplicación, el programa debe destruir la *cookie* o destruir la sesión. Justo en este momento hay una cosa que tiene que quedarte muy clara: **¡ninguno de estos métodos es completamente seguro!**. Las *cookies* pueden rastrearse o modificarse en el ordenador del cliente. Además, algunos clientes las tienen desactivadas. ¡No te puedes fiar de ellas! Las variables de sesión, en principio más seguras, pueden ser atacadas capturando el ID de sesión, como veremos más adelante. El método más seguro, y el más complicado de programar, es el que combina: * Cookies y/o variables de sesión. * Variables guardadas en una tabla de la BD. El uso de *frameworks* solventes (como Laravel, que estudiaremos más adelante) hace innecesario tomarse este trabajo, puesto que todos habilitan un mecanismo de sesiones seguras que mejora notablemente las prestaciones de las sesiones nativas de PHP. No obstante, en las actividades resueltas y propuestas del final del tema plantearemos una solución para la autenticación de usuarios desarrollada por nosotros mismos y que resultará razonablemente segura. ",
    "url": "/docs/dwes/_site/cookies-sesiones-seguridad/control-de-acceso.html",
    "relUrl": "/cookies-sesiones-seguridad/control-de-acceso.html"
  },"19": {
    "doc": "3.4 Técnicas de ataque frecuentes",
    "title": "3.4 Técnicas de ataque frecuentes",
    "content": "## 3.4. Técnicas de ataque frecuentes {: .no_toc } - TOC {:toc} Cualquier aplicación web, por el mero hecho de estar abierta a recibir información procedente de la red, es susceptible de ser atacada. Y te aseguro que, antes o después, cualquier aplicación que esté *online* acaba por ser atacada. Es una certeza matemática. En esta sección vamos a describir qué tipos de ataque son los más frecuentes. Aunque proporcionaremos algunas estrategias de defensa (que debes tener en cuenta en tus desarrollos), hay una idea común a todas: lo más seguro es utilizar un *framework* como Laravel, Symfony o Zend, debidamente actualizado. Los mecanismos de seguridad que implementan estos frameworks son suficientes para la mayor parte de los casos y se mejoran cada vez que se descubre una vulnerabilidad. Aún así, conviene que conozcas con qué tipos de ataque te vas a encontrar y cuales son las formas de defenderse de ellos. (Esta sección está adaptada de [securitybydefault.com](securitybydefault.com)) ### 3.4.1. Captura de ID de sesión Como ya hemos visto, el ID de una sesión se guarda como una *cookie* (llamada generalmente *phpsessid*) en el cliente para distinguir a ese cliente de otros a la hora de acceder a las variables de sesión. Por lo tanto, viaja en el paquete http desde el servidor hasta el cliente. Un atacante que esté escuchando en esa red puede **leer la cookie con el ID de sesión del paquete http** y, de ese modo, **suplantar la identidad** de la persona que inició la sesión. También puede inyectar Javascript a su víctima para capturar de ese modo el ID de sesión, con idénticos resultados. Por último, si el atacante consigue tener acceso, aunque sea por unos minutos, al ordenador de su víctima, puede robar el ID de sesión (que en el cliente siempre se almacena como texto plano) y suplantarlo con toda comodidad. Soluciones: * Combinar las variables de sesión con *cookies* o con entradas en la base de datos. * Cambiar el ID de sesión periódicamente. * No confiar en variables de sesión de PHP para almacenar información muy sensible. * Denegar el acceso a la *cookie* de sesión desde Javascript (usando el atributo *httponly*). * Acceder solo a webs que usen https, no http. De ese modo, la cookie de sesión viaja encriptada hasta el navegador. Este es uno de los muchos motivos por los que https se ha impuesto definitivamente a lo largo y ancho de la web. ### 3.4.2. Inyección de SQL Este ataque consiste en que **un usuario malintencionado ejecuta sentencias SQL contra la base de datos** del sitio web mediante el simple procedimiento de insertarlas en un formulario. ¿Qué cómo narices se hace eso? Te lo explico con un ejemplo. Imagina que nuestro atacante ha hecho la suposición de que nuestra tabla de usuarios se llama *users* (una suposición muy razonable). Entonces, el tío, o la tía, llega al formulario de login de la aplicación, donde se nos pide el *nick* y la contraseña, y escribe esto en el campo *nick*: ![Ataque por inyección SQL](/docs/dwes/_site/assets/images/03-formulario-inyeccion-sql.png) Cuando pulse el botón *\"Sign in\"* ocurrirá algo muy curioso... y muy desagradable. Dentro de nuestro código fuente, seguramente tendremos una línea parecida a esta: $sql = \"SELECT * FROM users WHERE nick = '$nick' and passwd = '$pass'\"; Fíjate otra vez en lo que el atacante ha escrito en el campo *nick* del formulario de login. Eso significa que la variable *$nick* tendrá este contenido: ```nada'; DELETE * FROM users; #```. Imagina lo que va a suceder cuando esa variable se expanda dentro de la sentencia SQL anterior. ¿Te lo has imaginado ya? Por si acaso aún no lo has pillado, te lo chivo. Lo que sucederá es que, al expandir la variable *$nick* en ese string, la variable *$sql* pasará a tener este valor: SELECT * FROM users WHERE nick ='nada'; DELETE * FROM users; #'and passwd = '$pass' (He puesto en negrita el contenido de la variable *$nick* expandido dentro del string *$sql*) Es decir, que el atacante ha logrado convertir un inofensivo *SELECT* en una secuencia de dos instrucciones. Y una de ellas no es nada inofensiva. En efecto, cuando pidamos a la base de datos que ejecute ese SQL, las sentencias se ejecutarán en orden. El primer SELECT no devolverá ningún resultado, pero es sintácticamente correcto y, en cualquier caso, al atacante no le interesan esos resultados. Como el SELECT es sintácticamente correcto, la base de datos no se detendrá ahí, sino que seguirá ejecutando las sentencias. Y le llegará el turno al DELETE. ¡Bingo! El simpático atacante acaba de cepillarse nuestra tabla de usuarios. (Lo que haya a continuación del símbolo # se ignorará, porque ese es el símbolo de comentario en SQL). El atacante no solo puede ejecutar un DELETE mediante este sencillo procedimiento, sino que puede llevar a cabo otras acciones destructivas (¿qué tal un DROP DATABASE?) o instrusivas (puede intentar insertar un usuario administrador fraudulento en la tabla *users*, por ejemplo). Y todo ello partiendo de una suposición bastante plausible: que la tabla de usuarios se llama *users*. Para blindarse frente a inyecciones de SQL, se recomienda: * **Filtrar los datos procedentes de los formularios. SIEMPRE**. Por ejemplo, si los nombres de usuario sólo pueden estar compuestos por letras y números, no se deben permitir caracteres como comillas, puntos y coma, asteriscos, almohadillas, etc. * **Escapar los caracteres especiales** de cualquier dato de entrada antes de enviarlo al gestor de bases de datos. Por ejemplo, *mysql_real_escape_string()* coloca barras invertidas antes de ciertos caracteres. *addslashes()* hace algo parecido. Esto hace que ya no se ejecuten como sentencias SQL. En las versiones recientes de PHP, el escape de caracteres especiales se hace automáticamente con cualquier dato que llegue por GET o POST. * **Usar nombres poco habituales para las tablas** de la base de datos. Una estrategia frecuente es utilizar un identificador significativo (como *users* para la tabla de usuarios) y añadirle varios caracteres o números aleatorios (así, la tabla se convertiría en algo como *users_58283*). Ese sufijo aleatorio se suele almacenar en un archivo de configuración para que esté accesible para todos los scripts del programa. Esta técnica tan simple dificulta enormemente cualquier intento de acceso fraudulento a las tablas. ### 3.4.3. XSS (cross site scripting) El ataque por XSS consiste en **ejecutar código de scripting malicioso** (básicamente, Javascript) en el contexto del sitio web. Hay muchas formas de hacer XSS. Por ejemplo, imagínate que tenemos un blog de noticias y que un usuario malicioso publica, *como parte del texto de una entrada*, este string: ```javascript ``` ¿Qué ocurriría? Pues que cada vez que alguien visite nuestro portal y cargue esa noticia, será redirigido a *otrositio.com*, donde probablemente pretenderán venderle medicamentos para la disfunción eréctil o algo por el estilo. Otra cosa que suele hacerse con XSS es robar datos de las *cookies* del cliente, aprovechando que Javascript puede acceder a las *cookies*. Para ello, el atacante solo tiene que inyectar un código como este: ```javascript ``` Para evitar los ataques XSS, la estrategia más útil, otra vez, es **filtrar todos los datos externos**. El filtrado de datos es sencillo de hacer y te ahorrará mogollón de problemas. En resumen: **nunca** te fíes de ningún dato que provenga de un formulario si no lo has filtrado antes y le has quitado todos los caracteres sospechosos. ### 3.4.4. CSRF o XSRF (cross site request forgery) Este tipo de ataques **explota la confianza que tiene un sitio web en la identidad de un usuario**. Es decir, se toma a un usuario válido registrado en un sitio (por ejemplo, sitio-confiable.com) y, desde otro sitio (por ejemplo, sitio-maligno.com), se le fuerza a hacer algo chungo en sitio-confiable.com. Veámoslo con un ejemplo. Supón que eres un usuario administrador en sitio-confiable.com. Para borrar a un usuario de tu web (o cualquier otro recurso), lanzas una URL como https://sitio-confiable.com/usuario/delete/28 (donde 28 es el id del usuario). Este tipo de URLs son muy habituales en las aplicaciones web. Pues bien, imagina que has abierto una sesión como administrador en sitio-confiable.com y, sin cerrarla, navegas por otra web llamada sitio-maligno.com. Y un atacante supermalvado, conocedor de tu propensión a navegar por sitios chungos sin cerrar la sesión en sitio-confiable.com, ha colocado este código como parte del código fuente de sitio-maligno.com: ```html ``` Cuando tu navegador cargue esa página, lanzará una petición GET a sitio-confiable.com, resultando en la eliminación del usuario 28 sin que tú te enteres de cómo ha podido suceder semejante desgracia. Esto es solo un ejemplo. Por supuesto, el atacante puede hacer un montón de cosas desagradables en sitio-confiable.com, porque ese sitio está confiando en ti, que eres un usuario legítimo con una sesión abierta. Puedes pensar: ¿y quién demonios se va a dejar una sesión abierta y se va a poner a navegar por otros sitios sin cerrarla? Respuesta: *todo* el mundo. Si tú no lo has hecho nunca, aunque solo haya sido una vez, probablemente no perteneces a la especie humana. Algunas técnicas para dificultar el ataque por CSRF: * **Utilizar POST en lugar de GET** para recibir datos. * **Generar tokens únicos para cada petición**. Un tóken es una cadena alfanumérica aleatoria generada por el servidor cuando sirve el código HTML de un formulario. El cliente debe enviar de vuelta ese tóken junto con los datos del formulario para que el servidor acepte la petición como válida. Si un atacante intenta efectuar un ataque CSRF, enviará sus peticiones sin el tóken y serán rechazadas. ### 3.4.5. DT (directory transversal) Este ataque se produce cuando el atacante logra **acceder a ficheros del servidor que están fuera del directorio de la aplicación** y que, teóricamente, no deberían ser accesibles desde esta. Es fácil comprender cómo puede montarse un ataque así. Imagina un programa PHP que haga un *include()* de este estilo: ```php include (\"views/\" . $viewName); ``` Si un atacante logra manipular la variable *$viewName* para asignarle, por ejemplo, el valor \"../../../../otro-fichero.php\", nuestro programa hará un include de un fichero que está claramente fuera de los directorios de la aplicación. Para evitar este tipo de ataques, algunas estrategias son: * **Tener un array de páginas y carpetas válidas**. Si un include trata de acceder a un recurso que no está en la lista, se sospechará de un ataque. * **Buscar caracteres sospechosos en los nombres de los archivos**. Si la variable *$viewName* del ejemplo anterior incluye los caracteres \"../\", la cosa se pone fea. No en vano, el ataque Directory Transversal también se denomina \"ataque punto punto barra\". ### 3.4.6. RFI (remote file inclusion) Este ataque se produce cuando **se incluye un archivo remoto** explotando una vulnerabilidad del código fuente. Imagina, como antes, un programa PHP que haga un *include()* tan común como este: ```php include ($viewName); ``` Imagina también que este código se invoque normalmente mediante una petición del estilo: https://sitio-confiable.com?view=main.php. O algo parecido. Es una estrategia habitual en muchas aplicaciones web. Pues bien, un atacante podría pedir la siguiente URL: https://sitio-confiable.com?view=https://sitio-malicioso/soy-un-script-malvado.php Es decir, ha colocado como *$viewName* la URL de un programa PHP externo a nuestro servidor, y nuestro programa hará un *include()* de ese código tan feliz y contento, sin saber que se trata de código malicioso que acabará directamente en las tripas de nuestro programa. Una vez que *soy-un-script-malvado.php* se esté ejecutando en el servidor *sitio-confiable.com*, puede hacer cosas terribles, como, por ejemplo, esta: ```php ``` (No te digo lo que hace ese comando por si se te ocurre probarlo, pero ya te adelanto que no es agradable). Para prevenir los ataques por RFI, algunas estrategias válidas son: * **No confiar en los datos** que no provengan de nuestro sistema. * **Validar y filtrar los datos** que introduce el usuario (sí, otra vez: validar, validar y validar cualquier cosa que provenga del usuario). ",
    "url": "/docs/dwes/_site/cookies-sesiones-seguridad/tecnicas-de-ataque-frecuentes.html",
    "relUrl": "/cookies-sesiones-seguridad/tecnicas-de-ataque-frecuentes.html"
  },"20": {
    "doc": "3.5 Autenticación mediante ACL",
    "title": "3.5 Autenticación mediante ACL",
    "content": "## 3.5. Autenticación mediante ACL {: .no_toc } - TOC {:toc} En esta sección, vamos a poner en práctica muchas de las cosas que hemos visto en este tema mediante un caso práctico realista y completamente resuelto. Completamente resuelto pero mejorable, porque una aplicación informática *siempre* se puede mejorar. De hecho, en la sección de \"Ejercicios propuestos\" afrontaremos varias mejoras que tendrás que intentar tú en forma de ejercicios propuestos. ¿O pensabas que iba a hacer yo todo el trabajo? ### 3.5.1. Qué es la autenticación mediante ACL Casi todas las aplicaciones web incluyen un subsistema de autenticación de usuarios. El más completo de esos subsistemas es el de las **lisas de control de acceso** (ACL = Access Control List). Ese subsistema suele estar basado en este diseño de base de datos: ![Tablas ACL](/docs/dwes/_site/assets/images/03-acl.jpg) Esto significa que necesitamos **cinco tablas** para implementar un ACL completo. Sin embargo, muchas veces tendremos suficiente con solo tres tablas (users, roles y roles-users), o incluso solo con una (users, añadiendo quizá un campo \"type\"). **Optar por una solución más o menos compleja dependerá del tipos de sistema que estemos implementando.** En cualquier caso, es conveniente que conozcas el esquema ACL completo (es decir, el de 5 tablas) para que lo pongas en práctica cuando lo necesites. Por eso te lo he presentado. Ahora ya sois oficialmente amigos. ### 3.5.2. Una implementación de autenticación mediante ACL Como ocurre con muchos conceptos en el ámbito de la programación, las ACL se entienden mejor viéndolas que explicándolas. Así que vamos a hacer una implementación de ejemplo, que de paso nos servirá para mostrar en acción muchas de las cosas que hemos visto en este tema. Ojo, que esta es solo *una de las posibles implementaciones*. Pueden existir mil variaciones. Pero, como sucedía con los ejemplos que hemos visto anteriormente, te servirá como base para tu propia implementación de una ACL. **IMPORTANTE**: en esta implementación verás una distribución de archivos un poco peculiar y que, a primera vista, puede resultarte hasta caprichosa. No te agobies. Hemos respetado una arquitectura de aplicaciones denominada ***modelo-vista-controlador*** o ***MVC***. Hablaremos largo y tendido sobre esa arquitectura más adelante, y entonces comprenderás que la distribución del código no tenía nada de caprichosa. Por ahora, solo tienes que seguir la pista a lo que sucede, y ni siquiera es necesario que lo entiendas al 100%. Un 80% ya estaría genial. Un 50% sería suficiente. Tu comprensión de este código aumentará cuando tengas que utilizarlo y adaptarlo a tus propios proyectos. #### Nuestras tablas ACL Vamos a suponer que esta autenticación con ACL se está implementando para un sistema de publicación de noticias (un blog, un periódico digital o algo semejante). Solo por darle un poco de contexto. Realmente, cambiando los permisos, podría utilizarse casi para cualquier web. Haremos una implementación completa del ACL, es decir, con las cinco tablas. Esas cinco tablas tendrán el siguiente aspecto (te muestro algunos datos de ejemplo para que quede más claro de lo que estamos hablando): **TABLA users** id|email|passwd|name|telef|etc (otros campos) -|-|-|-|- 1|pepe@iescelia.org|1234|Pepe Pérez|555 230 111|etc 2|ana@iescelia.org|1234|Ana López|555 398 234|etc Etc|Etc|Etc|Etc|Etc|Etc **TABLA roles** id|description -|- 1|Admin 2|Editor 3|User **TABLA roles-users** idUser|idRol -|- 1|1 2|2 2|3 etc|etc **TABLA permissions** id|description|action -|- 1|Crear contenido nuevo|createContentForm 2|Editar contenido propio|editMyContentForm 3|Editar contenido ajeno|editAnyContentForm 4|Borrar contenido propio|deleteMyContentForm 5|Borrar contenido ajeno|deleteAnyContentForm 6|Publicar contenido propio|publishMyContentForm 7|Publicar contenido ajeno|publishAnyContentForm 8|Leer contenido publicado|readContent **TABLA permissions-roles** idRol|idPermission -|- 1|1 1|2 1|3 1|4 1|5 1|6 1|7 1|8 2|1 2|2 2|6 2|8 3|8 Observa que, con estas tablas, queda perfectamente definido a qué perfil de usuario (o \"rol\") pertenece cada usuario y qué cosas puede hacer con ese perfil. Por ejemplo, el usuario Pepe Pérez, que tiene el Id = 1, es un Administrador, porque tiene asociado el rol 1 en la tabla *roles-users*. Y los administradores tienen permiso para hacerlo absolutamente todo, según se desprende de la tabla *permissions-roles*. En cambio, la usuaria Ana López (Id = 2) tiene perfil de Editor, y los editores solo tienen permiso para cuatro operaciones: Crear contenido nuevo, Editar su propio contenido, Publicar su propio contenido y Leer el contenido publicado. #### Código fuente de nuestra implementación En esta implementación, no escribiremos el código para hacer cosas como \"Crear contenido nuevo\" o \"Publicar contenido\". Eso dependerá del sistema concreto que estemos programando, y no es lo que nos interesa ahora. Lo que nos interesa es ver cómo se autentica un usuario en una aplicación web y cómo se le puede dar acceso a unas funcionalidades o a otras dependiendo del contenido de las tablas ACL. Una vez autenticado, el usuario accederá a una vista diferente de la aplicación dependiendo de sus privilegios, donde se le mostrarán las opciones de que dispone. Es decir, si el usuario que se loguea es Pepe Pérez, que tiene rol de Administrador, la aplicación debe mostrarle estas opciones: * Editar contenido (propio y ajeno) * Borrar contenido (propio y ajeno) * Publicar contenido (propio y ajeno) * Leer contenido * Crear contenido En cambio, si se loguea Ana López, que tiene dos perfiles, la aplicación le dará a elegir cuál quiere usar. Si elige el perfil de Editor, las opciones deben reducirse a: * Editar contenido (propio) * Publicar contenido (propio) * Leer contenido * Crear contenido Cada una de estas opciones redirigirá la aplicación de regreso a *index.php*, con un valor diferente para la variable *action* que se pasará por la URL. Ese valor se saca de la tabla *permissions*. **Insisto en una idea muy importante**: no es necesario que comprendas la totalidad de este código en este momento. Basta con que te esfuerces en captar la idea general. Volverás sobre él, y sobre infinitas variedades de él, más adelante, cada vez con mayor comprensión de lo que está sucediendo. Así que léelo sin prisa y sin agobios, como quien se adentra en la traducción de un texto escrito en una lengua que se parece un poco a la suya sin llegar a serlo. Una última advertencia: esta solución presenta algunos problemas de seguridad (como no filtrar las variables procedentes de un formulario) que resolveremos en los ejercicios propuestos más adelante. **Archivo index.php** Este archivo captura la variable *action* desde la URL. Esta variable, como ya vimos en el ejemplo de la Biblioteca, indica a la aplicación qué es lo que debe hacer. Luego se instancia un objeto de tipo *Controller* y se invoca un método con el mismo nombre que la *action*. ```php $action(); ``` **CONTROLADOR (archivo controller.php)** En el controlador están reflejadas todas las posibles acciones que puede realizar la aplicación. Es decir, tiene que haber un método por cada posible valor de la variable *action*. ```php view = new View(); // Vistas $this->user = new User(); // Modelo de usuarios } /** * Muestra el formulario de login */ public function showLoginForm() { $this->view->show(\"loginForm\"); } /** * Procesa el formulario de login y, si es correcto, inicia la sesión con el id del usuario. * Redirige a la vista de selección de rol. */ public function processLoginForm() { // Validación del formulario if ($_REQUEST['email'] == \"\" || $_REQUEST['pass'] == \"\") { // Algún campo del formulario viene vacío: volvemos a mostrar el login $data['errorMsg'] = \"El email y la contraseña son obligatorios\"; $this->view->show(\"loginForm\", $data); } else { // Hemos pasado la validación del formulario: vamos a procesarlo $userData = $this->user->checkLogin($_REQUEST['email'], $_REQUEST['pass']); if ($userData!=null) { // Login correcto: creamos la sesión y pedimos al usuario que elija su rol $_SESSION['idUser'] = $userData->id; $this->SelectUserRolForm(); } else { $data['errorMsg'] = \"Usuario o contraseña incorrectos\"; $this->view->show(\"loginForm\", $data); } } } /** * Muestra formulario de selección de rol de usuario */ public function selectUserRolForm() { $data['roles'] = $this->user->getUserRoles($_SESSION['idUser']); $this->view->show(\"selectUserRolForm\", $data); // Posible mejora: si el usuario solo tiene un rol, la aplicación podría seleccionarlo automáticamnte // y saltar a $this->showMainMenu() } /** * Procesa el formulario de selección de rol de usuario y crea una variable de sesión para almacenarlo. * Redirige al menú principal. */ public function processSelectUserRolForm() { $_SESSION['userRol'] = $_REQUEST['idRol']; $this->showMainMenu(); } /** * Muestra el menú de opciones del usuario según la tabla de persmisos */ public function showMainMenu() { $data['permissions'] = $this->user->getUserPermissions($_SESSION['userRol']); $this->view->show(\"mainMenu\", $data); } } ``` **VISTA (view.php)** Este archivo contiene un método genérico (dentro de la clase View) para mostrar cualquier otra vista, cuyo nombre se le pasa como parámetro desde el controlador. ```php \" . $data['errorMsg'] . \" . \"; } if (isset($data['infoMsg'])) { echo \"\" . $data['infoMsg'] . \" . \"; } echo \" Email: Contraseña: \"; ``` **VISTA selectUserRolForm (archivo views/selectUserRolForm.php)** Esta vista muestra la lista de roles de un usuario. Sirve por si un usuario tiene asignado más de un rol. Así, antes de terminar el login, podrá elegir con qué rol quiere ingresar en la aplicación. ```php \"; echo \"\"; echo \"\"; foreach ($data['roles'] as $rol) { echo \"id.\"'>\".$rol->description.\"\"; } echo \"\"; echo \"\"; echo \"Enviar\"; echo \"\"; ``` **VISTA mainMenu (archivo views/mainMenu.php)** Esta vista muestra las opciones del programa asociadas a un usuario concreto. Cada opción es un enlace a la propia aplicacion con un valor diferente para la variable *action*. ```php \"; foreach ($data['permissions'] as $permission) { echo \"action . \"'>\" . $permission->description . \"\"; } ``` **MODELO (archivo user.php)** El modelo contiene todos los métodos necesarios para acceder a la base de datos (o, en general, a cualquier recurso del servidor). Esos métodos siempre se invocan desde el controlador. En este caso, llamamos *user.php* al modelo porque accederá únicamente a la tabla de usuarios. ```php db */ public function __construct() { $this->db = new mysqli(\"servidor\", \"usuario\", \"contraseña\", \"base-de-datos\"); } /** * Comprueba si un email y una password pertenecen a algún usuario de la base de datos. * @param String $email El email del usuario que se quiere comprobar * @param String $pass La contraseña del usuario que se quiere comprobar * @return User $usuario Si el usuario existe, devuelve un objeto con todos los campos del usuario en su interior. Si no, devuelve un objeto null */ public function checkLogin($email, $pass) { if ($result = $this->db->query(\"SELECT id FROM users WHERE email = '$email' AND password = '$pass'\")) { if ($result->num_rows == 1) { $usuario = $result->fetch_object(); return $usuario; } else { return null; } } else { return null; } } /** * Busca en la base de datos la lista de roles de un usuario * @param integer $idUser El id del usuario * @return array $resultArray Un array con todos los roles del usuario, o null si el usuario no existe o no tiene roles asignados */ public function getUserRoles($idUser) { $resultArray = array(); if ($result = $this->db->query(\"SELECT roles.* FROM roles INNER JOIN `roles-users` ON roles.id = `roles-users`.idRol WHERE `roles-users`.idUser = '$idUser'\")) { if ($result->num_rows > 0) { while ($rol = $result->fetch_object()) { $resultArray[] = $rol; } return $resultArray; } else { return null; } } else { return null; } } /** * Busca en la base de datos los permisos asociados a un rol * @param integer $idRol El id del rol * @return array $resultArray Un array con la lista de permisos asociados al rol, o null si el rol no existe o no tiene permisos asociados */ public function getUserPermissions($idRol) { $resultArray = array(); if ($result = $this->db->query(\"SELECT permissions.* FROM permissions INNER JOIN `permissions-roles` ON permissions.id = `permissions-roles`.idPermission WHERE `permissions-roles`.idRol = '$idRol'\")) { if ($result->num_rows > 0) { while ($permission = $result->fetch_object()) { $resultArray[] = $permission; } return $resultArray; } else { return null; } } else { return null; } } } ?> ``` ",
    "url": "/docs/dwes/_site/cookies-sesiones-seguridad/autenticacion-mediante-acl.html",
    "relUrl": "/cookies-sesiones-seguridad/autenticacion-mediante-acl.html"
  },"21": {
    "doc": "3.6 Ejercicios propuestos",
    "title": "3.6 Ejercicios propuestos",
    "content": "## 3.6. Ejercicios propuestos {: .no_toc } - TOC {:toc} Vamos a enfilar el final de este tema con una batería de ejercicios propuestos, que consistirán en una serie de mejoras sobre nuestra implementación de las listas de control de acceso. Ten en cuenta que lo que hagas aquí se puede reutilizar en posteriores proyectos de aplicaciones web, así que vamos a tomárnoslo en serio, ¿te parece? Como vamos a trabajar con la implementación anterior, tal vez te apetezca ponerla a funcionar en tu servidor local. El código fuente lo puedes copiar de este mismo documento. Para que no tengas que construir la base de datos a mano, puedes usar [este archivo SQL](/docs/dwes/_site/assets/code/03-acl.sql) para importarla en tu servidor local. #### Ejercicio 1. Crear la capa de seguridad Si te fijas en el código fuente, hemos accedido en varios puntos al array superglobal *$_SESSION*. Más arriba dijimos que las variables de sesión de PHP no son completamente seguras. Confiar nuestro mecanismo de autenticación a esas variables es como jugar a la ruleta rusa. ¿Y si queremos cambiarlo? Por ejemplo, por *cookies*. Vale, las *cookies* tampoco son muy seguras, pero la pregunta sigue siendo la misma: ¿y si queremos cambiar la forma en la que se almacena el ID del usuario logueado tras la autenticación? La única manera es *revisar TOOOODO el código fuente* y cambiar las referencias a *$_SESSION* por *$_COOKIE* (o el mecanismo que hayamos elegido para sustituir a las variables de sesión). Y, si pretendemos mejorar la seguridad de la aplicación, no solo sustituirla, lo mismo: ponte a revisar todo tu código una y otra vez. Por eso suele construirse una **capa de seguridad**. Que es lo que te propongo hacer ahora. La capa de seguridad no es más que una clase (podemos llamarla *Seguridad* o *Security*) guardada en un archivo aparte que contendrá una colección de métodos para gestionar la seguridad de la aplicación. Así, cada vez que queramos cambiar algo en la forma se protege de los ataques, solo tendremos que acudir a esa clase y tocar aquí o allí, como en una intervención quirúrjica muy localizada. Así que, en este ejercicio, te pido crear una clase *Seguridad* (o *Security*) que contenga, para empezar, estos métodos: * **openSession()**: para abrir una sesión de usuario cuando alguien se loguee correctamente. Este método seguirá usando una variable de sesión de PHP (ya lo cambiaremos después). Por ahora, solo queremos centralizar en esta clase el manejo de sesiones y seguridad. * **getUserId()**: devuelve el ID del usuario logueado (si existe). * **getUserRoles()**: devuelve un array con los roles del usuario logueado (si existe) * **getUserPermissions()**: devuelve un array con los permisos del usuario logueado (si existe) Cuando tengas hecha esa clase, sustituye cualquier referencia a $_SESSION en el código fuente de nuestro caso práctico (ver sección anterior) por llamadas a métodos de esta clase, hasta que el programa funcione exactamente igual que antes, pero con la clase Seguridad integrada en él. #### Ejercicio 2. Filtrar los datos de entrada Añade un nuevo método en la clase *Seguridad* que puedes llamar ***filter()***. Este método recibirá un *string* y lo devolverá filtrado, es decir, limpio de cualquier carácter o palabra sospechosa. Puedes empezar por eliminar los caracteres especiales como \"\", \"#\" o \"$\", señal de que alguien puede estar intentando inyectar Javascript, SQL o tratando de atacar mediante CSRF. Con eso ya irás bastante seguro. Luego busca todos los puntos de la aplicación donde se accede a las variables de la URL sin filtro (es decir, los puntos donde se usa $_REQUEST, $_GET o $_POST) y llama al método *filter()* antes de acceder a esas variables. Más adelante, puedes mejorar la función de filtrado localizando palabras como \"script\", \"location.href\" o similares. Lo bueno de esta solución es que no tendrás que tocar el resto del programa: al tener la función de filtrado encapsulada en la clase *Seguridad*, cualquier mejora posterior afectará a toda la aplicación sin modificar el código externo a esta clase. #### Ejercicio 3. Cerrar la sesión y destruir las variables Es algo que no hemos hecho hasta ahora, ¿verdad? La clase *Seguridad* debe tener un método para destruir las variables de sesión y cerrar la sesión de un usuario autenticado. Lo podemos llamar ***closeSession()***. Habrá que añadir una opción \"Cerrar sesión\" en el menú principal de la aplicación que enlace con una entrada del controlador que, a su vez, invoque este método de la clase *Seguridad*. #### Ejercicio 4. Añadir cookies para controlar la sesión Hemos dicho a lo largo del texto que manejar las sesiones de usuario solo con las variables de sesión de PHP es arriesgado, puesto que un atacante podría suplantar la sesión con relativa facilidad capturando la *cookie* \"phpsessid\". Para proporcionar a este mecanismo un extra de protección, se pueden crear *cookies* adicionales que nos den una pista en caso de que se produzca un ataque. Estas *cookies* se manipulan desde la clase *Seguridad* de forma transparente al resto del programa. Es decir, el resto de clases ni se enteran de que la seguridad de la aplicación se está incrementando. ¡Es la magia de la programación orientada a objetos! Las *cookies* que vamos a crear en este punto son: * idUsuario: Guardaremos el id del usuario logueado en una *cookie* además de en una variable de sesión. Cada vez que la clase *Seguridad* vaya a comprobar algo (los permisos del usuario, por ejemplo), se asegurará de que la *cookie* y la variable de sesión contienen exactamente el mismo valor. Cualquier discrepancia provocará un cierre de la sesión inmediato. * idRol: Haremos lo mismo con el rol del usuario. * myToken: Será una *cookie* con un valor aleatorio que guardaremos en el cliente, al mismo tiempo que crearemos una variable de sesión donde se guardará el mismo valor. Si un atacante suplanta el id de sesión de PHP, probablemente no suplantará este token. En cada operación de la clase *Seguridad* comprobaremos que los dos tokens coinciden y, si no es así, cerraremos la sesión. #### Ejercicio 5. Añadir una tabla para controlar la sesión El mecanismo extra de seguridad que hemos implementado en el apartado anterior no es suficiente. Un atacante avispado se percatará antes o después de que hay por ahí pululando una *cookie* adicional (nuestro token), y terminará suplantándolo. Para subir un escalón en nuestra protección frente a ataques, necesitamos crear una tabla en la base de datos que tenga más o menos esta estructura: ```sql CREATE TABLE IF NOT EXISTS `MySessions` ( `id` varchar(40) NOT NULL, `ipAddress` varchar(45) NOT NULL, `idUser` INTEGER NOT NULL, `idRol` INTEGER NOT NULL, `token` varchar(200) NOT NULL, `timestamp` int(10) unsigned DEFAULT 0 NOT NULL, PRIMARY KEY (id) ); ``` Cuando un usuario de autentique en la aplicación, crearemos sus variables de sesión y sus *cookies* como hasta ahora y, además, insertaremos un registro en la tabla *MySessions* con toda la información de la sesión, a la que añadiremos: * La IP desde la que el cliente se ha conectado. Curiosea en internet para averiguar cómo se puede obtener este dato. * La fecha y hora exacta de esa conexión (a eso se le denomina *timestamp* o marca de tiempo). En cualquier operación posterior, la clase *Seguridad* realizará todas las comprobaciones que ya realizaba hasta ahora y, además, lanzará una consulta a la base de datos para recuperar, mediante el valor del token, el ID del usuario y su rol. Si el token no existe en la base de datos, mal asunto: cerramos la sesión. Y si hay cualquier discrepancia entre los valores de la base de datos, de las variables de sesión y de las cookies, mal asunto también: cerramos la sesión. La seguridad puede continuar mejorándose indefinidamente. Por ejemplo: si detectamos un posible ataque procedente de una dirección IP, podemos pasarla a una tabla de \"direcciones baneadas\" e impedir cualquier intento de conexión en el futuro desde esa dirección. #### Ejercicio 6. Limitar el acceso al controlador (y completar la aplicación) Todo esto está muy bien (aunque te hace volverte un poco paranoico, ¿verdad?), pero, por muchas mejoras en la seguridad que estemos introduciendo, cualquier atacante, incluso sin pasar por el login, puede escribir esto en su navegador y meterse hasta la cocina en nuestra aplicación: ``` https://mi-servidor/index.php?action=showMainMenu ``` Sustituye \"showMainMenu\" por cualquier otra cosa (¿qué tal \"deleteUser\"?) y tienes un problema de los gordos. Para programar una aplicación web segura necesitamos **proteger los métodos del controlador**, de manera que solo pueda ejecutarlos un usuario autenticado y con los privilegios adecuados. Fíjate en que cada usuario tendrá acceso a diferentes métodos del controlador, dependiendo de su rol. Por ejemplo, a un método como *showMainMenu()* podrá acceder cualquier usuario logueado, pero un método como *deleteUser()* debe estar más limitado y solo los administradores deberían poder ejecutarlo. Así que tienes que añadir una barrera de entrada en cada método del controlador, en forma de un par de líneas de código que comprueben: a) Que hay un usuario correctamente autenticado. b) Que ese usuario tiene privilegios suficientes para ejecutar este método. Las dos comprobaciones se hacen invocando métodos de la clase *Seguridad*. Te dejo a ti pensar cómo se implementa esto exactamente (en realidad, hay varios modos). Si cualquiera de las dos comprobaciones falla, el usuario verá una pantalla de \"Acceso prohibido\" o algo por el estilo. #### Ejercicio 7. Actualizar periódicamente el ID de sesión Una técnica de defensa frecuente es modificar el ID de sesión periódicamente (cada pocos minutos, o bien cada vez que se recibe una petición del cliente). Implementa esta opción en tu aplicación. Te advierto que es lo más complicado que has hecho hasta ahora. Puedes considerar que este es un ejercicio de nivel avanzado. #### Ejercicio 8. Aplicar a un caso realista Por último, vamos a aplicar todas estas mejoras en la seguridad a una aplicación web más completa. Para ello, utiliza el código fuente de tu Videoclub (la aplicación que programamos en el tema anterior). Si no dispones de ese código, puedes usar el de la Biblioteca. Lo encontrarás en un capítulo anterior de este mismo texto. No es que sea una aplicación muy completa, pero si te servirá para comprobar que la capa de seguridad es muy eficaz contra los ataques más habituales. Añade la clase *Seguridad* al código fuente de tu aplicación y sustituye la apertura de la sesión por llamadas a los métodos de la clase *Seguridad*. Por último, protege todos los accesos al controlador para asegurarte de que solo los usuarios con los privilegios adecuados puede ejecutar ese código. Y una última advertencia: por mucho que protejas una aplicación web, puedes encontrarte con atacantes que burlen tus medidas de seguridad. La única solución para eso es disponer siempre de un *backup* de tu código y tu base de datos para restaurarlo todo en caso de catástrofe, así que no dejes de hacer copias con frecuencia (o contrata un proveedor de *hosting* que las haga por ti). ",
    "url": "/docs/dwes/_site/cookies-sesiones-seguridad/ejercicios-propuestos.html",
    "relUrl": "/cookies-sesiones-seguridad/ejercicios-propuestos.html"
  },"22": {
    "doc": "3.7 Ejercicios resueltos",
    "title": "3.7 Ejercicios resueltos",
    "content": "## 3.7. Ejercicios resueltos {: .no_toc } - TOC {:toc} Aquí puedes descargar el código fuente de la aplicación con listas de control de acceso (ACL) que hemos trabajado en clase. Incluye una capa de seguridad muy sencilla (hecha con variables de sesión de PHP) y una capa de abstracción de datos. * [Descargar el código fuente](/docs/dwes/_site/assets/code/03-acl.zip) * [Descargar la base de datos (con algunos datos de prueba)](/docs/dwes/_site/assets/code/03-acl.sql) Todas las modificaciones que vayamos haciendo en clase se subirán de nuevo a estos archivos para que siempre dispongas de las versiones más actualizadas del código. ",
    "url": "/docs/dwes/_site/cookies-sesiones-seguridad/ejercicios-resueltos.html",
    "relUrl": "/cookies-sesiones-seguridad/ejercicios-resueltos.html"
  },"23": {
    "doc": "3 Cookies, sesiones y seguridad",
    "title": "3 Cookies, sesiones y seguridad",
    "content": "# 3. Cookies, sesiones y seguridad {:toc} En este capítulo vamos a profundizar en varios aspectos de PHP de vital importancia para las aplicaciones web. Por un lado, tenemos las ***cookies*** y las **sesiones**, dos mecanismos que permiten a la aplicación mantener vivas algunas variables de forma indefinida. Después estudiaremos un problema endémico a las aplicaciones web: la **seguridad**. En efecto, al tratarse de aplicaciones que, por definición, están permanentemente conectadas a la red, son susceptibles de recibir ataques de manera continua e indiscriminada. Y, de hecho, lo hacen. Veremos cuáles son los tipos de ataque más frecuente y cómo podemos proteger nuestra aplicación contra ellos, algo en lo que juegan un papel importante las *cookies* y las variables de sesión. Por último, nos centraremos en algo muy relacionado con la seguridad: la autenticación de usuarios para acceder a la aplicación. La mayor parte de las aplicaciones web necesitan un mecanismo seguro de autenticación. Veremos en qué consisten las **listas de control de acceso** y plantearemos una implementación muy completa en la que pondremos en práctica todo lo que hemos aprendido hasta ahora e incluso iremos un paso más allá al introducir la arquitectura MVC, que veremos en el siguiente tema. ",
    "url": "/docs/dwes/_site/cookies-sesiones-seguridad/",
    "relUrl": "/cookies-sesiones-seguridad/"
  },"24": {
    "doc": "4 Arquitectura MVC",
    "title": "Listado de Artículos",
    "content": "| Fecha | Titulo | . fetch_array()) { echo \"\"; echo \" | \".$row['fecha'].\" | \"; echo \" | \".$row['titulo'].\" | \"; echo \" . \"; } echo \"\"; // Cerramos la conexión con la BD $db->close(); ?> ``` Esta solución se denomina **monolítica**, porque incluye todo el código necesario en el mismo bloque. Por supuesto, para un ejemplo tan simple como este, el código monolítico es más que suficiente, pero en un sistema más complejo pronto empieza a convertirse en un monstruo inmanejable. #### Primera mejora: controlador + vista Vamos a aproximarnos un poco a la solución MVC **separando ese código monolítico en dos bloques** (que guardaremos en archivos distintos): * **Un controlador** (archivo *index.php*). * **Una vista** (archivo *showAllArticles.php*). Primero, el **controlador**. Se encargará de recuperar los datos, pero *no de mostrarlos*. Generar el interfaz de usuario, es decir, el HTML, será la labor que le dejaremos a la vista. El controlador preparará esos datos y los empaquetará en un array para que estén disponibles en la vista. Y la vista la insertaremos en el controlador con un *include()*. ```php query('SELECT fecha, titulo FROM articulo'); // Convertimos la lista de artículos, que es un cursor de MySQL, en un array estándar de PHP $articles = array(); while ($row = $res->fetch_array()) { $articles[] = $row; } $db->close(); // Incluimos el código de la vista, donde se usará el array de artículos // para generar la tabla HTML. include('showAllArticles.php'); ?> ``` La **vista** que mostrará los datos del array contiene un código muy semejante al de la solución monolítica, solo que ahora estará ubicada en un archivo aparte (*showAllArticles.php*) y hará un bucle sobre el array de resultados que le ha preparado el controlador: ```php ",
    "url": "/docs/dwes/_site/mvc/",
    "relUrl": "/mvc/"
  },"25": {
    "doc": "4 Arquitectura MVC",
    "title": "Listado de Articulos",
    "content": "| Fecha | Titulo | . | \".$article['fecha'].\" | \".$article['titulo'].\" | . \"; } ?> ``` #### Segunda mejora: modelo, vista y controlador En esta segunda mejora, **dividiremos el código en tres bloques** (ubicados, de nuevo, en archivos diferentes): * **Un modelo** para los artíclos (archivo *articles.php*). Contendrá una clase con un método que se encargará de acceder a la base de datos y empaquetar el resultado de la consulta en un array. * **Una vista** (archivo *showAllArticles.php*). Se encargará de generar el HTML con el resultado de la consulta. * **Un controlador** (archivo *index.php*). Se encargará de invocar al modelo y a la vista en el orden correcto. Por lo tanto, el **controlador** (*index.php*), al extraer de él todo lo que tenga que ver con la base de datos, se queda en algo tan sencillo como esto: ```php include('articles.php'); // En este archivo estará el modelo $articulos = Model::getAll(); // Este método del modelo nos devuelve la lista de artículos include('showAllArticles.php'); // En este archivo estará la vista ``` El **modelo** (*articles.php*) consta de una clase con solo un método (de momento) encargado de consultar todos los artículos y devolverlos empaquetados en un array: ```php query('SELECT fecha, titulo FROM articulo'); $articles = array(); while ($row = $res->fetch_array()) { $articles[] = $row; } $db->close(); return $articles; } } ?> ``` Por último, la **vista** (*showAllArticles.php*) será exactamente igual que en la versión anterior: un recorrido por el array de artículos para mostrarlos en formato HTML: ```php ",
    "url": "/docs/dwes/_site/mvc/",
    "relUrl": "/mvc/"
  },"26": {
    "doc": "4 Arquitectura MVC",
    "title": "Listado de Articulos",
    "content": "| Fecha | Titulo | . | \".$article['fecha'].\" | \".$article['titulo'].\" | . \"; } ?> ``` #### Tercera mejora: añadiendo capa de abstracción de datos Como no sabemos lo que es el miedo, vamos a complicar nuestro patrón modelo-vista-controlador con una **cuarta capa**: la **capa de abstracción de datos**. La idea de esta capa adicional es proporcionar un mecanismo de abstracción respecto del gestor de base de datos concreto que estemos utilizando. Vaya frasecita, ¿eh? *\"Un mecanismo de abstracción respecto del gestor de base de datos\"*. Si no has bizqueado un poco al leerlo, es que tienes los nervios de acero. ¿Qué narices significa eso? Es solo una de esas expresiones de que los informáticos usamos para fardar, como cuando un médico te dice que estás acatarrado, pero te lo dice en latín para que parezca más complicado de lo que es. Te explico qué es eso del *\"mecanismo de abstracción bla, bla, bla\"*. Si te fijas en el **modelo** de la solución anterior, verás que estamos usando una clase (*mysqli*) y unos métodos que solo funcionan con MySQL o MariaDB. Si quiséramos cambiar el gestor de base de datos (algo relativamente frecuente), tendríamos que revisar *todos* nuestros modelos, y tal vez modificar y volver a probar miles de líneas de código. Una forma de independizar nuestra aplicación del gestor de base de datos que haya debajo es programar lo que se llama **capa de abstracción** que contenga dos o tres métodos genéricos (como *consultar()* para lanzar SELECT o *manipular()* para lanzar INSERT, UPDATE o DELETE). De ese modo, cuando queramos hacer una consulta desde el modelo, no lo haremos con los métodos de MySQL (como *query()*, *fetch_array()* y similares), sino con los nuestros (*consultar()*, *manipular()*, o como los hayamos querido llamar). Si algún día necesitamos cambiar el gestor de base de datos, solo tendremos que reescribir el código de esa capa de abstracción, es decir, un par de decenas de líneas de código frente a varios miles que teníamos que revisar y probar antes. Por lo tanto, en esta tercera mejora vamos a dividir el código en cuatro bloques: * **Un controlador** (archivo *index.php*). * **Una vista** (archivo *view.php*). * **Un modelo en dos capas**: * **Capa de abstracción de datos** (*db.php*) * **Capa de acceso a datos** (el modelo de artículos propiamente dicho) (*articles.php*). El código de la **capa de abstracción** sería algo así: ```php class Db { private $db; // Aquí guardaremos la conexión con la base de datos /** * Abre la conexión con la base de datos * @param $server URL del servidor de la base de datos * @param $username Nombre de usuario en ese servidor * @param $pass Contraseña * @param $dbname Nombre de la base de datos * @return 0 si la conexión se realiza con normalidad y -1 en caso de error */ function createConnection($server, $username, $pass, $dbname) { $db = new mysqli($servidor, $usuario, $clave, $dbname); if ($db->connect_errno) return -1; else return 0; } /** * Cierra la conexión con la base de datos */ function closeConnection() { if ($this->db) $this->db->close(); } /** * Lanza una consulta (SELECT) contra la base de datos. * ¡Ojo! Este método solo funcionará con sentencias SELECT. * @param $sql El código de la consulta que se quiere lanzar * @return Un array bidimensional con los resultados de la consulta (estará vacío si la consulta no devolvió nada) */ function dataQuery($sql) { $res = $this->db->query($sql); $resArray = array(); if ($res) { $resArray = $res->fetch_all(); } return $resArray; } /** * Lanza una sentencia de manipulación de datos contra la base de datos. * ¡Ojo! Este método solo funcionará con sentencias INSERT, UPDATE, DELETE y similares. * @param $sql El código de la consulta que se quiere lanzar * @return El número de filas insertadas, modificadas o borradas por la sentencia SQL (0 si no produjo ningún efecto). */ function dataManipulation($sql) { $this->db->query($sql); return $this->db->affected_rows; } } ``` El código del **modelo** va a hacer uso de la capa de abstracción en lugar de usar los métodos de la clase *mysqli* directamente: ```php include \"Db.php\"; class Articles { public function getAll() { $db = new Db(); // Creamos un objeto para usar nuestra capa de abstracción // Conectamos con la BD a través de nuestra capa de abstracción $db->createConnection('mi-host', 'mi-usuario', 'mi-clave', 'mi-base-de-datos'); // Lanzamos la consulta a través de nuestra capa de abstracción. // Nos devolverá directamente un array estándar de PHP. $articles = $db->dataQuery('SELECT fecha, titulo FROM articulo'); // Cerramos la conexión con la BD $db->closeConnection(); return $articles; } } ``` El **controlador** y la **vista** son exactamente los mismos que en la solución anterior, así que no vamos a escribir el código de nuevo. Esto es lógico: solo hemos modificado la forma en la que trabaja el modelo, pero gracias al encapsulamiento de los objetos, el resto de la aplicación no se ha enterado de ello. #### Cuarta (y última) mejora: transformación en clases y objetos reutilizables. Código fuente definitivo Para terminar, vamos a dejar el **código bien organizado** y a mostrarlo completo. Lo que haremos en esta última etapa es **empaquetarlo todo en clases reutilizables**. Observa que sigue siendo el mismo código fuente, solo que empaquetado en clases y métodos. Lo único que queda fuera de una clase es la instanciación inicial del objeto controlador. Fíjate bien en cómo hemos convertido las vistas en una clase con un método *show()* que nos servirá para mostrar cualquier vista y reutilizar el mismo *header* y el mismo *footer*. Cada vista se programará en un archivo independiente que deberemos organizar en directorios y subdirectorios. De momento, nuestra aplicación solo tiene una vista llamada *showAllArticles*, pero se podrían visualizar todas las necesarias usando el método *show()*. Otra cosa que quiero que observes con mucha atención es **el punto de entrada a la aplicación** (archivo ***index.php***), porque lo hemos dejado preparado para poder añadir nuevas funciones al programa con posterioridad, así como varios controladores. El método que se ejecutará dependerá no solo de la **variable *\"action\"*** que se pasa por GET, sino también de otra variable llamada ***\"controller\"***, que también se pasa por GET, y que contendrá el nombre de la clase del controlador. Así, para invocar, por ejemplo, el método *showAll()* del controlador *ArticlesController*, la ruta debería ser esta: http://mi-servidor/index.php?controller=ArticlesController&action=showAll Este *index.php* es tan genérico que **te servirá para montar cualquier aplicación MVC en el futuro**. Si repasas el código del ejemplo resuelto de tema anterior (el de la autenticación mediante ACL), verás que ya se parecía mucho a este esquema, aunque en aquel *index.php* siempre utilizábamos el mismo controlador. **Punto de entrada a la aplicación** (*index.php*) ```php $action(); ?> ``` **Controlador de artículos** (articlesController.php) ```php // Controlador. Debería tener un método por cada posible valor de la variable \"action\". include (\"view.php\"); include (\"articles.php\"); class ArticlesController { public function showAll() { $data['articles'] = Articles::getAll(); View::show(\"showAllArticles\", $data); } // Añadir a partir de aquí un método por cada posible valor de la variable \"action\" } ``` **Clase vista** (view.php) ```php ``` **Vista showAllArticles** (showAllArticles.php) ```html ",
    "url": "/docs/dwes/_site/mvc/",
    "relUrl": "/mvc/"
  },"27": {
    "doc": "4 Arquitectura MVC",
    "title": "Listado de Articulos",
    "content": "| Fecha | Titulo | . | \".$articles['fecha'].\" | \".$articles['titulo'].\" | . \"; } ?> ``` **Modelo - Capa de acceso a datos** (articles.php) ```php include \"db.php\"; class Articles { public function getAll() { $db = new Db(); $db->createConnection('mi-host', 'mi-usuario', 'mi-clave', 'mi-base-de-datos'); $articles = $db->dataQuery('SELECT fecha, titulo FROM articulo'); $db->closeConnection(); return $articles; } } ``` **Modelo - Capa de abstracción de datos** (db.php) ```php class Db { private $db; // Aquí guardaremos la conexión con la base de datos /** * Abre la conexión con la base de datos * @param $server URL del servidor de la base de datos * @param $username Nombre de usuario en ese servidor * @param $pass Contraseña * @param $dbname Nombre de la base de datos * @return 0 si la conexión se realiza con normalidad y -1 en caso de error */ function createConnection($server, $username, $pass, $dbname) { $db = new mysqli($servidor, $usuario, $clave, $dbname); if ($db->connect_errno) return -1; else return 0; } /** * Cierra la conexión con la base de datos */ function closeConnection() { if ($this->db) $this->db->close(); } /** * Lanza una consulta (SELECT) contra la base de datos. * ¡Ojo! Este método solo funcionará con sentencias SELECT. * @param $sql El código de la consulta que se quiere lanzar * @return Un array bidimensional con los resultados de la consulta (estará vacío si la consulta no devolvió nada) */ function dataQuery($sql) { $res = $this->db->query($sql); $resArray = array(); if ($res) { $resArray = $res->fetch_all(); } return $resArray; } /** * Lanza una sentencia de manipulación de datos contra la base de datos. * ¡Ojo! Este método solo funcionará con sentencias INSERT, UPDATE, DELETE y similares. * @param $sql El código de la consulta que se quiere lanzar * @return El número de filas insertadas, modificadas o borradas por la sentencia SQL (0 si no produjo ningún efecto). */ function dataManipulation($sql) { $this->db->query($sql); return $this->db->affected_rows; } } ``` ## 4.4. El patrón MVC en la teoría Ahora que hemos aprendido a manejarnos con el patrón MVC por medio de un ejemplo, estamos en condiciones de definirlo de manera más teórica. E incluso entender esa definición, no te vayas a creer. El patrón MVC consiste, pues, en dividir la aplicación en tres capas: * **Los modelos**, donde se programa la *lógica de negocio*. De esa forma tan rimbombante se refiere la literatura técnica al acceso a los datos con los filtros, algoritmos y restricciones que el sistema imponga. Dicho en palabras más sencillas, esto significa que en los modelos debemos colocar todo el código de acceso a la base de datos o a cualquier otro recurso del servidor (como las variables de sesión, por ejemplo). Los modelos deben empaquetar esos datos en objetos estándar de PHP (como arrays) y devolverlos al controlador. Lo más práctico es **crear un modelo para cada tabla maestra** de la base de datos. Los *frameworks* automatizan los métodos más típicos de cada modelo, como insertar un registro, borrar, actualizar, consultar uno o consultar todos. Ya veremos de qué formas tan alucinantes se las ingenian para hacer todo esto con un mínimo de esfuerzo por nuestra parte y, por supuesto, sin escribir el mismo código una y otra vez. * **Las vistas**, donde se programan todas las salidas HTML que el usuario final va a ver y con las que va a interactuar. El código Javascript y CSS, por lo tanto, forma parte de las vistas. En las vistas estará el grueso del código de cualquier aplicación. Los *frameworks* más avanzados incluyen sistemas de **plantillas** para reutilizar fragmentos de vistas, así como lenguajes adicionales para simplificar la codificación de las vistas. Pero, si programamos en PHP clásico, tendremos que construir las vistas manualmente. * **Los controladores**, donde se captura cada petición del usuario y se dirige el flujo de ejecución, invocando a los modelos y a las vistas en el orden adecuado. En una aplicación pequeña, bastará con tener un controlador para todo. Cuando la aplicación crece, suele hacerse **un controlador por cada modelo**, es decir, un controlador por cada tabla maestra. Los controladores estarán compuestos por una colección de métodos, uno para cada funcionalidad de la aplicación. El método que se ejecute en cada ocasión estará controlado por la URL. En concreto, por la variable *\"action\"* que se pasará por GET, aunque, por supuesto, puedes ponerle otro nombre si *\"action\"* no te gusta. En los *frameworks*, esta variable \"action\" se transforma en una URL limpia que, a través de un objeto adicional llamado **enrutador**, termina provocando la invocación del método adecuado. Es decir: en una aplicación MVC como las que hemos visto hasta ahora, tendremos una ruta como esta para, por ejemplo, consultar el artículo con id 37: https://mi-servidor/index.php?action=showArticle&idArticle=37 En cambio, en un *framework* avanzado, la ruta tendrá un aspecto más limpio para hacer lo mismo. Algo así como: https://mi-servidor/articles/show/37 Y el enrutador se encargará trocear esa URL y extraer de ella la información para instanciar el controlador adecuado y llamar al método correcto. # 4.5. Ejercicios propuestos Para terminar, como siempre, vamos a proponer algunos casos prácticos para que pongas manos a la obra. Se trata de crear, paso a paso, una aplicación web de corte realista que puede ser muy útil en un lugar como un instituto, una empresa, una oficina o cualquier otra organización medianamente compleja. Un problema que se presenta a menudo en estas organizaciones es la necesidad de compartir ciertos recursos, como proyectores, ordenadores portátiles, salas de conferencias o de exposiciones, etc. En nuestro instituto, por ejemplo, tenemos unas hojas impresas colgadas con una chincheta en un tablón de anuncios para que el profesorado reserve los carritos con portátiles o las aulas de informática, de modo que dos personas no traten de usar a la vez el mismo recurso. Es un método un poco primitivo (aunque eficaz, todo hay que decirlo) que se puede informatizar fácilmente mediante una aplicación web. Y eso es lo que proponemos aquí. Se trata de **escribir una aplicación para reservar recursos** de una organización. Los recursos pueden ser de cualquier tipo (ordenadores, proyectores, espacios físicos, etc.). Los usuarios, que tendrán que estar registrados, podrán reservar cada recurso durante tramos horarios predefinidos. Las tablas de la aplicación, por lo tanto, serán estas: * Resources(id#, name, description, location, image) -> Los recursos que se pueden reservar * Users(id#, username, password, realname) -> Los usuarios registrados * TimeSlots(id#, dayOfWeek, startTime, endTime) -> Los tramos temporales en lo que se pueden hacer reservas * Reservations(idResource#, idUser#, idTimeSlot#, date, remarks) -> Las reservas (remarks = comentarios) La aplicación, una vez rellenadas con datos las tablas maestras *Resources*, *Users* y *TimeSlots*, permitirá a los usuarios registrados reservar recursos. Antes tendrán que autenticarse (es decir, pasar por un login). Para hacer una reserva, un usuario tiene que seleccionar un recurso, una fecha y un tramo horario. Si el recurso ya está reservado, no se podrá reservar por segunda vez, obviamente. Para conseguir implementar la aplicación completa, vamos a hacerlo por pasos, de modo incremental. ¡Que cada persona llegue hasta donde buenamente pueda! **Paso 1. Mantenimiento de la tabla Resources** En este paso, debes crear todos los elementos necesarios para hacer el manenimiento completo de la tabla de recursos. Es decir: listado, inserción, borrado y modificación de recursos. Hazlo exactamente en ese orden, porque he escrito las operaciones en orden de dificultad en su implementación. Para hacerlo, necesitarás: * El punto de entrada a la aplicación (index.php) * El controlador de recursos (clase ResourcesController) * El modelo de recursos (clase Resources) * La capa de abstracción (clase Db) * La clase vista (View) * Una colección de vistas sencillas. Al menos dos: una para mostrar el listado de recursos y otra para el formulario de inserción y modificación (se puede reutilizar el mismo formulario para las dos cosas). Fíjate en que puedes reutilizar gran parte del código fuente que hemos mostrado como ejemplo de MVC más arriba, con unas pocas adaptaciones. Lo ideal es hacer que, desde la vista *showAllResources*, se pueda acceder al resto de funcionalidades relacionadas con los recursos. Es decir, esa vista quedaría algo así: ``` MANTENIMIENTO DE RECURSOS Recurso Ubicación Acciones Impresora Láser Brother Aula 8 Modificar | Eliminar Carrito de portátiles A Lab. Biología Modificar | Eliminar Proyector portátil Dirección Modificar | Eliminar etc. Añadir nuevo ``` Los textos \"Modificar\", \"Eliminar\" y \"Añadir nuevo\" deben ser *links* que nos conduzcan de regreso a la aplicación para realizar esas acciones con los recursos. **Paso 2. Mantenimiento de la tabla TimeSlots** El mantenimiento de esta tabla es muy similar al de la anterior. Necesitarás un controlador nuevo y un modelo nuevo, con métodos muy parecidos a los que ya has implementado para *Resources*. **Paso 3. Mantenimiento de la tabla Users** Más de lo mismo. Reutiliza y adapta todo lo que puedas. Este tercer mantenimiento de tabla te debería salir con mucha más facilidad y rapidez que los dos anteriores. **Paso 4. Menú principal** Hasta ahora, tenemos un puñado de métodos en uno o varios controladores que se invocan pasando variables de control por la URL (algo como http://mi-servidor/index.php?controller=resources&action=showAll). En este punto, vamos a juntarlos todos en un menú principal que contendrá enlaces a todas esas URLs. Cuando añadamos más funcionalidades al programa, solo tendremos que agregarlas al menú principal. Es decir, se trata de construir una vista *\"mainMenu\"* (o con el nombre que más te guste) a la que se acceda después de superar el login y que muestre algo como esto: ``` Bienvenid@, nombre-de-usuario MENÚ DE OPCIONES Mantenimiento de recursos Mantenimiento de tramos horarios Mantenimiento de usuarios Cerrar sesión ``` Los textos \"Mantenimiento de recursos\", \"Mantenimiento de tramos horarios\", etc, deben ser *links* que nos conduzcan de regreso a la aplicación para acceder a las vistas de mantenimiento de esos elementos. **Paso 5. Autenticación** De momento, cualquiera puede entrar a la aplicación y añadir, modificar o eliminar registros de las tablas maestras. Vamos a proteger el acceso al menú principal con un sistema de autenticación (login). Puedes reutilizar el código del tema anterior, cuando hablamos de las listas ACL, pero simplificando aquel código, puesto que aquí solo tenemos una tabla de usuarios registrados (nada de tablas de permisos ni roles). No te olvides de controlar el acceso a los métodos de los controladores para que solo los usuarios debidamente autenticados puedan ejecutarlos. **Paso 6. Reservas** Hacer o eliminar reservas consiste, básicamente, en insertar y eliminar registros de la tabla *TimeSlots*. Sin embargo, no es un mantenimiento como el de las otras tablas, puesto que esta tabla proviene de una relación ternaria entre tres entidades (reservas, slots y usuarios), y no es una tabla maestra como tal. Por eso dejamos este mantenimiento de tabla para el final: porque es el más *raro* y, además, constituye la pieza principal de la aplicación: si esto no está hecho, la aplicación, simplemente, carece de su funcionalidad principal. **Paso 7. Roles de usuario** (Este paso es optativo) Vamos a añadir un campo nuevo a la tabla de usuarios. Lo llamaremos *\"type\"*, y solo podrá contener dos valores: 0 (admin) o 1 (user). Puedes usar un VARCHAR si te sientes más cómodo/a que con códigos numéricos. Si el usuario que entra en la aplicación es de tipo 0 (admin), tendrá acceso al menú principal y a todos los métodos de todos los controlares. Como hasta ahora, vamos. Pero si el usuario que entra en la aplicación es de tipo 1 (user), en el menú principal solo le aparecerán las opciones de acceso a las reservas. Es decir, no podrá añadir, modificar ni eliminar usuarios, slots o recursos. Cosa que es bastante lógica, ¿no te parece? Recuerda revisar el acceso a todos los métodos de todos los controladores para asegurarte de que un usuario de tipo 1 no entre, por ejemplo, al método para borrar recursos, ni siquiera escribiendo manualmente la URL. **Paso 8. Otras mejoras** (Este paso es optativo) A la aplicación se le pueden hacer infinitas mejoras. Aquí te sugiero algunas, pero estaría bien que te sacaras otras de tu propia chistera: * Hacer que las vistas sean visualmente atractivas con CSS y/o Javascript. * Mostrar un calendario en el que se aprecien visualmente las reservas de una semana o de un mes. O, mejor aún, incorporar un selector para poder ver el día actual, la semana actual o el mes actual (ojo, que esto último es bastante complicadillo). * Añadir la posibilidad de crear y anular reservas directamente desde el calendario. Observa que, así, la vista principal del usuario de tipo 1 sería el calendario, mientras que el usuario de tipo 0 seguiría accediendo al viejo menú de principal para hacer el mantenimiento completo de tablas. * Controlar que los usuarios de tipo 1 solo puedan eliminar sus propias reservas, no las de otros usuarios. En cambio, los usuarios de tipo 0 podrán eliminar cualquier reserva. * Eliminar automáticamente las reservas cuya fecha ya haya pasado. **Paso 9. Enrutador** (Este paso es optativo) *Advertencia: ¡este paso puede resultar complicadillo!* ¿Te atreves a crear un enrutador como el de los frameworks avanzados? No es un elemento fundamental para que la aplicación web funcione, sino que tan solo sirve para construir rutas limpias. Recuerda que el enrutador tiene que ser capaz de coger una URL limpia, como esta: https://mi-servidor/user/show/37 ...y deducir de ahí que hay que invocar el método *show(37)* del controlador de usuarios. O bien el método *showUser(37)* si tu aplicación es tan simple que solo tiene un controlador. Debería funcionar con cualquier ruta construida de ese modo y cualquier cantidad de controladores. A ver si se te ocurre algo para incorporar un enrutador como este a la aplicación. (No sé si te has dado cuenta, pero, poco a poco, estamos construyendo nuestro porpio *framework* casero para programar aplicaciones MVC) ",
    "url": "/docs/dwes/_site/mvc/",
    "relUrl": "/mvc/"
  },"28": {
    "doc": "4 Arquitectura MVC",
    "title": "4 Arquitectura MVC",
    "content": "# 4. Arquitectura MVC {: .no_toc } - TOC {:toc} En ingeniería del software, como en cualquier otra ingeniería, existen una serie de soluciones estandarizadas que se ajustan sorprendentemente bien a una enorme variedad de situaciones diferentes. Estas soluciones se denominan **patrones de software**, y vamos a empezar este tema hablando de ellas. Después nos centraremos en los **patrones de arquitectura**, y sobre todo en uno en concreto denominado **MVC o Modelo-Vista-Controlador** que tiene una enorme importancia en el ámbito de las aplicaciones web. Pero, antes de meternos a saco con el patrón MVC, tendremos que darle un par de vueltas al término \"arquitectura\", porque, en el ámbito de las aplicaciones web, se usa con dos significados distintos que conviene que tengas claros para no hacerte un lío. Terminaremos el tema mostrando, como siempre, un ejemplo de código bastante basado en la arquitectura MVC, de modo que puedas usarlo para comprender mejor los conceptos teóricos y como base para tus propios proyectos. ## 4.1. Patrones de software Antes de entrar en la parte más práctica de todo este asunto, es decir, antes de que veamos los patrones de arquitectura y los apliquemos en un ejemplo concreto de aplicación web, tienes que dejarme que te hable de los **patrones de software**. Los patrones de software son *soluciones comprobadas a problemas comunes en el desarrollo de software*. La arquitectura MVC, de hecho, es un patrón, porque se ha probado infinidad de veces y se adapta a la perfección a multitud de problemas diferentes. Para que un patrón pueda considerarse tal cosa, tiene que cumplir estas condiciones: * Debe haber sido comprobado en otros sistemas. * Debe ser fácilmente reutilizable. * Debe ser aplicable a diferentes circunstancias. * Debe estar bien documentado. ### 4.1.1. Tipos de patrones Dependiendo del grado de abstracción del patrón, existen patrones de diverso tipo: * De arquitectura * De diseño * De creación de objetos * De estructura de clases * De comportamiento * De dialectos * De interacción o interfaz de usuario * De análisis * De dominio ### 4.1.2. Ejemplo de patrón: el patrón Singleton Antes de centrarnos en el patrón MVC, vamos a ver, solo a modo de ejemplo, otro tipo de patrón: **el patrón Singleton**, que está considerado un *patrón de diseño*. Algunos recursos en una aplicación son de tal naturaleza que sólo puede existir una instancia de ese tipo de recurso. Por ejemplo, la conexión a la base de datos a través de un manejador de base de datos. A veces interesa compartir un manejador de base de datos para que el resto de recursos no tengan que conectarse y desconectarse continuamente de la BD, y sólo debería existir una instancia de ese manejador. El patrón Singleton cubre esta necesidad. Un objeto es “singleton” si la aplicación puede generar una y sólo una instancia del mismo. Esta es una implementación sencilla y reutilizable de ese patrón. Utiliza un constructor privado para evitar que se creen varias instancias del objeto y un método *static* para obtener la única instancia permitida. Ojo, que solo se trata de un ejemplo. De hecho, ni siquiera está completo, porque en PHP hay varias formas de construir un objeto sin pasar por el constructor. No te lo tomes como algo que tengas que aprenderte de memoria o algo así. Lo interesante de este ejemplo es que veas que existen muchos patrones que pueden (y, de hecho, deben) reutilizarse una y otra vez en el diseño de aplicaciones. ```php class Singleton { private static $instancia; // Referencia a la única instancia de este objeto. Es private // para que nadie pueda usarla desde fuera del objeto // Constructor privado. Nadie podrá crear objetos desde fuera de la clase. private function __construct() { $this->contador = 0; } // Este método comprueba si existe ya una instancia del objeto Singleton. // Si existe, la devuelve. Si no existe, la crea antes de devolverla. public static function getInstance() { if ( self::$instancia instanceof self) { self::$instancia = new self; } return self::$instancia; } } ?> ``` Teniendo una clase como esa, el objeto Singleton puede usarse de este modo: ```php // Las dos variables contendrán, en realidad, el mismo objeto Singleton $single1 = Singleton::getInstance(); $single2 = Singleton::getInstance(); ``` Por supuesto, a la clase Singleton podemos añadirle todos los métodos que necesitemos, como a cualquier clase, sin que pierda su condición de Singleton. ## 4.2. Arquitectura de una aplicación web Ahora que tenemos claro qué es un patrón de software, vamos a centrarnos en los **patrones de arquitectura**. Pero existe un problema cuando hablamos de \"arquitectura de una aplicación\" en el ámbito de las aplicaciones web. El problema es este: usamos el término *\"arquitectura de una aplicación\"* para referirnos a dos cosas distintas: la *arquitectura física* y la *arquitectura lógica*. Vamos a intentar explicar la diferencia. ### 4.2.1. Arquitecturas FÍSICAS multicapa (multitier) Una **arquitectura física de varios niveles** (multinivel o *multitier*, en inglés) consiste en un conjunto de ordenadores conectados a una red que ejecutan de forma conjunta una aplicación. El ejemplo más sencillo es la arquitectura cliente-servidor, la más popular en aplicaciones web sencillas: una máquina cliente y una máquina servidor ejecutan alternativamente fragmentos del código, proporcionando al usuario final la sensación de una aplicación unificada. ![Arquitectura en 2 niveles](/docs/dwes/_site/assets/images/04-arquitectura-2-niveles.png) Por supuesto, nada impide que tengamos más de dos máquinas colaborando en red para ejecutar una aplicación web. Podemos tener, por ejemplo, un cliente, un servidor web y un servidor de bases de datos (estos dos últimos en dos máquinas físicas diferentes). Esto sería una arquitectura de 3 niveles físicos. Esta arquitectura se puede generalizar. Una con N niveles físicos tendría este aspecto: ![Arquitectura en N niveles](/docs/dwes/_site/assets/images/04-arquitectura-N-niveles.png) La arquitectura física es algo que incumbe sobre todo a los administradores de sistemas, que son los encargados de montarla, configurarla y mantenerla. Para el programador, sin embargo, suele resultar transparente. Por ejemplo, cuando nos conectamos a un servidor de bases de datos desde nuestra aplicación, poco importa que ese servidor esté en la misma máquina física o en otra máquina diferente: la forma de conectarse y operar con la base de datos es exactamente la misma. Así que la arquitectura física, siendo importante, no lo es demasiado para nosotros y nosotras como desarrolladores. En cambio, la arquitectura lógica es otra historia... ### 4.2.2. Arquitecturas LÓGICAS multicapa (multilayer) Ahora viene la vuelta de tuerca: la arquitectura de una aplicación también puede referirse a sus capas (*layers* en inglés) lógicas. Es decir, a las capas de software que nosotros, los desarrolladores/as, creamos. **Dividir una aplicación en capas que colaboran entre sí por medio de interfaces bien definidos** no es una idea nueva, ni pertenece exclusivamente al ámbito de la programación web. Pero la mayor parte de las aplicaciones web hacen uso de este mecanismo de abstracción. La idea es fragmentar nuestra aplicación en capas de niveles de abstracción cada vez mayor. En un extremo, la **capa más abstracta** es la que interacciona con el **usuario**: ahí se implementará nuestro interfaz de usuario, o lo que en aplicaciones web se llama *front-end*. En el otro extremo, la **capa menos abstracta** es la que está en contacto con el **hardware** de la máquina. Bueno, en el caso de una aplicación web, no hay contacto directo con el harware, sino con otras capas aún menos abstractas que están fuera de nuestra aplicación, como el sistema operativo, el servidor web o el gestor de bases de datos. Esas capas externas a nuestra aplicación son las que, realmente, interaccionan con el hardware en última instancia. Esta división en capas de abstracción, que puede parecer una complicación innecesaria, tiene un montón de ventajas y por eso se usa en cualquier aplicación un poco más complicada que \"Hola, mundo\". ### 4.2.3. Ventajas de las arquitecturas multicapa Las arquitecturas multicapa permiten varias cosas que no pueden hacerse con los códigos monolíticos. Entre otras: * Desarrollar en paralelo cada capa (mayor rapidez de desarrollo). * Aplicaciones más robustas gracias al encapsulamiento. ¿Te suena? ¡Programación orientada a objetos! Cada capa se implementa en una clase, y cada clase hace su trabajo sin importunar a las demás y sin preocuparse por cómo funcionan las otras internamente. * El matenimiento es más sencillo. * Más flexibilidad para añadir módulos. * Más seguridad, al poder aislar (relativamente) cada capa del resto. * Mejor escalabilidad: es más fácil hacer crecer al sistema. * Mejor rendimiento (aunque esto podría discutirse: puedes hacer un sistema multicapa con un rendimiento desastroso y un sistema monolítico que vaya como un tiro. Pero, en general, es más fácil mejorar el rendimiento trabajando en cada capa por separado). * Es más fácil hacer el control de calidad, incluyendo la fase de pruebas. El único inconveniente reseñable de las arquitecturas multicapa es que pueden hacer que una aplicación muy simple se vuelva artificialmente más compleja de lo necesario. Pero eso solo sucede en aplicaciones muy, pero que muy simples. Para cualquier aplicación convencional, la arquitectura multicapa simplifica el diseño en lugar de complicarlo. En resumen: todo son ventajas. Ya ves por qué todo el mundo hace aplicaciones web con arquitecturas multicapa. ## 4.3. La arquitectura Modelo-Vista-Controlador (MVC) Y por fin llegamos a la palabreja: la arquitectura Modelo-Vista-Controlador o MVC. Cuando hablamos de **arquitectura de una aplicación** nos referimos a la estructura básica que la sustenta, como los pilares de un edificio en construcción. Si quitas las paredes, las ventanas, las puertas, los azulejos de la cocina... todavía pueden distinguirse las formas fundamentales, ¿verdad? Pues bien, el *patrón de arquitectura* más popular en aplicaciones web se llama **MVC o Modelo-Vista-Controlador** y muy pronto se va a convertir para ti en un viejo amigo. ### 4.3.1. ¿Qué es el MVC? El MVC es tan solo **una arquitectura multicapa estandarizada**. Una arquitectura de **3 capas**, para ser exactos. Este es el esquema de una arquitectura en 3 capas. Recuerda lo que hemos visto antes: cada capa ejecuta una parte de la solución, y entre ellas colaboran para formar la aplicación completa. La capa superior interactúa con el usuario; la capa inferior, con la máquina (donde dice \"hardware\", debería decir \"cualquier cosa menos abstracta que nuestro programa\"). Tienes permiso para imaginar cada capa como una clase con sus métodos y atributos. ![Arquitectura en 3 capas](/docs/dwes/_site/assets/images/04-arquitectura-3-capas.png) Pues bien, si a esas tres capas les ponemos nombres exóticos como *modelo*, *vista* y *controlador*, y tuneamos un poco el esquema, ya lo tenemos: **la arquitectura MVC**. ![Arquitectura MVC](/docs/dwes/_site/assets/images/04-arquitectura-mvc.png) Es decir, **la arquitectura MVC solo es un caso particular de la arquitectura en 3 capas**. ¿Y ya está? Bueno, no. Ahora tienes que aprender qué significa *en realidad* esta palabrería. Porque todo esto está muy bien como construcción teórica, pero ¿cómo te afecta a ti a la hora de programar? ¿Qué clases tienes que crear? ¿Qué parte del código hay que poner en cada clase? En la práctica, es más simple de lo que parece. Lo vas a ver enseguida. Y lo maravilloso es que el 99,99% de las aplicaciones web encajan como un guante en esta arquitectura. Es decir, apenas tendremos que hacer trabajo de diseño previo, porque, si es una aplicación web, ya sabemos qué clases tendremos que construir: los que nos indique la arquitectura MVC. Antes de pasar a la parte práctica de todo esto, permíteme un breve apunte: por supuesto, nada impide construir arquitecturas con más de 3 capas. De hecho, nosotros vamos a usar una variante del MVC en el que se añade una capa adicional por debajo del modelo, es decir, una arquitectura con 4 capas. Pero ya llegaremos a eso. ### 4.3.2. MVC en la práctica: una implementación incremental Tras esta introducción al MVC, vamos a estudiar a fondo este patrón. Y lo vamos a hacer por medio de un ejemplo, que es como mejor suelen comprenderse estas cosas. Una vez terminado y comprendido el ejemplo, daremos una definición más teórica. Es decir, que lo vamos hacer al revés de lo habitual: primero la práctica y luego la teoría. Según mi experiencia, la gente suele comprenderlo mejor en ese orden. Pero, para que esto funcione, tienes que **leer el código fuente con atención**. Es un código sencillo y bien comentado, y que se va complicando muy poco a poco, en pasos incrementales, desde un código clásico monolítico hasta una implementación completa de un MVC. Si lo lees con la atención que te pido, verás como, **al acabar, entenderás perfectamente en qué consiste el MVC** y podrás empezar a aplicarlo en tus proyectos. El ejemplo con el que vamos a trabajar es este: supongamos que queremos programar una pequeña aplicación web que nos permita hacer publicaciones en una especie de blog simplificado. Esas publicaciones se guardan como registros en una tabla de una base de datos. En el código de ejemplo sobre el que vamos a trabajar, nos vamos a centrar en una funcionalidad concreta de este mini-blog: el listado de los artículos existentes en la base de datos. #### Código monolítico Una primera aproximación a la solución, **sin usar ningún patrón de arquitectura** en absoluto, podría ser esta (échale un vistazo y asegúrate de entenderlo): ```php query('SELECT fecha, titulo FROM articulo'); ?> // Generamos una tabla HTML con el resultado de la consulta ",
    "url": "/docs/dwes/_site/mvc/",
    "relUrl": "/mvc/"
  },"29": {
    "doc": "5 Laravel",
    "title": "5 Laravel",
    "content": "# 5. Laravel Laravel es un **framework PHP MVC diseñado para agilizar el desarrollo de aplicaciones web**. En ese sentido, hace auténtica magia. En los últimos años ha tenido una gran penetración en la industria. Empezaremos por aprender qué es un framework PHP MVC, qué frameworks existen y en qué circunstancias resulta interesante utilizar una de estas herramientas para desarrollar una aplicación. Dedicaremos el resto del tema a estudiar todas las peculiaridades de Laravel para aprender a desarrollar aplicaciones con este poderoso framework. ",
    "url": "/docs/dwes/_site/laravel/",
    "relUrl": "/laravel/"
  },"30": {
    "doc": "6 Servicios web",
    "title": "6 Servicios web",
    "content": "# 6. Servicios web {: .no_toc } - TOC {:toc} Los **servicios web** son un tipo particular de aplicación web: una aplicación pensada no solo para ser usada por usuarios humanos, sino por otras aplicaciones. Existen dos estándares para crear servicios web. En este tema, vamos a estudiar esos dos estándares y a ver cómo podemos construir una aplicación de este tipo. ## 6.1. ¿Qué es un servicio web? ### 6.1.1. Una definición de servicio web Un **servicio web** es una aplicación web capaz de **comunicarse e intercambiar información con otra aplicación** (que denominaremos *cliente*) independientemente de la plataforma en la que cada una se ejecute. Es decir, el servicio web puede estar programado en PHP y correr bajo un sistema operativo GNU/Linux y el cliente puede estar programado con C# y correr bajo un Windows, y deberían ser capaces de comunicarse y trabajar juntas. Pero es importante que quede claro que, en este caso, la aplicación web (servidor) y la aplicación cliente *son dos aplicaciones diferentes*. Los mensajes que las aplicaciones se intercambian generalmente tienen formato **XML** o **JSON**. Existen dos estándares principales en la industria para implementar servicios web, denominados **SOAP** y **REST**. A lo largo el tema, vamos a aprender cómo funciona cada uno de ellos. ### 6.1.2. Diferencias entre servicios web y aplicaciones web Llegados a este punto, puede que estés pensando: \"Vale, pero ¿en qué se diferencia todo esto de una aplicación web MVC? ¿No intercambian también el cliente y el servidor información independientemente de la plataforma en la que se ejecuta cada uno?\". Pues sí, pero hay algunas **diferencias fundamentales entre un *servicio web* y una *aplicación web***: * Una aplicación web está diseñada para que un ser humano interactúe con ella a través de un interfaz DHTML. Un servicio web, en cambio, está pensado para que lo use otra aplicación informática (el cliente), no necesariamente un ser humano. * Por ese motivo, los servicios web suelen carecer de interfaz de usuario y no producen salidas HTML legibles. Es decir, un servicio web puro **no suele tener vistas**. * En cambio, los servicios web suelen producir salidas XML o JSON, pensadas para que los clientes las procesen. Una aplicación web, en cambio, solo responde con XML o JSON cuando recibe una petición Ajax, algo que veremos en el tema siguiente. Por lo demás, un servicio web puede tener una arquitectura *aproximadamente* MVC, y digo *aproximadamente* porque el servicio web, como acabo de contarte, carece de vistas. Pero puede seguir conservando sus controladores y sus modelos. Los controladores se encargarán de convertir los datos de los modelos a JSON o XML y devolverlos al cliente. ## 6.2. SOAP **SOAP (Single Object Access Protocol)** es un mecanismo estandarizado para la implementación, descripción y publicación de servicios en red. SOAP establece el modo en el que deben comportarse el cliente y el servidor para hablar entre sí, así como la forma en la que el servidor debe dar a conocer sus servicios. ### 6.2.1. La pila de protocolos de SOAP El estándar **SOAP** define una serie de protocolos de niveles de abstracción crecientes. Esta colección de protocolos suele denominarse **pila de protocolos SOAP**, y son los siguientes: Nivel de abstracción|Protocolo -|- Nivel de descubrimiento|UDDI -|- Nivel de publicación|UDDI -|- Nivel de descripción|WSDL -|- Nivel de mensajería|SOAP -|- Nivel de red|TCP, SMTP, FTP, etc Como ves, SOAP solo es uno de los protocolos de la pila, aunque todo el tinglado recibe el nombre \"SOAP\" por extensión. Vamos a explicar brevemente en qué consiste cada protocolo de la pila, y lo vamos a hacer, como en otras ocasiones, por medio de unos ejemplos en lugar de perdernos en largas y farragosas explicaciones. ### 6.2.2. Los protocolos SOAP y WSDL Para entender cómo funciona el **protocolo SOAP** (el más importante de la pila, como ya te habrás imaginado por su nombre) y, en menor medida, el **protocolo WSDL**, vamos a implementar tres ejemplos de servicios web muy sencillos: * En el primero veremos cómo construir un servidor que devuelva colecciones de datos en forma de array. * En el segundo veremos cómo puede un servidor devolver datos con estructura más compleja formateados con JSON. * En el tercero montaremos un pequeño servidor con WSDL. #### Ejemplo 1: Consulta de una BD de marcas y modelos de coches Vamos a programar un servicio web muy simple capaz de servir a los clientes que nos lo pidan un listado de las **marcas de coches** que existen y otro con los **modelos** registrados que pertenecen a una marca en concreto. El servidor, por lo tanto, necesita dos funciones: * obtenerMarcas * obtenerModelos($idMarca) Aquí ya se ve la primera diferencia con REST: ni los nombres de los métodos están estandarizados, ni hay una colección de métodos predefinidos para cada tipo de recurso. Cuando veamos REST en el siguiente apartado, entenderás mejor qué significa esta afirmación. El cliente, como es lógico, debe conocer cómo utilizar el servidor. Esto puede hacerse mediante el protocolo WSDL (que ya veremos un poco después) o por otras vías más tradicionales: documentación de la API, guía del desarrollador, manual de usuario... En estos ejemplos, tanto el servidor como el cliente estarán escritos en PHP. Por supuesto, puede usarse cualquier otro lenguaje para ello, en particular en el lado del cliente. Para saber cómo hacer un cliente SOAP en otros lenguajes, consulta la documentación de tu lenguaje preferido. **EN EL LADO DEL SERVIDOR** necesitaremos crear un objeto de tipo *SoapServer* y definir los métodos a los que el servidor va a responder. La clase *SoapServer* forma parte de la biblioteca de clases estándar de PHP y debería estar disponible en tu servidor a partir de PHP5. Vamos a empezar por los métodos. Crearemos un fichero (por ejemplo, llamado **GestionAutomoviles.class.php**) en cuyo interior escribiremos una clase con los métodos que necesitemos. Para nuestro ejemplo de marcas y modelos de coches, podría ser algo así: ```php class GestionAutomoviles { public function obtenerMarcas() { $db = new mysqli(); $marcas = array(); if( $db ) { $result = $db->query('select id, marca from marcas'); while( $row = $result->fetch_array() ) $marcas[$row['id']] = $row['marca']; $db->close(); } return $marcas; } public function obtenerModelos($idMarca) { $db = new mysqli(); $modelos = array(); if( $marca !== 0 ) { $result = $db->query('select id, modelo from modelos where marca = ' . $idMarca ); while( $row = $result->fetch_array() ) $modelos[$row['id']] = $row['modelo']; } $db->close(); return $modelos; } } ``` Ahora, en otro archivo aparte que llamaremos, por ejemplo, **webservice.php**, *registramos el servicio* usando la clase *SoapServer* de PHP y asignándole la clase anterior, *GestionAutomoviles*. Se hace así: ```php 'http://localhost/')); $soap->setClass('GestionAutomoviles'); $soap->handle(); ?> ``` Si observas el constructor de *SoapServer* verás que tiene dos argumentos: * El **fichero WSDL** donde se describe el servicio. Como aún no vamos a usar fichero WSDL, ese argumento lo dejaremos a *null* por ahora. * La **URI** donde el servidor va a estar escuchando. Puede ser el directorio raíz de nuestro servidor o cualquier subdirectorio o archivo. En el ejemplo, hemos puesto simplemente *localhost*, pero tú tendrás que adaptarlo a tu servidor. **EN EL LADO DEL CLIENTE**: para comprobar que nuestro servidor SOAP funciona bien, necesitamos crear un secillo cliente que consuma ese servicio. Como hemos dicho antes, esta parte también la vamos a programar en PHP, aunque podría hacerse en cualquier otro lenguaje con soporte SOAP. Necesitamos crear un objeto de tipo *SoapClient*: ```php $soapS = new SoapServer(null, \"URI del servidor\"); ``` Nuevamente, el primer argumento del constructor es el fichero WSDL. Como aún no trabajamos con ellos, lo dejamos a null. Si tuviéramos fichero WSDL, no necesitaríamos indicar la URI del servidor, porque el propio fichero WSDL lo establecería de forma inequívoca. Una vez hecho eso, podemos consumir los servicios del cliente. Por ejemplo: ```php 'http://localhost/', 'location' => 'http://localhost//webservice.php')); $marcas = $client->obtenerMarcas(); foreach($marcas as $key => $value ) echo $value; ?> ``` Fíjate en la manera en la que hemos indicado la localización del servidor: en un array, le decimos a *SoapClient* su ubicación y la ruta de acceso al fichero que maneja el servicio (en nuestro ejemplo, webservice.php). #### Ejemplo 2: Lista de libros de una biblioteca. El ejemplo anterior funciona porque tanto cliente como servidor trabajan en PHP. Pero si el cliente no fuera PHP, podría tener problemas al recibir los datos de respuesta del servidor, que son arrays PHP. Lo más adecuado cuando se responden datos complejos es enviarlos en algún formato estándar de intercambio de información, como **XML o JSON**. En este nuevo ejemplo, vamos a crear un servidor que nos devuelva la **lista de libros de una biblioteca** (lo que incluirá el id, el título y el ISBN de cada libro) empaquetada en un string **JSON**. De momento, tampoco usaremos WSDL (fichero de descripción del servicio). **LADO DEL SERVIDOR** Definimos los métodos de nuestro servidor (archivo *libros.class.php*). En este ejemplo, solo habrá un método : ```php class libros { private function getLibrosJSON() { $sql = \"SELECT * FROM libros\"; $db = new dbAbstract(); // Suponemos que existe una capa // de abstracción de datos return json_encode($db->consulta($sql)); } ...aquí irían más métodos que pudiera tener el servidor } ``` Después, registramos el servidor (archivo *libros.server.php*): ```php 'http://localhost/')); $soap->setClass('libros'); $soap->handle(); ?> ``` **LADO DEL CLIENTE** De nuevo, lo vamos a crear en PHP, que es el lenguaje con el que estamos trabajando, pero podrías programarlo con cualquier otro lenguaje de programación de tu elección. ```php 'http://localhost/', 'location' => 'http://localhost/libros.server.php')); $listaLibros = $libros->getLibrosJSON(); ?> ``` A partir de ahí, el cliente dispondrá en la variable *$listaLibros* de la información recibida del servidor (id, titulo, isbn de todos los libros) empaquetada en formato JSON. #### Ejemplo 3: Servicio de calculadora Este será un servicio mucho más simple y hasta un poco tontorrón, pero no te lo tomes a mal: solo es un ejemplo. El servicio simple y tontorrón proporcionará dos métodos: * **sumar (op1, op2)** --> Devuelve la suma de op1 y op2 * **restar (op1, op2)** --> Devuelve la diferencia entre op1 y op2 Y va a ser un servicio muy simple y tontorrón porque, ahora sí, **usaremos WSDL para definir el servicio** y que los clientes sepan cómo usarlo. Así será más fácil que entiendas la estructura de estos ficheros, que no son nada fáciles de entender porque no están escritos para que los lean personas, sino otros programas. **LADO DEL SERVIDOR** El código de este servidor es extremadamente simple. Fíjate en que ahora, el crear el objeto SoapServer, sí indicamos el nombre del archivo WSDL (*calculadora.wsdl*): ```php AddFunction(\"sumar\"); $server->AddFunction(\"restar\"); $server->handle(); ?> ``` **LADO DEL CLIENTE** El cliente lo volveremos a programar en PHP, aunque ya sabes que puedes programarlo en cualquier otro lenguaje. Fíjate en que también indicamos el archivo WSDL al crear el objeto *SoapClient*, y no es necesario informarle de nada más porque el archivo WSDL ya contiene todo lo necesario para que el cliente sepa conectarse al servidor: ```php sumar(4.75, 12.5); $resultado_resta = $clienteSOAP->restar(4.75, 12.5); echo \"La suma es: \" . $resultado_suma . \"\"; echo \"La resta es: \" . $resultado_resta . \"\"; ?> ``` **DOCUMENTO WSDL** El documento WSDL es un archivo de texto alojado en el servidor donde se describen todos los aspectos del servicio: * Los **mensajes** que se pueden intercambiar entre el cliente y el servidor. * Los **argumentos** y tipos de datos de esos mensajes. * Las **operaciones** y sus tipos * Las **rutas** donde puede encontrarse el servidor Se trata de un documento en formato XML que resulta bastante farragoso de leer, así que tómatelo con calma (ahora entenderás por qué hemos elegido un servicio tan simple como el de este ejemplo para ver su archivo WSDL: si usáramos un servicio más realista, el archivo resultaría un monstruo de miles de líneas). Aquí lo tienes: ```xml . ``` Escribir los documentos WSDL a mano es casi imposible. Y hacerlo sin cometer errores, es imposible del todo. Para eso existen **herramientas automatizadas** que toman el archivo con la clase que contiene los métodos del servicio y generan automáticamente el archivo WSDL. Puedes encontrar estas herramientas de creación automática del archivo WSDL en cualquier IDE avanzado (como Netbeans o Eclipse) y también en muchos sitios web. Por lo tanto, no es un documento que vayas a tener que redactar tú, ni siquiera que leer tú: se trata de una descripción del servicio escrita por y para programas informáticos. Por eso no tiene un formato demasiado legible para un humano. ### 6.2.3. UDDI Este protocolo, que también forma parte de la pila SOAP, es muy fácil de explicar. *Olvídate de que existe*. Fin de la explicación. Fácil, ¿verdad? Por si esta explicación te sabe a poco, te diré que UDDI fue un intento de la industria por estandarizar repositorios de servicios, de manera que cualquier cliente pudiera lanzar una petición a la red para descubrirlos y usarlos. Imagina que tienes una web que necesita conocer la previsión del tiempo en una zona, la que sea. Puedes localizar un servicio web que te proporcione esa información (ya sea de forma gratuita o mediante una suscripción, eso es irrelevante). Hay, de hecho, muchos servidores que ofrecen este servicio, empezando por el de la Agencia Estatal de Meteorología de España. Para usar ese servicio, tienes que conocer el servidor que lo ofrece y luego bucear en su API para avieriguar cómo narices debes pedirle la información y en qué formato te la va a devolver. Y, una vez hecho eso, ya estás listo para programar tu cliente y consumir ese servicio. Pues bien: el servicio UDDI buscaba implementar una manera para que el servidor publicara el tipo de servicio que oferta y los clientes pudieran escanear la red en busca de esos servicios, para luego seleccionar uno y lanzar peticiones contra él, todo ello de forma automatizada y transparente al programador. Era una idea interesante, ¿verdad? Pero murió hace mucho. De hecho, entró en punto muerto en el año 2006, cuando Microsoft e IBM decidieron abandonar el proyecto. Así que, lo dicho: aunque en teoría el protocolo UDDI forma parte de la pila SOAP, puedes actuar como si no existiera. ## 6.3. REST ### 6.3.1. ¿Qué es REST? **REST (Representational State Transfer)** es un mecanismo de intercambio de información entre clientes y servidores de una red. A diferencia de SOAP, está orientado a los datos, esto eso, proporciona siempre los mismos tipos de acceso a los recursos, sin posibilidad de definir nuevas operaciones. Por esa razón se dice que **REST está orientado a los datos** mientras que **SOAP está orientado a los procesos**. Actualmente, gran parte de las APIs, ya sean públicas o privadas, se programan según el diseño REST para que los programadores que las usen sepan qué esperar de la API sin necesidad de consultar farragosas páginas de documentación o de pelearse con el servidor mediante el infalible método de ensayo y error. ### 6.3.2. Las 7 operaciones REST Un servidor REST debe implementar **siete operaciones de acceso a cada tipo de recurso**. Si no las implementa, ya no es REST. Podrá ser *aproximadamente* REST, pero no REST. Los nombres de las operaciones, los datos que se esperan que se devuelvan y el verbo http de acceso deben respetarse escrupulosamente. Imagina que estamos programando un servidor REST para acceder, por ejemplo, a un recurso llamado *Producto* dentro de una aplicación más grande (por ejemplo, una tienda online). En la siguiente tabla tienes las siete operaciones que un servidor REST puede realizar con ese recurso, es decir, con los productos de la base de datos. También te indico qué significa cada operación y un ejemplo típico de la URL que permitirá el acceso a través de https. |Operación|Significado|Verbo|URL típica|---|---|---|---|index|Mostrar todos los producto|GET|https://servidor/producto/|show|Mostrar un producto|GET|https://servidor/producto/id|create|Mostrar formulario de creación de un producto|GET|https://servidor/producto/create|store|Crear un producto con los datos procedentes de un formulario|POST|https://servidor/producto/store|edit|Mostrar el formulario de edición de un producto|GET|https://servidor/producto/edit/id|update|Actualizar el producto con los datos procedentes del formulario|PUT o PATCH|https://servidor/producto/update/id|destroy|Eliminar un producto|DELETE|https://servidor/producto/destroy/id| Hay una excepción a esta regla: las operaciones *create* y *edit* podrían no estar disponibles en algunas APIs REST, cuando estas estén diseñadas para que las usen otras aplicaciones y no seres humanos. Soy consciente de que esta tabla necesita algunas explicaciones adicionales, así que vamos a ello. En primer lugar, ¿qué es eso de los *verbos* que figura en cada petición? ### 6.3.3. Los verbos http: GET, POST, PUT, PATCH y DELETE El protocolo http define dos tipos de petición al servidor, GET y POST. El estándar REST aumenta estos tipos en otros tres: PUT, PATCH y DELETE. Veamos qué significa exactamente cada uno: * **GET** se utiliza para *solicitar* datos al servidor. Por ejemplo: \"Dame toda la información de un producto\". * **POST** se utiliza para *enviar* datos al servidor. Por ejemplo: \"Aquí tienes toda la información de un producto; anda, almacénalo en tu base de datos\". * **PUT/PATCH** se utiliza para solicitar al servidor la modificación de datos que ya existen. Por ejemplo: \"Este es el nuevo precio de un producto que ya estaba en tu base de datos. Tómalo y actualízalo\". Si se van a actualizar *todos* los datos de un producto, se utiliza *PUT*. Si se va a actualizar solo *una parte* de los datos de un producto, se utiliza *PATCH*. * **DELETE** se usa para solicitar la eliminación de datos en el servidor. Por ejemplo: \"Elimina este producto\". Por ese motivo, en algunas URLs de la tabla anterior enviamos un id como parte de la ruta. Ese id indicará al servidor qué producto le estamos pidiendo que nos busque, modifique o elimine. Una moraleja tal vez imprevista de esta tabla es que nunca deberías enviar datos al servidor mediante GET, puesto que GET solo tendría que usarse para *obtener* datos del servidor. Otra moraleja es que el propio verbo de la petición http ya contiene información sobre lo que se le está pidiendo hacer al servidor. De hecho, en un servidor REST, contiene información fundamental. Por eso es tan importante respetar las convenciones. Si ya has trabajado con HTML antes, seguro que conocías el significado de GET y POST, pero probablemente nunca habías oído hablar de PUT, PATCH y DELETE, ¿verdad? ### 6.3.4. El problema de PUT, PATCH y DELETE Cuando solicitamos una URL a un servidor sin indicar otra cosa, el protocolo http/https asumirá que se trata de una petición GET. Si en un formulario indicamos que el método de envío de los datos al servidor es POST, los datos que el usuario rellene en ese formulario se enviarán al servidor mediante POST, como parte del paquete http, en una zona especialmente dedicada a empaquetarlos: ```html ...cuerpo del formulario ``` Pero **con HTML5 *no hay manera de hacer una petición al servidor por PUT, por PATACH o por DELETE***. Esto se debe a que la implementación actual de http no contempla los verbos PUT, PATCH ni DELETE. Sin embargo, **en el estándar REST estos verbos son fundamentales**. Como a nosotros nos interesa construir servidores REST con acceso por http, es decir, vía web, aquí tenemos un grave problema. Mientras llega una nueva implementación de http y/o de HTML, **este problema tiene dos soluciones temporales**: * Sustituir las llamadas con PUT, PATCH o DELETE por llamadas POST convencionales. Esto hará que, en la práctica, nuestro servidor deje de ser REST, claro. * Parchear las llamadas con PUT, PATCH o DELETE mediante un campo oculto (de tipo *hidden*) en el formulario. Esta es la forma en la que se realizan las implementaciones REST vía web en la actualidad. Tienes un ejemplo en este formulario: ```html ...cuerpo del formulario... ``` Tal vez recuerdes que esto es exactamente lo que hace Laravel para implementar llamadas mediante PUT, PATCH o DELETE. ¿Qué dices? ¿Que no te acuerdas? Entonces quizá sea el momento de que retrocedas y repases un poco el enrutador de Laravel. ### 6.3.5. REST y RESTful: ¿hay alguna diferencia? Puede que hayas leído en algún sitio esa palabreja: RESTful. ¿Significa lo mismo que REST? ¿Qué diferencia hay? En realidad, es casi lo mismo: * **REST** se refiere a una **aplicación web** con una arquitectura como la que hemos estado comentando en los epígrafes anteriores. * **RESTful** se refiere a **una API** que respeta la arquitectura REST. No una aplicación web, sino una API. Es decir, RESTful se refiere a un *servicio web*, pensado para responder a otros programas, no a usuarios humanos. RESTful y JSON tienen una relación especial: todas **las APIs RESTful devuelven sus datos formateados en JSON**. Entiéndeme: si a tu servidor le llega una petición de tipo GET a través de una ruta como esta: ```https://servidor/producto/18```, no hay nada que te impida devolver los datos del producto 18 formateados en XML, por ejemplo, pero tienes que ser consciente de que tu API habrá dejado de ser RESTful. El ejemplo típico de servidor RESTful es el que usan las **aplicaciones OVA (*one-view-application*)**. Estas aplicaciones, una vez cargada la vista principal, hacen toda la comunicación con el servidor mediante Ajax, sin abandonar jamás esa vista. Las aplicaciones OVA lanzan peticiones al servidor y este responde mediante JSON en lugar de con vistas completas. Una aplicación así, en el lado del cliente, se está comportando como un consumidor de servicios y, en el lado del servidor, como una API. Veremos Ajax en el capítulo siguiente y aprenderemos a construir aplicaciones OVA, que son cada vez más frecuentes. En estos casos, el lado del cliente y el lado del servidor *actúan como aplicaciones independientes*, conectadas solo por la API (aunque la experiencia del usuario sea la de encontrarse ante una única aplicación). Por ese motivo, hay programadores/as que se especializan en desarrollo en el lado del cliente (**front-end**) y otros que se especializan en desarrollo en el lado del servidor (**back-end**). Conclusión: si vas a desarrollar una API, es buena idea que sea RESTful. En ese caso, cada vez que tengas que devolver un producto (o lo que sea) formateado en JSON desde tu controlador, es mejor que te olvides de las vistas y te limites a hacer algo así: ```php public function show($id) { $producto = modelo-de-productos::get($id); // Obtenemos los datos del producto $id pidiéndoselos a nuestro modelo echo json_encode($producto); } ``` ### 6.3.6. REST vs SOAP Ya sabemos en qué consisten las dos grandes arquitecturas para construir servicios web. Ahora, la pregunta del millón: ¿cuál es mejor de las dos? **SOAP es más flexible que REST**: permite definir nuevas operaciones sobre los recursos, mientras que REST está limitado a las 7 operaciones predefinidas. **REST es mucho más sencillo de usar e implementar que SOAP**: las operaciones son bien conocidas y no es necesario describirlas (WSDL) ni publicarlas de ningún modo. Para usar un servidor REST, no hay que estudiarse ninguna API ni pelearse con estructuras de datos desconocidas. Por todo ello, para la mayor parte de las aplicaciones REST es más que suficiente, y de ahí su mayor implantación en la actualidad. ### 6.3.7. Algunos trucos para implementar un servidor REST Para implementar un servidor REST (o RESTful, si se trata de una API pura) basta con: * Crear una arquitectura MVC para los recursos/datos que deseemos servir. Recuerda que, con Laravel, esto se puede conseguir con el comando: ``` $ php artisan make:controller --resource ``` * En lugar de mostrar los recursos en una vista, los devolveremos al cliente mediante JSON con un sencillo *echo* (recuerda que esa salida la recibirá el cliente, no un ser humano) Si estamos trabajando con Laravel, en lugar de *echo* usaremos *return* al final de cada método del controlador. Laravel se encargará de enviar ese valor devuelto al cliente. * Es importante respetar los nombres de las peticiones HTTP (create, store, edit, update, etc), así como los verbos (GET, POST, PUT, PATCH o DELETE), puesto que serán los que el cliente utilice. ",
    "url": "/docs/dwes/_site/servicios-web/",
    "relUrl": "/servicios-web/"
  },"31": {
    "doc": "7 Ajax",
    "title": "7 Ajax",
    "content": "# 7. Ajax {: .no_toc } - TOC {:toc} ## 7.1. Un poco de introducción al asunto ## 7.1.1. ¿Qué es Ajax? **Ajax** significa **Asynchronous Javascript And XML**. Qué bien, ¿no? ¿Y eso qué quiere decir? Ajax es una tecnología javascript para lanzar y recibir las peticiones al servidor en segundo plano. La página sigue funcionando con normalidad mientras la petición al servidor se resuelve: el usuario puede interactuar con ella y la página responde y no se queda *congelada* a la espera de que el servidor conteste. **Todo eso es lo que significa \"de forma asíncrona\"**. Esta forma de trabajar, que puede parecer una chorrada, se creó para que las páginas dieran la impresión de ser más ágiles de lo que en realidad eran (sobre todo en una época en la que las redes eran más lentas y los servidores podían tardar bastante en responder). En la actualidad, Ajax ha permitido algo que parecía impensable hace una década: que gran parte de la página se ejecute en el cliente y que se pidan al servidor solo los fragmentos de la página que necesitan ser actualizados. Ajax permite actualizar las páginas sin necesidad de recargarlas por completo, lo que mejora la usabilidad y velocidad de respuesta, y cambia radicalmente nuestra forma de programar una aplicación web. ### 7.1.2. Ajax no sirve, en realidad, para nada Esa es la pura verdad. Puedes programar una aplicación web completa, compleja y profesional sin hacer una sola petición Ajax. Pero Ajax mejora el rendimiento y la experiencia del usuario. Puedes sustituir unas pocas peticiones convencionales por peticiones Ajax sin cambiar demasiado en tu aplicación. Por ejemplo, para borrar un recurso, puedes lanzar la petición DESTROY por Ajax y actualizar tu vista para eliminar el recurso del documento HTML cuando el servidor responda. Esto es fácil de hacer. Y muy recomendable. Te aconsejo empezar a trastear con Ajax de este modo. ### 7.1.3. Y, sin embargo, Ajax ha cambiado la forma en la que desarrollamos aplicaciones web Cómo algo que, en realidad, no sirve para nada ha logrado cambiar la forma en la que desarrollamos aplicaciones web puede parecer un misterio a simple vista, pero existe una razón muy simple para ello y te la cuento ahora mismo. La mayoría de las aplicaciones web se pasan todo el tiempo haciendo lo mismo: accediendo a recursos de una base de datos para consultarlos, crearlos, modificarlos o borrarlos, todo ello mediante interfaces de usuario semejantes. Es decir, el interfaz de usuario para crear, modificar y borrar productos de una base de datos es prácticamente el mismo que el que se usa para crear, modificar y borrar proveedores, por decir algo. Así que alguien se preguntó: *¿por qué estamos programando todo el tiempo lo mismo?* Ajax nos permite hacer algo muy ingenioso para evitar este engorro: **diseñar un interfaz de usuario genérico y vacío, solo compuesto por contenedores preparados para nutrirse de datos del servidor**. Por ejemplo, podemos diseñar un típico interfaz de usuario HTML que nos muestre una lista de recursos (productos, proveedores, o lo que sea) junto con los botones de \"Update\" y \"Delete\", además de un botón de \"Add new\". Pero ese interfaz estará vacío, y mediante Ajax lo cargaremos con productos, con proveedores o con lo que necesitemos. Crearemos el interfaz una vez y lo podemos reutilizar miles de veces, para todo tipo de recursos. Este tipo de aplicaciones, también llamadas **SPA (Single-page applications)**, necesitan una arquitectura algo distinta de la que usamos en las aplicaciones web tradicionales, además de una librería en el lado del cliente para ayudarnos en la creación de contenedores genéricos (librerías como **Angular**, **React** o **Vue.js**). Aunque excede a nuestros propósitos profundizar en estas librerías, veremos algunos fundamentos sobre el uso de Vue.js con Laravel al final de este capítulo. En lo que sigue de este capítulo, aprenderemos los fundamentos de Ajax usándolo de forma puntual en el entorno de una aplicación web convencional con arquitectura MVC, no construyendo una aplicación SPA, que es algo mucho más complejo que, en todo caso, llegará después. ## 7.2. Cómo enviar peticiones Ajax al servidor con JavaScript clásico En este apartado vamos a aprender a enviar y recibir respuestas por Ajax **mediante JavaScript clásico**. El objeto XMLHttpRequest es la forma tradicional de trabajar con Ajax en JavaScript. Hay rumores fundados de que este objeto va a ser declarado obsoleto en breve (puede que ya lo esté cuando leas estas líneas). Por esa razón, no es muy buena idea usarlo para desarrollos nuevos. Sin embargo, lo vamos a ver aquí por dos razones: primera, porque hay mucho código antiguo JavaScript circulando por ahí donde lo vas a encontrar. Y, segunda, porque es una forma muy conveniente de comprender cómo funciona la comunicación asíncrona con el servidor. En apartados posteriores veremos cómo trabajar con Ajax mediante otros mecanismos no (presuntamente) obsoletos. ### 7.2.1. Peticiones sin datos al servidor La forma más sencilla (y primitiva) de usar Ajax es **lanzar una petición asíncrona al servidor** sin que el usuario de la web se percate de ello (porque se hará en segundo plano). El servidor no sabrá si la petición se lanzó en primer o en segundo plano y, en realidad, no le importa: él se limitará a atender la petición. Para lanzar una petición mediante Ajax usando JavaScript tradicional (luego veremos cómo hacerlo con jQuery, que simplifica bastante el proceso), necesitamos crear un objeto de tipo **XMLHttpRequest**. Este objeto nos permitirá controlar todo el proceso de envío de la petición, recepción de la posible respuesta y control de los errores que hayan podido ocurrir. Observa detenidamente este fragmento de código JavaScript: ```javascript peticion_http = new XMLHttpRequest(); peticion_http.onreadystatechange = procesa_respuesta; peticion_http.open('GET', 'http://servidor/recurso'); peticion_http.send(null); function procesa_respuesta() { if(peticion_http.readyState == 4) { if(peticion_http.status == 200) { alert(peticion_http.responseText); } } } ``` En las cuatro primeras líneas se crea el objeto de tipo XMLHttpRequest y luego se hacen tres cosas clave con él: 1. **Se le indica qué función se debe ejecutar cuando el servidor responda**. Recuerda que esta función se ejecutará también en segundo plano, sin que el usuario de la página se percate de que está sucediendo algo. 2. **Se le indica qué recurso del servidor se quiere invocar** (típicamente, una URL). Para ello se usa el método open(). Ahí también se indica el método de envío de datos al servidor (GET o POST), incluso si no se envían datos al servidor en absoluto, como en este ejemplo. 3. Por último, **se lanza la petición al servidor** con el método send(). El argumento \"null\" debe sustituirse por los datos que se envían al servidor mediante GET en caso de que los hubiera. Eso deja lista la petición. JavaScript permanecerá a la escucha en segundo plano hasta que el servidor responda. Cuando lo haga, se ejecutará la función procesa_respuesta(). En esa función se hacen tres cosas muy importantes: 1. **Se comprueba si el estado de la petición (readyState) es 4**. Eso significa que el servidor ha terminado de procesarla. La petición pasa por varios estados hasta completarse, y el servidor informa de todos ellos. Es decir, la función procesa_respuesta() se ejecuta al menos una vez para cada uno de estos estados: * readyState == 1 -> OPENED: Se acaba de abrir la comunicación con el servidor. Es decir, se acaba de ejecutar open(). * readyState == 2 -> HEADERS_RECEIVED: Se acaba de enviar la petición al servidor. Es decir, se acaba de ejecutar send(). * readyState == 3 -> LOADING: Se está recibiendo la respuesta del servidor. * readyState == 4 -> DONE: Se ha recibido la respuesta del servidor. Por eso es necesario comprobar que readyState == 4 antes de hacer ninguna otra cosa. 2. **Se comprueba que la respuesta del servidor es 200**. Esto, según el protocolo http, significa que no hay errores en la página. El servidor puede responder con otros códigos, como 404 (recurso no encontrado) o 403 (prohibido el acceso a ese recurso). Puedes encontrar en miles de sitios de internet todas las posibles respuestas de una petición http. 3. Si readyState == 4 y status == 200, significa que **todo ha ido bien y el servidor ha respondido**. Ya podemos hacer lo que sea que tengamos que hacer con esa respuesta. En este ejemplo, nos hemos limitado a mostrar esa respuesta en un alert. Observa en el ejemplo como la respuesta del servidor se recibe en forma de String en el atributo responseText. ### 7.2.2. Peticiones con datos al servidor (GET) Si has entendido el ejemplo anterior, este te va a costar muy poco. Simplemente, vamos a **enviar algunos datos al servidor por GET**, exactament igual que lo haríamos si los enviáramos mediante un formulario. De hecho, el servidor no notará la diferencia. El código para lograrlo es este: ```javascript var cp = document.getElementById(\"codigo_postal\"); var telefono = document.getElementById(\"telefono\"); query_string = \"&codigo_postal=\" + encodeURIComponent(cp.value) + \"&telefono=\" + encodeURIComponent(telefono.value); peticion_http = new XMLHttpRequest(); peticion_http.onreadystatechange = procesa_respuesta; peticion_http.open('GET', 'http://servidor/scrip.php'); peticion_http.send(query_string); function procesa_respuesta() { .... } ``` No ponemos la función procesa_respuesta() porque es la misma de antes. En cambio, sí que hay algunos añadidos en el código de preparación de la solicitud, ¿verdad? Para empezar, hemos cogido un par de datos de un formulario: el código postal y el teléfono (puede ser un formulario de alta de usario o algo por el estilo: recuerda que esto solo es un ejemplo). Luego hemos creado una variable llamada queryString que contiene el string con los datos que queremos enviar al servidor por GET. Como los datos por GET se codifican en la URL, es necesario usar el formato de la URL (separando las variables con el carácter &) y codificar cualquier carácter especial (con la función encodeURIComponente() de Javascript). Por último, en el momento de hacer send(), hemos agregado nuestra query_string para que sea enviada al servidor. Una vez allí, PHP la podrá procesar como cualquier otra string enviada por GET, es decir, usando las variables superglobales $_GET o $_REQUEST. ### 7.2.3. Peticiones con datos al servidor (POST) Si, en lugar de enviar datos al servidor por GET, preferimos **enviar datos por POST**, la técnica es muy similar a la anterior, con un par de variaciones: 1. Debemos indicar \"POST\" en lugar de \"GET\" en el método open(), como es lógico. 2. Debemos indicarle a Ajax que el paquete http llevará variables POST en su cabecera. Para eso se usa el método setRequestHeader(). Lo puedes ver en el siguiente ejemplo: ```javascript var cp = document.getElementById(\"codigo_postal\"); var telefono = document.getElementById(\"telefono\"); query_string = \"&codigo_postal=\" + encodeURIComponent(cp.value) + \"&telefono=\" + encodeURIComponent(telefono.value); peticion_http = new XMLHttpRequest(); peticion_http.onreadystatechange = procesa_respuesta; peticion_http.open(\"POST\", \"http://servidor/script.php\"); peticion_http.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); peticion_http.send(query_string); function procesa_respuesta() { .... } ``` ### 7.2.4. Peticiones con datos al servidor (XML) Todo esto está muy bien si lo que enviamos al servidor son un par de datos sueltos, como el código postal y el teléfono en los ejemplos anteriores. Pero **¿y si tenemos que enviar mucha información?** Digamos, por ejemplo, un array de códigos postales y teléfonos. En ese caso, usar GET se hace inviable (por la limitación de caracteres), así que recurriremos a POST y **empaquetaremos nuestros datos en un string XML o JSON**. En este ejemplo, vamos a usar XML: ```javascript var cp = document.getElementById(\"codigo_postal\"); var telefono = document.getElementById(\"telefono\"); xml = \"\" + \"\" + cp + \" + + telefono + + \"\"; peticion_http = new XMLHttpRequest(); peticion_http.onreadystatechange = procesa_respuesta; peticion_http.open(\"POST\", \"http://servidor/script.php\"); peticion_http.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); peticion_http.send(xml); function procesa_respuesta() { .... } ``` ## 7.3. Cómo recibir la respuesta del servidor con JavaScript clásico En todos los ejemplos anteriores, el servidor conestaba con un simple texto que mostrábamos por medio de un alert() de Javascript. Ni siquiera nos preocupamos por el contenido de ese texto. Podría ser cualquier cosa: algo como \"petición procesada\", \"usuario borrado\" o cosas por el estilo. Pero **a veces el servidor tiene que contestar algo complejo**. Por ejemplo, una tabla completa. En ese caso, como es lógico, necesitamos recurrir a **XML o JSON** para empaquetar todos los datos de la respuesta y enviarlos desde el servidor hacia el cliente. Vamos a ver un par de ejemplo, uno resuelto con XML y otro con JSON. En ninguno de los dos casos mostraremos cómo lo hace el servidor para crear los datos: supondremos que eso ya sabes hacerlo, puesto que se trata de PHP. Nos centraremos en cómo procesa Ajax, es decir, Javascript, esa respuesta. ### 7.3.1. Recepción de datos XML En este ejemplo, el servidor nos devuelve un string XML consistente en un array de códigos postales y teléfonos (de clientes, de usuarios, de lo que sea. Recuerda -otra vez- que solo es un ejemplo). Observa cómo esa respuesta se accede por medio de responseXML (no responseText, como hasta ahora). A partir de ahí, Javascript puede usar esa respuesta como un objeto XML cualquiera: puede buscar hijos de un nodo, puede buscar nodos por su tag, etc. En el ejemplo, nos limitamos a recuperar el código postal y el teléfono del primer elemento del array y a mostrarlo en el documento preexistente, en una capa con el ID \"respuesta\". ```javascript function procesaRespuesta() { if(peticion_http.readyState == 4) { if(peticion_http.status == 200) { var xml = peticion_http.responseXML; var datos = xml.getElementsByTagName(\"datos\")[0]; var telefono = datos.getElementsByTagName(\"telefono\")[0]. firstChild.nodeValue; var cp = datos.getElementsByTagName(\"cp\")[0]. firstChild.nodeValue; document.getElementById(\"respuesta\").innerHTML = \"Codigo postal = \" + codigo_postal + \"\" + \"Telefono = \" + telefono; } } } ``` ### 7.3.2. Recepción de datos JSON Javascript prefiere JSON a XML, es no es un secreto. Casi todos los programadores lo prefieren, en realidad. Así que veamos cómo hacer lo mismo que antes, pero ahora con JSON. La respuesta JSON llegará en responseText, no en responseXML. Eso significa que Javascript la recibe como un String cualquiera. Luego, con la función eval() de Javascript, podemos convertir ese String en un objeto complejo y, a partir de ahí, usar ese objeto para acceder a todos sus elementos. En el ejemplo, como antes, solo accederemos al primer código postal y al primer teléfono y los mostraremos en la capa \"respuesta\" de nuestro documento. ```javascript function procesaRespuesta() { if(http_request.readyState == 4) { if(http_request.status == 200) { var json = http_request.responseText; var objeto_json = eval(\"(\"+json+\")\"); var telefono = objeto_json.datos.telefono; var codigo_postal = objeto_json.datos.cp; document.getElementById(\"respuesta\").innerHTML = \"Codigo postal = \" + codigo_postal + \"\" + \"Telefono = \" + telefono; } } } ``` ## 7.4. Ajax y jQuery El uso de jQuery facilita enormemente la programación de llamadas Ajax al servidor. El decir: se puede manejar Ajax al 100% sin recurrir a jQuery, pero con jQuery es más fácil. jQuery ofrece varias funciones para hacer llamadas Ajax: * **$.ajax()** → La más configurable pero también la más compleja. * **$.get()** → Para lanzar peticiones GET sencillas. * **$.post()** → Para lanzar peticiones POST sencillas * **$.load()** → Para lanzar peticiones GET y cargar la respuesta en una capa. Vamos a verlas una por una. ### 7.4.1. Función $.ajax() Tiene esta sintaxis: ```javascript $.ajax({ url: '/ruta/hasta/script.php', type: 'POST', data: 'parametro1=valor1&parametro2=valor2', contentType: 'tipo de contenido que enviamos al servidor', dataType: 'tipo de contenido con el que responde el servidor', success: function(data) { // Aquí el código para procesar la respuesta }, fail: function() { // Aquí el código para procesar el error } }); ``` Bueno, en realidad $.ajax() admite más argumentos aparte de los que te muestro aquí arriba, pero estos son los principales. Si quieres verlos todos, te sugiero que te des una vuelta por la documentación oficial de jQuery, que por cierto es fantásticamente buena. Observa como, en una sola invocación, conseguimos hacerlo todo: indicar la URL donde se dirigirá la petición, el tipo de envío de datos (GET o POST), los datos que enviamos al servidor, el tipo de datos que recibiremos como respuesta, el nombre de la función que procesará la respuesta e, incluso, el nombre de la función que procesará el error, en caso de que el servidor responda con un código de error. En ***contentType*** puedes indicar el tipo de datos que vas a enviar al servidor. Por defecto, se supone que es 'application/x-www-form-urlencoded; charset=UTF-8', pero te puede interesar cambiarlo por 'multipart/form-data', por ejemplo, si vas a enviar un archivo binario (como una imagen). En ***dataType*** puedes indicar el tipo de datos que se espera que te devuelva el servidor. Por defecto será 'text', es decir, texto plano, pero puedes indicar cosas muy variadas, como 'xml', 'json', 'html' o incluso 'script' si el servidor te va a devolver un fragmento de código JavaScript. Esto ayuda a su procesamiento posterior en la sección ***success***. Por último, en la sección ***success*** puedes acceder a los datos devueltos por el servidor a través de la variable ***data***, que tendrá el formato correspondiente al tipo de datos que hayas indicado en ***dataType***. Por ejemplo, si en ***dataType*** especificaste que el servidor iba a responder con un objeto json, jQuery tratará de convertir la respuesta a un objeto asumiendo el formato json y te la dejará preparada y lista para usar en el parámetro ***data***. Aquí vemos un ejemplo de uso de $.ajax(): ```javascript $(document).ready(function () { $.ajax({ type: \"POST\", url: \"mi-script.php\", data: {email: $(\"#email\").val()}, success: function (data) { $(\"#message\").html(data); }, error: function (req, status, error) { alert(req + \" \" + status + \" \" + error); } }); }); ``` Si es la primera vez que ves código jQuery, esto te sonará tanto como el chino mandarín. Pero no te agobies, que en realidad es muy fácil. Te lo explico en cuatro frases. La primera línea, ***$(document).ready()***, sirve para indicar al navegador que no debe ejecutar la función que haya ahí dentro hasta que el documento no se haya cargado por completo y el árbol DOM desplegado en la memoria del cliente. Solo entonces se lanzará el resto del código. Es algo muy común en el código jQuery. Después viene la llamada Ajax, con varios de los atributos que mencionábamos antes. Fíjate que no hemos usado ni ***dataType*** ni ***contentType***, por lo que se asumirán los valores por defecto. En la sección ***data*** se especifican los datos que se envían a mi-script.php. Solo enviamos un email, pero podríamos enviarle más cosas. Observa que lo hemos formateado en json. Es lo más habitual. En la sección ***success*** hemos colocado directamente el código de la función que se lanzará al recibir la respuesta del servidor. Esa forma de inyectar funciones sin nombre directamente es muy habitual de jQuery. La función se limita a tomar la respuesta del servidor y mostrarla en una capa con el ID \"#message\", pero, por supuesto, podría hacer cualquier otra cosa más compleja. En la sección ***error***, por último, lanzamos un mensaje de error mediante un alert(), que solo saltará si ocurre algún error durante la petición Ajax. Fíjate en que esa función tiene tres parámetros (optativos) que utilizamos para informar al usuario con más detalle de qué error se ha producido. ### 7.4.2. Funciones $.get() y $.post() En muchas ocasiones, no necesitamos usar ni la mínima parte de las posibilidades de la función $.ajax(). Cuando tenemos que **hacer una llamada sencillita por Ajax** al servidor y no queremos complicarnos la vida, puede ser más útil y rápido recurrir a las funciones **$.get()** y **$.post()**. Como su propio nombre indica, $.get() lanza una petición Ajax mediante GET y $.post() hace lo mismo, pero con POST. Su sintaxis es esta: ```javascript $.get(url, datos, funcion_manejadora); $.post(url, datos, funcion_manejadora); ``` Aquí tienes un ejemplo en el que llamamos por Ajax a ***mi-script.php***, enviándole mediante GET un nick de usuario. El servidor responderá con un texto plano que contendrá el nombre de ese usuario y lo mostrará mediante un alert(): ```javascript $.get('mi-script.php', { user: 'juanperez03' }, function(username) { alert('Hola, ' + username); } ); ``` ### 7.4.3. Función $.load() Un caso particularmente simple (y habitual) de uso de Ajax es aquel en el que **lanzamos una petición al servidor para rellenar una capa de nuestra página con la información que el servidor nos devuelve**. Por ejemplo, imagina que tenemos un formulario de registro de usuarios y, en el campo del nick del usuario, deseamos comprobar si ese nick ya está en uso en la base de datos. Mediante Ajax, se puede hacer de forma dinámica y atractiva capturando el evento onblur en del campo nick y lanzando en ese momento una petición Ajax al servidor para que haga la consulta a la base de datos. Si el usuario ya existe, el servidor puede responder con un texto el tipo \"Ese usuario ya existe\". En caso contrario, puede responder con \"Ese nick está disponible\" o algo así. En ambos casos, ese String puede mostrarse en una capa junto al cuadro de texto, una capa que, hasta ese momento, habrá estado vacía. Este escenario tan habitual se puede resolver con $.ajax(), con $.get() o con $.post(), pero existe una función jQuery específica para ello. Se llama **$.load()** y tiene esta sintaxis: ```javascript $('#info').load('mi-script.php'); ``` Simplemente, se ejecuta ***mi-script.php*** en el servidor y se carga el texto de respuesta en la capa #info. Sin funcion manejadora ni historias. Más fácil, imposible, ¿verdad? ## 7.5. Ajax y la API Fetch Hubo un tiempo en el que todos los programadores que querían una sintaxis limpia a la hora de usar Ajax se decantaban por jQuery. Sin embargo, la tecnología en el campo del desarrollo web cambia tan deprisa, que jQuery ya se considera una biblioteca algo desfasada. Sin embargo, la sintaxis de $.ajax(), la función de jQuery para gestionar llamadas Ajax, ha tenido un eco en las versiones más recientes de JavaScript, que ahora tiene su propia forma integrada de hacer solicitudes Ajax: mediante la **API Fetch**, un nuevo estándar para realizar solicitudes de servidor. En esta sección vamos a aprender a lanzar peticiones GET y POST usando la API Fetch de JavaScript. ### 7.5.1. Promesas de JavaScript Para hacer peticiones asíncronas al servidor el la API Fetch, usaremos el **método *fetch()***. Y el método *fetch()* devuelve lo que en JavaScript se denomina **una promesa** (*promise*), así que, antes de continuar, tenemos que comprender qué es eso de las promesas. #### Entendiendo las *promesas* de JavaScript Imagina que vas a pedir una pizza a un local de comida rápida. Pagas en el mostrador y te dan un ticket con un número. Cuando llamen a ese número, podrás recoger tu pizza. *Ese ticket es una promesa.* El ticket significa que, en el futuro, obtendrás una pizza. Pero que todavía no la tienes. Cuando llaman a tu número, significa que la promesa se ha cumplido. Si no te llaman, significa que la promesa no se cumplió. Hay múltiples razones por las que una promesa puede no cumplirse nunca, ¿verdad? En el caso de la pizza, puede que el cocinero se quede sin ingredientes, puede que un inspector de sanidad cierre el establecimiento o puede haber un incendio en la cocina. Literalmente, hay millones de razones por las que una promesa podría no cumplirse, aunque lo normal es que lo haga. En resumen, una promesa se resuelve cuando ocurre alguna de estas cosas: * Obtenemos la comida. * No obtenemos la comida pero sí una razón de por qué no. Las promesas, de hecho, pueden estar en **3 estados**: * **Pendientes**. Una promesa recién lanzada está en este estado. * **Resueltas**. La promesa pasa a este estado si se resuelve correctamente. * **Rechazadas**. La promesa pasa a este estado si se produce un error y no puede atenderse la petición. ### 7.5.2. Lanzando peticiones asíncronas con *Fetch* La sintaxis básica de una petición asíncrona con *fetch()* es esta: ```javascript fetch(url) .then(function() { // Este código se ejecuta cuando el estado pasa a \"Promesa Resuelta\" .catch(function() { // Este código se ejecuta cuando el estado pasa a \"Promesa Rechazada\" }); ``` Con el método *fetch()* se obtiene una **promesa**. Si la promesa se resuelve con éxito, es decir, si el servidor responde correctamente, se ejecuta la función dentro del método *then()*. Y, si falla, se ejecuta la función que hay dentro de *catch()*. Lo habitual, por supuesto, es que **el servidor responda a nuestras peticiones con datos**. Puede ser algo tan simple como un valor booleano o algo tan complejo como una tabla llena de objetos formateada en JSON. Si la llamada al servidor va a devolver datos, estos se recogen en un parámetro de la función del *then()*. Del mismo modo, si se ha producido un error, este se recoge como parámetro en la función del *catch()*: ```javascript fetch(url) .then(function(data) { // Procesar la respuesta. Los datos están en \"data\" }) .catch(function(error) { // Procesar el error. El error está en \"error\" }); ``` ### 7.5.3. Lanzar peticiones por POST Fetch supondrá que todas las peticiones al servidor se envían por GET, salvo que se le indique lo contrario. Para lanzar **una petición por POST** se debe utlizar un segundo argumento de la función *fetch()* y pasarle el encabezado http con los datos que se van a enviar. Por ejemplo: ```javascript const url = 'https://mi-servidor/mi-ruta'; let data = { name: 'Pepe', age: 42 } let httpData = { method: 'POST', body: data, headers: new Headers() } fetch(url, httpData) .then(function() { // Procesar la respuesta del servidor }); ``` ***Headers*** es parte de la API Fetch. Permite manipular los encabezados de las solicitudes y respuestas http, que es donde se empaquetan los datos enviados por POST. La variable *fetchData*, por tanto, llevará todos los datos que se van a enviar por POST. El API Fetch puede usarse de otras maneras, pero esto es más que suficiente para empezar a trabajar con el servidor en modo asíncrono en una gran variedad de situaciones diferentes. ## 7.6. Ajax y Laravel Al trabajar con **Laravel**, estamos acostumbrados a que cada método del controlador termine devolviendo una vista completa (*return view...*). ¿Pero qué pasa si hacemos una petición Ajax a una aplicación web escrita con Laravel en el lado del servidor? Laravel puede continuar devolviendo una vista completa, pero es no suele ser lo que Ajax espera recibir como respuesta. Ajax espera respuestas cortas y concisas: algo como 'true' o 'false', o un número, o un String o, como mucho, una estructura de datos más compleja formateada en XML o JSON. Pero no una página web completa con su cabecera, su cuerpo y toda la parafernalia. Y eso es precisamente lo que devuelve Laravel al rederizar cualquier vista. Así que, ¿cómo lo hacemos? ### 7.6.1. Paso 1. Crear un controlador para las peticiones Ajax Esto no es imprescindible, pero sí suele ser una práctica habitual: **reunir todas las peticiones Ajax en un único controlador**. Ten en cuenta que, para el servidor, no hay diferencia entre una petición Ajax y una petición normal. El servidor recibe su petición por http o https y la atiende, ejecutando en enrutador, el controlador y todo lo que venga detrás, y produciendo una salida como resultado que se envía de vuelta al cliente. Punto. Así que suele ser buena idea separar las peticiones Ajax de las peticiones normales mediante la diferenciación de controladores, salvo que tengas una muy biena razón para no hacerlo. Por lo tanto, crearemos un controlador ***AjaxController*** y añadiremos a nuestro enrutador (*/routes/web.php*) las líneas correspondientes, como esta: ```php Route::post('miJqueryAjax','AjaxController@miMetodo'); ``` ### 7.6.2. Paso 2. Crear los métodos del controlador Lo siguiente sería **crear los métodos que necesitemos en AjaxController** (o, si hemos decidido no crear un controlador específico para Ajax, crear los métodos en los controladores que corresponda). Solo hay que tener una cosa clara: estos métodos que responderán a las peticiones Ajax **no pueden terminar con una vista**. Imagina un método que reponderá a una petición Ajax y que solo deba responder con un String, cuyo valor pueda ser \"Ese usuario ya existe\" o \"Usuario disponible\". Lo haríamos así: ```php class AjaxController extends Controller { public function miMetodo() { ...aquí va mi código... if ($lo_que_sea) $result = \"Ese usuario ya existe\"; else $result = \"Usuario disponible\"; return $result; } } ``` Imagina ahora que queremos devolver algo más complicado, como un array o una colección de datos. No pasa nada: los formateamos como json y los enviamos de regreso al cliente, así: ```php class AjaxController extends Controller { public function miMetodo() { ...aquí va mi código... return response()->json($mi_variable_compleja); } } ``` Por supuesto, esta última manera también te funcionará para devolver un simple String, un booleano o un entero. Es la forma más conveniente de terminar un método de un controlador que va a ser invocado por Ajax y no mediante una petición normal al servidor. Ten en cuenta que: * La salida de una petición Ajax suele ser JSON, pero podría ser otra cosa: HTML, XML o simple texto plano. * Lo repetimos una vez más: para responder a una petición Ajax no se debe renderizar una vista (¡salvo que tengas una muy buena excusa para hacerlo!), sino que basta con un return response(). ### 7.6.3. Paso 3. Agregar el token CSRF a las peticiones Como vimos al estudiar Laravel, **las peticiones enviadas por POST con Laravel deben llevar el token CSRF** o serán rechazadas. Esto se hacía para prevenir cierto tipo de ataques frecuentes a través de formularios HTML. Los detalles no son importantes aquí y, en todo caso, puedes repasar el capítulo sobre Laravel o sobre Sesiones, Cookies y Seguridad para revisar el concepto. Lo importante ahora es esto: cuando lances una petición POST mediante Ajax, Laravel la rechazará porque no llevará el token CSRF. Recuerda que el servidor no tiene ni idea de si la petición llega desde Ajax o no: para él, se trata de datos que provienen de un formulario HTML, y si no lleva ese token, automáticamente se convierte en un formulario sospechoso. Así que, si tienes Laravel en el lado del servidor, **necesitas agregar el token CSRF a las peticiones por POST**, así: ```javascript $.ajax({ method: \"POST\", url: \"mi-url\", data: { \"_token\": \"{% raw %}{{ csrf_token() }}{% endraw %}\" }, ...etc... }); ``` Por supuesto, puedes añadir más ***data*** a tu petición: tantos datos como necesites enviar al servidor. Como esto puede ser un poco engorroso, hay una forma de agregar automáticamente el token CSRF a **todas** las peticiones. Basta con escribir esto en el header de nuestro layout: ```html ``` A partir de ahora, podremos hacer las peticiones Ajax normalmente, porque el token CSRF se añadirá él solito a cada petición Ajax. ### Ajax, Laravel y Vue.js Esta parte la veremos más adelante... ¡si nos da tiempo! ",
    "url": "/docs/dwes/_site/ajax/",
    "relUrl": "/ajax/"
  },"32": {
    "doc": "8 Otras tecnologías",
    "title": "8 Otras tecnologías",
    "content": "# 8. Otras tecnologías En esta sección vamos a hacer un repaso rápido a **otras tecnologías para desarrollo web del lado del servidor** diferentes de PHP sobre Apache (o similar). Será solo un vistazo superficial, para que te hagas una idea de cómo huelen y a qué saben estos otros lenguajes y veas que, en lo sustancial, no difieren mucho unas de otras, al menos desde el punto de vista del programador. Todas las diferencias se centran en los detalles, no en lo principal. Esto quiere decir que, si te manejas bien con PHP, podrás pasarte a cualquiera de estos lenguajes con muy poco esfuerzo y en solo unos días. ",
    "url": "/docs/dwes/_site/otras-tecnologias/",
    "relUrl": "/otras-tecnologias/"
  },"33": {
    "doc": "5.1 Frameworks PHP MVC",
    "title": "5.1 Frameworks PHP MVC",
    "content": "## 5.1. ¿Qué es un framework? {: .no_toc } - TOC {:toc} Un **framework** es un conjunto estandarizado de prácticas de programación para resolver una serie de problemas habituales. El framework proporciona una serie de **clases, librerías y otros componentes** para facilitar el desarrollo ágil, seguro y escalable de nuevas aplicaciones. Por lo tanto, un **framework MVC PHP** es un conjunto de clases, librerías y otros componentes destinados a servir de base para desarrollar aplicaciones en PHP con arquitectura MVC. La idea es esta: *no inventar la rueda cada vez que la necesitamos*. ### 5.1.1. ¿Realmente necesito un framework para desarrollar una aplicación web? No, los frameworks *nunca* son imprescindibles.....*pero casi siempre son muy convenientes*. Hay programadores pro-frameworks y anti-frameworks. Los programadores anti-frameworks acaban desarrollando, aposta o sin querer, su propio framework después de llevar varias aplicaciones MVC a sus espaldas. Para decidir si necesitas un framework o no, tienes que conocer antes cómo funcionan y qué ventajas e inconvenientes presentan. Usar un framework tiene ciertas **ventajas**, como: * Reutilización del trabajo ya hecho (recuerda: no reinventar la rueda). * Extensa documentación. * Separación en capas. * Seguimiento de buenas prácticas de programación. * Escalabilidad y mantenimiento. * Desarrollo más rápido y, por tanto, más económico. Pero también tiene algunos **inconvenientes**: * A veces pueden limitar el desarrollo. * Curva de aprendizaje costosa (más en unos frameworks que en otros). Es decir: al principio iremos más lentos que sin framework, hasta que le cojamos el tranquillo. * Puede llegar a implicar más trabajo, dependiendo del proyecto. * Preferencias personales: algunos programadores solo se sienten cómodos si todo el código es suyo. * Actualizaciones frecuentes e imprevistas. A menudo, la actualización de un framework hace que parte de tu aplicación deje de funcionar. * Ocultan gran parte del funcionamiento de la aplicación: no son aptos para aprender a programar. En resumen: la idea es que, al usar un framework, solo te centras en desarrollar lo importante. El resto (lo que ya estaba desarrollado en el framework y que es común a muchas aplicaciones web) no te quita tiempo. ### 5.1.2. ¿Qué framework escoger? Existen multitud de frameworks MVC PHP. Estos son algunos de gran implantación en la actualidad: * **Symfony**: el más extendido desde hace años. * **Laravel**: el que tiene un crecimiento más rápido. * **CodeIgniter**: el más sencillo, aunque su implantación en la industria el menor. * Otros framworks MVC PHP importantes son Zend Framework, Yii y CakePHP. Lamentablemente, no hay respuesta a la pregunta: ¿qué framework es mejor? Puedes pasar el resto de tu vida leyendo en foros y en blogs, descargando e instalando varios frameworks para desecharlos a los dos días, esperando a que salga una nueva versión o un framework nuevo... Nunca podrás responder a esa pregunta. Como mucho, podrás responder a esta otra: ¿qué framework prefiero? Y eso solo después de haber probado varios durante algún tiempo. Además, el framework por sí sólo puede no ser suficiente para un desarrollo completo, y probablemente harán falta otros componentes que afectarán a la experiencia de programación. Algunos ejemplos son: * Librerías del lado del servidor: pear, pChart, doctrine... * Librerías del lado del cliente: jQuery, Vue.js, Angular, React, bootstrap... ",
    "url": "/docs/dwes/_site/laravel/que-es-un-framework.html",
    "relUrl": "/laravel/que-es-un-framework.html"
  },"34": {
    "doc": "5.10 Migraciones",
    "title": "5.10 Migraciones",
    "content": "## 5.10. Migraciones {: .no_toc } - TOC {:toc} Las **migraciones** constituyen una especie de control de versiones para la base de datos de la aplicación. Permiten crear y modificar tablas de la BD con independencia del SGBD que estemos usando. Con las migraciones no solo podrás reconstruir la base de datos en menos de lo que tarda en decirse \"Von Neumann\" (algo muy práctico cuando estás en fase de desarrollo), sino que podrás parchear la base de datos de una aplicación en producción en un tiempo record y con riesgo cero. (Solo el que ha tenido que parchear la base de datos de una aplicación en producción antes de la existencia de las migraciones sabe la tranquilidad de espíritu que esto produce y la cantidad de problemas embarazosos que te quita de encima). Antes de empezar, recuerda que, para que cualquier operación sobre la base de datos funcione, debes tener bien configuradas estas variables de entorno del archivo .env de Laravel: ``` DB_HOST=localhost DB_DATABASE=mi-base-de-datos DB_USERNAME=mi-usuario-de-BD DB_PASSWORD=mi-password-de-BD ``` ### 5.10.1. Crear tablas mediante las migraciones La primera cosa para las que sirven las migraciones es para **crear las tablas de tu aplicación**. Olvídate de exportar e importar a mano el archivo SQL de tu base de datos. Eso lo hacían los cromañones. Vamos a trabajar con un ejemplo, como siempre. Imagina que tenemos una tabla llamada *Clients* con los campos típicos: *id*, *name*, *address*, etc. De acuerdo. Creemos, paso a paso, las migraciones de esta tabla: **Paso 1**: Inicializar el sistema de migraciones de Laravel (si ya lo hemos hecho antes, nos dará un error al intentar hacerlo otra vez): ``` $ php artisan migrate:install ``` **Paso 2**: Crear la migración para la tabla Clients: ``` $ php artisan make:migration create_clients_table ``` Esto generará un fichero en la carpeta */database/migrations* cuyo nombre contendrá un *timestamp* o marca de tiempo. Vamos, que contendrá un numerajo con la fecha y hora actual. Algo tan bonito como */database/migrations/20221226072434createclientstable.php* Si editas ese fichero, verás dos métodos: * **up()** → se ejecuta cuando se lanza la migración. Se encarga de crear la tabla en la base de datos. * **down()** → se ejecuta cuando se cancela la migración. Se encarga de eliminar la tabla de la base de datos. **Paso 3**: Editar el fichero */database/migrations/20221226072434createclientstable.php*: En el método *up()* tienes que indicar las columnas que tendrá la tabla. Por ejemplo: ```php public function up() { Schema::create('clients', function (Blueprint $table) { $table->bigIncrements('id')->index();// UNSIGNED BIGINT AUTOINC. $table->string('name',75)->unique(); // VARCHAR $table->text('address')->nullable(); // TEXT $table->integer('level'); // INT $table->date('brith_date'); // DATE // La siguiente línea crea campos created_at y updated_at. Si la borras // esos campos no existirán en tu tabla $table->timestamps(); }); } public function down() { Schema::drop('clients'); } ``` **Paso 4**: Lanzar las migraciones. ``` $ php artisan migrate ``` Esto creará las tablas que no se hayan creado aún. Es decir, si una migración ya se ha lanzado con anterioridad, no se vuelve a ejecutar para no perder los datos que pudieran existir en esas tablas. **Paso 5**: Revertir las migraciones (si es necesario) Si necesitas revertir la creación de todas las tablas: ``` $ php artisan migrate:rollback ``` Para revertir solo el último paso en la creación de tablas: ``` $ php artisan migrate:rollback --step=1 ``` Para dejar la BD a su estado original (vacía): ``` $ php artisan migrate:reset ``` ¡Cuidado! Estas acciones son destructivas. Pero, por supuesto, hay una forma de modificar una tabla sin borrarla y volver a crearla. Es lo que vamos a hacer a continuación. ### 5.10.2. Modificar tablas mediante migraciones Si necesitas **modificar una tabla que ya existe** (por ejemplo, para añadir o eliminar campos), tienes dos opciones: 1. Modificar la migración original (en la que se crea la tabla) para añadir o eliminar el campo afectado. Esto te obligará a lanzar la migración de nuevo y, por lo tanto, la tabla se reconstruirá y todos los datos que pudiera contener se perderán. 2. Crear una nueva migración en la que únicamente se haga la modificación de la tabla, sin tocar el resto. Esto respetará los datos que la tabla ya pudiera contener. Como es lógico, la opción 2 será la que preferiremos si la aplicación ya está en producción y necesitamos modificar la estructura de la base de datos. En cambio, durante el desarrollo, puede ser más simple utilizar la opción 1. Supongamos que queremos añadir un campo *email* a la tabla *Clients* del apartado anterior. Si optas por la opción 2, es decir, por crear una nueva migración que se encargue de hacer esa modificación en la tabla sin alterar sus datos, la forma de proceder es la siguiente: **Paso 1**. Crear la migración: ``` $ php artisan make:migration add_email_to_clients --table=clients ``` (Nota: puedes asignar el nombre que quieras a las migraciones, pero Laravel aconseja utilizar las convenciones que ves en estos ejemplos para simplificarnos la vida) **Paso 2**: Editar la migración */database/migration/add_email_to_clients.php* para añadir, en el método *up()*, el campo nuevo; y, en el método *down()*, especificaremos qué hay que hacer en caso de que se fuerce un rollback de esta migración: ```php public function up() { Schema::table('clients', function (Blueprint $table) { $table->string('email')->after('address'); }); } public function down() { Schema::table('clients', function (Blueprint $table) { $table->dropColumn('email'); }); } ``` ### 5.10.3. Otras operaciones en las migraciones Las migraciones pueden usarse para cualquier otra operación sobre la estructura de la base de datos, como: * Cambiar tipos de columnas. * Cambiar atributos de columnas (null, unique, default...) * Cambiar o asignar claves primarias y ajenas. Las migraciones construídas de este modo nos permitirán reproducir la base de datos en cualquier servidor o actualizarla en cualquier momento sobre una aplicación en producción sin necesidad de programar parches o exportar la BD a un archivo SQL para importarlo en otro servidor. Como te dije al principio, solo el que ha hecho alguna vez alguna de estas cosas a mano sabe la cantidad de trabajo que las migraciones ahorran en el mantenimiento de una aplicación y la asombrosa cantidad de errores embarazosos que evita. Más info en: [https://laravel.com/docs/8.x/migrations](https://laravel.com/docs/8.x/migrations) ### 5.10.4. Seeding El ***seeding*** es una técnica adicional a la de las migraciones que permite **cargar con datos las tablas** de la base de datos. Es muy práctico en estos supuestos: * Si quieres tener un conjunto de **datos de prueba** en tu base de datos de desarrollo, esa que destrozas periódicamente cuando haces pruebas. Con un solo comando, tendrás la base de datos reconstruída después de cada destrozo. * Si necesitas cargar algunos datos mínimos en algunas tablas para que la aplicación, una vez desplegada en un servidor de producción, funcione (por ejemplo, para crear un usuario administrador en la tabla *Users* o para crear algunas entradas en una tabla *Options*). Para crear un *seeder* (por ejemplo, para la tabla *users*), sigue estos pasos: **Paso 1**. Ejecuta el comando: ``` $ php artisan make:seeder UsersTableSeeder ``` **Paso 2**. Edita el archivo */database/seeds/UsersTableSeeder.php* y añade algo como esto al método *up()* (por supuesto, modifica el código para adaptarlo a tu tabla y a tus datos): ```php public function run() { Users::truncate(); // Opativo: vacía la tabla antes de rellenarla DB::table('users')->insert([ 'name' => 'Stephen Falken', 'address' => 'Oregon 97, Goose Island', 'email' => 'sfalken@norad.com', 'brith_date' => '1932-09-03', ]); DB::table('users')->insert([ 'name' => 'Jennifer Mack', 'address' => 'Richmond Av 3385, Seattle', 'email' => 'jenmack876@gmail.com', 'brith_date' => '1967-01-28', ]); } ``` **Paso 3**. Ejecuta este comando para lanzar el seeder y que los datos se carguen en tu tabla: ``` $ php artisan db:seed --class=UsersTableSeeder ``` Esto cargará solo dos registros en la tabla *users*. Si quieres más, solo tienes que crear nuevas líneas *insert()* en el método *up()*. ### 5.10.4. Automatizar el seeding Lanzar los seeders de uno en uno puede ser muy tedioso. Puedes lanzar varios seeders con un solo comando si haces lo siguiente: **Paso 1**. Edita el fichero */database/seeds/DatabaseSeeder.php* **Paso 2**. Añade a la función *run()* una línea como esta por cada seeder que quieras ejecutar automáticamente: ```php $this->call(UsersTableSeeder::class); ``` **Paso 3**. ¡Y listo! Al ejecutar el comando ```db:seed``` de Artisan, sin indicar la clase, se lanzarán todos los seeders que hayas añadido a *run()*. ``` $ php artisan db:seed ``` ### 5.10.5. Lista de comandos superútiles para manejar migraciones Por último, te muestro un resumen con los comandos más útiles sobre migraciones y seeders para que puedas consultarlos cuando lo necesites: * Lanzar todas las migraciones pendientes: ``` $ php artisan migrate ``` * Crear la migración para crear una tabla: ``` $ php artisan make:migration --create= ``` * Crear una migración para modificar una tabla ya existente: ``` $ php artisan make:migration --table= ``` * Retroceder un paso en todas las migraciones: ``` $ php artisan migrate:rollback ``` * Retroceder N pasos en todas las migraciones: ``` $ php artisan migrate:rollback --step= ``` * Deshacer todas las migraciones que se hayan ejecutado hasta ahora (resetear la base de datos): ``` $ php artisan migrate:reset ``` * Resetear la base de datos y volver a reconstruirla lanzando todas las migraciones: ``` $ php artisan migrate:refresh ``` * Resetear la base de datos, reconstruirla y llenarla de datos con los seeders: ``` $ php artisan migrate:refresh --seed ``` * Eliminar todas las tablas y lanzar todas las migraciones de nuevo: ``` $ php artisan migrate:fresh ``` * Eliminar todas las tablas y lanzar todas las migraciones y todos los seeders de nuevo: ``` $ php artisan migrate:fresh --seed ``` ",
    "url": "/docs/dwes/_site/laravel/migraciones.html",
    "relUrl": "/laravel/migraciones.html"
  },"35": {
    "doc": "5.11 Usando la BD con Eloquent",
    "title": "5.11 Usando la BD con Eloquent",
    "content": "## 5.11. Usando la BD con Eloquent {: .no_toc } - TOC {:toc} Eloquent uno de los componentes de Laravel que permiten al desarrollador manipular los datos de la BD sin rebajarse a escribir sucio SQL. Y lo consigue mediante un mecanismo simple y elegante: el mapeo objeto-relacional. En esta sección vamos a ver qué es eso del mapeo y cómo sacarle a Eloquent el máximo partido para que nuestros modelos se programen prácticamente solos. ### 5.11.1. ¿Qué es el mapeo objeto-relacional? Eloquent no es más que una librería incluida con Laravel que utiliza un patrón de software llamado **ORM (Object-Relational Mapping)** para abstraer aún más el acceso a la base de datos, de manera que no tengamos que escribir y depurar SQL. *Mapear* los objetos de nuestra aplicación con una BD relacional significa que Eloquent convierte los registros de tus tablas en objetos de tu aplicación para que los manipules con mayor facilidad. Sí, lo has entendido bien: podrás manejar los datos de tu base de datos como si fueran objetos de tu aplicación. Y, cuando los modifiques, borras o crees, se ejecutará el código SQL necesario (sin que tú te enteres) para traducir esas operaciones en sentencias para la base de datos. Te lo muestro con un ejemplo. Imagina que tenemos una tabla de artículos de un blog. La llamaremos *Articles*, y tendrá 3 campos: el *id* (entero), el *title* (cadena de caracteres) y el *body* (cadena de caracteres). Con Eloquent, usar esa tabla es tan fácil como hacer algo así: ```php $art = Article::find('7'); // Buscamos un artículo por su id echo $art->title; // Ahora podemos acceder a los campos de ese artículo $art->body = \"Texto del cuerpo\"; // O también podemos modificar los campos del artículo $art->save(); // Si hacemos save(), los cambios se guardan en la BD ``` ### 5.11.2. ¿Cómo puedo usar Eloquent en mi aplicación? Tienes que **crear un modelo**. ¿Qué te creías? Pero con Artisan es así de fácil: ``` $ php artisan make:model ``` Por ejemplo: ``` $ php artisan make:model Article ``` El modelo se creará en */app/models/Article.php* (¡cuidado! En versiones más antiguas de Laravel, el modelo se creará en */app/Article.php*) Truco: si creas el modelo con la **opción -m**, se creará atomáticamente su migración, lo cual resulta tremendamente práctico: ``` $ php artisan make:model Article -m ``` Ya tienes tu modelo. Si no puedes contener tu curiosidad insaciable y lo abres, verás un archivo bastante decepcionante con este aspecto: ```php ', 100)->get(); // Select con where $articlesList = Article::where('id', '>', 100)->take(10)->get(); // Select con where y take $maxId = Article::max('id'); // Devuelve el último id asignado ``` A lo mejor hay algo que te está chirriando. Si escribimos cosas como estas en el controlador, ¿no significa eso que estamos lanzando consultas desde el controlador? Y eso está prohibidísimo en la arquitectura MVC. ¿Es que Laravel no respeta la arquitectura MVC? Hay quien dice que sí, hay quien dice que no y hay quien dice que psé, psé. En realidad, no estamos escribiendo SQL en el controlador, ni estamos accediendo a la base de datos de ninguna manera explícita. Cuando lanzamos un ```Article::find($id)``` desde el controlador, por ejemplo, no sabemos qué ocurre por debajo ni de dónde se extrae la información: nos limitamos a acceder a una de nuestras clases y obtener de ella un objeto de tipo *Article*. ### 5.11.5. Inserciones y borrados con Eloquent También podemos usar Eloquent para **insertar** un nuevo artículo desde nuestro controlador: ```php $art = new Article; $art->title = 'Los Chitauri invaden Nueva York'; $art->body = 'Bla, bla, bla'; $art->save(); ``` Si los datos del artículo vienen de un formulario, fíjate en lo alucinantemente fácil que es recoger todos esos datos, crear un objeto Article con ellos y guardar el artículo en la BD: ```php public function store(Request $request) { Article::create($request->all()); // Esto es una ASIGNACIÓN MASIVA de las que hablábamos más arriba!! return view('la-vista-que-sea'); } ``` Ojo: solo los campos que hayas indicado como *fillables* en el modelo se podrán asignar al artículo de este modo. Eso es lo que significa **asignación masiva**. Y, por supuesto, también podemos **modificar y borrar** artículos de la base de datos: ```php $art = Article::find(18); // MODIFICAR $art->body = 'Nuevo cuerpo'; $art->save(); $art = Article::find(13); // BORRAR $art->delete(); ``` ### 5.11.6. Lista de los métodos más útiles de Eloquent Hemos visto en los últimos ejemplos **algunos métodos de Eloquent** por separado. Te los reúno en esta sección para que los puedas consultar cuando lo necesites. Aviso: no están todos, solo los de uso más habitual. Si quieres una lista completa, ya sabes: acude a la [documentación oficial](https://laravel.com/docs/8.x/eloquent). * **all()** → Recupera todos los registros de una tabla. * **where(\"campo\", valor)** → Aplica claúsula *where*. * **orderBy(\"campo\", \"asc\\|desc\")** → Aplica claúsula *order by*. * **get()** → Recupera registros seleccionados. Se suele usar con *where* y/o *order by*: ``` Ciudades::where(\"ciudad\", \"Madrid\")->orderBy(\"id\", \"asc\")->get(); ``` * **first()** → Recupera el primer registro. * **latest()** → Recupera el último registro. * **find(valor)** → Busca registros con ese valor en el campo *id*. * **findOrFail(valor)** → Lanza un error 404 si no encuentra el registro. * **count(), max(), min()...** → Utiliza funciones de agregado de SQL. * **save()** → Inserta o actualiza registros. * **update()** → Actualiza registros. * **delete()** → Elimina registros. ### 5.11.7. Relaciones entre tablas con Eloquent Las **relaciones entre tablas** también se pueden manejar con Eloquent sin necesidad de andar escribiendo larguísimos INNER JOIN y otros miembros de su nutrida familia, con todos los errores de escritura que suelen hacernos perder el tiempo depurando SQL. Aunque al principio te parezca que definir las relaciones entre tablas con Eloquent necesita mucho trabajo previo, te garantizo que después te alegrarás de haberlo hecho. Porque las relaciones, una vez definidas, se comportan como consultas y se puede operar con ellas como si lo fueran. Lo comprenderemos mejor, como siempre, con ejemplos. En los siguientes apartados, vamos a suponer que tenemos estas tablas: * usuarios(id#, nombre, passwd) * emails(id#, email, usuario_id) → Esta tabla tiene una relación 1:1 con usuarios * articulos(id#, titulo, texto, idUsuario) → Esta tabla tiene una relación 1:N con usuarios * roles(id#, nombre) → Esta tabla tiene una relación N:N con usuarios ATENCIÓN: en la tabla *artículos* hemos usado a propósito un nombre no estándar para la clave foránea. Para respetar la convención de Laravel, debería llamarse *usuario_id* en lugar de *idUsuario*, como en la tabla *emails*. #### 5.11.7.1. Relaciones 1:1 (usuarios emails) Para definir un **relación 1:1** con Eloquent debes hacer lo siguiente: **Paso 1**. En el modelo de la tabla maestra (clase *Usuario*, en nuestro ejemplo) añadimos este método: ```php public function email() { return $this->hasOne('App\\Email'); } ``` **Paso 2**. En el modelo de la tabla relacionada (clase *Email*) añadimos este método: ```php public function usuario() { return $this->belongsTo('App\\Usuario'); } ``` A partir de ahora, se puede recuperar el email de un usuario como si fuera un miembro de la clase *Usuario*, tan sencilla como esto: ```php $email = Usuario::find(1)->email; $user = Email::all()->first()->user; ``` Y también funciona al revés. Es decir, a partir de un objeto de tipo *Email*, podemos acceder a su usuario como si fuera un atributo de la clase *Email*. #### 5.11.7.2. Relaciones 1:N (usuarios artículos) Si tienes una **relación 1:N** (como la que hay entre las tablas de *usuarios* y *artículos* de nuestro ejemplo), para definirla en Eloquent tienes que hacer esto: **Paso 1**. En el modelo de la tabla maestra (clase *Usuario*), añade este método: ```php public function articulos() { return $this->hasMany('App\\Articulo', 'idUsuario'); } // ATENCIÓN: hemos tenido que indicar el nombre de la clave foránea // (idUsuario) porque no habíamos respetado la convención de Laravel // (usuario_id) al crear la tabla de artículos ``` **Paso 2**. En el modelo de la tabla relacionada (class Articulo), añade este otro método: ```php public function usuario() { return $this->belongsTo('App\\Usuario'); } ``` ¡Y listo! Ya puedes recuperar los artículos a partir del usuario, como si fueran atributos de esa clase. Y a la inversa también funciona. Por ejemplo: ```php $articulos = Usuario::find(1)->articulos; foreach ($articulos as $articulo) { // Procesar cada artículo } ``` #### 5.7.11.3. Relaciones N:N (usuarios roles) Si lo que tienes es una **relación N:N** (como la que hay entre *usuarios* y *roles* en nuestro ejemplo), los pasos a seguir para construirla con Eloquent son estos: **Paso 1**. En el modelo de una de las tablas (clase *Usuario*) añadimos este método: ```php public function roles() { return $this->belongsToMany('App\\Rol'); } ``` **Paso 2**. En el modelo de la otra tabla (clase *Rol*) añadimos este método: ```php public function usuarios() { return $this->belongsToMany('App\\Usuario'); } ``` Ahora, ya se pueden recuperar los roles a partir del usuario o a la inversa. Por ejemplo: ```php $roles = Usuario::find(1)->roles; foreach ($roles as $rol) { // Procesar cada rol } ``` #### 5.7.11.4. La tabla pivote: insertar, modificar y borrar en relaciones N:N Insertar, modificar y borrar en relaciones N:N implica escribir datos (normalmente, ids) en la **tabla intermedia** o **tabla pivote**, lo cual suele suponer un engorro cuando se hace *a mano* con SQL. Ese tedioso proceso también se puede automatizar con Eloquent. Lo vemos con un ejemplo entre nuestras tablas *usuarios* y *roles*. **Para insertar** un usuario y sus roles se usa el método *attach()*: ```php public function store(Request $r) { $user = new User($r->all()); $user->roles()->attach($r->roles); $user->save(); } ``` **Para actualizar** un usuario y sus roles se usa el método *sync()*: ```php public function update(Request $r, $id) { $user = User::find($id); $user->fill($r->all()); $user->roles()->sync($r->roles); $user->save(); } ``` **Para eliminar** un usuario y sus roles se usa el método *detach()*: ```php public function destroy($id) { $user = User::find($id); $user->roles()->detach(); $user->delete(); } ``` #### 5.7.11.5. Problemas frecuentes en relaciones N:N Eloquent supondrá que **el nombre de la tabla de la relación** se ha formado con los nombres de las dos tablas maestras en snake case y ordenadas alfabéticamente. Por ejemplo, en la relación N:N entre *usuarios* y *roles*, Eloquent supondrá que existe una tabla llamada *roles_usuarios*. Si no se llama así, la relación fallará. Se puede indicar otro nombre de tabla al definir la relación. Por ejemplo, en el modelo de usuarios (clase *Usuario*): ```php public function roles() { return $this->belongsToMany('App\\Rol', 'usuarios_roles'); } ``` También se pueden indicar los nombres de las claves foráneas si no siguen las convenciones (que, según Laravel, son *usuario_id*, *rol_id*, etc) ```php public function roles() { return $this->belongsToMany('App\\Rol', 'usuarios_roles', 'id_usuario', 'id_rol'); } ``` ¿Te has fijado en que hemos creado un método para acceder a la tabla relacionada, pero estamos usando un atributo en su lugar? ```php public function articulos() { return $this->hasMany('App\\Articulo'); } public function loQueSea() { $arts = Usuario::find(1)->articulos; // articulos, no articulos() } ``` Pues bien, el atributo *articulo* es un **atributo virtual** creado por Eloquent. Pero el método *articulos()* también existe, y puede usarse como una consulta, extendiéndola como necesitemos. Por ejemplo: ```php $arts = Usuario::find(1)->articulos()->where('titulo','foo')->first(); ``` ",
    "url": "/docs/dwes/_site/laravel/eloquent.html",
    "relUrl": "/laravel/eloquent.html"
  },"36": {
    "doc": "5.12 Usando la BD con QueryBuilder",
    "title": "5.12 Usando la BD con QueryBuilder",
    "content": "## 5.12. Usando la BD con QueryBuilder {: .no_toc } - TOC {:toc} En esta sección te voy a presentar a **QueryBuilder**, otra forma de acceder a la base de datos desde Laravel que te resultará muy útil en aquellos casos en los que, por la razón que sea, los métodos de Eloquent no sean suficientes. ### 5.12.1. ¿Qué es y cómo se utiliza QueryBuilder? Eloquent permite usar la BD de forma simple y elegante en la mayor parte de las circunstancias. Aún así, puede haber situaciones en las que queramos un acceso de más bajo nivel a la BD. Para eso existe **QueryBuilder**. El grado de abstracción de QueryBuilder es mucho menor que el de Eloquent. Es decir, estaremos *CASI escribiendo SQL*, sin llegar a hacerlo. Algunos ejemplos de uso te darán una pista de qué tipo cosas se pueden hacer con QueryBuilder: ```php $users = DB::table(\"users\")->get(); $users = DB::table(\"users\")->where(\"name\", \"=\", \"Ana\")->first(); $users = DB::table(\"users\")->where(\"edad\", \">=\", 18)->orderBy(\"apellidos\"); $maxId = DB::table(\"users\")->max(\"id\"); $existe = DB::table(\"users\")->where(\"id\", \"=\", $id)->exists(); $users = DB::table(\"users\")->select(\"nombre, apellidos as apell\")->get(); ``` Ahora ves a qué me refiero cuando digo que QueryBuilder es *casi* SQL, sin llegar a serlo. No tendrás que depurar el SQL, ni pelearte con comillas que se abren y cierran, ni nada de eso. QueryBuilder generará el SQL por ti a partir de expresiones como las que acabas de ver. En la [documentación oficial](https://laravel.com/docs/8.x/queries) encontrarás una referencia completa de todas las funciones de QueryBuilder, pero con estas que ves en el ejemplo puedes construir prácticamente cualquier consulta sencilla. ### 5.12.2. Colecciones El **resultado** de consultas como las que veíamos de ejemplo en el apartado anterior es bastante intuitivo: * O bien un **dato simple** (como el *$maxId* de la cuarta consulta, que es un entero). * O bien un **objeto de tipo Collection**. Las **colecciones de Laravel** tienen un montón de métodos útiles para procesarlas y puedes echarle un vistazo a la [documentación oficial](https://laravel.com/docs/8.x/collections) para ello, pero la mayor parte de las veces basta con hacer un *foreach* sobre la variable para ir accediendo a cada uno de los elementos, que se comportarán como objetos del tipo adecuado. Por ejemplo, para acceder a todos los registros de la tabla de usuarios: ```php $users = DB::table(\"users\")->get(); foreach ($users as $user) { echo $user->name; echo $user->email; ...etc... } ``` ### 5.12.3. Ventajas de QueryBuilder sobre SQL Como ves, QueryBuilder te permite construir sentencias SQL sin necesidad de escribir SQL. La **ventaja** de esto es triple: 1. No tendremos que depurar nuestros errores sintácticos en SQL, con el ahorro de tiempo que eso conlleva. 2. El SQL generado será 100% compatible con el gestor de base de datos que estemos utilizando. Si escribimos SQL en crudo, tendremos que adaptarlo al dialecto de nuestro gestor de base de datos. Y, si cambiamos de gestor, habrá que revisar todas las sentencias SQL para adaptarlas de nuevo. Todo esto lo evita QueryBuilder, puesto que hace esa adaptación por nosotros. 3. Es imposible que suframos un ataque por inyección de código, puesto que QueryBuilder no lo permitirá. ### 5.12.4. Relaciones entre tablas con QueryBuilder Las relaciones entre tablas se manejan con **joins**, como en SQL, solo que escritos al estilo QueryBuilder. Para hacer un **INNER JOIN**, puedes usar como referencia este ejemplo: ```php $users = DB::table('users') ->join('contacts', 'users.id', '=', 'contacts.user_id') ->join('orders', 'users.id', '=', 'orders.user_id') ->select('users.*', 'contacts.phone', 'orders.price') ->get(); ``` Por supuesto, también puedes hacer **LEFT JOIN** y **RIGHT JOIN**: ```php $resultado = DB::table('A')->leftJoin('B'...); $resultado = DB::table('A')->rightJoin('B'...); ``` ### 5.12.5. SQL crudo Por último, QueryBuilder también te permite **escribir SQL crudo**, es decir, SQL tal cual, si es que alguna vez lo necesitas. Eso sí, deberías valorar muy bien para qué narices quieres escribir SQL crudo. ¿Estás seguro/a de que eso que intentas hacer no se puede lograr más fácilmente con Eloquent o con QueryBuilder? Además, tendrás que extremar las precauciones ante un posible ataque por inyección de código. Si aún así no te he convencido, puedes ejecutar tu SQL crudo así: ```php $resultado = DB::raw('escribe-aquí-tu-sentencia-SQL'); ``` ",
    "url": "/docs/dwes/_site/laravel/querybuilder.html",
    "relUrl": "/laravel/querybuilder.html"
  },"37": {
    "doc": "5.13 Sesiones con Laravel",
    "title": "5.13 Sesiones con Laravel",
    "content": "## 5.13. Sesiones con Laravel {: .no_toc } - TOC {:toc} Como es lógico, Laravel también proporciona su propio sistema de manejo de **variables de sesión**, es decir, variables persistentes en el servidor asociadas a cada cliente. Las variables de sesión de Laravel son mucho más seguras y poderosas que las variables de sesión estándar de PHP. En esta sección vamos a ver cómo funcionan y qué posibilidades nos ofrecen las sesiones en Laravel. ### 5.13.1. Drivers de sesión Las sesiones de configuran en */config/sessions.php*, y una de las cosas que debes configurar ahí es el **driver** de sesión, es decir, el tipo de manejador que quieres que manipule las sesiones. * ***Files***: El driver por defecto es ***files***. Es el más sencillo y funcionará en casi cualquier servidor. Eso significa que Laravel guardará las variables de sesión en un fichero especial en el servidor (que nosotros no tenemos que manejar: Laravel se encargará de todo). * ***Memcached*** y ***redis***: El driver *files* es más que suficiente para una aplicación en desarrollo, pero para una aplicación en producción, Laravel recomienda usar otros *drivers* llamados ***memcached*** o ***redis*** porque son más rápidos. Ambos son *daemons* del sistema programados para esta tarea. Obviamente, el servidor debe soportarlos para que puedas usarlos. Consulta con tu proveedor o con tu administrador de sistemas la configuración de tu servidor web para saber si puedes usar alguno de estos dos *drivers*. Si no, tendrás que conformarte con *files*. * ***Database***: Si necesitas seguridad adicional, sin duda tu driver es ***database***. Esto almacenará dos copias de cada variable de sesión: una en un fichero y otra en una tabla especial de la base de datos. Si un atacante consiguiera manipular una de las dos variables, Laravel cerrará la sesión automáticamente y el atacante se quedará con un palmo de narices. Eso sí, este sistema es el más lento de todos porque requiere un acceso a la base de datos para cada petición al servidor. ### 5.13.2. Persistencia de las variables de sesión Laravel maneja dos tipos de variable según su persistencia: * **Variables flash**: solo duran una petición y luego desaparecen. * **Variables de sesión convencionales**: existen hasta que las destruimos expresamente. #### Variables flash Son variables de sesión que solo duran una petición y luego se *autodestruyen*. Se usan típicamente para enviar un *feedback* o mensaje de retroalimentación al usuario. Te lo muestro con un ejemplo. Imagina el típico formulario de *login*. En caso de producirse un error, lo habitual es que la aplicación nos muestre de nuevo ese formulario con un mensaje del tipo de \"Usuario no reconocido\". Para lograr eso, haríamos lo siguiente en el controlador. Observa el uso del método *with()* para crear una variable flash de sesión llamada *mensaje*: ```php return ('login/form')->with('mensaje', 'Usuario no reconocido'); ``` En la vista, podemos acceder a esa variable flash. Por ejemplo, así: ```php @if (session('mensaje')) {% raw %}{{ session('mensaje'); }}{% endraw %} @endif ``` A partir de este momento, la variable flash se destruye y cualquier intento de acceder a ella provocará un error de ejecución. #### Variables de sesión convencionales Las variables de sesión convencionales se manejan con la **clase *Session***, que tiene un montón de métodos estáticos para crear variables, destruirlas, consultarlas, etc. Los métodos más útiles son: * **put()** -> almacena una variable de sesión: ```php Session::put('nombre-variable', 'valor'); ``` * **push()** -> elimina una variable de sesión: ```php Session::push('nombre-variable'); ``` * **get()** -> devuelve el valor de una variable de sesión: ```php $v = Session::get('nombre-variable'); $v = Session::get('nombre-variable', 'valor-por-defecto'); ``` * **all()** -> devuelve todas las variables de sesión en un array: ```php $a = Session::all('nombre-variable', 'valor'); ``` * **flush()** -> elimina todas las variables de sesión: ```php Session::flush(); ``` * **flash()** -> crea manualmente una variable de sesión de tipo flash: ```php Session::flash('nombre-variable', 'valor'); ``` ### 5.13.3. Autenticación La autenticación de usuarios, es decir, el sistema de *login* seguido de la creación de una o varias variables de sesión asociadas al usuario que se acaba de loguear, es un componente habitual de muchas aplicaciones web. Hasta la versión 5, Laravel proporcionaba un sistema de autenticación integrado en su código que se podía añadir a nuestra aplicación con un simple comando de Artisan. Pero a partir de Laravel 6, los desarrolladores decidieron aligerar el núcleo de Laravel lo máximo posible, y sacaron del sistema muchos componentes, incluyendo el sistema de autencicación. Actualmente, Laravel proporciona los denominados *Starter Kits*, que son componentes que se pueden instalar mediante *composer* para realizar esas tareas que se extrajeron del núcleo de Laravel. Para la autenticación, Laravel dispone de dos *Starter Kits*, llamados ***Breeze*** y ***Jetstream***. Vamos a ver el primero, que es más sencillo pero suficiente en la mayor parte de las situaciones. ### 5.13.4. Laravel Breeze ***Larevel Breeze*** contiene todo el código necesario para crear un sistema de autenticación completo y seguro capaz, entre otras cosas, de: * Hacer el Login e iniciar la sesión * Registrar nuevos usuarios * Recuperar contraseñas olvidadas * Confirmaar el registro de usuarios mediante email Para **instalar *Laravel Breeze***, debes abrir un terminal en tu servidor web y ejecutar estos comandos: ``` $ composer require laravel/breeze --dev $ php artisan breeze:install $ npm install $ npm run dev $ php artisan migrate ``` El primer comando instalará las librerías PHP necesarias para que *Laravel Breeze* se ejecute. El segundo, añadirá *Breeze* a tu aplicación, creando automáticamente varios controladores, modelos, vistas y hasta migraciones. Los dos comandos *npm* sirven para compilar el CSS y el JS de *Breeze*, de manera que funcione más rápido. Por último, actualizamos las migraciones para que se creen las tablas adicionales que *Breeze* va a necesitar. Una vez hecho esto, *Breeze* creará automáticamente varias rutas en un enrutador especial, */routes/auth.php*. Entre ellas: ```php Routes::get(\"/login\") → Para mostrar el formulario de login Routes::post(\"/login\") → Para procesar el formulario de login Routes::post(\"/logout\") → Para cerrar la sesión Routes::get(\"/register\") → Para mostrar el fomulario de registro Routes::post(\"/register\") → Para procesar el formulario de registro ``` Puedes probarlas escribiéndolas en tu navegador. Comprobarás que funcionan estupendamente. También se crearán varios controladores como *LoginController* y *RegisterContoller*. Los puedes encontrar en *App/Http/Controllers/Auth*. Y, por supuesto, se crean varias vistas, como *auth/login.blade.php*, *register.blade.php* y *layouts/app.blade.php* (la plantilla que usarán *login* y *register*). Por último, se crea una vista *home* de ejemplo (*dashboard.blade.php*) a la que llegamos después de hacer login. Esa vista *home* la puedes cambiar en */app/providers/RouteServiceProvider.php* para redirigirla a la vista que te interese. ¡Y listo! Ya tienes hecho un sistema de login completo y superseguro. Solo te queda adaptar esas vistas y controladores a tus necesidades. ### 5.13.5. Autenticación y vistas: cómo generar código dependiendo del tipo de usuario En las vistas, tenemos un par de directivas de Blade muy útiles relacionadas con las sesiones: ***@auth*** y ***@guest***. Puedes ver cómo funcionan en este ejemplo: ```php @auth ... // Este código solo se ejecuta si existe un usuario logueado @endauth @guest ... // Este código solo se ejecuta si NO existe usuario logueado @endguest ``` Además, podemos acceder a los datos del usuario mediante la clase Auth: ```php $user = Auth::user() // Devuelve el usuario actualmente logueado o null si no hay ninguna sesión abierta. if (Auth::check()) { // Devuelve true si el usuario actual está logueado... } ``` (Más métodos de Auth en [la documentación oficial](https://laravel.com/docs/8.x/authentication)) ### 5.13.6. Autenticación y middlewares: cómo proteger los controladores Los **middlewares** de Laravel son componentes que capturan y filtran todas las peticiones HTTP que llegan a la aplicación. Literalmente, se ponen *en medio* de cualquier petición al servidor, y de ahí su nombre. Están ubicados en *App/Http/Middleware*. Hay dos *middlewares* importantes relacionados con la autenticación en Laravel: *Authenticate* (que tiene un alias: ***auth***) y *RedirectIfAuthenticated* (alias ***guest***). Los alias se definen en *App/Http/Kernel.php* Podemos usar estos *middlewares* en el constructor de nuestros controladores para protegerlos en todo o en parte. Es decir, para impedir el acceso de usuarios no logueados a ciertos métodos del controlador. Observa este ejemplo para aprender a hacerlo. Ya verás qué fácil y versátil es: ```php public function __construct() { // Solo usuarios logueados podrán acceder a cualquier función de este controlador: $this->middleware(\"auth\"); // Solo usuarios logueados podrán acceder a los métodos create() y edit(): $this->middleware(\"auth\")->only(\"create\", \"edit\"); // Solo usuarios logueados podrán acceder al controlador excepto a show(): $this->middleware(\"auth\")->except(\"show\"); } ``` El *middleware auth* también puede usarse en el enrutador, para proteger el acceso a una ruta concreta, así: ```php Route::get('/ruta-a-proteger', 'Controlador@metodo')->middleware('auth'); ``` ",
    "url": "/docs/dwes/_site/laravel/sesiones.html",
    "relUrl": "/laravel/sesiones.html"
  },"38": {
    "doc": "5.14 Helpers de Laravel",
    "title": "5.14 Helpers de Laravel",
    "content": "## 5.14. Helpers de Laravel {: .no_toc } - TOC {:toc} Los ***helpers*** son componentes de Laravel que hemos estado usando casi desde el principio sin darnos cuenta porque, como su propio nombre indica, nos ayudan a resolver pequeñas tareas tediosas. Ha llegado el momento de presentártelos formalmente, ¿no crees? ### 5.14.1. ¿Qué son los helpers? Un ***helper*** es un componente del framework diseñado para **facilitar alguna tarea** típica en el desarrollo de una aplicación web. Por ejemplo: el *helper url()* sirve para generar un ruta absoluta a partir de una relativa, de modo que la ruta absoluta siempre funcione, sea cual sea el servidor donde ejecutes la aplicación. Aquí puedes ver un ejemplo de uso de este *helper*: ```html Volver ``` Cuando el *helper url()* actúe, traducirá la expresión anterior por este código HTML: ```html Volver ``` Eso permite que la ruta sea correcta aunque muevas la aplicación de un servidor a otro, sin necesidad de modificar el código fuente. **El uso de los *helpers* es optativo**: solo son ayudantes, y el programador/a debe decidir si le resultan útiles o no. Los *helpers* cambian mucho de una versión a otra de Laravel, por lo que te recomiendo que eches un vistazo a la documentación oficial para saber qué *helpers* están disponibles en tu versión de Laravel. Puedes encontrar una lista completa de helpers en: [https://laravel.com/docs/X.x/helpers](https://laravel.com/docs/8.x/helpers) (sustituye X.x por tu versión de Laravel) ### 5.14.2. Algunos helpers útiles de Laravel #### 5.14.2.1. url helper Ya lo hemos visto en el ejemplo anterior. **Crea rutas absolutas** a enlaces de tu alicación a partir de rutas relativas. Las rutas absolutas siempre son más fiables, pero tienen el problema de que hay que cambiarlas si la aplicación cambia de servidor. Ese problema lo resuelve el *helper url()*. Se usa como en este ejemplo: ```html Volver ``` El código anterior generará este HTML: ```html Volver ``` #### 5.14.2.2. route helper Es parecido a *url()*, pero sirve para **rutas con nombre**. Por ejemplo, si en el enrutador tenemos una ruta con nombre como esta: ```php Route::get(\"mi-ruta\", \"metodo@mi-controlador\")->name(\"nombre-ruta\"); ``` ...podemos referirnos a ella en cualquier vista como: ```html Texto ``` ...o como: ```html Texto ``` La segunda forma es mejor que la primera, porque nos permite cambiar en cualquier momento la dirección que ve el usuario sin modificar el código fuente del resto de la aplicación. #### 5.14.2.3. request helper Este *helper* **proporciona información sobre la petición** (GET, POST o la que sea) con la que se cargó la página. El *helper request()* devuelve un objeto con varios métodos para acceder a esa información. Estos son los más útiles: * **request()->url()** → Devuelve un string con la ruta actual (completa). * **request()->path()** → Devuelve un string con la ruta actual (solo desde la raíz de la aplicación, sin http ni el nombre del servidor). * **request()->is(\"ruta\")** → Devuelve true si \"ruta\" coincide con la ruta actual. Admite wildcards (símbolos * y ?). * **request()->input(\"campo\")** → Devuelve el valor de \"campo\" (enviado desde formulario). * **request()->all()** → Devuelve un array con todos los campos. * **request()->has(\"campo\")** → Devuelve true si en la petición existe un campo con el nombre indicado. * **request()->isMethod(\"método\")** → Devuelve true si la petición se hizo por el método indicado (POST, GET, PUT, etc). El *helper request()* puede usarse en las vistas (como ```request()->url()```, por ejemplo) o inyectarse en las funciones del controlador como un argumento, así: ```php public function mi_función(Request $r) ``` En este último caso, podemos acceder a todos los datos enviados mediante un formulario a través del objeto $r. Por ejemplo: ```php public function mi_función(Request $r) { $name = $r->name; $email = $r->email; $pass = $r->password; ...etc... } ``` #### 5.14.2.4. redirect helper Muy útil cuando queremos **redirigir al usuario hacia otra URL o acción** (por ejemplo, para evitar que al pulsar F5 se reenvíen los datos de un formulario). Admite varias formas: ```php return redirect('user/login'); return redirect()->action('LoginController@login'); return back(); ``` #### 5.14.2.5. auth helper Como vimos en la sección de sesiones y autenticación, este helper permite **saber si existe algún usuario autenticado** en la aplicación. **auth()->user()** nos devolverá el usuario autenticado (como un objeto de tipo ***User***) o *null* si nadie ha hecho login. Con el objeto *User* podemos acceder a todos los datos del usuario. Por ejemplo: ```php $user = auth()->user(); Bienvenido/a, {% raw %}{{ $user->name }}{% endraw %}. Este es su email: {% raw %}{{ $user->email }}{% endraw %} ``` #### 5.14.2.6. errors helper Se utiliza para **conocer y mostrar los errores de validación de un formulario**. El objeto *$errors* está disponible en todas las vistas gracias a que un *Middleware* (*ShareErrorsFromSession*) la inyecta automáticamente. Algunos métodos útiles de este objeto son: * **$errors->all()** → devuelve un array con todos los errores detectados. * **$errors->any()** → devuelve true si se ha detectado algún error. * **$errors->first(\"campo\")** → devuelve el primer error de todos los que puedan afectar al campo indicado. ",
    "url": "/docs/dwes/_site/laravel/helpers.html",
    "relUrl": "/laravel/helpers.html"
  },"39": {
    "doc": "5.15 Flujo de trabajo típico con Laravel",
    "title": "5.15 Flujo de trabajo típico con Laravel",
    "content": "## 5.15. Flujo de trabajo típico con Laravel {: .no_toc } - TOC {:toc} Lo que vas a encontrar aquí es solo **un posible flujo de trabajo con Laravel**, es decir, una propuesta del orden en el que debes hacer las cosas para desarrollar una aplicación con este framework. No es el único flujo de trabajo posible, y sin duda no es el mejor, pero puede resultarte **útil en tus primeros desarrollos**, como si alguien te llevara de la mano a lo largo de un camino sinuoso. Más adelante, cuando vayas adquiriendo experiencia, tú mismo/a crearás tu propio flujo de trabajo ideal. El flujo que te propongo tiene los siguientes pasos (los cuatro primeros son solo para aplicaciones nuevas): 1. **Instalar y configurar la nueva aplicación.** 2. **Crear los modelos** (se supone que ya tendrás la BD diseñada). 3. **Crear las migraciones y los *seeders*.** 4. **Lanzar las migraciones y *seeders* para crear y poblar la BD.** 5. **Crear en el enrutador las entradas de la funcionalidad que vas a programar.** 6. **Crear el controlador (si no existe) para la funcionalidad que vas a programar.** 7. **Crear las funciones del controlador necesarias.** 8. **Crear las funciones del modelo necesarias (si no existen ya).** 9. **Crear las vistas necesarias.** 10. **Probar.** 11. **Repetir los pasos 5-10 para cada funcionalidad adicional.** ",
    "url": "/docs/dwes/_site/laravel/flujo-de-trabajo-con-laravel.html",
    "relUrl": "/laravel/flujo-de-trabajo-con-laravel.html"
  },"40": {
    "doc": "5.16 Aspectos avanzados de Laravel",
    "title": "5.16 Aspectos avanzados de Laravel",
    "content": "## 5.16. Aspectos avanzados de Laravel {: .no_toc } - TOC {:toc} En este apartado iremos añadiendo información breve sobre algunos aspectos avanzados de Laravel que no nos haya dado tiempo a tratar en las sesiones teóricas pero que surjan durante el desarrollo de los proyectos y sean interesantes. Algunos de esos aspectos pueden ser: * Cómo desplegar Laravel en (casi) caulquier servidor sin volverse loco * Cómo actualizar la versión de Laravel de una aplicación existente sin pegarse un tiro en el pie * Traducciones * *Testing* con Laravel * *Testing* con herramientas externas: Mockery y Selenium * Paginación de vistas * *Routes model bindings* * Validación avanzada de formularios con *form requests* * Laravel Mix para precompilación de CSS y Javascript * Cómo crear nuestros propios *helpers* y *middlewares* * Manipulación avanzada de las colecciones de Laravel (*collections*) * Eventos y *listeners* * Mejoras del rendimiento. Caché de Laravel * Decoradores e interfaces ",
    "url": "/docs/dwes/_site/laravel/aspectos-avanzados.html",
    "relUrl": "/laravel/aspectos-avanzados.html"
  },"41": {
    "doc": "5.17 CRUD desarrollado con Laravel",
    "title": "5.17 CRUD desarrollado con Laravel",
    "content": "## 5.17. CRUD desarrollado con Laravel: un ejemplo completo {: .no_toc } - TOC {:toc} Para finalizar esta introducción (sí, sí: aunque haya sido muy largo, no es más que una introducción) a Laravel, vamos a **desarrollar una pequeña aplicación web desde cero**. Se tratará, en realidad, de un fragmento de otra aplicación más grande: una tienda online o tal vez un sistema de gestión de almacén. Da lo mismo. Nosotros vamos a desarrollar la parte de **mantenimiento de productos**. Para ello, supondremos que en la base de datos existe una tabla llamada *products* con los campos *id, name, description* y *price*. Vamos a construir el controlador, el modelo y las vistas necesarias para hacer el **CRUD completo** (create-read-update-delete) de esta tabla con Laravel, sin olvidarnos de las migraciones, los seeders y, por supuesto, el enrutador. ¿Estás preparado/a? Pues vamos allá. ### Migraciones Para esta miniaplicación solo necesitamos una migración, puesto que solo tenemos que crear una tabla. La migración se crea con el comando ```php artisan make:migration create_table_products``` y se escribe en el archivo ***/database/migrations/_timestamp_create_products_table.php***, que tendrá este contenido: ```php id(); $table->string('name', 100); $table->string('description', 500); $table->double('price', 5, 2); $table->timestamps(); }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::dropIfExists('products'); } } ``` ### Seeders En este *seeder* vamos a cargar unos cuantos datos de prueba. Obviamente, puedes cambiarlos por los que tú quieras. El seeder se crea con el comando ```php artisan make:seeder ProductTableSeeder```, eque generará el archivo ***/database/seeders/ProductTableSeeder.php***. Recuerda que, para poder lanzar el seeder automáticamente con ```php artisan migrate:fresh --seed``` u otro comando similar, tienes que editar el archivo *DatabaseSeeder.php* y añadir el *seeder* de productos. Si no recuerdas cómo hacerlo, consulta la sección de este tema dedicada a las migraciones. En cualquier caso, siempre puedes lanzar el *seeder* manualmente en cualquier momento con ```php artisan db:seed --class=ProductTableSeeder```. ```php insert([ 'name' => 'Papel higiénico', 'description' => 'Papel higiénico extrasuave para glúteos sensibles', 'price' => '1.35', ]); DB::table('products')->insert([ 'name' => 'Lejía blanca 1L', 'description' => 'Lejía pura capaz de traladrar las baldosas', 'price' => '0.95', ]); DB::table('products')->insert([ 'name' => 'Detergente Ariel 1.5L', 'description' => 'Detergente líquido para lavadoras', 'price' => '4.90', ]); DB::table('products')->insert([ 'name' => 'Gel Hidroalcohólico 350ml', 'description' => 'Gel hidroalcólico sin perfume, 70% de alcohol', 'price' => '3.50', ]); DB::table('products')->insert([ 'name' => 'Gel de baño con avena - 750 ml', 'description' => 'Gel de baño con aceites vegetales, hipoalergénico', 'price' => '1.50', ]); } } ``` ### Enrutador El enrutador de la aplicación está en ***/routes/web.php***. Basta con abrirlo y añadir esta línea: ```php Route::resource('products', 'ProductController'); ``` Alternativamente, podrías crear a mano las siete entradas correspondientes a las **siete rutas de un servidor REST**, así: ```php Route::get('product', 'ProductController@index')->name('product.index'); Route::get('product/{product}', 'ProductController@show')->name('product.show'); Route::get('product/create', 'ProductController@create')->name('product.create'); Route::post('product/{product}', 'ProductController@store')->name('product.store'); Route::get('product/{product}/edit', 'ProductController@edit')->name('product.edit'); Route::patch('product/{product}', 'ProductController@update')->name('product.update'); Route::delete('product/{product}', 'ProductController@destroy')->name('product.destroy'); ``` El resultado sería el mismo, pero si defines manualmente las rutas, tienes más control sobre cómo son exactamente. Por ejemplo, puedes traducirlas a español (¿qué tal cambiar \"product/create\" por \"producto/crear\"?). O podrías hacer algún cambio más profundo a nivel técnico. Por ejemplo, que la petición para hacer *delete* llegue por GET en lugar de por DELETE (así no tendrías que usar un botón de formulario para lanzar el borrado de un producto y podrías lanzarlo con un link). Eso sí: ten en cuenta que, si haces algún cambio de este tipo en las rutas, tu servidor ya no será 100% REST. Hay una posibilidad intermedia: respetar las 7 rutas estándar REST y *añadir* alguna adicional que te venga bien, como el borrado mediante GET. Algo así: ```php // Estas son las 7 rutas estándar REST: Route::resource('products', 'ProductController'); // Añadimos una ruta NO ESTÁNDAR para borrar productos mediante GET Route::get('product/delete/{product}', 'ProductController@destroy')->name('product.myDestroy'); ``` ### Controlador El controlador de productos se crea con el comando ```php artisan make:controller ProductController```. El archivo se generará en ***/app/Http/Controllers/ProductController.php***. Tendrás que rellenar el código de los 7 métodos REST con algo como esto:: ```php $productList]); } public function show($id) { $p = Product::find($id); $data['product'] = $p; return view('product.show', $data); } public function create() { return view('product.form'); } public function store(Request $r) { $p = new Product(); $p->name = $r->name; $p->description = $r->description; $p->price = $r->price; $p->save(); return redirect()->route('product.index'); } public function edit($id) { $product = Product::find($id); return view('product.form', array('product' => $product)); } public function update($id, Request $r) { $p = Product::find($id); $p->name = $r->name; $p->description = $r->description; $p->price = $r->price; $p->save(); return redirect()->route('product.index'); } public function destroy($id) { $p = Product::find($id); $p->delete(); return redirect()->route('product.index'); } } ``` ### Modelo El modelo se crea con el comando ```php artisan make:model Product```. El archivo con el modelo se generará en ***app/models/product.php***. No es necesario que toques este archivo: puedes dejarlo, de momento, tal y como lo ha generado Artisan. ### Vista: plantilla principal La plantilla principal o *master layout* debes crearla en ***views/layouts/master.blade.php***. Por supuesto, puedes hacerla como quieras. Aquí te propongo un *master layout* muy sencillito al que luego le podrás ir añadiendo cosas fácilmente: ```html @yield('title') . @section('sidebar') Este es mi master sidebar. @show @yield('content') . ``` ### Vista: todos los productos La vista con todos los productos la llamaremos ***views/products/all.blade.php*** y puede tener un aspecto como este: ```html @extends(\"layouts.master\") @section(\"title\", \"Administración de productos\") @section(\"header\", \"Administración de productos\") @section(\"content\") Nuevo @foreach ($productList as $product) | {% raw %}\"{{$product->name}}{% endraw %}\" | {% raw %}\"{{$product->description}}{% endraw %}\" | {% raw %}\"{{$product->price}}{% endraw %}\" | id)}{% endraw %}\"}\">Modificar | id)}{% endraw %}\"}\" method=\"POST\"> @csrf @method(\"DELETE\") | @endforeach @endsection ``` ### Vista: creación/modificación de productos Reutilizaremos la vista para crear y modificar productos, puesto que son prácticamente iguales. El archivo de la vista será ***views/products/form.blade.php***, y su contenido puede ser algo así: ```html @extends(\"layouts.master\") @section(\"title\", \"Inserción de productos\") @section(\"header\", \"Inserción de productos\") @section(\"content\") @isset($product) $product->id]) }}{% endraw %}\"\" method=\"POST\"> @method(\"PUT\") @else @endisset @csrf Nombre del producto:name ?? '' }}{% endraw %}\"\"> Descripción:description ?? '' }}{% endraw %}\"\"> Precio:price ?? '' }}{% endraw %}\"\"> @endsection ``` Observa cómo se genera una cabecera de formulario distinta según se vaya a usar el formulario para crear o para modificar un producto. Asímismo, fíjate en cómo se rellenan los atributos *value* de los campos del formulario con los datos actuales del producto (en caso de que existan). ### ¿Y ahora qué? Ahora ha llegado el momento de comprobar si tu aplicación funciona. Primero, lanza las migraciones y los seeders con ```php artisan migrate:fresh --seed```. Asegúrate de haber añadido tu seeder de productos a *DatabaseSeeder.php* para que se lance automáticamente tras las migraciones. Si todo va bien, la aplicación estará lista para responder en **https://tu-servidor-local/product** El código que hemos mostrado hasta aquí solo es un pequeño ejemplo y se puede mejorar de muchísimas maneras, por supuesto. Estas son algunas mejoras evidentes: * Programar la vista **product/show.blade.php**, que está ausente en el código anterior. Esa es la vista que mostrará un producto individual. Si intentas lanzarla ahora pidiendo la ruta *https://tu-servidor/product/1* (sustituye 1 por el ID de cualquier producto), verás que Laravel te da un error de \"View not found\". * Se puede simplificar el método *store()* del controlador haciendo una asignación masiva. Bastaría con indicar en el modelo que todos los campos de la tabla son *fillables* para poder hacer en el método *store()* del controlador algo como esto: ```$p = new Product($r->all())``` * Se puede alterar el aspecto visual de la aplicación trabajando el *master layout* y añadiendo ahí algo de CSS y/o Javascript, sin que haya que tocar el resto de vistas. * A partir de ahí, habría que seguir construyendo la aplicación, añadiendo más tablas con su correspondientes controladores, modelos y vistas. Llegará un momento en el que tendremos que crear las relaciones entre las tablas en los modelos, como explicamos en el apartado dedicado a Eloquent. * Otro paso lógico, común a muchas aplicaciones web, sería añadir un sistema de autenticación con **Laravel Breeze**. Utiliza este código fuente como punto de partida para tus propios desarrollos con Laravel. Cuando hayas cogido un poco de práctica, verás que resulta mucho más rápido montar una aplicación web convencional con Laravel que hacerlo con PHP clásico. ",
    "url": "/docs/dwes/_site/laravel/crud-con-laravel.html",
    "relUrl": "/laravel/crud-con-laravel.html"
  },"42": {
    "doc": "5.2 Características de Laravel",
    "title": "5.2 Características de Laravel",
    "content": "## 5.2. Características de Laravel {: .no_toc } - TOC {:toc} **Laravel es un framework PHP MVC para desarrollo rápido de aplicaciones web**. Automatiza muchos procesos habituales y tiene una curva de aprendizaje empinada, pero no tanto como otros frameworks (con \"otros\" queremos decir \"Symfony\", que es, sin duda, el framework más difícil de aprender). Desde hace algunos años, Laravel ha experimentado un crecimiento espectacular en el mercado de las aplicaciones web. ### 5.2.1. Ventajas de Laravel Para ir abriendo boca, te cuento algunos de los puntos fuertes que tiene Laravel: 1. Sintaxis simple y elegante. 2. Mapeo objeto-relacional (ORM): Eloquent. 3. Potente sistema de plantillas para vistas: Blade. 4. Reutiliza y moderniza componentes de Symfony. 5. Es sencillo (esto es un decir) y potente. 6. Uso creciente en la industria: es previsible que domine el mercado durante los próximos años. 7. Comunidad de usuarios altamente especializada (buena relación señal/ruido, al menos de momento) ### 5.2.2. Inconvenientes de Laravel Como no hay nada perfecto, es evidente que Laravel también tiene algunos defectillos. Entre ellos, estos: 1. Instalación, configuración y despliegue complejos, incluso a través de servicios de virtualización. 2. Curva de aprendizaje elevada. 3. Se mueve según los intereses personales de su autor (es obra individual), con actualizaciones muy frecuentes y cambios caprichosos. Las actualizaciones pueden ser un quebradero de cabeza. 4. Inestabilidad de varios de sus componentes: a menudo hay que recurrir a *fixes* o a componentes de terceros. 5. Fuerte dependencia de la consola de comandos y de herramientas de terceros (composer, vagrant, npm...). Esto, por supuesto, solo es un inconveniente para las personas que tengan alergia a la consola de comandos. ",
    "url": "/docs/dwes/_site/laravel/caracteristicas.html",
    "relUrl": "/laravel/caracteristicas.html"
  },"43": {
    "doc": "5.3 Instalación de Laravel",
    "title": "5.3 Instalación de Laravel",
    "content": "## 5.3. Instalación de Laravel {: .no_toc } - TOC {:toc} En esta sección vamos a describir el proceso de instalación de Laravel en un servidor local para desarrollo. Hay, básicamente, tres posibilidades: 1. **Usar un servidor Apache (o similar) local y configurarlo adecuadamente** para que Laravel funcione. 2. **Usar un servidor virtualizado mediante Vagrant**. 3. **Usar un servidor virtualizado mediante Docker**. Vagrant y Docker son dos soluciones de virtualización muy utilizadas últimamente. La virtualización es un campo fascinante y en la cresta de la ola. Lamentablemente, aquí no tenemos ni tiempo ni espacio para hablarte largo y tendido sobre ello, por lo que nos limitaremos a explicarte los pasos que debes seguir para montar tu servidor virtualizado y ponerte a trabajar con Laravel, sin entrar en otros detalles. Si quieres aprender más sobre Vagrant: [https://www.vagrantup.com/docs](https://www.vagrantup.com/docs) Si quieres aprender más sobre Docker: [https://docs.docker.com/](https://docs.docker.com/) ### 5.3.1. Instalación nativa en servidor local **No es recomendable instalar Laravel de forma nativa en tu servidor local** porque requiere una fuerte configuración del servidor. Tendrás que instalar bastante librerías que consumirán recursos de tu máquina sin necesidad, tales como OpenSSL, Mbstring o Tokenizer. También necesitarás instalar composer, la herramienta de resolución de dependencias de PHP. Por todo ello, los desarrolladores de Laravel aconsejan **virtualizar el servidor**. Esto lo podemos hacer mediante **Vagrant** o **Docker**. Discutiremos estas dos opciones más adelante. Si, aún así, estás decidido a instalar Laravel de forma nativa en tu servidor local, sigue estos pasos: #### **Paso 1** Instala todo el software de servidor necesario para que Laravel funcione. Empieza por instalar **composer**, la herramienta de instalación de dependencias de PHP. Después, durante la instalación de Laravel, el propio composer se encargará de instalar el resto del software necesario. Si no puede instalar algo, ya te avisará para que lo hagas tú manualmente. #### **Paso 2** Descarga Laravel usando composer. ``` $ composer global require \"laravel/installer\" ``` #### **Paso 3** Instala una copia de Laravel limpia y lista para usar (en un directorio accesible por Apache o el servidor web que estés usando, claro). Puede ser que tengas que añadir el comando *laravel* al PATH del sistema. ``` $ laravel new ``` Por ejemplo: ``` $ laravel new blog ``` No olvides dar los permisos necesarios a tus archivos y directorios. #### Problemas frecuentes Lamentablemente, la lista de posibles problemas que pueden surgir durante una instalación nativa de Laravel son tantos y tan variados, dependiendo de la configuración de tu servidor, que sería imposible dar una lista exhaustiva. Te vuelvo a recordar que *los desarrolladores de Laravel desaconsejan instalarlo de este modo*, pero allá tú. Si sigues empeñado/a en hacerlo, puedes intentar seguir alguna de estas guías: * [Guía para instalar Laravel en localhost en Ubuntu Linux](https://www.howtoforge.com/tutorial/install-laravel-on-ubuntu-for-apache/) * [Guía para instalar Laravel en localhost con Windows y XAMPP:](https://weeklyhow.com/installing-laravel-8-with-xampp/) ### 5.3.2. Instalación de Laravel con máquina virtual Vagrant (Homestead) **Vagrant** es una herramienta para crear un entorno de desarrollo virtual portable sin necesidad de instalar componentes en nuestra máquina. Utiliza de forma transparente alguna otra tecnología de virtualización, como VirtualBox, VMWare, Docker o KVM. Con Vagrant se pueden crear entornos de desarrollo perfectamente configurados que luego podemos replicar con un simple comando cad vez que los necesitemos. Esto agiliza mucho el proceso de configuración de nuestro servidor web. Cada entorno de desarrollo configurado con Vagrant se llama **Box**. Hay cientos de *boxes* ya configurados que podemos usar, o podemos definir los nuestros propios. Pues bien, **Homestead** es un Box de Vagrant con todo lo necesario para desarrollar con Laravel sin necesidad de configurar nada en nuestro servidor local. Este Box, creado por los propios desarrolladores de Laravel, puede adaptarse para equipararlo al servidor donde se vaya a desplegar la aplicación en el futuro. La instalación de Laravel por medio de Homestead **es la forma recomendada para desarrollar proyectos Laravel en un entorno local**. La puesta en producción es otra historia, y dependerá de las posibilidades de configuración del servidor. Instalar Laravel con Homestead en tu entorno local puede parecer un proceso largo y complejo, pero no suele dar problemas y la fiabilidad de está solución está garantizada, por lo que es la manera más recomendable. Si deseas instalarlo, sigue estos pasos: #### **Paso 1** Instala en tu ordenador la última versión disponible de Virtual Box. #### **Paso 2** Instala también Vagrant y git (si aún no lo tenías instalado) #### **Paso 3** Agrega a Vagrant el box de Homestead con este comando: ``` $ vagrant box add laravel/homestead ``` #### **Paso 4** Consigue el último código fuente de Laravel: ``` $ git clone https://github.com/laravel/homestead.git ~/Homestead ``` #### **Paso 5** Selecciona la rama \"release\" del repositorio de Laravel y lanza el script de inicialización: ``` $ cd Homestead $ git checkout release $ bash init.sh (o init.bat en Windows) ``` #### **Paso 6** Edita el archivo Homestead.yaml para configurar tu máquina virtual. Es un archivo bastante sencillo de entender. Normalmente, basta con ajustar los nombres de las carpetas. #### **Paso 7** Edita el archivo hosts de tu sistema (/etc/hosts en Linux o C:\\Windows\\System32\\drivers\\etc\\hosts en Windows) para añadir esta línea: ``` 192.168.10.10 homestead.test ``` (En el archivo .yaml puedes configurar otra IP para tu máquina virtual si lo prefieres) #### **Paso 8** Levanta la máquina virtual Homestead: ``` $ vagrant up ``` (Este comando hay que ejecutarlo desde el directorio Homestead) La primera vez puede tardar un rato mientras crea y configura la VM. #### **Paso 9** Prueba en el navegador la dirección: http://homestead.test. El servidor debería responder. #### **Paso 10** Prueba a acceder a la VM mediante ssh con el comando: ``` $ vagrant ssh ``` #### **Paso 11** En la máquina real, crea el directorio ~/code (o el que esté configurado en el archivo Homestead.yaml). #### **Paso 12** En la máquina virtual, a la que te habrás conectado con ```$ vagrant ssh```, ve al mismo directorio ~/code (o el que esté configurado en Homestead.yaml) y actualiza las librerías PHP con composer: ``` $ composer create-project laravel/laravel code --prefer-dist $ composer install ``` ¡Y listo! A partir de ahora, tú trabajarás en tu directorio local ~/code y cualquier cambio que hagas se mapeará automáticamente al directorio ~/code en la VM. Mantén todo el tiempo una consola abierta en la VM para ejecutar los comandos que vayas necesitando, que con Laravel serán muchos. Ten en cuenta que MySQL estará escuchando en 127.0.0.1:33060 (con el user “Homestead” y la password “secret”, salvo que hayas cambiado la configuración), pero ojo: esto solo es para conexiones desde *fuera* de Homestead. Desde el punto de vista de la app, MySQL seguirá estando en localhost:3306. Dependiendo de tu versión de Laravel, es posible que necesites generar una clave SSH para conexiones seguras con tu servidor virtual. Aquí tienes un par de enlaces sobre como hacerlo: * [Cómo hacerlo en Linux](https://ekiketa.es/fallo-en-homestead-check-your-homestead-yaml-file-the-path-to-your-private-key-does-not-exist/) * [Cómo hacerlo en Windows 10](https://medium.com/@eaimanshoshi/i-am-going-to-write-down-step-by-step-procedure-to-setup-homestead-for-laravel-5-2-17491a423aa) Más información sobre el proceso de instalacion de Homestead en [https://laravel.com/docs/8.X/homestead](https://laravel.com/docs/8.X/homestead) ### 5.3.3. Laravel con Docker **Docker** es una solución de virtualización aún más ligera que Vagrant. Con Docker, se virtualizan solo los servicios de software que nuestra aplicación necesita para funcionar (en lugar de la máquina completa, como haría Virtual Box, por ejemplo), y se ejecutan directamente en la máquina anfitrión. Los servicios virtualizados se agrupan en conjuntos llamados ***images***. Cuando una *image* se instancia (como quien instancia una clase en programación orientada a objetos), pasan de denominarse ***containers***. Hay *docker images* para todo lo imaginable. Puedes encontrarlas en [https://hub.docker.com](https://hub.docker.com). Aunque Laravel recomienda la virtualización mediante Vagrant, muchos desarrolladores optan por Docker. Así que, si prefieres instalar Laravel mediante Docker para un desarrollo local, sigue estos pasos: #### **Paso 1** **Instala *docker*** y, optativamente, otra herramienta llamada ***docker-compose***, en tu ordenador. Descárgalos de la web del desarrollador ([https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)) o de los repositorios oficiales de tu distribución, si estás usando GNU/Linux. *docker-compose* es una utilidad de Docker para instanciar simultáneamente varios contenedores configurados, por lo que no es mala idea tenerla instalada junto con Docker. #### **Paso 2** **Busca una *docker image*** para desarrollo con Laravel en [https://hub.docker.com](https://hub.docker.com). Por ejemplo, Bitnami (una empresa propiedad de VMWare) tiene imágenes bastante fiables. La imagen de Bitnami para Docker se denomina bitnami/docker. #### **Paso 3** **Crea una carpeta para almacenar el código** de tu aplicación web en tu disco duro. No importa en qué parte del árbol de directorios local estés. #### **Paso 4** En la consola, teclea el comando para crear una **copia local de las imágenes necesarias**. En el caso de la imagen Laravel de Bitnami, el comando es: ``` $ docker pull bitnami/laravel ``` El nombre de la *docker image* vendrá en la documentación de la propia imagen en https://hub.docker.com #### **Paso 5** Sigue las instrucciones para el **despliegue del contenedor**. El desarrollador de la *docker image* habrá documentado este proceso en https://hub.docker.com. En el caso de la imagen bitnami/laravel, hay que copiar un archivo remoto mediante el comando *curl* y levantar las imágenes docker con *docker-compose*. ``` $ curl -LO https://raw.githubusercontent.com/bitnami/bitnami-docker-laravel/master/docker-compose.yml $ docker-compose up ``` ¡Y listo! Nuestro Laravel estará funcionando con todas sus dependencias resueltas. ",
    "url": "/docs/dwes/_site/laravel/instalacion.html",
    "relUrl": "/laravel/instalacion.html"
  },"44": {
    "doc": "5.4 Arquitectura, convenciones y configuración de Laravel",
    "title": "5.4 Arquitectura, convenciones y configuración de Laravel",
    "content": "## 5.4. Arquitectura, convenciones y configuración de Laravel {: .no_toc } - TOC {:toc} Como cualquier framework, Laravel sigue una serie de convenciones para los identificadores, la estructura de directorios de la aplicación y la configuración. Aunque no es imprescindible seguir esas convenciones, y puede resultar un poco enojoso las primeras veces (en plan: ¿pero por qué tengo que llamar a esa clase así, si quiero llamarla de otro modo?), a la larga el uso de convenciones ahorra muchísimo tiempo de desarrollo y, sobre todo, de depuración. ¿Cuántas veces no has estado depurando un error consistente en haber olvidado que el nombre de una tabla de la base de datos lo habías escrito en plural y no en singular, o al revés? **\"Convención sobre configuración\"** es un lema de muchos frameworks. Quiere decir que, si seguimos las convenciones del framework, tanto si nos gustan como si no, nos ahorraremos mucho tiempo de discusión sobre la configuración y muchos quebraderos de cabeza posteriormente. ### 5.4.1. Estructura de directorios Después de una instalación limpia de Laravel, nos encotraremos con una estructura típica de directorios que hay que respetar. Los más importantes (al menos, para empezar) son estos: **composer.json**: información para composer (ya sabes, el administrador de paquetes de PHP). Sirve para instalar todas las librerías de terceros que Laravel necesita para funcionar. Imprescindible para instalar la aplicación en otro servidor. **/app**: el código de nuestra aplicación. Aquí están los **modelos**. **/app/config**: configuración de la aplicación. **/app/http**: peticiones HTTP, incluyendo los **controladores**. **/database**: migraciones y *seeders* de la base de datos. Las migraciones son muy importantes y les dedicaremos un apartado más adelante. **/plugins**: pues eso. **/public**: directorio de acceso público. Aquí Laravel generará todo lo que hay que mover al servidor para poner la web en producción. Puedes crear aquí dentro carpetas para colocar imágenes, scripts JS o archivos css. **/resources**: Aquí dentro están las **vistas**. También el resto de *assets* (imágenes, css, js). A diferencia del directorio public, los archivos JS o css que coloquemos aquí estarán precompilados no serán accesibles vía web y, lo que es más importante, podemos crear archivos Less, Sass, JS y varios frameworks JS, y Laravel se encargará de compilarlos automáticamente y generar versiones minimizadas de nuestro CSS y nuestro JS. De momento, vamos a colocar nuestro CSS y nuestro JS en la carpeta /public. Más adelante puedes trastear con /resources si lo deseas. **/storage**: aquí Laravel guarda su memoria caché, información sobre las sesiones, vistas compiladas... No debes tocar esta carpeta para nada. **/vendors**: librerías de terceros. Es **importante** añadir esta carpeta al .gitignore si vas a construir un repositorio git para tu aplicación Laravel, porque /vendors puede ocupar bastante espacio y no tiene sentido incluirla en tu proyecto. Si necesitas desplegar esta aplicación Laravel en otro servidor, basta con clonar el repositorio y ejecutar ```composer update```. Eso *rellenará* la carpeta /vendor con las librerías más adecuadas para ese servidor. ### 5.4.2. Convenciones en Laravel Laravel tiene un montón de convenciones que persiguen hacer más sencilla la configuración de la aplicación y evitar errores tontos que pueden consumir mucho tiempo de depuración. Aunque la mayoría de estas convenciones no son obligatorias, es recomendable respetarlas para ahorrarte quebraderos de cabeza posteriores. * En primer lugar, usa solo **identificadores en inglés**. Mejor *User* que *Usuario*. Así, de paso, practicas un poco el idioma universal de la informática. * **Modelos**: Los nombres de los modelos deben ser iguales a los de las tablas de la base de datos, pero en singular, en CamelCase y con mayúscula. Ejemplo: *RegisteredUser* * **Controladores**: Llámalos como los modelos, pero añadiendo la palabra \"controller\". Ejempo: *RegisteredUserController* * **Métodos**: Se nombran en camelCase yt empezando con minúscula. Ejemplo: *RegisteredUser::getAll()* * **Atributos**: Se nombran en en snake_case y empezando con minúscula. Ejemplo: *RegisteredUser::first_name* * **Variables**: Los identificadores deben ir en camelCase y empezando con minúscula. En plural si se trata de una colección y en singular si es un objeto individual o una variable simple. Ejemplos: *bannedUsers* (colección, en plural), *articleContent* (objeto individual, en sigular) * **Tablas**: Se nombran en plural y en snake_case. Ejemplo: registered_users. * **Columnas de las tablas**: Se nombran en snake_case, sin referencia al nombre de la tabla. Ejemplo: first_name * **Clave primaria**: La llamaremos *id*. Siempre. No le des más vueltas. *id* y punto. El tipo: integer y *auto-increment*. * **Claves ajenas**: Se forman con el nombre de la tabla ajena en singular más la palabra *id*. Ejemplo: *article_id* * **Timestamps**: Laravel siempre crea marcas de tiempo para todo. Y siempre se llaman *created_at* y *updated_at*, de tipo *datetime*. Acostúmbrate a tenerlas en todas tus tablas. * **Tablas pivote**: Son esas tablas horribles formadas como resultado de una relación N:N entre dos tablas maestras. Se nombran en snake_case, en plural y orden alfabético. Ejemplo: *articles_users* será el pivote entre las tablas *articles* y *users*. ### 5.4.3. Variables de entorno. El archivo .env En el directorio raíz de toda aplicación hecha con Laravel existe un archivo muy especial llamado ***.env***. Ojo, porque en los sistemas tipo Linux, todos los archivos cuyo nombre empieza por un punto están ocultos. Debes buscar la opción para mostrar los archivos ocultos de tu navegador de archivos si quieres verlo. Este archivo contiene todas las variables de entorno que configuran la aplicación, como: * APP_ENV: En esta variable se indica si la aplicación está en desarrollo o en producción * APP_DEBUG: ¿Queremos mostrar los errores para depuración? Se pone a *true* durante el desarrollo y se cambia a *false* al pasar a producción. * APP_URL: La URL base de la aplicación. Hay que modificarla cuando movemos la aplicación a otro servidor. * DB_CONNECTION, DB_HOST, DB_USERNAME, etc. Es decir, la configuración de la conexión a la base de datos. Una instalación limpia de Laravel vendrá con un archivo llamado ***example.env***, que contiene una plantilla para que puedas construir tu propio archivo .env. Simplemente, renombra el archivo example.env y asigna los valores correctos a las variables de entorno. Cuidado: *el archivo .env NO debe sincronizarse con git* (o con el control de versiones que usemos) porque contiene información sensible. Asegúrate de incluirlo en tu *.gitignore*. Consulta la sección sobre Git de este mismo manual si no sabes como hacerlo. Una vez creado nuestro archivo .env, podemos usar las variables definidas en él en cualquier otra parte de la aplicación. Por ejemplo, en */config/database.php* usaremos una expresión así: ```php 'default' => env('DB_CONNECTION', 'mysql') ``` El primer parámetro de *env()* es la variable de entorno que queremos consultar y el segundo es el valor por defecto en caso de que la variable no exista. ### 5.4.4. Archivos de configuración del directorio /config En este directorio encontraremos multitud de archivos que configuran el funcionamiento de Laravel. En principio, no es necesario modificar ninguno, porque las configuraciones básicas se manejan desde el archivo .env. Sin embargo, hay situaciones en las que sí necesitaremos acceder a estos archivos y tocar alguna configuración. Algunos archivos de configuración importantes que puedes encontrar aquí son: * **database.php**: configuración de la conexión a la base de datos. Toma sus valores principales de .env, pero desde aquí podemos cambiar otras cosas, como el controlador (por defecto es MySQL, pero podemos cambiarlo a PostgreSQL, SQLite, etc). * **app.php**: nombre de la aplicación, estado (desarrollo, producción...). * **session.php**: forma en la que se almacenarán las variables de sesión (por defecto, en un fichero en el servidor). ",
    "url": "/docs/dwes/_site/laravel/arquitectura-convenciones-configuracion.html",
    "relUrl": "/laravel/arquitectura-convenciones-configuracion.html"
  },"45": {
    "doc": "5.5 Artisan, la consola que mola",
    "title": "5.5 Artisan, la consola que mola",
    "content": "## 5.5. Artisan, la consola que mola {: .no_toc } - TOC {:toc} Laravel viene de serie con una utilidad de consola de comandos llamada ***Artisan***. Con *Artisan* se automatizan montones de tareas habituales del trabajo con Laravel, así que acostúmbrate a tener siempre abierto un terminal de texto en el directorio raíz de tu aplicación. En esta sección vamos a aprender a utilizar los comandos básicos de Artisan. ### 5.5.1. ¿Qué es Artisan y cómo se utiliza? Como hemos dicho, **Artisan** es una herramienta de consola, escrita en PHP, que viene con Laravel para **ayudarte a realizar tareas cotidianas en tu aplicación de forma automatizada**. Algunas de esas tareas que automatiza Artisan son: * Generar esqueletos de controladores y modelos. * Crear migraciones de bases de datos (para manipular la estructura de las tablas, como enseguida veremos). * Rellenar la BD con datos de prueba. * Hacer el enrutamiento. * Configurar la aplicación. * Crear baterías de pruebas. * Gestionar la caché de Laravel (una memoria intermedia generada por Laravel que hace que tu aplicación se cargue más rápido). Y así otro montón de cosas. No te preocupes si aún no entiendes qué significan algunas de estas cosas. Lo iremos viendo todo poco a poco. Lo importante ahora es que comprendas la tremenda utilidad de Artisan en el trabajo cotidiano con Laravel y que aprendas lo básico de su sintaxis. ### 5.5.2. Un ejemplo práctico: crear un controlador Veamos cómo funciona Artisan con un ejemplo. Supongamos que quieres crear un controlador. Para ello, existen dos maneras: 1. **A mano**. Nos vamos al directorio /app/Http/Controllers y creamos un archivo llamado, digamos, *HolaController.php*. Luego lo rellenamos con el esqueleto de un controlador vacío, copiando y pegando de otro controlador existente y eliminando todo lo que no nos haga falta. Este método, obviamente, es lento, farragoso y resulta fácil que cometamos algún error. 2. **Con Artisan**. Simplemente, tecleamos este comando en el directorio raíz de nuestra aplicación: ``` $ php artisan make:controller HolaController ``` ¡Hemos terminado! Artisan creará por nosotros el archivo /app/Http/Controllers/HolaController.php y lo rellenará con el esqueleto de un controlador vacío y sintácticamente correcto. ### 5.5.3. Artisan y máquinas virtuales Si utilizas Laravel con una máquina virtual (Vagrant/Homestead o Docker), es importante que recuerdes esto: *tienes que hacer login en la máquina virtual para poder usar ejecutar los comandos de Artisan*. Las primeras veces se te olvidará. Intentarás ejecutar comandos de Artisan en tu máquina real y te dará un error, porque Artisan no está allí instalado, sino en tu servidor (es decir, en tu máquina virtual). 1. Si usas **Vagrant/Homestead**, debes loguearte en la máquina virtual así: ``` $ vagrant ssh ``` 2. Si usas **Docker**, abre una terminal en tu máquina virtual con este comando: ``` $ docker exec -it bash ``` (Si desconoces el id de tu contenedor, puedes averiguarlo con el comando ```$ docker container ls```) Una vez dentro de la máquina virtual, accede al directorio de tu aplicación y podrás ejecutar cualquier comando de Artisan. ### 5.5.4. Comandos principales de Artisan Una buena forma de empezar con Artisan es teclear este comando: ``` $ php artisan list ``` Ya te imaginas lo que hace, ¿verdad? Por si acaso andas un poco despistado/a hoy, te lo cuento yo: Artisan te mostrará una lista con todos los comandos válidos en tu instalación de Laravel. Esto puede variar según tu versión de Laravel y los componentes que tengas instalados. En un primer momento, estos son los comandos que más vas a utilizar (cuando te conviertas en un experto/a en Laravel, irán llegando otros por pura necesidad): * ```php artisan db:migrate``` --> Para hacer migraciones (crear la estructura de nuestra base de datos). * ```php artisan db:seed``` --> Para llenar de datos predefinidos nuestra base de datos. * ```php artisan make:migration``` --> Crea una migración (para crear la estructura de la base de datos). * ```php artisan make:seeder``` --> Crea un seeder (para rellenar con datos las tablas). * ```php artisan make:controller``` --> Para crear un controlador. * ```php artisan make:model``` --> Para crear un modelo. * ```php artisan route:list``` --> Muestra todas las rutas definidas en el enrutador. ",
    "url": "/docs/dwes/_site/laravel/artisan.html",
    "relUrl": "/laravel/artisan.html"
  },"46": {
    "doc": "5.6 Primeros pasos con Laravel. Hola mundo",
    "title": "5.6 Primeros pasos con Laravel. Hola mundo",
    "content": "## 5.6. Primeros pasos con Laravel: Hola mundo {: .no_toc } - TOC {:toc} En esta sección vamos a crear nuestra primera aplicación funcional con Laravel: el tradicional \"Hola mundo\". Vale, ya sé que no es gran cosa, pero nos servirá para aprender la dinámica de trabajo con Laravel y para construir un esqueleto de aplicación sobre la que montar algo más grande más adelante. Vamos a crear esta aplicación paso a paso. Tal vez te parezca un poco exagerado, pero recuerda que la curva de aprendizaje de Laravel es muy empinada al principio y se suaviza mucho después. Es decir: los primeros pasos son los que más cuestan. ### Paso 1. Crea una clave segura Lo primero que debes hacer en cualquier aplicación Laravel es crear una clave segura para la aplicación. Esto crea una clave de encriptación aleatoria que se guarda en el archivo de configuración de la aplicación (.env). Laravel utilizará esa clave para cifrar ciertas cosas (por ejemplo, las contraseñas de usuario). Por ahora, no te preocupes de para qué sirve exactamente esta clave. Lo único importante es que Laravel no funcionará sin ella. Así pues, lo primero que hay que hacer con cualquier aplicación Laravel nueva es ejecutar este comando: ```php php artisan key:generate ``` ### Paso 2. Prueba el enrutador Vamos a empezar probando algo sencillo: capturar una ruta. Edita el archivo */routes/web.php* y añade esto: ```php Route::get('/hola', function() { return \"Hola, mundo\"; }); ``` Esto significa que, cuando escribas la ruta \"hola\" en la barra de direcciones del navegador, se ejecutará esta función anónima (también denominadas ***closure***) y, como resultado, se verá el texto \"Hola, mundo\" en la ventana del navegador. Pruébalo en el navegador, escribiendo la dirección: *http://mi-servidor/index.php/hola* ### Paso 3. Crea una ruta hacia un controlador Los *closures* o funciones sin nombre raramente se usan en el enrutador. Lo que suele hacer en enrutador es redirigir la ejecución hacia un controlador. Es justo lo que vamos ahora. Edita el enrutador (*/routes/web.php*) y sustituye la ruta anterior por esto: ```php Route::get('/hola', 'HolaController@index'); ``` Esto indica al enrutador que, al recibir la ruta \"hola\", se debe ejecutar el método *index()* del controlador *HolaController*. Pero el controlador *HolaController* no existe, así que vamos a crearlo con este comando de Artisan:: ```php $ php artisan make:controller HolaController ``` Por último, edita el controlador (*/app/Http/Controllers/HolaController.php*) y añádele el método *index()*: ```php public function index() { return \"Hola, mundo\"; } ``` Comprueba que funciona en el navegador: *http://mi-servidor/index.php/hola* **NOTA IMPORTANTE**: a partir de Laravel 8, para que este enrutamiento funcione es necesario descomentar la siguiente línea del archivo */app/Providers/RouteServiceProvider.php*: ```php // protected $namespace = 'App\\Http\\Controllers'; ) ``` ### Paso 4. Cargar una vista desde el controlador ¿Recuerdas que, en la arquitectura MVC, el controlador no debería producir ninguna salida HTML? Pues bien, nuestro controlador la está produciendo. Vamos a modificarlo para que el método *index()* del controlador no genere el \"Hola, mundo\", sino que invoque a una **vista** que se encargue de ello. Además, vamos a inyectar en la URL una variable con el nombre del usuario para mostrar cómo se capturan esos valores y cómo se pasan a las vistas en Laravel. Comenzamos modificando el enrutador (*/routes/web.php*). Observa cómo se usan las llaves { y } para indicar la presencia de una variable en la URL: ```php Route::get('/hola/{nombre}', 'HolaController@show'); ``` Ahora creamos un método *show()* en el controlador (*/app/Http/Controllers/HolaController.php*): ```php public function show($nombre) { $data['nombre'] = $nombre; return view('hola', $data); } ``` Como ves, estamos invocando una vista llamada *hola* y le estamos pasando un array con los datos necesarios (el nombre del usuario, en este caso). Esa vista debe crearse en */resources/views/hola.blade.php* y puede tener este aspecto: ```html Saludos, {% raw %}{{$nombre}}{% endraw %}. ¿Le apetece una partidita de ajedrez? ``` Puedes probar esta nueva ruta cargando en el navegador una ruta como: *http://mi-servidor/index.php/hola/ProfesorFalken* La respuesta debería ser esta: ``` Saludos, ProfesorFalken. ¿Le apetece una partidita de ajedrez? ``` Recuerda que, desde Laravel 8, el funcionamiento del enrutador ha cambiado. Para conservar compatibilidad hacia atrás, hay que abrir el archivo */app/Providers/RouteServiceProvider.php* y descomentar esta línea: ```php // protected $namespace = 'App\\Http\\Controllers'; ``` Hay otras soluciones para esto que [se describen aquí](https://litvinjuan.medium.com/how-to-fix-target-class-does-not-exist-in-laravel-8-f9e28b79f8b4). ",
    "url": "/docs/dwes/_site/laravel/hola-mundo-con-laravel.html",
    "relUrl": "/laravel/hola-mundo-con-laravel.html"
  },"47": {
    "doc": "5.7 Enrutamiento",
    "title": "5.7 Enrutamiento",
    "content": "## 5.7. Enrutamiento {: .no_toc } - TOC {:toc} Llegados a este punto, ya debes haber creado tu primera aplicación Laravel (\"Hola, mundo\") y habrás aprendido algo fundamental sobre el **enrutador**: cómo hacer que la solicitud de una URL termine ejecutando un método de un controlador. En esta sección, profundizaremos en el enrutador, un componente fundamental de cualquier aplicación web. ### 5.7.1. ¿Qué es el enrutador? El **enrutador** de Laravel es el componente que captura las URL solicitadas al servidor y las traduce a **invocaciones a métodos de los controladores**. El enrutador es capaz, además, de **mapear fragmentos de la URL** a variables PHP que serán inyectadas como parámetros a los métodos del controlador. Esto significa que, si le pides al servidor una ruta como esta: https://mi-servidor/user/delete/12 ...el enrutador puede \"trocear\" esa URL para extraer los segmentos (\"user\", \"delete\" y \"12\"). Y tú puedes decidir qué hacer con cada uno de esos segmentos. Lo normal en este ejemplo sería que invocaras el método *delete()* del controlador *UserController*, y que ese método recibiera como parámetro el dato *12*, que será el id del usuario que se pretende borrar. Y hay una última cosa que el enrutador puede hacer: **distinguir el verbo http** empleado para solicitar una página al servidor. Es decir, para el enrutador no es lo mismo una solicitud enviada por GET que otra enviada por POST. Incluso admite verbos que aún no están soportados por HTML, como DELETE o PUT, y que teóricamente van a formar parte de futuras implementaciones del lenguaje. Un poco más abajo explicaremos qué narices significa todo esto. ### 5.7.2. Enrutamiento básico Como vimos en el ejemplo del \"Hola, mundo\", hay varias **formas de generar una salida** HTML desde el enrutador (*/routes/web.php*). En este código de ejemplo vemos las cuatro formas básicas: ```php // Forma 1: generar la salida directamente en el enrutador, con un closure (función sin nombre) Route::get('/hola', function() { return \"Hola, mundo\"; }); // Forma 2: llamar a una función de un controlador sin pasarle parámetros Route::get('/hola', 'HolaController@show'); // Forma 3: llamar a una función de un controlador pasándole parámetros Route::get('/hola/{nombre}', 'HolaController@show'); // Forma 4: llamar a una función de un controlador con un parámetro optativo Route::get('/hola/{nombre?}', 'HolaController@show'); ``` La diferencia esntre la forma 3 y la 4 es que, en la forma 3, la ruta debe llevar forzosamente un dato a continuación de \"/hola\" (algo como: https://mi-servidor/hola/juan). Si no lo lleva, el enrutador considerará que no se trata de esa ruta y seguirá buscando alguna ruta coincidente en el resto del archivo. En cambio, en la forma 4, el dato final es optativo, así que el enrutador invocará el método *show()* del controlador tanto si ese dato aparece en la URL como si no lo hace. ### 5.7.3. Rutas con nombre Es MUY recomendable **asignar un nombre a las rutas** en el enrutador. Esto hace que, más adelante, podamos cambiar la URL de los enlaces sin tener que modificar el código fuente de nuestras vistas. El nombre se le asigna a una ruta añadiendo ```->name('nombre')``` al final: ```php Route::get('/contactame', 'Controlador@contacto')->name('contact'); ``` En tu código fuente, debes referirte a esta ruta siempre con la expresión ```route('contact')``` (ya veremos exactamente cómo se hace esto), pero el usuario verá la dirección https://servidor/contactame. En el futuro se puede cambiar la forma en la que lo ve el usuario. Por ejemplo, puedes cambiar ```Route::get('/contactame'...)``` por ```Route::get('/acerca-de'...)```, pero no tendrás que modificar ni una línea de código más en tu aplicación, porque internamente esa ruta seguirá llamándose ```route('contact')```. ### 5.7.4. Verbos http: GET, POST, PUT, PATCH y DELETE Además de GET, en el enrutador se pueden enrutar otras acciones: ```php Route::get(); // Solicitudes habituales Route::post(); // Recepción de datos de formulario (para insert) Route::put(); // Recepción de datos para update (también puede escribirse Route::patch(), que no es lo mismo, pero casi) Route::delete(); // Recepción de datos para delete Route::match(array('GET','POST'), 'ruta', acción) // Responderá tanto a GET como a POST ``` Los verbos PUT, PATCH y DELETE no están soportados aún por HTML. Las razones por las que esto ocurre son tan confusas que, sinceramente, creo que ni siquiera en el W3C lo entienden. La cuestión es que aún no existen, y punto. Es decir, no puedes crear un formulario así: ``````, porque tu navegador no lo entenderá. Solo puedes poner `````` o ``````. Cuando trabajes con Laravel, puedes **emular PUT, PATCH o DELETE** en los formularios así: ```html @method('DELETE') ``` Tal vez, llegado a este punto, te estés preguntando qué diferencia hay entre PUT y PATCH. O tal vez no. Salta a la siguiente sección si no te interesan estas sutilezas, y continúa leyendo en caso contrario. En teoría, una petición enviada por PUT debería culminar con la ejecución de un UPDATE en el servidor que modifique *un recurso entero*. Es decir, un registro completo de una tabla de la base de datos. En cambio, PATCH debería emplearse cuando el UPDATE vaya a modificar solo *una parte de los campos de un registro*, y no todos. ¿Que te parece una chorrada hacer esa distinción? Bueno, lo que tú o yo opinemos no importa demasiado. Todo esto es un estándar y, por lo tanto, hay que comérselo con patatas. ### 5.7.5. Orden de las rutas El **orden** en el que se escriben las rutas en el enrutador es importante. Por ejemplo, si pedimos la dirección *http://mi-servidor/usuario/crear*, escribir estas dos rutas en este orden es un error: ```php Route::get('usuario/{nombre}', 'UsuarioController@show'); Route::get('usuario/crear', 'UsuarioController@create'); ``` El enrutador tratará de mostrar un usuario cuyo nombre sea \"crear\" (que seguramente no existirá) porque la petición encaja con las dos rutas y el enrutador elegirá la primera ruta que encuentre. La solución pasa por alterar el orden de las líneas en el enrutador: ```php Route::get('usuario/crear', 'UsuarioController@create'); Route::get('usuario/{nombre}', 'UsuarioController@show'); ``` De este modo, la petición *http://mi-servidor/usuario/crear* seguirá encajando en las dos rutas, pero el enrutador elegirá la primera. En cambio, una petición parecida pero con cualquier otro nombre (por ejemplo, *http://mi-servidor/usuario/luis*), solo encajará con la segunda ruta. ### 5.7.6. Servidor RESTful Un **servidor RESTful** es aquel que responde a la [arquitectura REST](https://juanda.gitbooks.io/webapps/content/api/arquitectura-api-rest.html). La arquitectura REST no es más que una forma estandarizada de construir un servidor para que realice las tareas típicas de mantenimiento de recursos. Y los recursos pueden ser cualquier cosa que se almacene en el servidor: usuarios, clientes, productos, películas, facturas... Es decir: el 99% de las veces, los recursos son registros en una tabla de la base de datos. El enrutador de un servidor RESTful contendrá las 7 operaciones definidas en la arquitectura REST para cada recurso accesible desde la red, y que permiten manipular el recurso: mostrarlo, buscarlo, insertarlo, modificarlo o borrarlo. Por ejemplo, para un recurso llamado \"user\", esas 7 operaciones son: ```php Route::get('user', 'UserController@index')->name('user.index'); // Recupera todos los usuarios Route::get('user/{user}', 'UserController@show')->name('user.show'); // Recupera un usuario concreto con id = user Route::get('user/crear', 'UserController@create')->name('user.create'); // Lanza el formulario de creación de usuarios Route::post('user/{user}', 'UserController@store')->name('user.store'); // Recoge los datos del formulario y los inserta en la base de datos Route::get('user/{user}/edit', 'UserController@edit')->name('user.edit'); // Lanza el formulario de modificación de usuarios Route::patch('user/{user}', 'UserController@update')->name('user.update'); // Recoge los datos del formulario y modifica el usuario de la base de datos Route::delete('user/{user}', 'UserController@destroy')->name('user.destroy'); // Elimina al usuario de la base de datos ``` Ten encuenta que, si estás construyendo un servidor RESTful, debes **respetar escrupulosamente los nombres y URLs de las rutas**. Así, cualquier otro usuario o aplicación que use tu servidor sabrá cómo manipular los recursos sin necesidad de consultar la documentación técnica. Laravel te permite resumir esas entradas del enrutador en una sola línea que engloba a las siete rutas REST: ```php Route::resource('user'); ``` ",
    "url": "/docs/dwes/_site/laravel/enrutamiento.html",
    "relUrl": "/laravel/enrutamiento.html"
  },"48": {
    "doc": "5.8 Vistas y plantillas. Blade",
    "title": "{% raw %}{{$name}}{% endraw %}",
    "content": "Este es el contenido de mi página. @endsection ``` Observa que hemos respetado el *master layout* de ejemplo que creamos más arriba. Observa también cómo se hace el *echo* de la variable: nada de abrir y cerrar PHP (``````) ni de abrir y cerrar comillas: simplemente, se encierra la variable entre llaves dobles (```{% raw %}{{$variable}}{% endraw %}```), y Laravel se encargará de traducir eso al *echo* correspondiente. La vista queda de ese modo mucho más limpia y, por lo tanto, es más fácil de escribir, leer y depurar. ### 5.8.5. Condiciones en las vistas Blade admite **expresiones condicionales** para modificar el aspecto de una vista dependiendo del valor de una variable o del estado de la aplicación. Por supuesto, eso también puede hacerse sin Blade: solo hay que usar un *if* de PHP. Pero con Blade es más fácil y limpio porque, nuevamente, no tendremos que andar abriendo y cerrando PHP ni peleándonos con las comillas del *echo*. En el siguiente ejemplo, el contenido de la vista depende de la variable *$day* enviada desde el controlador. Observa como el *if* de PHP se sustituye por la directiva *@if* de Blade. Controlador: ```php function show() { return view('page', array('name' => 'Manolo','day' => 'Viernes')); } ``` Vista */resources/views/page.blade.php*: ```html @extends('layouts.master') @section('title', 'Page Title') @section('sidebar') Esto se añadirá al sidebar del master layout. @endsection @section('content') ",
    "url": "/docs/dwes/_site/laravel/vistas-y-plantillas-con-blade.html",
    "relUrl": "/laravel/vistas-y-plantillas-con-blade.html"
  },"49": {
    "doc": "5.8 Vistas y plantillas. Blade",
    "title": "{% raw %}{{$name}}{% endraw %}",
    "content": "Este es el contenido de mi página. @if ($day == 'Viernes') Hoy me roban el carro . @else Hoy me dedico a cantar . @endif @endsection ``` ### 5.8.6. Bucles en las vistas Igual que existen condiciones, Blade también permite hacer **bucles** para simplificar la generación de visas. Por ejemplo, en la siguiente vista recorremos un array llamado *$bebidas* y mostramos su contenido. Controlador: ```php function show() { $bebidas = array('Cerveza','Agua','Zumo'); return view('page',array('name' => 'Manolo','day' => 'Lunes', 'bebidas' => $bebidas)); } ``` Vista */resources/views/page.blade.php*: ```html @extends('layouts.master') @section('title', 'Page Title') @section('sidebar') Esto se añadirá al sidebar del master layout. @endsection @section('content') ",
    "url": "/docs/dwes/_site/laravel/vistas-y-plantillas-con-blade.html",
    "relUrl": "/laravel/vistas-y-plantillas-con-blade.html"
  },"50": {
    "doc": "5.8 Vistas y plantillas. Blade",
    "title": "{% raw %}{{$name}}{% endraw %}",
    "content": "Este es el contenido de mi página. @if ($day == 'Viernes') Hoy me roban el carro . @else Hoy me dedico a cantar . @endif ",
    "url": "/docs/dwes/_site/laravel/vistas-y-plantillas-con-blade.html",
    "relUrl": "/laravel/vistas-y-plantillas-con-blade.html"
  },"51": {
    "doc": "5.8 Vistas y plantillas. Blade",
    "title": "Estas son las bebidas disponibles:",
    "content": "@foreach ($bebidas as $bebida) {% raw %}{{$bebida}}{% endraw %} @endforeach @endsection ``` Observa que, nuevamente, esto mismo podría hacerse con PHP clásico, pero con Blade el código queda mucho más limpio y resulta menos propenso a errores. ### 5.8.7. Invocación de funciones PHP Desde una vista Blade se puede **invocar cualquier función de PHP** sin necesidad de abrirlo y cerrarlo (ya sabes: nada de `````` en las vistas). Por ejemplo, si necesitamos usar la función *date()*, la invocamos así: ```html ",
    "url": "/docs/dwes/_site/laravel/vistas-y-plantillas-con-blade.html",
    "relUrl": "/laravel/vistas-y-plantillas-con-blade.html"
  },"52": {
    "doc": "5.8 Vistas y plantillas. Blade",
    "title": "Ejemplo de llamada a función estándar de PHP",
    "content": "La fecha del servidor es: {% raw %}{{date(' D M, Y')}}{% endraw %} . ``` Esto no solo es más limpio, sino también más seguro, porque Blade filtra posibles ataques por XSS. (Por cierto: si alguna vez necesitas saltarte la protección contra XSS, puedes usar {% raw %}{!! ... !!}{% endraw %} en lugar de {% raw %}{{ ... }}{% endraw %}). ### 5.8.8. Otras directivas Blade Blade dispone de multitud de directivas para hacer prácticamente cualquier cosa en la vista sin tener que recurrir a PHP. En esta lista mostramos solo las directivas más habituales. - **@section** → Marca el inicio de una sección de contenido. - **@endsection** → Marca el final de una sección. - **@show** → Marca el final de una sección y la muestra. - **@yield('section')** → Muestra el contenido de una sección (si existe, claro). - **@extends('view')** → Hereda de una plantilla padre. - **@parent** → Muestra el contenido de la sección del mismo nombre en la plantilla padre. - **@include('view')** → Incluye una subvista. - **@if - @else - @endif** → Condicional. - **@for - @endfor** → Bucle for clásico. - **@foreach - @endforeach** → Buche foreach. - **@forelse - @empty - @endforelse** → Como foreach, pero con tratamiento de arrays que vienen vacíos. - **@break - @continue** → Para usar en los bucles. - **@switch - @case - @break** → Condicional múltiple. - **@isset($variable) - @endisset** → Comprueba si la variable existe. - **@auth - @endauth** → La sección solo se muestra si hay un usuario autenticado en la aplicación. - **@php - @endphp** → Para añadir código PHP plano. Usar con moderación. - **{% raw %}{{- Comment -}}{% endraw %}** → Comentarios (no serán renderizados). - **{% raw %}{{ $variable }}{% endraw %}** → Equivalente a echo $variable, pero no es necesario abrir y cerrar PHP, y nos protegemos contra inyección de JS. - **{% raw %}{{ $variable ?? texto-por-defecto }}{% endraw %}** → Como el anterior, pero chequea si la variable existe. Si existe, muestra su valor. Si no, muestra texto-por-defecto. - **$loop** → Es una variable muy útil para usar en y/o depurar un foreach. Nos dice si estamos en el primer elemento, en el último, cuántos loops llevamos, etc. ### 5.8.9. Tratamiento de formularios con Blade Blade también facilita un montón el **tratamiento de los formularios**. Y, por supuesto, filtra por nosotros cualquier código malicioso que traten de colarnos a través de ellos. Vamos a verlo con un ejemplo. Imaginemos una vista con este formulario (fíjate cómo indicamos la ruta en el *action*): ```html @csrf Enviar ``` Recuerda que los métodos PUT, PATCH y DELETE no existen aún en HTML y que Laravel los simula con un campo oculto en el formulario que se crea con la directiva **@method('PUT')** (o PATCH o DELETE). En este formulario no la hemos usado porque se envía por POST. Lo que sí hemos usado es la directiva **@csrf**. Todos los formularios deberían llevarla. Impide los ataques por CSRF, incrustado un token aleatorio en el formulario que Laravel se encargará de comprobar cuando los datos del formulario regresen al servidor. No te preocupes si no entiendes bien como funciona, por Laravel se encarga de hacerlo todo. Tú solo tienes que colocar la directiva @csrf en todos tus formularios. En el enrutador, definiremos la ruta \"mi-ruta\" del action del formulario: ```php Route::post('mi-ruta', 'MiControlador@store'); ``` Y, en el controlador, creamos el método *store()*. Observa cómo recuperamos los datos del formulario a través de la variable $r: ```php public function store(Request $r) { $email = $r->get(\"email\"); $asunto = $r->get(\"asunto\"); ...etc... } ``` Esta es una forma alternativa para el controlador: ```php public function store() { $email = request(\"email\"); $asunto = request(\"asunto\"); ...etc... } ``` ### 5.8.10. Validación de formularios con Blade Otra cosa que Blade facilita muchísimo es la **validación de formularios en el lado del servidor**. Aquí toca hacer un paréntesis para responder a esta pregunta: ¿dónde deberían validarse los formularios? ¿En el cliente (con HTML y Javascript) o en el servidor (con PHP y Laravel)? . La respuesta es: en los dos sitios. Sobre todo si es un formulario con información sensible. La validación en el cliente es más sencilla de hacer. Comprobar que un campo de texto de un formulario no se envía vacío, por ejemplo, es algo trivial con HTML. Y con Javascript es solo un poquito más complicado. Hacer esas comprobaciones en el servidor resulta más trabajoso: hay que recibir el formulario, comprobar los valores de los campos y, si hay un error, tenemos que volver a enviar el formulario, pero respetando los datos que el usuario ya hubiera tecleado, todo ello junto con un mensaje informando del error. Sí, en el servidor es más complicado. Pero también más seguro. Las validaciones en el cliente pueden desactivarse (puedo usar un navegador antiguo para evitar las comprobaciones por HTML, y puedo deshabilitar temporalmente el motor de Javascript), así que son una primera barrera defensiva muy convieniente pero poco segura. Las comprobaciones en el servidor son imposibles de saltar para un atacante. Así que deberíamos hacer los dos conjuntos de comprobaciones en todos nuestros formularios. Y aquí es donde Laravel nos ayuda. Vamos a retomar **la vista** del ejemplo anterior y a modificar el formulario para que se valide en el servidor. Tendríamos que añadirle algunas cositas: ```html @if ($errors->any()) @foreach ($errors->all() as $error) {% raw %}{{ $error }}{% endraw %} @endforeach @endif ...resto del formulario igual... ``` Fíjate en cómo mostramos los errores -si los hay- con un bucle. El objeto *$errors* (disponible en todas las vistas) tiene muchos más métodos útiles que puedes consultar en la documentación de Laravel. Y el **controlador** quedaría así. Observa cómo definimos varias **reglas de validación** para campos del formulario: ```php public function store() { request->validate([ 'email' => 'required|email', 'asunto' => 'required' ]); // A partir de aquí, se procesa el formulario igual que antes ``` Puedes consultar todas las reglas de validación admitidas en [https://laravel.com/docs/validation](https://laravel.com/docs/validation). Cuando vuelve a cargarse el formulario que contenía un error, suele ser apropiado hacerlo con los datos que el usuario ya había tecleado. A esto se le llama **\"repopular\" el formulario**, y con Blade se hace así (observa el atributo *value* del campo *email*): ```html @if ($errors->any()) @foreach ($errors->all() as $error) {% raw %}{{ $error }}{% endraw %} @endforeach @endif ...resto del formulario igual... ``` ### 5.8.11. Añadir CSS y Javascript a nuestras vistas Laravel ya trae dos archivos (*app.css* y *app.js*) basados en **Boostrap** para empezar a trabajar. Para usarlos, basta con añadir esto a la cabecera de nuestras vistas: ```html | ``` Si queremos **añadir reglas CSS**, *NO debemos editar /public/app.css*, porque es un CSS compilado y minimizado con ***SASS***. Lo correcto para añadir nuestro CSS a ese archivo es: 1. Editar */resources/sass/app.css* 2. Recompilar este archivo con *SASS* (o con *less* o con *stylus*) La recompilación se hace con este comando ``` $ npm run dev ``` O también con: ``` $ yarn dev ``` Si no tienes ni idea de lo que estamos hablando con esto de *less*, *SASS* y demás zarandajas, tienes dos opciones: o te empapas un poco de ello antes de continuar (lamentablemente, en este manual no tenemos espacio para verlo TODO), o te olvidas de ellos y colocas tu CSS y tu Javascript en un directorio púbico sin compilar ni nada. Para lograr esto último, simplemente, guarda tu CSS y tu Javascript en el **directorio /public** de Laravel. En ese caso, los archivos no estarían optimizados (tendríamos que optimizarlos a mano, si queremos) y serían accesibles de forma pública. Pero es una solución lo suficientemente buena para empezar. Un consejo: si vas a colocar tu CSS y tu Javascript en /public, al menos crea subcarpetas para organizarlo un poco. Por ejemplo, /public/css y /public/js. ### 5.8.12. Vistas de error personalizadas Por último, te menciono un pequeño truco para darle a tu aplicación un toque más profesional: **personalizar las vistas de error**. Simplemente, crea una carpeta */resources/views/errors*. Todas las vistas que metas ahí dentro se considerarán pantallas de error. Ahora solo tienes que ponerles los nombres adecuados. Por ejemplo, si creas un archivo llamado */resources/views/errors/404.blade.php*, esa vista se mostrará cada vez que ocurra un error 404 (página no encontrada). Fácil, ¿no? ",
    "url": "/docs/dwes/_site/laravel/vistas-y-plantillas-con-blade.html",
    "relUrl": "/laravel/vistas-y-plantillas-con-blade.html"
  },"53": {
    "doc": "5.8 Vistas y plantillas. Blade",
    "title": "5.8 Vistas y plantillas. Blade",
    "content": "## 5.8. Vistas y plantillas. Blade {: .no_toc } - TOC {:toc} **Blade es un poderoso y sencillo sub-lenguaje** que nos permitirá **generar plantillas de vistas** para minimizar el código que necesitaremos para nuestras vistas. Las plantillas Blade admiten condiciones y bucles para operar con las variables PHP, de modo que la misma plantilla se comporta de forma diferente con diferentes conjuntos de datos. ¡Y se acabó la pesadilla de abrir y cerrar comillas en las instrucciones ```echo```! Con Blade, tampoco será necesario abrir y cerrar php (``````) para operar con las variables del servidor y generar la salida. El código escrito con Blade no solo es más limpio y fácil de depurar que con PHP básico, sino también más seguro, porque Blade impide cualquier ataque con XSS. Pero es no es todo. Además, unas plantillas pueden heredar de otras para reutilizar mejor el código. Así que Blade tiene un montón de ventajas y ningún inconveniente. Bueno, sí que tiene un inconveniente: que tienes que aprender a usarlo. Pero es tan sencillo que, cuando hayas trabajado con Blade un par de semanas, te preguntarás cómo habías podido sobrevivir hasta ahora sin él. ### 5.8.1. Master layout ***Layout*** es una forma genérica de referirse al diseño de capas del interfaz de usuario de una aplicación. Es decir, el *layout* de una aplicación es el diseño de los elementos de su interfaz de usuario. ![Ejemplos de layout](/docs/dwes/_site/assets/images/07-ejemplos-de-layout.png) *(Ejemplos de layout adaptados a diferentes tamaños de pantalla. Imagen tomada de [Seobility.net](https://www.seobility.net/en/wiki/Media_Queries) y publicada con licencia [CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/))* El ***master layout*** es el diseño maestro del que derivan todas las vistas. Las aplicaciones web suelen tener un *master layout* muy definido, y todas las vistas de la aplicación lo respetan. Ese *master layout* suele almacenarse, por convenio, en un archivo llamado */resources/views/layouts/master.blade.php* Vamos a construir un *master layout* de ejemplo. Será muy simple, pero más adelante puedes complicarlo todo lo que quieras, y cada modificación afectará automáticamente a todas las vistas de tu aplicación. ```html @yield('Titulo') . @section('sidebar') Este es mi master sidebar. @show @yield('content') . ``` Aquí nos encontramos con varias **directivas** importantes de Blade: * **@yield('Titulo')** --> Esto define una sección llamada 'Título', que en el master layout está vacía. Las vistas que hereden del master layout tendrán que definir cuál es el valor de 'Título', y ese valor aparecerá escrito aquí. * **@section('sidebar')** --> Esto define una sección llamada 'sidebar' que NO está vacía (contiene el texto \"Este es mi master sidebar\", pero podría contener cualquier otra cosa). Las vistas que hereden del master layout podrán AÑADIR contenido a esta sección. * **@show** --> Hace que el contenido de la sección se muestre en ese punto del documento. * **@yield('content')** --> De nuevo, una sección que está vacía en el master layout y cuyo contenido tendrá que definirse en las vistas que hereden de esta. ### 5.8.2. Vistas que heredan del master layout Después de crear nuestro *master layout*, lo siguiente es empezar a construir vistas que lo utilicen. Es decir, que **hereden** de él todos sus componentes y añadan nuevos elementos, respetando la configuración básica establecida por el *master layout*. El aspecto de una vista que herede del *master layout* de nuestro ejemplo anterior debería ser este: ```html @extends('master') @section('title', 'Titulo de la página') @section('sidebar') Esto se añadirá al master sidebar. @endsection @section('content') Aquí va el contenido de mi página. @endsection ``` De nuevo tenemos varias *directivas* de Blade muy importantes: * **@extends('master')** --> Esto indica que esta vista hereda del master layout. * **@section('title, 'Título de la página')** --> Aquí se define el contenido de la sección 'Título' que en el master layout estaba vacía. * **@section('sidebar')** --> Aquí añade contenido a la sección 'sidebar', que en el master layout no estaba vacía. * **@ensection** --> Se emplea cuando el contenido de una sección ocupa varias líneas de código y no es posible escribirlo dentro de la propia directiva. ### 5.8.3. Cómo pasar variables a las vistas Las **variables** a las vistas deben enviarse **empaquetadas en un array**. Hay varias formas de lograr esto, todas ellas correctas. Puedes emplear la que te resulte más cómoda o más elegante: ```php // Forma 1: crear el array antes de llamar a la vista $data['variable1'] = 'valor'; $data['variable2'] = 'valor'; return view('vista', $data); // Forma 2: crear un array con el constructor array() return view('vista', array('variable1'=>'valor', 'variable2'=>'valor')); // Forma 3: crear un array con corchetes [] return view('vista', ['variable1'=>'valor', 'variable2'=>'valor']); // Forma 4: usar el método with() return view('vista')->with(['variable1'=>'valor', 'variable2'=>'valor']); // Forma 5: usar la función compact() return view('vista', compact('variable1', 'variable2')); ``` ### 5.8.4. Cómo usar las variables en las vistas Vale, ya hemos enviado algunas variables a las vistas. Ahora, ¿cómo las usamos? La vista no recibe el array con las variables, sino **las variables ya extraídas del array**. Esto significa que, si le pasas a una vista un par de variables como ```['variable1'=>'valor', 'variable2'=>'valor']```, en la vista existirán dos variables llamadas *$variable1* y *$variable2*, y no encontrarás ni rastro del array que las contenía. Veámoslo con un ejemplo. Supongamos que tenemos este método en un controlador: ```php function show() { return view('page', array('name' => 'Manolo Escobar')); } ``` En la vista */resources/views/page.blade.php* tendrás disponible una variable *$name*, y la puedes usar de este modo: ```html @extends('layouts.master') @section('title', 'Page Title') @section('sidebar') Esto se añadirá al sidebar del master layout. @endsection @section('content') ",
    "url": "/docs/dwes/_site/laravel/vistas-y-plantillas-con-blade.html",
    "relUrl": "/laravel/vistas-y-plantillas-con-blade.html"
  },"54": {
    "doc": "5.9 Controladores",
    "title": "5.9 Controladores",
    "content": "## 5.9. Controladores {: .no_toc } - TOC {:toc} Los **controladores** son un elemento clave de la **arquitectura MVC**. En Laravel, los controladores funcionan exactamente igual que en las aplicaciones MVC hechas con PHP clásico. Es decir: son los puntos de entrada a la aplicación desde el enrutador. Los controladores deberían permanecer lo más sencillos posible: nada de accesos a la base de datos ni de generación de HTML. Esas acciones se derivarán a los modelos y las vistas. El controlador es un organizador del flujo de la aplicación: decide qué componente tiene que trabajar y el orden en el que lo debe hacer. En esta sección, vamos a aprender a construir controladores con Laravel. Vas a ver que es algo extremadamente sencillo. ### 5.9.1. Cuatro cosas importantes sobre los controladores en Laravel 1. Los **controladores** en Laravel siempre **heredan de la clase *Controller*** o de una subclase de *Controller*. ```php class MiControlador extends Controller { ... } ``` 2. Su nombre debería escribirse en singular, CamelCase y terminando en la palabra Controller. Por ejemplo: *UserController*, *LoginController*, *ArticleController*... 3. **Cada método del controlador debe terminar en un *return***. Lo que el método devuelva será convertido automáticamente en una *HTTP response 200*, es decir, en una respuesta válida http, excepto si es un array, en cuyo caso Laravel lo convertirá automáticamente en JSON (perfecto para responder a peticiones Ajax, como veremos más adelante). 4. Si lo necesitas, puedes actuar sobre la *HTTP response* devolviendo algo como esto: ```php return response('contenido', 201) ->header('mi-cabecera', 'contenido') ->header('otra-cabecera', 'más-contenido') ->cookie('mi-cookie', 'valor'); (etc) ``` (Pero no nos engañemos: no lo necesitarás hacer demasiado a menudo). ### 5.9.2. Tres formas de crear un controlador Los controladores se pueden crear a mano: vas al directorio */app/http/controllers*, creas allí un archivo vacío y empiezas a escribir código como una fiera. Pero nadie lo hace así porque **Artisan** ya crea el esqueleto del archivo por ti. Así que es mejor que vayas a lo práctico: abre una consola en tu servidor web y ponte a escribir. **Forma 1. Crear un controlador vacío.** Por ejemplo, para crear un controlador para la tabla de usuarios: ``` $ php artisan make:controller UserController ``` **Forma 2. Crear un controlador de tipo resource.** Estos controladores se generan automáticamente con un andamiaje para construir recursos **REST**. Es decir, la clase ya llevará incorporados los métodos *index(), create(), store(), show(), edit(), update()* y *destroy()* del estándar REST. (Si no sabes de qué estamos hablando, revisa la sección que dedicamos al enrutamiento en Laravel) Para crear un controlador RESTful: ``` $ php artisan make:controller UserController --resource ``` No te olvides de añadir al enrutador (*/routes/web.php*) las rutas REST para este tipo controlador. Te recuerdo que se pueden resumir las siete rutas en esta sola entrada del enrutador: ``` Route::resource('nombreRecurso', 'controlador'); ``` En nuestro ejemplo: ``` Route::resource('usuarios', 'UserController'); ``` **Forma 3. Crear un controlador tipo API.** Una **API** (*Application Programming Interface*) es un interfaz entre programas. Es decir, es la forma en la que unos programas interaccionan con otros. Algunas aplicaciones web se diseñan para que otros programas las utilicen, no para que las utilicen seres humanos. En estos casos, el interfaz de usuario no existe (o es mínimo) y lo importante es el API. Y los métodos del controlador no devuelven vistas, sino datos formateados en JSON. Se puede construir con Laravel un controlador tipo API de forma muy simple, porque es parecido a un *resource*, pero sin *create()* ni *edit()*, porque una API no necesita mostrar los formularios de inserción/modificación. ``` $ php artisan make:controller UserController --api ``` De nuevo, no te olvides de las entradas en el enrutador. Puedes englobarlas todas en una sola entrada con este aspecto: ``` Route::apiResource('usuarios', 'UserController'); ``` ",
    "url": "/docs/dwes/_site/laravel/controladores.html",
    "relUrl": "/laravel/controladores.html"
  },"55": {
    "doc": "8.1 CGI",
    "title": "8.1 CGI",
    "content": "## 8.1. Common Gateway Interface (CGI) **CGI** es **la solución más antigua** para el desarrollo web en el lado del servidor. En la década de 1990, cuando se empezó a pensar en la posibilidad de crear página dinámicas generadas por el servidor a partir de los recursos del mismo (típicamente, una base de datos), los primeros desarrollos utilizaron, como es lógico, las tecnologías presentes en ese momento en los servidores web. Todos los servidores tenían un compilador de C/C++, así que alguien pensó: *¿por qué no escribimos las aplicaciones web en C/C++, las compilamos y hacemos que el ejecutable se pueda invocar vía web?* Para lograr esto último, se utilizó **CGI** (***Common Gateway Interface***). CGI es **una interfaz entre los servidores web y las aplicaciones que se ejecutan en el servidor**. Estas aplicaciones pueden estar construidas en cualquier lenguaje (no solo C/C++). A CGI, eso le da igual. Solo define la forma de transferir información en ambos sentidos. La figura siguiente muestra la forma en la que se ejecutan programas en el servidor a través de CGI. Si lo observas con atención, verás que no difiere demasiado de la forma en la que trabaja PHP, porque cualquier petición tiene 4 pasos: 1. Se recibe la petición de un cliente web. 2. El servidor web recibe la peticion y, a través del interfaz CGI, le pide al sistema operativo que ejecute el programa correspondiente. 3. La salida del programa se redirige al servidor web. De esto se encarga, nuevamente, el interfaz CGI. 4. El servidor devuelve al cliente el resultado de la ejecución del programa. ![Esquema CGI](/docs/dwes/_site/assets/images/08-cgi-esquema.png) ### 8.1.1. Entonces, ¿en qué se diferencia CGI de PHP? Lo primero, CGI no es un lenguaje de programación. Eso ya lo hemos dicho. Es un ***interfaz*** entre el servidor web y el sistema operativo para poder ejecutar *cualquier programa escrito en cualquier lenguaje a través de la web*. Puede parecer una solución perfecta, ¿verdad? Pero, si fuera así, ¿por qué no se sigue usando de forma masiva? ¿Por qué se abandonó en favor de PHP u otros de los lenguajes que vamos a ver más adelante? La respuesta breve es: **CGI tiene problemas de rendimiento**. Cada vez que se recibe una petición de un cliente, se crea un nuevo proceso en el servidor para ejecutar el programa en cuestión. Este proceso necesita un espacio de memoria para colocar su código fuente y sus datos, y estos recursos solo se liberan cuando el servidor termina de responder al cliente. Esta creación de procesos independientes implica una carga importante para el servidor, por lo cual esta modalidad de generación de contenido dinámico *no es escalable*. Por su parte, PHP (y otras soluciones que veremos más adelante) no crean un proceso independiente para cada petición recibida, sino que un mismo macro-proceso se encarga de gestionarlas todas. En términos de escalabilidad, esta opción es mucho mejor. Así que, cuando los servidores empezaron a recibir muchas visitas simultáneas, CGI comenzó a abandonarse. *Sencillamente, ningún servidor CGI podía soportar grandes volúmenes de peticiones*. Existen algunas alternativas para **solucionar este problema de CGI**, como mantener un sólo proceso CGI en memoria que se encargue de procesar todas las peticiones (técnica conocida como **FastCGI** y que, de hecho, se sigue utilizando en la actualidad, incluso para ejecutar PHP en el servidor), pero resulta más complejo de configurar y operar, e implica algunos problemas de seguridad. En cualquier caso, estos detalles de configuración del servidor son cosas que competen más a los administradores de sistemas que a los desarrolladores. ",
    "url": "/docs/dwes/_site/otros/cgi.html",
    "relUrl": "/otros/cgi.html"
  },"56": {
    "doc": "8.2 Perl",
    "title": "8.2 Perl",
    "content": "## 8.2. Perl A partir de este punto, veremos varios lenguajes alternativos a PHP (es decir, su \"competencia\") siguiendo siempre el mismo esquema: * Primero, enumeraremos las características y filosofia del lenguaje. * Luego explicaremos a grandes rasgos cómo hay que configurar el servidor para poder usar ese lenguaje para desarrollo web. * Después mostraremos la sintaxis básica del lenguaje. * Por último, escribiremos dos ejemplos completos en cada lenguaje: un sencillo \"hola, mundo\" y un programa algo más complejo que lanza una validación de login mediante ajax. En este segundo caso, la parte del cliente será siempre la misma, y solo cambiaremos la parte del servidor. Eso te permitirá apreciar las diferencias entre unos lenguajes y otros. Enseguida te darás cuenta de que esas diferencias son mínimas. ### 8.2.1. Características del lenguaje Perl Fecha de aparición: 1987. Perspectivas: * Uso decreciente. * Apto para tareas pequeñas y rápidas. * Cuenta con desarrolladores muy fieles y experimentados. Documentación muy extensa. * Soporte amplio en cualquier servidor. Filosofía de Perl: * Versión mejorada del shell scripting de Unix. * Pensado para procesamiento rápido de archivos de texto y automatización de tareas de administración del sistema. * Favorece la programación ágil, rápida y sucia de scripts. * Énfasis en las expresiones regulares. * Multiparadigma. * En combinación con CGI, se popularizó para aplicaciones web antes de la aparición de PHP. ### 8.2.2. Configuración necesaria en el servidor Para utilizar Perl en un servidor Apache o similar, necesitaremos: 1. Instalar el intérprete Perl (usr/bin/perl). 2. Activar los módulos perl y/o cgi de Apache y configurar el handler para CGI. 3. Instalar módulos Perl adicionales para acceso a bases de datos, etc. Se puede ejecutar el intérprete Perl de forma nativa en Apache, o bien hacerlo a través de CGI. Lo primero es más difícil de configurar y raramente se encuentra en hostings web compartidos. ### 8.2.3. Sintaxis básica de Perl Las variables en Perl no se declaran, tienen tipado dinámico y son globales por defecto. ```perl $var = valor; print \"La variable var vale $variable\"; ``` Algunos operadores: * Comparación: lt, gt, le, ge, eq, ne... * Asignación: = Algunas estructuras de control: ```perl while (condicion) { Acciones } if (condicion) { Acciones-1 } else { Acciones-2 } ``` ### 8.2.4. Entrada / salida Entrada de datos estándar: ```perl chop ( $variable = ); ``` Lectura de datos desde un formulario HTML: ```perl use CGI; my $cgi = CGI->new; my $username = $cgi->param(\"username\"); ``` Salida: ```perl print \"cadena $variable cadena...\"; ``` ### 8.2.5. Bibliotecas, funciones y clases Para utilizar una biblioteca o ***package***, como se denominan en Perl, se emplea la palabra **use**: ```perl use nombre-biblioteca; ``` Las bibliotecas se empaquetan en archivos con extensión .pm (***Perl Modules***). Dentro de ellas, puede haber una colección de funciones o métodos que se declaran así: ```perl package nombre-biblioteca; Sub nombre-funcion (argumentos) { Acciones } ``` Estas funciones pueden usarse desde fuera de la biblioteca con esta sintaxis: ```perl use nombre-biblioteca; nombre-biblioteca::nombre-funcion(argumentos); ``` Los ***packages*** también pueden usarse para construir clases (o algo parecido) de las que luego se pueden instanciar objetos. Más o menos así: ```perl package nombre-de-la-clase; sub new { # Este es el método constructor my $self = {}; # Array para los atributos $self->{VAR1} = 0; # Un atributo $self->{VAR2} = 9; # Otro atributo } sub otro-método{ # Aquí van el resto de métodos de la clase } sub DESTROY { # Método destructor } 1 # Para que el intérprete Perl no se queje al interpretar este archivo ``` Como puedes observar, Perl está lleno de peculiaridades que muchos consideran anticuadas o, como mínimo, poco elegantes. Observa si no la forma que tiene de crear los atributos de instancia, los caprichosos nombres de los métodos (a veces en minúscula, a veces en mayúscula) o la necesidad de terminar el ***package*** con un 1 para que el intérprete Perl lo considere un script válido. Por último, para instanciar un objeto de esta clase: ```perl use nombre-de-la-clase; $objeto = nombre-de-la-clase->new(); ``` ### 8.2.6. Ejemplo 1 en Perl: Hola mundo ```perl #!/usr/bin/perl print \"Content-type: text/html\\n\\n\"; print \"Hola mundo\"; print \"Hola, mundo\"; print \" . \"; ``` ### 8.2.7. Ejemplo 2 en Perl: login con comprobación de email por Ajax Este segundo ejemplo, como hemos explicado más arriba, consistirá en un formulario de login que comprobará el nombre de usuario y la contraseña mediante una petición Ajax. #### Formulario HTML El formulario de login es un simple código HTML que será idéntico en todos los ejemplos que veremos en el resto de este capítulo, así que solo lo mostraremos aquí por primera vez. ```html Nombre de usuario . Contraseña . Login . ``` #### Script jQuery El script que lanza la petición Ajax (cuyo código puede ir en el mismo archivo que el formulario) será ***casi*** idéntico en todos los ejemplos: solo cambiará el nombre del script al que se lanza la petición. En nuestro caso actual, es script lo hemos llamado **login.pl** (la extensión .pl denota que se trata de un script escrito en lenguaje Perl). Como es lógico, en ejemplos posteriores, tendrías que cambiar el nombre de ese archivo por el que corresponda (login.py si estamos usando Python, login.rb si estamos usando Ruby, etc). Para no repetirnos innecesariamente, no volveremos a mostrar tampoco el código de este script en los ejemplos sucesivos. Observa que Javascript está esperando que el servidor responda con un JSON que puede llevar estos tres datos en su interior: * data.error: Un string con un texto de error en caso de que el usuario o la contraseña sean incorrectos. * data.success: Un string con un texto de éxito en caso de que el usuario y la contraseña sean correctos. * data.userId: Un entero con el ID del usuario logueado (solo en caso de éxito). ```javascript $(document).ready(function(){ $(\"form#loginForm\").submit(function() { var username = $('#username').attr('value'); // Obtenemos el username var password = $('#password').attr('value'); // Obtenemos la password if (username && password) { // Los valores de username y password no están vacíos $.ajax({ type: \"GET\", url: \"login.pl\", dataType: \"json\", data: \"username=\" + username + \"&password=\" + password, success: function(data){ if (data.error) { // El servidor ha devuelto un error de login $('div#loginResult').text(\"data.error: \" + data.error); $('div#loginResult').addClass(\"error\"); } else { // El servidor ha hecho el login correctamente $('form#loginForm').hide(); $('div#loginResult').text(\"data.success: \" + data.success + \", data.userid: \" + data.userid); $('div#loginResult').addClass(\"success\"); } } }); } else { $('div#loginResult').text(\"Debe escribir su nombre de usuario y su contraseña\"); $('div#loginResult').addClass(\"error\"); } $('div#loginResult').fadeIn(); return false; }); }); ``` #### Script Perl en el lado del servidor (login.pl) Este sería el script en Perl que respondería a la petición Ajax anterior. Observa que, a pesar de la peculiar sintaxis de Perl, la estructura del algoritmo es idéntica a la que usaríamos si lo escribiéramos en PHP: 1. Recuperamos los datos del formulario (username y password) 2. Conectamos con la base de datos 3. Lanzamos la consulta contra la tabla de usuarios 4. En función del resultado de la consulta, preparamos nuestro JSON de respuesta al cliente 5. Devolvemos el JSON al cliente ```perl #!/usr/bin/perl -T use CGI; use DBI; use strict; use warnings; # read the CGI params my $cgi = CGI->new; my $username = $cgi->param(\"username\"); my $password = $cgi->param(\"password\"); # connect to the database my $dbh = DBI->connect(\"DBI:mysql:database=mydb;host=localhost;port=2009\", \"mydbusername\", \"mydbpassword\") or die $DBI::errstr; # check the username and password in the database my $statement = qq{SELECT id FROM users WHERE username=? and password=?}; my $sth = $dbh->prepare($statement) or die $dbh->errstr; $sth->execute($username, $password) or die $sth->errstr; my ($userID) = $sth->fetchrow_array; # create a JSON string according to the database result my $json = ($userID) ? qq{% raw %}{{\"success\" : \"login is successful\", \"userid\" : \"$userID\"}}{% endraw %} : qq{% raw %}{{\"error\" : \"username or password is wrong\"}}{% endraw %}; # return JSON string print $cgi->header(-type => \"application/json\", -charset => \"utf-8\"); print $json; ``` ",
    "url": "/docs/dwes/_site/otros/perl.html",
    "relUrl": "/otros/perl.html"
  },"57": {
    "doc": "8.3 Python",
    "title": "Hola, mundo",
    "content": "\" print \" . \" ``` ### 8.3.7. Ejemplo 2 en Python: login con comprobación de email por Ajax Repetimos ahora el ejemplo del login con comprobación de usuario y contraseña mediante Ajax, pero no mostraremos de nuevo el código del formulario ni de la llamada Ajax. Para ver ese código, revisa la sección que dedicamos al lenguaje Perl. Allí solo tendrás que cambiar el nombre del script (login.pl) por login.py. El código de ese script sí que cambia, claro. Esta es la versión del mismo escrita en Python: ```python #!/usr/bin/python import cgi import MySQLdb # Capturamos los valores del formulario form = cgi.FieldStorage() usuario = form[\"username\"].value; password = form[\"password\"].value; print \"Usuario = \", usuario, \" Pass = \", password # Lanzamos la consulta contra la base de datos db=MySQLdb.connect(host='localhost', user='yo-que-sé', passwd='vete-a-saber', db='lo-que-sea') cursor=db.cursor() num_rows = cursor.execute(\"SELECT id FROM users WHERE username = '%s' AND password = '%s';\", (usuario, password)) userid = cursor.fetchone() # Devolvemos el resultado en JSON print \"Content-type: application/json\\n\" if num_rows == 0: print \"{'error': 'Usuario o contraseña incorrectos'}\" else: print \"{'success': 'El usuario y la contraseña son válidos', 'userid': '%d'\", userid ``` ",
    "url": "/docs/dwes/_site/otros/python.html",
    "relUrl": "/otros/python.html"
  },"58": {
    "doc": "8.3 Python",
    "title": "8.3 Python",
    "content": "## 8.3. Python ### 8.3.1. Características del lenguaje Python Fecha de aparición: 1991 Perspectivas: * Uso creciente. * Es el sustituto natural de Perl para el desarrollo rápido de scripts. * También usado en grandes proyectos como alternativa a PHP. * Menos extendido que PHP, pero comunidad con muchos desarrolladores profesionales (mejor relación señal/ruido) * Muchas bibliotecas de terceros → flexibilidad Filosofía: * Es la versión “limpia” de Perl. Pensado para escribir scripts de forma rápida y limpia. * Énfasis en la legibilidad: Python es casi pseudocódigo (código “pythonico” → v. “El Zen de Python”) * Interpretado. Tipado dinámico. Fuertemente tipado. * Expresiones regulares heredadas de Perl. * Multiparadigma: imperativo, O.O., funcional. ### 8.3.2. Configuración necesaria en el servidor Para hacer funcionar Python en un servidor Apache o similar, es necesario: 1. Instalar el intérprete Python (/usr/bin/python). El más extendido es CPhyton. 2. Activar los módulos python y/o cgi de Apache y configurar el handler de Apache para CGI. 3. Instalar módulos adicionales (p. ej: para acceso a bases de datos) si es necesario. Python puede funcionar de forma nativa integrado en Apache o a través de CGI. Lo primero es más rápido; lo segundo, más frecuente. ### 8.3.3. Sintaxis básica de Python Las variables en Python no se declaran obligatoriamente: tienen tipado dinámico y son locales por defecto. ```python varariable = valor; print \"La variable var vale %s\" (variable); ``` En Python hay muchos tipos de datos complejos predefinidos: listas, tuplas, diccionarios... Algunos operadores son: * Comparación: , =, ==, != * Asignación: = Y estas son algunas estructuras de control. **¡Cuidado! ¡El código debe indentarse OBLIGATORIAMENTE!** No existen las llaves ({ y }) en Python. ¡La indentación (o sangrado) marca los bloques! ```python while condicion: Acciones if condicion: Acciones-1 else: Acciones-2 ``` ### 8.3.4. Entrada / Salida La entrada de datos por teclado puede hacerse con raw_input(): ```python variable = raw_input(\"Texto\") ``` Pero a nosotros nos interesa hacer entrada de datos a través de un formulario HTML. Esto se hace así: ```python import cgi form = cgi.FieldStorage() campo = form[\"campo\"].value ``` En cuanto a la salida de datos, se usa ***print*** con cadenas de formato, seguida de una lista de variables. Cada elemento de la cadena de formato marcado con un % se sustituirá por una variable de la lista, en el mismo orden en el que estén escritas. Por ejemplo: ```python print \"cadena %s cadena %s ...\" (variable1, variable2) ``` El símbolo %s significa que en esa posición irá un String. Otras posibilidades son %d (enteros) o %f (float). Esta forma de especificar las cadenas de formato está directamente tomada del lenguaje C. En Python existen muchas otras formas de hacer una salida de datos, pero ***print*** es lo suficientemente potente como para que puedas utilizarla para cualquier cosa imaginable en una aplicación web. ### 8.3.5. Bibliotecas, funciones y clases En Python hay tres niveles de agrupación de bibliotecas: * Módulos: un módulo es un fichero con código Python en su interior. Puede ser una clase o un puñado de funciones sueltas, por ejemplo. * Paquetes (*packages*): un paquete es un directorio que contiene varios módulos. También puede contener subpaquetes. Los paquetes se instalan y desinstalan con un gestor de paquetes (como *pip*, que viene a ser como *composer* en PHP). * Bibliotecas (*libraries*): una biblioteca es cualquier fragmento de código reutilizable que se puede incluir en otros proyectos. Las bibliotecas pueden ser paquetes o no. Existe una *Python Standard Library* que contiene todas las funciones básicas de Python y viene preinstalada con el *core* del lenguaje. Podemos incluir una librería en nuestro proyecto Python usando la palabra *import*: ```python import mi-librería ``` Como hemos dicho, dentro de cada módulo puede haber clases o subrutinas sueltas. Una subrutina (procedimiento o función) se declara así en Python (observa de nuevo como la indentación o sangrado es fundamental porque marca el comienzo y final de los bloques de código): ```python def mi-funcion(param1, param2, etc): # Aquí va el código de la función [return valor1, varlor2...] ``` En cuanto a las clases, la sintaxis para declararlas y muy similar a PHP, Java o C++ (recordando que, en Python, no se usan las llaves sino la indentación): ```python class MyClass: un_atributo = valor otro_atributo = valor # Esto es un constructor def __init__(self): self.un_atributo = 0 def un_metodo(parámetros): return lo_que_sea ``` ### 8.3.6. Ejemplo 1 en Python: Hola mundo ```python #!/usr/bin/python print \"Content-type: text/html\\n\\n\" print \"\" print \" ",
    "url": "/docs/dwes/_site/otros/python.html",
    "relUrl": "/otros/python.html"
  },"59": {
    "doc": "8.4 .NET",
    "title": "Hola, mundo",
    "content": "\") response.write(\" . \") %> ``` ### 8.4.7. Ejemplo 2 en VBasic: login con comprobación de email por Ajax Como antes, no mostraremos el código del lado del cliente (formulario + solicitud Ajax). Si quieres repasar ese código, lo encontrarás en la sección correspondiente al lenguaje Perl. Lo que sí encontrarás aquí es el código de login.asp, el script escrito en VB.NET que realiza la consulta a la base de datos para comprobar si el login es correcto y devuelve el resultado formateado en JSON. ```asp ``` ",
    "url": "/docs/dwes/_site/otros/punto-net.html",
    "relUrl": "/otros/punto-net.html"
  },"60": {
    "doc": "8.4 .NET",
    "title": "8.4 .NET",
    "content": "## 8.4.NET ### 8.4.1. Características de .NET Fecha de aparición: 1996 (ASP) / 2002 (.NET) Perspectivas: * .NET es la alternativa de Microsoft a JSP para desarrollo de grandes proyectos, donde PHP, Python o Ruby se quedan (o eso dicen desde Microsoft) pequeños. * .NET no es un lenguaje de programación, sino el conjunto de toda la tecnología de servidor de Microsoft para desarrollar aplicaciones web. Esa tecnología se puede usar con varios lenguajes. Los más habituales con Visual Basic .NET (conocido como VB.NET) y C#. * Tiene componentes exclusivos en el servidor y altas prestaciones. * Su coste es más elevado. * Hay que sufrir los problemas de seguridad endémicos a los productos Microsoft. Filosofía: * Framework de código cerrado y propietario. * Tecnología multilenguaje. Suele correr con VB.NET o C#. * Puede funcionar como PHP, embebido dentro de HTML. * Incluye controles de servidor exclusivos de Microsoft (equivalentes a los ActiveX del lado del cliente) ### 8.4.2. Configuración necesaria en el servidor Para hacer funcionar una aplicación .NET es necesario tener un servidor con sistema operativo Windows Server, que tiene integrado Microsoft IIS (Internet Information Server). También puede ejecutarse con un módulo de apache (llamado *mono*), pero es mucho más lento. Cada solución requiere su propio servidor. Si quieres PHP, Python o Ruby, usa Apache. Si quieres JSP, usa Tomcat. Si quieres ASP, usa IIS. Así te evitarás problemas. ### 8.4.3. Sintaxis básica de .NET con VB.NET El código VB.NET (como el de C#) se puede embeber en HTML de este modo: ```html ... Este texto se ha generado desde HTML ``` No es necesario declarar las variables de tipo simple, pero puede hacerse: ```vb Dim i,j,k As Integer ``` Los operadores son los habituales, excepto el de asignación, que se escribe con un solo igual. Las posibles ambigüedades con el operador de comparación se resuelven por el contexto: * Operadores de comparación: , =, =, * Operadores de asignación: = Y estas son algunas estructuras de control: ```vb Do While (condicion) Acciones Loop For variable As Integer = 1 To 5 Acciones Next If (condicion) Then Acciones-1 Else Acciones-2 End If ``` ### 8.4.4. Entrada / Salida Para leer los datos procedentes de un formulario debemos recurrir al objeto predefinido *request*: ```vb // Leer datos de un formulario (GET): variable = request.QueryString(\"campo\"); // Leer datos de un formulario (POST): variable = request.Form(\"campo\"); ``` La salida de datos se hace con *response.write()*: ```vb response.write (\"cadena\" + variable + \"cadena2\"); ``` ### 8.4.5. Bibliotecas, funciones y clases Con VB.NET (o C#) se pueden crear bibliotecas de clases de forma visual desde el propio entorno de programación de .NET. Las clases en VB.NET se definen de forma muy parecida a Java o PHP: ```vb class MiClase Inherits ClaseMadre Dim int UnAtributo; Dim bool OtroAtributo; Function MiMetodo(parametros) As tipo // Aquí va el código del método return valor; End Function End Class ``` Para utilizar una librería (estándar o de terceros) se utiliza la directiva @Import: ```vb @Import Namespace=\"Biblioteca\" ``` Por último, se pueden definir subrutinas independientes (funciones o métodos) con esta sintaxis: ```vb Sub NombreMétodo(parametros) Acciones; End Sub ``` ### 8.4.6. Ejemplo 1 en VBasic: Hola mundo ```asp \") response.write(\" ",
    "url": "/docs/dwes/_site/otros/punto-net.html",
    "relUrl": "/otros/punto-net.html"
  },"61": {
    "doc": "8.5 JSP",
    "title": "Hola, mundo",
    "content": "\"); out.println(\" . \"); %> ### 8.5.7. Ejemplo 2 en JSP: login con comprobación de email por Ajax Nuevamente, mostraremos solo el script del lado del sevidor (login.jsp). El código del lado del cliente lo tienes disponible en la sección que dedicamos al lenguaje Perl, donde solo tendrás que cambiar la referencia a \"login.pl\" por \"login.jsp\". ```jsp ``` ",
    "url": "/docs/dwes/_site/otros/jsp.html",
    "relUrl": "/otros/jsp.html"
  },"62": {
    "doc": "8.5 JSP",
    "title": "8.5 JSP",
    "content": "## 8.5. JSP ### 8.5.1. Características del lenguaje JSP Fecha de aparición: 1995 Perspectivas: * Usado para proyectos grandes y complejos, donde PHP (y otros lenguajes de scripting) se quedan pequeños. O eso aseguran los chicos de Oracle, claro. * El lenguaje de programación es Java, es decir, lo conoce cualquier programador. * Velocidad de ejecución superior a la de otros lenguajes semi-interpretados. Filosofía: * Adaptación natural de Java al lado del servidor. * Orientado a objetos. Multiplataforma. Fuertemente tipado. * Puede embeberse dentro de HTML, como PHP. * El código Java se precompila en un Servlet y se deja cargado en la memoria del servidor. Las peticiones subsiguientes se ejecutan así de forma más rápida. Este enfoque está siendo adoptado por otras tecnologías del lado del servidor, como NodeJS o algunos frameworks basados en otros lenguajes, que *precompilan* las vistas para servirlas mucho más deprisa. ### 8.5.2. Configuración necesaria en el servidor Para ejecutar Java en el lado del servidor, lo más apropiado es instalar Tomcat. Es el servidor de referencia para la tecnología JSP. Apache Tomcat es un servidor web capaz de contener y servir los servlets de Java. Implementa todos los servicios necesarios para que JSP funcione correctamente. Existen otros servidores, como JBoss o Embarcadero, pero Tomcat continúa siendo el más extendido en la actualidad. Como se ejecuta sobre la máquina virtual de Java, es posible hacerlo funcionar en cualquier sistema operativo. Otras soluciones, como ejecutar JSP a través de CGI en un servidor web convencional, son técnicamente viables pero resultan mucho más lentas. ### 8.5.3. Sintaxis básica de JSP El código JSP se embebe en HTML de este modo: ```html ... Este texto se ha generado desde HTML . ``` Las variables se declaran como en cualquier programa Java. Por ejemplo: ```java int var = 5; out.print(\"La variable var vale \" + var); ``` Estos son los operadores más habituales: ```java Comparación: , =, ==, != Asignación: = ``` Y estas son algunas estructuras de control: ```java while (condicion) { Acciones; } if (condicion) { Acciones-1; } else { Acciones-2; } ``` ### 8.5.4. Entrada / Salida La entrada de datos a través de un formulario HTML se hace usando el objeto request, que estará precargado en cualquier Servlet. La salida se puede hacer con un simple System.out.println(): ```java // Leer datos de un formulario: variable = request.getParameter(\"campo\"); // Salida: System.out.println (\"cadena\" + variable + \"cadena2\"); ``` ### 8.5.5. Bibliotecas, clases y métodos La forma de escribir clases y métodos en JSP es la misma que en Java, como es lógico. No vamos a explicar aquí todas las peculiaridades del lenguaje, que son muchas y pintorescas. Solo recordaremos que, en Java, no pueden existir métodos fuera de las clases, porque es un lenguaje orientado a objetos bastante estricto. La sintaxis para declarar una clase, sus atributos y sus métodos es esta: ```java class MiClase extends ClaseMadre { public|private|protected tipo atributo; public|private|protected tipo nombre(params) { Acciones; } } ``` Cada clase debe ir en un archivo independiente con el mismo nombre que la clase que contiene. Las clases de Java pueden agruparse en paquetes (*packages*). La forma de importar un paquete para usar sus clases en nuestro programa es: ```java import paquete; // Esto importa el paquete completo import paquete.clase; // Esto importa solo una clase del paquete ``` Pero cuidado, cuando se trabaja con JSP existe una pequeña diferencia en la forma de importar paquetes: en lugar de la sentencia *import*, se debe emplear una directiva del precompilador. Las directivas son instrucciones para el precompilador de Java que modifican su modo de proceder durante la compilación. Todas las directivas empiezan por el símbolo \"@\". En el caso concreto de la importación de paquetes o clases en un script JSP, la directiva que debemos emplear es: ```jsp ``` ### 8.5.6. Ejemplo 1 en JSP: Hola mundo \"); out.println(\" ",
    "url": "/docs/dwes/_site/otros/jsp.html",
    "relUrl": "/otros/jsp.html"
  },"63": {
    "doc": "8.6 Ruby",
    "title": "Hola, mundo",
    "content": "\" print \" . \" ``` ### 8.6.7. Ejemplo 2 en Ruby: login con comprobación de email por Ajax Una vez más, solo mostraremos el script del lado del servidor (login.rb). Para revisar el código del lado del cliente, puedes acudir a la sección dedicada al lenguaje Perl, y sustituir la referencia al script login.pl por login.rb. El resto del código permanecerá idéntico. ```ruby #!/usr/bin/ruby require \"mysql\" require \"cgi\" begin # Conexión con la base de datos con = Mysql.new 'server', 'db-user', 'db-password', 'db-name' # Recuperamos la información del formulario HTML cgi = CGI.new name = cgi[\"username\"] pass = cgi[\"password\"] # Consultamos la base de datos res = con.query(\"SELECT id FROM users WHERE user = '#{name}' AND password = '#{pass}'\") # Generamos la salida JSON para el cliente print \"Content-type: application/json\\n\\n\" if res.num_rows == 0 print %Q!{\"error\": \"Username or password not valid\"}! else row = res.fetch_hash print %Q!{\"success\": \"Authentication is OK\", \"userid\": \"#{row['id']}\" }! end con.close if con end ``` ",
    "url": "/docs/dwes/_site/otros/ruby.html",
    "relUrl": "/otros/ruby.html"
  },"64": {
    "doc": "8.6 Ruby",
    "title": "8.6 Ruby",
    "content": "## 8.6. Ruby ### 8.6.1. Características del lenguaje Ruby Fecha de aparición: 1995 Perspectivas: * Uso y popularidad creciente. * Base de programadores fiel y especializada. * Excelente relación señal/ruido. * Aún tiene algunos problemas por resolver: El lenguaje todavía está en fase de importantes cambios, tiene peor rendimiento que Python o PHP y muchos módulos (gemas) están mal documentados. Filosofía: * Completa –y verdaderamente– orientado a objetos. Todo es un objeto. * Admite otros paradigmas ocultos bajo los objetos. * “Rápido y fácil”. Es un lenguaje divertido: de programadores para programadores. * Curva de aprendizaje larga pero nunca abrupta. * Potente sistema de expresiones regulares. * En combinación con Rails, ideal para desarrollo web MVC rápido y basado en prototipos. #### ¿Y Ruby on Rails? Rails, también conocido como *Ruby-on-rails*, es un framework para desarrollar aplicaciones web MVC con Ruby. Apareció en 2004 y gustó tanto que otros frameworks para otros lenguajes (como Laravel para PHP) se han inspirado en su forma de trabajar: abundantes capas de abstracción para evitar tareas de bajo nivel, *scaffolding*, integración con Ajax, *Convention over Configuration* (CoC) y *Don't Repeat Yourself* (DRY). Rails se hizo tan famoso que mucha gente, aún hoy en día, confunde el lenguaje (Ruby) con el framework (Ruby on Rails). ### 8.6.2. Configuración necesaria en el servidor Para poder ejecutar scripts en Ruby en un servidor web Apache o similar, necesitarás: * Instalar el intérprete Ruby en el sistema. * Instalar el módulo de Ruby (mod_ruby) y/o el módulo cgi (mod_cgi) para Apache. * Configurar el manejador de Apache para CGI. * Instalar módulos adicionales para Ruby (como cgi o mysql) si son necesarios. Como en el caso de Perl o Python, Ruby puede correr de forma nativa en Apache (más rápido pero menos frecuente) o como script CGI. ### 8.6.3. Sintaxis básica de Ruby En Ruby, no es necesario declarar las variables. El tipado es dinámico (tipo *duck*: si anda como un pato y parece un pato, es que es un pato). Todo es un objeto en este lenguaje, incluso números enteros o los valores constantes, lo cual conduce a expresiones chocantes como estas: ```ruby 5.isEven? \"cadena\".lenght variable_cadena.chop! ``` Ruby está lleno de convenciones para evitar tener que llenar la documentación de explicaciones innecesarias (a esto se le llama \"filosofía CoC\" = *Convention over Configuracion*). Por ejemplo: * Es una convención que todos los métodos cuyo nombre termine en una interrogación, deben devolver un booleano. En el ejemplo anterior, el método *isEven* es uno de ellos. * Otra convención es que todos los métodos cuyo nombre termine en una admiración, modificarán irreversiblemente el objeto con el que se invocan. En el ejemplo anterior, el método *chop!* troceará la cadena cada vez que encuentre un espacio en blanco en su interior, convirtiéndola en un array de cadenas. Los operadores de Ruby son los habituales: ```ruby Comparación: ==, , =, =, != Asignación: = ``` Las estructuras de control también te resultarán familiares. No se utilizan llaves ({...}) para marcar los bloques, sino que cada bloque finaliza con la palabra *end*. El sangrado es optativo pero, por supuesto, muy recomendable. ```ruby while condicion Acciones end if condicion Acciones-1 else Acciones-2 end ``` Sin embargo, el uso de bucles clásicos casi siempre puede sustituirse por iteradores sobre objetos, algo cada vez más frecuente en los lenguajes orientados a objetos: ```ruby variable_array.do_each ... end num_rows.times do ... end ``` ### 8.6.4. Entrada / Salida La entrada de datos a través de un formulario HTML se hace usando un objeto de la clase CGI. La salida, con una sencilla sentencia *print*: ```ruby // Leer datos de un formulario require \"cgi\" cgi = CGI.new variable = cgi[\"campo\"]; // Salida de datos print \"cadena\", variable, \"cadena2\", ... ``` ### 8.6.5. Bibliotecas, clases y métodos Las clases en Ruby se declaran de forma muy semejante a Python (observa cómo el símbolo \"\" print \" ",
    "url": "/docs/dwes/_site/otros/ruby.html",
    "relUrl": "/otros/ruby.html"
  },"65": {
    "doc": "8.7 Node.js",
    "title": "8.7 Node.js",
    "content": "## 8.7. Node.js **Node.js** no es un lenguaje de programación, sino un entorno de ejecución en el lado del servidor (aunque puede funcionar en otros entornos) basado en el lenguaje **Javascript**. Por lo tanto, al contrario que el código Javascript convencional, Node.js ejecuta Javascript en el servidor. De este modo, pueden unificarse los lenguajes del lado del cliente y del servidor. Esa es una de las razones que explica el rápido crecimiento que Node.js está experimentando en los últimos años. Como es lógico, en Node.js se omiten todas las referencias a la API del navegador web y, como es lógico también, se añade soporte para las APIs del sistema operativo u otros subsistemas típicos que se encuentran en los servidores. Por ejemplo, con Node.js tenemos acceso a bases de datos o al sistema de ficheros del servidor. Vamos a ver una introducción muy breve a Node.js. Ten en cuenta que, además, Node.js no suele usarse de forma independiente para desarrollar aplicaciones web, sino en conjunción con algún framework como **Express**. De hecho, es rara la aplicación web que se programa sin Express en la actualidad. ### 8.7.1. Características del lenguaje Node.js Fecha de aparición: 2009 Perspectivas: * Uso y popularidad creciente. * Posibilidad de convertirse en un estándar de desarrollo web *fullstack*. * Buena relación señal/ruido. * Node.js tiene problemas que resolver si quiere imponerse como estándar: la API cambia continuamente y no es compatible hacia atrás, la librería estándar de Javascript es minúscula comparada con otros lenguajes y las librerías de terceros son a veces poco probadas, cambiantes o directamente inexistentes para hacer ciertas cosas que en otras plataformas se dan por supuestas. Filosofía: * Usa el motor de JavaScript V8 de Chrome *fuera del navegador* para ejecutarse en el servidor. * Las operaciones de E/S son *sin bloqueo*, esto es, *asíncronas*. * El fluje de ejecución no es lineal, sino *dirigido por eventos*, como ocurre casi siempre en las aplicaciones web. Esto mejora el rendimiento, porque el programa está casi todo el tiempo ocioso, a la espera de que ocurra algún evento. * Tiene acceso nativo a bases de datos documentales como *MongoDB*. Hablaremos un poco más sobre qué significa esto más adelante. * Las aplicaciones altamente escalables. * Simplicidad y modularidad. * Gestor **npm** para librerías de terceros. ### 8.7.2. Configuración necesaria en el servidor Node.js **incluye su propio servidor web**. Recuerda que Node.js *no* es un lenguaje de programación, sino una plataforma de desarrollo en el lado del servidor completa. Así que, para lanzar un servidor web con Node.js, lo único que debemos instalar en el servidor es el propio Node.js. Una vez hecho esto, podemos crear un servidor HTTP básico creando un programa Javascript como este: ```javascript var http = require('http'); http.createServer(function (peticion, respuesta) // Aquí se escribe la respuesta del servidor ).listen(9000, '127.0.0.1'); // Puerto e IP donde escuchará el servidor ``` Luego bastará con ejecutar este programa en el servidor desde una consola de comandos: ``` $ node nombre-del-archivo.js ``` ### 8.7.3. Sintaxis básica de Node.js El lenguaje de programación que usa Node.js es Javascript, así que hay poco que decir sobre la sintaxis de las estructuras de control, las asignaciones o los operadores, puesto que ya la conoces. ### 8.7.4. Entrada / Salida con Node.js La entrada y salida en un entorno Node.js es lo que más se diferencia del Javascript que manejas habitualmente, puesto que ahora estamos trabajando en un servidor, no en un navegador web. La salida mediante **console.log()** puede seguir usándose, pero no es lo habitual en aplicaciones web, puesto que esa salida se producirá en la consola de texto del servidor. Para la entrada, existe la función **openStdin()**, que crea un objeto sobre el que se puede agregar un evento de entrada de datos, como en este ejemplo: ```javascript console.log(\"Escribe tu nombre\"); var stdin = process.openStdin(); stdin.addListener(\"data\", function(entradaPorTeclado) { console.log(\"Tu nombre es: \" + entradaPorTeclado.toString()); }); ``` Aquí se puede ver **qué significa que Node.js sea un entorno de ejecución dirigido por eventos**: en lugar de lanzar la lectura por teclado y dejar al programa esperando hasta que esa lectura por teclado se produzca, lo que hacemos es asignar un **manejador de evento** o **listener** que se ejecutará cuando ocurra cierto evento asociado. En este ejemplo, asociamos un *listener* al objeto *stdin*. Cuando ocurra el evento (en este caso, el evento se llama \"data\", que significa \"recepción de datos\" en el objeto *stdin*), se ejecutará el código de la función. Mientras tanto, el programa continuará con su ejecución normal, atendiendo a cualquier otro evento que pudiera producirse y que esté programado para atender. Sin embargo, en una aplicación web, raramente se hace la entrada y salida por consola, ¿verdad? **La entrada debería hacerse desde un formulario web, mientras que la salida debería ser una respuesta HTTP**. Te muestro cómo se hace esto con Node.js con otro ejemplo: ```javascript var http = require('http'); var datos_del_post; http.createServer(function(peticion, respuesta) { if(peticion.method == 'POST'){ var datos_del_post = ''; peticion.on('data', function(trozo_de_datos){ datos_del_post += trozo_de_datos; }); peticion.on('end', function(){ datos_del_post = querystring.parse(datos_del_post); respuesta.writeHead(200, {'Content-Type': 'text/html'}); respuesta.write(\"He recibido correctamente el formulario\"); respuesta.write(\"Estos son los datos que me han llegado:\"); respuesta.write(\"Nombre: \" + datos_del_post.name + \". Email = \" + datos_del_post.email); frespuesta.end(); }); }else{ respuesta.writeHead(200, {'Content-Type': 'text/html'}); respuesta.end(\"No he ha llegado ningún dato por POST\"); } }).listen(9000, '127.0.0.1'); ``` Si observas este código, verás que tiene la misma estructura que el que vimos en el apartado \"Configuración necesaria en el servidor\", solo que hemos rellenado la función principal con más cosas. Esa función tiene dos argumentos, ***petición*** y ***respuesta***: * En ***petición***, el servidor coloca todos los datos de la petición que proviene del cliente. La información del formulario estará aquí, por lo tanto. * En ***respuesta***, el servidor colocará todos los datos de la respuesta HTTP que va a enviar al cliente. Fíjate cómo en el código, en primer lugar, miramos si la petición del cliente nos llegó por POST. Si es así, creamos dos manejadores de eventos: * El manejador **\"data\"** se ejecutará cuando llegue un nuevo fragmento de información por POST. * El manejador **\"end\"** se ejecutará cuando haya terminado de recibirse información desde el cliente. Por eso, en el manejador \"data\" nos limitamos a ir encadenando los datos que llegan por POST en la variable *datos_del_post*, y es en el manejador \"end\" cuando los procesamos. Observa cómo en ese manejador generamos la respuesta HTTP mediante el método ***write()***. La respuesta se envía al cliente cuando se ejecuta el método ***end()***. ### 8.7.5. Módulos de Node.js Las bibliotecas o **módulos**, como se llaman en Node.js, son una parte crucial de este entorno de desarollo. Los módulos, como en cualquier lenguaje, permiten reutilizar código, pero gracias a **npm** (*Node Package Manager*), puedes insertar tus librerías dentro de otras, o bien publicarlas para ponerlas al servicio de la comunidad. Y, por supuesto, usar las librerías de otros para tus proyectos. #### Require Para utilizar un módulo, se usa **require**. Por ejemplo, un módulo de la librería estándar de Node.js se llama \"fs\" y sirve para manipular ficheros. Si lo necesitamos en nuestro programa, basta con escribir esto: ```javascript const fs = require('fs'); fs.readFile('./file.txt', 'utf-8', (err, data) => { if(err) { throw err; } console.log('data: ', data); }); ``` En este ejemplo, hemos importado el módulo \"fs\" y lo hemos asignado a una variable. A partir de esa variable, podemos usar cualquier método del módulo, como *readFile()*. La lista de funciones disponibles, como es lógico, tendrás que consultarla en la documentación del módulo. **require** buscará los módulos en este orden: 1. Módulos de la librería estándar de Node.js 2. Módulos importados con *npm* 3. Módulos locales, es decir, que hayamos descargado y almacenado manualmente en el directorio de trabajo. #### Librería estándar de Node.js Con solo instalar Node.js en el sistema, ya dispones de todos los módulos de la librería estándar. Algunos de los módulos más utilizados con aplicaciones web son: * **fs**: Para manipular ficheros. * **path**: Para trabajar con directorios. * **http**: Para crear servidores y clientes. * **url**: Para analizar URLs y extraer segmentos y variables de ellas. #### Módulos instalados con npm Los módulos instalados con npm están desarrollados por terceros, es decir, no forman parte del *core* de Node.js. Exiten literalmente miles de módulos que puedes instalar con npm, ya que cualquier desarrollador puede publicar el suyo. Asegúrate de consultar la web del desarrollador (y, sobre todo, la página de documentación) antes de instalar un módulo. Algunos ejmplos de módulos npm que podrían ser útiles en una aplicación web son: * **lodash**: Para manipular arrays, objetos, colecciones, cadenas... * **request**: Un servidor http más simple de usar que el módulo estándar que viene con Node.js. * **gm**: Permite manipular imágenes en el servidor: rotación, recorte, redimensionamiento, etc. * **pdfkit**: Para importar y exportar documentos PDF. * **express**: Un framework completo (aunque minimalista) para trabajar con Node, con soporte para *middlewares*, renderizadores de vistas y mucho más. * **restify**: Para crear servidores REST de forma aún más minimalista que con *express*. Para instalar un módulo mediante npm, basta con teclear esto en un terminal: ``` $ npm install pdfkit ``` Después, en nuestro código fuente, podemos usar ese módulo así: ```javascript const pdfkit = require('pdfkit'); ``` ### 8.7.6. Node.js y MongoDB **MongoDB** es un gestor de bases de datos **no relacional** (o **no-SQL**) con una implantación creciente en el mercado profesional. Se dice que MongoDB está **orientado a documentos**. Los *documentos* en estas bases de datos son el equivalente a los *registros* de las bases de datos relacionales, pero menos rígidos. Un documento puede contener literalmente cualquier cosa, siempre que esté formateada del modo adecuado para la base de datos (lo que significa, generalmente, que esté escrito en correcto XML o JSON). Las bases de datos documentales son capaces de bucear en esos documentos, crear nuevos documentos, modificarlos y borrarlos, indexarlos y, como es lógico, realizar búsquedas. MongoDB agrupa los documentos en **colecciones**, de modo que si un documento es algo parecido a un registro (pero más flexible), una colección es algo parecido a una tabla (también más flexible). No existe el concepto de campo, dominio, ni nada parecido: cada documento de la colección puede tener su propia estructura. MongoDB y Node.js se han llevado muy bien desde siempre, hasta el punto de que parte del éxito actual de uno se debe al éxito del otro, y viceversa. No es nuestra intención (ni tenemos espacio aquí) adentrarnos en los vericuetos de las bases de datos documentales, sino presentártelas para que conozcas su existencia. Si pretendes dedicarte al desarrollo web profesionalmente, es muy posible que, antes o después, te encuentres con bases de datos no-SQL como MongoDB. ### 8.7.7. Ejemplo 1 en Node.js: Hola mundo ```javascript var http = require('http'); http.createServer(function (req, res) // Cabecera http. No es imprescindible, pero sí recomendable. // Recuerda que el código 200 significa \"OK\" en el protocolo http/https. // El 'Content-type' más habitual es 'text/html' o 'application/json'. res.writeHead(200, 'Content-Type': 'text/html'); res.write('Hola, mundo!'); res.end(); ).listen(9000); // Puerto donde el servidor escuchará ``` ### 8.7.8. Ejemplo 2 en Node.js: login con comprobación de email por Ajax Como en las ocasiones anteriores, solo mostramos aquí el script del lado del servidor (login.js). Para revisar el código del lado del cliente, puedes acudir a la sección dedicada al lenguaje Perl, y sustituir la referencia al script login.pl por login.js. El resto del código permanecerá idéntico. Hay que destacar que, con el uso de **Express**, la implementación de esta respuesta del servidor se simplificaría bastante. No lo tomes, por lo tanto, como un ejemplo realista, sino como una muestra el aspecto que tiene el código fuente de Node.js. Observa que, al tratarse de un código dirigido por eventos, no escribimos el algoritmo de arriba a abajo, en el orden en el que se deben ejecutar las cosas, sino que vamos respondiendo a estos eventos: * Recepción de datos por GET. * Finalización de la recepción de datos por GET. * Conexión lista con la base de datos. Curiosamente, la consulta a la base de datos no lanza un evento cuando está lista, sino que la función manejadora se indica justo a continuación de la consulta. Esta función se ejecutará cuando la consulta finalice y la base de datos devuelva los resultados. ```javascript var mysql = require('mysql'); var http = require('http'); var GETdata, dbconnection; http.createServer(function(peticion, respuesta) { if(peticion.method == 'GET'){ var GETdata = ''; peticion.on('data', function(data) { // Vamos recogiendo los datos que llegan por GET GETdata += data; }); peticion.on('end', function(){ // Ha finalizado la llegada de datos. Preparamos la conexión con la BD. GETdata = querystring.parse(GETdata); var dbconnection = mysql.createConnection({host: \"localhost\", user: \"nombre-usuario\", password: \"contraseña\", database: \"nombre-base-de-datos\"}); }); } dbconnection.connect(function(err) { // La conexión con la BD ya está lista if (err) throw err; // Lanzamos la consulta y procesamos la respuesta dbconnection.query(`SELECT * FROM users WHERE username = '${GETdata.username}' AND password = '${GETdata.password}'`, function (err, result, fields) { if (err) throw err; respuesta.writeHead(200, {'Content-Type': 'application/json'}); if (result.length == 0) { respuesta.write(JSON.stringify({\"error\": \"Username or password not valid\"})); } else { respuesta.write(JSON.stringify({\"success\": \"Authentication OK\", \"userid\": result[0].id})); } respuesta.end(); }); }); }).listen(9000, '127.0.0.1'); ``` ",
    "url": "/docs/dwes/_site/otros/nodejs.html",
    "relUrl": "/otros/nodejs.html"
  },"66": {
    "doc": "8.8 Más tecnologías aún",
    "title": "8.8 Más tecnologías aún",
    "content": "## 8.8. Y otras tecnologías aún más extrañas Además de los lenguajes que hemos visto, existen otras alternativas a PHP para desarrollar aplicaciones web en el lado del servidor. A continuación mostramos una lista con alguna de estas alternativas (no están todas las que son, pero sí son todas las que están) para quien quiera profundizar aún más en el asunto: ### 8.2.1. ColdFusion ColdFusion es la alternativa en el lado del servidor de Adobe. Es al mismo tiempo **un servidor de aplicaciones y un lenguaje de programación**. Utiliza elementos para insertar su código en la página web y, lógicamente, interacciona de manera óptima con otros productos de Adobe. Los archivos tienen extensión .cfm. Se diseñó para tener un rendimiento muy elevado (por ejemplo, aprovecha bien la presencia de múltiples procesadores en el servidor). Su implantación siempre ha sido bastante minoritaria. ### 8.2.2. WebDNA WebDNA es un lenguaje especialmente diseñado para hacer scripting del lado del servidor (no como PHP, Perl, Python o Ruby, que fueron pensados para otros propósitos). Especialmente rápido en la interacción con bases de datos. Utiliza etiquetas encerradas entre corchetes [...] para intercalar su código con HTML. A pesar de sus notables características, nunca ha gozado de demasiado éxito. ### 8.2.3. Erlang Se trata de un lenguaje para desarrollo de aplicaciones concurrentes (es decir, en las que varios procesos se ejecutan simultáneamente, cooperando en la resolución de un problema). Fue diseñado para sistemas en tiempo real, y se utiliza a veces en el lado del servidor cuando las aplicaciones tienen necesidades de procesamiento muy elevadas. ### 8.2.4. Otros SSJS (Server Side JavaScript) Node.js no inauguró la moda de utilizar Javascript en el lado del servidor: solo ha tenido más éxito que otros. Hace mucho tiempo que se juguetea con la idea de programar scripts del lado del servidor en JavaScript, por lo que existen otras soluciones como **JSSP**, un proyecto *opensource* que de momento no ha tenido demasiado éxito, o **Wakanda**, basado parcialmente en Node y que incluye de forma nativa más cosas, como su propio gestor de bases de datos relacionales o soporte para frameworks en el cliente (Angular, por ejemplo). ",
    "url": "/docs/dwes/_site/otros/mas-tecnologias-aun.html",
    "relUrl": "/otros/mas-tecnologias-aun.html"
  },"67": {
    "doc": "Apéndice I. Sistemas de control de versiones. Git",
    "title": "Apéndice I. Sistemas de control de versiones. Git",
    "content": "# Apéndice 1. Sistemas de control de versiones. Git {: .no_toc } - TOC {:toc} # A1.1. Sistemas de control de versiones Es *inconcebible* que un desarrollador trabaje en la actualidad sin un sistema de control de versiones. Fíjate que en la frase anterior no tiene cabida tu opinión. Lo siento, pero es lo que hay. No importa si te gustan estos sistemas o no. No importa si estás los usas de forma habitual o siempre has huido de ellos como de la peste. No importa si ni siquiera sabes qué son o cómo funcionan. Si quieres dedicarte profesionalmente al desarrollo de software, tienes que conocerlos porque te los vas a encontrar vayas donde vayas. ## A1.1.1. ¿Qué es un sistema de control de versiones? Un **sistema de control de versiones** es un *almacén en la nube pensado para equipos de desarrollo de software*. Es decir, como Google Drive, pero a lo bestia. El sistema de control de versiones no solo sirve para que un puñado de usuarios (entre uno y miles) suban su código fuente a la nube para ponerlo a salvo de posibles problemas con las máquinas locales, sino que, además, permite: * Conservar absolutamente todo el historial de versiones previas. * Documentar cada cambio, de manera que siempre sea posible saber quién, cómo, dónde, cuándo y por qué escribió cada línea de código. * Revertir el software a un estado anterior en cualquier momento. * Crear ramas o \"estados alternativos\" del software, que luego podrán fusionarse con otras ramas o abandonarse sin llegar a nada. * Crear \"forks\" o réplicas del sistema que luego podrán evolucionar de forma independiente (o volver a fusionarse con el contenido original). * Evitar conflictos cuando el mismo código fuente ha sido editado simultánemente por dos personas. Y, en caso de que estos conflictos ocurran, ayudar a resolverlos. Se trata de un buen puñado de funciones, ¿verdad? Ese es el motivo por el que absolutamente todas las organizaciones serias que se dedican a desarrollar software utilizan algún sistema de control de versiones. Pero es que incluso para un programador/a solitario, que trabaja de forma autónoma, las ventajas de usar uno de estos sistemas superan de lejos a los inconvenientes, porque... espera un momento... ¡Resulta que no tienen ningún inconveniente! Así que ya lo sabes: si aún no los usas, este es el momento de hacer un esfuerzo e incorporar un sistema de control de versiones a tu vida. ## A1.1.2. ¿Cómo funcionan los sistemas de control de versiones? Existen muchos sistemas de control de versiones, aunque el mercado está dominado por unos pocos de ellos: CVS, Subversion, Mercurial, Bazaar y, sobre todo, Git. Cada uno tiene sus propias peculiaridades, pero suelen compartir varias características comunes: * El código fuente del proyecto (y todas sus versiones previas) se guarda en uno o varios servidores. Esa colección de código fuente se denomina ***repositorio***. El servidor puede estar en Internet y pertenecer a una compañía externa. También puede estar en nuestra intranet, instalado en una de nuestras máquinas. O puede estar en nuestro propio ordenador. * Los repositorios pueden ser **remotos** (si están en otra máquina distinta de la nuestra) o **locales** (si están en nuestra máquina). * **Siempre se trabaja sobre el repositorio local**. Cuando una funcionalidad del código se termina, el código fuente modificado se sube al repositorio remoto, para que el resto de miembros del equipo puedan disponer de él. * Si otra persona del equipo ha modificado los mismos archivos fuente que nosotros, el sistema de control de versiones nos avisará del conflicto durante la sincronización y nos obligará a hacer manualmente una fusión de los archivos afectados, mostrándonos las diferentes versiones del mismo, antes de completar la sincronización. La sincronización con el repositorio remoto, por lo tanto, no puede ser automática (como en Google Drive o Dropbox), sino que hemos de hacerla explícita, momento en el cual el sistema nos avisará de posibles conflictos. Esta es la única manera de resolver adecuadamente esos conflictos en proyectos donde haya mucha gente trabajando simultáneamente. # A1.2. Git básico Git es, en la actualidad, el sistema de control de versiones más utilizado del mundo con diferencia. También es uno de los más completos y complejos. Así que, si aprendes a utilizar Git, podrás apañártelas con cualquier otro sistema de control de versiones. En esta sección vamos a ver cómo se usa Git a nivel básico. El acceso a las funciones avanzadas irá viniendo solo, con el tiempo y el uso. ## A1.2.1. Poniendo en marcha Git Git es un sistema de control de versiones que se creó inicialmente para desarrollar el núcleo de Linux. Es de código abierto (*opensource*). Eso quiere decir que cualquiera puede coger el código, modificarlo, adaptalo y distribuirlo. Por eso encontrarás multitud de implementaciones de Git, así como muchos servidores y clientes que lo usan. Todos son compatibles entre sí. Git crea repositorios locales y remotos que hay que mantener sincronizados manualmente. Para usar Git, necesitas al menos: * Instalar un **cliente de Git** en tu ordenador de trabajo. * Instalar un **servidor de Git** en el ordenador donde vayas a alojar el repositorio remoto. Para el servidor Git, mucha gente utiliza **servidores gratuitos disponibles en Internet**. Los más conocidos de ellos son **GitHub** y **GitLab**. Son sitios web donde te registras y ¡voilà!, ya tienes disponible un servidor Git en línea para que funcione de repositorio remoto. Además, estos sitios proporcionan características adicionales muy convenientes, como sistemas de gestión de *issues* o tareas pendientes, gestión de proyectos, estadísticas, evaluación de la calidad de software, etc. También funcionan como redes sociales para desarrolladores. En fin, que, salvo que seas un paranoico de la seguridad o estés desarrollando código ultrasecreto para la NSA o el CSIF, usar GitHub o GitLab como repositorio remoto es la opción más interesante. Así que ya puedes dejar de leer esto y registrarte ahora mismo en alguno de los dos. ¿Ya estás de regreso? Vale, ahora tienes que instalarte en tu ordenador un cliente Git. Clientes Git hay muchos, algunos más bonitos que otros. Yo te recomiendo el cliente básico en modo texto, con el que tendrás que salirte a la consola y teclear comandos. Teclear comandos incomprensibles de forma rápida y segura siempre queda muy bien para presumir. Aparte de eso, aprenderse los comandos básicos de Git te salvará la vida en algún momento de tu futuro profesional, te lo aseguro, así que es una buena inversión de tiempo. Puedes encontrar los clientes oficiales de Git en la web del proyecto: **https://git-scm.com/** Cuando hayas aprendido a apañarte con los comandos, es posible que te gusten tanto que ya no quieras recurrir a los clientes gráficos. Pero, por si acaso no es así, te comento que existen mogollón de ellos que te permitirán sincronizar tus archivos con un solo clic y resolver conflictos de forma rápida y muy visual. Algunos de ellos son: **GitHub Desktop** (ofrecido por GitHub), **GitKraken**, **Git Cola** o **Tortoise Git**. Por último, ten en cuenta que todos los entornos de desarrollo medianamente potentes ofrecen una integración absoluta con Git. Es decir, que si usas **Visual Studio Code**, **Eclipse**, **NetBeans** o muchos otros, no necesitarás ningún cliente git adicional, porque ya lo traen incorporado. Tan solo debes configurar la ruta el repositorio remoto y al local, y hala, a programar y a sincronizar como si no hubiera un mañana. ## A1.2.2. Creando un repositorio nuevo Bien, pues ya tenemos nuestra cuenta en GitHub o GitLab y hemos instalado un cliente Git en nuestra máquina. ¿Ahora qué? Podemos encontrarnos ante dos escenarios diferentes: 1. Voy a empezar un proyecto nuevo y quiero inicializar un repositorio en blanco. 2. Ya tengo mi código fuente (todo o una parte) escrito y quiero añadirlo a un repositorio git. Vamos a ver cómo proceder en cada caso. Lo haremos mostrando cómo se usa el cliente git de línea de comando. Desde los clientes gráficos, el proceso será parecido, pero tendrás que trastear con el cliente en cuestión o leerte su documentación para ver los detalles. #### Caso 1: Voy a empezar un proyecto nuevo y quiero inicializar un repositorio en blanco. 1. Abre un terminal de línea de comandos y muévete al directorio o carpeta donde tienes pensado crear tu código fuente. Usa para ello los comandos ```cd carpeta``` (para cambiar de carpeta) o ```mk carpeta``` (para crear una carpeta nueva). 2. Para crear un repositorio git local en la carpeta elegida, simplemente teclea este comando: ``` $ git init ``` 3. Para conectar este repositorio local con un repositorio remoto en GitHub o GitLab, escribe a continuación este comando: ``` $ git remote add origin ``` Sustituye \"URI\" por la dirección de tu repositorio que te habrá proporcionado GitHub o GitLab. Por ejemplo, en GitHub, una URI de repositorio tiene un aspecto como este: https://github.com/usuario/nombre-repositorio.git). Obviamente, el repositorio remoto deberías haberlo creado antes desde la web de GitHub o GitLab. Eso es todo. A partir de ahora, podrás empezar a desarrollar tu código en local y a sincronizar tus archivos con el repositorio remoto cada vez que lo necesites. El procedimiento para hacer esto último lo describimos un poco más adelante. #### Caso 2: Ya tengo mi código fuente y quiero añadirlo a un repositorio git Este caso es un poquito más complejo, pero tampoco mucho. Asegúrate de tener ya creado un repositorio (vacío) en GitHub o GitLab antes de seguir esta guía. 1. Abre un terminal de línea de comandos y muévete a la carpeta donde tengas tu código fuente. Usa para ello el comando ```cd carpeta```. 2. Para crear un repositorio git local en esa carpeta, simplemente teclea este comando: ``` $ git init ``` 3. Para conectar este repositorio local con un repositorio remoto en GitHub o GitLab, escribe esto: ``` $ git remote add origin ``` Sustituye \"URI\" por la dirección de tu repositorio que te habrá proporcionado GitHub o GitLab. Por ejemplo, en GitHub, una URI de repositorio tiene un aspecto como este: https://github.com/usuario/nombre-repositorio.git) 4. Edita el archivo .gitignore para incluir en él los archivos y carpetas que no quieres incluir en el repositorio. Más adelante hablaremos del archivo .gitignore con más detalle, porque es muy importante. 5. Haz tu primer commit para añadir todo el código fuente que ya tienes: ``` $ git add * $ git commit -m \"Primer commit con todo el código preexistente\" ``` 6. Sube el código de ese commit a tu repositorio remoto (te pedirá tu usuario y contraseña en GitHub o GitLab): ``` $ git push ``` Si ahora entras en tu perfil de GitHub o GitLab, verás que el repositorio remoto ya contiene todos los archivos que tenías en tu proyecto (excepto los que señalaste en .gitignore). Los repositorios local y remoto ya están creados y puedes empezar a trabajar con normalidad, escribiendo código y subiéndolo al repositorio remoto cuando lo necesites. Este proceso lo describiremos en detalle enseguida. Si no has entendido alguno de estos pasos, no te agobies. Enseguida te quedarán más claros. #### Más cosas sobre la inicialización de un repositorio Hay otro par de cosas que te interesa hacer al iniciarlizar un repositorio. Solo tendrás que hacerlo una vez y, después, tu repositorio lo recordará. Después del *git init*, puedes indicarle al repositorio qué usuario de GitHub o GitLab va a realizar los commits. Esto se hace así: ``` $ git --config user.name \"Mi-nombre-de-usuario\" $ git --config user.email \"Mi-email\" ``` Para comprobar que la información es correcta, simplemente teclea: ``` $ git --config list ``` #### ¡Antes de continuar! No te olvides de .gitignore Una última cosita antes de describir cómo es el trabajo cotidiano con git y qué significa todo eso de los commits. Esa cosita es sobre el archivo ***.gitignore***. Es un archivo muy importante que debería estar en el directorio raíz de tu proyecto. Si no existe, créalo. Ten en cuenta que en los sistemas GNU/Linux y Mac, los archivos cuyo nombre empiezan por un punto se consideran ocultos, por lo que es posible que el archivo esté ahí sin que lo veas. Ese archivo **contiene una lista de todas las cosas que no se deben subir al repositorio remoto**. Esto incluye, entre otros: * **Los archivos de configuración**. Es habitual en una aplicación web tener un archivo de configuración (llamado *config.php* o algo parecido) con un puñado de variables donde se guarda el host de la base de datos, el usuario y la contraseña para ese host, el nombre de la base de datos, etc. Y, vamos a ver, ¿de verdad quieres que cualquiera que acceda a tu repositorio de GitHub o GitLab vea esa información? Además del problema de seguridad que puede suponerte (sobre todo si, como el 99% de los desarrolladores, usas el acceso root a tu servidor local de bases de datos mientras estás desarrollando un nuevo proyecto), es que no tiene sentido subir esa información al repositorio remoto, porque será diferente en cada servidor donde la aplicación se ponga en producción. Lo que sí suele hacerse es crear un archivo de configuración de ejemplo (algo como config-example.php), donde se muestre la estructur que debe tener config.php pero se dejen en blanco los valores de las variables. Ese archivo sí que puede sincronizarse con el resto del código y subirse a GitHub o GitLab. * **Archivos de recursos que no forman parte de la aplicación**. Imagina que estás programando una aplicación web para una biblioteca. Esa aplicación usa algunas imágenes para construir sus vistas (por ejemplo, una hermosa fotografía de un libro antiguo para el encabezamiento). Esas imágenes **sí** forman parte de la aplicación y **sí** deben subirse al repositorio remoto. Pero ahora supón que, como es lógico, para probar la aplicación has creado un montón de libros falsos en tu base de datos local. Cada vez que añades un libro falso, le asignas una imagen de la portada (falsa también), que la aplicación almacenará en algún directorio del servidor local. Esas imágenes forman parte de los datos de prueba, no de la propia aplicación, y, por tanto **no** deberían subirse a GitHub ni GitLab. El directorio completo donde almacenes esas imagenes debería incluirse en .gitignore. Si no lo haces así, llenarás el repositorio remoto de basurilla y, además, harás que ocupe mucho más espacio del necesario, hasta el extremo que una clonación del repositorio puede tardar varias horas y ocupar muchos gigabytes. Ten en cuenta que el repositorio no solo contiene el estado actual del proyecto, sino también *todos los estados anteriores*, lo que incluye todas las imágenes de libros falsos que hayas podido añadir alguna vez durante el desarrollo. Esto no solo es aplicable a imágenes, sino a cualquier otro recurso que use la aplicación y que no forme parte de la propia aplicación: sonidos, fuentes tipográficas, vídeos, etc. * **Bibliotecas de terceros**. A menudo, recurrimos a bibliotecas de terceros para usarlas en nuestra aplicación. Incluir ese código en nuestro repositorio nos puede meter en un embrollo legal (mírate bien la licencia de uso de *todas* las bibliotecas que vayas a utilizar) y, además, nos puede hacer engordar innecesariamente el repositorio. Tendrás que valorar una a una si es conveniente incluir determinada librería o no. Las librerías no incluidas deberán ser instaladas manualmente cuando la aplicación se despliegue en un servidor, lo cual deberás explicar muy bien en la documentación. Por ejemplo, en el caso de Laravel, se aconseja no incluir la carpeta \"vendor\" en el repositorio remoto. Es decir, hay que añadir la carpeta \"vendor\" a .gitignore antes de la primera sincronización. En \"vendor\" se encuentran todas las librerías de terceros que usa Laravel. Entonces, para desplegar esta aplicación en un servidor, ¿de dónde sacamos todas esas librerías? Fácil: cuando despleguemos el código en un servidor, solo tendremos que ejecutar \"composer update\" en el directorio raíz de la aplicacion, y el propio composer se encargará de instalar las librerías que sean necesarias en las versiones más adecuadas para ese servidor. # A1.3. Trabajo básico con Git Ya tenemos nuestros repositorios local y remoto inicializados y conectados, y el archivo .gitignore a punto. ¿Qué hacemos ahora? Muy fácil: ponernos a trabajar como si git no existiera. Y luego, cuando des por finalizada una parte de la aplicación (un método, una clase, una funcionalidad concreta: tú decides cada cuánto tiempo haces esto), pasarla a la ***Staging Area***. ## A1.3.1. Un momento... ¿Staging quéeee? La ***Staging Area*** es como la pista de despegue de Git. La idea es la siguiente: Git no quiere sincronizar tus archivos con el repositorio remoto de forma automática (como hacen las plataformas para el público general, como Google Drive o Dropbox), porque sabe que los programadores producimos mucha basura al cabo del día. Si cada vez que escribimos una basurilla, Git la sincronizara con el remoto, el resto de personas del proyecto estarían recibiendo nuestra basura de forma permanente. Y nosotros la de esas personas. Y esparcir basura no es una buena política. Así que Git quiere que seas muy consciente de cuándo deseas sincronizar algo, y de qué es lo que deseas sincronizar. Quiere que te tomes el trabajo (que tampoco es para tanto, la verdad) de emplear medio minuto de tu tiempo para decirle: \"eh, Git, he estado currándome estos dos archivos esta mañana y creo que *ahora* ya no son una basura\". Para eso sirve la *Staging Area*. Tienes que pasar los archivos que ya no son una basura a la *Staging Area*. Y tienes que hacerlo tú, generalmente cuando hayas terminado una funcionalidad y la hayas probado adecuadamente. Lo bastante como para que no te avergüence que otras personas del equipo reciban tu código. Para **añadir archivos a la *Staging Area*** se usa el comando **git add**, así: ``` $ git add archivo1 archivo2 archivo3 ... ``` Se pueden añadir carpetas completas: ``` $ git add carpeta1 carpeta2 ... ``` Y también se pueden usar símbolos comodín, como el asterisco. De modo que, si estás muy, pero que muy seguro/a de que todos los archivos que han andado tocando desde el último commit están en un estado aceptable, puedes hacer esto para que git se encargue de *añadir todos los archivos modificados recientemente a la Staging Area*: ``` $ git add * ``` Por fin, cuando tengas una o varias cosas preparadas en la *Staging Area*... Bueno, entonces llega el momento de hacer un **commit**. ## A1.3.2. Hacer commit Un **commit** (palabra que podríamos traducir por \"perpetrar\") consiste en empaquetar todos los cambios de la *Staging Area* para enviarlos a otro repositorio, normalmente el repositorio remoto. El decir, con el commit le decimos a Git: \"quiero que prepares todo el código que te he puesto en la *Staging Area* a para enviarlo a GitHub\" (o a dónde sea). Se puede hacer un commit por cada pequeña modificación que introducimos en la *Staging Area*, o se pueden preparar muchos archivos en la *Staging Area* y luego empaquetarlos en un único mega-commit. Eso lo decidís tú y tu equipo de desarrollo. Pero suele ser buena idea hacer commits de funcionalidades o tareas individuales. Es decir, si esta mañana he estado trabajando en dos funcionalidades, \"Añadir usuarios nuevos\" y \"Modificar la vista de edición de usuarios\", es mejor que haga dos commits separados para cada una de esas funcionalidades. Esto es así porque, a cada commit, le tengo que añadir ***obligatoriamente*** un texto descriptivo donde indique qué cambios estoy subiendo con ese commit. El comando para hacer un commit es: ``` $ git commit -m \"Mensaje\" ``` Ahora saco mi bola de cristal y te digo: no tardarás ni una semana en empezar a hacer commits cuyo texto descriptivo será algo como \"aslkdaslkjda\", \"aaa\", \"yoquésé\". Eso es una pésima idea. Antes o después, alguien del equipo meterá la pata, subirá un cambio indebido y todo el repositorio explotará. Entonces, intentaréis regresar a un estado en el que el código aún funcionaba, pero encontraréis que los últimos commits tienen explicaciones incomprensibles como \"aslkdaslkjda\", \"aaa\" y \"yoquésé\". Y sudaréis tinta para descubrir cuál fue el commit explosivo. Los commits deben llevar textos descriptivos breves pero informativos. Por ejemplo: \"Arreglo el fallo del id de usuario inexistente al actualizar foto de perfil\" o \"Elimino el botón de modificar de la vista de libros\". Pero, ¡ojo!, hacer commit **no sube los archivos al repositorio remoto**. Todavía no. Recuerda que Git quiere que estés muy seguro/a de que subes lo que realmente tienes que subir, así que aún te falta un último paso: hacer ***push***. ## A1.3.3. Subir el commit: hacer push El último paso para enviar nuestros cambios locales al repositorio remoto (típicamente, GitHub o GitLab) consiste en hacer ***push***. Es decir, literalmente, \"empujar\" los cambios al repositorio remoto. La operación *push* enviará todos los commits que aún no se hayan enviado al repositorio remoto. A partir de ese momento, estarán disponibles para el resto de miembros del equipo. Pero solo a partir de ese momento. Para hacer push, basta con escribir: ``` $ git push ``` Lo normal es que el repositorio remoto te pida tu nombre de usuario y contraseña, pero eso dependerá de si el acceso a ese repositorio está autenticado o no. Por supuesto, tanto GitHub como GitLab te solicitarán que te identifiques. ## A1.3.4. Bajar la última versión del código: hacer pull Si podemos subir nuestros cambios al repositorio remoto, tendremos que tener una forma de bajar los cambios del resto de miembros del equipo, ¿verdad? Por supuesto, existe un comando para ello. Es este: ``` $ git pull ``` Es recomendable hacer pull antes de hacer push, por si alguien ha tocado alguno de los archivos que nosotros pretendemos subir. En ese caso, Git nos avisará del conflicto y nos ayudará a resolverlo (más adelante veremos cómo). No podremos hacer push hasta resolver ese conflicto, para evitar pérdidas de código. ## A1.3.5. Resumiéndolo todo: flujo de trabajo habitual con git Si resumimos lo dicho hasta ahora, tenemos que, después de inicializar el repositorio (cosa que hay que hacer solo una vez), el trabajo cotidiano con Git consiste en: 1. Desarrollar nuestra aplicación con normalidad, como si git no existiera. 2. Cuando terminamos de hacer algo, añadirlo a la *Staging Area* (git add). 3. Cada cierto tiempo, o cuando acabamos una funcionalidad, empaquetar todos los cambios que esperan en la *Staging Area* en un commit (git commit). 4. Bajarnos los commits del resto de miembros del equipo (git pull) 5. Subir nuestros commits al repositorio remoto (git push) Podemos verlo gráficamente en el siguiente esquema. Las tres primeras columnas (workspace, Staging Area y Local Repo) están en nuestro ordenador de trabajo. El repositorio remoto (Remote Repo) está en un servidor, como GitHub o GitLab. ``` Workspace Staging area (INDEX) Local repo (HEAD) Remote repo | | | git add → | | | git commit → | | | | ← ← ← ← ← | ← ← ← ← ← | ← git pull | | | | git push → | | | | | ``` Un último apunte: te voy a chivar un comando muy útil de git cuando no estás muy seguro de qué archivos has estado tocando últimamente (¿a quién no le ha pasado eso? ¿Eh?). Este comando te resumirá el estado de tu repositorio local, indicándote qué archivos han sido modificados (pero no están en la Staging Area), qué archivos están preparados en la Staging Area (pero no en un commit) y, por supuesto, qué commits están hechos pero aún sin subir. Todo eso, gratis y tecleando este humilde comando: ``` $ git status ``` ¿Es potente o no es potente este Git? Pues aún no has visto nada. # A1.4. Algunas cosillas avanzadas sobre git Solo con lo que hemos visto hasta ahora (add, commit, push y pull) ya tienes suficiente para empezar a funcionar con git. Luego, conforme te surjan otras necesidades, puedes ir curioseando por internet para profundizar en ciertos aspectos. Una de esas \"necesidades\" que te surgirán antes o después consiste en lo siguiente: Imagínate la escena: un día llegas a clase después de haberte acosatado a las tantas trabajando en tu proyecto. Antes de acostarte hiciste un push para subir todos tus cambios y puedes jurar que todo funcionaba perfectamente. Pero ahora, tú y el resto de miembros de tu equipo acabáis de hacer pull y... ¡BUM! El proyecto entero salta por los aires. El homepage no carga. Otras rutas que *estás seguro* de que funcionaban hace unas horas ahora no responden. ¿Qué narices ha pasado? Tranquilidad: ahí está Git para sacarte del embrollo. ## A1.4.1. Regreso al pasado: cómo revertir los cambios Las causas de un desastre como ese pueden ser tantas que, en la práctica, es como si fueran infinitas. Un problema con el proxy, un merge mal hecho, una desconfiguración de uno de los servidores locales que ha afectado a algún archivo clave, un error de algún miembro del equipo que ha sobreescrito cientos de archivos con versiones incorrectas... Causas infinitas, como te digo. No suele compensar el esfuerzo de buscar la razón última de lo que ha ocurrido, salvo que os pase esto con cierta regularidad: entonces sí que es cuestión de preocuparse. La mayoría de las veces es un problema puntual que puede resolverse de un modo muy simple: volviendo a la última versión estable. En primer lugar, si lo que quieres es revertir cambios de los que **aún no has hecho commit**, es tan fácil como: ``` $ git reset --hard ``` Pero, la mayor parte de las veces, el problema viene de cambios de los que no solo ya se ha hecho commit, sino que incluso se han subido al repositorio remoto. ¿Cómo descartamos esos cambios para volver a un estado anterior? En primer lugar, si aún no lo has hecho, ejecuta un **git pull** para traerte la última versión del código a tu repositorio local. Luego, utiliza el comando **git log**: ``` $ git log (muestra historial de cambios) $ git log --oneline (muestra historial de cambios simplificado) ``` Con esto obtendrás una lista, ordenada por cronología inversa (de más reciente a más antiguo), de todos los commits que has hecho en el repositorio. Observa que cada commit está identificado con un id único en hexadecimal. Cada id de commit está acompañado de su descripción. Si habéis sido cuidadosos con los commits y les habéis puesto descripciones representativas (y no \"asdfasdf\" o \"aaa\"), resutará fácil localizar en esa lista el commit causante del destrozo. A continuación, usa el comando **git revert** para regresar al commit *inmediatamente anterior* a aquel en el que se produjo el caos: ``` $ git revert HEAD [main id-de-commit] revert \"Mensaje del revert\" ``` Lo que hace este comando es devolver tu repositorio local (HEAD) al commit \"id-del-commit\". Pero, ojo, que no elimina todos los commits posteriores, sino que crea un nuevo commit (main) con el \"Mensaje del revert\" que le hayas indicado. En este nuevo commit habrá desaparecido todo el código conflictivo. El proyecto volverá a estar en un estado estable. Ahora bastará con hacer **git push** para subir el nuevo commit al repositorio remoto y que todos los miembros del equipo puedan replicarlo en sus máquinas. Es posible que, en el proceso, hayáis perdido algo de código valioso: todo depende de cuánto hayáis tenido que retroceder en el historial de commits hasta alcanzar un estado válido. Pero ese código en realidad no se ha perdido, porque los commits siguen ahí, en el historial de git. Existe una forma de poner el repositorio local en un commit concreto. Si lo haces y abres cualquier archivo fuente, lo encontrarás como estaba en ese commit, no como está en el último. ¿No es maravilloso? Así, podrás recuperar manualmente el código que pudiera haberse perdido al hacer el *git revert*. El comando que te permite saltar momentáneamente a cualquier commit es **git checkout**: ``` $ git checkout id-del-commit ``` Ahora puedes ver y rescatar el código fuente válido sin temor: nada de lo que hagas en este estado afectará al tu proyecto, porque los cambios se perderán cuando salgas de este \"viaje en el tiempo\" (salvo que crees una nueva rama del proyecto, pero esa es otra historia). Y, para regresar al presente, es decir, al último commit, basta con teclear: ``` $ git checkout main ``` ## A1.4.2. Cuando dos personas se encaprichan del mismo archivo Cuando ejecutas *git pull*, traes a tu repositorio local las versiones más recientes de todos los archivos del proyecto. Esto ya lo sabíamos. Si *git pull* se ejecuta sin contratiempos, aparecerá un mensaje informándote de ello. Pero los contratiempos existen, qué le vamos a hacer. La vida sería muy aburrida y predecible sin ellos. El contratiempo más habitual, con diferencia, al hacer *git pull* es el aviso de un conflicto el alguno de los archivos modificados en el repositorio remoto. Eso quiere decir que *tú* has estado tocando el código de un archivo *al mismo tiempo que otra persona de tu equipo*. Supongamos que, en un archivo A, tú has añadido las líneas A1, A2 y A3, mientras que otra persona ha añadido las líneas A4, A5 y A6. Si la otra persona ha subido el archivo A al repositorio remoto antes que tú, git se dará cuenta cuando intentes hacer *git pull* de que tu copia local del archivo y la que hay en el repositorio remoto no coinciden: no solo porque la tuya tiene las nuevas líneas A1, A2 y A3, sino porque a la tuya *le faltan* las líneas A4, A5 y A6. En ese caso, y para no perder ninguna de las nuevas líneas de código, git te mostrará un mensaje de advertencia y creará una versión nueva del archivo A en la que estarán **todas las líneas de código nuevas, tanto las tuyas como las de la otra persona**, rodeadas de unas marcas de texto como estas: ``` >>>>>> nueva-rama ``` Ahora, lo único que tienes que hacer es buscar manualmente esas líneas conflictivas y resolverlas a mano, es decir, quedarte con las líneas correctas y borrar las que no lo sean. Borra también todas las marcas que ha puesto ahi git para indicarte el conflicto. Si usas cualquier editor de texto medianamente potente, te mostrará esas líneas resaltadas e incluso te ayudará a encontrarlas. Una vez que hayas resuelto manualmente las líneas en conflicto, basta con guardar los cambios y hacer *git add* y *git commit -m \"Resolviendo el conflicto bla,bl,bla\"* para que el *git pull* y el *git push* vuelvan a funcionar a la perfección. ## A1.4.3. Proyectos que se complican: cómo crear ramas Imagina esta situación: tienes un proyecto ya en marcha, con una versión más o menos estable funcionando, y entonces surge la necesidad de desarrollar una nueva funcionalidad. Y esta nueva funcionalidad va a poner patas arriba una parte importante del código y va a dejar la aplicación hecha unos zorros durante un tiempo. Si trabajas con tu repositorio como hemos hecho hasta ahora, el resultado es que, durante ese tiempo, todo tu proyecto dejará de funcionar. No podrás hacer demos a los clientes (ni a tus profesores/as), no podrás probar la aplicación, no podrás cargarla con datos reales, etc. ¡Todo quedará paralizado hasta que la nueva funcionalidad esté en marcha! En un equipo de desarrollo grande, esta es una situación cotidiana que provocaría que gran parte de la gente se tuviera que quedar de brazos cruzados a la espera de la finalización de la nueva funcionalidad. Pero incluso en un equipo pequeño es un engorro llegar a este extremo. Para evitarlo, existen **las ramas** (*branches*) de Git. Una rama no es más que una copia del repositorio que puede evolucionar por su cuenta mientras la rama original permanece inalterada. Los desarrolladores/as que trabajen en esa rama pueden así trabajar en la nueva funcionalidad sin que el resto del equipo se vea afectado. Cuando la nueva funcionalidad se termine, lo único que hay que hacer es fusionar las dos ramas. Esto puede ser un trabajo ímprobo si se han estado modificando los mismos archivos en la rama principal y en la rama nueva, pero no se trata de un fallo de Git, que quede claro, sino de un fallo de organización del equipo. Y si la nueva funcionalidad nunca llega a terminarse (cosa que puede ocurrir por miles de razones), no pasa nada: la rama se elimina, o simplemente se abandona, y la rama principal sigue intacta. Crear una rama nueva es tan sencillo como usar este comando: ``` $ git branch nombre-nueva-rama ``` El comando *git branch* tiene muchas otras posibilidades. Aquí te pongo unas cuantas: ``` $ git branch --list (saca un listado de todas las ramas existentes) $ git branch -d nombre-rama (elimina una rama) $ git branch -D nombre-rama (elimina una rama a lo bestia, incluso si tiene cambios sin fusionar) $ git branch -m nuevo-nombre (cambia en nombre de la rama actual) ``` Ten en cuenta que, cuando creas una rama, *aún no estás trabajando en ella*. Si quieres cambiar a esa rama para empezar a trastear con ella sin tocar a la principal, debes hacer un *git checkout*: ``` $ git checkout nombre-rama ``` Por último, para fusionar una rama con otra (típicamente, con la rama principal o *main*), tienes que seguir estos pasos: 1. Asegúrate de estar situado en la rama que va a recibir la fusión. Si esa rama es *main*, tienes que hacer: ``` $ git checkout main ``` 2. Haz un *git pull* para tener disponible la última versión del código. 3. Realiza la fusión de las dos ramas con *git merge*: ``` $ git merge nombre-rama ``` En este punto, tendrás que resolver manualmente los conflictos que puedan surgir (si los hay), como hemos explicado más arriba. ## A1.4.4. ¿Aún quieres saber más? Git es un sistema de control de versiones increíblemente completo. Sus creadores parecen haber pensado en escenarios de lo más aberrante y han tenido en cuenta casi cada cosa que puede suceder en un proyecto complejo. Si no, no se explica la enorme cantidad de comandos y posibilidades que ofrece. Si necesitas saber más cosas sobre Git, internet está plagada de contenidos de calidad (y otros bastante penosos) sobre este sistema. Como siempre te recomiendo, acude en primer lugar a la referencia oficial: https://git-scm.com/docs Personalmente, a mí me gustan mucho los tutoriales de Atlassian. Aunque están orientados a BitBucket (un servicio competidor de GitHub o GitLab), casi todas sus recomendaciones son aplicables a cualquier servidor Git. Los puedes encontrar aquí: https://www.atlassian.com/es/git/tutorials ",
    "url": "/docs/dwes/_site/scv-git/",
    "relUrl": "/scv-git/"
  },"68": {
    "doc": "About",
    "title": "About",
    "content": "Estos apuntes han sido elaborados por [Alfredo Moreno Vozmediano](https://ensegundapersona.es) y se publican aquí con licencia [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/), lo que quiere decir que eres libre de usar este material, copiarlo, distribuirlo y modificarlo siempre que el resultado de todo eso mantenga la misma licencia y cites la autoría original. Algunos fragmentos (pocos) están tomados y adaptados de otras fuentes. Cuando eso ocurre, lo indico claramente en el texto. Debes atenerte a la licencia de los sitios web de origen para esos fragmentos. ",
    "url": "/docs/dwes/_site/about/",
    "relUrl": "/about/"
  },"69": {
    "doc": "1.1 Algunas cosas que debes saber sobre los CMS",
    "title": "1.1 Algunas cosas que debes saber sobre los CMS",
    "content": "## 1.1. Algunas cosas que debes saber sobre los CMS {: .no_toc } - TOC {:toc} ### 1.1.1. Inconvenientes de desarrollar una web desde cero Desarrollar sitios web programándolos desde cero (o más o menos desde cero, porque la mayor parte de las veces se parte de librerías existentes) tiene varias **ventajas** como: * Nos permite sacar el máximo partido tanto del servidor como de los clientes. * Nos da un control absoluto sobre el sitio web que estamos desarrollando. * Nos posibilita ajustarnos al máximo a los requerimientos y crear aplicaciones a medida. Pero también tiene **inconvenientes**: * La creación de un sitio desde cero es un proceso muy largo. * Las ampliaciones y actualizaciones del sitio también resultan lentas y costosas. * Ambas tareas (creación y actualización) requieren personal altamente cualificado, con conocimientos de todas las tecnologías implicadas. Es decir, desarrolladores web. Y eso cuesta dinero. Cuando los inconvenientes superan a las ventajas, el equipo de desarrollo puede optará por **no desarrollar desde cero**. Esto ocurre en la inmensa mayoría de los proyectos. No es necesario inventar la rueda cada vez que tengamos que construir un coche, ¿verdad? Pues para construir una aplicación web pasa lo mismo. Ahora bien, ¿de qué base partimos? Podemos construir una biblioteca de clases que resuelvan las tareas más habituales de cualquier aplicación web, cosas como la autenticación de usuarios, la seguridad, el acceso a bases de datos, etc. Cosas que se repiten una y otra vez con muy pocas variaciones. Esa biblioteca de clases puede ser más grande o más pequeña, más elaborada o más simple, más configurable o más rígida. Pero, sea como sea, nos ahorrará tiempo y esfuerzo en el desarrollo de nuevos proyectos. A esas bibliotecas se las denomina ***frameworks*** y es rara la aplicación web que no se programa usando alguna de las muchas que hay por ahí pululando, bien se usa un framework propio creado por el propio equipo de desarrollo. Pero se puede ir un paso más allá y utilizar una biblioteca más grande, una que ya te lo dé casi todo hecho y a la que solo tengas que indicarle qué tipografía, qué colores y qué contenidos quieres mostrar en tu web, y ella solita se las apañe para generarte la web de forma casi automática. Esta solución casi mágica son los **sistemas gestores de contenido (CMS)** de los que estamos hablando. Sin programar una sola línea de código, puedes tener lista en unos minutos una web plenamente funcional y de aspecto profesional. Por suerte para nosotros, los desarrolladores/as web, la CMS no pueden hacerlo todo. Son soluciones extraordinariamente eficaces para montar sitios web convencionales, pero cuando quieres crear algo que se salga de los límites muy marcados del CMS, necesitas a un programador/a. Y entonces, ¿a quién vas a llamar? ### 1.1.2. Cómo funciona un CMS **Un CMS (Content Management System)** es una aplicación web que se ejecuta en un servidor y se controla desde un navegador (cliente), y que nos permite: * Crear a través del navegador un sitio web completamente nuevo en muy poco tiempo. * Administrar fácilmente todo lo relacionado con el sitio web: usuarios, privilegios, contenido, apariencia, menús, etc. * Y todo ello sin tener conocimientos de HTML, CSS, PHP ni el resto de tecnologías (ojo: no es necesario, pero sí conveniente) El CMS guarda el **contenido** del sitio web en una **base de datos**. Cuando se solicita una página, un programa escrito en PHP (o en otro lenguaje de servidor) busca el contenido de esa página en la BD y la genera dinámicamente, entregándola al navegador web (cliente). Además, otro conjunto de programas permiten agregar nuevo contenido, modificar el contenido existente, crear usuarios, gestionar privilegios, etc. Todo ello altera los datos existentes en la BD, que a su vez alteran la forma en la que el usuario percibe la página cuando la visita. Al sitio web en sí se le denomina a veces ***front-end***. El front-end, en este sentido, es lo que ve el visitante de la web. A las páginas de adminsitración del sitio se les llama a veces ***back-end*** o ***dashboard*** (panel de administración). El back-end sólo es accesible a algunos usuarios (administradores, editores, etc). El CMS siempre necesita, por ello, un control de acceso de usuarios o login. ¡Cuidado! Los términos front-end y back-end son confusos. En términos de programación, a menudo se denomina ***front-end*** a la parte de la aplicación que se ejecuta en el navegador web y ***back-end*** a la parte de la aplicación que se ejecuta en el servidor e interactúa con los recursos del mismo (como la base de datos). En este otro sentido, el front-end está escrito en HTML, CSS, JavaScript (y cualquiera de las múltiples librerías que existen para Javascript, como jQuery, React o Vue.js) y el back-end está escrito en PHP, Java, Python u otros lenguajes del lado del servidor. Si encuentras por ahí una oferta de trabajo para un \"desarrollador/a back-end\" o \"desarrollador/a front-end\", se refiere a esta última acepción de ambos términos. Es decir, están pidiendo un \"desarrollador/a HTML + CSS + Javascript (y librerías de Javascrit)\" o un \"desarrollador/a en PHP o similar\". ### 1.1.3. Tipos de CMS Hay un montón (¡pero un montón!) de CMS, y cada uno tiene sus propias características, puntos fuertes y puntos débiles. Como hay tantos, resulta útil clasificarlos. Algunos autores los clasifican según su **método de distribución**: * Código abierto y software libre. * Código propietario. Pero, personalmente, creo que tiene más sentido clasificarlos por su **funcionalidad**. Así, nos encontramos con CMS de estos tipos (entre otros): * CMS genéricos (para cualquier tipo de sitio web) * CMS para blogs. * CMS para foros. * CMS para wikis. * CMS para e-learning (aprendizaje en línea) * CMS para e-commerce (comercio electrónico) * CMS para publicaciones digitales (periódicos, revistas...) Algo tremendamente odioso de los CMS es que **son fuertemente incompatibles** entre sí. Cada uno utiliza un interfaz distinto, bases de datos completamente diferentes para almacenar la información, módulos incompatibles, etc. Existen algunas iniciativas para lograr que los servicios desarrollados en un CMS puedan utilizarse en otros, pero todavía están en un estadio muy inicial. Lo que sí existen son familias de CMS relacionados entre sí que pueden compartir algunas características, generalmente porque unos CMS han derivado de otros. ### 1.1.4. Algunos ejemplos de CMS importantes Los CMS propietarios no han podido competir con los CMS libres. Por ello, han evolucionado hacia soluciones cloud computing completas, como Microsoft Azure, Google Cloud o Amazon Web Services (AWS). Entre los verdaderos CMS abundan las soluciones opensource o software libre. Por ejemplo: * **Blogs**: WordPress, Jekyll, GetSimple, Umbraco... * **Wikis**: MediaWiki, XWiki, DokuWiki... * **Foros**: phpBB, MyBB, bbPress, Discourse... * **e-learning**: Moodle, WebCT, Mahara, etc. * **e-commerce**: PrestaShop, Magento, OsCommerce, OpenCart... Muchos de estos CMS desaparecerán, se fundirán con otros o se dividirán en varios proyectos desde que yo escriba estas líneas hasta que tú las leas. Lo mejor es que eches un vistazo a alguna lista actualizada de CMS, como [esta de Wikipedia](https://en.wikipedia.org/wiki/List_of_content_management_systems). ### 1.1.5. Instalación de un CMS IMPORTANTE: la instalación puede diferir de un CMS a otro, pero, más o menos, todos necesitan los mismos pasos. Hay que leer cuidadosamente las instrucciones de instalación, que encontrarás en la web del desarrollador. Los pasos que suelen ser habituales en casi todos los CMS son: 1. Descargar la última versión del programa de la web del desarrollador. 2. Asegurarse de que el servidor cumple los prerrequisitos para ejectuar el CMS (versión de Apache, PHP, MySQL u otro software necesario) 3. Subir el CMS por al servidor (por ftp, vía web o como tu proveedor de hosting te lo permita). 4. Crear la base de datos. 5. Lanzar la instalación del CMS. Esto suele hacerse cargando una dirección concreta en tu navegador. 6. Adapar el archivo de configuración (suele llamarse config.php, config.inc, o algo similar). En los CMS más elaborados este paso no es necesario, pues el programa de instalación se encarga de generar un archivo de configuración válido. 7. A veces, hay que modificar los permisos de algún directorio y/o archivo. 8. Instalar el paquete de idioma español (si está disponible) ### 1.1.6. Explotación de un CMS IMPORTANTE: la explotación puede diferir notablemente de un CMS a otro, pero, en general, todo tienen una serie de elementos en común. Hay que leer cuidadosamente las instrucciones de uso, que encontrarás en la web del desarrollador. Pasos que suelen ser habituales en casi todos los CMS, una vez realizada la instalación: 1. Asignar una password de alta seguridad al usuario administrador que se crea por defecto. 2. Crear otros usuarios y asignarles privilegios. 3. Editar la página de inicio del sitio web. 4. Cambiar la plantilla (apariencia) del sitio. 5. Instalar módulos de ampliación (si es necesario). 6. Crear el contenido y/o revisar el contenido creado por otros usuarios. En las siguientes secciones nos centraremos en la instalación y explotación de algunos de los CMS más populares del mercado. ",
    "url": "/docs/dwes/_site/cms/algunas-cosas-que-debes-saber.html",
    "relUrl": "/cms/algunas-cosas-que-debes-saber.html"
  },"70": {
    "doc": "Desarrollo Web en Entorno Servidor",
    "title": "Desarrollo Web en Entorno Servidor",
    "content": "Esta es la documentación (apuntes) del módulo de ***Desarrollo Web en Entorno Servidor*** del Ciclo Formativo de Grado Superior de Desarrollo de Aplicaciones Web impartido en el IES Celia Viñas de Almería (España). 1. TOC {:toc} ",
    "url": "/docs/dwes/_site/",
    "relUrl": "/"
  },"71": {
    "doc": "1.3 Moodle",
    "title": "1.3 Moodle",
    "content": "## 1.3. Moodle {: .no_toc } - TOC {:toc} (La información de esta sección está adaptada de [docs.moodle.org](https://docs.moodle.org), donde toda la documentación se encuentra publicada bajo una licencia [GNU General Public License](https://docs.moodle.org/dev/License)) ### 1.3.1. Características de Moodle Moodle es un sistema de gestión de contenidos orientado a **crear comunidades de aprendizaje** en línea. Este tipo de plataformas tecnológicas también se conoce como **LMS (Learning Management System)**. Su licencia es GPL (es decir: es software libre). Moodle es un auténtico monstruo en cuanto a tamaño, funciones y posibilidades. Eso, por supuesto, tiene un coste: Moodle también es un devorador de recursos y resulta relativamente complejo de usar, tanto para el usuario final como para el administrador. Algunas soluciones propietarias, como *Google Suite for Education*, son más intuitivas y atractivas visualmente, pero están a años luz de Moodle en cuanto a funcionalidad. Moodle está programado en lenguaje PHP y puede usar diferentes gestores de bases de datos para almacenar el contenido. MySQL o PostgreSQL son los más habituales, pero también es posible utilizar Oracle o SQL Server. Las características más destacables de Moodle son: * Su arquitectura y herramientas son apropiadas para la educación a distancia, y también para complementar el aprendizaje presencial. * Tiene una interfaz de usuario sencilla y compatible con todos los navegadores y las recomendaciones W3C. Eso sí, es más complejo que otras soluciones como Google Suite for Education, aunque Moodle también es muchísimo más potente. * La instalación es sencilla (¡casi siempre!), requiriendo tan solo un servidor que soporte bases de datos y PHP con algunas extensiones bastante comunes. * Da mucha importancia a la seguridad: todos los formularios son revisados, las cookies cifradas, el alta de usuarios revisada, etc. * Es fuertemente configurable, permitiendo la instalación de módulos adicionales (plugins) para incrementar sus posibilidades. * También pueden instalarse plantillas para cambiar su apariencia. * Es un sistema enorme que consume *muchos* recursos en el servidor. ### 1.3.2. Algunos módulos de Moodle Los recursos en Moodle se organizan mediante **cursos**. Un curso es gestionado por uno o varios profesores/as, que puede editar el contenido, y contiene un puñado de alumnos/as (organizados en grupos o no) que pueden acceder a los recursos pero no editarlos. ![Moodle - Lista de cursos disponibles](/docs/dwes/_site/assets/images/01-moodle-lista-de-cursos.png) ###### Ejemplo de lista de cursos disponibles en una instalación de Moodle (extraido de docs.moodle.org) En Moodle, esos recursos se clasifican en categorías llamadas **módulos**. Cada módulo tiene sus propias características y está orientado a un tipo de actividad distinta: cuestionarios en línea, lecciones, tareas para que los alumnos suban, encuestas y otro montón más. Un usuario administrador puede instalar o desinstalar módulos para ajustar su versión de Moodle a las necesidades de su organización. Por eso, aunque todos los Moodle se parecen, cada uno tiene sus propias características. Los profesores/as pueden, dentro de sus cursos, utilizar todos los módulos que estén disponibles en el sistema para crear los recursos que su alumnado verá al acceder al curso en cuestión. ![Moodle - Lista de módulos](/docs/dwes/_site/assets/images/01-moodle-lista-de-modulos.png) ###### Lista de recursos disponibles en Moodle (puede variar dependiendo de los plugins instalados) A la hora de crear un recurso, Moodle proporciona al profesor/a una enorme (y cuando digo enorme quiero decir *enooorme*) cantidad de posibilidades de configuración. Cada tipo de recurso tiene diferentes configuraciones, claro, pero algunas de las más típicas son: * Descripción detallada del recurso. * Fechas en las cuales ese recurso va a estar disponible para el alumnado. * Restricciones de acceso. * Calificación (numérica, cualitativa, por rúbrica, sin calificación...) * Retroalimentación al finalizar la actividad. ![Moodle - Ejemplo de configuración de un recurso](/docs/dwes/_site/assets/images/01-moodle-configuracion-recurso.png) ###### Ejemplo de configuración de un recurso (una tarea, en este caso) A continuación vamos a describir los módulos más populares. #### Módulo de archivos Los archivos son uno de los recursos más simples de los que dispone Moodle. Se trata, simplemente, de documentos que sube el profesor/a y que estarán accesibles al alumnado. Los documentos pueden ser de cualquier tipo. #### Módulo de Tareas Este módulo sirve para que el alumnado envíe tareas al profesor/a. Estas tareas pueden constar de un texto en línea o uno o varios archivos subidos a la plataforma. * Puede especificarse la fecha final de entrega de una tarea y la calificación máxima que se le podrá asignar. * Los estudiantes pueden subir sus tareas (en cualquier formato de archivo) al servidor. Se registra la fecha en que se han subido. * Se permite enviar tareas fuera de tiempo, pero el profesor puede ver claramente el tiempo de retraso. * Para cada tarea en particular, puede evaluarse a cada estudiante (calificaciones y comentarios) en una única página con un único formulario. Incluso se puede corregir el documento escribiendo encima, como haríamos con una tarea hecha en papel. * Las observaciones del profesor se adjuntan a la página de la tarea de cada estudiante y se le envía un mensaje de notificación. * El profesor/a tiene la posibilidad de permitir el reenvío de una tarea tras su calificación (para volver a calificarla). ![Moodle - Ejemplo de tarea](/docs/dwes/_site/assets/images/01-moodle-tarea.png) ###### Ejemplo de tarea de subida de texto en línea. Así es como la ve un estudiante una vez creada. #### Módulo de consultas Las consultas son votaciones. Pueden usarse para votar sobre algo o para recibir una respuesta de cada estudiante (por ejemplo, para pedir su consentimiento para algo). * El profesor/a puede ver una tabla que presenta de forma intuitiva la información sobre quién ha elegido qué. * Se puede permitir que los estudiantes vean un gráfico actualizado de los resultados. #### Módulo de foro Hay diferentes tipos de foros disponibles: exclusivos para los profesores, de noticias del curso y abiertos a todos. * Las discusiones pueden verse anidadas u ordenadas cronológicamente. * El profesor/a puede obligar a la suscripción del alumnado a un foro o permitir que cada persona elija a qué foros suscribirse. * Se pueden habilitar o inahibilitar las respuestas en un foro o en un determinado tema. * El profesor/a puede mover los temas de discusión entre distintos foros. * La participación en el foro del alumnado se puede calificar. #### Módulo de Cuestionarios Los cuestionarios son los típicos exámenes tipo test. Pueden utilizarse como exámenes, como ejercicios de autoevaluación, como pruebas de evaluación inicial, etc. * Los profesores/as pueden definir una base de datos de preguntas que podrán ser usadas en diferentes cuestionarios. Esto requiere una gran inversión de tiempo al principio, pero luego pueden reutilizarse las preguntas toda la vida. Y existen bancos de preguntas disponibles en internet. * Las preguntas pueden ser almacenadas en categorías de fácil acceso, y estas categorías pueden hacerse accesibles desde cualquier curso de Moodle. * Los cuestionarios se califican automáticamente. Pueden ser recalificados si se modifican las preguntas. * Los cuestionarios pueden tener un límite de tiempo a partir del cual no estarán disponibles. * El profesor/a puede determinar si los cuestionarios pueden ser resueltos varias veces y si se mostrarán o no las respuestas correctas y los comentarios * Las preguntas y las respuestas de los cuestionarios pueden ser mezcladas (aleatoriamente) para impedir que el alumnado recurra al viejo truco de copiarse unos a otros. * Las preguntas pueden incorporar imágenes y otros recursos multimedia. * Hay preguntas de muchísimos tipos: verdadero/falso, respuesta múltiple, texto abierto, emparejamiento, etc. Incluso hay respuestas calculadas, perfectas para plantear un problema matemático o científico cuyos datos de entrada sean variables. #### Módulo de encuestas Las encuestas permiten al profesor/a conocer más datos sobre el progreso del alumnado o sobre la efectividad de un curso o un conjunto de recursos. Es importante aclarar que el **módulo de cuestionarios** y el **módulo de encuestas** se parecen pero no son iguales. El primero es un módulo adicional opcional de Moodle (si bien es muy popular). El segundo es un módulo estándar predefinido bastante menos potente. * Existen encuestas ya preparadas que sirven como instrumentos para el análisis de proceso de enseñanza en línea. * Se pueden generar informes de las encuestas, descargables como texto (CSV) o como hoja de cálculo para su posterior análisis. * A cada estudiante se le informa sobre sus resultados comparados con la media de la clase. #### Módulo de Wikis Un wiki es un espacio colaborativo de construcción de contenido. En los wikis (como en *Wikipedia*) es la comunidad la que redacta y revisa el contenido. Las diferentes entradas del wiki pueden enlazarse entre sí (enlaces internos) o con otras páginas (enlaces externos). También se puede insertar contenido multimedia. * Cualquier usuario puede editar cualquier artículo (bueno, en Wikipedia hay ciertos artículos protegidos, pero en los wikis de Moodle, no). * El wiki permite que el alumnado trabaje sobre los mismos documentos de forma grupal. * Se guarda un historia completo de todas las modificaciones de cada entrada del wiki, de modo que pueda revertirse un cambio si se ha producido un error o una *vandalización*. * Se guarda un registro de qué usuarios han hecho cada cambio. * El profesor/a puede calificar la participación de cada alumno/a en el wiki. #### Módulo de lección Las lecciones de Moodle son colecciones de páginas web enlazadas entre sí, de modo que *cuentan una historia*. Al final de cada página, el profesor/a puede introducir una pregunta para comprobar en qué grado el alumno/a ha asimilado el contenido. En función de la respuesta, la lección puede dirigir al alumno/a a una página o a otra diferente, de modo que cada persona puede seguir su propio camino a lo largo de la lección. Es como uno de esos libros de \"Elige tu propia aventura\", pero con un solo final (la asimilación de la lección) al que cada persona puede llegar por un camino diferente, a veces corto y directo, a veces largo y tortuoso. #### Otros módulos Moodle tiene muchos (pero muchos) otros módulos, algunos predefinidos y otros instalables mediante plugins. También se pueden desarrollar plugins nuevos para Moodle, desde luego, aunque en este curso no entraremos en ello. Mencionamos a continuación muy brevemente algunos otros módulos que es habitual encontrar: * **Enlace externo**: para crear links a recursos fuera de Moodle. * **Página**: para crear páginas web dentro de Moodle con un sencillo editor WYSIWYG. * **Chat**: para programar sesiones de chat de texto entre los miembros de un curso. * **Glosario**: para crear listas de definiciones, de forma similar a un diccionario, o, en general, para organizar información. * **Base de datos**: para crear de forma colaborativa un repositorio de información sobre cualquier temática. La estructura de cada registro de información la define el profesor/a. * **Taller**: para crear tareas con revisión entre pares. Los criterios de revisión los establece el profesor/a. * **Libro**: para crear material de estudio o de consulta en formato libro, con capítulos y subcapítulos. ### 1.3.3. Los roles de usuario en Moodle Como en todo sistema complejo, en Moodle existen varios roles de usuario predefinidos, cuyo papel dentro del sistema es ligeramente distinto. Estos roles son: * **Invitado**. No necesitan autenticarse. Solo pueden acceder a la página principal y a algunos cursos marcados como \"con acceso a invitados\". No pueden subir tareas, ni participar en los foros, ni contribuir al contenido de ninguna otra manera. * **Estudiante**. Son usuarios registrados que necesitan autenticarse. Tienen acceso a determinados cursos. Para acceder a ellos tienen que estar matriculados en los mismos, algo que puede hacer el profesor/a o pueden hacer por su cuenta conociendo una clave de matriculación. Una vez que acceden a un curso, tienen acceso a todos los recursos que el profesor/a haya hecho visibles y pueden subir tareas y participar en foros, chats, wikis, etc. El profesor/a puede calificar todas sus contribuciones. * **Profesor/a sin permisos de edición**. Puede acceder a sus cursos, evaluar las tareas del alumnado y interactuar con ellos en chats, foros y demás, pero no puede añadir, borrar ni modificar los recursos del curso. * **Profesor/a con permisos de edición**. Puede hacer todo lo del anterior y, además, añadir, borrar y modificar recursos en un curso. Un mismo usuario puede ser profesor/a en un curso (y, por tanto, administrarlo) y estudiante en otro, o no tener ni siquiera privilegios de acceso a los otros cursos. El profesor/a tiene acceso a un completísimo sistema de cálculo de calificaciones de sus estudiantes. * **Administrador/a**. Este usuario puede acceder con privilegios plenos a todos los cursos y también a la administración de Moodle, lo que incluye un montón de cosas: administración de usuarios, de cursos, de categorías, de plugins, de plantillas, de las copias de seguridad, de la configuración del servidor y un largo etcétera. Además, el administrador cuenta, entre sus privilegios, con la posibilidad de renombrar estos roles y también de definir roles nuevos, asignando los permisos que considere conveniente a cada rol. ### 1.3.4. Instalación y explotación de Moodle Moodle es un CMS mucho más complejo que Wordpress. Por eso, su instalación y explotación, aunque no difieren mucho en esencia de la de Wordpress, puede plantearte más problemas. En esta sección vamos a ver a grandes rasgos en qué consisten las dos cosas. #### Instalación de Moodle La instalación de Moodle es, como decimos, parecida a la de Wordpress: 1. En primer lugar, debemos **descargar el código fuente** de Moodle del sitio oficial (moodle.org) y **subirlo a nuestro servidor** mediante FTP, SSH o el sistema de administración de archivos que nos facilite nuestro proveedor de hosting. El código fuente debe subirse a una carpeta accesible vía web (es decir, debe estar dentro de *htdocs*, *httpdocs* o *public_html*). 2. Creamos un directorio llamado ***moodledata*** vacío. Este directorio contendrá todos los recursos de los cursos. Lo ideal es que, por seguridad, el directorio *moodledata* ***NO*** sea accesible vía web (es decir, ***NO*** debe estar dentro de *htdocs*, *httpdocs* o *public_html*), pero, a veces, dependiendo de la configuración del servidor, esto no será posible. 3. Creamos una **base de datos** vacía. 4. **Lanzamos la instalación**. Para ello, solo tenemos que escribir la URI de la carpeta donde hemos copiado el código fuente. Algo como: https://mi-servidor/mi-carpeta-moodle 5. El programa de instalación se empezará a ejecutar y nos **preguntará los datos típicos**: nombre del sitio, nombre del host de bases de datos, usuario y contraseña para la base de datos, usuario y contraseña para el administrador de Moodle... Ah, y también te preguntará por la ubicación de la carpeta *moodledata*. 6. En cierto momento de la instalación, Moodle hará una **comprobación de las extensiones de PHP** instaladas en el servidor. Nos mostrará en color verde las extensiones detectadas, en amarillo o naranja las que no están instaladas pero no son imprescindibles, y en color rojo las que no están instaladas y que sí son imprescindibles. *Es necesario instalar esas extensiones para poder usar Moodle*. En ese caso, deberás contactar con tu proveedor de *hosting* para solicitarle la instalación de esas extensiones (o, en general, para solicitarle un entorno apto para la ejecución de Moodle). 7. Si todo va bien, Moodle comenzará a crear la estructura de la base de datos (lo cual puede demorarse unos minutos, porque la base de datos tiene más de doscientas tablas) y, al terminar, tendrás funcionando una instalación de Moodle limpia y lista para usar. ![Moodle - Comprobación de extensiones durante la instalación](/docs/dwes/_site/assets/images/01-moodle-chequeo-instalacion.png) ###### Listado de comprobación de extensiones durante la instalación de Moodle #### Labores de administración Ya hemos dicho varias veces que Moodle es un sistema realmente grande y complejo, ¿verdad? Así que seguro que no te sorprenderá oír que la administración de Moodle también es compleja. El mejor consejo que te puedo dar en este punto es: olvídate de tutoriales y manuales y, en su lugar, instálate un Moodle de prueba en tu servidor local y dedícate a trastear con él como si fuera un Moodle real. Crea usuarios y cursos, cambia la plantilla, juguetea con los enrolamientos, curiosea el administrador de archivos y las opciones de configuración del servidor... Esta es la mejor manera de familiarizarse con la administración de Moodle. Luego, en el mundo real, cuando surja un problema real, sabrás (más o menos) a dónde dirigirte, o al menos no estarás por completo perdido/a. Y, por supuesto, cuando necesites consultar algo, acude siempre en primer lugar a la documentación oficial: https://docs.moodle.org En esta sección solo vamos a referirnos a las labores críticas de administración, esas que hay que hacer sí o sí para poner en marcha en Moodle recién instalado. 1. **Configurar el *homepage***. Una vez autenticado con un usuario administrador de Moodle, busca siempre el menú \"Site administration\" para acceder a las opciones de administración. Esas opciones están agrupadas por categorías: Usuarios, Cursos, Servidor, etc. Una de las primeras cosas que tendrás que hacer allí es buscar la sección \"Front page\" y, una vez allí, la opción \"Front page settings\". Al acceder a esta opción, podrás establecer el nombre de tu sitio y las cosas que quieres que aparezcan en el home. Al terminar, no olvides pulsar el botón para guardar los cambios que estará al final de la página. 2. **Cambiar la plantilla o *theme***. Las últimas versiones de Moodle vienen con dos plantillas preinstaladas, llamadas *\"Boost\"* y *\"Classic\"*. Cualquiera de las dos son totalmente funcionales, pero también un poco aburridas. Si quieres que tu Moodle luzca de un modo distinto, necesitarás buscar otra plantilla en internet (las hay gratuitas y de pago) y luego acceder a \"Site administration\" -> \"Site appearance\" para instalarla y activarla. Por supuesto, existe toda una rama de negocio centrada en la creación de *themes* para Moodle (muchos basados en las plantillas \"Boost\" y \"Classic\"), así como en el desarrollo de *plugins*. Sin embargo, entrar en detalles sobre cómo se hace eso excede a los propósitos de este curso. 3. **Crear categorías y cursos**. Si tu Moodle va a contener muchos cursos (más de seis o siete), lo más apropiado es que los organices en categorías para no volver locos a los estudiantes. Sea como sea, los cursos y las categorías pueden crearse, modificarse y eliminarse en \"Site administration\" -> \"Courses\". Es buena idea que eches un vistazo a la opción \"Course default settings\" en primer lugar, porque todos los cursos que crees van a heredar esos *settings* por defecto. 4. **Administrar usuarios**. Por último, en la sección \"Site administration\" -> \"Users\" puedes admnistrar todo lo relativo a la creación de usuarios registrados: * Formas de autenticación de usuarios: podrás elegir entre permitir que los usuarios se auto-registren en tu plataforma usando su email, o bien impedir esta posibilidad y registrar manualmente a los usuarios (lo cual es más seguro pero también más trabajoso). * Formas de enrolamiento (matriculación) en los cursos: también tendrás que elegir si vas a permitir que los estudiantes se enrolen (o matriculen) en los cursos por sí mismos (en cuyo caso, los profesores/as tienen que establecer una clave de matriculación y comunicársela a sus estudiantes para evitar accesos no deseados) o si la matriculación de hará manualmente. 5. **Configurar el sitio**. Las opciones de configuración están repartidas por todo el menú de administración y puedes pasarte semanas curioseando por ellas sin acabar de recorrerlas todas. Pero hay unas cuantas a las que debes prestar atención en el momento de poner en marcha tu Moodle: * Idioma: lo puedes configurar en \"Site administration\" -> \"Language\" -> \"Language settings\". Puedes agregar paquetes de idiomas que no estén instalados en \"Site administration\" -> \"Language\" -> \"Language pack\". * País y huso horario: muy importante para que las fechas de las entregas funcionen correctamente. Se ajusta en \"Site administration\" -> \"Location\" -> \"Location settings\". * Seguridad de las contraseñas: puedes ajustarla en \"Site administration\" -> \"Security\" -> \"Site security settings\" -> \"Password policy\". * Plugins: en concreto, deberías revisar los módulos que quieres que estén disponibles para tus profesores/as, lo cual se hace en \"Site administration\" -> \"Plugins\" -> \"Activity modules\". Ahora ya tienes un Moodle más o menos preparado para dejarlo en manos de tus profesores/as, de modo que empiecen a cargar contenido en sus cursos y a trabajar con el alumnado. Si nunca has ejercicio como profesor/a en Moodle, te aconsejo que tú mismo/a te des de alta en un curso como profesor/a y trastees un buen rato creando y modificando contenido. Es la mejor forma de aprender a hacerlo. Y, siempre, recuerda que Moodle es un CMS tan enorme que nunca se terminan de conocer todos sus recovecos. #### Migración Lo que sigue es aplicable a la gran mayoría de los CMS, no solo a Moodle. Si lo incluimos aquí es porque, con Moodle, el proceso de migración resulta particularmente complicado. **Migrar** una aplicación web significa *moverla de un servidor a otro* sin que se pierda ni el contenido, ni la funcionalidad ni la apariencia. Es decir, la experiencia del usuario no debe verse afectada. No visitante no deberían ni enterarse de que ahora la web está corriendo en otro servidor (salvo que hayamos cambiado el nombre de dominio, claro). Para muchos CMS, existen plugins que automatizan o semiautomatizan el proceso de migración. Sin embargo, y según mi experiencia personal, aunque esos plugins pueden resultar útiles en Wordpress, con Moodle dejan mucho que desear y el proceso debe hacerse manualmente. La migración manual de una aplicación web consiste en: 1. Descargar una copia completa de todos los archivos de tu Moodle en su estado actual. Eso incluye también el directorio *moodledata* completo. 2. Descargar un volcado SQL de la base de datos. 3. Poner la aplicación en \"modo mantenimiento\", para que nadie la use mientras dure la migración. 4. Subir el código fuente al nuevo servidor. 5. Crear una base de datos vacía en el nuevo servidor. A ser posible, con el mismo nombre que tenía en el viejo servidor. 6. Ejecutar el volcado SQL en la base de datos vacía para reproducir el contenido de la base de datos del servidor antiguo en el nuevo. 7. Revisar el archivo de configuración del CMS por si hay que cambiar alguna variable. En el caso de Wordpress, recuerda que ese archivo es *wp-settings.php*. En el caso de Moodle, el archivo se llama ***config.php*** y está ubicado en la raíz de la instalación. 8. Si has cambiado de dominio, te queda un paso adicional (si el dominio es el mismo, no tienes que hacer nada en este punto). Se trata de acceder a la base de datos de Moodle y buscar manualmente en *todas* las tablas cualquier referencia al viejo servidor para cambiarlas. Vamos a explicar esto último mejor. Supón que estás moviendo tu Moodle de una URI como esta: https://servidor-antiguo/moodle a una URI como esta: https://servidor-nuevo/moodle. Además de todo lo que hemos explicado en los pasos del 1 al 7, vas a tener que bucear en las tablas de la base de datos para buscar el texto \"https://servidor-antiguo/moodle\" y sustituirlo por \"https://servidor-nuevo/moodle\". Dependiendo de los plugins que tengas instalados, puedes encontrar esa cadena unas pocas veces o cientos de veces. Si tienes experiencia con bases de datos, puedes programar un pequeño programa que se encargue de hacer la búsqueda y la sustitución de forma automática. También puedes recurrir a clientes como PHPMyAdmin y MySQL Workbench, que te permiten hacer búsquedas y sustituciones de forma masiva en las tablas. Si no tienes experiencia con bases de datos... Bueno, en ese caso tendrás que armarte de paciencia o hacer un cursillo acelerado. Una vez hecho todo esto, Moodle (o Wordpress, o el CMS que sea) debería estar funcionando en el nuevo servidor con normalidad. Otro consejo importante: recuerda que Moodle es más exigente que Wordpress en cuanto a la configuración del servidor. Para evitar problemas con la migración, lo más conveniente es que el nuevo servidor tenga una configuración lo más parecida posible al antiguo. Esto incluye la versión de PHP y de MySQL (o la base de datos que uses), así como las extensiones de PHP instaladas. Y un último consejo: cuando vayas a empezar la migración, consigue un buen cargamento de café y no te olvides de cruzar los dedos. #### Actualización Otro quebradero de cabeza con Moodle son las actualizaciones. Los CMS, como cualquier otro programa, conviene tenerlos siempre actualizados para evitar problemas de seguridad y de rendimiento. Wordpress es fácil de actualizar: el propio panel de administración te avisará cuando haya una nueva versión, y actualizarás el sistema con un par de clics. Aunque a veces pueden surgir contratiempos y es buena idea disponer de una copia de seguridad de la web antes de hacerlo, es una operación que no suele plantear problemas. Con Moodle, la situación es en teoría igual de fácil, pero en la práctica no. Recuerda que es un sistema muuucho más grande y complejo de Wordpress, así que las actualizaciones son proporcionalmente más grandes y complejas también. La actualización de Moodle, por lo tanto, es un proceso largo, complejo y delicado. Asegúrate de seguir a rajatabla y muy despacito estos pasos: 1. Haz una copia de seguridad de todos los archivos de tu Moodle (incluyendo *moodledata*) y de la base de datos. Descarga esa copia en un lugar seguro (no la dejes en tu servidor). Si algo sale mal, siempre puedes tratar de restaurar el Moodle que tenías. 2. Averigua qué versión de Moodle tienes. Esto lo puedes ver en \"Site administration\" -> \"Notifications\" 3. Averigua a qué versión de Moodle tienes que migrar. Si estás, digamos, en la versión 2.4, no puedes saltar a la 3.11 así, alegremente. Tienes que ir saltito a saltito, actualizando a las versiones críticas intermedias. Estas versiones críticas, en el momento de escribir esto (septiembre de 2021) son: 1.3 > 1.6 > 1.8 > 1.9 > 2.2 > 2.7 > 3.1 > 3.6 > 3.11 Es decir, si tu versión actual es la 2.4 y quieres llegar a la 3.11, primero tienes que actualizar a la versión crítica más cercana (la 2.7), y luego saltar a la siguiente (3.1), a la siguiente (3.6) y por fin llegar a tu versión de destino (3.11). 4. Descarga todas las versiones de Moodle por las que vas a tener que pasar hasta llegar a tu versión destino. Asegúrate de que tu servidor cumple los requisitos mínimos para poder instalarlas. 5. Pon tu Moodle en \"modo mantenimiento\". Esto se hace en \"Site administration\" -> \"Server\" > \"Maintenance mode\". 6. Si tu versión de Moodle actual es 3.0 o posterior, necesitarás establecer una \"password de actualización\" en tu archivo config.php. Simplemente, abre el archivo config.php y agrega esta línea: $CFG->upgradekey = 'tu-password'; La password debe tener al menos 8 caracteres y mezclar números, letras y caracteres especiales. 7. Entra en los archivos de tu servidor y renombra la carpeta donde tengas instalado el Moodle actual. Vamos a suponer, por ejemplo, que lo tienes instalado en una carpeta llamada \"aulavirtual\". Pues bien, renómbrala a algo como \"aulavirtual-antigua\". 8. Sube la versión a la que vas a actualizar al servidor a la carpeta donde tenías el viejo Moodle (en nuestro ejemplo, \"aulavirtual\"). Recuerda que debes actualizar de manera incremental. Es decir, si tu viejo Moodle estaba en la versión 2.4, el Moodle que debes subir en este paso es la versión 2.7. 9. Copia el config.php de la instalación antigua en la nueva. 10. Abre un navegador web y escribe la URI del nuevo Moodle seguida de \"/admin\". En nuestro ejemplo, esa URI sería: https://tu-servidor/aulavirtual/admin. Se iniciará la actualización de Moodle. Si incluiste una clave de actualización en config.php, en este punto de la pedirá. 11. La actualización hará algunas comprobaciones. Es posible que te salte algún error y no puedas continuar. Los errores más frecuentes se deben a extensiones de PHP que la nueva versión necesita y la vieja no, o bien a plugins o plantillas que no son compatibles con la nueva versión. Debes resolver estos problemas antes de continuar. Para las extensiones de PHP, configura bien tu servidor. Para los plugins y plantillas, vuelve a renombrar las carpetas de Moodle (\"aulavirtual\" pasará a \"aulavirtual-nueva\" y \"aulavirtual-antigua\" pasará a \"aulavirtual\") y accede a tu viejo Moodle. Desinstala los plugins o plantillas que te causan problemas y vuelve a dejar los nombres de las carpetas como estaban para poder lanzar de nuevo la actualización. 12. Cuando hayas superado todas las comprobaciones, simplemente pulsa el botón de \"Continuar con la actualización\" y cruza los dedos. 13. Sigue las indicaciones del actualizador. Con un poco de suerte, al terminar tendrás tu Moodle actualizado. 14. Repite los pasos del 7 al 13 hasta llegar a la versión de Moodle que te interesa alcanzar. Como ves, es un proceso largo y tedioso, donde pueden surgir mil complicaciones. No es raro encontrarse con que una actualización de Moodle resulta inviable. Por ejemplo, porque tu Moodle dependa fuertemente de un plugin incompatible con las nuevas versiones. O por cualquier otra razón. En esos casos, una alternativa es hacer una instalación limpia con la versión más actual y luego exportar e importar los cursos uno a uno. Por supuesto, esto solo es viable si tu organización tiene un número reducido de cursos. En situaciones extremas, la actualización de Moodle se vuelve imposible. Qué le vamos a hacer. Una última advertencia: si dispones de tiempo suficiente para ello, te sugiero hagas una copia local de tu Moodle actual y pruebes la actualización en primer lugar sobre esa copia. Si te vas a encontrar con alguna sorpresa desagradable al actualizar, mejor que te la encuentres en una copia local que en el servidor real. Y que la fuerza te acompañe porque la vas a necesitar. ",
    "url": "/docs/dwes/_site/cms/moodle.html",
    "relUrl": "/cms/moodle.html"
  },"72": {
    "doc": "1.4 Prestashop",
    "title": "1.4 Prestashop",
    "content": "## 1.4. Prestashop {: .no_toc } - TOC {:toc} (La información de esta sección está adaptada de [doc.prestashop.com](https://doc.prestashop.com), donde se publicó originalmente con licencia *free Atlassian Confluence Open Source Project*. En el momento de escribir estas líneas, la documentación ya no está en línea, pero aún puede encontrarse en [The Wayback Machine](https://archive.org)) ### 1.4.1. Características de Prestashop Prestashop es un CMS de código abierto para la creación de comercios online de cualquier tipo. Actualmente es el líder indiscutible en su sector, aunque tiene algunos competidores serios como *Magento*, *VooCommerce* (un plugin para Wordpress), *VirtueMart* (un plugin para Joomla!) o *Shopify*. Como sucede con otros CMS de código abierto, aunque el código fuente de Prestashop es libre y gratuito y dispone de muchos plugins y plantillas que también son gratuitas, hay muchas otras de pago. En el caso de Prestashop, esta vía de negocio es aún más acusada que con Wordpress o Moodle, de manera que es difícil (aunque no imposible) poner en marcha una tienda online basada en Prestashop sin recurrir a algunos complementos de pago. En esta sección, vamos a hacer un repaso muy rápido a las características principales de Prestashop. ### 1.4.2. Instalación de Prestashop #### Requisitos previos Para instalar PrestaShop necesitas, como pasa con cualquier CMS escrito en PHP, un servidor web con soporte para PHP y un servidor de bases de datos (MySQL, MariaDB, PostgreSQL o similar). La configuración del servidor es algo más exigente que con Wordpress. Como sucedía con Moodle, necesitarás que ciertas extensiones estén habilitadas en el servidor para que Prestashop funcione correctamente. Asegúrate de contratar un proveedor de hosting que sea compatible con Prestashop antes de ponerte en marcha, o contacta con tu proveedor actual para ver qué posibilidades de reconfiguración de tu servidor actual te ofrece. Además, necesitarás un mínimo de 128 MB de RAM exclusivos para PHP. Pero eso solo es el mínimo. Prestashop consume muchos recursos. Cuanta más RAM tenga PHP a su disposición, mejor. Prestashop recomienda encarecidamente la instalación sobre un sistema Unix o tipo Unix (es decir, Linux). Siempre funcionará mejor y de forma más segura que sobre un servidor de Microsoft. Durante la instalación, el propio instalador hará un chequeo del servidor y te informará de cualquier problema de configuración antes de continuar. Pero, si lo prefieres, puedes consultar previamente la [página oficial de requisitos del sistema](https://www.prestashop.com/es/requisitos-de-sistema). #### Proceso de instalación Muchos proveedores de hosting permiten instalar Prestashop (igual que Wordpress, Moodle y muchos otros CMS) desde el panel de administración del propio hosting, con un par de clics. Si ese es tu caso, enhorabuena. Si no, siempre puedes recurrir a una instalación manual. El proceso de instalación de Prestashop es semejante al de cualquier otro CMS. A grandes rasgos, se trata de seguir estos pasos: 1. Descarga la última versión de Prestashop del [sitio oficial](https://prestashop.com). 2. Sube el código fuente de Prestashop a tu servidor. Mejor si preparas previamente una carpeta para alojarlo. Ni que decir tiene que esa carpeta debería estar en una ubicación accesible vía web (es decir, dentro de *htdocs*, *httpdocs* o *public_html*). 3. Crea una base de datos vacía en tu servidor. 4. Lanza la instalación. Para eso, basta con que escribas la URI donde has alojado el código fuente de Prestashop. 5. Sigue las instrucciones del instalador. 6. Cuando la instalación haya terminado, elimina la carpeta /install. #### Algunos trucos y consejos Utiliza siempre una versión de prueba, mejor en localhost, pero también puedes hacerlo en cualquier servidor. Cuando la hayas dejado a tu gusto, puedes moverla a su ubicación definitiva. Mover un Prestashop de un servidor a otro es como mover cualquier otro CMS: te llevas todos los archivos, la base de datos y cambias los datos de configuración (en el archivo *app/config/parameters.php*). No elimines tu versión de prueba de Prestashop. Más adelante, puede servirte como entorno de preproducción para probar cambios en tu tienda online sin que afecte a la versión en producción. ### 1.4.3. Y después de instalar, ¿qué? Breve guía para el administrador novato Prestashop construye toda la infraestructura para montar una tienda online, pero no la tienda en sí. Es decir, alguien se tiene que encagar de subir los productos, las categorías, los precios, las ofertas especiales... Las posibilidades de Prestashop son inmensas y, al principio, los administradores pueden sentirse un poco perdidos al acceder al panel de administración. En esta sección hablaremos de las acciones más comunes en el trabajo inicial con Prestashop (cuando áun estás montando la tienda) y también en el día a día cuando la tienda ya está en uso. En esta sección, vamos a resumir los pasos más importantes que debe dar un administrador cuando pretende poner en marcha una tienda online con un Prestashop recién instalado. #### Acceder al panel de administración Lo primero que tienes que saber es cómo entrar al *panel de administración* o \"sala de máquinas\" de tu Prestashop. Simplemente, abre tu navegador web preferido y añade la ruta \"admin\" a la URI de tu Prestashop. Es decir, si instalaste Prestashop en https://mi-servidor/mi-prestashop, encontrarás el acceso al panel de administración en https://mi-servidor/mi-prestashop/admin #### Desactivar la tienda online: modo mantenimiento y modo catálogo Una tarea habitual tras finalizar una instalación limpia, o cuando vas a meter mano a lo bestia en tu tienda, es poner Prestashop en *\"modo mantenimiento\"*, de manera que cualquier posible visitante no se encuentre una tienda a medio construir (lo cual da muy mala imagen), sino el aviso de que la tienda está, en efecto, a medio construir. Acceder al panel de administración y ve a la sección *\"Shop Parameters / General\"*. Las opciones sobre el modo mantenimiento están en la segunda pestaña. Además de activar/desactivar tu tienda, puedes indicar una dirección IP a través de la cual tú podrás seguir visitando la tienda para ver cómo quedan los cambios. Cuando ya te hayas decidido por una plantilla y hayas subido unos cuantos productos, puedes preferir poner la tienda en *\"modo catálogo\"*. Esto es un punto intermedio entre el *\"modo mantenimiento\"* (la tienda es completamente inaccesible) y el modo de funcionamiento normal. En el *\"modo catálogo\"*, los visitantes podrán navegar por tu tienda y visitar los productos, pero no les aparecerán ni los precios ni los botones de compra. Puedes activar/desactivar el *\"modo catálogo\"* en la sección *\"Shop Parameters / Products Settings\"* del panel de administración. #### Borrar el contenido por defecto de la tienda La instalación por defecto de Prestashop incluye un conjunto de datos de ejemplo que seguramente querrás eliminar. Los datos de prueba dependen de tu instalación concreta y de la versión de Prestashop. Los datos de ejemplo que tendrás que eliminar incluyen productos, categorías, atributos, proveedores, imágenes, etiquetas, pedidos, clientes y páginas estáticas. Sin embargo, *tal vez te interese conservar por un tiempo estos datos de prueba para ver cómo luce la tienda cuando tiene datos cargados*, al menos hasta que acabes de echar un vistazo a todas las opciones de Prestashop. Para eliminar todo esto, puedes bucear por el panel de administración y borrar los elementos que no te sirven de uno en uno (o, tal vez, modificar algunos en lugar de borrarlos para adaptarlos a tus necesidades). Es un trabajo largo y tedioso. Por suerte, existe un ***plugin*** llamado *Database Cleaner* que te permitirá resetear la base de datos de forma muy rápida: * Accede a la sección *\"Modules > Modules & Services\"* del panel de administración. * Busca el módulo *\"Database Cleaner\"* y haz clic en el botón *\"Install\"*. Esto instalará el plugin. * Haz clic en el botón *\"Configure\"*. * Acepta el *warning* y haz clic en los botones *\"Delete Catalog\"* y *\"Delete Orders & Customers\"*. Esto limpiará de datos tu base de datos. ¡Cuidado! A menos que tengas copia, esos datos son irrecuperables. * Haz clic en el botón *\"Check & fix\"* para revisar la integridad de tus tablas. * Haz clic en el botón *\"Clean & optimize\"* para reorganizar los índices y dejar la base de datos en condiciones óptimas. #### Configuración básica de tu tienda online Ahora nos refererimeos a las cosas que tienes que configurar necesariamente a la hora de crear una tienda con Prestashop. Antes de nada, es importante que entiendas que una cosa es la configuración del núcleo de Prestashop y otra la configuración de cada *plugin*, que en Prestashop se denominan *módulos*. El núcleo de Prestashop se configura buceando en el panel de administración, en las secciones que veremos a continuación. En cambio, los *plugins* se configuran desde *\"Modules\" > \"Installed Modules\" > \"Configure\"*. Como es lógico, cada *plugin* tiene sus propias opciones de configuración y debes remitirte a la documentación del desarrollador para conocerlas. Aquí nos referiremos únicamente a la configuración básica del núcleo de Prestashop y de algunos módulos especialmente útiles. Una vez aclarado esto, entremos en faena. Cuando tengas una instalación limpia de Prestashop preparada, las cosas que debes configurar como mínimo son estas: * **El nombre de tu negocio**. Se hace en *\"Shop Parameters\" > \"Contact\" > \"Stores\" > \"Contact details\" > \"Shop name\". Esto es muy importante hacerlo para que los buscadores te indexen adecuadamente. * **El logo de la tienda**. El logo se verá en todas las página de la tienda online y en las facturas y emails que se emitan desde la tienda. Se accede a él en la ruta *\"Design\" > \"Theme & Logo\" > \"Your current theme\". * **La moneda por defecto**. Es la moneda en la que se mostrarán los precios de los productos. Se configura en *\"International\" > \"Localization\" > \"Configuration\"*. * **La información de contacto de la tienda**. Hay que establecer, al menos, el número de teléfono y una dirección de email. Se hace en *\"Shop Parameters\" > \"Contact\" > \"Stores\" > \"Contact details\"*. * **Slider de imágenes**. El *slider* es una secuencia de imágenes que aparecen una tras otra, normalmente en la parte superior del *home* (aunque esto depende de la plantilla). Es *slider* es importantísimo desde el punto de vista del atractivo visual de la tienda. Puedes definirlo en la sección dedicada al módulo *\"Image slider\"*. * **Páginas estáticas**. Las páginas estáticas, como en Wordpress, se usan para crear las típicas páginas de \"Acerca de\", \"Aviso legal\", \"Términos y condiciones\" y cosas así. Encontrarás que algunas ya existen en los datos por defecto, y puedes adaptarlas a tus necesidades. Otras tendrás que crearlas por tu cuenta. En ambos casos, puedes hacerlo desde *\"Design\" > \"Pages\"*. * **Redes sociales**. Las principales redes sociales de la empresa pueden gestionarse desde el módulo *\"Social media follow links\"*. * **Top menu**. El *top menu* es el menú principal de tu tienda. Suele mostrarse en la parte superior de todas las páginas, aunque esto, lógicamente, podría cambiar según la plantilla que uses. En el *top menu* puedes mostrar tus categorías de productos, así como links a otras páginas. Se gestiona desde el módulo *\"Main menu\"*. * **Contenido de la *homepage***. La plantilla por defecto incluye contenido variado para el *home*: textos, imágenes, links, etc. Si vas a usar el tema por defecto, puedes modificar este contenido (o eliminarlo antes de crear el tuyo). La *homepage* se manipula a través de diferentes módulos. Estos son los principales a los que deberías echar al menos un vistazo: * *Banner*: Para cambiar la imagen que aparece al final de la *homepage*. * *Custom text blocks*: Mensajes de texto que aparecen debajo del banner. * *Theme modules*: Configuración de la plantilla actual. * *Legal compliance*: Información legal, que puede variar según el mercado al que te dirijas. * **Idioma, métodos de pago y envíos**. Estos tres elementos son muy importantes y algo más complejos de configurar, por lo que los vamos a tratar en los siguientes apartados. * **Instalar plugins y plantilla**. También hablaremos de ello un poco más abajo. * **Dar de alta categorías y productos**. Cuando hayas pasado por todos los puntos anteriores, habrá llegado el momento de comenzar a dar crear categorías y productos en tu Prestashop. A partir de ahí, tu tienda online será plenamente funcional. A continuación, discutimos con un poco más de detalle algunos de los puntos anteriores. #### Cambiar el idioma Prestahop se instala por defecto en inglés. Si te has bajado el paquete de instalación en otro idioma, se instalará ese otro idioma y, además, el inglés, por lo que puedes estar seguro de que, sea cual sea la instalación de Prestashop con la que trabajes, la encontrarás, al menos, en inglés. Por eso es buena idea que te familiarices con el interfaz del panel de administración en inglés. Así, de paso, practicas el idioma. Cuando hay varios paquetes de idioma instalados, el front-end mostrará un selector en la parte superior para que el visitante elija en qué idioma desea ver la página. El back-end también se mostrará en los diferentes idiomas, aunque, en este caso, tendremos un selector de idioma para cada campo de texto. Si necesitas **instalar cualquier otro idioma**, puedes hacerlo desde el menú *\"International\" > \"Localization / Languages\"*. Puedes instalar todos los paquetes de idioma que quieras, pero ten en cuenta que *las descripciones de los productos tendrás que traducirlas tú*. También los nombres de los productos, las categorías, las etiquetas, las páginas estáticas, etc. Prestashop no lo hará automáticamente por ti. #### Métodos de pago Otra cosa muy importante es configurar los métodos de pago. Esto se hace en *\"Modules\" > \"Installed Modules\" \"Payments & Gateways\". Muchos métodos de pago necesitarán que primero te registres como vendedor en el servicio correspondiente, como, por ejemplo, PayPal. Por defecto, solo estarán activados dos métodos de pago: \"Cheque\" y \"Transferencia bancaria\". Ambos deben configurarse con tu información bancaria para poder recibir los pagos. Esto se hace en los módulos *\"Payments by check\"* y *\"Wire payment\"*. Si activas cualquier otro método de pago, tendrás que configurarlo, como es lógico, desde su módulo. Y si no encuentras el método de pago que necesitas, puedes instalar otros desde el [*marketplace* de plugins de Prestashop](http://addons.prestashop.com/en/4-payments-gateways-prestashop-modules). #### Configuración de los envíos Cualquier tienda online necesita que configures también los envíos (excepto si lo que vendes son productos descargables, claro). Los envíos se configuran en el menú *\"Shipping\"*. Los envíos por correo, si los vas a llevar tú en persona a la oficina, son los más fáciles de configurar. Si contratas los envíos con cualquier empresa de transportes, necesitarás instalar el módulo para Prestashop de esa empresa para poder configurar y automatizar los envíos, de manera que los compradores puedan acceder, por ejemplo, a la información de seguimiento del mismo. La devolución de productos está, en principio, deshabilitada. Si deseas habilitarla y configurarla, echa un vistazo a *\"Customer service\" > \"Merchandise returns\" > \"Merchandise return (RMA) options\". #### Instalación de plugins (modules) Prestashop tiene un montón de plugins (o *modules*, en jerga de Prestashop) disponibles para realizar tareas de lo más diverso: análisis de tráfico, métodos de pago y envío, diseño y navegación por la web, *marketing*, etc. Eso, solo entre los plugins \"oficiales\" que puedes encontrar en el *marketplace* de Prestashop. Si hablamos de plugins de terceras partes, la oferta se multiplica. El ecosistema de plugins es tan amplio que no es posible tratarlo aquí ni en ningún otro sitio. Si alguna vez necesitas alguna funcionalidad extra de Prestashop, simplemente bucea por el *marketplace* para buscar un plugin que haga lo que necesitas. La dirección de *marketplace* oficial de Prestashop es: [http://addons.prestashop.com/en/2-modules-prestashop](http://addons.prestashop.com/en/2-modules-prestashop). Cuando instales un plugin, tendrás que activarlo y configurarlo. Asegúrate de que funciona correctamente y que se lleva bien con tu plantilla antes de continuar. Si te causa problemas, prueba a cambiar la configuración o, en última instancia, desinstálalo e inténtalo con otro. Un plugin desmadrado puede fastidiar el funcionamiento de toda la web. #### Elección de la plantilla (theme) Dejamos para el final uno de los aspectos más importantes en cualquier CMS: elegir e instalar una plantilla. La plantilla o *theme*, como en Wordpress, Moodle o cualquier otro CMS, determina la manera en la que se ve tu web. Es decir, afecta al aspecto pero no al contenido. Existen muchas plantillas para elegir en el *marketplace* de Prestashop: [http://addons.prestashop.com/en/3-templates-prestashop](http://addons.prestashop.com/en/3-templates-prestashop). Muchas son gratuitas, otras muchas de pago y, la mayoría, tienen una versión gratuita limitada y una versión de pago con más opciones. También puedes desarrollar tu propia plantilla, por supuesto. Hay toda una rama de programadores profesionales especializados en desarrollo de plantillas y plugins para Prestashop. Sin embargo, eso excede de los propósitos de este texto. ### 1.4.4. Explotación de Prestashop Después de instalar y configurar los aspectos más importantes de tu Prestashop, ya te habrás familiarizado bastante con el panel de administración. En esta sección, vamos a hacer un rápido recorrido por ese panel por si se te ha escapado algo. El diseño del panel de administración, como en cualquier CMS, puede variar un poco entre versiones. En general, es un panel intuitivo y fácil de usar, aunque al principio puede intimidar un poco por el elevado número de elementos que contiene. Vamos a tratar de poner un poco de orden en ese caos. #### La barra superior La barra superior del panel de administración contiene información muy útil y links importantes: * La versión de Prestashop. * Links de acceso rápido (se pueden configurar a tu gusto haciendo clic en *\"Manage quick accesses\"*). * Barra de búsqueda. * Modo depuración. Puede ayudarte a localiar la causa del error si estás teniendo problemas con tu Prestashop o con algún módulo. * *View my shop*. Esto sirve para ver la tienda como la vería un visitante. * Notificaciones pendientes (incluye los últimos pedidos sin procesar). * Enlace directo a los últimos pedidos realizados, los últimos clientes registrados y los últimos mensajes recibidos. * Acceso al perfil del usuario que está logueado. #### Menús Durante la administración de una tienda Prestashop, tendrás que navegar constantemente por un montón de páginas con opciones de configuración. El menú principal persigue facilitar esa navegación. Desde Prestashop 1.7, el menú principal está dividido en 3 grandes secciones: 1. ***Sell***. Esta es la sección en la que más se trabaja en el día a día de la explotación de un Prestashop. Aquí encontrarás el acceso a los pedidos realizados y al catálogo de productos en venta. También puedes acceder a los clientes, a la atención al cliente (devoluciones y cosas así) y a las estadísticas de visitas y ventas. 2. ***Improve***. En esta sección, puedes modificar la configuración de tu Prestashop para adaptarlo a tus necesitades. Aquí encontrarás el acceso a los módulos (plugins) instalados, las plantillas, los métodos de pago y envío y la configuración del idioma. 3. ***Configure***. En esta sección encontrarás la configuración avanzada de Prestashop, así que, en principio, no tienes necesidad de tocar nada. Hay cosas como configuración de los backups automáticos, empleados de la empresa, configuración de algunos parámetros del núcleo de Prestashop, configuración del servidor web... #### Los botones Muchas página del panel de administración usan botones en la parte superior e inferior. Por ejemplo, la página para editar un producto puede mostrar hasta 8 botones al mismo tiempo. Los botones siempre son los mismos y tienen el mismo comportamiento en todo el panel de administración. Los más habituales son los siguientes: * ***Add new***. Abre una página de creación de un recurso, dependiendo del contexto: un nuevo producto, una nueva categoría, un nuevo pedido... * ***Recommended Modules and Services***. Abre una ventana modal que contiene los módulos (plugins) disponibles en el contexto actual. Por ejemplo, en la página *\"Shipping > Carriers\"*, este botón mostrará los plugins instalados en la categoría *\"Shipping & Logistics\"*. Es muy útil cuando necesitas encontrar rápidamente qué módulo es adecuado instalar o configurar para obtener un resultado concreto. * ***Save*** y ***Save and stay***. Almacena los cambios que se hayan hecho en la página actual. La única diferencia entre uno y otro es que el primero regresa a la página anterior y, el segundo, permanece en la página actual. * ***Export*** e ***Import***. Exporta o importa los datos de la página actual en formato CSV (texto plano). * ***Refresh***. Vuelve a cargar los datos de la página actual sin abandonarla. #### Las tres columnas principales del panel de administración Además de los elementos anteriores, al entrar al panel de administración de Prestashop encontrarás tres columnas que ocupan casi todo el espacio disponible. Estas tres columnas, aunque puedan parecer abarrotadas a primera vista, proporcionan un excelente resumen del estado de tu tienda online. Encima de las tres columnas hay una barra que permite **seleccionar el periodo de tiempo** para el que se muestran los datos del resto del panl. Se pueden seleccionar valores como \"día actual\", \"mes actual\", \"año actual\", \"mes anterior\", \"año anterior\", etc. También se puede seleccionar un rango de fechas cualquiera. Al cambiar el selector de fechas, los bloques de contenido del resto del panel se actualizan para mostrar los datos correspondientes a ese periodo. * La **columna izquierda** ofrece un vistazo rápido de la actividad de tu tienda en el periodo seleccionado: visitantes, carritos activos, pedidos pendientes de servir, solicitudes de devolución pendientes, carritos abandonados, stock de productos y estadísticas diversas. * La **columna central** muestra varios gráficos de ventas y una lista de los últimos pedidos. Se pueden seleccionar varios gráficos de gran interés para comprobar la evolución de las ventas, e incuso se pueden comparar varios gráficos entre sí para obtener más información. Haciendo clic en el botón de configuración, accedemos a otra página donde se muestran los ingresos y los gastos, así como el grado de consecución de los objetivos. * La **columna derecha** es de tipo informativo y contiene las última noticias sobre Prestashop, así como notificaciones sobre nuevas versiones y enlaces útiles. ",
    "url": "/docs/dwes/_site/cms/prestashop.html",
    "relUrl": "/cms/prestashop.html"
  },"73": {
    "doc": "1.2 Wordpress",
    "title": "\">",
    "content": ". 'Main', 'container' => 'nav' )); ?> . ``` Echa un vistazo al código sin miedo. La mayor parte es HTML, y solo hay un toquecito de PHP aquí y allá. ¿Qué dices? ¿Qué aún no sabes PHP? Verás, no hay mucho que entender aquí, así que no te asustes a la primera de cambio. Vamos a analizar el código línea a línea para que entiendas lo que hace: * Observa que, después del *doctype*, hemos usado un poquito de PHP para indicar el idioma de la instalación de Wordpress, utilizando en PHP la función *language_attributes()*. Esa es una de las muchas funciones del API de Wordpress que podemos llamar desde PHP, pero no desde HTML. * Observa también que **todo el código PHP tiene que ir entre las etiquetas \"\" y \"?>\"**, aunque seguro que ya te habías dado cuenta de eso si realmente has intentado leer el código, ¿verdad? * En la siguiente línea, y con el objetivo de asignar el *charset*, también hemos recurrido a una función de Wordpress (*bloginfo()*), así como para el título de la página (función *wp_title()*). Todas esas funciones deben llamarse desde PHP, por lo que abrimos y cerramos las etiquetas \"\" y \"?>\" cada vez que lo necesitamos. * Más abajo especificaremos el *viewport*. Si tu tema no va a ser responsivo, puedes quitar esta línea de código. * Justo después, para mostrar la URL al *favicon.ico* le indicamos la ruta a la carpeta \"mi-tema\" de la instalación de Wordpress. Eso se consigue con la función de Wordpress *get_stylesheet_directory_uri()*. * Un poco más abajo se usa la función *bloginfo()* con el argumento 'stylesheet_directory', que tiene el mismo efecto que *get_stylesheet_directory_uri()*. * Finalmente, se usa la función *wp_head()* de Wordpress, necesaria para que los plugins y otras funcionalidades de Wordpress estén disponibles en las páginas cargadas con nuestro tema. A partir de aquí cerramos la etiqueta *head* de HTML y empezamos con los contenidos de *body*. Quizás en este punto te estés preguntando por qué incluir el body en header.php. La razón es sencilla: algunos contenidos de la cabecera del tema van a aparecer en todas las páginas del sitio web, por lo que, al incluirlo aquí, evitamos duplicar código y logramos que el mantenimiento del tema sea más sencillo. Así, dentro de la sección \"\" del *body* HTML, incluiremos nuestra cabecera. En este ejemplo, hemos puesto el nombre del sitio web con un enlace a la página de inicio: ```html ",
    "url": "/docs/dwes/_site/cms/wordpress.html",
    "relUrl": "/cms/wordpress.html"
  },"74": {
    "doc": "1.2 Wordpress",
    "title": "\">",
    "content": "``` Fíjate que dentro del \"\" hemos escrito esta línea: ```php 'Main', 'container' => 'nav' )); ?> ``` Sirve para crear el menú de navegación. Para que funcione correctamente, primero deberemos añadir al archivo ***functions.php*** (que contiene las funciones propias del tema, como dijimos antes) este código: ```php 'Main' ) ); } ?> ``` Este código crea un menú llamado \"Main\" que nos aparecerá en el panel de administración de Wordpress, en *Apariencia -> Menús*. Lo que este código dice es que si existe una función llamada *register_nav_menus*, entonces debe crearse un nuevo menú de navegación llamado *Main*. Además, la función de Wordpress *add_theme_support()* sirve para indicar que en este tema queremos poder crear menús dinámicos. A partir de aquí, simplemente habremos de ir a *Apariencia -> Menús* en el *Dashboard* de Wordpress, crear nuestro menú y guardarlo, como con cualquier otro *theme*. Con esto ya tenemos la cabecera del tema creada junto con su menú de navegación. #### Paso 4: Crear la barra lateral para widgets (sidebar.php) Si has trasteado un poco con Wordpress, te habrás dado cuenta de que la mayoría de los temas incluyen una barra lateral a la derecha o a la izquierda del contenido principal. Bueno, algunos incluyen varias barras laterales, pero vamos a centrarnos en una, que es lo más frecuente. Las barras laterales suelen utilizarse para contener los ***widgets***. Hay temas que admiten *widgets* (la mayoría) y otros que no. Lo primero que tendremos que hacer, entonces, es informar a Wordpress de que nuestro tema **sí admite *widgets***. Para ello, abriremos de nuevo el archivo ***functions.php*** e incluiremos esta función: ```php 'Main Sidebar', 'before_widget' => ' . ', 'after_widget' => '', 'before_title' => '', 'after_title' => ' . ', )); ?> ``` Si activamos este tema y vamos al *dashboard* de Wordpress, en el menú *Apariencia -> Widgets* veremos que nos aparece una nueva zona de *widgets* llamada *\"Main Sidebar\"*. Una vez creada la zona lista para *widgets*, vamos a llamarla dentro del archivo ***sidebar.php***, otro archivo típico de casi todas las plantillas. Creamos este archivo y escribimos: ```html ``` Hemos utilizado un id llamado *\"sidebar\"* porque en este tema sólo va a existir una barra lateral. Si quieres que tu tema tenga más barras laterales, quizás prefieras utilizar una clase *\"sidebar\"* en lugar de un id. Y listo, ya tenemos creada la barra lateral lista para contener *widgets*. #### Paso 5: Crear el pie de página (footer.php) Llega el momento de crear otro elemento común en casi todos los temas: el pie que aparecerá en todas las páginas del sitio web. Recuerda que Wordpress funciona por módulos, y que los módulos son como piezas de un puzle: hasta ahora hemos ido creando esas piezas (*header*, *sidebar*, y ahora el *footer*) para luego montarlas todas en *index.php*. Pero eso será un poco más adelante. Ahora centrémonos en el *footer*. El *footer* se crea, oh sorpresa, en un archivo llamado ***footer.php*** que puede quedarnos así: ```html &amp;amp;amp;copy; , . Mi primer tema. ``` Fíjate en que la capa id=\"wrapper\" empezó en el *header* y la terminamos ahora, en el *footer*. Esto es lo más habitual, pero si queremos un *header* o un *footer* que se extienda por toda la pantalla, podemos mover las posiciones de los *div* que abren y cierran la capa \"wrapper\". Aquí aparece una llamada a la función de Wordpress *wp_footer()*, que es semejante a *wp_header()*. Estas funciones son lo que se llaman **hooks de Wordpress** y hacen funcionar los plugins que instalemos. Si no la incluyes, tu tema funcionará, pero la mayor parte de los plugins, no. #### Paso 6: Crear la página principal (index.php) La página principal se diseña en el archivo ***index.php***. Nuestro index tendrá inicialmente este aspecto: ```html ``` Observa estas tres funciones clave del API de Wordpress: * ***get_header()*** inserta los contenidos del archivo header.php en ese punto. * ***get_sidebar()*** hace lo mismo con la barra lateral. * ***get_footer()*** hace... bueno, ya te imaginas lo que hace, ¿verdad? Así montamos nuestro puzle de tres piezas. Fácil, ¿no? Sí, sí, un puzle muy sencillo, pero con la estructura básica de muchos temas de Wordpress. Y, en cualquier caso, podemos complicarlo añadiendo más cosas. Que es justo lo que vamos a hacer ahora... #### Paso 7. El loop de Wordpress (otra vez index.php) En el ***loop*** reside toda la magia de Wordpress. ¿Qué es el *loop*? Es un bucle (claro) en el que se muestran las entradas almacenadas en la base de datos de Wordpress. Y nosotros podemos decidir cómo se muestran esas entradas. Este código de ejemplo de *loop* debe añadirse a continuación del anterior en ***index.php***: ```html ",
    "url": "/docs/dwes/_site/cms/wordpress.html",
    "relUrl": "/cms/wordpress.html"
  },"75": {
    "doc": "1.2 Wordpress",
    "title": "\">",
    "content": "Publicado el por . ``` La primera línea constituye el auténtico ***loop***: ```html ``` Wordpress mirará si hay alguna entrada disponible (*if(have_posts())*). Si es así, entramos en un bucle que se repite para todos los posts (*while(have_posts())*). Y, para cada post, se recupera su contenido de la base de datos (*the_post()*). Una vez seleccionado el post, se muestra su información: la fecha de publicación (*the_time()*), los autores (*the_author_posts_link())*, el extracto (*the_excerpt()*)... Si no hay posts, se muestra el mensaje de \"No hay entradas\". #### Paso 8. Añadir thumbnails al loop (seguimos en index.php) Si queremos **añadir *thumbnails*** (imágenes destacadas) a cada publicación como sucede en muchos sitios web, lo que haremos es lo siguiente: vamos al archivo ***functions.php*** y añadimos este código: ```html ``` Con este código hemos habilitado los *thumbnails* de nuestras entradas y hemos establecido un tamaño para los mismos de 200x150 píxeles. Una vez hecho esto, modificaremos el *loop* de ***index.php*** como sigue: ```html ",
    "url": "/docs/dwes/_site/cms/wordpress.html",
    "relUrl": "/cms/wordpress.html"
  },"76": {
    "doc": "1.2 Wordpress",
    "title": "\">",
    "content": "Publicado el por . ``` Observa que hemos añadido un par de líneas en las que se comprueba si el post tiene *thumbnail* y, en caso afirmativo, lo recuperamos de la base de datos y lo mostramos (función *the_post_thumbnail()*). La forma concreta en la que queremos que se visualice todo esto debe establecerse mediante CSS, por supuesto, en el archivo *style.css*. Vamos a dejar de añadir cosas *loop* en este punto, pero podríamos seguir ìncorporando elementos. Por ejemplo, **una paginación** de las entradas. Encontrarás en la red mucha información sobre el tema, aunque lo más práctico es bajarse una plantilla sencillita ya hecha que incluya lo que sea que queremos hacer y curiosear en su código fuente. #### Paso 9. Resultados de la búsqueda (search.php) Los resultados de la búsqueda se especifican en el archivo ***search.php***. He aquí un ejemplo: ```html ",
    "url": "/docs/dwes/_site/cms/wordpress.html",
    "relUrl": "/cms/wordpress.html"
  },"77": {
    "doc": "1.2 Wordpress",
    "title": "Resultados de la búsqueda",
    "content": " ",
    "url": "/docs/dwes/_site/cms/wordpress.html",
    "relUrl": "/cms/wordpress.html"
  },"78": {
    "doc": "1.2 Wordpress",
    "title": "\">",
    "content": "Publicado el por max_num_pages); } ?> ``` Fíjate qué curioso: se parece mucho a *index.php*. Tiene sentido, puesto que el resultado de una búsqueda no es otra cosa que una lista de *posts*. Esta página es la que va a mostrar los resultados de una búsqueda, así que vamos a necesitar habilitar el buscador en nuestro *theme*. Un buen sitio para colocarlo puede ser el *sidebar*. Iremos a nuestro archivo *sidebar.php* y, justo antes de la función que habilita la zona de *widgets* en la barra lateral, incluiremos este código: ```html /\"> \" name=\"s\" id=\"s\" /> ``` Con esto tenemos un campo de búsqueda en nuestra barra lateral. No olvides que en el archivo *style.css* debes dar formato a todas las clases e ids para que la plantilla se visualice como tú quieras. #### Paso 10. Configurar la vista de las entradas (single.php) La página de cada entrada o post individual es aquella donde solo se ve una entrada con todo su contenido. El archivo donde se define esto es ***single.php***, y puede ser más o menos así: ```html ",
    "url": "/docs/dwes/_site/cms/wordpress.html",
    "relUrl": "/cms/wordpress.html"
  },"79": {
    "doc": "1.2 Wordpress",
    "title": "\" rel=\"bookmark\" title=\"Enlace permanente a \">. ",
    "content": "Publicado por el . Categoría: ``` Si has llegado hasta aquí, te resultará fácil comprender este código. Si en el *loop* principal (en *index.php*) utilizamos *the_excerpt()* para mostrar el extracto de la entrada, aquí utilizamos la función *the_content()* para recuperar el contenido completo de la entrada. Por supuesto, esto se puede complicar hasta el infinito. A modo de ejemplo, observa cómo podríamos mostrar las entradas relacionadas: ```html ID); if ($tags) { $tag_ids = array(); foreach($tags as $individual_tag) $tag_ids[] = $individual_tag->term_id; $args=array( 'tag__in' => $tag_ids, 'post__not_in' => array($post->ID), 'showposts'=>5, // Number of related posts that will be shown. 'caller_get_posts'=>1 ); $my_query = new wp_query($args); if( $my_query->have_posts() ) { echo 'Artículos relacionados . '; while ($my_query->have_posts()) { $my_query->the_post(); ?> | \" rel=\"bookmark\" title=\"Permanent Link to \"> | '; } wp_reset_query(); } ?> ``` #### Paso 11: Habilitar y mostrar los comentarios Para permitir los comentarios en una entrada, añadiremos este código a nuestro archivo ***functions.php***: ```php // Permitir comentarios encadenados function enable_threaded_comments(){ if (is_singular() AND comments_open() AND (get_option('thread_comments') == 1)) { wp_enqueue_script('comment-reply'); } } add_action('get_header', 'enable_threaded_comments'); ``` Y en ***single.php***, justo antes de la línea del *endwhile*, escribiremos: ```html ``` Nuevamente, será el CSS, como es lógico, el que determine cómo se verán los comentarios. #### Paso 12: Crear la página de categorías y etiquetas Los archivos ***category.php*** y ***tags.php*** muestran, en ambos casos, una lista de entradas: * *category.php* muestra las entradas que pertenecen a una categoría. * *tags.php* muestra las entradas que contienen una etiqueta concreta. Eso significa que, de cara a la creación de la plantilla, los dos archivos son prácticamente iguales entre sí, y que los dos archivos contienen un *loop* muy semejante al de *index.php*. Para nuestra plantilla de ejemplo, te sugerimos que, en lugar de crear esos dos archivos, añadas esto antes del *loop* de *index.php*: ```html ",
    "url": "/docs/dwes/_site/cms/wordpress.html",
    "relUrl": "/cms/wordpress.html"
  },"80": {
    "doc": "1.2 Wordpress",
    "title": "Categoría: ",
    "content": " ",
    "url": "/docs/dwes/_site/cms/wordpress.html",
    "relUrl": "/cms/wordpress.html"
  },"81": {
    "doc": "1.2 Wordpress",
    "title": "Etiqueta: ",
    "content": "``` Cuando Wordpress vaya a mostrar, por ejemplo, la lista de artículos de una categoría, buscará el archivo *category.php* en la plantilla pero, como no lo encontrará, recurrirá a *index.php*. Y nuestro archivo *index.php* detectará que está mostrando los artículos de una categoría (*if (is_category()*) y mostrará el nombre de esa categoría antes del listado. #### ¿Y ahora qué? Ya tienes una plantilla sencilla y funcional creada desde cero. La creación de plantillas no termina aquí, claro. Solo hemos sentado las bases, pero son unas bases sólidas. La API de Wordpress es muy amplia, a menudo confusa y casi siempre redundante. Especializarse en el desarrollo para Wordpress es una tarea de largo recorrido que no puede aprenderse en unas cuantas horas. Pero si has llegado hasta aquí, ya has hecho, probablemente, lo más difícil. La mayoría de las plantillas tienen más archivos que la nuestra. Por ejemplo: * ***page.php***, para mostrar páginas estáticas. * ***author.php***, para mostrar la página de \"acerca de\". * ***404.php***, para crear nuestra propia página de error \"not found\". Por último, aquí tienes un diagrama de las relaciones que existen entre los archivos típicos de una plantilla Wordpress. Recuerda que el único obligatorio (además de styles.css) es index.php, y que una plantilla compleja puede tener otros archivos adicionales a los que aquí se muestran. ![Jerarquía de archivos de un tema de Wordpress](/docs/dwes/_site/assets/images/01-wordpress-jerarquia-archivos-tema.png) [Fuente: Wikimedia Commons](https://commons.wikimedia.org/wiki/File:Wordpress_Template_Hierarchy.png) Cuando Wordpress busque alguno de estos archivos y no le encuentre, recurrirá al siguiente en la jerarquía, y si no existe, al siguiente, y así hasta llegar a *index.php*, que sí debe existir. Eso es lo que nos ocurría en el Paso 12, cuando creábamos la plantilla para categorías dentro de *îndex.php* y no en *category.php*. ### 1.2.5. Plugins de Wordpress Los plugins de Wordpress, como cualquier plugin, son **añadidos que incrementan las funcionalidades del sistema base**. La arquitectura flexible de Wordpress permite realizar esa ampliación en casi cualquier sentido y es una de las razones del éxito de este CMS: con los plugins adecuados, un CMS originalmente pensado para hacer *blogging* puede convertirse casi en cualquier cosa. Los plugins, como ya hemos visto, se gestionan desde el menú \"Plugins\" del *dashboard*. Al instalar y activar un plugin, lo más habitual es que aparezca una nueva entrada de menú en algún sitio del *dashboard*. Cada plugin es virtualmente un programa nuevo acoplado a Wordpress, por lo que debes remitirte a la documentación de ese plugin para saber cómo utilizarlo. Hay muchos plugins gratuitos, otros muchos de pago y una gran mayoría que tienen una versión limitada gratuita y otra de pago con funciones adicionales. El desarrollo de plugins para Wordpress es una industria que proporciona muchos puestos de trabajo a programadores/as en la actualidad. Como hicimos con los *themes*, **vamos a ilustrar con un ejemplo el proceso de creación de plugins**. Haremos algo muy sencillo pero bien construido, de manera que pueda servirte para desarrollos posteriores más realistas. El plugin se llamará **\"Chiste\"** y se encargará de imprimir un chiste aleatorio cada vez que lo llamemos desde nuestra plantilla. El chiste aleatorio se extraerá de una tabla con chistes que almacenaremos en la base de datos. Lo puedes usar para imprimir un chiste en tu web de cuando en cuando, o para mostrar un chiste diferente cada vez que se carga la página, o yo qué sé para qué. Construiremos el plugin paso a paso, desde una versión muy simple que siempre contará el mismo chiste hasta la versión definitiva. De este modo, comprenderás muy bien el funcionamiento del sistema de plugins de Wordpress. #### **Crear un plugin nuevo** Para crear el plugin \"Chiste\" basta con crear un archivo llamado ***chiste.php*** en una carpeta llamada también *chiste* y ubicada a su vez en *wp-content/plugins/* Dentro del archivo *chiste.php*, escribiremos el comentario de cabecera para que Wordpress lo reconozca como un plugin válido (igual que sucede con las plantillas). Es muy importante respetar la sintaxis. ```php ``` #### **Añadir funciones al plugin** Vamos a crear nuestra primera función dentro del plugin. Abre el archivo ***chiste.php*** y añade esto: ```php function chiste(){ echo \"Van dos por tres calles y se cae el de enmedio\"; } ``` Supongo que este código no requiere demasiada explicación, ¿no? Pues ahí lo dejamos. #### **Instalar y desinstalar el plugin** Para poder instalar y desinstalar un plugin desde el panel de administracion de Wordpress, es necesario crear dos funciones más en ***chiste.php***: una para instalar y otra para desinstalar. Estas funciones, por ahora, las dejaremos vacías. Además, al final del archivo ***chiste.php*** hay que usar la funcion del API de Wordpress add_action() para indicar las funciones que activan y desactivan el plugin. Es más fácil hacerlo que explicarlo. Ahí va: ```php function chiste_instala(){ // Por ahora, la dejamos vacía } function chiste_desinstala(){ // Por ahora, la dejamos vacía } add_action('activate_chiste/chiste.php','chiste_instala'); add_action('deactivate_chiste/chiste.php', 'chiste_desinstala'); ``` #### **Cómo usar las funciones del plugin** Ahora ya puedes usar este plugin tan chistoso. Solo debes colocar en alguna sección de tu plantilla la siguiente línea: ```php ``` Por ejemplo, si colocas esa función en el archivo *header.php* de tu plantilla, cada vez que se cargue el header (es decir, en todas las páginas), la función *chiste()* será invocada y, hala, un chiste impreso en tu pantalla. #### **Configurar el plugin desde el panel de administración** Ahora vamos a crear una entrada dentro de los menús del *dashboard* que nos permita modificar las opciones de este plugin. La entrada de menú la integraremos en el menú \"opciones\". Para lograrlo, necesitamos dos funciones más en nuestro archivo ***chiste.php***: * *chiste_panel()*: aquí incluiremos el html necesario para la pantalla de configuración de nuestro plugin. Para no mezclar html dentro del código, usaremos la función include() de PHP, de manera que podamos colocar el HTML en otro archivo a parte. * *chiste_add_menu()*: aquí usaremos la función del API de Wordpress *add_options_page()*, que sirve para añadir una entrada al menó \"Opciones\". Además, llamaremos a otra función del API, *add_action()*, para provocar la invocación de *chiste_add_menu()* cada vez que Wordpress vaya a crear su menú de administración. ```php ``` Quizá la línea de *add_options_page()* requiera alguna explicación adicional, ¿verdad? Lo único que hacemos ahí es añadir una entrada al menú de opciones del *dashboard*, indicándole en los parámetros: * El título de la pantalla de administración de nuestro plugin (\"chiste\"). * El texto de la entrada de menú (también \"chiste\"). * El permiso necesario del usuario que podrá ver este elemento de menú. Hemos elegido \"manage_options\", que es un permiso típico de los administradores del sitio. Otros usuarios de menor nivel no podrán acceder a este menú. Tienes una lista completa de los permisos (o *capabilities*, en jerga de Wordpress) en https://wordpress.org/support/article/roles-and-capabilities/) * La URI amigable para esta opción de menú. Puede ser cualquier cosa, siempre que no esté ya en uso. Hemos usado el propio nombre del archivo (*basename(__FILE__)*) para evitar conflictos con otras opciones de menú. * El nombre de la función que se invocará cuando se haga clic en ese elemento de menú (es decir, *chiste_panel()*). El archivo *panel.html* será un simple formulario html que mostrará la configuración del plugin. Crearemos algo muy sencillo. Por supuesto, se puede mejorar con un poco de HTML y CSS. Lo guardaremos en ***template/panel.html***: ```html Inserte su chiste ``` Por último, modificaremos la función *chiste_panel()* para poder visualizar nuestros avances: ```php <?php function chiste_panel(){ include('template/panel.html'); } echo \" ",
    "url": "/docs/dwes/_site/cms/wordpress.html",
    "relUrl": "/cms/wordpress.html"
  },"82": {
    "doc": "1.2 Wordpress",
    "title": "{$_POST['chiste']}",
    "content": "\"; ?> ``` Podemos probar que todo funciona escribiendo algo en el formulario (pulsando \"Enviar\"). #### **Acceder a la BD desde nuestro plugin** También se puede acceder a la base de datos de Wordpress desde un plugin. Esto es práctico para, por ejemplo, crear nuestra propia tabla adicional con la que gestionar el contenido del plugin, que es justo lo que nosotros queremos. Para ello, antes debemos desinstalar el plugin desde el panel de control. Solo así podremos modificar la función de instalación y ejecutarla más adelante de nuevo. Las funciones de Wordpress que manejan la BD se invocan con una variable global ***$wpdb***: ```php prefix . \"chistes\"; $sql = \" CREATE TABLE $table_name( id INTEGER NOT NULL AUTO_INCREMENT , chiste TEXT NOT NULL , PRIMARY KEY ( `id` ) ) ;\"; $wpdb->query($sql); $sql = \"INSERT INTO $table_name (chiste) VALUES ('Van dos por tres calles y se cae el de enmedio');\"; $wpdb->query($sql); } function chiste_desinstala(){ global $wpdb; $tabla_nombre = $wpdb->prefix . \"chistes\"; $sql = \"DROP TABLE $tabla_nombre\"; $wpdb->query($sql); } ?> ``` Por supuesto, hay que agregar los datos a la BD desde nuestro panel de configuración del plugin, para lo cual modificaremos la función *chiste_panel()*: ```php function chiste_panel(){ include('template/panel.html'); global $wpdb; $table_name = $wpdb->prefix . \"chistes\"; if(isset($_POST['chiste_inserta'])){ $sql = \"INSERT INTO $table_name (chiste) VALUES ('{$_POST['chiste_inserta']}');\"; $wpdb->query($sql); } } ``` ¡Ahora que ya podemos insertar chistes en nuestra BD desde el *dashboard* de Wordpress! Solo nos queda poder mostrarlos en nuestra función *chiste()*. Para esto, extraeremos un chiste de manera aleatoria de nuestra BD modificando la función *chiste()*: ```php function chiste(){ global $wpdb; $table_name = $wpdb->prefix . \"chistes\"; $chiste = $wpdb->get_var(\"SELECT chiste FROM $table_name ORDER BY RAND() LIMIT 0, 1; \" ); include('template/chiste.html'); } ``` Ahora modifiquemos nuestro ***template/chiste.html*** para que imprima la variable $chiste: ```html ",
    "url": "/docs/dwes/_site/cms/wordpress.html",
    "relUrl": "/cms/wordpress.html"
  },"83": {
    "doc": "1.2 Wordpress",
    "title": "",
    "content": "``` Para terminar, vamos modificar el html de nuestro panel de opciones para que se adapte al html del administrador de Wordpress y no quede tan feo. Esto es solo una cuestión estética, por supuesto. Pero, ya que hacemos algo, vamos a hacerlo bien: ```html Introduce un nuevo chiste Escriba el chiste ``` ",
    "url": "/docs/dwes/_site/cms/wordpress.html",
    "relUrl": "/cms/wordpress.html"
  },"84": {
    "doc": "1.2 Wordpress",
    "title": "1.2 Wordpress",
    "content": "## 1.2. Wordpress {: .no_toc } - TOC {:toc} Wordpress es sin duda el campeón actual de los CMS. Algunas estadísticas afirman que el 90% de los sitios web de internet está hecho con Wordpress. Probablemente son estadísticas un poco infladas, pero la importancia de este CMS es innegable y cualquier desarrollador web debe conocerlo, aunque sea para odiarlo. Wordpress es un CMS enfocado a la creación de blogs, pero, en su estadio actual, permite crear casi cualquier tipo de sitio web: tiendas online, portales, revistas digitales, álbumes de imágenes o recursos de cualquier tipo... Está desarrollado en PHP bajo licencia GPL y se ha convertido en una auténtica plataforma de desarrollo web por sí mismo. Tiene detrás una enorme comunidad de desarrolladores y diseñadores, que se encargan de actualizarlo y de crear plugins y temas para la comunidad. ### 1.2.1. Características principales de Wordpress Las características principales de Wordpress son: * Separación entre el contenido y el diseño. El contenido se almacena en una base de datos. El diseño, en una plantilla, que es un conjunto de archivos CSS y PHP. * Apuesta decidida por la apariencia atractiva del resultado final (aunque esto depende mucho de la plantilla, claro) . * La estructura y diseño visual del sitio depende de un sistema de plantillas. Es decir: cambias la plantilla y todo el sitio web cambia de aspecto, conservando el mismo contenido. * La visualización final del contenido también depende de los plugins y widgets que se hayan instalado, y que pueden modificar sustancialmente en funcionamiento tanto del front-end como del back-end. * Código claro, bien estructurado y con una API bien documentada (alrededor del 50% de los programadores querrán internarme en un psiquiátrico por haber escrito esto). * Apuesta decidida por respetar las recomendaciones del W3C, aunque, desde luego, hay plugins y plantillas que no lo hacen. * Las entradas publicadas se ordenan por fecha, aunque esto se puede modificar. Wordpress se diseñó para hacer *blogging* y esa intención inicial aún permanece intacta, pero con un poco de manipulación puede emplearse para cualquier cosa. #### Funcionalidades de Wordpress Wordpress hace magia. Así de sencillo. Si te vas a convertir en desarrollador/a web, Wordpress es tu peor enemigo, porque permite que cualquier usuario medio, sin tener ni idea de programación, pueda crear un sitio web solvente y de aspecto profesional en un rato. No te voy a engañar: *a ti te llevaría meses programar algo parecido desde cero*. Pero **Wordpress también tiene sus limitaciones**, y cuando sus usuarios las descubren, necesitan a un programador que sepa meterse en las tripas del sistema para retorcérselas. Ahí es donde entrarás tú. De modo que sí: **Wordpress es tu peor enemigo, pero puede convertirse en tu mejor aliado**. Para eso, tienes que conocer qué es capaz de hacer y qué no. Entre sus asombrosas funciones podemos contar estas: * Fácil instalación, actualización y personalización. * Actualizaciones automáticas. * Múltiples usuarios con diferentes roles. * Capacidad de crear páginas estáticas además de entradas de blog. * Organización de las publicaciones por categorías y etiquetas (\"tags\"). * Buscador integrado de contenido. * Editor WYSIWYG (\"What You See Is What You Get\") por bloques. * Guardado automático de los artículos mientras se escriben. * Moderación de comentarios. * Personalización de las URIs de cada publicación. * Distribución de los artículos y comentarios mediante RSS y otros mecanismos estandarizados. * Gestión intuitiva de la biblioteca multimedia. * Admite plugins para aumentar y/o modificar la fucionalidad del sistema, a riesgo de convertirlo en una \"monstruo de Frankenstein\" hecho a pegotes. * Admite plantillas que cambian de forma radical la apariencia del sitio. * Admite widgets o pequeñas utilidades adicionales que pueden ubicarse en los lugares que la plantilla permita. #### Plantillas de Wordpress Las plantillas (o *themes*) de Wordpress son **diseños CSS que sirven para establecer la apariencia y estructura del sitio web**. Algunas también modifican parte del panel de administración. Hay una gran comunidad dedicada al diseño de estas plantillas. Puedes encontrarlas tanto en el sitio de Wordpress (comprobadas y aprobadas oficialmente) como en sitios web de terceros. Muchas son gratuitas, otras de pago y, la mayoría, tienen una versión gratuita con funciones adicionales de pago. Las posibilidades de las plantillas, tanto a nivel de diseño, estructura o gestión, son tan grandes que te permiten tener desde un simple blog hasta un sitio web completamente personalizable de forma intuitiva desde el panel de administración. Hay un gran campo de trabajo en las plantillas de Wordpress para un desarrollador web. Más adelante veremos como crear plantillas nuevas, algo que también te servirá para modificar las plantillas existentes. #### Widgets Los widgets son **pequeñas aplicaciones** que proporcionan nuevas funcionalidades a un programa o que permiten un acceso rápido a funcionalidades usadas con frecuencia. Pueden ser vistosos como, por ejemplo, relojes en pantalla, calculadoras, calendarios o nubes de tags; o pueden ser discretos pero útiles como, por ejemplo, un cuadro con enlaces de interés o un contador del número de visitas. Wordpress incorpora un sistema de widgets para sus plantillas que ofrece numerosas posibilidades y flexibilidad para el diseño y estructura de sus blogs. Cada plantilla puede soportar un número diferente de Widgets en distintas posiciones de la pantalla. #### Plugins Hay una monstruosa cantidad de plugins que **potencian el uso de Wordpress y que lo convierten en un CMS prácticamente de propósito general**. Encontrarás un plugin para casi cualquier cosa que se te ocurra. Bueno, no: encontrarás decenas de plugins para casi cualquier cosa que se te ocurra. Pero (¡siempre hay un pero!) con los plugins se corre el riesgo de empezar a parchear Wordpress hasta convertirlo en un amasijo informe de código puesto a pegotes. Muchos sitios web montados con Wordpress se vuelven ingobernables (y extraordinariamente lentos y pesados en la carga) por la gran cantidad de plugins que tienen activados. Otro problema de los plugins es que pueden provocar incontables problemas con las actualizaciones del sistema. En el ámbito de los plugins también hay mucho trabajo potencial para un futuro desarrollador/a web como tú: tanto para crear plugins nuevos y adaptados a las necesidades del cliente como para optimizar y racionalizar el uso de plugins existentes en los sitios que ya están en funcionamiento. Por último, y al igual que ocurría con las plantillas, tienes que saber que muchos plugins son gratuitos, otros son de pago, y otros tienen versiones gratuitas que se vuelven de pago cuando queremos utilizar sus características más atractivas. #### Fallos de seguridad de Wordpress Las críticas más contundentes contra Wordpress siempre se han centrado en sus problemas de seguridad. En mayo de 2007, por ejemplo, un estudio reveló que el 98% de los blogs basados en Wordpress eran vulnerables a ataques. Todos los sistemas que se vuelven muy populares se vuelven inseguros por el simple hecho de que se multiplican los ataques contra ellos. La receta para minimizar los posibles problemas de seguridad es sencilla: **mantener Wordpress actualizado**. No podemos hacer mucho más allá de eso. ### 1.2.2. Instalación y explotación de Wordpress #### Instalación de Wordpress Wordpress es un CMS increíblemente sencillo de instalar y poner en marcha. El proceso de instalación se ha depurado tanto, que cualquier usuario medio sin especiales conocimientos técnicos puede llevarlo a cabo. Como tú no eres un usuario/a medio, no vamos a detenernos mucho en ello, porque es realmente sencillo. A continuación, resumimos los pasos: 1. Necesitas, obviamente, ciertos prerrequisitos: acceso a un servidor web con soporte para PHP y un servidor de bases de datos MariaDB o similar. 2. Crea una base de datos vacía. Puedes llamarla como quieras (siempre que recuerdes el nombre, claro). 3. Descarga el código fuente de Wordpress (¡solo del sitio oficial, por favor! Es decir, de wordpress.org) y súbelo a una carpeta en tu servidor. La carpeta debe ser accesible vía web. Puedes usar FTP para ello. Muchos servidores tienen un navegador de archivos vía web que también te permitirá subir el código fuente. Otros servidores incluso te ofrecen la posibilidad de instalar Wordpress desde el propio panel de control de servidor. Consulta con tu proveedor o trastea con el panel de control para ver si es tu caso. 4. Lanza el programa de instalación. Esto se logra, simplemente, escribiendo la URI de tu wordpress. Algo como https://tu-servidor/tu-carpeta, donde \"tu-servidor\" es el nombre de dominio de tu servidor y \"tu-carpeta\" es la carpeta donde subiste el código fuente de Wordpress. 5. Aparecerá una pantalla como esta. A partir de aquí, solo tienes que seguir las instrucciones. ![Pantalla de instalación de Wordpress](/docs/dwes/_site/assets/images/01-wordpress-instalacion.png) #### Explotación de Wordpress Una vez que tienes instalado tu Wordpress en el servidor, ya dispones de un sitio en línea que puedes visitar en la URI https://tu-servidor/tu-carpeta. El sitio es por completo funcional pero, obviamente, está vacío de contenido. Su aspecto será más o menos como este: ![Wordpress recién instalado](/docs/dwes/_site/assets/images/01-wordpress-recien-instalado.jpg) Lo que estás viendo aquí es la plantilla (*theme*) por defecto de Wordpress. Dependiendo de la versión que instales, tendrá un aspecto algo diferente. Una instalación nueva también incorpora una publicación (*post*) de ejemplo (con un comentario también de ejemplo), así como una página estática. Lo siguiente que tienes que hacer es acceder al panel de administración, que estará hubicado en https://tu-servidor/tu-carpeta/wp-admin. Verás una pantalla de login donde tendrás que introducir el usuario y la contraseña de administración de Wordpress. Estas credenciales las seleccionaste durante el proceso de instalación. Una vez traspasada la puerta del login, encontrarás una pantalla con la que debes familiarizarte: el **panel de administración** o ***dashboard*** de Wordpress. ![Panel de administración de Wordpress](/docs/dwes/_site/assets/images/01-wordpress-panel-administracion.png) El resto de tu trabajo consistirá en familiarizarte con este panel de administración. Es una aplicación web muy completa e intuitiva, y a cualquier usuario/a un poco avezado no le costará trabajo hacerse con ella, e incluso le resultará divertido. No hay que decir que no necesitas saber nada de programación para manejar este panel. Solo a modo de introducción, te resumo las secciones principales que puedes encontrar en el *dashboard* de Wordpress, accesibles mediante el menú de la izquierda: * **Post**. Son las publicaciones de Wordpress (recuerda que, originalmente, era una herramienta para hacer *blogging*). Los artículos se crean con un sencillo editor WYSIWYG al que se le pueden ir añadiendo bloques. Hay multitud de opciones de configuración de cada artículo: a qué categoría pertenecen, qué etiquetas tienen, si se permiten o no los comentarios, la fecha de la publicación, la autoría, etc. * **Media**. Es la biblioteca multimedia. Desde aquí se organizan todos los recursos multimedia: imágenes, vídeos, audios, documentos... Cualquiera de esos recursos puede incrustarse en cualquier post. * **Pages**. Son las páginas estáticas de Wordpress. A diferencia de los posts, no se organizan cronológicamente ni se pueden asignar a categorías. Se utilizan para las páginas cuyo contenido debe estar siempre accesible y cambia poco con el tiempo: \"Acerca de\", \"Contacto\" y cosas así. * **Comments**. Desde aquí se moderan los comentarios que los visitantes hayan hecho a los posts. Aquí termina la parte del *dashboard* dedicada a gestionar el **contenido** del sitio. El resto de menús se dedican a gestionar la **apariencia y configuración** del sitio: * **Appearance**: Aquí se manipulan las plantillas (themes), los widgets, los menús... Pasarás incontables horas de diversión (y desesperación) en esta sección. * **Plugins**: No te desvelo nada nuevo si te digo que desde aquí gestionas los plugins, ¿verdad? * **Users**: Puedes dar acceso a otros usuarios a tu Wordpress. Hay varios niveles o roles de acceso: administrador, editor, publicador... Cada rol verá un menú de administración diferente. * **Tools**: Diferentes herramientas útiles. Importar y exportar contenido son las principales. Muchos plugins añadirán opciones a este menú (otros las añadirán en otra parte). * **Settings**: Opciones de configuración del sitio. Aquí se pueden cambiar muchas cosas muy importantes: el nombre del sitio, el formato de las URIs, si se permiten o no comentarios por defecto, si los comentarios se publican inmediatamente o tiene que moderarlos un administrador. Conviene que te pases un rato curioseando y probando cosas. ### 1.2.3. Breve tour por Wordpress para novatos Todo esto puede parecer complicadísimo, pero Wordpress (a nivel de usuario) es muy secillo de usar cuando has pasado un poco de tiempo con él. Si es tu primera vez con Wordpress, te recomiendo que te prepares un café (o tu infusión favorita), te sientes sin prisa ante el ordenador en algún momento en el que no te vayan a interrumpir durante varias horas y dediques una sesión intensiva a hacer lo siguiente: 1. **Instala un Wordpress** de prueba en tu servidor local o en un servidor remoto si aún no lo has hecho. 2. Accede al **panel de administración**. 3. **Crea dos o tres categorías**. Antes deberás decidir qué temática tendrá tu sitio. Utiliza algún tema de tu interés: un deporte, la tecnología, la programación, el cine, la literatura... Si usas algo que te interese, la experiencia será mucho más fructífera. Por ejemplo, si tu temática es \"programación\", podrías crear las categorías \"Java\", \"PHP\" y \"Python\", por decir algo. 4. **Crea un par de entradas** por cada categoría. No tienen que ser nada especial: solo estamos jugueteando. Copia y pega texto de alguna otra publicación de internet. O redáctalas tú, como prefieras. Asegúrate de incluir alguna imagen y otros elementos multimedia. 5. **Crea alguna página** (\"Acerca de\", \"Sobre mí\", \"Contacto\" o algo así). 6. **Cambia de plantilla**. Prueba varias que te gusten y, cuando te decidas por una, métete en sus opciones de configuración y trastea un rato. Algunas plantillas son configurables hasta límites enfermizos. Otras, en cambio, son muy limitadas. No olvides ir observando cómo estos cambios afectan a la forma en la que los visitantes verían en blog. 7. **Instala algunos plugins** de prueba que te parezcan interesantes. Por ejemplo, galerías de imágenes o formularios de contacto. 8. **Crea algunos usuarios** adicionales con distintos roles. Accede con ellos al panel de administración para ver las diferencias entre unos roles y otros. 9. **Juguetea sin miedo con las opciones** del menu \"Settings\". Algunas de ellas podrían dejar tu Wordpress totalmente inoperativo. ¡Bienvenido a la vida real! Trata de resolver el problema bicheando en internet. Antes o después, eso mismo te ocurrirá con sitios reales. Cuando termines esta experiencia inmersiva (que puede llevarte varios días), estarás en condiciones de montar un sitio web con Wordpress real. ### 1.2.4. Cómo crear y modificar una plantilla de Wordpress Wordpress dispone de una API de funciones útiles para desarrollar nuestras propias plantillas (*themes*) y plugins. Como vamos a hacer a lo largo de todo el texto, veremos este asunto de forma práctica: **creando nuestra propia plantilla desde cero**. Por cierto, que a lo largo de toda la sección nos referiremos indistintamente a las plantillas de Wordpress como *plantillas*, *temas* o *themes*, pues así lo encontrarás en toda la documentación que consultes. ¿Estás preparado/a? ¡Vamos allá! #### Las plantillas o temas de Wordpress Como ya hemos dicho, existen muchos sitios web donde adquirir plantillas (*themes*), empezando por el propio sitio oficial de Wordpress. Algunas son gratuitas, otras de pago, y otras tienen versiones gratuitas incompletas o parcialmente desactivadas, y versiones de pago que permiten usar todas las funcionalidades. Pero, a veces, queremos ir un paso más allá y desarrollar nuestra propia plantilla. Para ello, tenemos dos opciones: 1. **Utilizar una plantilla base**. Existen muchas plantillas básicas diseñadas para ser usadas como base para desarrollar nuevas plantillas. Contienen todos los elementos mínimos necesarios de una plantilla de Wordpress, además de otras características, de modo que el trabajo de creación de la nueva plantilla se minimiza. Estas plantillas a veces también se llaman *frameworks* Algun plantillas básicas muy conocidas son *Bones*, *Basic* o *Divi*. Los desarrolladores profesionales pueden acabar creando su propia plantilla base a partir de la cual crear el resto de plantillas a su gusto. 2. **Desarrollar la plantilla desde cero**. Este proceso es más costoso en tiempo, pero conseguiremos aproximarnos más a lo que estamos buscando, evitando estar atados a un *framework* que no hemos programado nosotros y conservando el control absoluto sobre los archivos y contenidos de la plantilla. En este texto vamos a decantarnos por la segunda opción, no porque sea mejor ni peor, sino porque es lo más didáctico si pretendemos aprender cómo se organizan las plantillas de Wordpress. #### Dónde localizar las plantillas instaladas Puedes encontrar los temas instalados a través del panel de administración (*dashboard*) de tu Wordpress, en el menú Appearance -> Themes. Pero, para nuestros propósitos, es mejor hacerlo navegando directamente entre las carpetas del servidor, en la ruta *carpeta-de-wordpress -> wp-content -> themes*. Ahí encontrarás una carpeta por cada plantilla de Wordpress instalada en tu sistema. Bastará, entonces, con crear una carpeta nueva para iniciar la construcción de nuestra plantilla. A partir de ahora supondremos que estamos creando un nuevo tema llamado ***mi-tema***. Es decir, dentro de la carpeta *themes*, habremos creado un directorio llamado *mi-tema*. #### Archivos mínimos de un tema de Wordpress Wordpress funciona mediante **módulos**. Por ejemplo, para insertar el pie de una página habremos de llamar al archivo *footer.php*, en caso de que exista. Y lo mismo con la cabecera, la barra de navegación, etc. Cada uno de esos elementos es un módulo. Una plantilla de Wordpress puede estar formada por muchos archivos, pero **para que un tema de Wordpress funcione sólo necesita dos archivos: index.php y style.css**. Está claro que con sólo estos dos archivos tendremos un tema muy básico, pero será considerado por Wordpress un tema válido si estos dos archivos están bien configurados. A continuación vamos a desarrollar una plantilla completa que nos sirva de base para otros proyectos. Contendrá una cabecera, un pie y una barra lateral. No pretendemos desarrollar una plantilla supercompleja con funciones avanzadas, claro, pero sí una bastante completa que podamos usar por sí misma o como base para proyectos más complejos. Nuestro tema va a tener la mayor parte de los archivos habituales en los temas \"profesionales\". ¿Qué cuáles son esos archivos? Aquí tienes una lista con una breve explicación de cada uno: * **/images**. Carpeta con las imágenes de la plantilla. * **/js**. Carpeta con los archivos de JavaScript. * **style.css**. Hoja de estilos de la plantilla. *Obligatoria para que la plantilla funcione.* * **index.php**. Página principal. *Obligatoria para que la plantilla funcione.* * **screenshot.png**. Imagen en miniatura. Se verá en el dashboard de Wordpress (menú Apariencia -> Temas). * **favicon.ico**. La imagen que se verá en el navegador (o al guardar el sitio como un marcador). * **header.php**. Cabecera de la plantilla. * **sidebar.php**. Barra lateral de la plantilla. * **footer.php**. Pie de página de la plantilla. * **single.php**. Una entrada (post) individual. * **page.php**. Una página estática individual. * **category.php**. Página de resultados de una categoría. * **tag.php**. Página de resultados de una etiqueta. * **search.php**. Página de resultados de búsqueda. * **functions.php**. Funciones genéricas de nuestra plantilla (accesibles desde todos los archivos de la misma). Como es lógico, para crear una buena plantilla es fundamental que poseas un buen dominio de HTML y CSS. Si no, mejor dedícate a otra cosa (por ejemplo, a aprender HTML y CSS). En el resto de esta sección, vamos a construir nuestra plantilla en 11 sencillos pasos. Bueno, o no tan sencillos, eso ya lo decides tú... #### Paso 1: La hoja de estilos (style.css) El primer paso para construir una plantilla de Wordpress siempre es el archivo ***style.css*** (dentro de la carpeta \"mi-tema\"). Ese archivo debe abrirse con estas líneas de comentario para que Wordpress lo reconozca como la hoja de estilos de la plantilla y la información aparezca en *Apariencia -> Temas*: ```css /* Theme Name: Mitema Theme URI: el lugar donde vayas a alojar el tema para ponerlo a disposición de la comunidad Description: La descripción del tema Author: Tu nombre y apellidos Author URI: la web profesional del creador del tema Version: 1.0 */ ``` A partir de aquí, puedes escribir tu propio código de CSS como harías con cualquier otra página web. De momento, puedes dejarlo así e ir añadiendo reglas CSS más adelante. #### Paso 2: Imágenes y JavaScript (subdirectorios /images y /js) Para este *theme* vamos a utilizar dos pequeñas librerías Javascript: * ***Modernizr***, que sirve para detectar las capacidades de HTML5 y CSS3 del navegador (por si nos topamos con un navegador anticuado, cosa que es, lamentablemente, más frecuente de lo que pueda parecer). * ***Respond***, que sirve para que las versiones jurásicas de Internet Explorer sepa interpretar los media queries de CSS3. Te lo confieso: podríamos crear nuestra plantilla sin estas librerías, pero las usaremos de excusa para que veas cómo se integra una librería Javascript en una plantilla de Wordpress. Para alojar ese tipo de contenido adicionarl, vamos a **crear las carpetas *\"images\"* y *\"js\"*** dentro de la carpeta *\"mi-tema\"*. * En la carpeta *\"js\"* colocaremos una copia de las librerías Modernizr y Respond (¡siempre bajadas de la web del desarrollador, por favor!). * En la carpeta *\"images\"* colocaremos más adelante las imágenes que vayamos necesitando para nuestro CSS. ¡Ojo! Hay dos archivos de imagen obligatorios para todas las plantillas Wordpres, ***screenshot.png*** y el ***favicon.ico***, pero estos se deben ubicar en el directorio raíz del tema y no dentro de la carpeta *\"images\"*. Recuerda que Wordpress utiliza estos dos archivos para la previsualización del tema y para el icono de la página una vez que el tema se active. #### Paso 3: Crear la cabecera del tema y el menú de navegación (header.php) El archivo ***header.php*** contiene la cabecera de todas las páginas que se carguen con nuestro tema. Es el lugar donde suele ponerse el logo, el menú principal, un banner con imágenes o cualquier otra cosa que queramos que aparezca en la parte superior de todas las páginas del sitio web. Este es un código sencillito para empezar con header.php: ```html > \"> | /favicon.ico\" /> | \" /> | \" /> . ",
    "url": "/docs/dwes/_site/cms/wordpress.html",
    "relUrl": "/cms/wordpress.html"
  }
}
