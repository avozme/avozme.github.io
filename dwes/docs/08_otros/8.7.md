---
layout: page
title: 8.7 NodeJS
permalink: /otros/nodejs.html
parent: 8 Otras tecnologías
grand_parent: Desarrollo Web en Entorno Servidor
nav_order: 7
has_children: false
---

## 8.7. Node.js

<div style='color:red'><strong>ATENCIÓN: esta sección aún está en construcción.</strong></div>

**Node.js** no es un lenguaje de programación, sino un entorno de ejecución en el lado del servidor (aunque puede funcionar en otros entornos) basado en el lenguaje **Javascript**.

Por lo tanto, al contrario que el código Javascript convencional, Node.js ejecuta Javascript en el servidor. De este modo, pueden unificarse los lenguajes del lado del cliente y del servidor. Esa es una de las razones que explica el rápido crecimiento que Node.js está experimentando en los últimos años.

Vamos a ver una introducción muy breve a Node.js. Ten en cuenta que, además, Node.js no suele usarse de forma independiente para desarrollar aplicaciones web, sino en conjunción con algún framework como **Express**.

### 8.7.1. Características del lenguaje Node.js

Fecha de aparición: 2009

Perspectivas: 

* Uso y popularidad creciente.
* Posibilidad de convertirse en un estándar de desarrollo web *fullstack*.
* Buena relación señal/ruido.
* Node.js tiene problemas que resolver si quiere imponerse como estándar: la API cambia continuamente y no es compatible hacia atrás, la librería estándar de Javascript es minúscula comparada con otros lenguajes y las librerías de terceros son a veces poco probadas, cambiantes o directamente inexistentes para hacer ciertas cosas que en otras plataformas se dan por supuestas.

Filosofía:

* Usa el motor de JavaScript V8 de Chrome *fuera del navegador* para ejecutarse en el servidor.
* Las operaciones de E/S son *sin bloqueo*, esto es, *asíncronas*.
* El fluje de ejecución no es lineal, sino *dirigido por eventos*, como ocurre casi siempre en las aplicaciones web. Esto mejora el rendimiento, porque el programa está casi todo el tiempo ocioso, a la espera de que ocurra algún evento.
* Tiene acceso nativo a bases de datos documentales como *MongoDB*.
* Las aplicaciones altamente escalables.
* Simplicidad y modularidad.
* Gestor **npm** para librerías de terceros.

### 8.7.2. Configuración necesaria en el servidor

Node.js **incluye su propio servidor web**. Recuerda que Node.js *no* es un lenguaje de programación, sino una plataforma de desarrollo en el lado del servidor completa.

Así que, para lanzar un servidor web con Node.js, lo único que debemos instalar en el servidor es el propio Node.js.

Una vez hecho esto, podemos crear un servidor HTTP básico creando un programa Javascript como este:

```javascript
var http = require('http');
http.createServer(function (peticion, respuesta) 
	// Aquí se escribe la respuesta del servidor
).listen(9000, '127.0.0.1'); // Puerto e IP donde escuchará el servidor
```

Luego bastará con ejecutar este programa en el servidor desde una consola de comandos:

```
$ node nombre-del-archivo.js
```

### 8.7.3. Sintaxis básica de Node.js

El lenguaje de programación que usa Node.js es Javascript, así que hay poco que decir sobre la sintaxis de las estructuras de control, las asignaciones o los operadores, puesto que ya la conoces.

### 8.7.4. Entrada / Salida con Node.js

La entrada y salida en un entorno Node.js es lo que más se diferencia del Javascript que manejas habitualmente, puesto que ahora estamos trabajando en un servidor, no en un navegador web.

La salida mediante **console.log()** puede seguir usándose, pero no es lo habitual en aplicaciones web, puesto que esa salida se producirá en la consola de texto del servidor. Para la entrada, existe la función **openStdin()**, que crea un objeto sobre el que se puede agregar un evento de entrada de datos, como en este ejemplo:

```javascript
console.log("Escribe tu nombre");
var stdin = process.openStdin();

stdin.addListener("data", function(entradaPorTeclado) {
    console.log("Tu nombre es: " + entradaPorTeclado.toString());
});
```

Aquí se puede ver **qué significa que Node.js sea un entorno de ejecución dirigido por eventos**: en lugar de lanzar la lectura por teclado y dejar al programa esperando hasta que esa lectura por teclado se produzca, lo que hacemos es asignar un **manejador de evento** o **listener** que se ejecutará cuando ocurra cierto evento asociado.

En este ejemplo, asociamos un *listener* al objeto *stdin*. Cuando ocurra el evento (en este caso, el evento se llama "data", que significa "recepción de datos" en el objeto *stdin*), se ejecutará el código de la función. Mientras tanto, el programa continuará con su ejecución normal, atendiendo a cualquier otro evento que pudiera producirse y que esté programado para atender.

Sin embargo, en una aplicación web, raramente se hace la entrada y salida por consola, ¿verdad? **La entrada debería hacerse desde un formulario web, mientras que la salida debería ser una respuesta HTTP**.

Te muestro cómo se hace esto con Node.js con otro ejemplo:

```javascript
var http = require('http');
var datos_del_post;
http.createServer(function(peticion, respuesta) {
   if(peticion.method == 'POST'){
      var datos_del_post = '';
      peticion.on('data', function(trozo_de_datos){
         datos_del_post += trozo_de_datos;
      });
      peticion.on('end', function(){
         var datos_del_post = querystring.parse(datos_del_post);
         respuesta.writeHead(200, {'Content-Type': 'text/html'});
         respuesta.write("He recibido correctamente el formulario");
         respuesta.write("Estos son los datos que me han llegado:");
         respuesta.write("Nombre: " + datos_del_post.name + ". Email = " + datos_del_post.email);
         frespuesta.end();
      });
   }else{
      respuesta.writeHead(200, {'Content-Type': 'text/html'});
      respuesta.end("No he ha llegado ningún dato por POST");
   }
}).listen(9000, '127.0.0.1');
```

Si observas este código, verás que tiene la misma estructura que el que vimos en el apartado "Configuración necesaria en el servidor", solo que hemos rellenado la función principal con más cosas.

Esa función tiene dos argumentos, ***petición*** y ***respuesta***:

* En ***petición***, el servidor coloca todos los datos de la petición que proviene del cliente. La información del formulario estará aquí, por lo tanto.
* En ***respuesta***, el servidor colocará todos los datos de la respuesta HTTP que va a enviar al cliente.

Fíjate cómo en el código, en primer lugar, miramos si la petición del cliente nos llegó por POST. Si es así, creamos dos manejadores de eventos:

* El manejador **"data"** se ejecutará cuando llegue un nuevo fragmento de información por POST.
* El manejador **"end"** se ejecutará cuando haya terminado de recibirse información desde el cliente.

Por eso, en el manejador "data" nos limitamos a ir encadenando los datos que llegan por POST en la variable *datos_del_post*, y es en el manejador "end" cuando los procesamos. Observa cómo en ese manejador generamos la respuesta HTTP mediante el método ***write()***. La respuesta se envía al cliente cuando se ejecuta el método ***end()***. 

### 8.7.5. Bibliotecas, funciones y clases

TODO XXX

### 8.7.6. Ejemplo 1 en Node.js: Hola mundo

```javascript
var http = require('http');

http.createServer(function (req, res) 
	// Cabecera http. No es imprescindible, pero sí recomendable.
	// Recuerda que el código 200 significa "OK" en el protocolo http/https.
	// El 'Content-type' más habitual es 'text/html' o 'application/json'. 
	res.writeHead(200, 'Content-Type': 'text/html'); 
	res.write('Hola, mundo!'); 
	res.end();
).listen(9000); // Puerto donde el servidor escuchará
```

### 8.7.7. Ejemplo 2 en Node.js: login con comprobación de email por Ajax

TODO XXX