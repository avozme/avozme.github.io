---
layout: page
title: 2.16 CRUD desarrollado con Laravel
permalink: /laravel/crud-con-laravel.html
nav_order: 17
has_children: false
parent: 2 Laravel
grand_parent: Desarrollo web full stack
---

## 2.16. CRUD desarrollado con Laravel: un ejemplo completo
{: .no_toc }

- TOC
{:toc}

Para finalizar esta introducción (sí, sí: aunque haya sido muy largo, no es más que una introducción) a Laravel, vamos a **desarrollar una pequeña aplicación web desde cero**.

Se tratará, en realidad, de un fragmento de otra aplicación más grande: una tienda online o tal vez un sistema de gestión de almacén. Da lo mismo. Nosotros vamos a desarrollar la parte de **mantenimiento de productos**.

Para ello, supondremos que en la base de datos existe una tabla llamada *products* con los campos *id, name, description* y *price*.

Vamos a construir el controlador, el modelo y las vistas necesarias para hacer el **CRUD completo** (create-read-update-delete) de esta tabla con Laravel, sin olvidarnos de las migraciones, los seeders y, por supuesto, el enrutador.

¿Estás preparado/a? Pues vamos allá.

### Migraciones

Para esta miniaplicación solo necesitamos una migración, puesto que solo tenemos que crear una tabla.

La migración se crea con el comando ```php artisan make:migration create_table_products``` y se escribe en el archivo ***/database/migrations/_timestamp_create_products_table.php***, que tendrá este contenido:

```php
<?php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

class CreateProductsTable extends Migration
{
    public function up(): void
    {
        Schema::create('products', function (Blueprint $table): void {
            $table->id();
            $table->string('name', 100);
            $table->text('description');             // usa text para textos largos y string(n) para cortos
            $table->decimal('price', 10, 2);         // 10 dígitos enteros y 2 decimales para el precio
            $table->timestamps();
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('products');
    }
};
```

### Seeders

En este *seeder* vamos a cargar unos cuantos datos de prueba. Obviamente, puedes cambiarlos por los que tú quieras.

El seeder se crea con el comando ```php artisan make:seeder ProductsTableSeeder```, que generará el archivo ***/database/seeders/ProductTableSeeder.php***.

Recuerda que, para poder lanzar el seeder automáticamente con ```php artisan migrate:fresh --seed``` u otro comando similar, tienes que editar el archivo *DatabaseSeeder.php* y añadir la línea ```$this->call([ProductsTableSeeder::class]);``` al método *run()*.

En cualquier caso, siempre puedes lanzar el *seeder* manualmente en cualquier momento con ```php artisan db:seed --class=ProductsTableSeeder```.

Un posible código fuente para este *seeder* podría ser este, que genera 200 productos aleatorios y realistas:

```php
<?php

namespace Database\Seeders;

use Illuminate\Database\Seeder;
use Illuminate\Support\Facades\DB;
use Faker\Factory as Faker;

class ProductsTableSeeder extends Seeder
{
    public function run(): void
    {
        $faker = Faker::create();

        for ($i = 0; $i < 200; $i++) {
            DB::table('products')->insert([
                'name'        => $faker->words(3, true), // 3 palabras unidas en un string
                'description' => $faker->sentence(10),   // frase de 10 palabras
                'price'       => $faker->randomFloat(2, 1, 999), // 2 decimales, entre 1 y 999
                'created_at'  => now(),
                'updated_at'  => now(),
            ]);
        }
    }
}

```

### Enrutador

El enrutador de la aplicación está en ***/routes/web.php***. 

Basta con abrirlo y añadir esta línea:

```php
Route::resource('products', 'ProductController');
```

Alternativamente, podrías crear a mano las siete entradas correspondientes a las **siete rutas de un servidor REST**, así:

```php
Route::get('product', 'ProductController@index')->name('product.index');
Route::get('product/{product}', 'ProductController@show')->name('product.show');
Route::get('product/create', 'ProductController@create')->name('product.create');
Route::post('product/{product}', 'ProductController@store')->name('product.store');
Route::get('product/{product}/edit', 'ProductController@edit')->name('product.edit');
Route::patch('product/{product}', 'ProductController@update')->name('product.update');
Route::delete('product/{product}', 'ProductController@destroy')->name('product.destroy');
```

*NOTA: veremos en el tema siguiente qué es eso del servidor REST.*

El resultado sería el mismo, pero si defines manualmente las rutas, tienes más control sobre cómo son exactamente. Por ejemplo, puedes traducirlas a español (¿qué tal cambiar "product/create" por "producto/crear"?). 

O podrías hacer algún cambio más profundo a nivel técnico. Por ejemplo, que la petición para hacer *delete* llegue por GET en lugar de por DELETE (así no tendrías que usar un botón de formulario para lanzar el borrado de un producto y podrías lanzarlo con un link).

Eso sí: ten en cuenta que, si haces algún cambio de este tipo en las rutas, tu servidor ya no será 100% REST. 

Hay una posibilidad intermedia: respetar las 7 rutas estándar REST y *añadir* alguna adicional que te venga bien, como el borrado mediante GET. Algo así:

```php
use App\Http\Controllers\ProductController;

// Estas son las 7 rutas estándar REST:
Route::resource('products', ProductController::class);
// Añadimos una ruta NO ESTÁNDAR para borrar productos mediante GET
Route::get('product/delete/{product}', [ProductController::class, 'destroy'])
     ->name('product.myDestroy');
```

### Controlador

El controlador de productos se crea con el comando ```php artisan make:controller ProductController```.

El archivo se generará en ***/app/Http/Controllers/ProductController.php***. Tendrás que rellenar el código de los 7 métodos REST con algo como esto::

```php
<?php
namespace App\Http\Controllers;

use App\Models\Product;
use Illuminate\Http\Request;

class ProductController extends Controller
{
    public function index()
    {
        $productList = Product::all();
        return view('product.all', compact('productList'));
    }

    public function show(Product $product)
    {
        return view('product.show', compact('product'));
    }

    public function create()
    {
        return view('product.form');
    }

    public function store(Request $request)
    {
        // Antes de guardar el producto en la BD, comprobamos que los datos sean correctos
        $request->validate([
            'name' => 'required|string|max:100',
            'description' => 'nullable|string',
            'price' => 'required|numeric|min:0',
        ]);

        Product::create($request->only(['name','description','price']));

        return redirect()->route('products.index');
    }

    public function edit(Product $product)
    {
        return view('product.form', compact('product'));
    }

    public function update(Request $request, Product $product)
    {
        // Antes de actualizar el producto en la BD, comprobamos que los datos sean correctos
        $request->validate([
            'name' => 'required|string|max:100',
            'description' => 'nullable|string',
            'price' => 'required|numeric|min:0',
        ]);

        $product->update($request->only(['name','description','price']));

        return redirect()->route('products.index');
    }

    public function destroy(Product $product)
    {
        $product->delete();
        return redirect()->route('products.index');
    }
}
```

No obstante, te he propuesto el código en formato de Laravel 11 y anteriores para que veas cómo se busca el producto con el método ***find()*** de Eloquent.

### Modelo

El modelo se crea con el comando ```php artisan make:model Product```.

El archivo con el modelo se generará en ***app/models/product.php***.

No es necesario que toques este archivo: puedes dejarlo, de momento, tal y como lo ha generado Artisan.

### Vista: plantilla principal

La plantilla principal o *master layout* debes crearla en ***views/layouts/master.blade.php***.

Por supuesto, puedes hacerla como quieras. Aquí te propongo un *master layout* muy sencillito al que luego le podrás ir añadiendo cosas fácilmente:

```html
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <meta name="csrf-token" content="{% raw %}{{ csrf_token() }}{% endraw %}">
    <title>@yield('title')</title>
    @vite(['resources/css/app.css', 'resources/js/app.js'])
</head>
<body>
    <aside>
        @yield('sidebar', 'Este es mi master sidebar.')
    </aside>

    <main class="container">
        @yield('content')
    </main>
</body>
</html>
```

### Vista: todos los productos

La vista con todos los productos la llamaremos ***views/products/all.blade.php*** y puede tener un aspecto como este:

```html
{% raw %}
<table border="1">
  <thead>
    <tr>
      <th>Nombre</th>
      <th>Descripción</th>
      <th>Precio</th>
      <th colspan="2">Acciones</th>
    </tr>
  </thead>
  <tbody>
    @foreach ($productList as $product)
      <tr>
        <td>{{ $product->name }}</td>
        <td>{{ $product->description }}</td>
        <td>{{ $product->price }}</td>
        <td><a href="{{ route('products.edit', $product->id) }}">Modificar</a></td>
        <td>
          <form action="{{ route('products.destroy', $product->id) }}" method="POST">
            @csrf
            @method('DELETE')
            <input type="submit" value="Borrar">
          </form>
        </td>
      </tr>
    @endforeach
  </tbody>
</table>
{% endraw %}
```

### Vista: creación/modificación de productos

Reutilizaremos la vista para crear y modificar productos, puesto que son prácticamente iguales.

El archivo de la vista será ***views/products/form.blade.php***, y su contenido puede ser algo así:

```html
{% raw %}
@extends('layouts.master')

@section('title', isset($product) ? 'Editar producto' : 'Nuevo producto')

@section('content')
@if ($errors->any())
    <div class="alert alert-danger">
        <ul>
            @foreach ($errors->all() as $error)
                <li>{{ $error }}</li>
            @endforeach
        </ul>
    </div>
@endif

<form action="{{ isset($product) ? route('products.update', $product) : route('products.store') }}" method="POST">
    @csrf
    @isset($product) @method('PUT') @endisset

    <label for="name">Nombre del producto:</label>
    <input type="text" id="name" name="name" value="{{ old('name', $product->name ?? '') }}"><br>

    <label for="description">Descripción:</label>
    <input type="text" id="description" name="description" value="{{ old('description', $product->description ?? '') }}"><br>

    <label for="price">Precio:</label>
    <input type="number" step="0.01" id="price" name="price" value="{{ old('price', $product->price ?? '') }}"><br>

    <input type="submit" value="{{ isset($product) ? 'Actualizar' : 'Crear' }}">
</form>
@endsection
{% endraw %}
```

Observa cómo se genera una cabecera de formulario distinta según se vaya a usar el formulario para crear o para modificar un producto. Asímismo, fíjate en cómo se rellenan los atributos *value* de los campos del formulario con los datos actuales del producto (en caso de que existan).

### ¿Y ahora qué?

Ahora ha llegado el momento de comprobar si tu aplicación funciona.

Primero, lanza las migraciones y los seeders con ```php artisan migrate:fresh --seed```. Asegúrate de haber añadido tu seeder de productos a *DatabaseSeeder.php* para que se lance automáticamente tras las migraciones. Si todo va bien, la aplicación estará lista para responder en **https://tu-servidor-local/products**

El código que hemos mostrado hasta aquí solo es un pequeño ejemplo y se puede mejorar de muchísimas maneras, por supuesto. Estas son algunas mejoras evidentes:

* Programar la vista ***products/show.blade.php***, que está ausente en el código anterior. Esa es la vista que mostrará un producto individual. Si intentas lanzarla ahora pidiendo la ruta *https://tu-servidor/products/1* (sustituye 1 por el ID de cualquier producto), verás que Laravel te da un error de "View not found".
* Se puede alterar el aspecto visual de la aplicación trabajando el *master layout* y añadiendo algo de CSS y/o Javascript, sin que haya que tocar el resto de vistas.
* A partir de ahí, habría que seguir construyendo la aplicación, añadiendo más tablas con su correspondientes controladores, modelos y vistas. Llegará un momento en el que tendremos que crear las relaciones entre las tablas en los modelos, como explicamos en el apartado dedicado a Eloquent.
* Otro paso lógico, común a muchas aplicaciones web, sería añadir un sistema de autenticación con **Laravel Breeze**.

Utiliza este código fuente como punto de partida para tus propios desarrollos con Laravel. Cuando hayas cogido un poco de práctica, verás que resulta mucho más rápido montar una aplicación web convencional con Laravel que hacerlo con PHP clásico.