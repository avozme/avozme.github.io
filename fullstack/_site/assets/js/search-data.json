{"0": {
    "doc": "1.1 Frontend vs backend vs full stack",
    "title": "1.1. Programación cliente-servidor",
    "content": ". | 1.1.1. Un poco de jerga informática | 1.1.2. Una petición web 1.0 | 1.1.3. Una petición web 2.0 | 1.1.4. Desarrollo web clásico (años 2000-2010) | 1.1.5. La revolución SPA (años 2010-2020) | 1.1.6. Retorno al full stack simplificado (2020-actualidad) | . En los primeros tiempos de Internet, no se ejecutaban programas en el servidor. Solo se pedían páginas estáticas (escritas en HTML) más o menos elaboradas que había sido guardadas en el servidor por un administrador de sistemas. A esto se le denominó web 1.0. A alguien se le ocurrió la idea de que los propios visitantes podrían también crear contenido. Ese contenido se guardaría en el servidor (en archivos o en una base de datos) y posteriormente podría recuperarse para generar con él páginas dinámicas, generadas sobre la marcha. Es decir, documentos HTML que no existieran previamente y que nadie, en realidad, hubiera tecleado, sino que se creasen a partir del contenido almacenado en esos archivos o esa base de datos. Esa web dinámica estaría generada por un programa ejecutado en el servidor, un programa cuya salida sería HTML válido, comprensible por el navegador que la reciba. A esto se le denominó web 2.0 y supuso una revolución tan grande como el propio nacimiento de Internet. 1.1.1. Un poco de jerga informática . Antes de continuar, tienes que asegurarte de que comprendes bien el significado de algunos términos básicos: . | Un servidor es un programa que se ejecuta en una máquina conectada a una red y que permanece dormido hasta que una petición procedente de la red lo despierta. Entonces, el programa hace algo (consulta datos, elabora un cálculo, lo que sea) y devuelve su resultado por la red. Por extensión, un servidor también es cualquier ordenador donde se ejecute un programa servidor. Es decir, usamos la misma palabra para referirnos a un programa y al ordenador donde se ejecuta ese programa. Mala idea, ya lo sé, pero es lo que hay. | El cliente es un programa que envía peticiones al servidor para despertarlo. También es el programa que recoge el resultado devuelto por el servidor. ¿Y sabes qué? Que, por extensión, la máquina donde se ejecuta un programa cliente también se llama cliente. | . Pues bien, en programación web, nuestro cliente es el navegador web (también llamado cliente web). Cualquier navegador del universo conocido entra en esta categoría. Excepto, tal vez, Internet Explorer (sí, esto es un chiste informático). Y un servidor es cualquier máquina de la red donde se esté ejecutando un programa servidor web como Apache, Nginx, Tomcat, IIS y otros cuando viejos amigos que irás conociendo a lo largo de este curso. 1.1.2. Una petición web 1.0 . Ahora que tienes claro qué es un servidor y un cliente web, puedes comprender el siguiente esquema. En él, se ilustra lo que ocurre cuando un cliente web (recuerda: tu navegador) envía al servidor la petición de una página estática. El servidor, en este caso, se limita a enviar al cliente el documento HTML tal cual está almacenado en su disco duro, sin cambiar una sola coma. 1.1.3. Una petición web 2.0 . Con la web 2.0 la cosa cambia bastante porque aparecen las páginas dinámicas, aunque tendrás que fijarte bien en el esquema para apreciar la diferencia. Quédate con lo importante: en este esquema, el cliente web no pide un documento HTML, sino un programa, que puede estar escrito en PHP o algún otro lenguaje. Eso es lo de menos. Ese programa se ejecuta en el servidor, y el resultado de esa ejecución es lo que recibe el cliente, no el programa en sí. Pues bien: si un sitio web funciona del primer modo, no es una aplicación web, sino una página web estática. Para que sea considerado una aplicación web, debe funcionar del segundo modo. 1.1.4. Desarrollo web clásico (años 2000-2010) . Cuando comenzaron a crearse las primeras aplicaciones web siguiendo el esquema cliente-servidor anterior, se usaron los lenguajes que en ese momento estaban disponibles en los servidores web (que, en su mayoría, como en la actualidad, estaban basados en Unix/Linux). Por eso las primeras aplicaciones se programaron en lenguajes como Perl, PHP, Python, Java (JSP) o Visual Basic (con ASP.NET). Con el tiempo, algunos de esos lenguaje evolucionaron y se adaptaron a los nuevos tiempos, por lo que han seguido usándose (como PHP, Java o Python), mientras que otros se quedaron desfasados (como Perl). En estas aplicaciones, el servidor contenía toda la lógica del programa y generaba una salida llamada “vista” o “view” que se podía visualizar en un navegador web, puesto que estaba codificada como HTML. Esta salida podía incluir CSS para mejorar la visualización y algo de Javascript para dinamizar la vista, pero poco más. Poco después surgieron los primeros frameworks MVC como Symfony (para PHP), Ruby on Rails (para Ruby) o Django (para Python). Estos frameworks eran librerías que facilitaban el desarrollo web y automatizaban muchas tareas comunes. 1.1.5. La revolución SPA (años 2010-2020) . A finales de la década del 2000 aparecieron las aplicaciones SPA (Sigle Page Application), también llamadas OVA (One View Application). Se caracterizaban porque, cuando el usuario hacia algo en la página, esta no se recargaba completamente, sino que solo se modificaba una parte. Esto fue posible gracias a que Javascript desarrolló la tecnología Ajax o de peticiones asíncronas, capaz de pedir datos al servidor en segundo plano, es decir, mientras el navegador continuaba funcionando. El usuario no se daba cuenta de que el navegador estaba solicitando datos al servidor ni de que el servidor estaba respondiendo. El resultado fueron aplicaciones web mucho más dinámicas e interactivas que las que se habían visto hasta entonces, puesto que la página no tenía que recargarse (es decir, pedirse de nuevo al servidor) continuamente. Muy pronto, todo el mundo quiso tener su propia aplicación SPA, pero esto planteaba un desafío a los desarrolladores: las aplicaciones SPA son mucho más difíciles de escribir que las aplicaciones web tradicionales, puesto que la lógica del programa está repartida de forma bastante caótica entre el cliente y el servidor. De repente, Javascript había dejado de ser un “juguete” y se encontraba gestionando gran parte de la lógica de las aplicaciones, mientras que los lenguajes más maduros y consistentes, como PHP o Java, se limitaban a implementar una API que consultaba la base de datos y devolvía los resultados como JSON o XML al cliente; es decir, ya no producían vistas complejas en HTML. Por eso aparecieron frameworks para Javascript como Angular, en primer lugar, y más tarde React, Vue o Svelte. Estos frameworks facilitaban la tarea del desarrollo en el lado del cliente. Para complicar aún más la cosa, en el lado del servidor también hubo una explosión de frameworks fuertemente incompatibles entre sí. Cada lenguaje tenía uno o varios frameworks para elegir (PHP tenía Laravel, Symfony o Zend; Python tenía Django, Flask o FastAPI; Java tenía Spring Boot o Jakarta; etc.) . El resultado de esta explosión de nuevas tecnologías fue que los desarrolladores web no podían especializarse en todas y, en la práctica, el mercado laboral acabó por dividirse en dos categorías: . | Los desarrolladores frontend, que trabajaban con Javascript y uno o varios de sus frameworks (Angular, sobre todo) | Los desarrolladores backend, que trabajaban con los lenguajes de servidor y algunos de sus frameworks (PHP con Laravel, sobre todo). | . También existía el perfil de desarrollador full stack, que era una persona que conocía las tecnologías del frontend y del backend, pero no se esperaba que realmente las controlase en profundidad. 1.1.6. Retorno al full stack simplificado (2020-actualidad) . La solución de construir cada aplicación web como si fueran dos proyectos casi independientes (SPA en el fronend y API en el backend) es demasiado compleja para muchos desarrollos. Esto ha sido un secreto a voces en la industria durante años. La solución apareció a principios de esta década, cuando comenzaron a surgir frameworks híbridos que integran frontend y backend, como Next.js, y simplifican en desarrollo. El front y el back ya no son dos mundos separados en cada proyecto, sino que todo vuelve a conformar una única aplicación. Además de frameworks nuevos como Next.js, basado en Node, algunos frameworks clásicos han sabido reinventarse como híbridos: . | Laravel con Inertia o con Livewire | Django con HTMX | Ruby on Rails con Hotwire | . Con estas soluciones, la lógica de la aplicación regresa al servidor, con lo que todo el sistema es más fácil de construir y de mantener, pero seguimos teniendo una SPA en el cliente, lo que hace que la experiencia del usuario no se resienta. Se unen así las ventajas de los dos mundos. Aunque siguen existiendo desarrolladores frontend y desarrolladores backend, el perfil de desarrollador full stack está teniendo un gran crecimiento gracias a estos nuevos frameworks. ",
    "url": "https://iescelia.org/docs/fullstack/_site/php/frontend-backend-fullstack.html#11-programaci%C3%B3n-cliente-servidor",
    "relUrl": "/php/frontend-backend-fullstack.html#11-programación-cliente-servidor"
  },"1": {
    "doc": "1.1 Frontend vs backend vs full stack",
    "title": "1.1 Frontend vs backend vs full stack",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/php/frontend-backend-fullstack.html",
    "relUrl": "/php/frontend-backend-fullstack.html"
  },"2": {
    "doc": "1.2 Caja de herramientas",
    "title": "1.2. Caja de herramientas para desarrollar de aplicaciones web con PHP",
    "content": ". | 1.2.1. HTML | 1.2.3. CSS | 1.2.4. Javascript | 1.2.5. PHP | 1.2.6. MariaDB o MySQL | 1.2.7. Montaje del servidor | . Para desarrollar apliaciones web necesitamos una caja de herramientas bastante completa. Algunas herramientas son fundamentales y genéricas, como el martillo o el destornillador. Otras, en cambio, son optativas y más específicas, y dependerán del trabajo que vayamos a realizar y de nuestras propias preferencias como desarrolladores. En esta sección vamos a hacer un repaso de las herramientas fundamentales (el martillo y el destornillador) que necesitaremos para sacar adelante este módulo. Algunas ya las conoces y otras las aprenderemos a manejar enseguida. En los siguientes temas nos dedicaremos a las herramientas más específicas y avanzadas. Nuestras herramientas fundamentales son estas: . | HTML, CSS y Javascript (y un navegador web) | PHP (en un servidor web con soporte para este lenguaje) | MySQL / MariaDB (y el correspondiente servidor de bases de datos) | . 1.2.1. HTML . HTML, como ya sabrás, significa “HyperText Markup Language” (Lenguaje de Etiquetas de Hipertexto), y no es un lenguaje de programación, sino un lenguaje para estructurar documentos de hipertexto. A lo largo de este curso supondremos que ya estás familiarizado con HTML. Tampoco es que necesites un nivel profesional para entenderlo todo, pero conocerlo con cierta profundidad te ayudará. Y, desde luego, si no conoces HTML en absoluto, no comprenderás nada de lo que ocurra a partir de ahora. Por lo tanto, si has olvidado todo el HTML que aprendiste, es mejor que pares aquí y lo repases un poco antes de continuar. Recuerda que HTML NO es un lenguaje de programación: no permite programar algoritmos. Pero sí permite incrustar otros lenguajes de programación en su interior, como enseguida veremos. Esos trozos de código incrustados dentro de HTML se denominan scripts. Brevísima historia de HTML . | En 1991 se crea HTML (procedente de un lenguaje anterior, SGML) junto con la World Wide Web, para formatear los documentos de la www. Aquella primera versión apenas tenía 20 tags. | Se amplía en sucesivas versiones hasta la 3.0, que no consiguió éxito debido a las limitaciones de los navegadores de la época. | Comienza la guerra de navegadores: Microsoft y Netscape sacan sus propios “dialectos” de HTML y destrozan en estándar. | A partir de HTML 4, los navegadores intentan unir las características de los dos, pero el resultado es demasiado confuso y complejo. Se introduce CSS. | En 1999 aparece HTML 4.1, que fue el estándar dominante durante muchos años. | En 2000 se define el estándar XHTML, la versión XML de HTML, mucho mejor estructurado y con menos añadidos pero igual de potente. Fracasa porque es demasiado estricto. | En 2014 HTML5 se convierte en el estándar de facto. | En la actualidad, HTML ya no lanza nuevas versiones, sino que se actualiza continuamente (living standard). | . 1.2.3. CSS . CSS significa “Cascade Style Sheet” (Hojas de estilo en cascada). CSS, como sin duda ya sabes, es un lenguaje para la definición de los formatos utilizados en una página web. Sólo permite definir el formato (es decir, el aspecto: colores, tipografías, disposición de los elementos…) de la página, no su contenido. Al definir los formatos en otra parte, se pueden reutilizar a lo largo de una o incluso de varias páginas: si cambiamos la definición CSS del formato, se cambian automáticamente los formatos de todas las páginas que usen esa definición. El objetivo último de CSS es separar completamente el formato de la página de su contenido. CSS1 apareció ya en 1996. CSS2 se usó con HTML 4 durante años. CSS3 llegó HTML5. En la actualidad, CSS es un living standard, como HTML, es decir, no se sacan nuevas versiones sino que se actualiza continuamente. Todos los navegadores van incorporando esas revisiones en sus propias actualizaciones. CSS está soportado universalmente, aunque los diferentes navegadores pueden interpretar de forma ligeramente distinta algunas definiciones CSS. Como ocurre con HTML, si tienes un poco oxidado tu CSS sería conveniente que lo repasaras antes de continuar. Tampoco es necesario que seas un experto/a en CSS: con que comprendas su sintaxis básica es suficiente. El resto puedes consultarlo conforme lo necesites e irás mejorando con el tiempo y la experiencia. 1.2.4. Javascript . JavaScript es un lenguaje interpretado que puede ser incrustado dentro del código HTML de una página web. El código JavaScript puede interactuar y modificar cualquier parte del documento HTML, por lo que dota a las páginas web de dinamismo e interactividad. JavaScript no es Java, por mucho que su nombre se parezca. También su sintaxis puede recordar un poco a Java en algunas ocasiones. Pero déjame que te lo repita de nuevo: Javascript no es Java. Se parecen tanto como un euro y un yen japonés. Las dos son monedas de curso legal, pero ahí terminan sus semejanzas. La implementación de JavaScript de cada navegador es distinta, obteniéndose resultados que no siempre son iguales, por desgracia para los desarrolladores. Por ejemplo, el motor Javascript de Chrome se llama V8, mientras que el de Firefox es Rhino y el de Safari y Microsoft Edge es WebKit. Nuevamente, si no sabes nada de Javascript, debes detenerte aquí y aprender los fundamentos antes de continuar, o te perderás una parte importante de lo que sigue. Y, nuevamente, no es necesario que te conviertas en un fuera de serie del lenguaje. De momento, basta con que lo comprendas y hayas hecho unas cuantas prácticas con él. Irás mejorando con la experiencia. Javascript nació en 1995 como un pequeño intérprete incrustado dentro del navegador Netscape para conseguir cierta interactividad en las webs, que hasta entonces eran totalmente estáticas. En 1997 se estandarizó como ECMAScript (ES1). Fue evolucionando con altibajos hasta llegar a la ECMAScript 6 (ES6) del año 2015, que supuso una auténtica revolución y convirtió a Javascript en el monstruo todoterreno que es hoy. Desde entonces, se saca una nueva versión del estándar cada año (ES2016, ES2017, etc) con mejoras sucesivas. Por último, ten en cuenta que son muy pocos los desarrollos que, en la actualidad, se hacen directamente con Javascript en el lado del cliente. Lo más habitual es utilizar librerías más o menos simples, o enormes frameworks, que ocultan el Javascript que existe debajo. Algunas de las librerías más populares son: jQuery (ya anticuada), Angular, Vue.js, React o Svelte. 1.2.5. PHP . PHP es un acrónimo recursivo. Significa “PHP Hypertext Preprocessor”. Sí, así es el sentido del humor de los informáticos. Qué le vamos a hacer. PHP es un lenguaje de programación de propósito general. De hecho, junto con librerías como PHP-Qt o PHP-GTK, puedes programar con él cualquier aplicación de escritorio con sus ventanitas, sus botoncitos y toda la parafernalia. Pero, por circunstancias más debidas al azar que a otra cosa, se empezó a usar para desarrollo web al comienzo de la web 2.0, y hoy en día se utiliza casi exclusivamente para ese propósito. Que es el propósito que a nosotros nos interesa, claro. Cuando se usa en desarrollo web, PHP aparece embebido dentro de documentos HTML. Enseguida veremos cómo se hace eso. Igual que sucedía con Javascript, pocos proyectos nuevos se desarrollan con PHP clásico. Lo normal es usar un framework (o colección compleja de librerías) que ocultan en todo o en parte el funcionamiento de PHP, que sigue corriendo debajo. Por supuesto, cualquier desarrollador/a web debe conocer tanto PHP como el funcionamiento de los frameworks que corren sobre PHP. Nosotros nos centraremos primero en PHP clásico, y más adelante veremos los frameworks para PHP, centrándonos en uno de los más populares y potentes que existen en la actualidad: Laravel. Características de PHP . | PHP permite conectarse con múltiples bases de datos: MySQL, MariaDB, Oracle, PostgreSQL, SQL Server, DB2, etc. También puede conectar por ODBC. | Es un lenguaje multiparadigma (procedimental, orientado a objetos y, en menor medida, funcional). Se parece mucho a otros lenguajes de tercera generación y orientados a objeto (en particular a C/C++ y, por tanto, a Java). Su curva de aprendizaje para los que ya saben programar es muy plana. | Es un lenguaje con tipado dinámico y débil. Es decir, los tipos de datos se asignan en tiempo de ejecución y pueden mezclarse tipos de datos con bastante libertad. Esto tiene ventajas e inconvenientes que descubrirás en tus carnes cuando empieces a programar con PHP. | Es un lenguaje tremendamente flexible. Casi todo se puede hacer de tres o cuatro formas diferentes. Eso le permite adaptarse a los gustos personales de cada programador/a. | . Brevísima historia de PHP . | Surge en 1994 como un proyecto personal de su creador, Rasmus Lerdorf, para automatizar ciertas tareas de su web personal. | PHP3 (1998), con un motor totalmente reescrito, tuvo un gran éxito comercial. | PHP4 (2000) supuso la eclosión de PHP como lenguaje del lado del servidor. Muchos scripts en PHP que circulan por la red están escritos en esta versión obsoleta, así que debes aprender a reconocerla para evitarla. | PHP5 (2004) tiene soporte para orientación a objetos y una biblioteca de clases bastante bien diseñada. Por lo tanto, desde esta versión PHP pasa de ser un lenguaje estructurado (3GL) a ser un lenguaje orientado a objetos. PHP5 dominó el mercado durante una década. | PHP6 empezó a desarrollarse en 2007 y se canceló en 2014. | PHP7 (2015) supuso una gran mejora en el rendimiento e introdujo otras novedades, como el tipado (opcional). Se considera un renacimiento del lenguaje y aún es la versión dominante en muchos sitios web. | PHP8 es la última versión (8.4.11 cuando escribo esto, en septiembre de 2025). Con mejoras y mantenimiento continuo, PHP sigue siendo un lenguaje muy vivo (aunque llevan 20 años anunciando su muerte). PHP7 ya no tiene soporte y todas los nuevos desarrollos con este lenguaje deberían escribirse en PHP8. | . Lo nuevo en PHP8 . Algunas de las novedades más destacables de PHP8 son: . | Mejoras importantes de rendimiento, con la aparición de JIT (Just in Time Compiler), un compilador de PHP que trabaja de forma transparente al programador para incrementar la velocidad de ejecución. | Mejoras menores en el manejo de las clases y métodos abstractos. | Simplificación en la declaración de atributos. | Posibilidad de usar arrays con índices negativos. | Aparición de los Attributes (similar a los decoradores) que permiten modificar el comportamiento de una clase sin alterar su código. | . Como ves, nada que vaya a revolucionar la forma de trabajar con PHP, solo mejoras continuas para evitar que PHP quede rezagado con respecto de otros lenguajes más modernos. Ventajas de PHP sobre otros lenguajes . PHP es uno de los lenguajes más utilizados para el desarrollo de aplicaciones web del lado del servidor. Hace años (¡muchos!) que algunos se empeñan en decir que está muerto o que está destinado a desaparecer, pero sigue ahí, obstinadamente entre los lenguajes más populares. Por algo será. Algunas de las ventajas que han hecho de PHP durar tanto tiempo son: . | Es un lenguaje en continua evolución que se ha adaptado a los nuevos tiempos. | Es un lenguaje libre y abierto. | Es muy eficiente (comparado con otros lenguajes del lado del servidor). | Es ejecutable en (casi) cualquier servidor. | Cuenta con una excelente documentación y miles de foros y sitios donde consultar dudas. | La curva de aprendizaje es baja si ya sabes programar. | Existen mogollón de entornos de desarrollo para PHP, para todos los gustos. | Ofrece fácil interoperatibilidad con otros sistemas, en particular con bases de datos. | Comunidad muuuy grande. | Su sintaxis, estabilidad y seguridad han mejorado enormemente desde los tiempos algo caóticos de PHP4. | . Inconvenientes de PHP con respecto a otros lenguajes . PHP también presenta algunos inconvenientes, por supuesto. No hay nada perfecto. Entre ellos, podemos destacar: . | Fallos de diseño (corregidos en su mayoría a partir de PHP5), como: . | Los métodos para acceso a bases de datos cambian según el SGBD usado. | Nombres de funciones inconsistentes. | No es completamente orientado a objetos. | Tipado confuso y, a veces, impredecible. | . | Grandes (e incompatibles) cambios entre versiones. | Pérdida lenta pero constante de cuota de mercado. | Pésima relación señal/ruido en la web: ¡hay demasiados malos desarrolladores en PHP! | . Gestión de dependencias con composer . Aunque PHP puede instalarse como un programa independiente, en el contexto del desarrollo de aplicaciones web siempre se utiliza como parte de un servidor web. Casi todos los servidores web proporcionan soporte nativo para PHP. Por ejemplo, Apache lo incorpora “de serie”, de modo que solo tenemos que tener un servidor con Apache instalado para poder desarrollar con PHP. Lo mismo puede decirse de otros servidores basados en sistemas Unix y Linux, como nginx o lighttpd. Cuando las aplicaciones se empiezan a hacer complejas, suele ser habitual que necesitemos paquetes de PHP que no son estándar, es decir, que no vienen con el lenguaje. Podemos instalarlos manualmente, desde luego, pero PHP, como todos los lenguajes medianamente serios, tiene su propio gestor de dependencias llamado composer. composer se usa desde la línea de comandos y trabaja utilizando un archivo de configuración llamado composer.json (porque está escrito en formato JSON) donde se especifican qué paquetes (o librerías) usa el proyecto en cuestión. Al ejecutar composer, ese archivo es leído y las dependencias instaladas o actualizadas en una carpeta del proyecto llamada /vendor. De ese modo, podemos tener todas las librerías correctamente instaladas y actualidadas con facilidad. El aspecto del archivo de configuración composer.json es algo así: . { \"require\": { \"monolog/monolog\": \"2.0.*\", \"phpunit/phpunit\": \"^9.5\", \"phpunit/php-code-coverage\": \"^9.2\" } } . Con la clave require le estamos indicando a composer que los paquetes siguientes son imprescindibles para nuestro programa y que tiene que instalarlos en /vendor junto con todas sus dependencias (si las tuvieran), es decir, junto con cualquier otra librería que esos paquetes necesiten para funcionar. El nombre de cada paquete está formado por el nombre del fabricante seguido del nombre del proyecto en cuestión. A menudo, ambos nombres son iguales (como en “monolog/monolog”), pero a veces no es así (“php-unit/php-code-coverage”). A continuación del nombre se indica la versión del paquete que necesitamos. Se pueden usar símbolos comodín. Así, por ejemplo, “2.0.*” significa “2.0.” seguido de cualquier otro número, mientras que “^9.5” significa “versión 9.5 o superior”. Existen otras secciones que se pueden añadir al archivo composer.json, como: . | require-dev: paquetes necesarios solo en el entorno de desarrollo (no en el de producción). | autoload: paquetes que deben cargarse automáticamente en memoria durante la ejecución de la aplicación, de manera que no sea necesario incluirlos con include o require. | conflict: paquetes que no funcionan bien con tu aplicación y que no deben ser instalados en ningún caso. | . La configuración de composer tiene muchos recovecos y se puede convertir en algo bastante complicado. No es nuestra intención dar ahora un curso sobre composer. Solo tienes que saber cómo añadir las librerías necesarias para tu aplicación (con require) y cómo lanzar su instalación y actualización. Para instalar los paquetes que necesita tu aplicación, solo tienes que teclear este comando (en el directorio raíz de tu aplicación, donde ya debe existir composer.json): . $ composer install . También se puede instalar un paquete suelto, sin necesidad de añadirlo a composer.json: . $ composer install nombre-del-paquete . Si lo que quieres es actualizar los paquetes de composer.json a la última versión disponible, teclea esto: . $ composer update . Por último, si quieres lanzar la autocarga de paquetes (los que hayas puesto en la sección “autoload”), teclea: . $ composer dump-autoload . Desde luego, composer tiene otras muchas opciones que no vamos a ver en este momento. Este es el uso básico de este gestor de dependencias, e irás aprendiendo otras cosas sobre él conforme lo necesites. 1.2.6. MariaDB o MySQL . Otra de las herramientas básicas de nuestra caja de herramientas es el gestor de bases de datos relacionales (SGBD). MariaDB es el SGBD líder del mercado de las aplicaciones web. Nos permitirá conectarnos a una base de datos en red y ejecutar sentencias SQL de forma remota al visitar una aplicación web. Es un fork de MySQL, por lo que, en la práctica, se puede usar cualquiera de ellos indistintamente. Existen otras posibilidades, desde luego. Entre las más populares están: . | SQL Server | Oracle | PostgreSQL | SQLite | . También está la posibilidad de usar base de datos no relacionales, como MongoDB, Cassandra o Redis. PHP puede conectarse también a estos sistemas, pero la forma de trabajar es diferente que con bases de datos relacionales. Como estas últimas son, de lejos, las predominantes en el mercado, nos centraremos en ellas. A partir de ahora, cuando hablemos de bases de datos, siempre nos estaremos refiriendo a MariaDB o MySQL, pero cualquier otra base de datos relacional puede usarse del mismo modo con mínimos cambios en el código fuente. Características de MariaDB . | MariaDB es un gestor de bases de datos relacional multiusuario y multiplataforma. | Permite mútiples conexiones remotas. | Es software libre. | Existen librerías para acceder a MariaDB desde muchos lenguajes: C/C++, Java, PHP, Perl, Pascal… Además, hay drivers ODBC. | Está muy extendida en aplicaciones web, generalmente en combinación con PHP. | Cuenta un interfaz gráfico programado en PHP, llamado PHPMyAdmin, que se ejecuta en el navegador web. Por supuesto, se puede usar cualquier otro cliente compatible con MySQL, como MySQL Workbench. | . Brevísima historia de MariaDB . | MySQL surgió como un proyecto OpenSource en Suecia en 1995. | El objetivo era lograr un SGBD rápido y fiable que cumpliera con el estándar SQL. | Las primeras versiones (que se denominaron mSQL) eran muy ineficientes. | La popularización de PHP y su ganancia en eficiencia a partir de la versión 3 la han hecho muy popular en la actualidad. | Tras su adquisición por Oracle, se intentó relegar al segmento medio-bajo en el mercado de los SGBD y surgió un fork: MariaDB (traducción para los recién llegados: “fork” significa “proyecto nuevo surgido a partir de otro proyecto ya existente”). | La versión más reciente (cuando escribo esto, en septiembre de 2025) es MariaDB 11.8.2 | . 1.2.7. Montaje del servidor . Para que todas las herramientas anteriores funcionen y, por lo tanto, para que podamos desarrollar una aplicación web completa, necesitamos dos componentes software adicionales: . | Un cliente web, también llamado navegador web. En este programa se ejecutan todas las tecnologías del lado del cliente (HTML, CSS y Javascript). Puedes usar el que más te guste, como Firefox, Chrome, Safari, Opera o Edge, pero es aconsejable que tengas varios a mano para probar tus aplicaciones en todos ellos, porque a veces ofrecen resultados ligeramente distintos. Los navegadores web modernos ofrecen un completísimo sistema de debug para depurar el lado del cliente de la aplicación. Debes familiarizarte con el del navegador que prefieras. Verás todos estos detalles en el módulo de Desarrollo web en entorno cliente. | Un servidor web. Este programa se encarga de ejecutar el código del lado del servidor, es decir, PHP o el lenguaje de servidor que hayas elegido. Instalar y configurar un servidor es una tarea muy compleja que no recae en los programadores, sino en los administradores de sistemas. No obstante, los programadores de aplicaciones web deben conocer los fundamentos de configuración de los servidores para trabajar con aplicaciones en el lado del servidor. Veréis bastante de esto en el módulo de Despliegue de aplicaciones web. Los servidores web más populares son Apache2 y nginx. Ambos corren en entornos Unix/Linux y permiten la ejecución de programas escritos en PHP y muchos otros lenguajes. El servidor IIS es el nativo de los sistemas basados en Windows Server y se utiliza para aplicaciones .NET, mientras que Tomcat es el preferido para ejecutar aplicaciones Java del lado del servidor, aunque el framework Spring Boot incluye su propio servidor y hace innecesario a Tomcat. | . Los desarrolladores web suelen tener un servidor web instalado en su propia máquina de trabajo, de modo que el mismo hardware ejecuta simultáneamente el cliente web y el servidor web, emulando el entorno de ejecución real, en el que el servidor web está en una máquina físicamente distinta del cliente. Tener ambos programas, cliente y servidor, corriendo en la misma máquina agiliza el proceso de desarrollo, aunque desplegar la aplicación en un servidor real, distinto del de desarrollo, puede llegar a ser bastante fastidioso. Los detalles de estas operaciones los estudiaréis en el módulo de Despliegue de aplicaciones web. De modo que, para desarrollar, vamos a instalar un servidor web en nuestra propia máquina. Aunque hay muchas maneras de hacer esto, vamos a mencionar dos de las más habituales: . | Instalar un servidor nativo. | Instalar un servidor virtualizado con Docker (OPCIÓN RECOMENDADA). | . Instalación de un servidor nativo . Consiste en instalar en nuestra máquina todas las aplicaciones necesarias para convertirla en un servidor web. Esto incluye, como mínimo: . | Apache2 o nginx. | MySQL o MariaDB. | . Optativamente, podemos instalar un cliente para MySQL basado en la web. PHPMyAdmin es la opción más popular. En lugar de instalar y configurar estos programas de uno en uno, lo cual es un trabajo tedioso y bastante especializado, existen paquetes que instalan de una sola tacada todos los programas necesarios para transformar nuestro equipo en un servidor, preconfigurados para un entorno de desarrollo web: . | XAMPP: este paquete incluye Apache2, MariaDB, PHP, Perl y PHPMyAdmin, entre otras cosas. Existen versiones para Windows, Mac y Linux y permite comenzar a desarrollar de forma muy rápida. | WAMPP: es un paquete parecido al anterior, pero solo para Windows. | LAMPP y MAMPP: son versiones de los paquetes anteriores, específicamente diseñadas para sistemas Linux y Mac, respectivamente. | . Estos paquetes se instalan con gran facilidad: solo hay que descargarlos de la web de fabricante (nunca de otros sitios) y seguir las intrucciones de instalación. Aunque XAMPP y compañía son soluciones rápidas y eficaces para empezar a desarrollar, el despliegue de las aplicaciones web desarrolladas sobre estos servidores puede darnos muchos quebraderos de cabeza, ya que cualquier diferencia entre la configuración de nuestro XAMPP y la configuración del servidor real puede hacer que la aplicación no funcione igual en el entorno de producción que en el de desarrollo. Instalación de un servidor virtualizado mediante Docker (OPCIÓN RECOMENDADA) . Para evitar los problemas del despliegue, lo más habitual en la actualidad es usar servidores virtualizados basados en Docker. Docker es un software de virtualización que usa el Kernel del sistema operativo real y virtualiza solo solo los servicios y el software necesario para la aplicación que estemos desarrollando. En nuestro caso, Docker puede ejecutar Apache o MySQL de forma virtualizada (es decir, sobre un entorno Linux virtualizado), aunque estemos trabajando en Windows o en MacOS. Este enfoque tiene dos grandes ventajas: . | No tenemos que instalar un montón de programas muy pesados en nuestro sistema. ¡Apache2 o MySQL Server son grandes devoradores de recursos! Además, ni siquiera funcionan bien en sistemas no-Linux. Al tenerlos virtualizados, no solo funcionarán a la perfección, sino que bastará con detener la máquina virtual para que dejen de consumir CPU y memoria RAM. | El entorno de desarrollo y el entorno de producción pueden ser completamente iguales, evitando los problemas de despliegue tan habituales en las apliaciones web. | . Docker es una herramienta de consola (aunque existe un Docker Desktop) que permite lanzar contenedores. Estos contenedores contienen el software virtualizado que nos interesa. Los contenedores están basados en imágenes disponibles libremente en repositorios como DockerHub (https://hub.docker.com/). Por lo tanto, basta con encontrar en DockerHub las imágenes del software que necesitemos (Apache2, MySQL, PHPMyAdmin, etc) y lanzarlas en nuestro entorno de desarrollo. Para ello, debemos instalar previamente un cliente de docker, disponible de forma gratuita en https://docs.docker.com/get-docker/. Puedes seguir las instrucciones para montar tu servidor con Docker en el Apéndice 2. Allí te explico cómo montar un servidor virtualizado que use Apache, MariaDB, PHP y PHPMyAdmin y ponerlo en marcha con un solo comando. ",
    "url": "https://iescelia.org/docs/fullstack/_site/php/caja-de-herramientas.html#12-caja-de-herramientas-para-desarrollar-de-aplicaciones-web-con-php",
    "relUrl": "/php/caja-de-herramientas.html#12-caja-de-herramientas-para-desarrollar-de-aplicaciones-web-con-php"
  },"3": {
    "doc": "1.2 Caja de herramientas",
    "title": "1.2 Caja de herramientas",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/php/caja-de-herramientas.html",
    "relUrl": "/php/caja-de-herramientas.html"
  },"4": {
    "doc": "1.3 Sintaxis de PHP",
    "title": "1.3. La sintaxis de PHP",
    "content": ". | 1.3.1. Cómo incrustar PHP dentro de HTML | 1.3.2. Comentarios | 1.3.3. Variables y constantes | 1.3.4. Operadores | 1.3.5. Arrays | 1.3.6. Estructuras de control | 1.3.7. Funciones y procedimientos | 1.3.8. Funciones anónimas, funciones lambda o closures | 1.3.9. Clases y objetos | 1.3.10. Salida de datos | 1.3.11. Paso de parámetros por la URL | 1.3.12. Entrada de datos a través de formulario | 1.3.13. Validación y saneamiento de formularios | 1.3.14. Namespaces | 1.3.15. Extensiones de PHP y referencia del lenguaje: cómo usar la biblioteca del lenguaje sin volverse loco | . 1.3.1. Cómo incrustar PHP dentro de HTML . El código PHP se escribe incrustado dentro de un documento de texto mediante estas etiquetas: . &lt;?php .... ?&gt; . Este archivo debe tener SIEMPRE extensión .php, NO .html . Cuando el servidor web encuentre un archivo con extensión .html, lo enviará al cliente sin mirar ni siquiera lo que hay en su interior. En cambio, cuando el servidor web encuentre un archivo con extensión .php, lo abrirá y buscará las etiquetas &lt;?php … ?&gt;, y ejecutará el código que haya dentro antes de enviar el resultado al cliente. El resto del archivo, es decir, lo que esté fuera de las etiquetas de PHP, se enviará al cliente sin modificar. 1.3.2. Comentarios . Los comentarios de PHP se pueden escribir de varias formas: . // Comentario de una línea # Comentario de una línea /* Comentario de una o varias líneas */ . 1.3.3. Variables y constantes . Las variables de una función/clase/método PHP son siempre locales, es decir, sólo están disponibles en esa función/clase/método, salvo que se indique otra cosa. Si se definen variables fuera de una función, serán globales a todo el fichero actual, pero no pueden usarse en el código ubicado en otros ficheros. Existen maneras de lograr que una variable sea global a todo el código, pero, vamos… ¿en serio quieres hacer eso? . (Nota anticipatoria: hay ciertas situaciones en las que una aplicación web necesita variables globales, pero ya lo veremos en su momento. Por ahora, solo recuerda que usar variables globales es una pésima práctica de programación). El identificador de variable siempre debe empezar por $. Esta es una peculiaridad de PHP que al principio descoloca un poco. En PHP, no es necesario declarar las variables: al inicializarlas queda especificado el tipo. A partir de PHP7 pueden indicarse los tipos predefinidos (int, float, string…), pero solo es algo optativo. Ejemplos: . $a = 4; // Variable entera (PHP5+) int $a = 4; // Variable entera (PHP7+) $media = 52.75; // Variable real $texto = \"Hoy es lunes\"; // Variable string . Cualquier variable puede cambiarse de tipo con funciones como intval(), floatval() o strval(): . $a = \"10\"; // $a es una cadena $b = intval($a); // $a se convierte a entero y se asigna a $b . Como no hay que declarar las variables, a veces no estaremos seguros de si una variable existe y tiene un valor válido (no nulo) asignado. Para averiguarlo existe la función isset(), que nos devuelve true si la variable existe y false en caso contrario. Del mismo modo, hay otra función muy útil, unset(), que hace desaparecer a una variable ya definida y libera la memoria que ocupaba: . if (isset($nombre)) { echo $nombre; // Solo muestra el nombre si la variable tiene algún valor } else { echo \"El nombre no está definido\"; } . El tipado de PHP es débil, así que puedes encontrarte expresiones donde se mezclen tipos. PHP hará las conversiones que le parezca oportunas, con resultados a veces imprevisibles, por lo que no es buena idea recurrir a estas estratagemas a menos que sepas muy bien lo que estás haciendo y el resultado que obtendrás. Por ejemplo: . $a = 3; // a es un integer $b = \"Hoy es lunes\"; // b es un string $c = $a + $b; // ¡Esto funciona, pero ¿a que no predices bien el resultado? . Los tipos de datos predefinidos en PHP son: . | integer (entero) | double (real) | bool (booleano) | string (cadena) | array (pues eso) | . En cuanto a las constantes, se crean con la función define(): . define(\"NOMBRE\", \"Pepito Pérez\"); // NOMBRE es una constante echo NOMBRE; // Muestra el valor de la constante. ¡Fíjate en que no lleva el símbolo $! . Las constantes, por convenio, suelen nombrarse en MAYÚSCULAS. El propio PHP tiene muchas constantes predefinidas (todas en mayúsculas) de ámbito global, como PHP_VERSION o PHP_OS. Algunas de estas constantes predefinidas empiezan y terminan por un doble subrayado, como __LINE__ o __FILE__. Estas constantes se llaman constantes mágicas y nos van a resultar muy útiles más adelante. 1.3.4. Operadores . Los operadores en PHP son iguales que los de Java, que, a su vez, los heredó de C/C++: . | Asignación: $a = 3; | Comparación: ==, &lt;=, &gt;=, !=, &lt;=&gt;, etc. | Operadores aritméticos: +, -, *, /, %… | Operadores lógicos: &amp;&amp;, ||, ! | Operadores de asignación combinados: +=, -=, ++, –, *=, /=, etc | . Existen operadores más esotéricos, como el operador ternario o los operadores a nivel de bit, que no usaremos demasiado. Sin embargo, PHP cuenta con algunos operadores curiosos que a lo mejor no conoces y que te pueden ahorrar mucho trabajo. Te los cuento brevemente: . Operador de coalescencia nulo. Con ese nombre tan rebuscado se conoce al operador ?? (doble interrogante). Simplemente, asigna a una variable valor u otro dependiendo de si está definida o no: . $user = $nombreUsuario ?? \"sin-nombre\"; . La variable $user del ejemplo anterior tomará el valor $nombreUsuario si y solo si esa variable, $nombreUsuario, existe y tiene un valor asignado. En caso contrario, tomará el valor “sin-nombre”. Operador nave espacial. Así se conoce el operador &lt;==&gt;. ¡Otro bonito chiste de informáticos! Se usa para comparar dos expresiones y decidir cuál es la menor. Devuelve -1 (si la primera expresión es menor que la segunda), 0 (si son iguales) o 1 (si la primera expresión es mayor que la segunda): . $resultado = $var1 &lt;==&gt; $var2; echo $resultado; // Mostrará -1, 0 o 1, dependiendo de los valores de $var1 y $var2 . 1.3.5. Arrays . Los arrays en PHP son colecciones de variables del mismo o de distinto tipo identificadas por un índice. Se parecen más a los ArrayList de Java que a los arrays clásicos propiamente dichos. $a[1] = \"lunes\"; $a[2] = 1; // El array de PHP puede contener datos de diferente tipo en cada elemento $a[3] = \"martes\"; $a[4] = 2; etc. El índice no tiene por qué ser un número entero: puede ser un String (array asociativo): . $a[\"ESP\"] = \"España\"; $a[\"FRA\"] = \"Francia\"; $a[\"POR\"] = \"Portugal\"; . Como los arrays son objetos, dispones de un montón de métodos y atributos para consultarlos y manipularlos. No es mi intención proporcionarte aquí una lista exhaustiva, porque son muchos y para eso ya está la documentación oficial, pero sí te voy a mostrar algunos que te permitan hacerte una idea: . | count($a): devuelve el número de elementos del array $a. | in_array(“valor”, $a): busca el elemento “valor” en el array $a. Devuelve true o false. | unset($a[4]): elimina un elemento (el 4, en este ejemplo) del array $a. | next($a): devuelve el siguiente elemento de un array (el primero, si es la primera vez que se invoca). | prev($a): devuelve el elemento anterior de un array (el último si es la primera vez que se invoca). | array_push($a, $elemento): añade el $elemento al final del array $a. | $elemento = array_pop($a): elimina el último elemento del array $a (y lo asigna a la variable $elemento). | sort($a) y asort($a): ordena el array $a. sort() se utiliza con arrays convencionales y asort() con arrays asociativos. | . 1.3.6. Estructuras de control . Vamos a hacer un repaso muy rápido por las estructuras de control de PHP. Si ya conoces otros lenguajes como Java, todas te resultarán familiares. Condicionales . El condicional doble tiene la sintaxis habitual: . if (condición) { acciones-1; } else { acciones-2; } . Por supuesto, la parte del else puede eliminarse si no la necesitas, y obtendrías un condicional simple. Bucle while . El bucle de tipo while tiene este aspecto: . while (condición) { acciones; } . Bucle repeat . El bucle de tipo repeat, es decir, con la condición al final, tiene esta sintaxis: . do { acciones; } while (condición); . Bucles for y foreach . El bucle for controlado por contador es idéntico a C/C++ y Java: . for (inicialización; condición; incremento) { acciones; } . Hay una variedad de bucle for muy interesante: el bucle foreach para recorrido de arrays asociativos: . foreach ($array as $índice=&gt;$var) { acciones; } . El bucle foreach se repite una vez para cada valor guardado en el array. Ese valor se asigna a la variable $var en cada repetición. Por ejemplo: . $a[\"ESP\"] = \"España\"; $a[\"FRA\"] = \"Francia\"; $a[\"POR\"] = \"Portugal\"; foreach ($a as $pais=&gt;$codigo) { echo \"Nombre del país: $pais - Código: $codigo&lt;br&gt;\"; } . La salida de este programa será: . Nombre del país: España - Código: ESP Nombre del país: Francia - Código: FRA Nombre del país: Portugal - Código: POR . break y continue . Como en muchos otros lenguajes, las instrucciones break y continue pueden usarse en el interior del cuerpo de los bucles para lograr este comportamiento: . | break. “Rompe” el bucle, es decir, se sale del bucle y continúa ejecutando el programa por la instrucción que haya inmediatamente después del mismo. | continue. Deja de ejecutar la iteración actual y vuelve al comienzo del bucle para iniciar una nueva iteración. | . Sintaxis alternativa con dos puntos . Las estructuras de control de PHP tienen una sintaxis alternativa que elimina el uso de las llaves, muy denostadas por algunos programadores. Por ejemplo, una instrucción if puede escribirse de forma tradicional: . if ($i &lt; 0) { echo \"La variable es menor que cero\"; } . …o bien con la “sintaxis dos puntos”: . if ($i &lt; 0): echo \"La variable es menor que cero\"; endif; . Puedes elegir la sintaxis con la que te sientas más cómodo/a. Nosotros, en este manual, usaremos la primera por estar más extendida, pero las dos son igualmente válidas. 1.3.7. Funciones y procedimientos . Los subprogramas (funciones y procedimientos) se escriben en PHP del mismo modo: con la palabra function. | Las funciones deben devolver un valor en su última línea con return. Si necesitas devolver varios valores, puedes empaquetarlos en un array o en un objeto. Ten en cuenta que, después de un return, la función terminará de forma inmediata y devolverá el control de ejecución al código desde la que fue invocada. Es decir: cualquier línea de código de la función que esté por debajo del return nunca se ejecutará. | Los procedimientos no tienen return. Realizan su función y terminan. | . Los argumentos de las funciones o procedimientos en PHP siembre se pasan por valor. Por si hay algún despistado/a: pasar argumentos por valor significa que PHP copiará en el parámetro de la función el valor de la variable con la que se invoca a dicha función, pero serán dos variables distintas. Si modificamos un parámetro dentro del código de la función, la variable con la que fue invocada no se verá afectada. Veámoslo con un ejempolo. Esta es una función con dos argumentos: . function calcular_iva($base, $porcentaje) { $total = $base * $porcentaje / 100; return $total; } . Para invocar a esta función, haremos algo como esto en algún otro punto del código fuente: . $iva = $calcular_iva($precio_del_articulo, 21); . En esta ocasión, hemos invocado a la función $calcular_iva() con dos parámetros: una variable ($precio_del_articulo) y una constante literal (21). Ambos parámetros se pasan por valor a la función. Eso significa que el valor de $precio_del_articulo se copia en el parámetro $base, y el valor del literal 21 se copia en $porcentaje. Cualquier modificación de $base o $porcentaje que pudiera producirse dentro del código de la función, no afectaría para nada a las variables originales ($precio_del_articulo y el literal 21). Por último, la función devuelve un valor mediante su return y ese valor se asigna a la varible $iva. Si esto del paso de parámetros por valor sigue sonándote a chino, quizá deberías repasar tus conocimientos sobre fundamentos de programación. Busca en internet algo como “paso de parametros por valor y por referencia” y dedica un rato a desentrañar los misterios del paso de parámetros antes de continuar. Definir el tipo de los argumentos . Desde PHP7, se puede definir el tipo de los argumentos de cualquier función: . function calcular_iva(float $base, float $porcentaje) { ... } . Esto es completamente optativo. Ahora bien, si defines el tipo de los argumentos y luego le pasas a la función un argumento de otro tipo, obtendrás un error de ejecución TypeError, como es lógico. Definir el tipo de la función . Desde PHP7 también se puede, optativamente, definir el tipo de datos que devolverá la función en el return: . function calcular_iva(float $base, float $porcentaje): float { ... } . Esto provocará que se evalúe de forma estricta el tipo de datos durante la invocación a la función y que se puedan producir errores de tipo (TypeError) en tiempo de ejecución, como es natural. Argumentos con valor predefinido . Algo muy útil que nos ofrece PHP es la posibilidad de asignar un valor por defecto a los argumentos de las funciones. Observa este ejemplo: . function calcular_iva($base, $porcentaje = 0.21) { ... } . El argumento $porcentaje tiene un valor por defecto, 0.21. Eso significa que podemos invocar esta función de dos maneras: . $a = calcular_iva(1000, 0.04); // Calculará el IVA de 1000 euros con un porcentaje del 4% $b = calcular_iva(1000); // Calculará el IVA de 1000 euros con un porcentaje del 21% . Como ves, en la primera invocación pasamos un valor para el argumento $porcentaje (0.04), por lo que ese argumento tomará ese valor. En cambio, en la segunda invocación nos olvidamos del segundo parámetro. Eso provocaría un error de ejecución en muchos lenguajes de programación, ¿verdad? Bueno, pues PHP lo ejecutará sin problemas, porque le hemos asignado un valor por defecto a $porcentaje. Eso significa que, si no le pasamos ningún valor, el argumento tomará su valor por defecto (0.21), y la función se ejecutará con ese valor asignado a esa variable. include y require . Cuando desarrollamos mucho código, a menudo colocamos colecciones de funciones (llamadas bibliotecas) en archivos diferentes que el resto del código. Para usar una función definida en otro archivo, necesitamos incluir ese código en nuestro archivo actual. Eso se hace con include y require: . | include se utiliza para incluir el código fuente de la biblioteca en nuestro archivo actual. Si la biblioteca no se encuentra, se produce un error de ejecución, pero el script actual continúa ejecutándose. | require también se utiliza para incluir el código fuente de la biblioteca en nuestro archivo actual. Pero si la biblioteca no se encuentra, se produce un error de ejecución y el script actual se detiene. | . Las variantes include_once y require_once se utilizan para evitar las inclusiones repetidas de código. Estas suelen ocurrir cuando nuestro programa es muy grande y varios scripts incluyen las mismas bibliotecas. Para prevenir errores por redefinición de funciones, se usa include_once o require_once: . include_once \"mi_biblioteca.php\"; // Incluye las funciones del archivo mi_biblioteca.php . El uso de include y require está en retroceso gracias a los espacios con nombre de las versiones recientes de PHP. Más adelante hablaremos de ellos. 1.3.8. Funciones anónimas, funciones lambda o closures . En muchos lenguajes modernos es habitual el uso de las funciones anónimas, funciones lambda o closures. Aunque no son exactamente lo mismo, se parecen mucho y por ahora no entraremos en detalles sobre sus diferencias. Se trata de funciones que no tienen nombre y que se usan directamente en una asignación a una variable o como parámetro de otra función. Las funciones anónimas suelen usarse en estos contextos: . | Cuando necesitas una función pequeña, con lógica breve, que no va a ser usada en ningún otro lugar. En este caso es más limpio crear una función anónima en el sitio donde la necesitas, y no una función aparte con su declaración, devolución de resultados y toda la parafernalia. | Si necesitas pasar una función como argumento a otra función. | Si necesitas una función que capture el valor de variables externas a la propia función. | Si necesitas asociar una función a un callback, un evento o una promesa (ya aprenderás que son estas cosas). | . En cambio, cuando la lógica de una función sea compleja, o bien su código se necesite invocar desde muchos lugares de la aplicación, es mejor que uses funciones tradicionales, con su nombre, su declaración y su cuerpo bien definido. Ten en cuenta que, si se usan mal, la funciones anónimas pueden volver incomprensible el código. Aquí puedes ver un ejemplo sencillo de función anónima: . $numero = 8; $doble = function(int $numero) { return $numero * 2; } echo $doble; // Imprimirá 16 . Hemos asignado la función anónima a una variable, llamada $doble. Por eso, al tratar de imprimir la variable, se invocará la función automáticamente. En este es otro ejemplo, una función sin nombre se pasa como parámetro: . function procesar(array $datos, callable $callback) { foreach ($datos as $d) { echo $callback($d) . \"\\n\"; } } procesar([1, 2, 3], fn($n) =&gt; $n * $n); . La función procesar() recibe dos parámetros: el primero es un array con datos y, el segundo, es una función anónima que le indica cómo procesar esos datos. En este caso, se calculará el cuadrado de cada uno de los datos del array, pero podría ser cualquier otra cosa. Piensa en lo flexible que se vuelve la función procesar() al utilizarla de este modo: ¡ahora el mismo código puede servir para hacer casi cualquier cosa con el array! . 1.3.9. Clases y objetos . A partir de la versión 5, PHP incluyó un completo soporte para orientación a objetos. Las clases, métodos y atributos se declaran de forma muy semejante a C++ y Java. Declaración de clases . En este ejemplo puedes ver cómo se declara una clase en PHP. Observa cómo se indica la herencia (extends) y cómo se declara el constructor (__construct()): . class MiClase extends ClaseMadre { // Declaración de propiedades (atributos) public $var1 = 'soy una variable pública de instancia'; private $var2 = 'y yo soy otra variable de instancia, pero privada'; // Método constructor (siempre se llama __construct) public function __construct($valor) { $this-&gt;var2 = $valor; } // Declaración de un método público public function mostrarVar() { echo $this-&gt;var2; } // Declaración de un método privado private function resetVar() { $this-&gt;var2 = ''; } public function otroMetodo() { // ...etc... } } . Algo que suele llamar la atención de los programadores que vienen de Java u otros lenguajes semejantes es que PHP no utiliza la notación punto para acceder a los miembros de una clase, sino la notación flecha (-&gt;). Por eso en el ejemplo anterior ves cosas como $this-&gt;var en lugar de this.var . Instanciación de objetos . Para instanciar un objeto de una clase, se usa la palabra new. El constructor puede llevar parámetros o no, como en Java. En el ejemplo anterior, el constructor tenía un argumento, así que new se usará así: . $miObjeto = new miClase('Estoy aprendiendo PHP'); $miObjeto-&gt;mostrarVar(); . La salida de este programa sería “Estoy aprendiendo PHP”. $this y parent . Como ya habrás supuesto, la variable $this se refiere siempre al objeto que está ejecutando el código, exactamente igual que en Java, Javascript y muchos otros lenguajes orientados a objeto. A veces, cuando tenemos una jerarquía de clases y unas heredan de otras, necesitamos invocar algún método de la clase madre o superclase. En ese caso, usaremos la palabra parent seguida de la notación cuatro puntos (::). Observa cómo se hace en este ejemplo, en el que el constructor de la subclase invoca al constructor de la superclase: . class MiClase { private $var1; public function __construct($param) { $this-&gt;var1 = $param; } } class MiSubclase extends MiClase { private $var2; public function __construct($param1, $param2) { $this-&gt;var2 = $param2; parent::__construct($param1); // Llamada a un método de la superclase } } . Miembros públicos, privados y protegidos . En PHP, mientras no se indique otra cosa, todos los miembros de una clase se considerarán públicos (public). Como en Java, existen tres niveles de visibilidad que podemos escoger para cada atributo y cada método: . | public: ese método o atributo es accesible desde el exterior de la clase. | private: ese método o atributo solo puede usarse desde dentro de la clase. | protected: ese método o atributo puede usarse desde dentro de la clase o desde cualquier clase hija. | . Getters y setters . En PHP también es habitual, como en muchos lenguajes de programación, que los atributos sean a menudo privados y que existan métodos getters y setters que se encarguen de manipularlos adecuadamente, sin que se acceda a los datos de los objetos desde el exterior. Esto es esencial para que los objetos funcionen como “cajas negras”. Los getters suelen devolver el valor de un atributo, pero los setters, en otros lenguajes, no devuelven nada. Sin embargo, en PHP es costumbre que los setters devuelvan el objeto completo, es decir, que terminen con un return $this. Así: . class MiClase { private $var1 = \"Esto es un atributo privado\"; // Getter public function getVar1() { return $var1; } // Setter public function setVar1($value) { $var1 = $value; return $this; // Devolvemos el objeto al terminar } } . Si lo hacemos así, estaremos creando lo que se llama un fluent interface o interfaz fluido, que es una forma rebuscada de decir que podremos encadenar varias invocaciones a métodos del objeto en una sola instrucción, algo que permite que el código se vea más organizado y legible. Para que veas en qué consiste el fluent interface, vamos a poner un ejemplo. Imagina que la clase anterior tuviera más atributos ($var1, $var2, $var3, etc), cada uno con sus respectivos setters. La forma tradicional de invocarlos todos sería algo así: . $obj = new MiClase(); $obj-&gt;setVar1($valor1); $obj-&gt;setVar2($valor2); $obj-&gt;setVar3($valor3); // etc. En cambio, si los setters devuelven this podemos usar un fluent interface y escribirlo así: . $obj = new MiClase(); $obj-&gt;setVar1($valor1) -&gt;setVar2($valor2) -&gt;setVar3($valor2); . Puede parecer un cambio insignificante, pero cuando los objetos son muy complejos, el código fluent se hace mucho más legible que el código tradicional. ¡Además, es gratis! . Clases abstractas e interfaces . Como en Java y otros lenguajes orientados a objetos, PHP también permite construir clases abstractas, que son clases que no se pueden instanciar. El objetivo de estas clases, como recordarás, es crear un molde a partir del cual puedan heredar otras clases que sí sean instanciables. Una clase abstracta se crea añadiendo la palabra abstract a la definición de la clase: . abstract class MiClase { ... } . También existen los interfaces, que son parecidos a las clases abstractas pero no pueden incorporar nada de código a los métodos. Es decir, se trata de una mera definición de métodos. Todas las clases que usen ese interfaz deben respetar e implementar esos métodos. Esto se hace cuando queremos que una colección de clases independientes proporcionen un conjunto de métodos homogéneos. Los interfaces se definen así: . interface MiInterface { public function unMetodo(); public function otroMetodo($parametro1, $parametro2); etc. } . Posteriormente, todas las clases que vayan a usar ese interface deben declararse de este modo: . class MiClase implements MiInterface { ... } . Métodos estáticos . Los métodos estáticos en PHP funcionan igual que en Java: se usan cuando una clase no tiene estado (es decir, no tiene atributos), o bien cuando ese método no tiene nada que ver con el estado de los objetos, sino que responde exactamente igual para todas las instancias. Los métodos estáticos se declaran así: . class MiClase { // Esto es un método estático public static function miMetodo() { ... } } . Para invocar un método estático, como es lógico, no es necesario instanciar ningún objeto. De hecho, si intentamos invocarlo a través de un objeto, fallará. Estos métodos se invocan a través del nombre de la clase directamente, usando la notación cuatro puntos (::): . // Esto invocará el método estático del ejemplo anterior MiClase::miMetodo(); . 1.3.10. Salida de datos . PHP puede hacer salidas de datos como cualquier otro lenguaje de programación: puede enviar texto a una impresora o datos a un fichero. O puede dibujar ventanas y componentes en un entorno gráfico de usuario. Pero cuando PHP se ejecuta como parte de una aplicación web, nada de eso tiene sentido: esa salida se produciría en el servidor, y nosotros no estamos allí para verla. Nosotros estamos en nuestro cliente (navegador web), pidiendo al servidor que ejecute un programa PHP. En este contexto, la salida PHP tiene que ser siempre código HTML válido. Ese código HTML será recibido por tu navegador, interpretado y mostrado. Observa el uso de echo para producir una salida HTML desde este pequeño script PHP: . &lt;body&gt; &lt;?php echo \"Soy un script de PHP y estoy generando código HTML. Para demostrarlo voy a escribir &lt;strong&gt;esto en negrita&lt;/strong&gt;\" ?&gt; &lt;/body&gt; . Si guardas este archivo en tu servidor web y lo cargas desde un navegador web (escribiendo la dirección https://tu-servidor/nombre-del-archivo.php), encontrarás que el navegador web recibe el siguiente código como resultado: . &lt;body&gt; Soy un script de PHP y estoy generando código HTML. Para demostrarlo voy a escribir &lt;strong&gt;esto en negrita&lt;/strong&gt; &lt;/body&gt; . Es decir, han desaparecido las etiquetas de PHP, así como el echo, y lo que recibe el navegador es código HTML limpio e impoluto. De hecho, el navegador no sabe si ese código HTML lo ha escrito una persona o lo ha generado un programa en PHP, como es el caso. Y ese será tu objetivo: escribir programas capaces de generar código HTML que el navegador pueda recibir e interpretar. Abreviatura para echo . En PHP moderno, hay una abreviatura para echo() que se usa muchísimo: . // Estas dos líneas son equivalentes: &lt;?php echo(\"Hola mundo\"); ?&gt; &lt;?= \"Hola mundo\" ?&gt; . Esta abreviatura solo se usa para hacer echo(). Si tienes una lógica PHP más compleja, debes usar los tags &lt;?php … ?&gt; habituales. 1.3.11. Paso de parámetros por la URL . Las aplicaciones web pueden recibir parámetros a través de la propia URL de invocación del servidor. Imagina que tenemos este link en un documento HTML: . &lt;a href=\"pagina.php?variable1=valor1&amp;variable2=valor2&amp;etc…\"&gt; . Al hacer clic en él, pediremos al servidor que ejecute el programa cuyo código fuente está en el archivo pagina.php, ¿verdad? . Pues bien, ese programa pagina.php tendrá a su disposición unas variables llamadas “variable1, *variable2, etc, que son las que han viajado hasta el servidor en la URL. Para acceder a esas variables, PHP utiliza un array global llamado $_GET, que se indexa con el nombre de las variables. Así: . &lt;?php echo \"La variable 2 vale:\".$_GET['variable2'].\"&lt;br&gt;\"; ?&gt; . Observa el uso del carácter punto (.) para concatenar strings en la salida de echo. Esto, en Java y muchos otros lenguajes, se haría con el carácter más (+). PHP es un poquito especial en este detalle. 1.3.12. Entrada de datos a través de formulario . Como PHP se ejecuta dentro de HTML, sólo puede recibir datos del usuario de la aplicación a través del navegador web. Y sólo hay una forma de introducir datos en una página web: a través de un formulario. Veámoslo con un ejemplo. Supongamos que hemos definido en HTML este sencillo formulario: . &lt;body&gt; &lt;form method=\"post\" action=\"destino.php\"&gt; Nombre&lt;br/&gt; &lt;input type=\"text\" name=\"nombre\"&gt;&lt;br/&gt; Apellidos&lt;br&gt; &lt;input type=\"text\" name=\"apellidos\"&gt;&lt;br/&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt; &lt;/body&gt; . Al pulsar el botón “Enviar”, se cargará el script destino.php en el servidor. Ese script recibirá dos variables HTML llamadas nombre y apellido, con el valor que el usuario haya introducido en el formulario. Para acceder a las variables HTML, se usa el array del sistema $_POST, indexándolo con el nombre de la variable: . &lt;?php echo \"La variable nombre vale\".$_POST['nombre'].\"&lt;br&gt;\" ?&gt; . Observa que $_POST es una variable semejante a $_GET. Puedes utilizar una u otra según el valor del atributo method de tu formulario HTML. La variable $_REQUEST sirve tanto para POST como para GET. Por eso será la que nosotros usaremos preferentemente en nuestros programas. 1.3.13. Validación y saneamiento de formularios . Los datos que llegan desde un formulario son una fuente inagotable de quebraderos de cabeza. Para empezar, casi todos los ataques a las aplicaciones web provienen de intentos de los atacantes de usar los formularios como puerta de entrada al servidor. Y no hay que menospreciar el caos que puede provocar en una aplicación un usuario bienintencionado pero torpe que envía al servidor cosas totalmente imprevistas a través de un formulario. Por lo tanto, todo lo que los usuarios de la aplicación escriban en un formulario debe filtrarse: . | En el cliente, usando los atributos HTML5 necesarios y, si hace falta, recurriendo a Javascript. | En el servidor, mediante PHP o el lenguaje de servidor que estemos usando. | . Ese filtro puede ser algo muy simple, como eliminar todos los caracteres no alfabéticos que provengan del formulario, o algo más complejo, como comprobar que el usuario ha escrito una dirección de email bien formada. Ese proceso de filtrado se denomina validación y saneamiento. Para ayudarnos en esta validación, PHP proporciona la función filter_var(), que limpia diferentes conjuntos de caracteres sospechosos de cualquier dato que provenga del formulario. Esta función recibe como parámetro un string y permite tanto sanearlo como validarlo. Por ejemplo, supongamos que tenemos un sencillo formulario con dos campos, nombre y email: . &lt;form action='procesa_formulario.php'&gt; &lt;input type='text' name='nombre'&gt; &lt;input type='text' name='email'&gt; &lt;button type='submit'&gt;Enviar&lt;/button&gt; &lt;/form&gt; . El script procesa_formulario.php recibirá los datos enviados por este formulario (nombre y email) en las variables $_REQUEST[“nombre”] y $_REQUEST[“email”]. Pues bien, si queremos sanear (limpiar) cualquier carácter sospechoso que pueda venir en esas variables, podemos hacerlo así: . if (!isset($_REQUEST[\"nombre\"])) { echo \"Error: el campo nombre es obligatorio\"; } if (!isset($_REQUEST[\"email\"])) { echo \"Error: el campo email es obligatorio\"; } $nombre = filter_var($_REQUEST[\"nombre\"], FILTER_SANITIZE_STRING); $email = filter_var($_REQUEST[\"email\"], FILTER_SANITIZE_EMAIL); . Tras la ejecución de este código nos habremos asegurado de que el usuario ha rellenado los dos campos y que esos campos no contienen ningún carácter sospechoso de ataque. filter_var() admite otros valores como segundo parámetro. Son estos: . | FILTER_SANITIZE_STRING: elimina cualquier etiqueta HTML que encuentre en el string. | FILTER_SANITIZE_NUMBER_INT: elimina cualquier carácter que no sea numérico (solo respeta los caracteres “+” y “-“) | FILTER_SANITIZE_URL: elimina cualquier carácter que no forme parte de una URL. El decir, solo deja las letras, los números y algunos caracteres especiales como _, : o ? | FILTER_SANITIZE_EMAIL: elimina cualquier carácter que no forme parte de una dirección de email típica. | . Si solo queremos validar un string procedente de un formulario, podemos cambiar los valores anteriores por FILTER_VALIDATE_STRING, FILTER_VALIDATE_NUMBER_INT, etc. Es decir, cambiaremos la palabra SANITIZE por VALIDATE. De ese modo, la función filter_var() no cambiará el string, sino que comprobará si pasa el filtro o no y nos devolverá true o false. Existen otros filtros más complejos que puedes consultar en la referencia oficial del lenguaje. Y, por supuesto, para construir validaciones más específicas, siempre puede programarlas por tu cuenta y riesgo, usando las funciones de procesamiento de strings que te ofrece PHP y currándotelo un poco. 1.3.14. Namespaces . Cuando las aplicaciones se hacen muy complejas pueden llegar a usar muchísimas clases (tanto nuestras como de librerías) y antes o después nos encontramos con problemas de redefinición. Es decir: dos clases, dos métodos o dos funciones que se llaman igual pero que pertenecen a librerías diferentes. Los namespaces o espacios con nombre permiten organizar clases mediante nombres descriptivos, igual que los archivos se organizan en carpetas. ¿Verdad que puedes tener dos archivos que se llamen igual en dos lugares distintos de tu disco duro? Pues eso mismo. Por ejemplo, podemos tener una clase llamada Planta para manejar las existencias de plantas vegetales de un centro comercial, y una clase diferente llamada también Planta que se refiera a los diferentes pisos del centro comercial. Cada clase estaría dentro de un namespace diferente, y así no se confundirían. Para asignar una clase (o lo que sea) a un espacio con nombres, basta con indicarlo al principio del archivo que contiene esa clase, así: . namespace vegetales; . Cualquier clase o función que se declare en este archivo pertenecerá al namespace “vegetales”. Para mantener un código limpio y bien organizado, lo habitual es escribir una sola clase en cada archivo, y colocar esos archivos en subcarpetas que tengan el mismo nombre que el namespace. De hecho, los namespaces de los sistemas complejos suelen incluir una jerarquía de carpetas que se indica así: . namespace Persona\\Empleado; . El archivo que comience de ese modo debería contener el código fuente de una clase llamada también Empleado, y el propio archivo debería llamarse empleado.php y localizarse en una subcarpeta llamada persona/empleado. ¿Y cómo se usa una clase localizada en un namespace? Muy sencillo: indicaremos el namespace que queremos utilizar mediante la instrucción use: . include_once(\"Persona/Empleado/empleado.php\"); // Esto incluye el código fuente de la clase Empleado use Persona/Empleado/Empleado; // Esto indica el namespace que queremos utilizar $emp = new Empleado(); // ¡Y ya tenemos disponible la clase Empleado! . 1.3.15. Extensiones de PHP y referencia del lenguaje: cómo usar la biblioteca del lenguaje sin volverse loco . Para terminar con esta introducción a PHP, no podemos dejar de hablar de las bibliotecas de clases y funciones que vienen con cualquier distribución del lenguaje. PHP dispone, literalmente, de miles de funciones y métodos disponibles para usar con nuestros programas. Estas funciones y métodos resuelven casi cualquier problema común concebible. Como la biblioteca de PHP es tan grande, los administradores del servidor deben decidir qué funciones y clases están disponibles activando o desactivando extensiones de PHP, que es una forma rebuscada de referirse a las bibliotecas del lenguaje. Cuando un servidor tiene activada una determinada extensión de PHP, todas sus funciones y métodos están disponibles para nuestros programas. Es imposible conocer toda esa vasta colección de funciones, clases y métodos. Para eso está la referencia oficial del lenguaje, que puedes encontrar en https://www.php.net/manual . Por ejemplo, existen muchas funciones para manipular strings. Imagina que un día necesitas convertir todos los caracteres de un string a mayúsculas. Parece razonable suponer que, si las bibliotecas de PHP son tan grandes, exitirá una función que pueda hacer eso por nosotros. ¿Cómo la localizamos? . Mi consejo es que acudas siempre a https://www.php.net/manual y allí utilices el buscador. Por ejemplo, teclea en la caja de búsqueda la palabra “strings”. En la página de resultados obtendrás una lista con todas las funciones relativas a strings. La función que estamos buscando debe incluir la palabra “upper”. Una rápida búsqueda por la página de resultados te conducirá a la función strtoupper(), que es justo la que estábamos buscando. Si accedes a la página de strtoupper() encontrarás una completa descripción de la función y, lo que es más importante, algunos ejemplos de código que puedes copiar, pegar y adaptar a tu caso concreto. Si, por alguna razón, decides buscar información sobre las biblioteca de PHP fuera de la web oficial, asegúrate que el sitio es de confianza y que la información que ofrece está actualizada: hay muchos sitios web que proporcionan soluciones obsoletas, inseguras o directamente erróneas. Por supuesto, también está la opción de recurrir a una IA generativa. Pero hazte un favor a ti y a tu cerebro de programador en formación: no te fíes al 100% de su respuesta y, sobre todo, nunca, nunca jamás le pidas a una IA que resuelva tu problema. Pídele mejor que te explique cómo podrías resolver el problema, y después trata de resolverlo por ti mismo. Si no, no habrás aprendido nada por el camino y, aunque tu programa funcione bien, habrás perdido el tiempo miserablemente. ",
    "url": "https://iescelia.org/docs/fullstack/_site/php/sintaxis-de-php.html#13-la-sintaxis-de-php",
    "relUrl": "/php/sintaxis-de-php.html#13-la-sintaxis-de-php"
  },"5": {
    "doc": "1.3 Sintaxis de PHP",
    "title": "1.3 Sintaxis de PHP",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/php/sintaxis-de-php.html",
    "relUrl": "/php/sintaxis-de-php.html"
  },"6": {
    "doc": "1.4 Interacción con la base de datos",
    "title": "1.4. Interacción entre MariaDB y PHP",
    "content": ". | 1.4.1. MySQL/MariaDB con PHP4 (¡Ojo! ¡Obsoleto!) | 1.4.2. MySQL/MariaDB a partir de PHP5 | 1.4.3. Inserción, modificación y borrado de datos con PDO | 1.4.4. Consultas con PDO | 1.4.5. Mejorando la implementación de consultas | 1.4.6. Formas de hacer fetch | . A partir de ahora, vamos a referirnos a MySQL/MariaDB indistintamente. Este será el gestor de bases de datos relacionales que vamos a usar a lo largo del curso. La adaptación a otros gestores, en cualquier caso, es muy simple. MySQL/MariaDB, como ya hemos visto, es un SGBD relacional de probada eficacia. La interacción con él resulta eficiente y segura para casi cualquier aplicación web que podamos concebir. 1.4.1. MySQL/MariaDB con PHP4 (¡Ojo! ¡Obsoleto!) . En la red hay mucho código PHP obsoleto que NO debes utilizar bajo ningún concepto porque es muy inseguro. Si encuentras código que se parece al siguiente, huye de esa página porque no te va a ayudar: . &lt;?php // *** CÓDIGO OBSOLETO -- ¡¡¡NO USAR!!!*** // Conectamos con MySQL mysql_connect(\"URL\",\"nombre_usuario\",\"contraseña\"); // Seleccionamos la base de datos con la que vamos a trabajar mysql_select_db(\"nombre_base_de_datos\"); // Ejecutamos una sentencia SQL mysql_query(\"INSERT INTO clientes (nombre,telefono) VALUES ('$nombre','$telefono')\"); . 1.4.2. MySQL/MariaDB a partir de PHP5 . Desde PHP5, se utiliza una biblioteca de clases para acceder a los diferentes SGBDs. Todos los nuevos desarrollos deberían usar las bibliotecas de clases y prescindir de las viejas librerías de funciones. Formas de acceder a bases de datos en PHP . PHP proporciona varios mecanismos para acceder a bases de datos (ya te lo dije antes: en PHP, casi todo se puede hacer de varias maneras distintas): . | Forma 1: Usar la extensión mysqli en su forma procedimental. Esta forma recuerda mucho a PHP4, pero cambiando la palabra “mysql” por “mysqli”. Por ejemplo, la función mysql_connect() ahora se llama mysqli_connect() (la “i” significa “improved”, es decir, “mejorado”). Esta forma es apta para programadores/as perezosos y anticuados, que no quieren pasarse a la programación orientada a objetos y se sienten cómodos con la forma de codificación tradicional. Pero ese no es tu caso, ¿verdad? Así que nunca utilizaremos la forma procedimental. | Forma 2: Usar la extensión mysqli en su forma orientada a objetos. Se accede a la base de datos a través de un objeto de la clase mysqli. Es decir, se crea una instancia (con new mysqli()) y, a través de ella, se tiene acceso a todos los métodos para interactuar con la base de datos. Si en lugar de una base de datos MySQL, trabajamos con otro gestor de base de datos, hay que crear un objeto de otro tipo. Por ejemplo, la clase SQLite3 sirve para conectar con bases de datos SQLite. Hay otros gestores que solo ofrecen la forma procedimental. | Forma 3: Usar la extensión PDO. A partir de PHP 5.1, existe una clase genérica, llamada PDO, que permite acceder a cualquier gestor de bases de datos mediante el mismo conjunto de métodos. Es lo que se llama una capa de abstracción de acceso a datos . Esto significa que, independientemente de la base de datos que se esté utilizando, PDO permite utilizar los mismos métodos para realizar consultas y obtener datos, por lo que es la forma de trabajo más flexible y la que vamos a utilizar en este curso. | . 1.4.3. Inserción, modificación y borrado de datos con PDO . Vamos a ver cómo funciona la clase PDO mediante unos cuantos ejemplos. En primer lugar, lanzaremos una inserción de datos. Imagina que tenemos una base de datos MySQL o MariaDB llamada mi-base-de-datos que contiene una tabla de clientes donde guardamos, entre otras cosas, los nombres y los teléfonos de los clientes. Insertar un registro en esa tabla desde PHP se logra en solo dos pasos: . &lt;?php // Datos de conexión $dsn = \"mysql:host=servidor;dbname=mi-base-de-datos;charset=utf8\"; $usuario = \"nombre-de-usuario\"; $clave = \"password\"; try { // Conexión con PDO $pdo = new PDO($dsn, $usuario, $clave); $pdo-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); // Sentencia preparada para insertar $sql = \"INSERT INTO clientes (nombre, telefono) VALUES (:nombre, :telefono)\"; $stmt = $pdo-&gt;prepare($sql); // Ejecutar la consulta con los valores $stmt-&gt;execute([ \":nombre\" =&gt; $nombre, \":telefono\"=&gt; $telefono ]); echo \"Registro insertado correctamente\"; } catch (PDOException $e) { echo \"Error: \" . $e-&gt;getMessage(); } . Si sustituyes la sentencia INSERT por cualquier otra instrucción SQL válida, también funcionará, con la excepción de SELECT, que se maneja de otra manera que enseguida veremos. Por lo tanto, el código anterior te puede servir de base para ejecutar cualquier INSERT, UPDATE o DELETE sobre tu base de datos. O incluso sentencias de definición de la base de datos, como CREATE TABLE o ALTER TABLE (siempre que el usuario con el que te estés conectando tenga permisos para ejecutarlas, claro) . 1.4.4. Consultas con PDO . Hemos dicho que las sentencias SELECT se lanzan desde PHP de un modo diferente al resto. ¿Por qué será? . La respuesta es sencilla de entender: la ejecución de consultas (SELECT) produce la devolución de un conjunto de registros, mientras que cualquier otra instucción (INSERT, UPDATE, DELETE o lo que sea) no devuelve ningún registro. Los registros obtenidos como resultado de un SELECT se manejan en PHP con un objeto denominado cursor. Un cursor no es más que un puntero al conjunto de resultados que señala al registro que se va a procesar a continuación. Es decir: se parece al cursor de tu procesador de textos, que te indica el lugar en el que vas a insertar o borrar caracteres. En el caso de los cursores MySQL, no te permiten borrar nada. El cursor solo señala un registro concreto dentro de los resultados del SELECT. Observa cómo se hace un SELECT en este ejemplo: . &lt;?php // Datos de conexión $dsn = \"mysql:host=servidor;dbname=database;charset=utf8mb4\"; $usuario = \"user\"; $clave = \"password\"; // Conexión con PDO $pdo = new PDO($dsn, $usuario, $clave); // Ejecutamos la consulta $sql = \"SELECT nombre, telefono FROM Clientes\"; $stmt = $pdo-&gt;query($sql); if ($stmt == false) { die(\"Error en la conexión o en la consulta: \" . $e-&gt;getMessage()); } ?&gt; &lt;table border=\"1\" align=\"center\"&gt; &lt;tr&gt; &lt;th&gt;Nombre&lt;/th&gt; &lt;th&gt;Teléfono&lt;/th&gt; &lt;/tr&gt; &lt;?php while ($cliente = $stmt-&gt;fetch(PDO::FETCH_ASSOC)) { echo \"&lt;tr&gt;\"; echo \"&lt;td&gt;\".$cliente[\"nombre\"].\"&lt;/td&gt;\"; echo \"&lt;td&gt;\".$cliente[\"telefono\"].\"&lt;/td&gt;\"; echo \"&lt;/tr&gt;\"; } ?&gt; &lt;/table&gt; . Probablemente ya lo hayas captado sin necesidad de explicaciones adicionales, pero, por si acaso no es así, ahí va una explicación adicional gratuita. Cuando se lanza una consulta contra una base de datos desde PHP, la base de datos nos devuelve el resultado en un cursor, como hemos dicho. Ese objeto de tipo cursor lo almacenamos en una variable que, en este ejemplo, hemos llamado $stmt (abreviatura de “Statement”). Recuerda que un cursor es un apuntador a un conjunto de resultados. Cuando un cursor está recién abierto, siempre apunta al primer registro de ese conjunto de resultados. Nuestra variable $stmt es un objeto y, como cualquier objeto, contiene una serie de métodos. Entre esos métodos, cualquier cursor siempre nos ofrecerá un método importantísimo llamado fetch(). El método fetch() nos devuelve el siguiente dato almacenado en el cursor (en nuestro caso, un registro completo) y hace avanzar al cursor para que apunte al siguiente dato (en nuestro caso, el siguiente registro). Así, lo deja preparado para recuperar otro registro en la siguiente iteración. Por eso hemos colocado la instrucción fetch() en un bucle. Cuando el cursor está recién abierto, el primer fetch() nos devuelve el primer registro del resultado. Es decir, el primer cliente. Podemos acceder a los campos de ese registro (como “nombre” o “teléfono”) accediendo al registro como si fuera un array ($registro[“nomnre”], $registro[“telefono”], etc). Por eso el método no se llama solo fetch(), sino fetch_array(). Pero fetch() no solo recupera el primer registro, sino que hace avanzar el cursor para que se quede apuntando al segundo. De este modo, en la siguiente iteración del bucle, fetch() nos recupera el segundo registro (el segundo cliente), y el cursor queda apuntando al tercero, listo para la siguiente iteración. Cuando no quedan más registros que procesar, fetch() devuelve false y el bucle termina. De ese modo, habremos procesado fácilmente todo el conjunto de resultados devueltos por la consulta. 1.4.5. Mejorando la implementación de consultas . Podríamos hacer muchas consideraciones adicionales sobre PHP, pero esto solo es una introducción al lenguaje, así que no profundizaremos mucho. Sin embargo, me gustaría que vieras una implementación alternativa del código anterior (PHP es muy flexible y admite muchas maneras de hacer lo mismo), porque ilustra algunas características de PHP que me parece que debes conocer: . &lt;!-- PARTE 1: Lógica de la consulta --&gt; &lt;?php // Configuración de la conexión $dsn = \"mysql:host=servidor;dbname=database;charset=utf8mb4\"; $usuario = \"user\"; $clave = \"password\"; try { // Conexión con PDO $pdo = new PDO($dsn, $usuario, $clave); $pdo-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); // Ejecutamos la consulta $stmt = $pdo-&gt;query(\"SELECT nombre, telefono FROM Clientes\"); $clientes = $stmt-&gt;fetchAll(PDO::FETCH_ASSOC); } catch (PDOException $e) { die(\"Error en la conexión o consulta: \" . $e-&gt;getMessage()); } ?&gt; &lt;!-- PARTE 2: Mostrar los datos de la consulta--&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;Nombre&lt;/th&gt; &lt;th&gt;Teléfono&lt;/th&gt; &lt;/tr&gt; &lt;?php foreach ($clientes as $cliente): ?&gt; &lt;tr&gt; &lt;td&gt;&lt;?= htmlspecialchars($cliente[\"nombre\"]) ?&gt;&lt;/td&gt; &lt;td&gt;&lt;?= htmlspecialchars($cliente[\"telefono\"]) ?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;?php endforeach; ?&gt; &lt;/table&gt; . Este código es funcionalmente idéntico que el que veíamos antes, pero tiene algunas mejoras interesantes en las que quiero que te fijes: . | Separa completamente la lógica del problema (la extracción de datos de la BD) de su presentación. Cuanto menos se mezcle el código PHP con el código HTML, menos confuso será el resultado. Por eso, en esta solución usamos fetchAll() en lugar de fetch(): para mover todo el resultado a un array asociativo (PDO::FETCH_ASSOC), que es un array PHP normal que podemos procesar más adelante, cuando vayamos a mostrarlo. | Utiliza &lt;?= … ?&gt;. Esto es una abreviatura muy habitual de &lt;?php echo(“…”) ?&gt;. | Utiliza $pdo-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION), que fuerza a que PDO lance una excepción si ocurre un error en la consulta. De otro modo, PDO no lanza excepciones, solo devuelve false si la consulta falla. El manejador de excepciones es más seguro y puede tener en cuenta más situaciones de error que la simple comprobación de ese false. | Utiliza htmlspecialchars(). Esto filtra cualquier contenido sospechoso que un atacante malicioso pudiera haber inyectado en tu base de datos, por lo que se considera más seguro que usar solo echo() en aplicaciones web. Imagínate que en la BD alguien hubiera logrado inyectar el código &lt;script&gt;location.href=’miServidor.com’&lt;/script&gt; en el campo teléfono de un usuario. ¿Qué pasaría al tratar de mostrar la lista de usuarios? htmlspecialchars() impedirá la ejecución de ese código malicioso y de cualquier otra cosa sospechosa o mal formada. | . 1.4.6. Formas de hacer fetch . Como has visto en los ejemplos, al hacer fetch() del resultado de una consulta recuperas los datos del siguiente registro, pero esto se puede lograr de varias maneras. En primer lugar, tenemos dos métodos para hacer fetch: . | fetch() recupera el siguiente registro de la consulta. | fetchAll() recupera todos los registros de la consulta. | . Además, tanto a fetch() como a fetchAll() podemos indicarle la forma en la que queremos que se almacenen los datos recuperados en variables PHP. Por ejemplo: . $stmt = $pdo-&gt;query(\"SELECT id, nombre FROM usuarios\"); while ($fila = $stmt-&gt;fetch(PDO::FETCH_ASSOC)) { echo $fila['nombre']; } . Aquí se ha usado fetch(PDO::FETCH_ASSOC), que devuelve los datos de la consulta en un array asociativo con esta forma: . $fila['id'] = Aquí-va-el-ID; $fila['nombre'] = \"Aquí va el nombre\"; . En cambio, podríamos haber recuperado los datos así: . $stmt = $pdo-&gt;query(\"SELECT id, nombre FROM usuarios\"); while ($fila = $stmt-&gt;fetch(PDO::FETCH_NUM)) { echo $fila['nombre']; } . En este caso, fetch(PDO::FETCH_NUM) nos colocará los datos en un array indexado por números, donde la posición 0 es la primera columna, la posición 1 la segunda, etc: . $fila[0] = Aquí-va-el-ID; $fila[1] = \"Aquí va el nombre\"; . Tanto fetch() como fetchAll() admiten, por tanto, varias posibilidades. Estas son las más interesantes, aunque hay más: . | fetch(PDO::FETCH_ASSOC): Devuelve los datos en un array asociativo. | fetch(PDO::FETCH_NUM): Devuelve los datos en un array indexado por números enteros. | fetch(PDO::FETCH_BOTH) (por defecto): Devuelve los datos en un array asociativo y en un array indexado por números enteros, las dos cosas a la vez. | fetch(PDO::FETCH_OBJ): Devuelve los datos en un objeto creado para la ocasión (Los datos serían accesibles como $fila-&gt;nombre, $fila-&gt;id, etc). | fetch(PDO::FETCH_CLASS, NombreClase): Devuelve los datos como instancias de la clase especificada. | . ",
    "url": "https://iescelia.org/docs/fullstack/_site/php/interaccion-con-mysql.html#14-interacci%C3%B3n-entre-mariadb-y-php",
    "relUrl": "/php/interaccion-con-mysql.html#14-interacción-entre-mariadb-y-php"
  },"7": {
    "doc": "1.4 Interacción con la base de datos",
    "title": "1.4 Interacción con la base de datos",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/php/interaccion-con-mysql.html",
    "relUrl": "/php/interaccion-con-mysql.html"
  },"8": {
    "doc": "1.5 Depurando el código PHP con xdebug",
    "title": "1.5. Depurando el código PHP con xdebug",
    "content": ". | 1.5.1. Herramientas estándar de PHP para depuración | 1.5.2. xdebug | 1.5.3. Instalación de xdebug en el servidor | 1.5.4. Instalación de xdebug en el IDE | 1.5.5. Cómo usar xdebug | . Depurar el código PHP es, en principio, una tarea ardua, porque el programa se ejecuta en un servidor y nosotros solo podemos ver el resultado de esa ejecución en un cliente web. Esto significa que, si ocurre un error, nos lo encontraremos mucho después de que haya ocurrido. Es algo así como cuando la policía encuentra los restos de un crimen (el cadáver, algunas huellas y unos cuantos cristales rotos en la habitación) mucho después de que el asesinato haya ocurrido. Hay que ejercer de auténticos detectives para, a partir de esas pistas, tratar de recomponer qué es lo que ha podido suceder en el servidor que ha provocado ese error. PHP ofrece varias funciones estándar para ayudarnos en la depuración pero, como vamos a ver, son bastante primitivas y poco funcionales, aunque pueden servirte en casos sencillos. Cuando la cosa se complica y el origen del error es difícil de rastrear, tendremos que recurrir a métodos más elaborados. Ahí entra en juego xdebug, el depurador más extendido en PHP. 1.5.1. Herramientas estándar de PHP para depuración . Como te decía, el propio lenguaje te ofrece varias funciones estándar para depurar errores. Las dos más utilizadas son: . | echo(): La función de salida estándar de PHP también se usa con propósitos de depuración. De hecho, esto se ha hecho siempre en todos los lenguajes. Simplemente, si un fragmento de tu código PHP está fallando (una función, un método, un módulo o lo que sea), coloca unos cuantos echo() estratégicos para mostrar el valor de tus variables clave, las que pueden estar tomando valores incorrectos. Verás el resultado de esos echo() en tu navegador web y te puede proporcionar información valiosa sobre lo que puede estar sucediendo. | print_r(): La función echo() solo muestra variables simples, pero no objetos o arrays. Si necesitas mostrar el contenido de algo más complejo que una variable simple, puedes usar print_r(), que enviará el contenido de cualquier variable a la salida estándar, por lo que podrás verla en tu navegador web. | var_dump(): Esta función es como print_r(), pero muestra aún más información sobre tu variable, como su tamaño. | . Además de estas funciones, los archivos de registro (logs) de tu servidor pueden mostrarte información importante sobre el error que se haya podido producir. La ubicación de los archivos log es diferente según tu sistema operativo, por lo que tendrás que investigar un poco acerca de qué archivos consultar. En general, hay un montón de archivos log que tu sistema operativo podría estar produciendo, así que lo primero sería averiguar cómo se llaman los archivos de log que produce tu servidor web en concreto. Por ejemplo, Apache en Ubuntu Linux tiene su registro de errores en /var/log/httpd/error_log. Como es imposible proporcionarte una lista de todos los archivos de registro de todos los servidores web en todos los sistemas operativos, tendrás que bichear un poco por Internet para localizar el log de tu servidor en concreto. 1.5.2. xdebug . Todo eso está muy bien, pero tanto las funciones estándar de PHP como los archivos log del servidor nos proporcionan una imagen a posteriori de lo que ha sucedido en el servidor. Es decir, vemos lo que ha ocurrido cuando el programa ya ha finalizado su ejecución, lo que a menudo dificultad localizar los errores. Además, usar funciones como print_r() o var_dump() implica introducir líneas de código de depuración dentro de mi programa. Ese código de depuración, poco a poco, va dejando basura que a veces se nos olvida eliminar. Nada hace peor efecto ante los usuarios que una aplicación web que de pronto muestra la salida de un var_dump() en mitad de una de sus vistas. Bueno, sí: un error de ejecución de PHP hace todavía peor efecto. Por todo ello, sería estupendo poder depurar el código PHP como si se estuviera ejecutando en nuestra máquina, igual que con cualquier otro lenguaje de programación. Eso es posible gracias a xdebug. xdebug es una extensión de PHP que permite al cliente y al servidor comunicarse mediante un protocolo especial para depurar el código que se ejecuta en el servidor. Es decir: nuestro código seguirá ejecutándose en el servidor, pero nuestro cliente (normalmente, nuestro editor de texto o nuestro IDE) podrá pedirle al servidor que lo ejecute paso a paso o que le comunique el valor de cualquier variable en ese momento. 1.5.3. Instalación de xdebug en el servidor . Cómo instalar xdebug en un servidor nativo . Como es una extensión, xdebug no viene de serie y necesita ser instalada en el servidor. La configuración más habitual del servidor web, es decir, un Apache bajo Linux (supondremos que es Debian o Ubuntu), necesita estos pasos para lograr la instalación de xdebug: . | Instalar php-dev, un paquete de herramientas de desarrollo para PHP: $ sudo apt install php-dev | Instalar xdebug a través de composer: $ composer install xdebug | Habilitar el módulo xdebug en nuestro servidor: $ sudo phpenmod xdebug | Reiniciar el servidor: $ sudo service apache2 restart | . Obviamente, estos pasos son diferentes en otros servidores y otros sistemas operativos, incluso en otros sistemas Linux. Es imposible mostrar aquí todas las configuraciones posibles de todos los sistemas, por lo que, nuevamente, tendrás que buscar cuál es la manera de instalar xdebug en tu servidor dependiendo de cuál sea tu configuración exacta. (Incluso es posible que tengas suerte y tu servidor ya tenga xdebug instalado) . Después de habilitar xdebug en tu servidor, puedes comprobar que está funcionando ejecutando phpinfo() en cualquier script o escribiendo $php -i en tu servidor. En ambos casos debería aparecer una sección dedicada a xdebug con información sobre la configuración de esta extensión. Cómo instalar xdebug en el servidor Docker de bitnami . Si estás usando las imágenes Docker de bitnami (ver Apéndice 2), la instalación de la extensión xdebug es aún más simple. Solo tienes que añadir estas líneas a tu archivo custom.ini: . [xdebug] zend_extension=\"/opt/bitnami/php/lib/php/extensions/xdebug.so\" xdebug.mode=debug xdebug.idekey=docker xdebug.start_with_request=yes xdebug.log=/dev/stdout xdebug.log_level=0 xdebug.client_port=9003 xdebug.client_host=&lt;pon-aquí-la-IP-de-tu-ordenador&gt; . Esto lanzará la extensión xdebug dentro del contenedor y la conectará con tu cliente (tu Visual Studio Code o el IDE que estés usando) en el puerto 9003, que es el estándar de Xdebug. Reinicia los contenedores y listo. No dejes de comprobar que xdebug está funcionando haciendo un echo phpinfo() o echo xdebug_info(). 1.5.4. Instalación de xdebug en el IDE . Una vez instalada la extensión xdebug, llega el momento de usarla. xdebug puede integrarse prácticamente con cualquier IDE medianamente decente. Nosotros vamos a ver cómo integrarla con Visual Studio Code, que es probablemente el IDE más utilizado en la actualidad. Si utilizas otro entorno de desarrollo, tendrás que buscar por ahí cómo habilitar xdebug en tu IDE, pero los pasos serán bastante similares a estos: . | Instalar una extensión adecuada para la integración de xdebug con VS Code. La más utilizada es una llamada PHP Debug. | Editar el archivo .vscode/launch.json. Este archivo contiene la configuración de debugging, es decir, la conexión con el componente xdebug de nuestro servidor. | . El archivo launch.json se crea automáticamente al lanzar la extensión PHP Debug en VS Code. Simplemente, haz clic en el botón “Run and Debug” de tu barra izquierda: . Haz clic en “Create a launch.json file”. VSCode te sugerirá algunas plantillas para launch.json. Yo te recomiendo que no utilices ninguna de ellas y que, en su lugar, pongas esto en launch.json: . { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Listen for XDebug on Docker\", \"type\": \"php\", \"request\": \"launch\", \"port\": 9003, \"pathMappings\": { \"/app\": \"${workspaceFolder}\" } } ] } . Esto le indica a VS Code en qué puerto debe comunicarse con Xdebug (el 9003) y en qué directorio del servidor está la aplicación (/app si usas las imágenes de Bitnami, pero tendrás que cambiarlo si usas otras imágenes). ${workspaceFolder} se refiere al directorio local donde está la aplicación. Tendrás que tener abierto VS Code en el directorio raíz de la misma para que funcione. Si algo falla, prueba a poner aquí una ruta absoluta al directorio de tu aplicación. A partir de ahí, podrás depurar tu programa desde el menú “Run”, aunque es conveniente que te aprendas los atajos de teclado para ir más rápido (por ejemplo, F5 lanza el depurador de forma automática). Coloca un breakpoint en algún lugar de tu código. Luego, lanza tu aplicación desde tu navegador web preferido y haz que ejecute ese código. Verás que la ejecución se detiene justo en el breakpoint y VS Code pasa a primer plano, marcándote la línea en la que el programa se ha detenido. Eso significará que el depurador está funcionando perfectamente. 1.5.5. Cómo usar xdebug . Si ya tenemos instalado xdebug en el servidor y lo hemos activado correctamente en nuestro IDE preferido, el proceso de depuración es bastante parecido al de cualquier otro lenguaje de programación. Nuevamente, nos referiremos a VS Code, pero el funcionamiento de xdebug será muy semejante en otros entornos de desarrollo. | Al ejecutar el código, VS Code nos mostrará las opciones para avanzar paso a paso, entrar dentro de funciones, saltar la ejecución de una función, continuar la ejecución sin parar o detener el programa. | Podemos crear puntos de ruptura o breakpoints haciendo click a la izquierda de la línea de código donde queremos detener la ejecución de la aplicación. | Podemos visualizar el valor de cualquier variable en ese instante poniendo el ratón encima de la variable en el propio código fuente. | En el panel izquierdo, podemos acceder a las variables del programa (tanto locales como globales y superglobales) y definir cualquier expresión que queramos que se vaya evaluando en tiempo real (watches). | Desde el mismo panel también se ve cuántas instancias de la aplicación que se está depurando están en marcha. Podemos pararlas, reiniciarlas o continuar la depuración de cada una de ellas de manera independiente. | . Además de estas funciones comunes de depuración, xdebug ofrece muchas funciones avanzadas que nosotros no vamos a ver, pero que puede que te interese usar en el futuro. Por ejemplo, puedes crear diferentes configuraciones de la sesión de debugging en el archivo launch.json para depurar diferentes aplicaciones (no es lo mismo depurar una aplicación web que una aplicación de línea de comandos). Otra función muy interesante de xdebug es la posibilidad de hacer profiling, es decir, un análisis del rendimiento de la aplicación web para detectar posibles problemas de rendimiento o cuellos de botella. Si quieres ampliar la información sobre xdebug, aquí tienes la documentación oficial. ",
    "url": "https://iescelia.org/docs/fullstack/_site/php/depuracion-php-xdebug.html#15-depurando-el-c%C3%B3digo-php-con-xdebug",
    "relUrl": "/php/depuracion-php-xdebug.html#15-depurando-el-código-php-con-xdebug"
  },"9": {
    "doc": "1.5 Depurando el código PHP con xdebug",
    "title": "1.5 Depurando el código PHP con xdebug",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/php/depuracion-php-xdebug.html",
    "relUrl": "/php/depuracion-php-xdebug.html"
  },"10": {
    "doc": "1.6 Cookies y variables de sesión",
    "title": "1.6. Cookies y sesiones",
    "content": ". | 1.6.1. ¿Qué son las cookies? | 1.6.2. Manejando cookies con PHP | 1.6.3. Variables de sesión | 1.6.4. Abrir sesiones: session_start() | 1.6.5. Usar variables de sesión: $_SESSION | 1.6.6. Eliminar variables de sesión: unset() y session_destroy() | 1.6.7. Control de acceso a las aplicaciones web | 1.6.8. Autenticación mediante ACL | . En esta sección vamos a ver qué son las cookies y cómo podemos acceder a ellas para crearlas o manipularlas desde PHP. 1.6.1. ¿Qué son las cookies? . Las cookies son pequeños archivos de texto enviados desde el servidor que se almacenan en el lado del cliente. Es decir, en el navegador. Permiten guardar información de forma persistente, de manera que se mantenga entre una petición al servidor y otra. Una cookie puede estar viva durante minutos, horas, días o incluso indefinidamente. Desde PHP, se pueden usar las cookies usando la función setcookie() y el array global $_COOKIE. Vamos a ver cómo. 1.6.2. Manejando cookies con PHP . Enviar una cookie: setcookie() . Esta función define una cookie que se enviará al cliente junto con el resto de las cabeceras de HTTP. Devuelve true si la cookie se envía con éxito o false en caso contrario. Su sintaxis es: . bool setcookie ( string $name [, string $value [, int $expire = 0 [, string $path [, string $domain [, bool $secure = false [, bool $httponly = false ]]]]]] ) . Las cookies deben enviarse antes de que el programa genere ninguna salida. Esto no es un capricho de PHP, sino una restricción del protocolo http. Por lo tanto, debes llamar a esta función antes de hacer cualquier salida, incluidos espacios en blanco. En caso contrario, la cookie no estará disponible hasta que la página se recargue. La función setcookie() admite un montón de parámetros, la mayor parte de ellos optativos: . | name: El nombre de la cookie. Este es el único obligatorio. | value: El valor de la cookie. | expire: El tiempo que la cookie tardará en expirar. Se trata de una fecha expresada en formato Unix. | path: La ruta del servidor para la que la cookie estará disponible. Si se utiliza ‘/’, la cookie estará disponible en la totalidad del dominio. | domain: El dominio para el cual la cookie está disponible. | secure: Si la cookie solo debería enviarse en caso de conexión https, pon este argument a true. | httponly: Esta cookie solo será accesible a través de http. Es decir, no podrá accederse a la cookie desde Javascript. | . Aquí tienes tres ejemplos de envío de la misma cookie: . &lt;?php $value = \"I'm your father\"; setcookie(\"VaderQuote\", $value); setcookie(\"VaderQuote\", $value, time()+3600); // la cookie expira en una hora setcookie(\"VaderQuote\", $value, time()+3600, \"/quotes/\", \"bestquotes.com\", 1); ?&gt; . Recuperar una cookie: $_COOKIES[] . Para ver el contenido de una cookie, simplemente hay que acceder al array global $_COOKIES. Por ejemplo: . &lt;?php // Imprimir una cookie individual echo $_COOKIE[\"VaderQuote\"]; ?&gt; . Borrar una cookie . Para forzar el borrado de una cookie en el cliente basta con enviarla con una fecha de expiración anterior a la fecha actual. Por ejemplo: . &lt;?php setcookie (\"VaderQuote\", \"\", time() - 3600); // Establece la fecha de expiración una hora en el pasado ?&gt; . 1.6.3. Variables de sesión . Las sesiones de PHP son un mecanismo para que un script almacene variables (llamadas variables de sesión) en el servidor de manera persistente, de modo que posteriores ejecuciones de programas en el servidor solicitadas desde el mismo cliente pueden acceder a esas variables. Es decir: en la práctica, las variables de sesión se comportan como si fueran variables globales a toda la aplicación web. Seguro que te habían dicho que usar variables globales es una mala idea y una pésima práctica de programación. Eso es cierto y, al mismo tiempo, usarlas resulta inevitable. Bienvenido/a al extravagante mundo de las aplicaciones web. Por ese motivo, debe reducirse el uso de las variables de sesión a lo estrictamente imprescindible. ¿Qué cosas resulta útil guardar en variables de sesión? Cosas como el ID o el nombre de un usuario logueado en un sistema o el estado de la aplicación. Poco más. Cosas pequeñas pero tremendamente importantes. Cada cliente tiene su propio espacio de variables de sesión en el servidor, de manera que no se mezclan unas con otras, ni un cliente puede acceder a las variables de otro cliente. La forma en la que PHP logra distinguir a los clientes entre sí es enviándoles, de forma transparente, una cookie con un valor aleatorio distinto para cada cliente. “De forma transparente” significa que ni el programador ni el usuario se enteran de que esa cookie existe: PHP se encarga de hacerlo por su cuenta. En el archivo php.ini se puede configurar la manera en la que PHP almacenará las variables de sesión (en memoria, en un fichero, etc), pero esto es irrelevante de cara a su funcionamiento y compete más al administrador del sistema que al programador. Lo que a nosotros nos interesa es aprender a crear variables de sesión, asignarles valor y recuperarlo posteriormente. 1.6.4. Abrir sesiones: session_start() . Antes de acceder a cualquier variable de sesión (ya sea para crearla, para modificarla o para eliminarla) necesitamos indicarle a PHP que queremos usar variables de sesión en ese programa. La función session_start() se usa para eso: habilita el acceso a las variables de sesión, es decir, crea una nueva sesión o reanuda una sesión preexistente. Las sesiones admiten un nombre, por si necesitas crear sesiones separadas para el mismo cliente. No obstante, la mayor parte de las veces te bastará con crear sesiones sin nombre, sin necesidad de pasar ningún argumento a session_start(). 1.6.5. Usar variables de sesión: $_SESSION . Las variables de sesión se manipulan a través del array superglobal $_SESSION. Si necesitas una variable de sesión llamada, por ejemplo, nombre_usuario, simplemente haz esto: . session_start(); $_SESSION['nombre_usuario'] = \"valor-de-la-variable\"; . Por supuesto, el valor de esa posición del array $_SESSION puede consultarse o modificarse cuando lo necesitemos, porque se trata de un array como otro cualquiera… salvo que es superglobal, es decir, es accesible desde cualquier punto del programa. 1.6.6. Eliminar variables de sesión: unset() y session_destroy() . La función unset() se utiliza para destruir cualquier variable, incluidas las de sesión: . unset($_SESSION['nombre_usuario']); . Si lo que deseas es destruir todas las variables de sesión, es preferible recurrir a session_destroy(). Ahora bien, session_destroy() destruye la información asociada a la sesión actual, pero no elimina realmente las variables de la memoria del servidor ni borra la cookie de sesión del cliente. Si eres un fanático de la seguridad y quieres asegurarte de destruir todas las variables de sesión, puedes usar la función session_unset(). Y, para borrar la cookie de sesión, debes usar setcookie(), como en este ejemplo: . &lt;?php session_start(); // Destruimos todas las variables de sesión (optativo) session_unset(); // Si queremos destruir la sesión completamente, borramos también la cookie de sesión. $params = session_get_cookie_params(); setcookie(session_name(), '', time() - 42000, $params[\"path\"], $params[\"domain\"], $params[\"secure\"], $params[\"httponly\"] ); // Finalmente, cerramos 0la sesión session_destroy(); ?&gt; . 1.6.7. Control de acceso a las aplicaciones web . Cookies y variables de sesión se usan a menudo, por separado o de forma combinada, para controlar el acceso a una aplicación web. Es decir, para hacer el login. En este punto conviene que te hagas esta pregunta: ¿qué significa “loguearse” en una aplicación? . Piénsalo un momento. ¿Qué significa eso realmente? . Por supuesto, implica superar un formulario donde se nos pregunta nuestro nombre de usuario (o nuestro email, o alguna otra identificación) y una contraseña. Pero, si lo superamos, ¿qué sucede entonces? . Autenticarse o “loguearse” en una aplicación significa que esa aplicación cambia de estado y pasa a reconocernos como usuarios registrados. Algo tiene que cambiar dentro de la aplicación, porque a partir de ese momento, y solo para nosotros, se comportará de un modo distinto. Ese “algo” implica que la aplicación recordará quiénes somos nosotros y cuales son nuestros privilegios en la aplicación hasta que cerremos la sesión. Y sobre nosotros puede recordar muchas cosas: el nombre, los apellidos, nuestra foto de perfil… Pero, sobre todas esas cosas, hay una fundamental: nuestro ID de usuario. Todos los usuarios registrados tienen un ID en todos los sistemas. A la aplicación le basta con conocer nuestro ID para recordar quiénes somos. ¿Y cómo “recuerda” una aplicación web un dato como ese? Muy fácil: almacenándolo en una cookie o en una variable de sesión, que son persistentes hasta que el programa decide destruirlas. Es decir, cuando el usuario abandona la aplicación, el programa debe destruir la cookie o destruir la sesión. Justo en este momento hay una cosa que tiene que quedarte muy clara: ¡ninguno de estos métodos es completamente seguro!. Las cookies pueden rastrearse o modificarse en el ordenador del cliente. Además, algunos clientes las tienen desactivadas. ¡No te puedes fiar de ellas! . Las variables de sesión, en principio más seguras, pueden ser atacadas capturando el ID de sesión, como veremos más adelante. El método más seguro, y el más complicado de programar, es el que combina: . | Cookies y/o variables de sesión. | Variables guardadas en una tabla de la BD. | . El uso de frameworks solventes (como Laravel, que estudiaremos más adelante) hace innecesario tomarse este trabajo, puesto que todos habilitan un mecanismo de sesiones seguras que mejora notablemente las prestaciones de las sesiones nativas de PHP. No obstante, en las actividades resueltas y propuestas del final del tema plantearemos una solución para la autenticación de usuarios desarrollada por nosotros mismos y que resultará razonablemente segura. 1.6.8. Autenticación mediante ACL . Casi todas las aplicaciones web, como hemos visto, tienen un subsistema de autenticación de usuarios. El más completo de esos subsistemas es el de las listas de control de acceso (ACL = Access Control List). Ese subsistema suele estar basado en este diseño de base de datos: . Esto significa que necesitas cinco tablas para implementar un ACL completo. Sin embargo, muchas veces tendremos suficiente con solo tres tablas (users, roles y roles-users), o incluso solo con una (users, añadiendo quizá un campo “type”). Optar por una solución más o menos compleja dependerá del tipo de sistema que estemos implementando. En cualquier caso, es conveniente que conozcas el esquema ACL completo (es decir, el de 5 tablas) para que lo pongas en práctica cuando lo necesites. Por eso te lo he presentado. Ahora ya sois oficialmente amigos. ",
    "url": "https://iescelia.org/docs/fullstack/_site/php/cookies-y-sesiones.html#16-cookies-y-sesiones",
    "relUrl": "/php/cookies-y-sesiones.html#16-cookies-y-sesiones"
  },"11": {
    "doc": "1.6 Cookies y variables de sesión",
    "title": "1.6 Cookies y variables de sesión",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/php/cookies-y-sesiones.html",
    "relUrl": "/php/cookies-y-sesiones.html"
  },"12": {
    "doc": "1.7 Arquitectura MVC",
    "title": "1.7. Arquitectura MVC",
    "content": ". | 1.7.1. Arquitectura de aplicaciones | 1.7.2. ¿Qué es la arquitectura MVC? | 1.7.3. MVC en la práctica: una implementación incremental | 1.7.4. El patrón MVC en la teoría . | Endpoints | . | 1.7.5. Una implementación completa: Biblioteca | . La arquitectura MVC es un patrón de software, es decir, una solución probada montones de veces que se adapta bien a muchos problemas diferentes. En este apartado vamos a aprender a aplicar este patrón arquitectónico a nuestras aplicaciones web hechas con PHP. 1.7.1. Arquitectura de aplicaciones . Cuando hablamos de arquitectura de una aplicación nos referimos a la estructura básica que la sustenta, como los pilares de un edificio en construcción. Si quitas las paredes, las ventanas, las puertas, los azulejos de la cocina… todavía pueden distinguirse las formas fundamentales, ¿verdad? . Pues bien, el patrón de arquitectura más popular en aplicaciones web se llama MVC o Modelo-Vista-Controlador. 1.7.2. ¿Qué es la arquitectura MVC? . El MVC es tan solo una arquitectura multicapa estandarizada. Una arquitectura de 3 capas, para ser exactos. Este es el esquema de una arquitectura en 3 capas. Cada capa ejecuta una parte de la solución, y entre ellas colaboran para formar la aplicación completa. La capa superior interactúa con el usuario; la capa inferior, con la máquina (donde dice “hardware”, debería decir “cualquier cosa menos abstracta que nuestro programa”). Tienes permiso para imaginar cada capa como una clase con sus métodos y atributos. Pues bien, si a esas tres capas les ponemos nombres exóticos como modelo, vista y controlador, y tuneamos un poco el esquema, ya lo tenemos: la arquitectura MVC. ¿Y ya está? Bueno, no. Ahora tienes que aprender qué significa en realidad esta palabrería. Porque todo esto está muy bien como construcción teórica, pero ¿cómo te afecta a ti a la hora de programar? ¿Qué clases tienes que crear? ¿Qué parte del código hay que poner en cada clase? . En la práctica, es más simple de lo que parece. Lo vas a ver enseguida. Y lo maravilloso es que muchísimas aplicaciones web encajan como un guante en esta arquitectura. Es decir, apenas tendremos que hacer trabajo de diseño previo, porque, si es una aplicación web, ya sabemos qué clases tendremos que construir: los que nos indique la arquitectura MVC. Antes de pasar a la parte práctica de todo esto, permíteme un breve apunte: por supuesto, nada impide construir arquitecturas con más de 3 capas. De hecho, nosotros vamos a usar una variante del MVC en el que se añade una capa adicional por debajo del modelo, es decir, una arquitectura con 4 capas. Pero ya llegaremos a eso. 1.7.3. MVC en la práctica: una implementación incremental . ATENCIÓN: esta sección es solo para quien esté interesado en comprender más profundamente el patrón MVC. Léela atentamente si es tu caso. Si no, puedes saltar sin problemas al Apartado 1.7.4. Tras esta introducción al MVC, vamos a estudiar a fondo este patrón. Y lo vamos a hacer por medio de un ejemplo, que es como mejor suelen comprenderse estas cosas. Una vez terminado y comprendido el ejemplo, daremos una definición más teórica. Es decir, que lo vamos hacer al revés de lo habitual: primero la práctica y luego la teoría. Según mi experiencia, la gente suele comprenderlo mejor en ese orden. Pero, para que esto funcione, tienes que leer el código fuente con atención. Es un código sencillo y bien comentado, y que se va complicando muy poco a poco, en pasos incrementales, desde un código clásico monolítico hasta una implementación completa de un MVC. Si lo lees con la atención que te pido, verás como, al acabar, entenderás perfectamente en qué consiste el MVC y podrás empezar a aplicarlo en tus proyectos. El ejemplo con el que vamos a trabajar es este: supongamos que queremos programar una pequeña aplicación web que nos permita hacer publicaciones en una especie de blog simplificado. Esas publicaciones se guardan como registros en una tabla de una base de datos. En el código de ejemplo sobre el que vamos a trabajar, nos vamos a centrar en una funcionalidad concreta de este mini-blog: el listado de los artículos existentes en la base de datos. Código monolítico . Una primera aproximación a la solución, sin usar ningún patrón de arquitectura en absoluto, podría ser esta (échale un vistazo y asegúrate de entenderlo): . &lt;? // Conectamos con la base de datos $db = new mysqli('mi-host', 'mi-usuario', 'mi-clave', 'mi-base-de-datos'); // Lanzamos una consulta para recuperar los artículos que haya en la base de datos $res = $db-&gt;query('SELECT fecha, titulo FROM articulo'); ?&gt; // Generamos una tabla HTML con el resultado de la consulta &lt;h1&gt;Listado de Artículos&lt;/h1&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;Fecha&lt;/th&gt; &lt;th&gt;Titulo&lt;/th&gt; &lt;/tr&gt; &lt;?php // Recorremos fila a fila el resultado de la consulta while ($row = $res-&gt;fetch_array()) { echo \"&lt;tr&gt;\"; echo \"&lt;td&gt; \".$row['fecha'].\" &lt;/td&gt;\"; echo \"&lt;td&gt; \".$row['titulo'].\" &lt;/td&gt;\"; echo \"&lt;/tr&gt;\"; } echo \"&lt;/table&gt;\"; // Cerramos la conexión con la BD $db-&gt;close(); ?&gt; . Esta solución se denomina monolítica, porque incluye todo el código necesario en el mismo bloque. Por supuesto, para un ejemplo tan simple como este, el código monolítico es más que suficiente, pero en un sistema más complejo pronto empieza a convertirse en un monstruo inmanejable. Primera mejora: controlador + vista . Vamos a aproximarnos un poco a la solución MVC separando ese código monolítico en dos bloques (que guardaremos en archivos distintos): . | Un controlador (archivo index.php). | Una vista (archivo showAllArticles.php). | . Primero, el controlador. Se encargará de recuperar los datos, pero no de mostrarlos. Generar el interfaz de usuario, es decir, el HTML, será la labor que le dejaremos a la vista. El controlador preparará esos datos y los empaquetará en un array para que estén disponibles en la vista. Y la vista la insertaremos en el controlador con un include(). &lt;? // Este es el controlador. // Como esta aplicación de ejemplo solo realiza una acción, // no usamos de momento la variable \"action\" // Conectamos a la BD y sacamos la lista de artículos $db = new mysqli('mi-host', 'mi-usuario', 'mi-clave', 'mi-base-de-datos'); $res = $db-&gt;query('SELECT fecha, titulo FROM articulo'); // Convertimos la lista de artículos, que es un cursor de MySQL, en un array estándar de PHP $articles = array(); while ($row = $res-&gt;fetch_array()) { $articles[] = $row; } $db-&gt;close(); // Incluimos el código de la vista, donde se usará el array de artículos // para generar la tabla HTML. include('showAllArticles.php'); ?&gt; . La vista que mostrará los datos del array contiene un código muy semejante al de la solución monolítica, solo que ahora estará ubicada en un archivo aparte (showAllArticles.php) y hará un bucle sobre el array de resultados que le ha preparado el controlador: . &lt;h1&gt;Listado de Articulos&lt;/h1&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;Fecha&lt;/th&gt; &lt;th&gt;Titulo&lt;/th&gt; &lt;/tr&gt; &lt;?php foreach($articles as $article) { echo \"&lt;tr&gt; &lt;td&gt;\".$article['fecha'].\"&lt;/td&gt; &lt;td&gt;\".$article['titulo'].\"&lt;/td&gt; &lt;/tr&gt;\"; } ?&gt; &lt;/table&gt; . Segunda mejora: modelo, vista y controlador . En esta segunda mejora, dividiremos el código en tres bloques (ubicados, de nuevo, en archivos diferentes): . | Un modelo para los artíclos (archivo articles.php). Contendrá una clase con un método que se encargará de acceder a la base de datos y empaquetar el resultado de la consulta en un array. | Una vista (archivo showAllArticles.php). Se encargará de generar el HTML con el resultado de la consulta. | Un controlador (archivo index.php). Se encargará de invocar al modelo y a la vista en el orden correcto. | . Por lo tanto, el controlador (index.php), al extraer de él todo lo que tenga que ver con la base de datos, se queda en algo tan sencillo como esto: . include('articles.php'); // En este archivo estará el modelo $articulos = Model::getAll(); // Este método del modelo nos devuelve la lista de artículos include('showAllArticles.php'); // En este archivo estará la vista . El modelo (articles.php) consta de una clase con solo un método (de momento) encargado de consultar todos los artículos y devolverlos empaquetados en un array: . &lt;?php class Articles { public function getAll() { $db = new mysqli('mi-host', 'mi-usuario', 'mi-clave', 'mi-base-de-datos'); $res=$db-&gt;query('SELECT fecha, titulo FROM articulo'); $articles = array(); while ($row = $res-&gt;fetch_array()) { $articles[] = $row; } $db-&gt;close(); return $articles; } } ?&gt; . Por último, la vista (showAllArticles.php) será exactamente igual que en la versión anterior: un recorrido por el array de artículos para mostrarlos en formato HTML: . &lt;h1&gt;Listado de Articulos&lt;/h1&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;Fecha&lt;/th&gt; &lt;th&gt;Titulo&lt;/th&gt; &lt;/tr&gt; &lt;?php foreach($articles as $article) { echo \"&lt;tr&gt; &lt;td&gt;\".$article['fecha'].\"&lt;/td&gt; &lt;td&gt;\".$article['titulo'].\"&lt;/td&gt; &lt;/tr&gt;\"; } ?&gt; &lt;/table&gt; . Tercera mejora: añadiendo capa de abstracción de datos . Como no sabemos lo que es el miedo, vamos a complicar nuestro patrón modelo-vista-controlador con una cuarta capa: la capa de abstracción de datos. La idea de esta capa adicional es proporcionar un mecanismo de abstracción respecto del gestor de base de datos concreto que estemos utilizando. Vaya frasecita, ¿eh? “Un mecanismo de abstracción respecto del gestor de base de datos”. Si no has bizqueado un poco al leerlo, es que tienes los nervios de acero. ¿Qué narices significa eso? . Es solo una de esas expresiones de que los informáticos usamos para fardar, como cuando un médico te dice que estás acatarrado, pero te lo dice en latín para que parezca más complicado de lo que es. Te explico qué es eso del “mecanismo de abstracción bla, bla, bla”. Si te fijas en el modelo de la solución anterior, verás que estamos usando una clase (mysqli) y unos métodos que solo funcionan con MySQL o MariaDB. Si quiséramos cambiar el gestor de base de datos (algo relativamente frecuente), tendríamos que revisar todos nuestros modelos, y tal vez modificar y volver a probar miles de líneas de código. Una forma de independizar nuestra aplicación del gestor de base de datos que haya debajo es programar lo que se llama capa de abstracción que contenga dos o tres métodos genéricos (como consultar() para lanzar SELECT o manipular() para lanzar INSERT, UPDATE o DELETE). De ese modo, cuando queramos hacer una consulta desde el modelo, no lo haremos con los métodos de MySQL (como query(), fetch_array() y similares), sino con los nuestros (consultar(), manipular(), o como los hayamos querido llamar). Si algún día necesitamos cambiar el gestor de base de datos, solo tendremos que reescribir el código de esa capa de abstracción, es decir, un par de decenas de líneas de código frente a varios miles que teníamos que revisar y probar antes. Por lo tanto, en esta tercera mejora vamos a dividir el código en cuatro bloques: . | Un controlador (archivo index.php). | Una vista (archivo view.php). | Un modelo en dos capas: . | Capa de abstracción de datos (db.php) | Capa de acceso a datos (el modelo de artículos propiamente dicho) (articles.php). | . | . El código de la capa de abstracción sería algo así: . class Db { private $db; // Aquí guardaremos la conexión con la base de datos /** * Abre la conexión con la base de datos * @param $server URL del servidor de la base de datos * @param $username Nombre de usuario en ese servidor * @param $pass Contraseña * @param $dbname Nombre de la base de datos * @return 0 si la conexión se realiza con normalidad y -1 en caso de error */ function createConnection($server, $username, $pass, $dbname) { $db = new mysqli($servidor, $usuario, $clave, $dbname); if ($db-&gt;connect_errno) return -1; else return 0; } /** * Cierra la conexión con la base de datos */ function closeConnection() { if ($this-&gt;db) $this-&gt;db-&gt;close(); } /** * Lanza una consulta (SELECT) contra la base de datos. * ¡Ojo! Este método solo funcionará con sentencias SELECT. * @param $sql El código de la consulta que se quiere lanzar * @return Un array bidimensional con los resultados de la consulta (estará vacío si la consulta no devolvió nada) */ function dataQuery($sql) { $res = $this-&gt;db-&gt;query($sql); $resArray = array(); if ($res) { $resArray = $res-&gt;fetch_all(); } return $resArray; } /** * Lanza una sentencia de manipulación de datos contra la base de datos. * ¡Ojo! Este método solo funcionará con sentencias INSERT, UPDATE, DELETE y similares. * @param $sql El código de la consulta que se quiere lanzar * @return El número de filas insertadas, modificadas o borradas por la sentencia SQL (0 si no produjo ningún efecto). */ function dataManipulation($sql) { $this-&gt;db-&gt;query($sql); return $this-&gt;db-&gt;affected_rows; } } . El código del modelo va a hacer uso de la capa de abstracción en lugar de usar los métodos de la clase mysqli directamente: . include \"Db.php\"; class Articles { public function getAll() { $db = new Db(); // Creamos un objeto para usar nuestra capa de abstracción // Conectamos con la BD a través de nuestra capa de abstracción $db-&gt;createConnection('mi-host', 'mi-usuario', 'mi-clave', 'mi-base-de-datos'); // Lanzamos la consulta a través de nuestra capa de abstracción. // Nos devolverá directamente un array estándar de PHP. $articles = $db-&gt;dataQuery('SELECT fecha, titulo FROM articulo'); // Cerramos la conexión con la BD $db-&gt;closeConnection(); return $articles; } } . El controlador y la vista son exactamente los mismos que en la solución anterior, así que no vamos a escribir el código de nuevo. Esto es lógico: solo hemos modificado la forma en la que trabaja el modelo, pero gracias al encapsulamiento de los objetos, el resto de la aplicación no se ha enterado de ello. Cuarta mejora: transformación en clases y objetos reutilizables. Ahora vamos a dejar el código bien organizado y a mostrarlo (casi) completo. Lo que haremos es empaquetarlo todo en clases reutilizables. Observa que sigue siendo el mismo código fuente, solo que empaquetado en clases y métodos. Lo único que queda fuera de una clase es la instanciación inicial del objeto controlador. Fíjate bien en cómo hemos convertido las vistas en una clase con un método show() que nos servirá para mostrar cualquier vista y reutilizar el mismo header y el mismo footer. Cada vista se programará en un archivo independiente que deberemos organizar en directorios y subdirectorios. De momento, nuestra aplicación solo tiene una vista llamada showAllArticles, pero se podrían visualizar todas las necesarias usando el método show(). Otra cosa que quiero que observes con mucha atención es el punto de entrada a la aplicación (archivo index.php), porque lo hemos dejado preparado para poder añadir nuevas funciones al programa con posterioridad, así como varios controladores. El método que se ejecutará dependerá no solo de la variable “action” que se pasa por GET, sino también de otra variable llamada “controller”, que también se pasa por GET, y que contendrá el nombre de la clase del controlador. Así, para invocar, por ejemplo, el método showAll() del controlador ArticlesController, la ruta debería ser esta: . http://mi-servidor/index.php?controller=ArticlesController&amp;action=showAll . Este index.php es tan genérico que te puede servir para montar otras aplicaciones MVC. Punto de entrada a la aplicación (enrutador) (index.php) . &lt;?php include(\"articlesController.php\"); // Miramos a ver si se indica alguna acción en la URL if (!isset($_REQUEST['action'])) { // No hay acción en la URL. Usamos la acción por defecto (main). Puedes cambiarla por cualquier otra que vaya bien con tu aplicación. $action = \"main\"; } else { // Sí hay acción en la URL. Recuperamos su nombre. $action = $_REQUEST['action']; } // Hacemos lo mismo con el nombre del controlador if (!isset($_REQUEST['controller'])) { // No hay controlador en la URL. Asignaremos un controlador por defecto (Articles). Por supuesto, puedes cambiarlo por otro que vaya bien con tu aplicación. $controllerClassName = \"ArticlesController\"; } else { // Sí hay controlador en la URL. Recuperamos su nombre. $controllerClassName = $_REQUEST['controller']; } // Instanciamos el controlador e invocamos al método que se llama como la acción $controller = new $controllerClassName(); $controller-&gt;$action(); ?&gt; . Controlador de artículos (articlesController.php) . // Controlador. Debería tener un método por cada posible valor de la variable \"action\". include (\"view.php\"); include (\"articles.php\"); class ArticlesController { public function showAll() { $data['articles'] = Articles::getAll(); View::show(\"showAllArticles\", $data); } // Añadir a partir de aquí un método por cada posible valor de la variable \"action\" } . Clase vista (view.php) . &lt;?php class View { public function show($viewName, $data=null) { include(\"header.php\"); include(\"$viewName.php\", $data); include(\"footer.php\"); } } ?&gt; . Vista showAllArticles (showAllArticles.php) . &lt;h1&gt;Listado de Articulos&lt;/h1&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;Fecha&lt;/th&gt; &lt;th&gt;Titulo&lt;/th&gt; &lt;/tr&gt; &lt;?php $articles = $data['articles']; foreach($articles as $article) { echo \"&lt;tr&gt; &lt;td&gt;\".$articles['fecha'].\"&lt;/td&gt; &lt;td&gt;\".$articles['titulo'].\"&lt;/td&gt; &lt;/tr&gt;\"; } ?&gt; &lt;/table&gt; . Modelo - Capa de acceso a datos (articles.php) . include \"db.php\"; class Articles { public function getAll() { $db = new Db(); $db-&gt;createConnection('mi-host', 'mi-usuario', 'mi-clave', 'mi-base-de-datos'); $articles = $db-&gt;dataQuery('SELECT fecha, titulo FROM articulo'); $db-&gt;closeConnection(); return $articles; } } . Modelo - Capa de abstracción de datos (db.php) . class Db { private $db; // Aquí guardaremos la conexión con la base de datos /** * Abre la conexión con la base de datos * @param $server URL del servidor de la base de datos * @param $username Nombre de usuario en ese servidor * @param $pass Contraseña * @param $dbname Nombre de la base de datos * @return 0 si la conexión se realiza con normalidad y -1 en caso de error */ function createConnection($server, $username, $pass, $dbname) { $db = new mysqli($servidor, $usuario, $clave, $dbname); if ($db-&gt;connect_errno) return -1; else return 0; } /** * Cierra la conexión con la base de datos */ function closeConnection() { if ($this-&gt;db) $this-&gt;db-&gt;close(); } /** * Lanza una consulta (SELECT) contra la base de datos. * ¡Ojo! Este método solo funcionará con sentencias SELECT. * @param $sql El código de la consulta que se quiere lanzar * @return Un array bidimensional con los resultados de la consulta (estará vacío si la consulta no devolvió nada) */ function dataQuery($sql) { $res = $this-&gt;db-&gt;query($sql); $resArray = array(); if ($res) { $resArray = $res-&gt;fetch_all(); } return $resArray; } /** * Lanza una sentencia de manipulación de datos contra la base de datos. * ¡Ojo! Este método solo funcionará con sentencias INSERT, UPDATE, DELETE y similares. * @param $sql El código de la consulta que se quiere lanzar * @return El número de filas insertadas, modificadas o borradas por la sentencia SQL (0 si no produjo ningún efecto). */ function dataManipulation($sql) { $this-&gt;db-&gt;query($sql); return $this-&gt;db-&gt;affected_rows; } } . Quinta (y última) mejora: añadiendo un modelo genérico . En todos los modelos nos solemos encontrar una serie de operaciones que se repiten una y otra vez, como: . | Obtener todos los registros de una tabla. | Obtener un registro de una tabla buscando por id. | Borrar un registro a partir de su id. | Insertar un registro. | Modificar un registro. | . Podemos programar un modelo genérico que haga estas cosas sea cual sea la tabla de la que se trate. Así no tendremos que escribir una y otr avez las mismas operaciones para cada uno de los modelos: bastará con que nuestros modelos hereden de este modelo genérico, y todas esas operaciones ya estarán disponibles sin escribir ni una línea de código. Vamos a llamar Model a ese modelo genérico. Observa bien el siguiente código: . Modelo genérico (model.php) . class Model { protected $table; // Aquí guardaremos el nombre de la tabla a la que estamos accediendo private $db; // Y aquí la capa de abstracción de datos public function __construct($tableName) { $this-&gt;table = $tableName; $this-&gt;db = new Db(); $this-&gt;db-&gt;createConnection('mi-host', 'mi-usuario', 'mi-clave', 'mi-base-de-datos'); } public function getAll() { $list = $this-&gt;db-&gt;dataQuery('SELECT * FROM '.$this-&gt;table); $db-&gt;closeConnection(); return $list; } } . ¡Acabamos de crear un método getAll() genérico que funcionará con cualquier tabla! . Mira ahora en qué poquita cosa se queda nuestro modelo Articles: . include \"db.php\"; class Articles extends Model { public __construct() { $this-&gt;table = \"articles\"; } } . Como el modelo Articles hereda ahora del modelo genérico, Model, resulta que ya posee un método llamado getAll() que, por lo tanto, no tenemos que programar. A cambio, todo lo que tenemos que hacer es asignar el valor correcto al atributo $this-&gt;table, para que el modelo genérico Model sepa el nombre de la tabla con la que tiene que trabajar. Si ampliásemos nuestro modelo genérico, Model, con más funciones genéricas, todas ellas se heredarían en Articles (y en cualquier otro modelo de la aplicación). Las únicas funciones que tendríamos que escribir en Articles serían las específicas de ese modelo, si es que tiene alguna. Por experiencia, te puedo decir que la mayoría de los modelos no necesitarán ninguna función específica adicional, quedando así su código reducido a la mínima expresión. Vamos a añadir algunas funciones más a nuestro modelo genérico: . class Model { protected $table; // Aquí guardaremos el nombre de la tabla a la que estamos accediendo private $db; // Y aquí la capa de abstracción de datos public function __construct($tableName) { $this-&gt;table = $tableName; $this-&gt;db = new Db(); $this-&gt;db-&gt;createConnection('mi-host', 'mi-usuario', 'mi-clave', 'mi-base-de-datos'); } public function getAll() { $list = $this-&gt;db-&gt;dataQuery(\"SELECT * FROM \".$this-&gt;table); return $list; } public function get($id) { $record = $this-&gt;db-&gt;dataQuery(\"SELECT * FROM \".$this-&gt;table.\" WHERE id = \".$id); return $record; } public function delete($id) { $result = $this-&gt;db-&gt;dataQuery(\"DELETE FROM \".$this-&gt;table.\" WHERE id = \".$id); return $result; } } . Solo faltaría crear una función insert() y otra update() para tener un CRUD completo en nuestro modelo genérico. ¿Te atreves a hacerlo? (Advertencia: generalizar estas dos funciones es bastante más difícil que todas las demás). ",
    "url": "https://iescelia.org/docs/fullstack/_site/php/mvc/#17-arquitectura-mvc",
    "relUrl": "/php/mvc/#17-arquitectura-mvc"
  },"13": {
    "doc": "1.7 Arquitectura MVC",
    "title": "1.7.4. El patrón MVC en la teoría",
    "content": "Ahora que hemos aprendido a manejarnos con el patrón MVC por medio de un ejemplo, estamos en condiciones de definirlo de manera más teórica y entender mejor esa defición. (Si no has leído el ejemplo práctico del Apartado 1.7.3, es posible que las siguientes definiciones no acaben de tener sentido para ti. No te preocupes, lo irás pillando más adelante conforme practiques con el patrón MVC). El patrón MVC consiste, pues, en dividir la aplicación en tres capas: . | Los modelos, donde se programa la lógica de negocio. De esa forma tan rimbombante se refiere la literatura técnica al acceso a los datos con los filtros, algoritmos y restricciones que el sistema imponga. Dicho en palabras más sencillas, esto significa que en los modelos debemos colocar todo el código de acceso a la base de datos o a cualquier otro recurso del servidor (como las variables de sesión, por ejemplo). Los modelos deben empaquetar esos datos en objetos estándar de PHP (como arrays) y devolverlos al controlador. Lo más práctico es crear un modelo para cada tabla maestra de la base de datos. Los frameworks automatizan los métodos más típicos de cada modelo, como insertar un registro, borrar, actualizar, consultar uno o consultar todos. Ya veremos de qué formas tan alucinantes se las ingenian para hacer todo esto con un mínimo de esfuerzo por nuestra parte y, por supuesto, sin escribir el mismo código una y otra vez. | Las vistas, donde se programan todas las salidas HTML que el usuario final va a ver y con las que va a interactuar. El código Javascript y CSS, por lo tanto, forma parte de las vistas. En las vistas estará el grueso del código de cualquier aplicación. Los frameworks más avanzados incluyen sistemas de plantillas para reutilizar fragmentos de vistas, así como lenguajes adicionales para simplificar la codificación de las vistas. Pero, si programamos en PHP clásico, tendremos que construir las vistas manualmente. | Los controladores, donde se captura cada petición del usuario y se dirige el flujo de ejecución, invocando a los modelos y a las vistas en el orden adecuado. En una aplicación pequeña, bastará con tener un controlador para todo. Cuando la aplicación crece, suele hacerse un controlador por cada modelo, es decir, un controlador por cada tabla maestra. Los controladores estarán compuestos por una colección de métodos, uno para cada funcionalidad de la aplicación. El método que se ejecute en cada ocasión estará controlado por la URL. En concreto, por la variable “action” que se pasará por GET, aunque, por supuesto, puedes ponerle otro nombre si “action” no te gusta. En los frameworks, esta variable “action” se transforma en una URL limpia que, a través de un objeto adicional llamado enrutador, termina provocando la invocación del método adecuado. Es decir: en una aplicación MVC como las que hemos visto hasta ahora, tendremos una ruta como esta para, por ejemplo, consultar el artículo con id 37: . https://mi-servidor/index.php?action=showArticle&amp;idArticle=37 . | . Endpoints . Los endpoints son las URLs a las que una aplicación o servicio web responde. Hay un número limitado de maneras de invocar a la aplicación web de manera que esta responda adecuadamente. El resto de peticiones al servidor provocarán (o deberían provocar) un error de “página no encontrada”. Esto es un endpoint de nuestra aplicación MVC “casera”: . https://mi-servidor/index.php?action=showArticle&amp;idArticle=37 . Pero los endpoints no suelen tener un aspecto tan feo como ese. Esto es propio de aplicaciones web antiguas, hechas con PHP clásico y, aunque todavía encontrarás muchas aplicaciones así, la mayor parte de las aplicaciones y servicios web modernos usar endpoints limpios y con significado por sí mismos, lo que no solo es una mejora estética, sino que resulta más flexible y escalable, además de beneficiar el posicionamiento del sitio web. De hecho, existen maneras estandarizadas de construir los endpoints. Cuando aprendamos a usar un framework avanzado (como Laravel), nuestros endpoints tendrán un aspecto mucho más limpio para hacer lo mismo. Algo así como: . https://mi-servidor/articles/show/37 . Y el enrutador del framework se encargará trocear esa URL y extraer de ella la información para instanciar el controlador adecuado y llamar al método correcto. ",
    "url": "https://iescelia.org/docs/fullstack/_site/php/mvc/#174-el-patr%C3%B3n-mvc-en-la-teor%C3%ADa",
    "relUrl": "/php/mvc/#174-el-patrón-mvc-en-la-teoría"
  },"14": {
    "doc": "1.7 Arquitectura MVC",
    "title": "1.7.5. Una implementación completa: Biblioteca",
    "content": "A continuación encontrarás una posible implementación de una Biblioteca hecha con PHP clásico, sin ningún framework. La implementación sigue la arquitectura MVC, pero ten en cuenta que solo es una primera aproximación que se puede mejorar en muchos aspectos, como, por ejemplo: . | La creación de un enrutador. | Un mecanismo de control de acceso de usuarios. | La creación de una capa de abstracción de datos que independice los modelos de la base de datos. | La creación de un modelo genérico (del que herdarían el resto de modelos), que implementaría los métodos que aparecen la mayoría de los modelos, como get($id), getAll(), delete($id), etc. | Controladores múltiples (uno por modelo) | Archivo de configuración con los datos de conexión a la base de datos, para poder cambiarlos con facilidad y sin tocar el código de los modelos. | . Como ves, es una solución imperfecta en muchos sentidos, pero ilustra bastante bien los principios del MVC. Esta biblioteca, además, es una simplificación de una biblioteca real. Por el momento, lo único que puede hacer es el mantenimiento de los libros (dar de alta nuevos libros, modificarlos, borrarlos, buscarlos, etc) y de los autores. La hemos mantenido sencilla para que sea más fácil de seguir y el volumen del código no se dispare, pero es completamente funcional, y puedes añadirle nuevas funciones si quieres. Haz clic aquí para acceder al código fuente de la biblioteca . ",
    "url": "https://iescelia.org/docs/fullstack/_site/php/mvc/#175-una-implementaci%C3%B3n-completa-biblioteca",
    "relUrl": "/php/mvc/#175-una-implementación-completa-biblioteca"
  },"15": {
    "doc": "1.7 Arquitectura MVC",
    "title": "1.7 Arquitectura MVC",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/php/mvc/",
    "relUrl": "/php/mvc/"
  },"16": {
    "doc": "1.8 Ejemplos resueltos",
    "title": "1.8. Ejemplos resueltos",
    "content": ". | 1.8.1. Tabla de multiplicar | 1.8.2. Juego del número secreto | 1.8.3. Lista de libros | 1.8.4. Biblioteca | . Ya hemos visto cómo es el lenguaje PHP y cómo se puede acceder desde él a una base de datos externa para almacenar o recuperar información de ella. También cómo se puede estructurar el código con la arquitectura MVC. Aquí encontrarás todo eso aplicado a algunos supuestos prácticos, es decir, ejemplos de aplicaciones web programadas con PHP sin niguna librería ni framework adicional. Mira con detenimiento el código y asegúrate de comprenderlo. Para empezar a programar con PHP, no hay nada mejor que echar un vistazo a algunos programas fáciles que luego puedas utilizar como plantilla para los tuyos. Eso sí, es imprescindible que, después, dediques un tiempo a tratar de escribir tú mismo/a tus propios programas sencillos. Al final de este tema te propondremos algunos, aunque tú puedes cambiarlos por otros que te apetezcan más. Lo importante es que recuerdes siempre algo que parece obvio pero que, a menudo, la gente olvida: a programar solo puede aprenderse programando. 1.8.1. Tabla de multiplicar . Vamos a escribir un programa en PHP que pida un número al usuario y muestre su tabla de multiplicar hasta el 25 en una tabla HTML de 5 por 5 casillas. El usuario escribirá el número en un formulario HTML. Solución 1: con dos archivos fuente . Esta primera solución la vamos a plantear con dos archivos: . | index.php: contendrá el formulario en el que vamos a pedir al usuario que escriba un número. En el action del formulario, pondremos el nombre del segundo archivo para enviarle el número. | tabla.php: recibirá el número escrito en el formulario y calculará la tabla de multiplicar, escribiendo la salida en formato HTML. | . ARCHIVO index.php . &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Tabla de multiplicar - Versión 1&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action='tabla.php' method='GET'&gt; Introduce un número: &lt;input type='text' name='numero'&gt; &lt;br&gt; &lt;input type='submit'&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; . ARCHIVO tabla.php . &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Tabla de multiplicar - Versión 1&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php // Recuperamos el número escrito en el formulario. $n = $_REQUEST[\"numero\"]; // Mostramos la tabla de multiplicar en una tabla HTML echo \"&lt;table border='1'&gt;\"; echo \"&lt;tr&gt;&lt;td colspan='5'&gt;Tabla de multiplicar del número $n&lt;/td&gt;&lt;/tr&gt;\"; echo \"&lt;tr&gt;\"; for ($i = 1; $i &lt;= 25; $i++) { if (($i-1) % 5 == 0) echo \"&lt;/tr&gt;&lt;tr&gt;\"; echo \"&lt;td&gt;$n x $i = \" . $n * $i . \"&lt;/td&gt;\"; } echo \"&lt;/tr&gt;\"; echo \"&lt;/table&gt;\"; ?&gt; &lt;/body&gt; &lt;/html&gt; . Solución 2: con un solo archivo . Vamos a mejorar la solución anterior uniendo todo el código en un solo archivo, que podemos llamar index.php. Eso signfica que, ahora, en el action del formulario, escribiremos index.php, de modo que, al pulsar submit, el número se enviará al mismo programa. Es decir, index.php se ejecutará dos veces: una para mostrar el formulario y otra para calcular la tabla de multiplicar. Observa como se usa la función isset() para averiguar en cuál de esas dos ejecuciones estamos. Esta función recibe como parámetro una variable y nos dice si esa variable existe o, por el contrario, si no ha sido declarada ni inicializada aún. &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Tabla de multiplicar - Versión 2&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php if (!isset($_REQUEST[\"numero\"])) { // Si no tenemos un número pasado por GET, significa que estamos en la primera ejecución, // así que mostramos el formulario echo \"&lt;form action='index.php' method='GET'&gt; Introduce un número: &lt;input type='text' name='numero'&gt; &lt;br&gt; &lt;input type='submit'&gt; &lt;/form&gt;\"; } else { // Ya tenemos número pasado por GET. Vamos a calcular su tabla de multiplicar. $n = $_REQUEST[\"numero\"]; echo \"&lt;table border='1'&gt;\"; echo \"&lt;tr&gt;&lt;td colspan='5'&gt;Tabla de multiplicar del número $n&lt;/td&gt;&lt;/tr&gt;\"; echo \"&lt;tr&gt;\"; for ($i = 1; $i &lt;= 25; $i++) { if (($i-1) % 5 == 0) echo \"&lt;/tr&gt;&lt;tr&gt;\"; echo \"&lt;td&gt;$n x $i = \" . $n * $i . \"&lt;/td&gt;\"; } echo \"&lt;/tr&gt;\"; echo \"&lt;/table&gt;\"; } ?&gt; &lt;/body&gt; &lt;/html&gt; . 1.8.2. Juego del número secreto . Vamos a escribir una aplicación web en PHP para jugar al juego del número secreto. Es un juego clásico que consiste en lo siguiente: el ordenador elegirá un número al azar entre 1 y 100 y el jugador tendrá que averiguarlo. Cada vez que el jugador haga un intento, la aplicación le indicará si el número secreto es mayor o menor que el número introducido. Cuando el jugador por fin acierte, la aplicación le dará la enhorabuena y le indicará cuántos intentos ha necesitado para averiguar el número secreto. Vamos a ver dos soluciones para este programa. En la primera, utilizaremos las variables de la URL para mantener vivos los datos del programa. En la segunda, utilizaremos variables de sesión para lograr el mismo efecto de forma mucho más limpia. Juego del número secreto: solución sin variables de sesión . Este juego necesita que algunas variables, como el número secreto (variable $aleatorio) o el número de intentos (variable $intentos) persistan entre una solicitud al servidor y la siguiente. Para lograrlo, haremos que el script se envíe a sí mismo el valor de esas variables en la última línea. Supondremos que el archivo se llama index.php. Esta es una solución muy poco elegante, un estilo de programación de aplicaciones web que se dejó de usar hace años, pero que ilustra perfectamente cuál es el primer problema al que nos enfrentamos al desarrollar aplicaciones web: que se ejecutan en el servidor “a tirones”, un trozo cada vez, y para el servidor cada uno de esos trozos es un programa independiente, aunque el usuario tenga la sensación de que forman una aplicación coherente. &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Juego del número secreto&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php // Primero, comprobamos su ya existe la variable \"numero\" en la URL. // Si no existe, significa que el usuario tiene que escribir un número: tenemos que mostrarle el formulario. // Si ya existe, significa que el usuario ha escrito algún número y tenemos que comprobar si coincide con el aleatorio. if (!isset($_REQUEST['numero'])) { // La variable \"numero\" NO existe. Vamos a pedirle que lo escriba en un formulario // ¿Y el número aleatorio? Si aún no existe, significa que es LA PRIMERA ejecución y aún tenemos que elegirlo. // En cambio, si ya existe, tendremos que recuperarlo para seguir usando el mismo aleatorio y no uno nuevo cada vez. if (!isset($_REQUEST['aleatorio'])) { $intentos = 0; $aleatorio = rand(1,100); } else { $aleatorio = $_REQUEST['aleatorio']; $intentos = $_REQUEST['intentos']; } echo \"&lt;form action='numsecreto.php' method='get'&gt; Adivina mi número: &lt;input type='text' name='numero'&gt;&lt;br&gt; &lt;input type='hidden' name='aleatorio' value='$aleatorio'&gt; &lt;input type='hidden' name='intentos' value='$intentos'&gt; &lt;br&gt; &lt;input type='submit'&gt; &lt;/form&gt;\"; } else { // La variable \"numero\" existe. Eso indica que el usuario escribió un número en el formulario. // Vamos a recuperar ese número y a compararlo con el aleatorio. $n = $_REQUEST['numero']; $aleatorio = $_REQUEST['aleatorio']; $intentos = $_REQUEST['intentos']; $intentos++; echo \"Tu número es: $n&lt;br&gt;\"; if ($n &gt; $aleatorio) { echo \"Mi número es MENOR\"; } else if ($n &lt; $aleatorio) { echo \"Mi número es MAYOR\"; } else { echo \"&lt;p&gt;ENHORABUENA, HAS ACERTADO&lt;/p&gt;\"; echo \"Has necesitado $intentos intentos\"; } // Volvemos a llamar a este mismo programa, pasándole como variables de URL el aleatorio // y el número de intentos, para seguir jugando con el mismo número secreto. echo \"&lt;br&gt;&lt;a href='numsecreto.php?aleatorio=$aleatorio&amp;intentos=$intentos'&gt;Sigue jugando...&lt;/a&gt;\"; } ?&gt; . Juego del número secreto: solución con variables de sesión . En esta solución, se ha sustituido la chapuza de las variables pasadas por URL por variables de sesión. Aunque las veremos con más detalle en el siguiente tema, te puedo adelantar que las variables de sesión permiten almacenar datos persistentes entre sucesivas ejecuciones de scripts desde el mismo cliente. Es decir, el servidor recuerda el valor de determinadas variables para que ese programa ejecutado a tirones se comporte como un todo unificado de cara al usuario. Observa detenidamente cómo se usan las variables de sesión con PHP mediante el array global $_SESSION para obtener una solución más elegante que la anterior. &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Juego del número secreto&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php session_start(); // Primero, comprobamos su ya existe la variable \"numero\" en la URL. // Si no existe, significa que el usuario tiene que escribir un número: tenemos que mostrarle el formulario. // Si ya existe, significa que el usuario ha escrito algún número y tenemos que comprobar si coincide con el aleatorio. if (!isset($_REQUEST['numero'])) { // La variable \"numero\" NO existe. Vamos a pedirle que lo escriba en un formulario // ¿Y el número aleatorio? Si aún no existe, significa que es LA PRIMERA ejecución y aún tenemos que elegirlo. // En cambio, si ya existe, tendremos que recuperarlo para seguir usando el mismo aleatorio y no uno nuevo cada vez. if (!isset($_SESSION['aleatorio'])) { $_SESSION[\"intentos\"] = 0; $_SESSION[\"aleatorio\"] = rand(1,100); } echo \"&lt;form action='numsecreto.php' method='get'&gt; Adivina mi número: &lt;input type='text' name='numero'&gt;&lt;br&gt; &lt;br&gt; &lt;input type='submit'&gt; &lt;/form&gt;\"; } else { // La variable \"numero\" existe. Eso indica que el usuario escribió un número en el formulario. // Vamos a recuperar ese número y a compararlo con el aleatorio. $n = $_REQUEST['numero']; $_SESSION[\"intentos\"]++; echo \"Tu número es: $n&lt;br&gt;\"; if ($n &gt; $_SESSION[\"aleatorio\"]) { echo \"Mi número es MENOR\"; } else if ($n &lt; $_SESSION[\"aleatorio\"]) { echo \"Mi número es MAYOR\"; } else { echo \"&lt;p&gt;ENHORABUENA, HAS ACERTADO&lt;/p&gt;\"; echo \"Has necesitado \".$_SESSION[\"intentos\"].\" intentos\"; } // Volvemos a llamar a este mismo programa, pasándole como variables de URL el aleatorio // y el número de intentos, para seguir jugando con el mismo número secreto. echo \"&lt;br&gt;&lt;a href='numsecreto.php'&gt;Sigue jugando...&lt;/a&gt;\"; } ?&gt; . 1.8.3. Lista de libros . Aquí tienes un ejemplo sencillo de conexión con una base de datos MySQL o MariaDB para: a) consultar datos y b) insertar datos. Puedes usarlo como modelo para construir tus primeras interacciones con la base de datos mediante PDO: . &lt;?php $dsn = \"mysql:host=mariadb;dbname=pruebas;charset=utf8mb4\"; $usuario = \"user\"; $clave = \"1234\"; // Conexión con la BD try { $bd = new PDO($dsn, $usuario, $clave); } catch (PDOException $e) { die(\"Error en la conexión: \" . $e-&gt;getMessage()); } // Consulta $sql = \"SELECT * FROM libros\"; $stmt = $bd-&gt;query($sql); while ($libro = $stmt-&gt;fetch(PDO::FETCH_ASSOC)) { echo $libro[\"titulo\"].\"&lt;br&gt;\"; } // Inserción (modificación o borrado se harían de forma parecida) $sql_insert = \"INSERT INTO libros (titulo, genero, numPaginas, pais, ano) VALUES (:titulo, :genero, :numPaginas, :pais, :ano)\"; $stmt_insert = $bd-&gt;prepare($sql_insert); $valores = [ 'titulo' =&gt; 'Nuevo libro', 'genero' =&gt; 'Género desconocido', 'numPaginas' =&gt; 900, 'pais' =&gt; 'España', 'ano' =&gt; 2025 ]; if ($stmt_insert-&gt;execute($valores)) { echo \"Libro insertado correctamente.\"; } else { echo \"Error al insertar el libro.\"; } . 1.8.4. Biblioteca . Este es un caso práctico importante porque es la primera aplicación web “de verdad”, con una base de datos detrás y una estructura MVC, que vamos a ver. La aplicación web gestiona, de forma muy simplificada, una biblioteca. Trabaja con una base de datos compuesta de tres tablas (ya dije que estaría muy simplificada): libros, autores y escriben. Esta última es una tabla pivote, es decir, es la tabla que implementa la relación N:N entre libros y autores. La aplicación permite ver la lista de todos los libros disponibles, así como dar de alta libros nuevos y modificar o borrar los libros existentes. Lo mismo sucede con los autores. Por último, permite asociar autores a los libros (es decir, insertar datos en la tabla pivote escriben). El código tiene una arquitectura modelo-vista-controlador MVC mejorable, pero que sirve como primera aproximación válida a este patrón de diseño de software. Hemos usado un solo controlador (que también hace labores de enrutamiento), pero sería fácil dividirlo en varios. Haz clic aquí para acceder al código fuente de la biblioteca . ",
    "url": "https://iescelia.org/docs/fullstack/_site/php/ejemplos-resueltos.html#18-ejemplos-resueltos",
    "relUrl": "/php/ejemplos-resueltos.html#18-ejemplos-resueltos"
  },"17": {
    "doc": "1.8 Ejemplos resueltos",
    "title": "1.8 Ejemplos resueltos",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/php/ejemplos-resueltos.html",
    "relUrl": "/php/ejemplos-resueltos.html"
  },"18": {
    "doc": "1.9 Prácticas",
    "title": "1.9. Prácticas",
    "content": "Los siguientes son una colección de prácticas de programación que funcionan exactamente igual que los ejercicios en el gimnasio: para fortalecer tu musculatura como programador o programadora. E igual que los ejercicios en el gimnasio, estos requerirán de ti dedicación, esfuerzo y constancia. Pero por eso estás aquí, ¿no es cierto? Recuerda lo que hemos dicho muchas veces: a programar solo se aprende programando. Ejercicio 0: hola, mundo . Este ejercicio lo usaremos para probar la correcta puesta en marcha de nuestro servidor web local. Tienes dos opciones, como mínimo, para poner en marcha el servidor local: . | Instalar un servidor nativo: instala un paquete como XAMPP o instala manualmente Apache y MariaDB en tu sistema operativo. Luego ve al directorio htdocs de tu Apache y escribe un programa “holamundo.php” | Lanzar un servidor virtualizado con Docker (RECOMENDADO): baja y configura las imágenes para Apache, MariaDB y PHP. Lánzalas y pruébalas con un programa “holamundo.php”. Tienes toda la información sobre cómo hacerlo en el Apéndice 2. | . Para hacer el resto de ejercicios y prácticas, puedes usar cualquiera de los dos servidores. Ejercicio 1: comparar números . Vamos a hacer un primer ejercicio muy, muy sencillo para que te vayas soltando con la sintaxis de PHP y la forma de trabajar en el servidor. Tienes que escribir un programa en PHP que: . | Pida dos números al usuario a través de un formulario HTML. | Los compare para ver cuál es el menor de los dos. | Muestre todos los números que hay entre el menor y el mayor. | . Ejercicio 2: anagramas . Una palabra es un anagrama de otra si contiene las mismas letras colocadas en orden diferente. Por ejemplo, “CAVA” es un anagrama de “VACA”, y viceversa. El ejercicio consiste en escribir un programa en PHP que pida al usuario dos palabras y compruebe si la primera es un anagrama de la segunda. Para ello necesitarás: . | Crear un formulario HTML con un campo de texto y un botón de envío. | Procesar el formulario en otro archivo PHP (usa $_GET y $_POST para probar ambos métodos). | Añadir validaciones básicas (por ejemplo, que el campo no esté vacío). | . Ejercicio 3: conexión básica a una base de datos . | Crea una base de datos MySQL o MariaDB con una tabla usuarios(id#, nombre, email, password). | Inserta algunos datos de prueba en la tabla con PHPMyAdmin o MySQL Workbench. | Conéctate desde PHP a esa base de datos. | Inserta datos desde PHP con una consulta preparada. | Necesitarás, por un lado, un formulario HTML para pedirle los datos al usuario | Y, por otro lado, un pequeño programa PHP que procese el envío del formulario y proceda a insertar los datos en la BD. | . | Consulta la tabla de usuarios desde PHP y muestra todo su contenido en una salida HTML. | . Si te sobra algo de tiempo, intenta completar este pequeño programa para que, además: . | Pueda eliminar usuarios de la tabla. | Pueda modificar usuarios existentes en la tabla. | . Intenta organizar el código lo mejor posible. El objetivo no es necesariamente minimizar el número de archivos, sino lograr una organización de archivos racional y que te permita depurar y modificar el código con relativa facilidad. Echa un vistazo a este ejemplo de código para saber cómo empezar. Ejercicio 4: CRUD sencillo MVC . Utiliza la misma base de datos del ejercicio anterior para: . | Implementar un listado de usuarios que, además, incluya las opciones de insertar, modificar y borrar usuarios (CRUD = Create, Read, Update, Delete). | Estructura todo el código en tres carpetas: . | / (carpeta raíz): coloca aquí tu controlador/enrutador (index.php) | models/ (consultas a la base de datos) | views/ (HTML/PHP para mostrar datos) | . El archivo index.php debe recibir la acción (?action=…) y redirigir al método correspondiente. Puedes, y te aconsejo que así lo hagas, usar el código fuente de la Biblioteca que hemos visto en clase para hacer este ejercicio. | . Ejercicio 5: Autenticación con login básico . | Añade a la tabla usuarios un campo rol (p. ej. admin, editor, user…). | Crea un formulario de login que valide usuario y contraseña. | Si es correcto, redirige la aplicación al área privada (el CRUD que hiciste en el ejercicio anterior). | Si no, regresa al login y muestra un mensaje de error. | . Ejercicio 6: Sesiones y seguridad mínima . | Amplía el código del ejercicio anterior e inicia sesión con session_start() tras un login correcto. | Guarda el id del usuario y su rol en variables de sesión. | Asegúrate de que las páginas del CRUD solo son accesibles si existe sesión iniciada. | Añade un botón de Cerrar sesión que destruya las variables de sesión y regrese al login. | . Ejercicio 7. Listas de control de acceso . Modifica la aplicación que estamos construyendo para que: . | Solo los usuarios de tipo administrador (rol = admin) puedan acceder a todas las funciones del CRUD. | Otros usuarios registrados pero no administradores podrán ver la tabla de usuarios pero no operar con ella (ni insertar, ni borrar ni modificar). Si lo intentan, debe aparecer un mensaje de tipo “Acción prohibida”. | Centraliza la lógica de los permisos en un archivo común (security.php). | . ",
    "url": "https://iescelia.org/docs/fullstack/_site/php/ejercicios-propuestos.html#19-pr%C3%A1cticas",
    "relUrl": "/php/ejercicios-propuestos.html#19-prácticas"
  },"19": {
    "doc": "1.9 Prácticas",
    "title": "1.9 Prácticas",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/php/ejercicios-propuestos.html",
    "relUrl": "/php/ejercicios-propuestos.html"
  },"20": {
    "doc": "1.10 Práctica final",
    "title": "1.10. Práctica final del tema 1",
    "content": ". | 1.10.1. Control de acceso de usuarios con sesiones | 1.10.2. Capa de abstracción de datos | 1.10.3. CRUD completo de Autores | 1.10.4. Modelo genérico base | 1.10.5. Controladores múltiples | 1.10.6. Archivo de configuración | 1.10.7. Enrutador | . Para terminar la unidad didáctica de PHP vamos a proponer un caso prácticos más completo para que pongas manos a la obra. Se trata de modificar y mejorar, paso a paso, la aplicación de la Biblioteca. 1.10.1. Control de acceso de usuarios con sesiones . Objetivo: Añadir a la Biblioteca un sistema básico de autenticación y autorización. Tareas: . | Crear tabla usuarios en la BD: crea una tabla con campos idUsuario, nombreUsuario y password (encriptado con password_hash de PHP). | Crear formulario de login: vista views/usuario/login.php con campos usuario y contraseña. | Crar modelo Usuario: . | Método checkLogin($nombreUsuario, $password) que verifique las credenciales. | . | Iniciar sesiones: . | En index.php, inicia la sesión con session_start(). | Si el usuario está logueado, guarda su id y nombre en $_SESSION. | . | Proteger acciones: . | Sólo permitir insertar, modificar o borrar libros/autores si el usuario está logueado. | En caso contrario, redirigir a la vista de login con un mensaje de error. | . | Cerrar sesión: añade un enlace “Cerrar sesión” en el menú de navegación. | . 1.10.2. Capa de abstracción de datos . Objetivo: Que los modelos no dependan de PDO ni de la base de datos concreta. Tareas: . | Crea una clase Database en core/Database.php que: . | Tenga un constructor que establezca la conexión con la base de datos. | Defina métodos genéricos como query($sql, $params = []) y fetchAll(), fetch(). Estos últimos devolverán un array con los datos de la consulta (o null si la consulta no devolvió nada). | . | Modifica el modelo Libro para que use la clase Database en lugar de crear su propio objeto PDO. | Comprueba que la aplicación sigue funcionando igual. | . 1.10.3. CRUD completo de Autores . Objetivo: Poder crear, leer, actualizar y borrar autores. Tareas: Añadir a la aplicación el mantenimiento de Autores de libros: . | Crear nuevo modelo Autor con los métodos: insert(), update(), delete(), getAll(), get($id). | Añadir métodos necesarios al controlador index.php: . | mostrarListaAutores() | formularioInsertarAutor() | insertarAutor() | formularioModificarAutor() | modificarAutor() | borrarAutor() | . | Crear las vistas necesarias en views/autor/: . | all.php para listar y enlazar a modificar/borrar, igual que en libros. | form.php para insertar o editar, igual que en libros. | . | Añadir el enlace “Autores” en el menú de navegación (ya existe, pero ahora tendrá funcionalidad). | . 1.10.4. Modelo genérico base . Objetivo: Evitar duplicar código en los modelos. Tareas: . | Crea una clase abstracta BaseModel en models/BaseModel.php con métodos comunes como: . | Constructor que reciba el nombre de la tabla y el nombre de la columna clave primaria. | get($id) | getAll() | delete($id) | . | Haz que los modelos Libro y Autor hereden de BaseModel y utilicen estos métodos en lugar de reescribirlos. | Adapta las consultas específicas (por ejemplo, search de Libro) para que convivan con esta herencia. | . 1.10.5. Controladores múltiples . Objetivo: Separar las responsabilidades de cada entidad. Tareas: . | Crea los controladores controllers/LibrosController.php y controllers/AutoresController.php. | Mueve a cada uno de ellos los metodos correspondientes (listar, insertar, modificar, borrar). | Crea un index.php nuevo que llame al controlador adecuado a partir de la variable controller que vendrá, junto con action en la petición POST o GET. Algo así: | . $controller = $_REQUEST['controller'] ?? 'Libros'; $action = $_REQUEST['action'] ?? 'index'; $controllerClass = $controller . 'Controller'; require \"controllers/$controllerClass.php\"; (new $controllerClass())-&gt;$action(); . | Ajusta todos los enlaces en las vistas para pasar el nombre del controlador como parámetro, no solo la acción (?controller=Autores&amp;action=mostrarListaAutores). | . 1.10.6. Archivo de configuración . Objetivo: Posibilitar el cambio de las credenciales de la base de datos sin tocar el código. Tareas: . | Crea un archivo config.php que contenga el return de un array como este: | . return [ 'db' =&gt; [ 'host' =&gt; 'mariadb', 'dbname' =&gt; 'nombre-base-de-datos', 'user' =&gt; 'tu-usuario', 'pass' =&gt; 'tu-contraseña', 'charset' =&gt; 'utf8mb4' ] ]; . | En Database.php, usa require “config.php” para obtener el array, y conéctate a la base de datos usando esas credenciales. | Comprueba que cambiando el archivo de configuración (por ejemplo, otra contraseña) la aplicación sigue funcionando sin tocar los modelos. | . 1.10.7. Enrutador . (Este paso es optativo) . Advertencia: ¡este paso puede resultar complicadillo! . Objetivo: crear un enrutador como el de los frameworks avanzados para construir rutas limpias. Recuerda que un enrutador moderno debería ser capaz de coger una URL limpia, como esta: . https://mi-servidor/book/delete/37 . …y deducir de ahí que hay que invocar el método borrarLibro(37) del controlador de libros. Debería funcionar con cualquier ruta construida de ese modo y cualquier cantidad de controladores. A ver si se te ocurre algo para incorporar un enrutador como este a la aplicación. (No sé si te has dado cuenta, pero, poco a poco, hemos ido construyendo nuestro porpio mini-framework casero para programar aplicaciones MVC) . ",
    "url": "https://iescelia.org/docs/fullstack/_site/php/practica.html#110-pr%C3%A1ctica-final-del-tema-1",
    "relUrl": "/php/practica.html#110-práctica-final-del-tema-1"
  },"21": {
    "doc": "1.10 Práctica final",
    "title": "1.10 Práctica final",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/php/practica.html",
    "relUrl": "/php/practica.html"
  },"22": {
    "doc": "1 Programación web con PHP",
    "title": "1. Introducción a PHP",
    "content": "En este capítulo vamos presentar el lenguaje PHP. Veremos la sintaxis básica y cómo este lenguaje trabaja en el lado del servidor para crear aplicaciones web dinámicas, es decir, aplicaciones que generan un HTML distinto según los datos de entrada y el estado del servidor. Conoceremos el kit de herramientas básico que vamos a necesitar para convertirnos en desarrolladores/as web y nos conectaremos a una base de datos remota para enviar y recuperar información. También hablaremos de cookies y variables de sesión tal y como las maneja PHP, dos elementos imprescindibles para el desarrollo web, e introduciremos el patrón de arquitectura MVC, que son los “planos” con los que se construyen la gran mayoría de las aplicaciones web. ",
    "url": "https://iescelia.org/docs/fullstack/_site/php/#1-introducci%C3%B3n-a-php",
    "relUrl": "/php/#1-introducción-a-php"
  },"23": {
    "doc": "1 Programación web con PHP",
    "title": "1 Programación web con PHP",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/php/",
    "relUrl": "/php/"
  },"24": {
    "doc": "2 Laravel",
    "title": "2. Laravel",
    "content": "Laravel es un framework PHP MVC diseñado para agilizar el desarrollo de aplicaciones web. En ese sentido, hace auténtica magia. Desde hace más de una década ha tenido una gran penetración en la industria, desplazando a otros frameworks más clásicos como Symfony o Code Igniter. Empezaremos por aprender qué es un framework PHP MVC, qué frameworks existen y en qué circunstancias resulta interesante utilizar una de estas herramientas para desarrollar una aplicación. Dedicaremos el resto del tema a estudiar muchas de las peculiaridades de Laravel para aprender a desarrollar aplicaciones web en el backend con este poderoso framework. ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/#2-laravel",
    "relUrl": "/laravel/#2-laravel"
  },"25": {
    "doc": "2 Laravel",
    "title": "2 Laravel",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/",
    "relUrl": "/laravel/"
  },"26": {
    "doc": "3 Desarrollo de un API REST",
    "title": "3. Desarrollo de un API REST con Laravel",
    "content": ". | 3.1. ¿Qué es un servicio web? . | 3.1.1. Una definición de servicio web | 3.1.2. Diferencias entre servicios web y aplicaciones web | . | 3.2. SOAP | 3.3. API REST . | 3.3.1. ¿Qué es un API REST? | 3.3.2. Las 7 operaciones REST | 3.3.3. Los verbos http: GET, POST, PUT, PATCH y DELETE | 3.3.4. El problema de PUT, PATCH y DELETE | 3.3.5. REST vs SOAP | . | 3.4. Implementar un API REST con Laravel . | 3.4.1. Tips importantes antes de empezar… | 3.4.2. Un ejemplo completo | . | 3.5. Consumir el servicio web con Postman . | 3.5.1. Qué es Postman | 3.5.2. Instalación y puesta en marcha de Postman | 3.5.3. Cómo probar nuestro API REST | 3.5.4. Archivo de colección .json | 3.5.5. ¿Y qué más puede hacer Postman? | . | 3.6. Consumir el API REST con Javascript | 3.7. Práctica: construir un API REST sobre la Tierra Media . | Paso 1: crear la infraestructura | Paso 2: escribir el API | Paso 3: probar y consumir el API | . | . Los servicios web son un tipo particular de aplicación web: una aplicación pensada no solo para ser usada por usuarios humanos, sino también por otras aplicaciones informáticas. Por esa razón, un servicio web puede que no genere HTML (vistas), sino datos, normalmente codificados como XML o JSON, que serán consumidos por otras aplicaciones informáticas. Hay varios estándares de facto para crear servicios web. El más extendido es REST, que es el que vamos a estudiar, pero hay otros como GraphQL (en rápido crecimiento, sobre todo en aplicaciones ricas en datos), gRPC (muy usado para microservicios con necesidades alto rendimiento) o SOAP (más antiguo pero muy común en grandes empresas y organismos como banca, seguros o gobiernos). Nosotros nos centraremos en REST. Una aplicación web que ofrezca en el servidor un interfaz que implemente este estándar se suele denominar API REST. En este tema, vamos a aprender a construir una aplicación API REST usando Laravel. ",
    "url": "https://iescelia.org/docs/fullstack/_site/api-rest/#3-desarrollo-de-un-api-rest-con-laravel",
    "relUrl": "/api-rest/#3-desarrollo-de-un-api-rest-con-laravel"
  },"27": {
    "doc": "3 Desarrollo de un API REST",
    "title": "3.1. ¿Qué es un servicio web?",
    "content": "3.1.1. Una definición de servicio web . Un servicio web es una aplicación web capaz de comunicarse e intercambiar información con otra aplicación (que denominaremos cliente) independientemente de la plataforma en la que cada una se ejecute. Es decir, el servicio web puede estar programado en PHP y correr bajo un sistema operativo GNU/Linux y el cliente puede estar programado con C# y correr bajo un Windows, y deberían ser capaces de comunicarse y trabajar juntas. Pero es importante que quede claro que, en este caso, la aplicación web (servidor) y la aplicación cliente son dos aplicaciones diferentes. Los mensajes que las aplicaciones se intercambian generalmente tienen formato JSON o XML. Existen dos estándares principales en la industria para implementar servicios web, denominados SOAP y REST, aunque hay otros en rápido crecimiento como GraphQL o gRPC. A lo largo el tema, vamos a aprender cómo funcionan los dos primeros. 3.1.2. Diferencias entre servicios web y aplicaciones web . Llegados a este punto, puede que estés pensando: “Vale, pero ¿en qué se diferencia un servicio web de una aplicación web MVC? ¿En una aplicación web no intercambian también el cliente y el servidor información independientemente de la plataforma en la que se ejecuta cada uno?”. Pues sí, pero hay algunas diferencias entre un servicio web y una aplicación web: . | Una aplicación web está diseñada exclusivamente para que un ser humano interactúe con ella a través de un interfaz HTML. | Un servicio web, en cambio, está pensado para que lo pueda usar otra aplicación informática (el cliente), no necesariamente un ser humano. | . Por ese motivo, los servicios web pueden carecer de interfaz de usuario y no producir salidas HTML legibles. Un servicio web puro, de hecho, no suele tener vistas, solo salidas XML o JSON pensadas para que los clientes las procesen. Por lo demás, un servicio web puede tener una arquitectura aproximadamente MVC, y digo aproximadamente porque el servicio web, como acabo de contarte, puede carecer de vistas (aunque podría tenerlas). Pero seguirá conservando sus controladores y sus modelos. Los controladores se encargarán de convertir los datos de los modelos a JSON o XML y devolverlos al cliente, sin necesidad de crear vistas. ",
    "url": "https://iescelia.org/docs/fullstack/_site/api-rest/#31-qu%C3%A9-es-un-servicio-web",
    "relUrl": "/api-rest/#31-qué-es-un-servicio-web"
  },"28": {
    "doc": "3 Desarrollo de un API REST",
    "title": "3.2. SOAP",
    "content": "SOAP (Single Object Access Protocol) es un mecanismo estandarizado para la implementación, descripción y publicación de servicios en red. SOAP establece el modo en el que deben comportarse el cliente y el servidor para hablar entre sí, así como la forma en la que el servidor debe dar a conocer sus servicios. El estándar SOAP fue durante mucho tiempo la forma “oficial” y más extendida de construir servicios web de tipo empresarial, sobre todo en entornos donde la robustez, la estandarización y la compatibilidad con herramientas de integración eran cruciales (por ejemplo, banca, seguros, telecomunicaciones). En la actualidad, sin embargo, pocos servicios se montan como SOAP, y se prefieren casi siempre alternativas más modernas como REST, GraphQL o gRPC. Sin embargo, SOAP no está muerto ni mucho menos: todavía se usa ampliamente en sectores muy regulados y en sistemas antiguos (por ejemplo, servicios de facturación electrónica o sistemas de información gubernamentales). La pila de protocolos de SOAP . El estándar SOAP define una serie de protocolos de niveles de abstracción crecientes. Esta colección de protocolos suele denominarse pila de protocolos SOAP, y son los siguientes: . | Nivel de abstracción | Protocolo | . | Nivel de descubrimiento | UDDI | . | Nivel de publicación | UDDI | . | Nivel de descripción | WSDL | . | Nivel de mensajería | SOAP | . | Nivel de red | TCP, SMTP, FTP, etc | . Como ves, SOAP solo es uno de los protocolos de la pila, aunque todo el tinglado recibe el nombre “SOAP” por extensión. En este curso no vamos a ver cómo trabajar con SOAP, sino que simplemente lo mencionamos por su importancia histórica. En su lugar, nos vamos a centrar en el estándar más extendido en la actualidad entre servidores: REST. ",
    "url": "https://iescelia.org/docs/fullstack/_site/api-rest/#32-soap",
    "relUrl": "/api-rest/#32-soap"
  },"29": {
    "doc": "3 Desarrollo de un API REST",
    "title": "3.3. API REST",
    "content": "3.3.1. ¿Qué es un API REST? . REST (Representational State Transfer) es una arquitectura web para intercambiar información entre clientes y servidores de una red; es decir, es una arquitectura para diseñar servicios web. Los términos REST, API REST y RESTful son casi como sinónimos, pero tienen sutiles diferencias: . | REST es una arquitectura para diseñar servicios web. | API REST es un interfaz de programación (API) que sigue los principios REST. Es decir, es un servicio web que ofrece a los clientes una forma de interactuar acorde a la arquitectura REST. | RESTful se refiere a una API que respeta escrupulosamente los principios de diseño REST. Algunas API REST son RESTful, pero otras introducen pequeñas variaciones sobre el estándar REST. Solo las que siguen al 100% los principios de diseño REST son RESTful. | . A diferencia de SOAP, REST está orientado a los datos, esto es, proporciona siempre los mismos tipos de acceso a los recursos, sin posibilidad de definir nuevas operaciones. Suele decirse, por esa razón, que REST está orientado a los datos mientras que SOAP está orientado a los procesos. Actualmente, gran parte de las APIs, ya sean públicas o privadas, se programan según el diseño REST para que los programadores que las usen sepan qué esperar de la API sin necesidad de consultar farragosas páginas de documentación o de pelearse con el servidor mediante el infalible método de ensayo y error. 3.3.2. Las 7 operaciones REST . Un servidor REST debe implementar siete operaciones de acceso a cada tipo de recurso. Si no las implementa, ya no es REST. Podrá ser aproximadamente REST, pero no REST. Los nombres de las operaciones, los datos que se esperan que se devuelvan y el verbo http de acceso deben respetarse escrupulosamente. Imagina que estamos programando un servidor REST para acceder, por ejemplo, a un recurso llamado Producto dentro de una aplicación más grande (por ejemplo, una tienda online). En la siguiente tabla tienes las siete operaciones que un servidor REST puede realizar con ese recurso, es decir, con los productos de la base de datos. También te indico qué significa cada operación y un ejemplo típico de la URL que permitirá el acceso a través de https. | Operación | Significado | Verbo | URL típica | . | index | Mostrar todos los productos | GET | https://servidor/producto/ | . | show | Mostrar un producto | GET | https://servidor/producto/id | . | create | Mostrar formulario de creación de un producto | GET | https://servidor/producto/create | . | store | Crear un producto con los datos procedentes de un formulario | POST | https://servidor/producto/store | . | edit | Mostrar el formulario de edición de un producto | GET | https://servidor/producto/edit/id | . | update | Actualizar el producto con los datos procedentes del formulario | PUT o PATCH | https://servidor/producto/update/id | . | destroy | Eliminar un producto | DELETE | https://servidor/producto/destroy/id | . Hay una excepción a esta regla: las operaciones create y edit podrían no estar disponibles en algunas APIs REST, cuando estas estén diseñadas para que las usen otras aplicaciones y no seres humanos. Soy consciente de que esta tabla necesita algunas explicaciones adicionales, así que vamos a ello. En primer lugar, ¿qué es eso de los verbos que figura en cada petición? . 3.3.3. Los verbos http: GET, POST, PUT, PATCH y DELETE . El protocolo http define dos tipos de petición al servidor, GET y POST. El estándar REST aumenta estos tipos en otros tres: PUT, PATCH y DELETE. Veamos qué significa exactamente cada uno: . | GET se utiliza para solicitar datos al servidor. Por ejemplo: “Dame toda la información de un producto”. | POST se utiliza para enviar datos al servidor. Por ejemplo: “Aquí tienes toda la información de un producto; anda, almacénalo en tu base de datos”. | PUT/PATCH se utiliza para solicitar al servidor la modificación de datos que ya existen. Por ejemplo: “Este es el nuevo precio de un producto que ya estaba en tu base de datos. Tómalo y actualízalo”. Si se van a actualizar todos los datos de un producto, se utiliza PUT. Si se va a actualizar solo una parte de los datos de un producto, se utiliza PATCH. | DELETE se usa para solicitar la eliminación de datos en el servidor. Por ejemplo: “Elimina este producto”. | . Por ese motivo, en algunas URLs de la tabla anterior enviamos un id como parte de la ruta. Ese id indicará al servidor qué producto le estamos pidiendo que nos busque, modifique o elimine. Una moraleja tal vez imprevista de esta tabla es que nunca deberías enviar datos al servidor mediante GET, puesto que GET solo tendría que usarse para obtener datos del servidor. Otra moraleja es que el propio verbo de la petición http ya contiene información sobre lo que se le está pidiendo hacer al servidor. De hecho, en un servidor REST, contiene información fundamental. Por eso es tan importante respetar las convenciones. Si ya has trabajado con HTML antes, seguro que conocías el significado de GET y POST, pero probablemente nunca habías oído hablar de PUT, PATCH y DELETE, ¿verdad? . 3.3.4. El problema de PUT, PATCH y DELETE . Cuando solicitamos una URL a un servidor sin indicar otra cosa, el protocolo http/https asumirá que se trata de una petición GET. Si en un formulario indicamos que el método de envío de los datos al servidor es POST, los datos que el usuario rellene en ese formulario se enviarán al servidor mediante POST, como parte del paquete http, en una zona especialmente dedicada a empaquetarlos: . &lt;form action='http://servidor/lo-que-sea' method='POST'&gt; ...cuerpo del formulario &lt;/form&gt; . Pero con HTML5 no hay manera de hacer una petición al servidor por PUT, por PATACH o por DELETE. Esto se debe a que la implementación actual de http no contempla los verbos PUT, PATCH ni DELETE. Sin embargo, en el estándar REST estos verbos son fundamentales. Como a nosotros nos interesa construir servidores REST con acceso por http, es decir, vía web, aquí tenemos un grave problema. Mientras llega una nueva implementación de http y/o de HTML, este problema tiene dos soluciones temporales: . | Sustituir las llamadas con PUT, PATCH o DELETE por llamadas POST convencionales. Esto hará que, en la práctica, nuestro servidor deje de ser REST, claro. | Parchear las llamadas con PUT, PATCH o DELETE mediante un campo oculto (de tipo hidden) en el formulario. Esta es la forma en la que se realizan las implementaciones REST vía web en la actualidad. Tienes un ejemplo en este formulario: | . &lt;form action='http://servidor/lo-que-sea' method='POST'&gt; &lt;input type='hidden' name='_method' value='PUT'&gt; ...cuerpo del formulario... &lt;/form&gt; . Tal vez recuerdes que esto es exactamente lo que hace Laravel para implementar llamadas mediante PUT, PATCH o DELETE. ¿Qué dices? ¿Que no te acuerdas? Entonces quizá sea el momento de que retrocedas y repases un poco el enrutador de Laravel. 3.3.5. REST vs SOAP . Ya sabemos en qué consisten las dos grandes arquitecturas para construir servicios web. Ahora, la pregunta del millón: ¿cuál es mejor de las dos? . SOAP es más flexible que REST: permite definir nuevas operaciones sobre los recursos, mientras que REST está limitado a las 7 operaciones predefinidas. REST es mucho más sencillo de usar e implementar que SOAP: las operaciones son bien conocidas y no es necesario describirlas (WSDL) ni publicarlas de ningún modo. Para usar un servidor REST, no hay que estudiarse ninguna API ni pelearse con estructuras de datos desconocidas. Por todo ello, para la mayor parte de las aplicaciones REST es más que suficiente, y de ahí su mayor implantación en la actualidad. ",
    "url": "https://iescelia.org/docs/fullstack/_site/api-rest/#33-api-rest",
    "relUrl": "/api-rest/#33-api-rest"
  },"30": {
    "doc": "3 Desarrollo de un API REST",
    "title": "3.4. Implementar un API REST con Laravel",
    "content": "3.4.1. Tips importantes antes de empezar… . Antes de lanzarte a implementar un API REST en Laravel, lee esta sección, por favor. Para implementar un API REST con Laravel debes: . | Instalar el complemento para APIs de Laravel. Esto solo es necesario a partir de Laravel 12 (en versiones anteriores ya venía “de serie”): . $ php artisan install:api . | Crear la infraestructura de la base de datos, como en cualquier aplicación web. La base de datos son los cimientos, así que tendrás que empezar por crear tus migraciones y, opcionalmente, tus seeders. | Crear una arquitectura MVC para los recursos/datos que tengas que servir. Con Laravel, esto se consigue con uno de estos comandos: . $ php artisan make:controller --resource &lt;nombre-controlador&gt; $ php artisan make:controller --api &lt;nombre-controlador&gt; . | resource creará las 7 rutas REST y los 7 métodos del controlador correspondiente. Está pensado para construir una API RESTful con la que puede interactuar cualquiera, tanto usuarios humanos como otras aplicaciones. | api creará solo 5 de las 7 rutas REST, junto con los 5 métodos del controlador. Está pensado para construir una API REST con la que interactuarán otras aplicaciones, pero no humanos, por lo que no ofrece las operaciones create ni edit, que muestran formularios. | . | Devolver al cliente los datos formateados como JSON en lugar de mostrarlos en una vista HTML. Puede usarse también XML, pero JSON es más habitual. Con Laravel, en lugar de hacer return view() al final de cada método del controlador, usaremos return response()-&gt;json(&lt;datos&gt;). Laravel se encargará de enviar ese valor devuelto al cliente. | Respetar los nombres de los verbos y de las peticiones HTTP, puesto que serán los que el cliente utilice. Recuerda que en una API RESTful estos son: . | Verbos: GET, POST, PUT, PATCH, DELETE. | Peticiones: index (GET), show (GET), create (GET), store (POST), edit (GET), update (PUT/PATCH), destroy (DELETE). | . | . 3.4.2. Un ejemplo completo . (Haz clic aquí para acceder al código fuente completo de este ejemplo) . Ya estamos en condiciones de construir nuestro primer API REST con Laravel. En este ejemplo, serviremos los siguientes datos: . | Productos (id, nombre, descripcion, precio, stock): son los productos de una tienda online ficticia. | Clientes (id, nombre, apellido1, apellido2 y email): son los clientes de la tienda online. | Compras (cliente_id, producto_id, fecha, hora, unidades): es la relación N:N entre Productos y Clientes. | . Migraciones . Lo primero es crear las migraciones con $ php artisan make:migration nombre_migracion. Aquí te ofrezco un ejemplo de cómo podrían quedar: . Migración de Productos: database/migrations/&lt;timestamp&gt;_create_productos_table.php . &lt;?php use Illuminate\\Database\\Migrations\\Migration; use Illuminate\\Database\\Schema\\Blueprint; use Illuminate\\Support\\Facades\\Schema; return new class extends Migration { public function up() { Schema::create('productos', function (Blueprint $table) { $table-&gt;id(); $table-&gt;string('nombre'); $table-&gt;text('descripcion')-&gt;nullable(); $table-&gt;decimal('precio', 10, 2); $table-&gt;integer('stock'); $table-&gt;timestamps(); }); } public function down() { Schema::dropIfExists('productos'); } }; . Migración de Clientes: database/migrations/&lt;timestamp&gt;_create_clientes_table.php . &lt;?php use Illuminate\\Database\\Migrations\\Migration; use Illuminate\\Database\\Schema\\Blueprint; use Illuminate\\Support\\Facades\\Schema; return new class extends Migration { public function up() { Schema::create('clientes', function (Blueprint $table) { $table-&gt;id(); $table-&gt;string('nombre'); $table-&gt;string('apellido1'); $table-&gt;string('apellido2')-&gt;nullable(); $table-&gt;string('domicilio')-&gt;nullable(); $table-&gt;string('email')-&gt;unique(); $table-&gt;timestamps(); }); } public function down() { Schema::dropIfExists('clientes'); } }; . Migración de Compras (pivote con atributos): database/migrations/&lt;timestamp&gt;_create_compras_table.php . &lt;?php use Illuminate\\Database\\Migrations\\Migration; use Illuminate\\Database\\Schema\\Blueprint; use Illuminate\\Support\\Facades\\Schema; return new class extends Migration { public function up() { Schema::create('compras', function (Blueprint $table) { $table-&gt;id(); $table-&gt;foreignId('producto_id')-&gt;constrained()-&gt;onDelete('cascade'); $table-&gt;foreignId('cliente_id')-&gt;constrained()-&gt;onDelete('cascade'); $table-&gt;date('fecha'); $table-&gt;time('hora'); $table-&gt;integer('unidades'); $table-&gt;timestamps(); }); } public function down() { Schema::dropIfExists('compras'); } }; . Modelos . Lo siguiente sería crear los modelos con php artisan make:model NombreModelo. Aquí te muestro cómo podrían quedar para que reflejasen las relaciones entre las tablas mediante Eloquent. Modelo de Producto: app/Models/Producto.php . &lt;?php namespace App\\Models; use Illuminate\\Database\\Eloquent\\Model; class Producto extends Model { protected $fillable = ['nombre', 'descripcion', 'precio', 'stock']; public function clientes() { return $this-&gt;belongsToMany(Cliente::class, 'compras') -&gt;withPivot('fecha', 'hora', 'unidades') -&gt;withTimestamps(); } } . Modelo de Cliente: app/Models/Cliente.php . &lt;?php namespace App\\Models; use Illuminate\\Database\\Eloquent\\Model; class Cliente extends Model { protected $fillable = ['nombre', 'apellido1', 'apellido2', 'domicilio', 'email']; public function productos() { return $this-&gt;belongsToMany(Producto::class, 'compras') -&gt;withPivot('fecha', 'hora', 'unidades') -&gt;withTimestamps(); } } . Modelo de Compra (pivote): app/Models/Compra.php . &lt;?php namespace App\\Models; use Illuminate\\Database\\Eloquent\\Model; class Compra extends Model { protected $fillable = ['producto_id', 'cliente_id', 'fecha', 'hora', 'unidades']; public function producto() { return $this-&gt;belongsTo(Producto::class); } public function cliente() { return $this-&gt;belongsTo(Cliente::class); } } . Controladores RESTful . El siguiente paso es crear los controladores. Los generaremos con estos comandos: . $ php artisan make:controller ProductoController --api $ php artisan make:controller ClienteController --api $ php artisan make:controller CompraController --api . Recuerda que usamos la opción api en lugar de resource para que nos genere 5 métodos REST, no los 7 RESTful, puesto que no necesitaremos los formularios de creación ni de edición (se trata de una API para que la usen otras aplicaciones, no un usuario humano). Por ejemplo, así quedaría el controlador de Productos: app/Http/Controllers/ProductoController.php . &lt;?php namespace App\\Http\\Controllers; use App\\Models\\Producto; use Illuminate\\Http\\Request; class ProductoController extends Controller { public function index() { return response()-&gt;json(Producto::all(), 200); } public function store(Request $request) { $producto = Producto::create($request-&gt;all()); return response()-&gt;json($producto, 201); } public function show($id) { return response()-&gt;json(Producto::findOrFail($id), 200); } public function update(Request $request, $id) { $producto = Producto::findOrFail($id); $producto-&gt;update($request-&gt;all()); return response()-&gt;json($producto, 200); } public function destroy($id) { Producto::destroy($id); return response()-&gt;json(null, 204); } } . Los controladores de clientes (ClienteController) y compras (CompraController) serán parecidos, es decir, un CRUD que devuelve los datos en formato JSON. Como hemos construido las relaciones entre los modelos con Eloquent, no es necesario hacer nada más: Laravel se encargará de buscar todos los datos relacionados entre sí con su “magia” interna. Enrutador (Rutas API) . Como estamos construyendo una API pura, editaremos el enrutador routes/api.php en lugar de routes/web.php. ¡¡OJO!! Si trabajas con Laravel 12 o posterior, el archivo routes/api.php no existirá. Debes instalar primero el soporte para APIs de Laravel con el comando $ php artisan install:api &lt;?php use App\\Http\\Controllers\\ProductoController; use App\\Http\\Controllers\\ClienteController; use App\\Http\\Controllers\\CompraController; Route::apiResource('productos', ProductoController::class); Route::apiResource('clientes', ClienteController::class); Route::apiResource('compras', CompraController::class); . El enrutador routes/api.php usa el middleware api, que no maneja sesiones, cookies (es decir, que no tiene estado), ni ofrece protección contra el CSRF, por lo que solo se usa cuando no hay interacción directa entre el servidor y un usuario humano. Es decir, solo se usa en APIs puras. El enrutador routes/web.php usa el middleware web, que sí controla el estado (sesiones y cookies) y ofrece protección contra CSRF. Si estás construyendo un API RESTful, que sí puede usarse por un usuario humano (con los métodos create y edit), es mejor enrutar de este modo. Ejemplo de llamadas REST . Laravel está configurado para usar el enrutador api.php en lugar de web.php en todos los enpoints que empiecen por /api. Este comportamiento se puede cambiar, pero no hay necesidad de hacerlo en este ejemplo. Nuestra API, por tanto, responderá con JSON a cualquier solicitud HTTP con el prefijo /api. Por ejemplo: . | GET http://servidor/api/productos/1 → solicita los datos del producto con id 1. Recibirá como respuesta un JSON con este aspecto: . { \"id\": 1, \"nombre\": \"Teclado\", \"descripcion\": \"Mecánico\", \"precio\": 29.99, \"stock\": 20 } . | POST http://servidor/api/productos → en este caso, el servidor esperará recibir en el cuerpo de la petición HTTP los datos del producto que tiene que almacenar. El servidor desempaquetará esos datos y los guardará en la base de datos; y, si todo va bien, responderá con un JSON con los datos del producto que acaba de almacenar (parecido al JSON del ejemplo anterior) . En caso de error al insertar el producto, nuestra aplicación no tiene un comportamiento definido, así que devolverá un JSON con el código y el mensaje del error. Se puede mejorar el controlador para que devuelva otra información en caso de que suceda un error. | . ",
    "url": "https://iescelia.org/docs/fullstack/_site/api-rest/#34-implementar-un-api-rest-con-laravel",
    "relUrl": "/api-rest/#34-implementar-un-api-rest-con-laravel"
  },"31": {
    "doc": "3 Desarrollo de un API REST",
    "title": "3.5. Consumir el servicio web con Postman",
    "content": "3.5.1. Qué es Postman . Postman es una herramienta cliente para APIs muy popular que permite a desarrolladores probar, documentar y automatizar peticiones a servicios web. Es gratuita con opciones de pago. Postman se usa para todas estas cosas: . | Enviar peticiones HTTP (GET, POST, PUT, PATCH, DELETE, etc.) hacia tu API y visualizar la respuesta. | Configurar headers y parámetros. Por ejemplo, “Content-Type: application/json”, tokens de autenticación, etc. | Enviar cuerpos de petición en JSON para probar endpoints, es decir, URLs que esperan recibir datos en JSON para funcionar. | Visualizar las respuestas del servidor en formato JSON, XML, texto, etc., junto con el código de estado HTTP. | Guardar colecciones de pruebas para reutilizarlas o compartirlas con tu equipo (muy útil cuando varios desarrolladores trabajan con la misma API). | Automatizar pruebas: puedes escribir scripts en JavaScript dentro de Postman para verificar automáticamente que las respuestas cumplen con lo esperado. | Generar documentación de tu API a partir de las colecciones. | . 3.5.2. Instalación y puesta en marcha de Postman . Opción 1: Instalar Postman como app de escritorio (RECOMENDADO) . | Visita la web https://www.postman.com/downloads/. Si usas Linux, puedes buscar antes en los repositorios oficiales de tu distribución, porque podría incluir Postman. | Descarga e instala la versión más adecuada para tu sistema operativo. | Inicia sesión (puedes usar Google o GitHub). | . Opción 2: Usar Postman en la nube . | Accede a: https://web.postman.com/ | Inicia sesión y comienza a trabajar directamente en la nube. | . Ignorando el asistente de IA . En las nuevas versiones de Postman aparece por defecto un asistente de IA al lanzar la aplicación. Vamos a ignorar ese asistente para aprender a usar Postman nosotros, no una IA, que para eso estamos aquí. Para ello, puedes escribir algo como “Quiero ir al interfaz clásico de Postman” en el cuadro de diálogo de la IA, o elegir la opción File -&gt; New Postman Window. Entonces obtendrás una pantalla como esta: . 3.5.3. Cómo probar nuestro API REST . Vamos a ilustrar cómo funciona Postman con un ejemplo práctico: configurándolo para probar nuestro API REST de clientes, productos y compras que hemos implementado un poco más arriba. Configura una colección en Postman . Una colección es una serie de request o peticiones al servidor agrupados bajo el mismo nombre. Son como carpetas donde organizar peticiones para poder reutilizarlas más tarde, algo habitual si estás en fase de desarrollo de una API. La colección que nosotros vamos a crear nos permitirá lanzar todas las peticiones para trabajar con Productos, Clientes y Compras. En Postman puedes crear una colección llamada, por ejemplo, Tienda API, o bien puedes usar la colección que viene creada por defecto, MyCollection. Todo ello se hace en el panel izquierdo de Postman. Requests GET . Veamos como hacer un GET con Postman para comprobar si el API responde con los datos correctos. Cada request tendrá la URL base de tu API. En todos los ejemplos vamos a suponer que es https://servidor/api, pero, lógicamente, tendrás que cambiarla por la tuya. Pues bien: para hacer un GET /productos y guardar el request en nuestra colección solo tenemos que: . | Hacer clic en los tres puntos junto al nombre de la colección y pulsar en “Add request”. | Escribir el endpoint o ruta https://servidor/api/productos en el cuadro de búsqueda. | Asegurarnos de tener seleccionado el verbo GET. | Pulsar el botón “Send”. | . El servidor nos debería devolver todos los productos empaquetados en un JSON: . Requests POST con datos . Si hacemos una petición como POST /productos, el estándar REST indica que estamos tratando de enviar los datos de un producto al servidor para que este lo almacene en la base de datos. Por lo tanto, esta petición debe llevar los datos del producto empaquetados como JSON en el cuerpo (body) de la propia petición HTTP. Esto se logra así en Postman: . | Crear una nueva request en tu colección (haz clic en los 3 puntos junto al nombre de la colección y elige “Add request”). | Escribir el endpoint o ruta https://servidor/api/productos en el cuadro de búsqueda. | Asegurarnos de tener seleccionado el verbo POST. | En el panel de la request, seleccionar la pestaña “Body”. | Seleccionar “raw” y “JSON” en los desplegables, pues vamos a enviar los datos como JSON en texto plano (raw). | Escribir el objeto JSON que deseamos enviar al servidor. Por ejemplo: . { \"nombre\": \"Ratón inalámbrico\", \"descripcion\": \"Mouse óptico con USB\", \"precio\": 25.90, \"stock\": 100 } . | Pulsar el botón “Send”. | . El servidor responderá con un estado http 200 o 201 (si todo va bien) o con un error (estados 403, 404, 500 o cualquier otro). Además, puede enviarnos datos adicionales, como el id del recurso que acaba de crear o incluso un JSON con todos los datos del recurso que acaba de crear, como ocurre en el siguiente pantallazo: . Requests PUT, PATCH o DELETE . Del mismo modo que con POST podemos enviar requests con los verbos PUT, PATCH o DELETE, puesto que en el selector del método de envío encontraremos todos esos verbos. 3.5.4. Archivo de colección .json . Probablemente una de las formas más útiles de usar Postman como herramienta de testeo de un API es disponer de un archivo .json con todos los datos para lanzar los tests. Esto te permite preparar la batería de pruebas de una sola vez y utilizarla todas las veces que lo necesites. También es fácil hacer pequeños retoques en las pruebas y volver a cargar el .json en Postman. Para usar Postman de este modo, debes: . | Crear tu archivo .json con la colección de tests. No suele ser buena idea escribirlo a mano. Para esto puedes apoyarte en una IA como ChatGPT o la propia IA que viene integrada con Postman, a la que puedes pedir algo como esto: “Genera un archivo .json con una colección para Postman con la que probar la siguiente una API REST basada en las siguientes tablas”. Y, a continuación, detalla la estructura de tu base de datos. | Importa tu archivo .json con la opción “Import” de Postman. Se importará como una nueva colección. Si la colección ya existiera y te quedan dos con el mismo nombre, puedes borrar la que te sobre. | . Y listo: solo con esto ya tendrás todos los endpoints listos para probar. 3.5.5. ¿Y qué más puede hacer Postman? . Postman es mucho más que una herramienta para probar endpoints; es una plataforma completa de colaboración y automatización para APIs. Nosotros no vamos a ver mucho más en esta introducción, pero si quieres profundizar en ello, aquí tienes algunos de los trucos de magia que Postman puede realizar para ti: . | Automatización de pruebas: puedes escribir sripts en Javascript para validar las respuestas de forma automática o ejecutar múltiples peticiones en secuencia, así como ejecutar código antes y después de lanzar las peticiones. | Documentación de API: Postman no solo puede generar automáticamente documentación de la API a partir de la colección, sino que también puede publicarla online y mantenerla actualizada. | Monitoreo: con Postman se puede monitorear el estado de una API de forma automática a intervalos regulares y hacer que nos avise de cualquier mal funcionamiento. | Simulación de servidores: Postman puede simular servidores inexistentes para pruebas más complejas. | Trabajo en equipo: Puedes integrar Postman con GitHub, GitLab, Jenkins, etc. | Autenticación: también puedes gestionar la autenticación por múltiples medios en aquellas APIs que la exijan antes de responder a requests. | . ",
    "url": "https://iescelia.org/docs/fullstack/_site/api-rest/#35-consumir-el-servicio-web-con-postman",
    "relUrl": "/api-rest/#35-consumir-el-servicio-web-con-postman"
  },"32": {
    "doc": "3 Desarrollo de un API REST",
    "title": "3.6. Consumir el API REST con Javascript",
    "content": "Un API como el que hemos construido de ejemplo en esta unidad didáctica también se puede consumir desde una web estática HTML por medio de Javascript. La idea es que Javascript puede llamar al servidor REST y recibir la respuesta JSON, y después crear dinámicamente los elementos HTML necesarios para mostrar esa respuesta en la página que ya estaba cargada. Te muestro un pequeño ejemplo de código que hace exactamente eso. Es decir, lo que vas a ver a continuación es un frontend minimalista para el API REST que hemos creado más arriba (Productos, Clientes y Compras), programado con HTML y Javascript clásico, sin apoyo de ningún framework. O, lo que es lo mismo, programado como se hacía entre los años 2000 y 2010, más o menos. Por favor, ten en cuenta que este modo de programar se considera anticuado. Solo te lo muestro aquí con propósitos didácticos, para que veas por qué son necesarios los frameworks Javascript como Angular. &lt;!DOCTYPE html&gt; &lt;html lang=\"es\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Tienda online - Frontend SPA sin frameworks&lt;/title&gt; &lt;style&gt; body { font-family: Arial; margin: 2em; } table { border-collapse: collapse; width: 100%; margin-top: 1em; } th, td { border: 1px solid #ccc; padding: 4px; text-align: left; } input, textarea { width: 100%; margin-bottom: .5em; } button { margin-right: .5em; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Tienda online - Frontend SPA sin frameworks&lt;/h1&gt; &lt;div&gt; &lt;button onclick=\"mostrarLista()\"&gt;Ver productos&lt;/button&gt; &lt;button onclick=\"mostrarFormulario()\"&gt;Nuevo producto&lt;/button&gt; &lt;/div&gt; &lt;div id=\"view\"&gt;&lt;/div&gt; &lt;script&gt; var API_URL = \"http://localhost/api/productos\"; // Mostrar lista de productos function mostrarLista() { var view = document.getElementById(\"view\"); view.innerHTML = \"&lt;p&gt;Cargando productos...&lt;/p&gt;\"; fetch(API_URL) // Javascript pide los datos al servidor sin recargar la página .then(function(respuesta) { // Cuando el servidor responde, convertimos la respuesta en un objeto JSON return respuesta.json(); }) .then(function(datos) { // Cuando el objeto JSON está listo, lo procesamos para crear el nuevo HTML var html = \"&lt;h2&gt;Lista de productos&lt;/h2&gt;\"; html += \"&lt;table&gt;&lt;tr&gt;&lt;th&gt;ID&lt;/th&gt;&lt;th&gt;Nombre&lt;/th&gt;&lt;th&gt;Precio&lt;/th&gt;&lt;th&gt;Stock&lt;/th&gt;&lt;th&gt;Acciones&lt;/th&gt;&lt;/tr&gt;\"; for (var i = 0; i &lt; datos.length; i++) { var p = datos[i]; html += \"&lt;tr&gt;\"; html += \"&lt;td&gt;\" + p.id + \"&lt;/td&gt;\"; html += \"&lt;td&gt;\" + p.nombre + \"&lt;/td&gt;\"; html += \"&lt;td&gt;\" + p.precio + \"&lt;/td&gt;\"; html += \"&lt;td&gt;\" + p.stock + \"&lt;/td&gt;\"; html += \"&lt;td&gt;\" + \"&lt;button onclick='editarProducto(\" + p.id + \")'&gt;Editar&lt;/button&gt;\" + \"&lt;button onclick='eliminarProducto(\" + p.id + \")'&gt;Eliminar&lt;/button&gt;\" + \"&lt;/td&gt;\"; html += \"&lt;/tr&gt;\"; } html += \"&lt;/table&gt;\"; view.innerHTML = html; }) .catch(function(error) { // Si ocurre cualquier error en la secuecia anterior de acciones, damos un mensaje de error view.innerHTML = \"&lt;p&gt;Error al cargar los productos: \" + error + \"&lt;/p&gt;\"; }); } // Mostrar formulario vacío para crear productos function mostrarFormulario() { var view = document.getElementById(\"view\"); var html = \"&lt;h2&gt;Nuevo producto&lt;/h2&gt;\"; html += \"&lt;form id='formulario'&gt;\"; html += \"&lt;label&gt;Nombre:&lt;/label&gt;&lt;input name='nombre'&gt;&lt;br&gt;\"; html += \"&lt;label&gt;Descripción:&lt;/label&gt;&lt;textarea name='descripcion'&gt;&lt;/textarea&gt;&lt;br&gt;\"; html += \"&lt;label&gt;Precio:&lt;/label&gt;&lt;input name='precio' type='number' step='0.01'&gt;&lt;br&gt;\"; html += \"&lt;label&gt;Stock:&lt;/label&gt;&lt;input name='stock' type='number'&gt;&lt;br&gt;\"; html += \"&lt;button type='button' onclick='guardarProducto()'&gt;Guardar&lt;/button&gt;\"; html += \"&lt;button type='button' onclick='mostrarLista()'&gt;Cancelar&lt;/button&gt;\"; html += \"&lt;/form&gt;\"; view.innerHTML = html; } // Guardar producto nuevo function guardarProducto() { var f = document.getElementById(\"formulario\"); var datos = { nombre: f.nombre.value, descripcion: f.descripcion.value, precio: parseFloat(f.precio.value), stock: parseInt(f.stock.value) }; fetch(API_URL, { method: \"POST\", headers: { \"Content-Type\": \"application/json\" }, body: JSON.stringify(datos) }) .then(function(res) { return res.json(); }) .then(function() { alert(\"Producto creado correctamente.\"); mostrarLista(); }) .catch(function(error) { alert(\"Error al crear producto: \" + error); }); } // Formulario para editar producto (versión muy simplificada) function editarProducto(id) { var view = document.getElementById(\"view\"); view.innerHTML = \"&lt;p&gt;Cargando producto...&lt;/p&gt;\"; fetch(API_URL + \"/\" + id) .then(function(res) { return res.json(); }) .then(function(p) { var html = \"&lt;h2&gt;Editar producto&lt;/h2&gt;\"; html += \"&lt;form id='formulario'&gt;\"; html += \"&lt;input type='hidden' name='id' value='\" + p.id + \"'&gt;\"; html += \"&lt;label&gt;Nombre:&lt;/label&gt;&lt;input name='nombre' value='\" + p.nombre + \"'&gt;&lt;br&gt;\"; html += \"&lt;label&gt;Descripción:&lt;/label&gt;&lt;textarea name='descripcion'&gt;\" + p.descripcion + \"&lt;/textarea&gt;&lt;br&gt;\"; html += \"&lt;label&gt;Precio:&lt;/label&gt;&lt;input name='precio' type='number' value='\" + p.precio + \"' step='0.01'&gt;&lt;br&gt;\"; html += \"&lt;label&gt;Stock:&lt;/label&gt;&lt;input name='stock' type='number' value='\" + p.stock + \"'&gt;&lt;br&gt;\"; html += \"&lt;button type='button' onclick='actualizarProducto()'&gt;Actualizar&lt;/button&gt;\"; html += \"&lt;button type='button' onclick='mostrarLista()'&gt;Cancelar&lt;/button&gt;\"; html += \"&lt;/form&gt;\"; view.innerHTML = html; }); } // Actualizar producto function actualizarProducto() { var f = document.getElementById(\"formulario\"); var datos = { id: f.id.value, nombre: f.nombre.value, descripcion: f.descripcion.value, precio: parseFloat(f.precio.value), stock: parseInt(f.stock.value) }; fetch(API_URL + \"/\" + datos.id, { method: \"PUT\", headers: { \"Content-Type\": \"application/json\" }, body: JSON.stringify(datos) }) .then(function() { alert(\"Producto actualizado.\"); mostrarLista(); }) .catch(function(error) { alert(\"Error al actualizar: \" + error); }); } // Eliminar producto function eliminarProducto(id) { if (!confirm(\"¿Seguro que quieres eliminar el producto \" + id + \"?\")) return; fetch(API_URL + \"/\" + id, { method: \"DELETE\" }) .then(function() { alert(\"Producto eliminado.\"); mostrarLista(); }) .catch(function(error) { alert(\"Error al eliminar: \" + error); }); } // Mostrar lista al cargar la página mostrarLista(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; . Observa que, con esto, hemos construido nuestra primera aplicación SPA o single page application. Pero hacerlo de este modo tiene varios problemas: . | No es escalable. Imagina lo que habría que montar para añadir clientes, compras y otras entidades de datos: necesitaríamos decenas de vistas, cientos de eventos, validaciones, etc. El código se volvería rápidamente inmanejable. | No es reactivo. Hay que re-renderizar manualmente la página tras cada cambio en los datos. | No tiene código reutilizable. Todo está en funciones y cadenas HTML, diferentes para cada recurso. | Enrutamiento manual. El routing se hace cambiando el contenido del div “view”. | . Para solventar estos problemas existen los frameworks como Angular, Vue.js o React, entre otros. Nos adentraremos en ellos en la próxima unidad didáctica y construiremos un frontend SPA como se hace en la actualidad. ",
    "url": "https://iescelia.org/docs/fullstack/_site/api-rest/#36-consumir-el-api-rest-con-javascript",
    "relUrl": "/api-rest/#36-consumir-el-api-rest-con-javascript"
  },"33": {
    "doc": "3 Desarrollo de un API REST",
    "title": "3.7. Práctica: construir un API REST sobre la Tierra Media",
    "content": "En esta práctica vamos a crear una base de datos con información sobre la Tierra Media (el universo ficticio de Tolkien). Posteriormente escribiremos una API REST con Laravel que acceda a esos datos y probaremos a consumirlos con Postman. Por si hay alguien que no sepa de qué va esto, digamos que la Tierra Media es un universo de ficción creado por el escritor británico J. R. R. Tokien en sus obras \"El hobbit\" y \"El señor de los anillos\". La Tierra Media o Middle Earth cuenta con una detallada geografía inventada (con reinos, regiones y accidentes geográficos de todo tipo) y está poblado varias razas de criaturas como hombres, elfos, enanos, hobbits u orcos. Existen muchos personajes con nombre propio y multitud de objetos importantes que intervienen en las historias de Tolkien. Por supuesto, no es necesario que conozcas este universo ni a sus personajes para realizar este ejercicio, aunque probablemente es más divertido si los conoces. Paso 1: crear la infraestructura . Tablas de la base de datos . Basaremos nuestra API en la siguiente base de datos (respeta escrupulosamente los nombres de las tablas y las columnas para evitar posteriores conflictos). TABLAS MAESTRAS: . | realms (reinos): id, name (Rohan, Gondor, Mordor, etc.), ruler (nombre del rey o líder), alignment (Bien / Mal / Neutral), id_region (clave ajena) | heroes: id, name, race (humano, elfo, enano, hobbit, orco…), rank (capitán, explorador, etc.), realm_id (clave ajena), alive (boolean) | creatures (criaturas): id, name, species (trol, huargo, araña gigante, nazgûl…), threat_level (nivel de amenaza, de 1 a 10), id_region (clave ajena) | artifacts (artefactos u objetos): id, name, type (espada, anillo, gema, libro…), origin_realm_id (clave ajena), power_level (1–100), description | region: id, name | . TABLAS PIVOTE (relaciones N:N): . | artifact_hero: relación N:N entre heroe y artifact (hero_id, mission_id) | . Migraciones . Migración de la tabla regions . use Illuminate\\Database\\Migrations\\Migration; use Illuminate\\Database\\Schema\\Blueprint; use Illuminate\\Support\\Facades\\Schema; return new class extends Migration { public function up() { Schema::create('regions', function (Blueprint $table) { $table-&gt;id(); $table-&gt;string('name'); $table-&gt;timestamps(); }); } public function down() { Schema::dropIfExists('regions'); } }; . Migración de la tabla realms . use Illuminate\\Database\\Migrations\\Migration; use Illuminate\\Database\\Schema\\Blueprint; use Illuminate\\Support\\Facades\\Schema; return new class extends Migration { public function up() { Schema::create('realms', function (Blueprint $table) { $table-&gt;id(); $table-&gt;string('name'); $table-&gt;string('ruler'); $table-&gt;string('alignment'); $table-&gt;foreignId('region_id')-&gt;constrained('regions'); $table-&gt;timestamps(); }); } public function down() { Schema::dropIfExists('realms'); } }; . Migración de la tabla heroes . use Illuminate\\Database\\Migrations\\Migration; use Illuminate\\Database\\Schema\\Blueprint; use Illuminate\\Support\\Facades\\Schema; return new class extends Migration { public function up() { Schema::create('heroes', function (Blueprint $table) { $table-&gt;id(); $table-&gt;string('name'); $table-&gt;string('race'); $table-&gt;string('rank')-&gt;nullable(); $table-&gt;foreignId('realm_id')-&gt;constrained('realms'); $table-&gt;boolean('alive')-&gt;default(true); $table-&gt;timestamps(); }); } public function down() { Schema::dropIfExists('heroes'); } }; . Migración de la tabla creatures . use Illuminate\\Database\\Migrations\\Migration; use Illuminate\\Database\\Schema\\Blueprint; use Illuminate\\Support\\Facades\\Schema; return new class extends Migration { public function up() { Schema::create('creatures', function (Blueprint $table) { $table-&gt;id(); $table-&gt;string('name'); $table-&gt;string('species'); $table-&gt;unsignedTinyInteger('threat_level'); $table-&gt;foreignId('region_id')-&gt;constrained('regions'); $table-&gt;timestamps(); }); } public function down() { Schema::dropIfExists('creatures'); } }; . Migración de la tabla artifacts . use Illuminate\\Database\\Migrations\\Migration; use Illuminate\\Database\\Schema\\Blueprint; use Illuminate\\Support\\Facades\\Schema; return new class extends Migration { public function up() { Schema::create('artifacts', function (Blueprint $table) { $table-&gt;id(); $table-&gt;string('name'); $table-&gt;string('type'); $table-&gt;foreignId('origin_realm_id')-&gt;constrained('realms'); $table-&gt;unsignedTinyInteger('power_level'); $table-&gt;text('description')-&gt;nullable(); $table-&gt;timestamps(); }); } public function down() { Schema::dropIfExists('artifacts'); } }; . Migración de la tabla pivote artifact_hero . use Illuminate\\Database\\Migrations\\Migration; use Illuminate\\Database\\Schema\\Blueprint; use Illuminate\\Support\\Facades\\Schema; return new class extends Migration { public function up() { Schema::create('artifact_hero', function (Blueprint $table) { $table-&gt;id(); $table-&gt;foreignId('artifact_id')-&gt;constrained('artifacts'); $table-&gt;foreignId('hero_id')-&gt;constrained('heroes'); $table-&gt;timestamps(); }); } public function down() { Schema::dropIfExists('artifact_hero'); } }; . Seeders . Te dejo aquí algunos Seeders por si quieres rellenar tus tablas con algunos datos de prueba. Por supuesto, si lo prefieres, puedes inventarte tus propios datos o utilizar Faker para que sea Laravel quien se los invente. Seeder de la tabla regions . use Illuminate\\Database\\Seeder; use Illuminate\\Support\\Facades\\DB; class RegionsSeeder extends Seeder { public function run() { DB::table('regions')-&gt;insert([ ['name' =&gt; 'Eriador'], ['name' =&gt; 'Rhovanion'], ['name' =&gt; 'Mordor'], ['name' =&gt; 'Gondor'], ['name' =&gt; 'Rohan'], ]); } } . Seeder de la tabla realms . use Illuminate\\Database\\Seeder; use Illuminate\\Support\\Facades\\DB; class RealmsSeeder extends Seeder { public function run() { DB::table('realms')-&gt;insert([ ['name' =&gt; 'Gondor', 'ruler' =&gt; 'Aragorn', 'alignment' =&gt; 'Bien', 'region_id' =&gt; 4], ['name' =&gt; 'Rohan', 'ruler' =&gt; 'Éomer', 'alignment' =&gt; 'Bien', 'region_id' =&gt; 5], ['name' =&gt; 'Mordor', 'ruler' =&gt; 'Sauron', 'alignment' =&gt; 'Mal', 'region_id' =&gt; 3], ['name' =&gt; 'Erebor', 'ruler' =&gt; 'Thorin', 'alignment' =&gt; 'Bien', 'region_id' =&gt; 2], ]); } } . Seeder de la tabla heroes . use Illuminate\\Database\\Seeder; use Illuminate\\Support\\Facades\\DB; class HeroesSeeder extends Seeder { public function run() { DB::table('heroes')-&gt;insert([ ['name' =&gt; 'Aragorn', 'race' =&gt; 'Humano', 'rank' =&gt; 'Rey', 'realm_id' =&gt; 1, 'alive' =&gt; true], ['name' =&gt; 'Legolas', 'race' =&gt; 'Elfo', 'rank' =&gt; 'Arquero', 'realm_id' =&gt; 2, 'alive' =&gt; true], ['name' =&gt; 'Gimli', 'race' =&gt; 'Enano', 'rank' =&gt; 'Guerrero', 'realm_id' =&gt; 4, 'alive' =&gt; true], ['name' =&gt; 'Frodo', 'race' =&gt; 'Hobbit', 'rank' =&gt; 'Portador', 'realm_id' =&gt; 1, 'alive' =&gt; true], ]); } } . Seeder de la tabla creatures . use Illuminate\\Database\\Seeder; use Illuminate\\Support\\Facades\\DB; class CreaturesSeeder extends Seeder { public function run() { DB::table('creatures')-&gt;insert([ ['name' =&gt; 'Balrog', 'species' =&gt; 'Demonio', 'threat_level' =&gt; 10, 'region_id' =&gt; 2], ['name' =&gt; 'Nazgûl', 'species' =&gt; 'Espectro', 'threat_level' =&gt; 9, 'region_id' =&gt; 3], ['name' =&gt; 'Warg', 'species' =&gt; 'Lobo', 'threat_level' =&gt; 6, 'region_id' =&gt; 2], ['name' =&gt; 'Troll', 'species' =&gt; 'Troll', 'threat_level' =&gt; 7, 'region_id' =&gt; 5], ]); } } . Seeder de la tabla artifacts . use Illuminate\\Database\\Seeder; use Illuminate\\Support\\Facades\\DB; class ArtifactsSeeder extends Seeder { public function run() { DB::table('artifacts')-&gt;insert([ ['name' =&gt; 'Anillo Único', 'type' =&gt; 'Anillo', 'origin_realm_id' =&gt; 3, 'power_level' =&gt; 100, 'description' =&gt; 'Poder absoluto de Sauron'], ['name' =&gt; 'Andúril', 'type' =&gt; 'Espada', 'origin_realm_id' =&gt; 1, 'power_level' =&gt; 85, 'description' =&gt; 'Espada de Aragorn'], ['name' =&gt; 'Arco de Legolas', 'type' =&gt; 'Arco', 'origin_realm_id' =&gt; 2, 'power_level' =&gt; 70, 'description' =&gt; 'Arco del príncipe elfo'], ]); } } . Seeder de la tabla pivote artifact_hero . use Illuminate\\Database\\Seeder; use Illuminate\\Support\\Facades\\DB; class ArtifactHeroSeeder extends Seeder { public function run() { DB::table('artifact_hero')-&gt;insert([ ['artifact_id' =&gt; 1, 'hero_id' =&gt; 4], // Frodo lleva el Anillo Único ['artifact_id' =&gt; 2, 'hero_id' =&gt; 1], // Aragorn lleva la espada Andúril ['artifact_id' =&gt; 3, 'hero_id' =&gt; 2], // Legolas lleva el \"Arco de Legolas\" (claro) ]); } } . Paso 2: escribir el API . Crea con Laravel un API REST para acceder a los datos de las tablas anteriores. Los endpoints a los que debería responder este API son estos: . Regiones (regions) . | GET /regions –&gt; Listar todas las regiones | GET /regions/{id} –&gt; Obtener los datos de una región concreta | POST /regions –&gt; Crear una nueva región | PUT /regions/{id} –&gt; Actualizar una región existente | DELETE /regions/{id} –&gt; Eliminar una región | . Reinos (realms) . | GET /realms –&gt; Listar todos los reinos | GET /realms/{id} –&gt; Mostrar detalles de un reino, incluyendo región, héroes y artefactos | POST /realms –&gt; Crear un nuevo reino | PUT /realms/{id} –&gt; Actualizar un reino existente | DELETE /realms/{id} –&gt; Eliminar un reino | . Héroes (heroes) . | GET /heroes –&gt; Listar todos los héroes | GET /heroes/{id} –&gt; Mostrar detalles de un héroe, incluyendo reino y artefactos | POST /heroes –&gt; Crear un nuevo héroe | PUT /heroes/{id} –&gt; Actualizar un héroe existente | DELETE /heroes/{id} –&gt; Eliminar un héroe | . Criaturas (creatures) . | GET /creatures –&gt; Listar todas las criaturas | GET /creatures/{id} –&gt; Mostrar detalles de una criatura, incluyendo región | POST /creatures –&gt; Crear una nueva criatura | PUT /creatures/{id} –&gt; Actualizar una criatura existente | DELETE /creatures/{id} –&gt; Eliminar una criatura | . Artefactos (artifacts) . | GET /artifacts –&gt; Listar todos los artefactos | GET /artifacts/{id} –&gt; Mostrar detalles de un artefacto, incluyendo reino y héroes que lo poseen | POST /artifacts –&gt; Crear un nuevo artefacto | PUT /artifacts/{id} –&gt; Actualizar un artefacto existente | DELETE /artifacts/{id} –&gt; Eliminar un artefacto | . Asignación de artefactos a héroes (artifact_hero) . | POST /artifact-hero –&gt; Asignar un artefacto a un héroe (insert en pivot) | DELETE /artifact-hero –&gt; Retirar un artefacto de un héroe | GET /heroes/{id}/artifacts –&gt; Listar todos los artefactos de un héroe | GET /artifacts/{id}/heroes –&gt; Listar todos los héroes que poseen un artefacto | . Endpoints adicionales (opcionales) . | /realms/{id}/heroes –&gt; listar héroes de un reino específico | /regions/{id}/creatures –&gt; listar criaturas de una región específica | /heroes/alive –&gt; listar héroes vivos | /creatures/dangerous?level=8 –&gt; listar criaturas con amenaza alta | /artifacts/top –&gt; listar artefactos con power_level mayor a 90 | . Paso 3: probar y consumir el API . Vamos a terminar comprobando si el API que hemos construido realmente funciona. | Prueba algunos de los endpoints anteriores creando manualmente algunas peticiones en una colección de Postman. | Prueba todos los endpoints: . | Genera, con ayuda de ChatGPT u otra IA generativa, un archivo .json para probar todos los endpoints anteriores. | Importa el .json en Postman. | Lanza todos los requests para comprobar si tu API funciona con todas las peticiones. | . | . ",
    "url": "https://iescelia.org/docs/fullstack/_site/api-rest/#37-pr%C3%A1ctica-construir-un-api-rest-sobre-la-tierra-media",
    "relUrl": "/api-rest/#37-práctica-construir-un-api-rest-sobre-la-tierra-media"
  },"34": {
    "doc": "3 Desarrollo de un API REST",
    "title": "3 Desarrollo de un API REST",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/api-rest/",
    "relUrl": "/api-rest/"
  },"35": {
    "doc": "4 Vue.js",
    "title": "4. Vue.js",
    "content": ". | 4.1. Introducción a Vue.js | 4.2. Cómo se usa Vue.js | 4.3. Vue.js como librería JavaScript | 4.4. Vue.js con npm para aplicaciones frontend . | 4.4.1. Pasos para desarrollar un frontend con Vue | 4.4.2. Pasos para desplegar un frontend con Vue | 4.4.3. Pedir datos al servidor: fetch y axios | 4.4.4. Estructura típica de un componente vue | 4.4.5. Enrutamiento en el cliente | 4.4.6. Ejemplo completo: frontend con Vue v1 - solo mostrar datos | 4.4.7. Ejemplo completo: frontend con Vue v2 - CRUD completo, enrutamiento en servidor | 4.4.8. Ejemplo completo: frontend con Vue v3 - CRUD completo, enrutamiento en cliente | . | 4.5. Vue.js integrado en Laravel para aplicaciones full stack . | 4.5.1. Cómo instalar Vue dentro de Laravel paso a paso | 4.5.2. Estructura de directorios de un proyecto Laravel + Vue | 4.5.3. Ejemplo completo: CRUD con Vue.js y Laravel | . | 4.6. Práctica final: CRUD de cursos y estudiantes | . Vue.js es un framework para Javascript orientado al diseño de interfaces de usuario para aplicaciones web y a la creación de aplicaciones OVA (One View Application) o SPA (Single Page Application). Es similar a otros frameworks como Angular, React o Svelte, aunque con una curva de aprendizaje menos empinada, y tiene licencia de software libre. En este tema vamos a aprender los fundamentos de Vue.js para consumir los API REST que ya sabemos construir, de modo que podamos crear una aplicación de tipo OVA o SPA de forma rápida, eficiente y flexible, y lo haremos con dos enfoques diferentes: usando Vue para crear un frontend independiente del API (que sería nuestro backend) e integrando las dos partes en una sola aplicación (full stack). ",
    "url": "https://iescelia.org/docs/fullstack/_site/vue-js/#4-vuejs",
    "relUrl": "/vue-js/#4-vuejs"
  },"36": {
    "doc": "4 Vue.js",
    "title": "4.1. Introducción a Vue.js",
    "content": "Vue.js es lo que se llama un framework JavaScript progresivo diseñado para construir interfaces de usuario modernas y dinámicas. Se centra en la creación de Single Page Applications (SPA), es decir, aplicaciones web que cargan una única página HTML y actualizan su contenido de forma dinámica sin necesidad de recargar todo el sitio cada vez que el usuario realiza una acción. Ventajas principales . | Evita recargar la página completa con cada petición al servidor. | Permite crear componentes reutilizables, lo que hace el desarrollo más limpio y modular. | Incluye enrutamiento en cliente, lo que mejora la experiencia del usuario al navegar sin interrupciones. | Se integra fácilmente con Laravel, ya que este framework lo incluye preinstalado. | Es open source y cuenta con una comunidad muy activa. | . Otros frameworks similares . | Angular (Google, desde 2010) | React (Facebook/Meta, desde 2013) | Vue.js (open source, desde 2014) | Svelte (open source, desde 2016) | . ",
    "url": "https://iescelia.org/docs/fullstack/_site/vue-js/#41-introducci%C3%B3n-a-vuejs",
    "relUrl": "/vue-js/#41-introducción-a-vuejs"
  },"37": {
    "doc": "4 Vue.js",
    "title": "4.2. Cómo se usa Vue.js",
    "content": "Vue.js se puede utilizar de tres formas diferentes, según lo que necesites construir: . Opción 1: Como una librería JavaScript más . Puedes incluir Vue directamente desde un CDN dentro de un archivo HTML. Es la manera más simple de empezar a experimentar. &lt;script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"&gt;&lt;/script&gt; . A partir de aquí, puedes usar Vue dentro de esta página. Es ideal para probar ejemplos pequeños o hacer prototipos rápidos, pero no podrás hacer uso de características importantes de Vue como usar import/export para cargar otros componentes o para diseñar soluciones escalables. Veremos esta forma de trabajar con Vue en el apartado 4.3 de este tema. Opción 2: Con npm para proyectos frontend . Instalando Node.js y npm, puedes crear proyectos Vue completos exprimiendo toda su potencia: componentes, build tools, dependencias, etc. Esta opción se usa cuando queremos escribir una aplicación web de tipo frontend, es decir, que se ejecute en el cliente web consumiendo los datos producidos por el backend (que se ejecuta en el servidor). Este tipo de división frontend/backend, como ya sabes, ha sido y sigue siendo muy común en la industria, porque independiza por completo un proyecto de otro, aunque complica y encarece el desarrollo de todo el conjunto. Veremos esta forma de trabajar con Vue en el apartado 4.4 de este tema. Opción 3: Integrado en Laravel . Si ya usas Laravel, puedes trabajar con Vue directamente dentro del proyecto Laravel. Así conseguiríamos un verdader desarrollo full stack (backend con Laravel + frontend con Vue), todo en el mismo entorno. Veremos esta forma de trabajar con Vue en el apartado 4.5 de este tema. ",
    "url": "https://iescelia.org/docs/fullstack/_site/vue-js/#42-c%C3%B3mo-se-usa-vuejs",
    "relUrl": "/vue-js/#42-cómo-se-usa-vuejs"
  },"38": {
    "doc": "4 Vue.js",
    "title": "4.3. Vue.js como librería JavaScript",
    "content": "La forma más sencilla de empezar con Vue es usarlo como una librería directamente en tu HTML. El aspecto que tendría ese HTML sería algo así: . &lt;!DOCTYPE html&gt; &lt;html lang=\"es\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Probando Vue.js&lt;/title&gt; &lt;script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script&gt; const { createApp } = Vue; const app = createApp({ /* Código Vue aquí */ }); app.mount('#app'); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; . Esto te permitirá experimentar con la sintaxis de Vue y entender su reactividad. Esta modalidad no es recomendable para proyectos grandes, pero la emplearemos ahora para que conozcas de forma práctica las principales características de Vue a través de un puñado de ejemplos. Puedes descargar el código fuente completo de todos los ejemplos desde aquí. Ejemplo 1 – Hola mundo . Observa cómo se extrae la propiedad createApp del objeto Vue y se usa para construir otro objeto (app). Este objeto, que puede llamarse de otro modo aunque suele denominarse así, app, se utiliza para asignarle datos (con data()) o, como veremos en otros ejemplos, métodos, templates, eventos, etc. Finalmente, el objeto app se monta, es decir, se renderiza dentro del árbol DOM de la página. Observa asimismo que, dentro del bloque HTML, hay un div con el id=”app”. Ese id tiene que coincidir con el nombre de la variable donde se montó Vue. El resultado final será que el texto {{ message }} se sustituirá por el valor que se le dio en la función data(). No dudes en analizar el código detenidamente y probarlo en tu navegador web para comprobar que funcione. &lt;!DOCTYPE html&gt; &lt;html lang=\"es\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Ejemplo de uso de Vue.js&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; {{ message }} &lt;/div&gt; &lt;script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"&gt;&lt;/script&gt; &lt;script&gt; const { createApp } = Vue; // Extrae createApp del objeto Vue const app = createApp({ data() { return { message: 'Hola mundo' }; } }); app.mount('#app'); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; . Ejemplo 2 – Pregunta y respuesta . En este ejemplo vamos a ver cómo data() puede preparar múltiples datos para que sean renderizados en el árbol DOM. &lt;!DOCTYPE html&gt; &lt;html lang=\"es\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Ejemplo de uso de Vue.js&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;p&gt;La pregunta es: {{ pregunta }}.&lt;/p&gt; &lt;p&gt;La respuesta es: {{ respuesta }}.&lt;/p&gt; &lt;/div&gt; &lt;script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"&gt;&lt;/script&gt; &lt;script&gt; const { createApp } = Vue; const app = createApp({ data() { return { pregunta: \"¿Cómo te llamas?\", respuesta: \"Pepito Pérez\" }; } }); app.mount('#app'); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; . Ejemplo 3 – Condicional simple . Vue también permite hacer salidas HTML condicionadas a los valores de los datos, como puedes ver en este ejemplo. Cambia el valor del data visible dentro de Vue para ver qué efecto tiene en la página final. &lt;!DOCTYPE html&gt; &lt;html lang=\"es\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Ejemplo de uso de Vue.js&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;p v-if=\"visible\"&gt;Ahora puedes verme&lt;/p&gt; &lt;/div&gt; &lt;script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"&gt;&lt;/script&gt; &lt;script&gt; const { createApp } = Vue; const app = createApp({ data() { return { visible: true }; } }); app. mount('#app'); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; . Ejemplo 4 – Bucle . Igual que podemos hacer salidas HTML condicionadas por los datos, también podemos iterar sobre los datos para hacer salidas múltiples. Observa este código y ejecútalo en tu navegador web: . &lt;!DOCTYPE html&gt; &lt;html lang=\"es\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Ejemplo de uso de Vue.js&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;p v-for=\"animal in arrayAnimales\"&gt; {{ animal }} &lt;/p&gt; &lt;/div&gt; &lt;script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"&gt;&lt;/script&gt; &lt;script&gt; const { createApp } = Vue; const app = createApp({ data() { return { arrayAnimales: ['Perro', 'Gato', 'Oveja', 'Caballo'] }; } }); app.mount('#app'); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; . Ejemplo 5 – Formulario . En este ejemplo puedes ver cómo Vue posibilida el mapeo o emparejamiento de campos de un formulario HTML con variables declaradas en el data() de Vue, de modo que, si cambia una, cambia automáticamente la otra: . &lt;!DOCTYPE html&gt; &lt;html lang=\"es\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Ejemplo de uso de Vue.js&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;p&gt;Nombre: &lt;input type=\"text\" v-model=\"nombre\"&gt;&lt;/p&gt; &lt;p&gt;Tu nombre es: {{ nombre }}&lt;/p&gt; &lt;/div&gt; &lt;script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"&gt;&lt;/script&gt; &lt;script&gt; const { createApp } = Vue; const app = createApp({ data() { return { nombre: '' }; } }); app.mount('#app'); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; . Ejemplo 6 – Evento click . Introducimos aquí los methods de Vue para que veas cómo puedes capturar un evento de tipo click() (observa el @click en la sección HTML) y asociarlo a código Vue. &lt;!DOCTYPE html&gt; &lt;html lang=\"es\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Ejemplo de uso de Vue.js&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;p&gt;Nombre: &lt;input type=\"text\" v-model=\"nombre\"&gt;&lt;/p&gt; &lt;p&gt;&lt;button @click=\"saludar\"&gt;Púlsame&lt;/button&gt;&lt;/p&gt; &lt;/div&gt; &lt;script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"&gt;&lt;/script&gt; &lt;script&gt; const { createApp } = Vue; const app = createApp({ data() { return { nombre: '' }; }, methods: { saludar() { alert('Hola, ' + this.nombre); } } }); app.mount('#app'); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; . Ejemplo 7 – Evento key . Otro evento que a menudo nos interesa capturar (hay más, pero se manejan de forma parecida) es el evento de “tecla pulsada”. En el siguiente ejemplo vemos cómo asociar ese evento (@key) a un elemento HTML y disparar con él un método declarado en Vue. &lt;!DOCTYPE html&gt; &lt;html lang=\"es\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Ejemplo de uso de Vue.js&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;p&gt;Nombre: &lt;input type=\"text\" @keyup.enter=\"saludar\" v-model=\"nombre\"&gt;&lt;/p&gt; &lt;p&gt;&lt;button @click=\"saludar\"&gt;Púlsame&lt;/button&gt;&lt;/p&gt; &lt;/div&gt; &lt;script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"&gt;&lt;/script&gt; &lt;script&gt; const { createApp } = Vue; const app = createApp({ data() { return { nombre: '' }; }, methods: { saludar() { alert('Hola, ' + this.nombre); } } }); app.mount('#app'); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; . Ejemplo 8 – Componente “Hola mundo” . Un elemento fundamental de Vue son los componentes. Se trata de bloques reutilizables que pueden contener, entre otras cosas, un template o fragmento de código HTML con datos de Vue en su interior, además de data(), methods(), etc. El siguiente componente de Vue es el más simple posible: apenas un fragmento de HTML estático. Pero en este ejemplo puedes ver cómo reutilizamos el componente todas las veces que lo necesitemos sin tener que volver a escribirlo. &lt;!DOCTYPE html&gt; &lt;html lang=\"es\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Ejemplo de uso de Vue.js&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;hola-mundo&gt;&lt;/hola-mundo&gt; &lt;hola-mundo&gt;&lt;/hola-mundo&gt; &lt;/div&gt; &lt;script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"&gt;&lt;/script&gt; &lt;script&gt; const { createApp } = Vue; // Creamos la app const app = createApp({}); // Registramos el componente hola-mundo app.component('hola-mundo', { template: '&lt;div&gt;¡Hola mundo!&lt;/div&gt;' }); // Montamos la app app.mount('#app'); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; . Ejemplo 9 – Componente “mis-tareas” . El siguiente ejemplo muestra un componente un poquito más elaborado que “Hola mundo” (ejemplo 8). En este caso, tenemos un componente llamado “mis-tareas” con un HTML algo más complejo, que incluye datos (se itera sobre ellos con v-for), eventos (como @click), así como sus propios data() y methods. &lt;!DOCTYPE html&gt; &lt;html lang=\"es\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Ejemplo de uso de Vue.js&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;mis-tareas&gt;&lt;/mis-tareas&gt; &lt;/div&gt; &lt;script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"&gt;&lt;/script&gt; &lt;script&gt; const { createApp } = Vue; const app = createApp({}); // Registro del componente \"mis-tareas\" app.component('mis-tareas', { template: `&lt;div&gt; &lt;ul&gt; &lt;li v-for=\"tarea in tareas\" :key=\"tarea\"&gt;{{ tarea }}&lt;/li&gt; &lt;/ul&gt; Nueva tarea: &lt;input type=\"text\" v-model=\"nuevaTarea\" @keyup.enter=\"crearTarea\"&gt; &lt;button @click=\"crearTarea\"&gt;Añadir tarea&lt;/button&gt; &lt;/div&gt;`, data() { return { nuevaTarea: '', tareas: [] }; }, methods: { crearTarea() { if (this.nuevaTarea.trim() !== '') { this.tareas.push(this.nuevaTarea.trim()); this.nuevaTarea = ''; } } } }); app.mount('#app'); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; . Ejemplo 10 – Reutilizar el componente “mis-tareas” . En este último ejemplo de introducción vamos a ver cómo se puede reutilizar el componente “mis-tareas” para ilustrar que cada ocurrencia del componente tiene su propio estado, es decir, su propio conjunto de datos. Lee el código y ejecútalo luego en tu navegador web, para ver qué pasa. &lt;!DOCTYPE html&gt; &lt;html lang=\"es\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Ejemplo de uso de Vue.js&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;h1&gt;Tareas del equipo de trabajo&lt;/h1&gt; &lt;h2&gt;Pepito Pérez&lt;/h2&gt; &lt;mis-tareas&gt;&lt;/mis-tareas&gt; &lt;h2&gt;Susana Sánchez&lt;/h2&gt; &lt;mis-tareas&gt;&lt;/mis-tareas&gt; &lt;/div&gt; &lt;script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"&gt;&lt;/script&gt; &lt;script&gt; const { createApp } = Vue; const app = createApp({}); app.component('mis-tareas', { template: `&lt;div&gt; &lt;ul&gt; &lt;li v-for=\"(tarea, index) in tareas\" :key=\"index\"&gt; {{ tarea }} &lt;/li&gt; &lt;/ul&gt; Nueva tarea: &lt;input type=\"text\" v-model=\"nuevaTarea\" @keyup.enter=\"crearTarea\"&gt; &lt;button @click=\"crearTarea\"&gt;Añadir tarea&lt;/button&gt; &lt;/div&gt;`, data() { return { nuevaTarea: '', tareas: [] } }, methods: { crearTarea() { this.tareas.push(this.nuevaTarea); this.nuevaTarea = ''; } } }); app.mount('#app'); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; . ",
    "url": "https://iescelia.org/docs/fullstack/_site/vue-js/#43-vuejs-como-librer%C3%ADa-javascript",
    "relUrl": "/vue-js/#43-vuejs-como-librería-javascript"
  },"39": {
    "doc": "4 Vue.js",
    "title": "4.4. Vue.js con npm para aplicaciones frontend",
    "content": "Cuando quieres desarrollar una SPA completa, Vue se puede usar para construir un frontend que ataque a un backend escrito en cualquier otro lenguaje (puede ser PHP con Laravel o cualquier otra cosa). En esta situación estaremos hablando de dos proyectos completamente independientes: uno para el front y otro para el back. De hecho, pueden existir varios front atacando al mismo back, cada uno de ellos ofreciendo una solución distinta. Si lo usamos de este modo, Vue se utiliza junto con Node.js, npm y herramientas modernas de compilación como Vite. También usará el API fetch o Axios para lanzar las peticiones de datos al servidor. 4.4.1. Pasos para desarrollar un frontend con Vue . PASO 1. Instala Node, npm y Vite . La noticia rara es que no necesitamos Node.js, pero lo instalaremos porque viene con npm y vite, que son las herramientas que realmente nos harán falta. Pero ¿qué diferencia hay entre estos tres elementos? . | Node.js es un entorno de ejecución de JavaScript para servidores web. Añade al JavaScript convencional soporte para acceso a bases de datos, gestión de sesiones, etc. Por tanto, no lo usaremos directamente, pero sí nos harán falta npm y vite, que forman parte de Node. | npm (Node Package Manager) es el gestor de paquetes de Node. Nos resultará imprescindible para gestionar las dependencias de Vue y para traducir Vue a JavaScript comprensible por los navegadores web. Ten en cuenta que Vue no puede ser comprendido por ningún navegador, por lo que su código debe convertirse a JavaScript convencional. | Vite es un servidor rápido de desarrollo que traduce en tiempo real nuestro código Vue a JavaScript convencional para que podamos ir probando nuestro código conforme lo desarrollamos. | . Después de instalar Node, comprueba que tanto Node como npm funcionan: . $ node -v $ npm -v . Esto te devolverá la versión de cada uno de ellos. Necesitarás la versión 20 de Node o superior. PASO 2. Crea un nuevo proyecto Vue . Crearemos un proyecto vacío de Vue con este comando de npm: . $ npm create vue@latest . Durante la creación del proyecto, npm te hará varias preguntas, como: . | Project name: escribe el que quieras (te sugerirá algo como “frontend-vue”). | TypTypeScript, JSX Support, etc: No marques nada, no lo lo necesitas por ahora. | Experimental features: No marques ninguna. | Skip example code: Puedes responder «yes» para que no te cree ningún archivo .vue de ejemplo. | . PASO 3. Revisa la estructura de directorios . Tras la creación del proyecto se debe haber desplegado una estructura de directorios como esta: . src/ ├─ main.js ├─ App.vue └─ components/ ├─ Componente1.vue ├─ Componente2.vue ├─ Componente3.vue └─ Etc. | main.js es el punto de entrada de la aplicación. Se encarga de hacer el createApp() y montar la aplicación en un div de HTML (típicamente, un div con id=”#app”). | App.vue es el componente raíz de la aplicación. Funciona como contenedor principal donde se renderizan todos los demás componentes. Generalmente incluye la estructura base de la app: encabezado, navegación, etc. | En la carpeta components se añaden todos los componentes que vayamos a necesitar. | . Los componentes de Vue suelen tener todos esta estructura (profundizaremos en ello más adelante): . &lt;template&gt; HTML del componente &lt;/template&gt; &lt;script&gt; Código Vue y JavaScript del componente &lt;/script&gt; &lt;style&gt; Estilos CSS del componente &lt;/style&gt; . PASO 4. Instala las dependencias necesarias . npm se encargará de instalar todo lo necesario para que Vue funcione. Simplemente teclea: . $ cd frontend-vue # O el nombre de la carpeta de tu proyecto $ npm install . PASO 5. Lanza/detén el servidor de desarrollo . $ npm run dev . Esto hace que vite traduzca todo el código Vue a JavaScript para que puedas ver el resultado en un navegador web. La traducción se hará en tiempo real, es decir, cualquier cambio en Vue se podrá revisar inmediatamente en el navegador. El servidor de desarrollo suele dejar disponible tu frontend en http://localhost:5173 . Cuando termines la sesión de trabajo, detén el servidor de desarrollo pulsando CTRL + C. PASO 6. Lanza tu backend . Asegúrate de que tu backend está corriendo también, o si no el frontend no tendrá de dónde sacar los datos para trabajar. El backend puede estar funcionando en tu servidor local o en cualquier servidor remoto. Esto es indiferente, porque el front y el back son por completo independientes en este tipo de aplicaciones. PASO 7. Revisa posibles errores de CORS . Cuando empieces a desarrollar el frontend puedes obtener errores de CORS al pedir datos al servidor. En ese caso, deberás configurar el CORS en tu backend. CORS (Cross Origin Resource Sharing) es un mecanismo de seguridad del servidor que impide que un frontend alojado en otro lugar acceda a sus datos, salvo que le indiquemos al servidor que ese frontend es de confianza. El CORS se configura de forma diferente según el backend que hayas montado. Por ejemplo, con Laravel se hace editando el archivo config/cors.php. 4.4.2. Pasos para desplegar un frontend con Vue . Cuando tu frontend esté terminado y listo para desplegar en un servidor de internet, sigue estos pasos: . | Genera y optimiza todo el código del frontend: . $ npm run build . Esto creará código JavaScript minimizado y optimizado, comprensible por los navegadores web. El código optimizado se guardará en la carpeta dist . | Copia el contenido de dist a tu carpeta public de Laravel o a una carpeta de acceso público vía web de tu servidor (htdocs o algo así; dependerá del servidor). | Configura el CORS en tu servidor si es necesario. Esto tendrás que hacerlo si el front y el back están ubicados en servidores diferentes. | . 4.4.3. Pedir datos al servidor: fetch y axios . El frontend de Vue suele pedir datos al backend usando el API fetch o la librería Axios: . | El API fetch es una interfaz nativa de JavaScript que permite hacer solicitudes HTTP (como GET, POST, etc.) desde el navegador web en segundo plano, sin recargar la página ni detener la ejecución de la misma. Es decir, permite enviar y recibir datos de servidores sin que el usuario de la web se percate de ello. | La librería Axios es una librería de JavaScript que hace lo mismo que el API fetch, pero ofrece algunas funcionalidades adicionales, como conversión automática a JSON. | . Nosotros usaremos el API fetch en los próximos ejemplos, pero no entraremos en muchos detalles porque la estudiaréis en el módulo de “Desarrollo web en entorno cliente”. 4.4.4. Estructura típica de un componente vue . Los componentes de Vue suelen tener todos esta estructura: . &lt;template&gt; HTML del componente &lt;/template&gt; &lt;script&gt; Código Vue y JavaScript del componente &lt;/script&gt; &lt;style&gt; Estilos CSS del componente &lt;/style&gt; . Dentro de la sección script, un componente puede llevar muchas cosas. Las más habituales son: . | data() → código JS que devuelve un objeto con el estado actual del componente. | mounted() → código JS que se ejecuta cuando el componente se ha desplegado en el árbol DOM de la página. | created() → código JS que se ejecuta al crear el componente, antes de que esté en el DOM. | methods → contiene funciones JS que se pueden invocar desde el template (con los eventos @click, @submit, etc) | computed → define propiedades calculadas a partir de otras propiedades. Se recalculan automáticamente si alguna cambia. | template → estructura visual (HTML) del componente. | . Por ejemplo, en este sencillo componente puedes ver cómo se escriben muchos de los elementos Vue de la lista anterior: . &lt;template&gt; &lt;h2&gt;Contador: 8&lt;/h2&gt; &lt;p&gt;Doble del contador (computado): &lt;/p&gt; &lt;button @click=\"increment\"&gt;Incrementar&lt;/button&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'Contador', data() { // Devuelve el estado del componente return { count: 0 }; }, created() { // Se ejecuta cuando el componente es creado console.log('Componente creado. (created)'); }, mounted() { // Se ejecuta cuando el componente se monta en el árbol DOM de la página console.log('Componente montado en el DOM. (mounted)'); }, methods: { // Se ejecutan como respuesta a eventos en la página (ver @click más arriba) increment() { this.count++; } }, computed: { // Se ejecutan si cambian los datos base (this.count, en este caso) doubleCount() { return this.count * 2; } } }; &lt;/script&gt; . 4.4.5. Enrutamiento en el cliente . Otra de las cosas que puede hacer Vue es enrutar en el lado del cliente. Es decir, en lugar de ser Laravel (o quien sea que esté en el lado del servidor) quien haga el enrutamiento de cada endpoint hacia un controlador y un método para generar una nueva vista, es el propio navegador quien se encarga de decidir qué hay que hacer con cada ruta, sin llamar al servidor. Generalmente, con este tipo de enrutamiento, cada ruta provocará la carga de un nuevo componente de Vue, con lo cual la página cambia ante los ojos del usuario sin que haya intervenido el servidor. Por ejemplo, la ruta /home puede cargar un componente llamado Home.vue y la ruta /about puede cargar un componente llamado About.vue. Esto se indica así en Vue, en un archivo especial de rutas: . const routes = [ { path: '/home', component: Home }, { path: '/about', component: About } ] . Ninguno de esos dos endpoints (/home o /about) llama realmente al servidor, sino que los componentes ya existen en el cliente, por lo que la carga es mucho más rápida que en una aplicación web tradicional. Por supuesto, algunos componentes pueden requerir datos del servidor. Esos componentes lanzarán una petición en segundo plano al servidor desde su propio código, normalmente usando fetch o axios, y esperarán una respuesta JSON para actualizar lo que el usuario está viendo. En estos casos sí intervendrá, además del enrutador del cliente, el enrutador del servidor. Enrutar en el cliente, por lo tanto, tiene algunas ventajas sobre el enrutamiento en el servidor: . | El usuario puede usar atrás/adelante del navegador y todo funciona sin recargar ni reenviar datos al servidor. | Los «megacomponentes» pueden dividirse con más facilidad en componentes más pequeños. | El backend se simplifica (aunque el frontend se complica en la misma medida). | La navegación es más fluida porque hay menos accesos al servidor. | . Cambios que hay que hacer para enrutar en el cliente . Por defecto, Vue no hará enrutamiento en el frontend, pero puedes activar ese enrutamiento fácilmente: . | Instala en enrutador de Vue (si aún no lo has hecho). $ npm install vue-router . | Define las rutas y los componentes a los que cada ruta corresponde en un archivo de rutas. Este archivo puedes llamarlo como quieras, como por ejemplo src/router.js. Debe tener un aspecto como este: . import { createRouter, createWebHistory } from 'vue-router' // Importamos todos los componentes que vayamos a direccionar desde en enrutador import ProductosList from './components/ProductosList.vue' import ProductoForm from './components/ProductoForm.vue' // Definimos todas las rutas y el componente al que apuntan const routes = [ { path: '/', redirect: '/productos' }, { path: '/productos', component: ProductosList }, { path: '/productos/nuevo', component: ProductoForm } ] const router = createRouter({ history: createWebHistory(), routes }) export default router . | Carga el enrutador en tu main.js, antes de montar la app: . import router from './router' createApp(App).use(router).mount(#app); . | Usa &lt;router-link&gt; en los enlaces a los componentes en lugar de links normales con &lt;a href...&gt;. Por ejemplo, en tu App.vue podría aparecer algo como esto: . &lt;template&gt; &lt;div&gt; &lt;h1&gt;Mi App de Productos&lt;/h1&gt; &lt;router-link to=\"/productos\"&gt;Productos&lt;/router-link&gt; &lt;router-link to=\"/productos/nuevo\"&gt;Nuevo Producto&lt;/router-link&gt; &lt;router-view /&gt; &lt;/div&gt; etc... &lt;/template&gt; . Observa como cada &lt;router-link&gt; te lleva a una de las rutas que hemos definido en routes.js, que a su vez provocan la carga de un componente Vue . El elemento &lt;router-view&gt; que aparece justo después de los &lt;router-link&gt; indica a Vue que ahí, justo en ese punto, debe renderizar el componenten que se corresponda con la ruta actual. | . 4.4.6. Ejemplo completo: frontend con Vue v1 - solo mostrar datos . Para asimilar mejor toda esta sección e ilustrar bien cómo se usa Vue para construir frontends independientes del backend, vamos a crear un frontend con Vue para consumir el API «Compras» que programamos como ejemplo en el tema anterior. Recuerda que este API servía los datos de tres tablas: . | Productos(id, nombre, descripcion, precio, stock) → son los productos de una tienda online ficticia. | Clientes(id, nombre, apellido1, apellido2 y email) → son los clientes de la tienda online. | Compras(cliente_id, producto_id, fecha, hora, unidades) → es la relación N:N entre Productos y Clientes. | . Vamos a programar 3 versiones sucesivamente más complejas de este frontend: . | Versión 1: solo mostrará los listados de datos y no permitirá modificarlos. Es la más sencilla y por donde debes empezar a leer el código. | Versión 2: añadiremos funcionalidades CRUD a la versión 1, por lo que ya tendremos una aplicación 100% funcional, aunque aún hará enrutamiento en el servidor. | Versión 3: añadiremos enrutamiento en el cliente a la versión 2, por lo que tendremos una verdadera aplicación SPA que minimiza las recargas y los accesos al servidor. | . En la primera versión, crearemos los tres componentes para que tan solo muestren los datos disponibles en la base de datos, pero no permitan manipularlos (ni insertar, ni modificar, ni borrar). La app principal de Vue (#app) estará dividida, pues, en 3 componentes: . | productos-list → lista de productos | clientes-list → lista de clientes | compras-list → lista de compras | . ACCEDE AQUÍ AL CÓDIGO COMPLETO DE ESTA VERSIÓN . Código más importante de la versión 1 . Archivo main.js . Como siempre, este será el punto de entrada de la aplicación. Se encargará tan solo de montar el elemento app: . import { createApp } from 'vue' import App from './App.vue' createApp(App).mount('#app') . Archivo App.vue . Este componente contiene la plantilla (template) principal de la aplicación. Observa cómo se usan los v-if y v-else para renderizar un componente &lt;productos-list&gt;, &lt;clientes-list&gt; o &lt;compras-list&gt; según qué vista esté activa en este momento. Esto no será necesario cuando usemos enrutamiento en el cliente en la versión 3 de la aplicación. &lt;template&gt; &lt;div class=\"container\"&gt; &lt;h1&gt;Tienda Online - Panel de gestión&lt;/h1&gt; &lt;nav&gt; &lt;button @click=\"vista = 'productos'\"&gt;Productos&lt;/button&gt; &lt;button @click=\"vista = 'clientes'\"&gt;Clientes&lt;/button&gt; &lt;button @click=\"vista = 'compras'\"&gt;Compras&lt;/button&gt; &lt;/nav&gt; &lt;hr /&gt; &lt;section v-if=\"vista === 'productos'\"&gt; &lt;productos-list /&gt; &lt;/section&gt; &lt;section v-else-if=\"vista === 'clientes'\"&gt; &lt;clientes-list /&gt; &lt;/section&gt; &lt;section v-else&gt; &lt;compras-list /&gt; &lt;/section&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import ProductosList from './components/ProductosList.vue' import ClientesList from './components/ClientesList.vue' import ComprasList from './components/ComprasList.vue' export default { components: { ProductosList, ClientesList, ComprasList }, data() { return { vista: 'productos' } } } &lt;/script&gt; &lt;style&gt; /* Aquí irían los estilos CSS */ &lt;/style&gt; . Archivo components/ProductosList.vue . Este componente prepara los datos de los productos para mostarlos en una tabla HTML. Observa dos cosas: . | Cómo se hace un v-for sobre el array de productos para generar la tabla HTML con los datos. | Cómo se hace la llamada al servidor con fetch() en cuanto está montado en el DOM de la página para recibir como respuesta un JSON con los datos de los productos. | . &lt;template&gt; &lt;div&gt; &lt;h2&gt;Productos&lt;/h2&gt; &lt;table border=\"1\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Nombre&lt;/th&gt; &lt;th&gt;Descripción&lt;/th&gt; &lt;th&gt;Precio&lt;/th&gt; &lt;th&gt;Stock&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=\"producto in productos\" :key=\"producto.id\"&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { productos: [] } }, async mounted() { const res = await fetch('http://localhost/api/productos') this.productos = await res.json() } } &lt;/script&gt; . Archivo components/ClientesList.vue . Este componente es como productos-list, pero aplicado a los clientes. No mostraremos el código aquí para no alargar esto innecesariamente. Recuerda que puedes ver y descargar el código completo de este ejemplo en https://github.com/avozme/frontend-compras-v1 . Archivo components/ComprasList.vue . Este componente es como productos-list, pero con los datos de las compras. Fíjate que a Vue le da igual si esta tabla es una tabla maestra o una tabla pivote (relación N:N): para el frontend se trata tan solo de otra colección de datos que se van a mostrar en un componente data-table. Tampoco mostraremos el código aquí, porque es casi idéntico al de ProductosList.vue. Recuerda que tienes el código completo disponible en https://github.com/avozme/frontend-compras-v1 . 4.4.7. Ejemplo completo: frontend con Vue v2 - CRUD completo, enrutamiento en servidor . El frontend anterior consume el API Compras, pero lo hace solo para consultar los listados de datos. Podemos mejorarlo añadiendo funcionalidades de CRUD a cada uno de los componentes con datos (productos-list, clientes-list y compras-list). Eso complicará el código de cada componente, claro, pero nos ofrecerá una aplicación mucho más completa. Puedes echar un vistazo al código de esta versión más completa aquí. Solo vamos a mostrar el CRUD de Productos, pero los otros dos (Clientes y Compras) se resuelven de forma muy similar: . ACCEDE AQUÍ AL CÓDIGO FUENTE COMPLETO DE LA VERSIÓN 2 . Código más importante de la Versión 2 . Los archivos index.js y App.vue serían idénticos a los de la versión anterior. Lo único que cambia en esta versión son los componentes ProductosList.vue, ClientesList.vue y ComprasList.vue, que se vuelven más complejos al incorporar todas las funcionalidades de un CRUD. Archivo components/ProductosList.vue con CRUD completo . &lt;template&gt; &lt;div&gt; &lt;!-- Barra de búsqueda --&gt; &lt;div class=\"search-bar\"&gt; &lt;input v-model=\"filtro\" placeholder=\"Buscar producto...\" @input=\"filtrarProductos\" /&gt; &lt;button @click=\"abrirNuevo\"&gt;+ Nuevo producto&lt;/button&gt; &lt;/div&gt; &lt;!-- Tabla de productos --&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Nombre&lt;/th&gt; &lt;th&gt;Descripción&lt;/th&gt; &lt;th&gt;Precio&lt;/th&gt; &lt;th&gt;Stock&lt;/th&gt; &lt;th&gt;Acciones&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=\"producto in productosFiltrados\" :key=\"producto.id\"&gt; &lt;td&gt;{{ producto.id }}&lt;/td&gt; &lt;td&gt;{{ producto.nombre }}&lt;/td&gt; &lt;td&gt;{{ producto.descripcion }}&lt;/td&gt; &lt;td&gt;{{ producto.precio }}&lt;/td&gt; &lt;td&gt;{{ producto.stock }}&lt;/td&gt; &lt;td&gt; &lt;button @click=\"abrirEdicion(producto)\"&gt;Editar&lt;/button&gt; &lt;button @click=\"eliminarProducto(producto.id)\"&gt;Borrar&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;!-- Formulario de creación / edición --&gt; &lt;div v-if=\"mostrarFormulario\" class=\"formulario\"&gt; &lt;h3&gt;{{ productoActual.id ? 'Editar producto' : 'Nuevo producto' }}&lt;/h3&gt; &lt;form @submit.prevent=\"guardarProducto\"&gt; &lt;label&gt;Nombre:&lt;/label&gt; &lt;input v-model=\"productoActual.nombre\" required /&gt; &lt;label&gt;Descripción:&lt;/label&gt; &lt;input v-model=\"productoActual.descripcion\" /&gt; &lt;label&gt;Precio:&lt;/label&gt; &lt;input v-model.number=\"productoActual.precio\" type=\"number\" min=\"0\" step=\"0.01\" required /&gt; &lt;label&gt;Stock:&lt;/label&gt; &lt;input v-model.number=\"productoActual.stock\" type=\"number\" min=\"0\" required /&gt; &lt;div class=\"acciones\"&gt; &lt;button type=\"submit\"&gt;Guardar&lt;/button&gt; &lt;button type=\"button\" @click=\"cerrarFormulario\"&gt;Cancelar&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { productos: [], productosFiltrados: [], filtro: '', mostrarFormulario: false, productoActual: { id: null, nombre: '', descripcion: '', precio: 0, stock: 0 }, apiUrl: 'http://localhost:8000/api/productos' } }, async mounted() { await this.cargarProductos() }, methods: { async cargarProductos() { const res = await fetch(this.apiUrl) this.productos = await res.json() this.productosFiltrados = this.productos }, filtrarProductos() { const texto = this.filtro.toLowerCase() this.productosFiltrados = this.productos.filter(p =&gt; p.nombre.toLowerCase().includes(texto) ) }, abrirNuevo() { this.productoActual = { id: null, nombre: '', descripcion: '', precio: 0, stock: 0 } this.mostrarFormulario = true }, abrirEdicion(producto) { this.productoActual = { ...producto } this.mostrarFormulario = true }, cerrarFormulario() { this.mostrarFormulario = false }, async guardarProducto() { const metodo = this.productoActual.id ? 'PUT' : 'POST' const url = this.productoActual.id ? `${this.apiUrl}/${this.productoActual.id}` : this.apiUrl await fetch(url, { method: metodo, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(this.productoActual) }) await this.cargarProductos() this.cerrarFormulario() }, async eliminarProducto(id) { if (!confirm('¿Seguro que deseas eliminar este producto?')) return await fetch(`${this.apiUrl}/${id}`, { method: 'DELETE' }) await this.cargarProductos() } } } &lt;/script&gt; &lt;style scoped&gt; /* Aquí iría el CSS */ &lt;/style&gt; . Archivos src/components/ClientesList.vue y src/components/ComprasList.vue . Estos archivos son muy semejantes a ProductosList.vue, pero adaptados a la estrucura de Clientes y Compras, así que no los mostraremos aquí. Puedes consultar el código completo en https://github.com/avozme/frontend-compras-v2 . 4.4.8. Ejemplo completo: frontend con Vue v3 - CRUD completo, enrutamiento en cliente . La versión más completa de este frontend no solo haría un CRUD completo de cada recurso, sino que enrutaría en el cliente para minimizar los accesos al servidor y agilizar la ejecución. Además, lo lógico es dividir los componentes como ProductosList.vue en dos piezas: . | ProductosList.vue solo mostrará la lista de productos y los botones de acción. | ProductosForm.vue mostrará el formulario de insertar/modificar producto. | . Esta misma división debería hacerse con Clientes y con Compras. Obtendríamos así una aplicación frontend bien diseñada y fácilmente escalable con esta estructura de directorios: . src/ ├─ main.js ➔ prepara el createApp de Vue y la monta ├─ routes.js ➔ enrutador ├─ App.vue ➔ componente principal └─ components/ ├─ ProductosList.vue ➔ listado de productos con acciones CRUD ├─ ProductoForm.vue ➔ formulario añadir/editar productos ├─ ClientesList.vue ➔ listado de clientes con acciones CRUD ├─ ClienteForm.vue ➔ formulario añadir/editar clientes ├─ ComprasList.vue ➔ listado de compras con acciones CRUD └─ ComprasForm.vue ➔ formulario añadir/editar compras . Aquí solo te mostraré el código de ProductosForm y ProductosList, además de los cambios necesarios en los archivos main.js, routes.js y App.vue, pero puedes ver el código completo de los otros componentes (Clientes y Compras) en el siguiente link. ACCEDE AQUÍ AL CÓDIGO FUENTE COMPLETO DE ESTA VERSIÓN . Código más importante de la versión 3 . Archivo src/router.js . Este es el archivo de enrutamiento (no tiene una ubicación estándar y puedes encontrarlo en otros lugares del proyecto). Define qué componente se va a cargar con cada ruta. Por ejemplo, en el código de aquí abajo (recuerda: está incompleto; el código completo lo tienes aquí), la ruta /productos producirá la carga del componente ProductosList.vue, mientras que la ruta /productos/nuevo cargará el componente ProductoForm.vue. import { createRouter, createWebHistory } from 'vue-router' import ProductosList from './components/ProductosList.vue' import ProductoForm from './components/ProductoForm.vue' const routes = [ { path: '/', redirect: '/productos' }, { path: '/productos', component: ProductosList }, { path: '/productos/nuevo', component: ProductoForm }, ] const router = createRouter({ history: createWebHistory(), routes }) export default router . Hay que modificar el archivo principal de Vue (src/main.js) para que importe el router y lo use antes de montar la app. Algo así: . Archivo src/main.js . import { createApp } from 'vue' import App from './App.vue' import router from './router' createApp(App).use(router).mount('#app') . Archivo src/App.vue . En el componente principal de Vue (src/App.vue) hay que colocar un &lt;router-view /&gt; en el punto donde queremos que se muestren los componentes asociados a las rutas. También es habitual mostrar links construidos con &lt;router-link&gt; en lugar de &lt;a href...&gt;. Por ejemplo, en el ejemplo de aquí abajo (recuerda, está incompleto) hacemos que el texto “Lista de productos” enlace con la ruta “/productos”, que a su vez provoca la carga del componente ProductosList.vue según se definió en el archivo routes.js. &lt;template&gt; &lt;div&gt; &lt;nav style=\"margin-bottom: 1rem;\"&gt; &lt;router-link to=\"/productos\"&gt;Lista de productos&lt;/router-link&gt; | &lt;router-link to=\"/productos/nuevo\"&gt;Producto nuevo&lt;/router-link&gt; | &lt;/nav&gt; &lt;router-view /&gt; &lt;/div&gt; &lt;/template&gt; . Archivo components/ProductosList.vue . Este componente muestra la lista de productos. &lt;template&gt; &lt;div&gt; &lt;div class=\"search-bar\"&gt; &lt;input v-model=\"filtro\" placeholder=\"Buscar producto...\" @input=\"filtrarProductos\" /&gt; &lt;router-link to=\"/productos/nuevo\"&gt; &lt;button&gt;Nuevo producto&lt;/button&gt; &lt;/router-link&gt; &lt;/div&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Nombre&lt;/th&gt; &lt;th&gt;Descripción&lt;/th&gt; &lt;th&gt;Precio&lt;/th&gt; &lt;th&gt;Stock&lt;/th&gt; &lt;th&gt;Acciones&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=\"producto in productosFiltrados\" :key=\"producto.id\"&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt; &lt;router-link :to=\"`/productos/${producto.id}/editar`\"&gt; &lt;button&gt;Editar&lt;/button&gt; &lt;/router-link&gt; &lt;button @click=\"eliminarProducto(producto.id)\"&gt;Borrar&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { productos: [], productosFiltrados: [], filtro: '', apiUrl: 'http://localhost/api/productos' } }, async mounted() { await this.cargarProductos() }, methods: { async cargarProductos() { const res = await fetch(this.apiUrl) this.productos = await res.json() this.productosFiltrados = this.productos }, filtrarProductos() { const texto = this.filtro.toLowerCase() this.productosFiltrados = this.productos.filter(p =&gt; p.nombre.toLowerCase().includes(texto) ) }, async eliminarProducto(id) { if (!confirm('¿Seguro que deseas eliminar este producto?')) return await fetch(`${this.apiUrl}/${id}`, { method: 'DELETE' }) await this.cargarProductos() } } } &lt;/script&gt; . Archivo components/ProductoForm.vue . Este componente gestiona el formulario para añadir/editar un producto. &lt;template&gt; &lt;div class=\"formulario\"&gt; &lt;h3&gt;{{ esEdicion ? 'Editar producto' : 'Nuevo producto' }}&lt;/h3&gt; &lt;form @submit.prevent=\"guardarProducto\"&gt; &lt;label&gt;Nombre:&lt;/label&gt; &lt;input v-model=\"producto.nombre\" required /&gt; &lt;label&gt;Descripción:&lt;/label&gt; &lt;input v-model=\"producto.descripcion\" /&gt; &lt;label&gt;Precio:&lt;/label&gt; &lt;input v-model.number=\"producto.precio\" type=\"number\" min=\"0\" step=\"0.01\" required /&gt; &lt;label&gt;Stock:&lt;/label&gt; &lt;input v-model.number=\"producto.stock\" type=\"number\" min=\"0\" required /&gt; &lt;div class=\"acciones\"&gt; &lt;button type=\"submit\"&gt;Guardar&lt;/button&gt; &lt;router-link to=\"/productos\"&gt;&lt;button type=\"button\"&gt;Cancelar&lt;/button&gt;&lt;/router-link&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: ['id'], data() { return { producto: { id: null, nombre: '', descripcion: '', precio: 0, stock: 0 }, apiUrl: 'http://localhost/api/productos' } }, computed: { esEdicion() { return !!this.id } }, async mounted() { if (this.esEdicion) { const res = await fetch(`${this.apiUrl}/${this.id}`) this.producto = await res.json() } }, methods: { async guardarProducto() { const metodo = this.esEdicion ? 'PUT' : 'POST' const url = this.esEdicion ? `${this.apiUrl}/${this.id}` : this.apiUrl await fetch(url, { method: metodo, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(this.producto) }) this.$router.push('/productos') } } } &lt;/script&gt; . ",
    "url": "https://iescelia.org/docs/fullstack/_site/vue-js/#44-vuejs-con-npm-para-aplicaciones-frontend",
    "relUrl": "/vue-js/#44-vuejs-con-npm-para-aplicaciones-frontend"
  },"40": {
    "doc": "4 Vue.js",
    "title": "4.5. Vue.js integrado en Laravel para aplicaciones full stack",
    "content": "Hay dos formas de combinar Laravel y Vue: . | Frontend separado: Vue consume una API REST creada con Laravel, como hemos visto en la sección anterior. Esto es ideal si quieres mantener la independencia entre front y back. Tendrías dos aplicaciones separadas que puedes desarrollar, escalar o versionar independientemente una de la otra. | Integrado en Laravel: Vue se ejecuta dentro del propio proyecto Laravel. Esto es perfecto si buscas un desarrollo full stack unificado. Tendrías un solo proyecto (más complejo, pero solo uno). | . 4.5.1. Cómo instalar Vue dentro de Laravel paso a paso . | Instala Vue y el plugin de Vite . Si has instalado Laravel con compose: . $ npm install vue @vitejs/plugin-vue . Si has instalado Laravel con Sail: . $ ./vendor/bin/sail npm install vue @vitejs/plugin-vue` . Recuerda que Vite sirve para traducir Vue a JavaScript estándar en caliente, es decir, durante el desarrollo, para poder ver el efecto de los cambios inmediatamente. | Edita vite.config.js: añade los imports y activa Vue. import { defineConfig } from 'vite'; import laravel from 'laravel-vite-plugin'; import vue from '@vitejs/plugin-vue'; // Importamos plugin de Vue import tailwindcss from '@tailwindcss/vite'; export default defineConfig({ plugins: [ laravel({ input: [ 'resources/css/app.css', 'resources/js/app.js', ], refresh: true, }), vue(), // Añadimos soporte para .vue tailwindcss(), ], resolve: { alias: { 'vue': 'vue/dist/vue.esm-bundler.js', }, }, }); . | Edita resources/js/app.js: este es el archivo de entrada a Vue, así que debes añadir aquí los componentes Vue que tu aplicación vaya a usar. Por ejemplo, para registrar un componente Productos.vue: . import './bootstrap'; import { createApp } from 'vue'; import Productos from './components/Productos.vue'; const app = createApp({}); app.component('productos', Productos); app.mount('#app'); . | Inicia el servidor de desarrollo: . $ npm install # Solo la primera vez!! $ npm run dev . O, si trabajas con Sail: . $ ./vendor/bin/sail npm install # Solo la primera vez!! $ ./vendor/bin/sail npm run dev . | . A partir de ahora, ya puedes usar Vue en tus vistas de Blade. Por ejemplo: . @vite('resources/js/app.js') &lt;!-- Habilita Vue en esta vista--&gt; &lt;div id=\"app\"&gt; &lt;example-component&gt;&lt;/example-component&gt; &lt;/div&gt; . 4.5.2. Estructura de directorios de un proyecto Laravel + Vue . Como has podido observar en los ejemplos anteriores, cuando usas Vue con Laravel, los archivos de Vue se colocan en el directorio resources/js de Laravel: . laravel-project/ ├─ resources/ │ ├─ js/ │ │ ├─ app.js ←---- punto de entrada Vue │ │ └─ components/ │ │ ├─ ExampleComponent.vue │ │ └─ OtrosComponentes.vue │ ├─ views/ │ │ └─ welcome.blade.php ├─ routes/ │ └─ web.php │ └─resto del proyecto Laravel... 4.5.3. Ejemplo completo: CRUD con Vue.js y Laravel . Como siempre hacemos, vamos a ilustrar cómo se usa Vue dentro de Laravel mediante un ejemplo sencillo pero completo, puesto que es la mejor forma de comprenderlo. Vamos a crear una aplicación CRUD completa (Create, Read, Update, Delete) para gestionar la tabla de Productos con la que hemos venido trabajando desde el tema 3. Productos(id#, nombre, descripcion, precio, stock) . Tendremos a Laravel en el backend y a Vue en el frontend, pero trabajando en modo full stack y no como dos aplicaciones independientes. TIENES EL CÓDIGO FUENTE COMPLETO DE ESTE EJEMPLO EN: github.com/avozme/crud-laravel-vue . Pasos generales . | Crear el proyecto Laravel. | Activar Vue dentro de Laravel. | Configurar la base de datos. | Crear modelos, migraciones y seeders. | Crear el controlador RESTful. | Añadir las rutas API. | Crear los componentes Vue. | Crear las vistas Blade. | Compilar y desplegar. | . PASO 1. Crear proyecto de Laravel . Recuerda que hay dos formas «oficiales» de crear un proyecto Laravel nuevo: . A) Con composer: . $ composer create-project laravel/laravel tienda $ cd nombre-app $ php artisan serve # El servidor estará en http://localhost:8080 . B) Con Sail (docker): . $ curl -s https://laravel.build/mi-app | bash $ cd mi-app $ ./vendor/bin/sail up # El servidor estará en http://localhost . PASO 2. Preparación de Vue dentro de Laravel . A partir de Laravel 12, Vue no viene activado por defecto con Laravel, pero es fácil ponerlo en marcha: . Con composer: . $ npm install vue @vitejs/plugin-vue . Con Sail: . $ ./vendor/bin/sail npm install vue @vitejs/plugin-vue . A continación, edita el archivo vite.config.js del directorio raíz: . // Añadir este import: import vue from '@vitejs/plugin-vue'; export default defineConfig({ plugins: // Deja aquí todo como está. Solo tienes // que añadir esto al final: vue(), ], resolve: { alias: { 'vue': 'vue/dist/vue.esm-bundler.js', }, }, }); . También tienes que editar el archivo resources/js/app.js, es decir, el punto de entrada de Vue, para registrar el componente que vamos a usar (Productos.vue): . import './bootstrap'; import { createApp } from 'vue'; import Productos from './components/Productos.vue'; const app = createApp({}); app.component('productos', Productos); app.mount('#app'); . PASO 3. Configurar la conexión con la base de datos . Como con cualquier aplicación Laravel, debes editar el archivo .env para configurar la conexión con la BD. Los siguientes parámetros son los apropiados si usas Sail. En otro caso, sustitúyelos por los tuyos: . DB_CONNECTION=mysql DB_HOST=mysql DB_PORT=3306 DB_DATABASE=laravel DB_USERNAME=sail DB_PASSWORD=password . PASO 4. Modelos, migraciones, seeders . En este ejemplo solo tendremos un modelo, el de Productos. Lo creamos con la opción -m para que al mismo tiempo se cree la migración: . $ php artisan make:model Producto -m # Con composer $ ./vendor/bin/sail artisan make:model Producto -m # Con sail . Edita el modelo app/Models/Producto.php para hacer fillables todos los campos. Así podremos hacer asignación de datos masiva desde un formulario: . namespace App\\Models; use Illuminate\\Database\\Eloquent\\Model; use HasFactory; class Producto extends Model { // Campos que se pueden asignar masivamente protected $fillable = ['nombre', 'descripcion', 'precio', 'stock']; } . Edita también el método up() de la migración database/migrations/xx_create_productos_table.php: . Schema::create('productos', function (Blueprint $table) { $table-&gt;id(); $table-&gt;string('nombre'); $table-&gt;text('descripcion')-&gt;nullable(); $table-&gt;decimal('precio', 8, 2); $table-&gt;integer('stock'); $table-&gt;timestamps(); }); . Por último, lanza la migración para crear la tabla: . $ php artisan migrate # Con composer $ ./vendor/bin/sail artisan migrate # Con sail . Optativamente, por supuesto, puedes crear un Seeder para llenar con datos de prueba la tabla de Productos. PASO 5: Crear el controlador RESTful . Crea el controlador de productos con la opción - -api para convertirlo en controlador RESTful: . php artisan make:controller ProductoController --api . Los métodos del controlador app/Http/Controllers/ProductoController.php devolverán solo datos JSON, no vistas completas: . &lt;?php namespace App\\Http\\Controllers; use App\\Models\\Producto; use Illuminate\\Http\\Request; class ProductoController extends Controller { public function index() { return response()-&gt;json(Producto::all(), 200); } public function store(Request $request) { $producto = Producto::create($request-&gt;all()); return response()-&gt;json($producto, 201); } public function show($id) { return response()-&gt;json(Producto::findOrFail($id), 200); } public function update(Request $request, $id) { $producto = Producto::findOrFail($id); $producto-&gt;update($request-&gt;all()); return response()-&gt;json($producto, 200); } public function destroy($id) { Producto::destroy($id); return response()-&gt;json(null, 204); } } . PASO 6. Rutas API . Instala los componentes API de Laravel (necesario a partir de Laravel 12): . $ php artisan install:api # Con composer $ ./vendor/bin/sail artisan install:api # Con sail . Ya puedes editar routes/api.php: . use App\\Http\\Controllers\\ProductoController; Route::apiResource('productos', ProductoController::class); . Esto hará accesible nuestra API en http://servidor/api/productos. Por ejemplo: http://servidor/api/productos/destroy/1 . PASO 7. Crear los componentes de Vue . Como en este ejemplo solo trabajamos con productos, el único componente que necesitamos es Productos.vue, que crearemos en resources/js/components/Productos.vue. Podría ser algo así: . &lt;template&gt; &lt;div&gt; &lt;h2&gt;Gestión de productos&lt;/h2&gt; &lt;input v-model=\"filtro\" placeholder=\"Buscar producto...\" class=\"border p-2 mb-3\"&gt; &lt;ul&gt; &lt;li v-for=\"p in productosFiltrados\" :key=\"p.id\"&gt; {{ p.nombre }} - {{ p.precio }} € &lt;button @click=\"editar(p)\"&gt;Editar&lt;/button&gt; &lt;button @click=\"borrar(p.id)\"&gt;Eliminar&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;h3&gt;{{ editando ? 'Editar producto' : 'Nuevo producto' }}&lt;/h3&gt; &lt;input v-model=\"form.nombre\" placeholder=\"Nombre\"&gt; &lt;input v-model=\"form.descripcion\" placeholder=\"Descripción\"&gt; &lt;input v-model=\"form.precio\" type=\"number\" placeholder=\"Precio\"&gt; &lt;input v-model=\"form.stock\" type=\"number\" placeholder=\"Stock\"&gt; &lt;button @click=\"guardar\"&gt;Guardar&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'Productos', data() { return { productos: [], form: { id: null, nombre: '', descripcion: '', precio: '', stock: '' }, filtro: '', editando: false, apiBase: 'http://localhost/api/productos' }; }, computed: { productosFiltrados() { return this.productos.filter(p =&gt; p.nombre.toLowerCase().includes(this.filtro.toLowerCase()) ); }, }, methods: { async cargarProductos() { try { const res = await fetch(this.apiBase,{ headers: { 'Accept': 'application/json' } }); if (!res.ok) throw new Error('Error al cargar productos'); this.productos = await res.json(); } catch (error) { console.error(error); } }, async guardar() { try { const options = { method: this.editando ? 'PUT' : 'POST', headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' }, body: JSON.stringify(this.form) }; const url = this.editando ? `${this.apiBase}/${this.form.id}` : this.apiBase; const res = await fetch(url, options); if (!res.ok) throw new Error('Error al guardar el producto'); this.resetForm(); this.cargarProductos(); } catch (error) { console.error(error); } }, editar(prod) { this.form = { ...prod }; this.editando = true; }, async borrar(id) { try { const res = await fetch(`${this.apiBase}/${id}`, { method: 'DELETE' }); if (!res.ok) throw new Error('Error al borrar el producto'); this.cargarProductos(); } catch (error) { console.error(error); } }, resetForm() { this.form = { id: null, nombre: '', descripcion: '', precio: '', stock: '' }; this.editando = false; }, }, mounted() { this.cargarProductos(); }, }; &lt;/script&gt; . PASO 8: Crear las vistas Blade . De nuevo, solo necesitaremos la vista de productos para este ejemplo. La crearemos en resources/views/productos.blade.php: y en ella cargaremos el componente productos que hemos creado con Vue: . &lt;!DOCTYPE html&gt; &lt;html lang=\"es\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Gestión de Productos&lt;/title&gt; @vite('resources/js/app.js') &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;productos&gt;&lt;/productos&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; . Ten en cuenta que esta vista no se generará en el back, como ocurriría con una aplicación backend, sino que la utilizará Vue para renderizar su frontend SPA. Debes dirigir el endpoint / a la nueva vista para que Vue tome el control nada más entrar en la aplicación. Para ello, edita el archivo routes/web.php y dirige la ruta raíz a nuestra vista: . Route::get('/', function () { return view('productos'); }); . PASO 9: Desplegar, compilar, probar . Durante el desarrollo debes ejecutar npm en modo dev: . $ npm run dev # Para Laravel con compose $ ./vendor/bin/sail npm run dev # Para Laravel con sail . Así Vite traducirá cualquier cambio que hagas en Vue a un JavaScript comprensible por el navegador en tiempo real, y podrás ir viendo el resultado inmediatamente en http://localhost:8000 (si trabajas con compose y has levantado el back con php artisan serve) o en http://localhost (si trabajas con Sail y has levantado el back con ./vendor/bin/sail up). Sin embargo, para construir el build final debes ejecutar npm así: . $ npm run build # Para Laravel con compose $ ./vendor/bin/sail npm run build # Para Laravel con sail . Esto convertirá Vue en unos archivos JavaScript estándar minimizados y optimizados en la carpeta /public de Laravel que se servirán junto con el resto de Laravel. A partir de aquí, puedes desplegar la aplicación en cualquier servidor web como harías con cualquier proyecto de Laravel. Lo mejor sería: . | Clonar todo en el servidor web de producción (mejor con git) | Reconfigurar el archivo .env para el nuevo servidor | Lanzar el servidor y probarlo todo | . Recuerda que tienes el código fuente completo de este ejemplo en github.com/avozme/crud-laravel-vue . ",
    "url": "https://iescelia.org/docs/fullstack/_site/vue-js/#45-vuejs-integrado-en-laravel-para-aplicaciones-full-stack",
    "relUrl": "/vue-js/#45-vuejs-integrado-en-laravel-para-aplicaciones-full-stack"
  },"41": {
    "doc": "4 Vue.js",
    "title": "4.6. Práctica final: CRUD de cursos y estudiantes",
    "content": "Para practicar todo esto vamos a construir un CRUD completo usando Vue y Laravel para el siguiente caso: . Crea una aplicación web con Laravel (backend) y Vue (frontend) que nos permita: . | Crear, ver, editar y eliminar Cursos | Crear, ver, editar y eliminar Estudiantes | Relacionar Estudiantes con un Curso (relación 1:N) | . Las tablas de la base de datos tendrán esta estructura: . | courses(id#, name, description) | students(id#, name, email, course_id) | . Como ves, un curso puede tener muchos estudiantes pero cada estudiante solo pertenece a un curso. Los pasos que debes seguir para construir esta aplicación son los mismos que hemos seguido en el ejemplo del apartado anterior: . | Crear el proyecto Laravel | Preparar Vue dentro de Laravel | Configurar la conexión con la base de datos | Crear modelos y migraciones y, optativamente, seeders | Crear el controlador API RESTful | Añadir las rutas API | Construir los componentes Vue. ¡Este es el paso más costoso! . Puedes crear un megacomponente para cada recurso (Courses.vue y Students.vue) o dividirlos en componentes más sencillos (CoursesList.vue + CoursesForm.vue y StudentsList.vue + StudentsForm.vue). Tendrás que estudiar cómo gestionar la relación entre las dos tablas a nivel del interfaz de usuario. | Crear las vistas Blade. No olvides dirigir la ruta raíz (/) a alguna de tus vistas (la que quieras que haga de “home” de la aplicación). | Desplegar, compilar, probar | (Optativo) Enrutar en el cliente. Puedes modificar tus componentes para que el enrutamiento se haga en el cliente y así construir una aplicación 100% SPA. | . ",
    "url": "https://iescelia.org/docs/fullstack/_site/vue-js/#46-pr%C3%A1ctica-final-crud-de-cursos-y-estudiantes",
    "relUrl": "/vue-js/#46-práctica-final-crud-de-cursos-y-estudiantes"
  },"42": {
    "doc": "4 Vue.js",
    "title": "4 Vue.js",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/vue-js/",
    "relUrl": "/vue-js/"
  },"43": {
    "doc": "5 Intertia.js",
    "title": "5. Inertia.js",
    "content": "Inertia.js es una librería que permite construir aplicaciones SPA (Single Page Applications) utilizando frameworks backend como Laravel junto con un frontend moderno como Vue.js, todo ello sin necesidad de crear una API REST (o de otro tipo) separada. Inertia Actúa como un “puente” entre el backend y el frontend, permitiendo que se envíen datos del servidor al cliente directamente a través de los controladores, de forma similar a cómo se haría con las vistas tradicionales. Una vez en el cliente, cualquier framework Javascript, como Vue, React, Angular o Svelte, puede renderizar los datos enviados por los controladores del servidor. Gracias a Inertia tendremos a nuestro alcance las ventajas de las aplicaciones web clásicas (lógica de la aplicación en el backend y arquitectura más racional y sencilla) y de las aplicaciones web modernas (mayor interactividad). En resumen: Inertia nos proporciona lo mejor de los dos mundos. Esto facilita enormemente el desarrollo full stack moderno, pues no hay que separar completamente el frontend y el backend, siempre conservando una experiencia de usuario comparable a una SPA completa. MATERIAL EN PREPARACIÓN ",
    "url": "https://iescelia.org/docs/fullstack/_site/inertia/#5-inertiajs",
    "relUrl": "/inertia/#5-inertiajs"
  },"44": {
    "doc": "5 Intertia.js",
    "title": "5 Intertia.js",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/inertia/",
    "relUrl": "/inertia/"
  },"45": {
    "doc": "2.1 Características de Laravel",
    "title": "2.1. ¿Qué es un framework?",
    "content": ". | 2.1.1. ¿Realmente necesito un framework para desarrollar una aplicación web? | 2.1.2. ¿Qué framework escoger? | 2.1.3. Características de Laravel | . Un framework es un conjunto estandarizado de prácticas de programación para resolver una serie de problemas habituales. El framework proporciona una serie de clases, librerías y otros componentes para facilitar el desarrollo ágil, seguro y escalable de nuevas aplicaciones. Por lo tanto, un framework MVC PHP es un conjunto de clases, librerías y otros componentes destinados a servir de base para desarrollar aplicaciones en PHP con arquitectura MVC. La idea es esta: no inventar la rueda cada vez que la necesitamos. 2.1.1. ¿Realmente necesito un framework para desarrollar una aplicación web? . No, los frameworks nunca son imprescindibles… . …pero casi siempre son muy convenientes. Hay programadores pro-frameworks y anti-frameworks. Los programadores anti-frameworks acaban desarrollando, aposta o sin querer, su propio framework después de llevar varias aplicaciones MVC a sus espaldas. Para decidir si necesitas un framework o no, tienes que conocer antes cómo funcionan y qué ventajas e inconvenientes presentan. Usar un framework tiene ciertas ventajas, como: . | Reutilización del trabajo ya hecho (recuerda: no reinventar la rueda). | Extensa documentación. | Separación en capas. | Seguimiento de buenas prácticas de programación. | Escalabilidad y mantenimiento. | Desarrollo más rápido y, por tanto, más económico. | . Pero también tiene algunos inconvenientes: . | A veces pueden limitar el desarrollo. | Curva de aprendizaje costosa (más en unos frameworks que en otros). Es decir: al principio iremos más lentos que sin framework, hasta que le cojamos el tranquillo. | Puede llegar a implicar más trabajo, dependiendo del proyecto. | Preferencias personales: algunos programadores solo se sienten cómodos si todo el código es suyo. | Actualizaciones frecuentes e imprevistas. A menudo, la actualización de un framework hace que parte de tu aplicación deje de funcionar. | Ocultan gran parte del funcionamiento de la aplicación: no son aptos para aprender a programar. | . En resumen: la idea es que, al usar un framework, solo te centras en desarrollar lo importante. El resto (lo que ya estaba desarrollado en el framework y que es común a muchas aplicaciones web) no te quita tiempo. 2.1.2. ¿Qué framework escoger? . Existen multitud de frameworks MVC PHP. Estos son algunos de gran implantación en la actualidad: . | Symfony: el más extendido hace algunos años. Ahora está perdiendo cuota de mercado. | Laravel: el líder indiscutible en el ecosistema PHP. | CodeIgniter: el más básico y fácil de aprender, aunque su implantación en la industria el menor. | Otros framworks MVC PHP importantes son (o han sido) Zend Framework, Yii y CakePHP. | . Lamentablemente, no hay respuesta a la pregunta: ¿qué framework es mejor? . Puedes pasar el resto de tu vida leyendo en foros y en blogs, descargando e instalando varios frameworks para desecharlos a los dos días, esperando a que salga una nueva versión o un framework nuevo… . Nunca podrás responder a esa pregunta. Como mucho, podrás responder a esta otra: ¿qué framework prefiero? Y eso solo después de haber probado varios durante algún tiempo. Además, el framework por sí sólo puede no ser suficiente para un desarrollo completo, y probablemente harán falta otros componentes que afectarán a la experiencia de programación. Algunos ejemplos son: . | Otras librerías y/o frameworks del lado del servidor: pear, pChart, doctrine… | Librerías y/o frameworks del lado del cliente: Vue.js, Angular, React, bootstrap… | . 2.1.3. Características de Laravel . Laravel es un framework PHP MVC para desarrollo rápido de aplicaciones web. Automatiza muchos procesos habituales y tiene una curva de aprendizaje algo dura al principio. Desde hace algunos años, Laravel se ha consolidado como el líder absoluto en el mundo del backend hecho con PHP. Ventajas de Laravel . Para ir abriendo boca, te cuento algunos de los puntos fuertes que tiene Laravel: . | Sintaxis simple y elegante. | Mapeo objeto-relacional (ORM) con Eloquent. Gracias a él, podrás dejar de pelearte con SQL. | Potente sistema de plantillas para vistas con Blade. Se acabó mezclar HTML y PHP a lo loco. | Enrutamiento potente y sencillo. Esto es importante en una aplicación web. | Manejo de migraciones y seeding sencillo: una especie de “control de versiones” de la base de datos. | Seguridad y testing integrados. | Uso muy extendido en el ámbito profesional. | Comunidad de usuarios altamente especializada (buena relación señal/ruido, al menos de momento) | Excelente documentación. | . Inconvenientes de Laravel . Como no hay nada perfecto, es evidente que Laravel también tiene algunos defectillos. Entre ellos, estos: . | Curva de aprendizaje elevada. | Laravel es un framework grande y pesado. Siempre se ejecutará más lento que un programa hecho directamente en PHP (o con un framework más ligero). | Las actualizaciones mayores pueden romper la compatibilidad hacia atrás. | Demasiada «magia oculta». Laravel oculta muchas de las cosas que ocurren tras el escenario. Eso significa que, cuando algo falla, estamos basante perdidos. | Dependencia fuerte del ecosistema Laravel: te quedas un poco atado a él y a sus caprichos. | Algunas herramientas son de pago (aunque las más habituales no). | . ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/caracteristicas.html#21-qu%C3%A9-es-un-framework",
    "relUrl": "/laravel/caracteristicas.html#21-qué-es-un-framework"
  },"46": {
    "doc": "2.1 Características de Laravel",
    "title": "2.1 Características de Laravel",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/caracteristicas.html",
    "relUrl": "/laravel/caracteristicas.html"
  },"47": {
    "doc": "2.10 Usando la BD con Eloquent",
    "title": "2.10. Usando la BD con Eloquent",
    "content": ". | 2.10.1. ¿Qué es el mapeo objeto-relacional? | 2.10.2. ¿Cómo puedo usar Eloquent en mi aplicación? | 2.10.3. Pero ¿cómo sabe Laravel qué tabla está asociada a ese modelo? | 2.10.4. Consultas con Eloquent | 2.10.5. Inserciones y borrados con Eloquent | 2.10.6. Chuleta con los métodos más habituales de Eloquent | 2.10.7. Colecciones Eloquent | 2.10.8. Relaciones entre tablas con Eloquent | . Eloquent uno de los componentes de Laravel que permiten al desarrollador manipular los datos de la BD sin rebajarse a escribir sucio SQL. Y lo consigue mediante un mecanismo simple y elegante: el mapeo objeto-relacional. En esta sección vamos a ver qué es eso del mapeo y cómo sacarle a Eloquent el máximo partido para que nuestros modelos se programen prácticamente solos. 2.10.1. ¿Qué es el mapeo objeto-relacional? . Eloquent no es más que una librería incluida con Laravel que utiliza un patrón de software llamado ORM (Object-Relational Mapping) para abstraer aún más el acceso a la base de datos, de manera que no tengamos que escribir y depurar SQL. Mapear los objetos de nuestra aplicación con una BD relacional significa que Eloquent convierte los registros de tus tablas en objetos de tu aplicación para que los manipules con mayor facilidad. Sí, lo has entendido bien: podrás manejar los datos de tu base de datos como si fueran objetos de tu aplicación. Y, cuando los modifiques, borras o crees, se ejecutará el código SQL necesario (sin que tú te enteres) para traducir esas operaciones en sentencias para la base de datos. Te lo muestro con un ejemplo. Imagina que tenemos una tabla de artículos de un blog. La llamaremos Articles, y tendrá 3 campos: el id (entero), el title (cadena de caracteres) y el body (cadena de caracteres). Con Eloquent, usar esa tabla es tan fácil como hacer algo así: . $art = Article::find('7'); // Buscamos un artículo por su id echo $art-&gt;title; // Ahora podemos acceder a los campos de ese artículo $art-&gt;body = \"Texto del cuerpo\"; // O también podemos modificar los campos del artículo $art-&gt;save(); // Si hacemos save(), los cambios se guardan en la BD . 2.10.2. ¿Cómo puedo usar Eloquent en mi aplicación? . Tienes que crear un modelo. Con Artisan es así de fácil: . $ php artisan make:model &lt;Mi-modelo&gt; . Por ejemplo: . $ php artisan make:model Article . El modelo se creará en /app/Models/Article.php (¡cuidado! En versiones más antiguas de Laravel, el modelo se creará en /app/Article.php) . Truco: si creas el modelo con la opción -m, se creará atomáticamente su migración, lo cual resulta tremendamente práctico: . $ php artisan make:model Article -m . Ya tienes tu modelo. Si no puedes contener tu curiosidad insaciable y lo abres, verás un archivo bastante decepcionante con este aspecto: . &lt;?php namespace App\\Models; use Illuminate\\Database\\Eloquent\\Factories\\HasFactory; use Illuminate\\Database\\Eloquent\\Model; class Article extends Model { use HasFactory; } . ¿Y eso es todo? . Pues sí, eso es todo. La gracia está en ese extends Model de la definición de la clase: aunque tu modelo Article parezca vacío, en realidad acaba de heredar un mogollón de características útiles de la clase Model. Entre otras, todos los métodos de Eloquent. 2.10.3. Pero ¿cómo sabe Laravel qué tabla está asociada a ese modelo? . Buena pregunta. Laravel supondrá que la tabla se llama igual que el modelo, solo que en minúscula y plural. Es decir, la tabla de la base de datos asociada al modelo Article se debería llamar articles. Recuerda que en Laravel existen un montón de convenciones sobre los nombres de las cosas que conviene respetar, más que nada porque te facilitan mucho la vida y hacen que te centres en lo verdaderamente importante (crear el código de tu aplicación) en lugar de en lo accesorio (pelearte con los nombres). No obstante, si quieres ponerle otro nombre a la tabla, puedes hacerlo. También puedes cambiar otras muchas cosas, como el nombre del campo clave (Laravel supondrá que se llama id) o los campos sobre los que se puede hacer una asignación masiva, algo muy útil que veremos un poco más adelante. Por ejemplo, podemos editar el modelo /app/Articles.php y añadir estas líneas dentro de nuestra clase: . protected $table = 'articulos'; // El nombre de la tabla no será \"articles\" sino \"articulos\" protected $primaryKey = 'id_art'; // La clave primaria no será \"id\" sino \"id_art\" protected $fillable = array('id','titulo','cuerpo'); // Campos de la tabla en los que se permite la ASIGNACIÓN MASIVA (más adelante veremos qué es esto) . 2.10.4. Consultas con Eloquent . Solo con construir el modelo (y asignarlo a la tabla adecuada) ya tenemos detrás a Eloquent haciendo el mapeo objeto-relacional. Ahora podemos ir a nuestro controlador (que, por respetar las convenciones de Laravel, debería llamarse ArticlesController) y lanzar consultas con expresiones como estas: . use App\\Articulo; // Poner al principio del controlador para importar el modelo ... $articlesList = Article::all(); // Devuelve todos los artículos $myArticle = Article::find($id); // Devuelve el artículo con ese $id $myArticle = Article::findOrFail($id); // Error 404 si el artículo no existe $articlesList = Article::where('id', '&gt;', 100)-&gt;get(); // Select con where $articlesList = Article::where('id', '&gt;', 100)-&gt;take(10)-&gt;get(); // Select con where y take $maxId = Article::max('id'); // Devuelve el último id asignado . A lo mejor hay algo que te está chirriando. Si escribimos cosas como estas en el controlador, ¿no significa eso que estamos lanzando consultas desde el controlador? Y eso está prohibidísimo en la arquitectura MVC. ¿Es que Laravel no respeta la arquitectura MVC? . Hay quien dice que sí, hay quien dice que no y hay quien dice que psé, psé. En realidad, no estamos escribiendo SQL en el controlador, ni estamos accediendo a la base de datos de ninguna manera explícita. Cuando lanzamos un Article::find($id) desde el controlador, por ejemplo, no sabemos qué ocurre por debajo ni de dónde se extrae la información: nos limitamos a acceder a una de nuestras clases y obtener de ella un objeto de tipo Article. 2.10.5. Inserciones y borrados con Eloquent . También podemos usar Eloquent para insertar un nuevo artículo desde nuestro controlador: . $art = new Article; $art-&gt;title = 'Los Chitauri invaden Nueva York'; $art-&gt;body = 'Bla, bla, bla'; $art-&gt;save(); . Si los datos del artículo vienen de un formulario, fíjate en lo alucinantemente fácil que es recoger todos esos datos, crear un objeto Article con ellos y guardar el artículo en la BD: . public function store(Request $request) { Article::create($request-&gt;all()); // Esto es una ASIGNACIÓN MASIVA de las que hablábamos más arriba!! return view('la-vista-que-sea'); } . Ojo: solo los campos que hayas indicado como fillables en el modelo se podrán asignar al artículo de este modo. Eso es lo que significa asignación masiva. Y, por supuesto, también podemos modificar y borrar artículos de la base de datos: . $art = Article::find(18); // MODIFICAR $art-&gt;body = 'Nuevo cuerpo'; $art-&gt;save(); $art = Article::find(13); // BORRAR $art-&gt;delete(); . 2.10.6. Chuleta con los métodos más habituales de Eloquent . Hemos visto en los últimos ejemplos algunos métodos de Eloquent por separado. Te los reúno en esta sección para que los puedas consultar cuando lo necesites. Aviso: no están todos, solo los de uso más habitual. Si quieres una lista completa, ya sabes: acude a la documentación oficial. | all() → Recupera todos los registros de una tabla. | where(“campo”, valor) → Aplica claúsula where. | orderBy(“campo”, “asc|desc”) → Aplica claúsula order by. | get() → Recupera registros seleccionados. Se suele usar con where y/o order by: Ciudades::where(\"ciudad\", \"Madrid\")-&gt;orderBy(\"id\", \"asc\")-&gt;get(); . | first() → Recupera el primer registro. | latest() → Recupera el último registro. | find(valor) → Busca registros con ese valor en el campo id. | findOrFail(valor) → Lanza un error 404 si no encuentra el registro. | count(), max(), min()… → Utiliza funciones de agregado de SQL. | save() → Inserta o actualiza registros. | update() → Actualiza registros. | delete() → Elimina registros. | . 2.10.7. Colecciones Eloquent . Las consultas con Eloquent siempre nos devuelven colecciones de tipo Illuminate\\Database\\Eloquent\\Collection, que tienen varias ventajas con respecto de los arrays de objetos convencionales: . | Cada elemento es un objeto del modelo correspondiente (como User) | Cada elemento tiene métodos save(), delete(), etc. | Cada elemento tiene sus propias relaciones (ej: $user-&gt;posts) | La colección tiene métodos como map(), filter(), first(), sortBy()… | Se puede hacer encadenamiento de métodos: $users-&gt;where('active',1)-&gt;sortBy('name') | La colección o sus elementos se convierten a JSON con -&gt;toJson(). Se conservan las relaciones. | . Aquí tienes un ejemplo de una consulta Eloquent sobre la tabla users seguida de varias operaciones sobre la colección resultante: . // Obtenemos todos los usuarios activos. $usuariosActivos será una Collection de Eloquent $usuariosActivos = User::where('active', 1)-&gt;get(); // Recorremos la colección y mostramos los usuarios foreach ($usuariosActivos as $usuario) { echo $usuario-&gt;name . \" - \" . $usuario-&gt;email . \"\\n\"; } // Extraemos solo el campo 'name' a un array $nombre, que será algo así: [\"Ana\", \"Luis\", \"María\", ...] $nombres = $usuariosActivos-&gt;pluck('name'); // Filtramos la colección $mayoresDe30 = $usuariosActivos-&gt;filter(function($user) { return $user-&gt;birth_date &lt;= now()-&gt;subYears(30)-&gt;format('Y-m-d'); }); // Ordenamos la colección por nombre $ordenadosPorNombre = $usuariosActivos-&gt;sortBy('name'); // Transformamos los datos de la colección poniendo todos los emails en minúscula $emailsMayuscula = $usuariosActivos-&gt;map(function($user) { return strtolower($user-&gt;email); }); . 2.10.8. Relaciones entre tablas con Eloquent . NOTA: Esta sección puede considerarse material avanzado de Laravel . Las relaciones entre tablas también se pueden manejar con Eloquent sin necesidad de andar escribiendo larguísimos INNER JOIN y otros miembros de su nutrida familia, con todos los errores de escritura que suelen hacernos perder el tiempo depurando SQL. Aunque al principio te parezca que definir las relaciones entre tablas con Eloquent necesita mucho trabajo previo, te garantizo que después te alegrarás de haberlo hecho. Porque las relaciones, una vez definidas, se comportan como consultas y se puede operar con ellas como si lo fueran. Lo comprenderemos mejor, como siempre, con ejemplos. En los siguientes apartados, vamos a suponer que tenemos estas tablas: . | usuarios(id#, nombre, passwd) | emails(id#, email, usuario_id) → Esta tabla tiene una relación 1:1 con usuarios | articulos(id#, titulo, texto, idUsuario) → Esta tabla tiene una relación 1:N con usuarios | roles(id#, nombre) → Esta tabla tiene una relación N:N con usuarios | . ATENCIÓN: en la tabla artículos hemos usado a propósito un nombre no estándar para la clave foránea. Para respetar la convención de Laravel, debería llamarse usuario_id en lugar de idUsuario, como en la tabla emails. 2.10.8.1. Relaciones 1:1 (usuarios &lt;-&gt; emails) . Para definir un relación 1:1 con Eloquent debes hacer lo siguiente: . Paso 1. En el modelo de la tabla maestra (clase Usuario, en nuestro ejemplo) añadimos este método: . public function email() { return $this-&gt;hasOne('App\\Email'); } . Paso 2. En el modelo de la tabla relacionada (clase Email) añadimos este método: . public function usuario() { return $this-&gt;belongsTo('App\\Usuario'); } . A partir de ahora, se puede recuperar el email de un usuario como si fuera un miembro de la clase Usuario, tan sencilla como esto: . $email = Usuario::find(1)-&gt;email; $user = Email::all()-&gt;first()-&gt;user; . Y también funciona al revés. Es decir, a partir de un objeto de tipo Email, podemos acceder a su usuario como si fuera un atributo de la clase Email. 2.10.8.2. Relaciones 1:N (usuarios &lt;-&gt; artículos) . Si tienes una relación 1:N (como la que hay entre las tablas de usuarios y artículos de nuestro ejemplo), para definirla en Eloquent tienes que hacer esto: . Paso 1. En el modelo de la tabla maestra (clase Usuario), añade este método: . public function articulos() { return $this-&gt;hasMany('App\\Articulo', 'idUsuario'); } // ATENCIÓN: hemos tenido que indicar el nombre de la clave foránea // (idUsuario) porque no habíamos respetado la convención de Laravel // (usuario_id) al crear la tabla de artículos . Paso 2. En el modelo de la tabla relacionada (class Articulo), añade este otro método: . public function usuario() { return $this-&gt;belongsTo('App\\Usuario'); } . ¡Y listo! Ya puedes recuperar los artículos a partir del usuario, como si fueran atributos de esa clase. Y a la inversa también funciona. Por ejemplo: . $articulos = Usuario::find(1)-&gt;articulos; foreach ($articulos as $articulo) { // Procesar cada artículo } . 2.10.8.3. Relaciones N:N (usuarios &lt;-&gt; roles) . Si lo que tienes es una relación N:N (como la que hay entre usuarios y roles en nuestro ejemplo), los pasos a seguir para construirla con Eloquent son estos: . Paso 1. En el modelo de una de las tablas (clase Usuario) añadimos este método: . public function roles() { return $this-&gt;belongsToMany('App\\Rol'); } . Paso 2. En el modelo de la otra tabla (clase Rol) añadimos este método: . public function usuarios() { return $this-&gt;belongsToMany('App\\Usuario'); } . Ahora, ya se pueden recuperar los roles a partir del usuario o a la inversa. Por ejemplo: . $roles = Usuario::find(1)-&gt;roles; foreach ($roles as $rol) { // Procesar cada rol } . 2.10.8.4. La tabla pivote: insertar, modificar y borrar en relaciones N:N . Insertar, modificar y borrar en relaciones N:N implica escribir datos (normalmente, ids) en la tabla intermedia o tabla pivote, lo cual suele suponer un engorro cuando se hace a mano con SQL. Ese tedioso proceso también se puede automatizar con Eloquent. Lo vemos con un ejemplo entre nuestras tablas usuarios y roles. Para insertar un usuario y sus roles se usa el método attach(): . public function store(Request $r) { $user = new User($r-&gt;all()); $user-&gt;roles()-&gt;attach($r-&gt;roles); $user-&gt;save(); } . Para actualizar un usuario y sus roles se usa el método sync(): . public function update(Request $r, $id) { $user = User::find($id); $user-&gt;fill($r-&gt;all()); $user-&gt;roles()-&gt;sync($r-&gt;roles); $user-&gt;save(); } . Para eliminar un usuario y sus roles se usa el método detach(): . public function destroy($id) { $user = User::find($id); $user-&gt;roles()-&gt;detach(); $user-&gt;delete(); } . 2.10.8.5. Problemas frecuentes en relaciones N:N . Eloquent supondrá que el nombre de la tabla de la relación se ha formado con los nombres de las dos tablas maestras en snake case y ordenadas alfabéticamente. Por ejemplo, en la relación N:N entre usuarios y roles, Eloquent supondrá que existe una tabla llamada roles_usuarios. Si no se llama así, la relación fallará. Se puede indicar otro nombre de tabla al definir la relación. Por ejemplo, en el modelo de usuarios (clase Usuario): . public function roles() { return $this-&gt;belongsToMany('App\\Rol', 'usuarios_roles'); } . También se pueden indicar los nombres de las claves foráneas si no siguen las convenciones (que, según Laravel, son usuario_id, rol_id, etc) . public function roles() { return $this-&gt;belongsToMany('App\\Rol', 'usuarios_roles', 'id_usuario', 'id_rol'); } . ¿Te has fijado en que hemos creado un método para acceder a la tabla relacionada, pero estamos usando un atributo en su lugar? . public function articulos() { return $this-&gt;hasMany('App\\Articulo'); } public function loQueSea() { $arts = Usuario::find(1)-&gt;articulos; // articulos, no articulos() } . Pues bien, el atributo articulo es un atributo virtual creado por Eloquent. Pero el método articulos() también existe, y puede usarse como una consulta, extendiéndola como necesitemos. Por ejemplo: . $arts = Usuario::find(1)-&gt;articulos()-&gt;where('titulo','foo')-&gt;first(); . ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/eloquent.html#210-usando-la-bd-con-eloquent",
    "relUrl": "/laravel/eloquent.html#210-usando-la-bd-con-eloquent"
  },"48": {
    "doc": "2.10 Usando la BD con Eloquent",
    "title": "2.10 Usando la BD con Eloquent",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/eloquent.html",
    "relUrl": "/laravel/eloquent.html"
  },"49": {
    "doc": "2.11 Usando la BD con QueryBuilder",
    "title": "2.11. Usando la BD con QueryBuilder",
    "content": ". | 2.11.1. ¿Qué es y cómo se utiliza QueryBuilder? | 2.11.2. Colecciones | 2.11.3. Ventajas de QueryBuilder sobre SQL | 2.11.4. Relaciones entre tablas con QueryBuilder | 2.11.5. SQL crudo | . En esta sección te voy a presentar a QueryBuilder, otra forma de acceder a la base de datos desde Laravel que te resultará muy útil en aquellos casos en los que, por la razón que sea, los métodos de Eloquent no sean suficientes. 2.11.1. ¿Qué es y cómo se utiliza QueryBuilder? . Eloquent permite usar la BD de forma simple y elegante en la mayor parte de las circunstancias. Aún así, puede haber situaciones en las que queramos un acceso de más bajo nivel a la BD. Para eso existe QueryBuilder. El grado de abstracción de QueryBuilder es mucho menor que el de Eloquent. Es decir, estaremos CASI escribiendo SQL, sin llegar a hacerlo. Algunos ejemplos de uso te darán una pista de qué tipo cosas se pueden hacer con QueryBuilder: . $users = DB::table(\"users\")-&gt;get(); $users = DB::table(\"users\")-&gt;where(\"name\", \"=\", \"Ana\")-&gt;first(); $users = DB::table(\"users\")-&gt;where(\"edad\", \"&gt;=\", 18)-&gt;orderBy(\"apellidos\"); $maxId = DB::table(\"users\")-&gt;max(\"id\"); $existe = DB::table(\"users\")-&gt;where(\"id\", \"=\", $id)-&gt;exists(); $users = DB::table(\"users\")-&gt;select(\"nombre, apellidos as apell\")-&gt;get(); . Ahora ves a qué me refiero cuando digo que QueryBuilder es casi SQL, sin llegar a serlo. No tendrás que depurar el SQL, ni pelearte con comillas que se abren y cierran, ni nada de eso. QueryBuilder generará el SQL por ti a partir de expresiones como las que acabas de ver. En la documentación oficial encontrarás una referencia completa de todas las funciones de QueryBuilder, pero con estas que ves en el ejemplo puedes construir prácticamente cualquier consulta sencilla. 2.11.2. Colecciones . El resultado de consultas como las que veíamos de ejemplo en el apartado anterior es bastante intuitivo: . | O bien un dato simple (como el $maxId de la cuarta consulta, que es un entero). | O bien un objeto de tipo Collection. | . Las colecciones de Laravel tienen un montón de métodos útiles para procesarlas y puedes echarle un vistazo a la documentación oficial para ello, pero la mayor parte de las veces basta con hacer un foreach sobre la variable para ir accediendo a cada uno de los elementos, que se comportarán como objetos del tipo adecuado. Por ejemplo, para acceder a todos los registros de la tabla de usuarios: . $users = DB::table(\"users\")-&gt;get(); foreach ($users as $user) { echo $user-&gt;name; echo $user-&gt;email; ...etc... } . 2.11.3. Ventajas de QueryBuilder sobre SQL . Como ves, QueryBuilder te permite construir sentencias SQL sin necesidad de escribir SQL. La ventaja de esto es triple: . | No tendremos que depurar nuestros errores sintácticos en SQL, con el ahorro de tiempo que eso conlleva. | El SQL generado será 100% compatible con el gestor de base de datos que estemos utilizando. Si escribimos SQL en crudo, tendremos que adaptarlo al dialecto de nuestro gestor de base de datos. Y, si cambiamos de gestor, habrá que revisar todas las sentencias SQL para adaptarlas de nuevo. Todo esto lo evita QueryBuilder, puesto que hace esa adaptación por nosotros. | Es imposible que suframos un ataque por inyección de código, puesto que QueryBuilder no lo permitirá. | . 2.11.4. Relaciones entre tablas con QueryBuilder . Las relaciones entre tablas se manejan con joins, como en SQL, solo que escritos al estilo QueryBuilder. Para hacer un INNER JOIN, puedes usar como referencia este ejemplo: . $users = DB::table('users') -&gt;join('contacts', 'users.id', '=', 'contacts.user_id') -&gt;join('orders', 'users.id', '=', 'orders.user_id') -&gt;select('users.*', 'contacts.phone', 'orders.price') -&gt;get(); . Por supuesto, también puedes hacer LEFT JOIN y RIGHT JOIN: . $resultado = DB::table('A')-&gt;leftJoin('B'...); $resultado = DB::table('A')-&gt;rightJoin('B'...); . 2.11.5. SQL crudo . Por último, QueryBuilder también te permite escribir SQL crudo, es decir, SQL tal cual, si es que alguna vez lo necesitas. Eso sí, deberías valorar muy bien para qué narices quieres escribir SQL crudo. ¿Estás seguro/a de que eso que intentas hacer no se puede lograr más fácilmente con Eloquent o con QueryBuilder? . Además, tendrás que extremar las precauciones ante un posible ataque por inyección de código. Si aún así no te he convencido, puedes ejecutar tu SQL crudo así: . $resultado = DB::select('SELECT * FROM users WHERE active = ?', [1]); $resultado = DB::insert('INSERT INTO users (name) VALUES (?)', ['Ana']); $resultado = DB::update('UPDATE users SET active = 0 WHERE id = ?', [5]); $resultado = DB::delete('DELETE FROM users WHERE active = 0'); . En el caso del SELECT, el $resultado será un array de objetos (no una colección Eloquent). En el caso de INSERT, UPDATE o DELETE, $resultado será un número entero que indicará el número de registros afectados. ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/querybuilder.html#211-usando-la-bd-con-querybuilder",
    "relUrl": "/laravel/querybuilder.html#211-usando-la-bd-con-querybuilder"
  },"50": {
    "doc": "2.11 Usando la BD con QueryBuilder",
    "title": "2.11 Usando la BD con QueryBuilder",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/querybuilder.html",
    "relUrl": "/laravel/querybuilder.html"
  },"51": {
    "doc": "2.12 Sesiones con Laravel",
    "title": "2.12. Sesiones con Laravel",
    "content": ". | 2.12.1. Drivers de sesión | 2.12.2. Persistencia de las variables de sesión | 2.12.3. Autenticación | 2.12.4. Laravel Breeze | 2.12.5. Autenticación y vistas: cómo generar código dependiendo del tipo de usuario | 2.12.6. Autenticación y middlewares: cómo proteger los controladores | . Como es lógico, Laravel también proporciona su propio sistema de manejo de variables de sesión, es decir, variables persistentes en el servidor asociadas a cada cliente. Las variables de sesión de Laravel son mucho más seguras y poderosas que las variables de sesión estándar de PHP. En esta sección vamos a ver cómo funcionan y qué posibilidades nos ofrecen las sesiones en Laravel. 2.12.1. Drivers de sesión . Las sesiones de configuran en /config/sessions.php, y una de las cosas que debes configurar ahí es el driver de sesión, es decir, el tipo de manejador que quieres que manipule las sesiones. | Files: . El driver por defecto es files. Es el más sencillo y funcionará en casi cualquier servidor. Eso significa que Laravel guardará las variables de sesión en un fichero especial en el servidor (que nosotros no tenemos que manejar: Laravel se encargará de todo). | Memcached y redis: . El driver files es más que suficiente para una aplicación en desarrollo, pero para una aplicación en producción, Laravel recomienda usar otros drivers llamados memcached o redis porque son más rápidos. Ambos son daemons del sistema programados para esta tarea. Obviamente, el servidor debe soportarlos para que puedas usarlos. Consulta con tu proveedor o con tu administrador de sistemas la configuración de tu servidor web para saber si puedes usar alguno de estos dos drivers. Si no, tendrás que conformarte con files. | Database: . Si necesitas seguridad adicional, sin duda tu driver es database. Esto almacenará dos copias de cada variable de sesión: una en un fichero y otra en una tabla especial de la base de datos. Si un atacante consiguiera manipular una de las dos variables, Laravel cerrará la sesión automáticamente y el atacante se quedará con un palmo de narices. Eso sí, este sistema es el más lento de todos porque requiere un acceso a la base de datos para cada petición al servidor. | . 2.12.2. Persistencia de las variables de sesión . Laravel maneja dos tipos de variable según su persistencia: . | Variables flash: solo duran una petición y luego desaparecen. | Variables de sesión convencionales: existen hasta que las destruimos expresamente. | . Variables flash . Son variables de sesión que solo duran una petición y luego se autodestruyen. Se usan típicamente para enviar un feedback o mensaje de retroalimentación al usuario. Te lo muestro con un ejemplo. Imagina el típico formulario de login. En caso de producirse un error, lo habitual es que la aplicación nos muestre de nuevo ese formulario con un mensaje del tipo de “Usuario no reconocido”. Para lograr eso, haríamos lo siguiente en el controlador. Observa el uso del método with() para crear una variable flash de sesión llamada mensaje: . return ('login/form')-&gt;with('mensaje', 'Usuario no reconocido'); . En la vista, podemos acceder a esa variable flash. Por ejemplo, así: . @if (session('mensaje')) {{ session('mensaje'); }} @endif . A partir de este momento, la variable flash se destruye y cualquier intento de acceder a ella provocará un error de ejecución. Variables de sesión convencionales . Las variables de sesión convencionales se manejan con la clase Session, que tiene un montón de métodos estáticos para crear variables, destruirlas, consultarlas, etc. Los métodos más útiles son: . | put() -&gt; almacena una variable de sesión: . Session::put('nombre-variable', 'valor'); . | push() -&gt; elimina una variable de sesión: . Session::push('nombre-variable'); . | get() -&gt; devuelve el valor de una variable de sesión: . $v = Session::get('nombre-variable'); $v = Session::get('nombre-variable', 'valor-por-defecto'); . | all() -&gt; devuelve todas las variables de sesión en un array: . $a = Session::all('nombre-variable', 'valor'); . | flush() -&gt; elimina todas las variables de sesión: . Session::flush(); . | flash() -&gt; crea manualmente una variable de sesión de tipo flash: . Session::flash('nombre-variable', 'valor'); . | . 2.12.3. Autenticación . La autenticación de usuarios, es decir, el sistema de login seguido de la creación de una o varias variables de sesión asociadas al usuario que se acaba de loguear, es un componente habitual de muchas aplicaciones web. Hasta la versión 5, Laravel proporcionaba un sistema de autenticación integrado en su código que se podía añadir a nuestra aplicación con un simple comando de Artisan. Pero a partir de Laravel 6, los desarrolladores decidieron aligerar el núcleo de Laravel lo máximo posible, y sacaron del sistema muchos componentes, incluyendo el sistema de autencicación. Actualmente, Laravel proporciona los denominados Starter Kits, que son componentes que se pueden instalar mediante composer para realizar esas tareas que se extrajeron del núcleo de Laravel. Para la autenticación, Laravel dispone varios Starter Kits. Vamos a ver uno de ellos llamado Breeze, que es sencillo pero más que suficiente en la mayor parte de las situaciones. 2.12.4. Laravel Breeze . Larevel Breeze es un Starter Kit que contiene todo el código necesario para crear un sistema de autenticación completo y seguro capaz, entre otras cosas, de: . | Login y logout | Registro de usuarios | Recuperación de contraseña | Confirmación de registro mediante email, etc. | . Laravel Breeze genera PHP, HTML, CSS y Javascript. Estos últimos deben precompilarse con Vite (una herramienta de Laravel para generar elementos del frontend) antes de poder usarse. Por lo tanto, tendremos que poner en marcha vite con npm (recuerda: npm es el gestor de dependencias de Javascript, igual que composer es el gestor de dependencias de PHP). En resumen: para instalar Laravel Breeze, ejecuta estos comandos en tu terminal: . $ composer require laravel/breeze --dev $ php artisan breeze:install $ npm install $ npm run dev # En producción, usar npm run build . El primer comando instalará las librerías PHP necesarias para que Laravel Breeze se ejecute. El segundo, añadirá Breeze a tu aplicación, creando automáticamente varios controladores, modelos, vistas y hasta migraciones. Los dos comandos npm sirven para compilar el CSS y el JS de Breeze. Una vez hecho esto, Breeze creará automáticamente varias rutas en un enrutador especial, /routes/auth.php. Entre ellas: . Routes::get(\"/login\") → Para mostrar el formulario de login Routes::post(\"/login\") → Para procesar el formulario de login Routes::post(\"/logout\") → Para cerrar la sesión Routes::get(\"/register\") → Para mostrar el fomulario de registro Routes::post(\"/register\") → Para procesar el formulario de registro . Puedes probarlas escribiéndolas en tu navegador. Comprobarás que funcionan estupendamente. También se crearán varios controladores como LoginController y RegisterContoller. Los puedes encontrar en App/Http/Controllers/Auth. Y, por supuesto, se crean varias vistas, como auth/login.blade.php, register.blade.php y layouts/app.blade.php (la plantilla que usarán login y register). Por último, se crea una vista home de ejemplo (dashboard.blade.php) a la que llegamos después de hacer login. Esa vista home la puedes cambiar en /app/providers/RouteServiceProvider.php para redirigirla a la vista que te interese. ¡Y listo! Ya tienes hecho un sistema de login completo y superseguro. Solo te queda adaptar esas vistas y controladores a tus necesidades. 2.12.5. Autenticación y vistas: cómo generar código dependiendo del tipo de usuario . En las vistas, tenemos un par de directivas de Blade muy útiles relacionadas con las sesiones: @auth y @guest. Puedes ver cómo funcionan en este ejemplo: . @auth ... // Este código solo se ejecuta si existe un usuario logueado @endauth @guest ... // Este código solo se ejecuta si NO existe usuario logueado @endguest . Además, podemos acceder a los datos del usuario mediante la clase Auth: . $user = Auth::user() // Devuelve el usuario actualmente logueado o null si no hay ninguna sesión abierta. if (Auth::check()) { // Devuelve true si el usuario actual está logueado... } . (Más métodos de Auth en la documentación oficial) . 2.12.6. Autenticación y middlewares: cómo proteger los controladores . Los middlewares de Laravel son componentes que capturan y filtran todas las peticiones HTTP que llegan a la aplicación. Literalmente, se ponen en medio de cualquier petición al servidor, y de ahí su nombre. Están ubicados en App/Http/Middleware. Hay dos middlewares importantes relacionados con la autenticación en Laravel: Authenticate (que tiene un alias: auth) y RedirectIfAuthenticated (alias guest). Los alias se definen en App/Http/Kernel.php . Podemos usar estos middlewares en el constructor de nuestros controladores para protegerlos en todo o en parte. Es decir, para impedir el acceso de usuarios no logueados a ciertos métodos del controlador. Observa este ejemplo para aprender a hacerlo. Ya verás qué fácil y versátil es: . public function __construct() { // Solo usuarios logueados podrán acceder a cualquier función de este controlador: $this-&gt;middleware(\"auth\"); // Solo usuarios logueados podrán acceder a los métodos create() y edit(): $this-&gt;middleware(\"auth\")-&gt;only(['create', 'edit']); // Solo usuarios logueados podrán acceder al controlador excepto a show(): $this-&gt;middleware(\"auth\")-&gt;except(['show']); } . El middleware auth también puede usarse en el enrutador, para proteger el acceso a una ruta concreta, así: . Route::get('/ruta-a-proteger', [Controlador::class, 'metodo'])-&gt;middleware('auth'); . ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/sesiones.html#212-sesiones-con-laravel",
    "relUrl": "/laravel/sesiones.html#212-sesiones-con-laravel"
  },"52": {
    "doc": "2.12 Sesiones con Laravel",
    "title": "2.12 Sesiones con Laravel",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/sesiones.html",
    "relUrl": "/laravel/sesiones.html"
  },"53": {
    "doc": "2.13 Helpers de Laravel",
    "title": "2.13. Helpers de Laravel",
    "content": ". | 2.13.1. ¿Qué son los helpers? | 2.13.2. Algunos helpers útiles de Laravel | . Los helpers son componentes de Laravel que hemos estado usando casi desde el principio sin darnos cuenta porque, como su propio nombre indica, nos ayudan a resolver pequeñas tareas tediosas. Ha llegado el momento de presentártelos formalmente, ¿no crees? . 2.13.1. ¿Qué son los helpers? . Un helper es un componente del framework diseñado para facilitar alguna tarea típica en el desarrollo de una aplicación web. Por ejemplo: el helper url() sirve para generar un ruta absoluta a partir de una relativa, de modo que la ruta absoluta siempre funcione, sea cual sea el servidor donde ejecutes la aplicación. Aquí puedes ver un ejemplo de uso de este helper: . &lt;a href='{{ url('/users/login') }}&gt;Volver&lt;/a&gt; . Cuando el helper url() actúe, traducirá la expresión anterior por este código HTML: . &lt;a href='https://miservidor.com/users/login'&gt;Volver&lt;/a&gt; . Eso permite que la ruta sea correcta aunque muevas la aplicación de un servidor a otro, sin necesidad de modificar el código fuente. El uso de los helpers es optativo: solo son ayudantes, y el programador/a debe decidir si le resultan útiles o no. Los helpers cambian mucho de una versión a otra de Laravel, por lo que te recomiendo que eches un vistazo a la documentación oficial para saber qué helpers están disponibles en tu versión de Laravel. Puedes encontrar una lista completa de helpers en: https://laravel.com/docs/X.x/helpers (sustituye X.x por tu versión de Laravel) . 2.13.2. Algunos helpers útiles de Laravel . 2.13.2.1. url helper . Ya lo hemos visto en el ejemplo anterior. Crea rutas absolutas a enlaces de tu alicación a partir de rutas relativas. Las rutas absolutas siempre son más fiables, pero tienen el problema de que hay que cambiarlas si la aplicación cambia de servidor. Ese problema lo resuelve el helper url(). Se usa como en este ejemplo: . &lt;a href='{{ url('/users/login') }}&gt;Volver&lt;/a&gt; . El código anterior generará este HTML: . &lt;a href='https://miservidor.com/users/login'&gt;Volver&lt;/a&gt; . 2.13.2.2. route helper . Es parecido a url(), pero sirve para rutas con nombre. Por ejemplo, si en el enrutador tenemos una ruta con nombre como esta: . Route::get(\"mi-ruta\", \"metodo@mi-controlador\")-&gt;name(\"nombre-ruta\"); . …podemos referirnos a ella en cualquier vista como: . &lt;a href='{{ url('mi-ruta') }}&gt;Texto&lt;/a&gt; . …o como: . &lt;a href='{{ route('nombre-ruta') }}&gt;Texto&lt;/a&gt; . La segunda forma es mejor que la primera, porque nos permite cambiar en cualquier momento la dirección que ve el usuario sin modificar el código fuente del resto de la aplicación. 2.13.2.3. request helper . Este helper proporciona información sobre la petición (GET, POST o la que sea) con la que se cargó la página. El helper request() devuelve un objeto con varios métodos para acceder a esa información. Estos son los más útiles: . | request()-&gt;url() → Devuelve un string con la ruta actual (completa). | request()-&gt;path() → Devuelve un string con la ruta actual (solo desde la raíz de la aplicación, sin http ni el nombre del servidor). | request()-&gt;is(“ruta”) → Devuelve true si “ruta” coincide con la ruta actual. Admite wildcards (símbolos * y ?). | request()-&gt;input(“campo”) → Devuelve el valor de “campo” (enviado desde formulario). | request()-&gt;all() → Devuelve un array con todos los campos. | request()-&gt;has(“campo”) → Devuelve true si en la petición existe un campo con el nombre indicado. | request()-&gt;isMethod(“método”) → Devuelve true si la petición se hizo por el método indicado (POST, GET, PUT, etc). | . El helper request() puede usarse en las vistas (como request()-&gt;url(), por ejemplo) o inyectarse en las funciones del controlador como un argumento, así: . public function mi_función(Request $r) . En este último caso, podemos acceder a todos los datos enviados mediante un formulario a través del objeto $r. Por ejemplo: . public function mi_función(Request $r) { $name = $r-&gt;name; $email = $r-&gt;email; $pass = $r-&gt;password; ...etc... } . 2.13.2.4. redirect helper . Muy útil cuando queremos redirigir al usuario hacia otra URL o acción (por ejemplo, para evitar que al pulsar F5 se reenvíen los datos de un formulario). Admite varias formas: . return redirect('user/login'); return redirect()-&gt;action('LoginController@login'); return back(); . 2.13.2.5. auth helper . Como vimos en la sección de sesiones y autenticación, este helper permite saber si existe algún usuario autenticado en la aplicación. auth()-&gt;user() nos devolverá el usuario autenticado (como un objeto de tipo User) o null si nadie ha hecho login. Con el objeto User podemos acceder a todos los datos del usuario. Por ejemplo: . $user = auth()-&gt;user(); Bienvenido/a, {{ $user-&gt;name }}. Este es su email: {{ $user-&gt;email }} . 2.13.2.6. errors helper . Se utiliza para conocer y mostrar los errores de validación de un formulario. El objeto $errors está disponible en todas las vistas gracias a que un Middleware (ShareErrorsFromSession) la inyecta automáticamente. Algunos métodos útiles de este objeto son: . | $errors-&gt;all() → devuelve un array con todos los errores detectados. | $errors-&gt;any() → devuelve true si se ha detectado algún error. | $errors-&gt;first(“campo”) → devuelve el primer error de todos los que puedan afectar al campo indicado. | . ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/helpers.html#213-helpers-de-laravel",
    "relUrl": "/laravel/helpers.html#213-helpers-de-laravel"
  },"54": {
    "doc": "2.13 Helpers de Laravel",
    "title": "2.13 Helpers de Laravel",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/helpers.html",
    "relUrl": "/laravel/helpers.html"
  },"55": {
    "doc": "2.14 Flujo de trabajo típico con Laravel",
    "title": "2.14. Flujo de trabajo típico con Laravel",
    "content": "Lo que vas a encontrar aquí es solo un posible flujo de trabajo con Laravel, es decir, una propuesta del orden en el que debes hacer las cosas para desarrollar una aplicación con este framework. No es el único flujo de trabajo posible, y sin duda no es el mejor, pero puede resultarte útil en tus primeros desarrollos, como si alguien te llevara de la mano a lo largo de un camino sinuoso. Más adelante, cuando vayas adquiriendo experiencia, tú mismo/a crearás tu propio flujo de trabajo ideal. El flujo que te propongo tiene los siguientes pasos (los cuatro primeros son solo para aplicaciones nuevas): . | Instalar y configurar el proyecto. | Diseñar la base de datos (si no lo has hecho antes). | Crear migraciones. Lanzarlos para crear la BD. | (opcional) Crear seeders y lanzarlos para rellenar las tablas. | Crear las rutas de la funcionalidad que vayas a programar. | Crear los métodos del controlador para la funcionalidad que vayas a programar. | Crear las funciones del controlador necesarias. | Crear las funciones del modelo necesarias (si no existen ya). | Crear las vistas necesarias con Blade. | Probar la funcionalidad nueva (con el navegador o con PHP Unit). | Repetir los pasos 5-10 para cada funcionalidad adicional. | . ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/flujo-de-trabajo-con-laravel.html#214-flujo-de-trabajo-t%C3%ADpico-con-laravel",
    "relUrl": "/laravel/flujo-de-trabajo-con-laravel.html#214-flujo-de-trabajo-típico-con-laravel"
  },"56": {
    "doc": "2.14 Flujo de trabajo típico con Laravel",
    "title": "2.14 Flujo de trabajo típico con Laravel",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/flujo-de-trabajo-con-laravel.html",
    "relUrl": "/laravel/flujo-de-trabajo-con-laravel.html"
  },"57": {
    "doc": "2.15 Aspectos avanzados de Laravel",
    "title": "2.15. Aspectos avanzados de Laravel",
    "content": "Aunque hemos visto muchas cosas, Laravel es un framework gigantesco y se nos han quedado muchísimas cosas en el tintero que podríamos considerar aspectos avanzados de Laravel. Te dejo aquí una lista de algunas de esas cosas, por si te interesa investigar por tu cuenta para profundizar en tus habilidades. | Traducciones. | Paginación de resultados en vistas. | Páginas de error personalizadas. | Routes model bindings para URLs amigables. | Validación avanzada de formularios con form requests. | Optimizar el enrutador en servidores REST: Route::resource() | Enviar emails con Laravel. Mailtrap. Sparkpost. | Laravel Mix para usar SASS, LESS o STYLUS con CSS y Javascript para el diseño. | Filtrar las rutas con expresiones regulares. | Crear helpers y middlewares. | Políticas de acceso complejas. | Collections. | Relaciones polimórficas con Eloquent. | Eventos y Listeners. | Actualizar una aplicación existente a una versión de Laravel posterior. | Memoria caché y mejora del rendimiento. | Decoradores e interfaces. | Pruebas: unit tests, integration tests, functional tests, acceptance tests. Mockery y Selenium. | Jobs y Queues: manejo de trabajos en segundo plano. | Notifications: enviar notificaciones a usuarios vía email, Slack, SMS, etc. | API Resources / Transformadores: formateo de datos JSON para APIs REST. | Broadcasting / Websockets: tiempo real con Pusher o Laravel Websockets. | Task Scheduling: comandos programados (scheduler) usando cron. | . ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/aspectos-avanzados.html#215-aspectos-avanzados-de-laravel",
    "relUrl": "/laravel/aspectos-avanzados.html#215-aspectos-avanzados-de-laravel"
  },"58": {
    "doc": "2.15 Aspectos avanzados de Laravel",
    "title": "2.15 Aspectos avanzados de Laravel",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/aspectos-avanzados.html",
    "relUrl": "/laravel/aspectos-avanzados.html"
  },"59": {
    "doc": "2.16 CRUD desarrollado con Laravel",
    "title": "2.16. CRUD desarrollado con Laravel: un ejemplo completo",
    "content": "Para finalizar esta introducción (sí, sí: aunque haya sido muy largo, no es más que una introducción) a Laravel, vamos a desarrollar una pequeña aplicación web desde cero. Se tratará, en realidad, de un fragmento de otra aplicación más grande: una tienda online o tal vez un sistema de gestión de almacén. Da lo mismo. Nosotros vamos a desarrollar la parte de mantenimiento de productos. Para ello, supondremos que en la base de datos existe una tabla llamada products con los campos id, name, description y price. Vamos a construir el controlador, el modelo y las vistas necesarias para hacer el CRUD completo (create-read-update-delete) de esta tabla con Laravel, sin olvidarnos de las migraciones, los seeders y, por supuesto, el enrutador. ¿Estás preparado/a? Accede al código fuente completo de la aplicación aquí . ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/crud-con-laravel.html#216-crud-desarrollado-con-laravel-un-ejemplo-completo",
    "relUrl": "/laravel/crud-con-laravel.html#216-crud-desarrollado-con-laravel-un-ejemplo-completo"
  },"60": {
    "doc": "2.16 CRUD desarrollado con Laravel",
    "title": "2.16 CRUD desarrollado con Laravel",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/crud-con-laravel.html",
    "relUrl": "/laravel/crud-con-laravel.html"
  },"61": {
    "doc": "2.17 Prácticas",
    "title": "2.17. Prácticas",
    "content": "En esta colección de actividades prácticas vamos a montar, poco a poco, una pequeña aplicación web que funcionará en el backend mediante generación de vistas. Puedes usar el código de gestión de productos como base para orientarte. La aplicación será un fragmento de un blog, es decir, permitirá publicar artículos y mostrarlos. Al finalizar, habrás creado una aplicación sencilla pero funcional con un potente y seguro sistema de autenticación integrado. | Actividad 1. Preparar el entorno | Actividad 2: Primer “Hola Mundo” | Actividad 3: Plantillas y Blade | Actividad 4: Migraciones y Eloquent | Actividad 5: Mostrar todos los artículos | Actividad 6: Mostrar un artículo | Actividad 7: Alta de nuevos artículos | Actividad 8: Borrado de artículos | Actividad 9: Autenticación con Breeze | Actividad 10: Pulido final | . Actividad 1. Preparar el entorno . | Objetivo: Familiarizarse con los directorios de Laravel y preparar la aplicación. | Tareas: . | Instala Laravel con docker/sail. Más info aquí (con Composer o Sail). | Configura el archivo .env. Más info aquí. Trabajaremos con estas tablas en la base de datos (usa los tipos de datos que te parezcan más razonables para cada campo): . | Tabla users: id, username, email, password, role | Tabla articles: id, title, body, date, user_id | . | Lanza el servidor con $ ./vendor/bin/sail up -d o $ php artisan serve y comprueba que Laravel responde. | Explora la estructura de directorios. Más info aquí. | . | Resultado: Instalación limpia de Laravel funcionando y lista para desarrollar sobre ella. | . Actividad 2: Primer “Hola Mundo” . | Objetivo: Crear rutas, controladores y vistas básicas con Blade. | Tareas: . | Crea ruta simple en routes/web.php que devuelva un mensaje “Hola, mundo”. Más info aquí. | Crea un controlador HolaController con métodos index() y show($nombre) que hagan el saludo desde el propio controlador. El método show($nombre) debe incluir en el saludo el nombre de la persona que recibe como parámetro. Más info aquí. | Crea una vista Blade llamada hola.blade.php para mostrar los saludos. Más info aquí. | Prueba la URL http://servidor/hola en el navegador con parámetro y sin parámetro. Asegúrate que funciona según lo esperado en ambos casos. | . | Resultado: Construcción del primer controlador y vista funcional con Blade, con paso de parámetros en la URL. | . Actividad 3: Plantillas y Blade . | Objetivo: Aprender el uso de layouts, secciones y condicionales en Blade. | Tareas: . | Crea una nueva entrada en el enrutador y el controlador anteriores que renderice una vista llamada $articles. Esta vista debe recibir tres datos (más info aquí): . | $id: El id del usuario autor de los artículos | $username: el nombre de ese usuario | $articles: un array con los títulos de los artículos. | . Puedes asignar, de momento, valores fijos a esas variables antes de pasárselas a la vista. Más adelante las traeremos de la base de datos. | Crea el master layout en views/layouts/master.blade.php con las secciones title, sidebar y content. Más info aquí. | Crea una vista heredada del master layout llamada views/articles/page.blade.php. Más info aquí. La vista recibirá tres datos: $id (el id de un autor), $username (el nombre del autor) y $articles (un array con los títulos de los artículos que ha escrito ese autor). El la vista debes mostrar el id y el username en una salida HTML (la lista de títulos la usaremos enseguida). | Crea salida HTML dinámica y condicional (usando @if, @else y @endif), de manera que solo muestre la lista de títulos si contiene datos. Si la lista está vacía, la vista mostrará el texto “No existen artículos”. Más info aquí. | Usa un bucle @foreach para recorrer el array con los títulos de los artículos y mostrarlo en la salida HTML. Más info aquí. | . | Resultado: Construcción de vistas con Blade consistentes, reutilizables y dinámicas. | . Actividad 4: Migraciones y Eloquent . | Objetivo: Crear la base de datos, las migraciones y los modelos, así como algunas consultas de prueba. | Tareas: . | Crea los modelos User y Article. Ten en cuenta que, en versiones recientes de Laravel, el modelo User ya existirá y solo tienes que revisarlo por si necesitas añadir algún campo adicional. Más info aquí. | Crea las migraciones para las tablas users y articles, si es que aún no las has creado. Más info aquí. | Crea seeders para ambas tablas. Rellena las tablas con unos cuantos datos ficticios pero realistas generados con Faker. Más info sobre los seeders aquí y más info sobe Faker aquí. | Lanza las migraciones y los seeders con $ ./vendor/bin/sail artisan migrate:fresh --seed. | Haz algunas consultas básicas de prueba con Eloquent (all(), find(), where(), save()…). Para comprobar que funcionan, puedes crear una ruta en routes/web.php y un método en el controlador app/Http/Controllers/ArticlesController.php desde el que lanzar las consultas y mostrar los resultados. No hace falta que crees vistas para estos resultados, porque solo es una prueba que no estará en la versión final. Más info aquí. | . | Resultado: BD preparada y Eloquent funcionando. | . Actividad 5: Mostrar todos los artículos . | Objetivo: Crear una vista con todos los artículos | Tareas: . | Crea la ruta articles en el enrutador routes/web.php que ejecute el método index() del controlador de artículos (ArticleController). | Crea el método index() del controlador de artículos. Debe recuperar con Eloquent todos los artículos de la base de datos y pasárselos a la vista views/articles/index.blade.php | Crea la vista views/articles/index.blade.php, que recibirá la lista de artículos y los mostrará. Solo debe aparecer el título del artículo y la fecha. Puedes usar la misma vista de la aplicación de gestión de productos para inspirarte. | . | Resultado: Vista principal de artículos preparada | . Actividad 6: Mostrar un artículo . | Objetivo: Mostrar la información completa de un artículo al hacer clic en su título desde la lista general. | Tareas: . | Crea la ruta articles/{id} en el enrutador routes/web.php. Ponle un nombre a la ruta: -&gt;name('articles.show'). | Añade el método show($id) al controlador de artículos. Este método debe buscar el artículo $id con Eloquent y pasarlo a la vista articles/show.blade.php que vamos a crear enseguida. | Crea vista articles/show.blade.php que muestre título, contenido, autor y fecha del artículo que se le ha pasado desde el controlador. | Modifica la vista articles/index.blade.php que hicimos en el ejercicio anterior para que el título de cada artículo sea un link a la ruta de que has creado en este ejercicio. Usa para ello href = route('articles.show', $article-&gt;id) en lugar de escribir la ruta a mano con href = 'articles/$article-&gt;id'. Aunque ambas soluciones funcionarán, usar route() es mejor porque permite en el futuro cambiar los endpoints sin tener que modificar el código de la aplicación. | . | Resultado: Navegación completa entre el listado de artículos y la vista de detalle de cada uno. | . Actividad 7: Alta de nuevos artículos . | Objetivo: Crear nuevos artículos desde la aplicación, con mensajes de realimentación al usuario. | Tareas: . | Crea las nuevas rutas en routes/web.php: articles/create (GET) y articles (POST). Asígnales un nombre con -&gt;name(): articles.create y articles.store. | Añade al controlador de artículos estos dos métodos: . | create() para mostrar el formulario (vista views/articles/create.blade.php). | store() para validar los datos del formulario (title, body, date, etc), guardar el artículo en la BD con Eloquent y redirigir a la lista de artículos con un mensaje de éxito o de error. Por el momento, que todos los artículos se guarden con el user_id = 1. | . | Crea vista views/articles/create.blade.php con un formulario que incluya los campos de título, contenido y fecha. Opcionalmente, muestra posibles errores de validación. | Añade un enlace “Nuevo artículo” en la vista views/articles/index.blade.php que lleve al formulario de creación que acabas de crear. | . | Resultado: La aplicación permite ahora añadir artículos nuevos a la base de datos. | . Actividad 8: Borrado de artículos . | Objetivo: Añadir la posibilidad de borrar artículos, con confirmación y mensaje de éxito o error. | Tareas: . | Añade la ruta DELETE /articles/{id} en routes/web.php con el nombre articles.destroy. | Crea método destroy($id) en el controlador de artículos. Debe buscar el artículo, eliminarlo con Eloquent y redirigir a la lista de artículos con un mensaje de confirmación o de error en el borrado. | Añade a cada fila el botón “Eliminar” en la vista views/articles/index.blade.php. Cada artículo debe tener su propio formulario HTML con method=”POST” con un botón que envíe los campos @method('DELETE') y @csrf, para que el enrutador capture esa ruta. No dudes en inspirarte en la aplicación de gestión de productos para inspirarte. | Muestra un mensaje de feedback en la vista de lista de artículos (algo como “borrado con éxito” o “error al borrar”) tras efectuar el borrado. | . | Resultado: La aplicación puede ahora eliminar artículos. | . Actividad 9: Autenticación con Breeze . | Objetivo: Crear el login/logout y el alta de usuarios. | Tareas: . | Instala Laravel Breeze para añadir un sistema de autenticación a tu aplicación. Más info aquí. | Prueba el registro de usuarios y el login/logout. | Usa @auth y @guest en las vistas que tienes construidas hasta ahora para mostrar contenido condicional: los usuarios autenticados verán su nombre y los enlaces para “Añadir” y “Borrar” artículos. Los usuarios no autenticados no verán esos enlaces. Más info aquí . | Protege el controlador de artículos para que solo los usuarios autenticados puedan acceder a los métodos que alteran la información (como store() y destroy()). Comprueba que funciona. Más info aquí | . | Resultado: Sistema de login/registro funcional integrado en la aplicación. | . Actividad 10: Pulido final . | Objetivo: Consolidar la aplicación y probar el flujo completo. | Tareas: . | Modifica la aplicación para que, al crear un artículo, se guarde el id del usuario autenticado (hasta ahora, todos los artículos se estaban guardando con user_id = 1). | Revisa todos los formularios, mensajes al usuario y rutas en busca de posibles errores. | Cambia la página de inicio (dashboard) para que, tras el login, vayamos al listado de artículos. Solo deben aparecer los artículos del usuario autenticado en ese momento. | Añade la posibilidad de que un usuario autenticado modifique sus artículos, pero no los de los demás. Intenta reutilizar para ello la vista de añadir nuevos artículos en lugar de crear una nueva. | Añade un poco de CSS para hacer más atractivas las vistas. Más info aquí. | . | Resultado: Aplicación funcional de ejemplo, lista para extender con nuevas funcionalidades. | . ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/practicas.html#217-pr%C3%A1cticas",
    "relUrl": "/laravel/practicas.html#217-prácticas"
  },"62": {
    "doc": "2.17 Prácticas",
    "title": "2.17 Prácticas",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/practicas.html",
    "relUrl": "/laravel/practicas.html"
  },"63": {
    "doc": "2.2 Instalación de Laravel",
    "title": "2.2. Instalación de Laravel",
    "content": ". | 2.2.1. Instalación con Docker (RECOMENDADO) | 2.2.2. Instalación con composer | . En esta sección vamos a describir el proceso de instalación de Laravel en un servidor local para desarrollo. Tienes dos posibilidades: . | Usar composer. | Usar sail. | . En ambos casos, se trata de mecanismos oficiales de instalación recomendados por Laravel, así que puedes optar por el que quieras. Aunque, por supuesto, siempre eres libre de instalarlo manualmente y por tu cuenta sobre un servidor Apache, nginx o similar. 2.2.1. Instalación con Docker (RECOMENDADO) . Docker, como ya sabes, es una tecnología que solo virtualiza los servicios de software que nuestra aplicación necesita para funcionar en lugar de la máquina completa, como haría VirtualBox, por ejemplo. Los servicios virtualizados se agrupan en conjuntos llamados images. Cuando una image se instancia (como quien instancia una clase en programación orientada a objetos), pasan de denominarse containers. Laravel proporciona una herramienta llamada sail que permite desplegar un Laravel basado en Docker en cuestión de segundos con modificaciones mínimas en tu sistema nativo. | PASO 1. Instala docker y docker-compose en tu ordenador. Si trabajas con Windows, asegúrate de instalar también Docker desktop para iniciar y detener Docker con comodidad. Si trabajas con Linux, Docker Desktop no es necesario, pero puede resultarte cómodo. | PASO 2. Instala las imágenes oficiales de Laravel . $ curl -s https://laravel.build/mi-app | bash . (Cambiar “mi-app” por el nombre que tú quieras). Esto puede tomar un rato. Ten en cuenta que Laravel es un framework muy, muy grande. ¡Ojo! Si utilizas Windows esto no funcionará en el cmd ni el PowerShell. Necesitarás instalar WSL y, dentro de WSL, instalar una distribución Linux como Ubuntu. Esto te permitirá tener un Linux corriendo dentro de tu Windows de forma segura. Para lograrlo, debes ejecutar el comando wsl --install -d Ubuntu en tu PowerShell de Windows. Luego ejecuta el comando wsl y tendrás acceso a un terminal con un Ubuntu Linux completo dentro de tu Windows. Ese es el terminal que debes usar siempre para trabajar con Laravel. No olvides iniciar Docker Desktop, necesario para trabajar con docker en Windows. Es posible que necesites configurarlo para permtir a permitir a WSL/Ubuntu usar Docker (Settings -&gt; Resources -&gt; WSL Integration). | PASO 3. Levanta el servidor de desarrollo con sail . | . $ cd mi-app # O el directorio que hayas elegido en el paso anterior $ ./vendor/bin/sail up -d . | PASO 4. Comprueba que el servidor funciona. Visita http://localhost . | PASO 5. Comprueba que funciona el servidor MySQL. Haz ./vendor/bin/sail mysql para acceder al cliente en modo texto de MySQL. Los datos de la conexión los puedes consultar (y cambiar) en el archivo docker-compose.yml . | PASO 6. Al terminar, no olvides apargar el servidor virtual. | . $ ./vendor/bin/sail down . 2.2.2. Instalación con composer . composer es un gestor de dependencias para PHP, es decir, puede instalar librerías adicionales a los que vienen con PHP de fábrica. Eso incluye Laravel y todas las librerías que Laravel necesita. | PASO 1: Instala PHP y composer en tu sistema. composer es un gestor de dependencias para PHP, es decir, instala librerías y paquetes adicionales necesarios para que los programas (como Laravel) funcionen. | PASO 2: Descarga Laravel usando composer. Esto no solo descargará Laravel, sino también todas sus dependencias, que son muchas. $ composer create-project laravel/laravel nombre-app . (Cambia «nombre-app» por el nombre de tu aplicación) . | PASO 3: Accede al directorio de tu aplicación . $ cd nombre-app # O el nombre que hayas elegido en el paso anterior . No olvides dar los permisos necesarios a tus archivos y directorios. | PASO 4: Pon en marcha el servidor. Laravel viene con su propio servidor web para desarrollo (para producción, habría que sustituirlo por un Apache, nginx o similar bien configurado). $ php artisan serve . | PASO 5: Comprueba que el servidor funciona. Visita la URL http://localhost:8000 . | . ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/instalacion.html#22-instalaci%C3%B3n-de-laravel",
    "relUrl": "/laravel/instalacion.html#22-instalación-de-laravel"
  },"64": {
    "doc": "2.2 Instalación de Laravel",
    "title": "2.2 Instalación de Laravel",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/instalacion.html",
    "relUrl": "/laravel/instalacion.html"
  },"65": {
    "doc": "2.3 Configuración de Laravel",
    "title": "2.3. Arquitectura, convenciones y configuración de Laravel",
    "content": ". | 2.3.1. Estructura de directorios | 2.3.2. Convenciones en Laravel | 2.3.3. Variables de entorno. El archivo .env | . Como cualquier framework, Laravel sigue una serie de convenciones para los identificadores, la estructura de directorios de la aplicación y la configuración. Aunque no es imprescindible seguir esas convenciones, y puede resultar un poco enojoso las primeras veces (en plan: ¿pero por qué tengo que llamar a esa clase así, si quiero llamarla de otro modo?), a la larga el uso de convenciones ahorra muchísimo tiempo de desarrollo y, sobre todo, de depuración. ¿Cuántas veces no has estado depurando un error consistente en haber olvidado que el nombre de una tabla de la base de datos lo habías escrito en plural y no en singular, o al revés? . “Convención sobre configuración” es un lema de muchos frameworks. Quiere decir que, si seguimos las convenciones del framework, tanto si nos gustan como si no, nos ahorraremos mucho tiempo de discusión sobre la configuración y muchos quebraderos de cabeza posteriormente. 2.3.1. Estructura de directorios . Después de una instalación limpia de Laravel, nos encotraremos con una estructura típica de directorios que hay que respetar. Los más importantes (al menos, para empezar) son estos: . | composer.json: información para composer (ya sabes, el gestor de dependencias PHP). Sirve para instalar todas las librerías que Laravel necesita para funcionar. Imprescindible para desplegar la aplicación en otro servidor. | /app: el código de nuestra aplicación. Aquí están los modelos. | /app/Http: peticiones HTTP, incluyendo los controladores. | . | /bootstrap: contiene el archivo app.php, punto de arranque de Laravel, y los archivos de cache. En general, no hay que tocar nada aquí. | /config: archivos de configuración de la aplicación. | /database: migraciones y seeders de la base de datos. Las migraciones son muy importantes y les dedicaremos un apartado más adelante. | /public: directorio de acceso público. Puedes crear aquí dentro carpetas para colocar assets: imágenes, scripts JS o archivos CSS que no te importe que sean accesibles libremente vía web. | /resources: Aquí dentro están las vistas. También el resto de assets (imágenes, css, js). A diferencia del directorio public, los archivos JS o CSS coloquemos aquí estarán precompilados y no serán accesibles vía web. | /routes: aquí están los archivos de enrutamiento. Hay archivos separados para en enrutamiento web, para el enrutamiento vía API, para el enrutamiento para consola, etc. | /storage: aquí Laravel guarda su memoria caché, información sobre las sesiones, vistas compiladas… No debes tocar esta carpeta para nada. | /vendors: librerías. Es importante añadir esta carpeta a .gitignore si vas a construir un repositorio git para tu aplicación Laravel, porque /vendors puede ocupar bastante espacio y no tiene sentido incluirla en tu proyecto. Cuando vayas a desplegar esta aplicación Laravel en otro servidor, basta con clonar el repositorio y ejecutar composer update. Eso rellenará la carpeta /vendor con las librerías adecuadas para ese servidor. | . 2.3.2. Convenciones en Laravel . Laravel tiene un montón de convenciones que persiguen hacer más sencilla la configuración de la aplicación y evitar errores tontos que pueden consumir mucho tiempo de depuración. Aunque la mayoría de estas convenciones no son obligatorias, es recomendable respetarlas para ahorrarte quebraderos de cabeza posteriores. | En primer lugar, usa solo identificadores en inglés. Mejor User que Usuario. Así, de paso, practicas un poco el idioma universal de la informática. | Modelos: Los nombres de los modelos deben ser iguales a los de las tablas de la base de datos, pero en singular, en CamelCase y con mayúscula. Ejemplo: RegisteredUser . | Controladores: Llámalos como los modelos, pero añadiendo la palabra “controller”. Ejempo: RegisteredUserController . | Métodos: Se nombran en camelCase, empezando con minúscula (también llamado PascalCase). Ejemplo: RegisteredUser::getAll() . | Atributos: Se nombran en en snake_case y empezando con minúscula. Ejemplo: RegisteredUser::first_name . | Variables: Los identificadores deben ir en camelCase y empezando con minúscula. En plural si se trata de una colección y en singular si es un objeto individual o una variable simple. Ejemplos: bannedUsers (colección, en plural), articleContent (objeto individual, en sigular) . | Tablas: Se nombran en plural y en snake_case. Ejemplo: registered_users. | Columnas de las tablas: Se nombran en snake_case, sin referencia al nombre de la tabla. Ejemplo: first_name . | Clave primaria: La llamaremos id. Siempre. No le des más vueltas. id y punto. El tipo: integer y auto-increment. | Claves ajenas: Se forman con el nombre de la tabla ajena en singular más la palabra id. Ejemplo: article_id . | Timestamps: Laravel siempre crea marcas de tiempo para todo. Y siempre se llaman created_at y updated_at, de tipo datetime. Acostúmbrate a tenerlas en todas tus tablas. | . | Tablas pivote: Son esas tablas horribles formadas como resultado de una relación N:N entre dos tablas maestras. Se nombran en snake_case, en plural y orden alfabético. Ejemplo: articles_users será el pivote entre las tablas articles y users. | . 2.3.3. Variables de entorno. El archivo .env . En el directorio raíz de toda aplicación hecha con Laravel existe un archivo muy especial llamado .env. Ojo, porque en los sistemas tipo Linux, todos los archivos cuyo nombre empieza por un punto están ocultos. Debes buscar la opción para mostrar los archivos ocultos de tu navegador de archivos si quieres verlo. NOTA: Una instalación limpia de Laravel no tendrá archivo .env, sino un .env.example que puedes renombrar y usar como base para construir tu propio .env . El archivo .env contiene todas las variables de entorno que configuran la aplicación, como: . | APP_ENV: En esta variable se indica si la aplicación está en desarrollo o en producción . | APP_DEBUG: ¿Queremos mostrar los errores para depuración? Se pone a true durante el desarrollo y se cambia a false al pasar a producción. | APP_URL: La URL base de la aplicación. Hay que modificarla cuando movemos la aplicación a otro servidor. | DB_CONNECTION, DB_HOST, DB_USERNAME, etc. Es decir, la configuración de la conexión a la base de datos. | . Cuidado: el archivo .env NO debe sincronizarse con git (o con el control de versiones que usemos) porque contiene información sensible. Asegúrate de incluirlo en tu .gitignore. Consulta la sección sobre Git de este mismo manual si no sabes como hacerlo. Si cambias el contenido del archivo .env, posiblemente necesites limpiar la cache de configuración de Laravel para que el servidor asuma esos cambios: . $ php artisan config:clear . Una vez creado nuestro archivo .env, podemos usar las variables definidas en él en cualquier otra parte de la aplicación. Por ejemplo, si necesitamos acceder al nombre del host de la base de datos podemos hacer: . $host = env('DB_HOST', 'localhost'); . El primer parámetro de env() es la variable de entorno que queremos consultar y el segundo (optativo) es el valor por defecto en caso de que la variable no exista. ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/configuracion.html#23-arquitectura-convenciones-y-configuraci%C3%B3n-de-laravel",
    "relUrl": "/laravel/configuracion.html#23-arquitectura-convenciones-y-configuración-de-laravel"
  },"66": {
    "doc": "2.3 Configuración de Laravel",
    "title": "2.3 Configuración de Laravel",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/configuracion.html",
    "relUrl": "/laravel/configuracion.html"
  },"67": {
    "doc": "2.4 Artisan",
    "title": "2.4. Artisan",
    "content": ". | 2.4.1. ¿Qué es Artisan y cómo se utiliza? | 2.4.2. Un ejemplo práctico: crear un controlador | 2.4.3. Artisan con Docker: Sail | 2.4.4. Chuleta: comandos principales de Artisan | . Laravel viene de serie con muchas herramientas útiles. Una de ellas es Artisan, un programa de consola que automatiza montones de tareas habituales del trabajo con Laravel, así que acostúmbrate a tener siempre abierto un terminal de texto en el directorio raíz de tu aplicación. 2.4.1. ¿Qué es Artisan y cómo se utiliza? . Artisan es una herramienta de consola, escrita en PHP, que viene con Laravel para ayudarte a realizar tareas cotidianas en tu aplicación de forma automatizada. Algunas de esas tareas que automatiza Artisan son: . Generar scaffolding (esqueleto) de controladores y modelos. Crear migraciones de bases de datos (para manipular la estructura de las tablas) Rellenar la BD con datos de prueba. Gestionar y listar rutas. Cachear y limpiar la aplicación. Crear baterías de pruebas. Y otro montón de cosas. | Generar scaffolding (esqueletos o andamios) de controladores y modelos. | Gestionar las migraciones de bases de datos. Hablaremos de esto más adelante. | Rellenar o resetear la BD con datos. | Gestionar y listar rutas. | Cachear y limpiar la aplicación, según nos convenga. El cacheo hace que todo funcione más rápido, la limpieza hace que el caché funcione correctamente cuando hacemos ciertos cambios. | Crear baterías de pruebas y lanzar los tests (si usamos PHP Unit, por ejemplo, algo que no lo vamos a ver). | Ejecutar código, por ejemplo con Eloquent, sin necesidad de crear un archivo y lanzarlo. | . Y así otro montón de cosas. No te preocupes si aún no entiendes qué significan algunas de estas cosas. Lo iremos viendo todo poco a poco. Lo importante ahora es que comprendas la tremenda utilidad de Artisan en el trabajo cotidiano con Laravel y que aprendas lo básico de su sintaxis. 2.4.2. Un ejemplo práctico: crear un controlador . Veamos cómo funciona Artisan con un ejemplo. Supongamos que quieres crear un controlador. Para ello, existen dos maneras: . | A mano. Nos vamos al directorio /app/Http/Controllers y creamos un archivo llamado, digamos, HolaController.php. Luego lo rellenamos con el esqueleto de un controlador vacío, copiando y pegando de otro controlador existente y eliminando todo lo que no nos haga falta. Este método, obviamente, es lento, farragoso y resulta fácil que cometamos algún error. | Con Artisan. Simplemente, tecleamos este comando en el directorio raíz de nuestra aplicación: . $ php artisan make:controller HolaController . ¡Hemos terminado! Artisan creará por nosotros el archivo /app/Http/Controllers/HolaController.php y lo rellenará con el esqueleto de un controlador vacío y sintácticamente correcto. | . 2.4.3. Artisan con Docker: Sail . Si utilizas Laravel con virtualizado con Docker, según la recomendación oficial, es importante que comprendas que Artisan solo se puede ejecutar dentro de la máquina virtual. No es un comando que exista fuera de tu servidor. Laravel proporciona una herramienta llamada sail para facilitar la ejecución de artisan desde el exterior del contenedor. Simplemente, para lanzar artisan, escribe esto: . $ ./vendor/bin/sail artisan &lt;comando-de-artisan&gt; . Si te resulta muy largo eso de escribir ./vendor/bin/sail, puedes crear un alias en tu shell para acortarlo: . $ alias sail='[ -f sail ] &amp;&amp; bash sail || ./vendor/bin/sail' . Con ese alias podrás ejecutar artisan así: . $ sail artisan &lt;comando-de-artisan&gt; . De ahora en adelante, cuando veas un comando de artisan en este manual, recuerda que debes sustituir \"php\" por \"./vendor/bin/sail\" si estás trabajando con Docker . 2.4.4. Chuleta: comandos principales de Artisan . (Recuerda: sustituye php artisan por ./vendor/bin/sail artisan si estás usando Docker) . Una buena forma de empezar con Artisan es teclear este comando: . $ php artisan list . Ya te imaginas lo que hace, ¿verdad? . Por si acaso andas un poco despistado/a hoy, te lo cuento yo: Artisan te mostrará una lista con todos los comandos válidos en tu instalación de Laravel. Esto puede variar según tu versión de Laravel y los componentes que tengas instalados. En un primer momento, estos son los comandos que más vas a utilizar (cuando te conviertas en un experto/a en Laravel, irán llegando otros por pura necesidad): . | Comando Artisan | Significado | . | php artisan serve | Lanza un servidor de desarrollo (no es necesario si usas Docker) | . | php artisan migrate | Para hacer migraciones (gestionar la estructura de la base de datos) | . | php artisan db:seed | Para gestionar los datos de la base de datos | . | php artisan tinker | REPL interactivo. El REPL es un entorno de línea de comandos donde puedes probar y ejecutar código PHP y acceder a tu aplicación en tiempo real sin crear archivos ni afectar tu código existente. Muy útil para hacer alguna prueba rápida | . | php artisan make:migration | Crea una migración | . | php artisan make:seeder | Crea un seeder | . | php artisan make:controller | Crea un controlador | . | php artisan make:model | Crea un modelo | . | php artisan route:list | Muestra todas las rutas definidas | . | $ php artisan config:cache | Genera configuración optimizada | . | $ php artisan route:cache | Optimiza el enrutador | . | $ php artisan config:clear$ php artisan route:clear$ php artisan cache:clear$ php artisan view:clear | Elimina las cachés (útil si Laravel no «pilla» los últimos cambios) | . ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/artisan.html#24-artisan",
    "relUrl": "/laravel/artisan.html#24-artisan"
  },"68": {
    "doc": "2.4 Artisan",
    "title": "2.4 Artisan",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/artisan.html",
    "relUrl": "/laravel/artisan.html"
  },"69": {
    "doc": "2.5 Hola mundo",
    "title": "2.5. Hola mundo",
    "content": ". | Solución 1: saludar en el enrutador | Solución 2: saludar en un controlador | Solución 3: saludar en una vista | . En esta sección vamos a crear nuestra primera aplicación funcional con Laravel: el tradicional “Hola mundo”. Vale, ya sé que no es gran cosa, pero nos servirá para aprender la dinámica de trabajo con Laravel y para construir un esqueleto de aplicación sobre el que montar algo más grande más adelante. Vamos a crear esta aplicación de tres formas diferentes, para que veas diferentes componentes de Laravel en acción en cada una de las soluciones. Tal vez te parezca un poco exagerado, pero recuerda que la curva de aprendizaje de Laravel es muy pronunciada al principio. Es decir: los primeros pasos son los que más cuestan. Solución 1: saludar en el enrutador . Vamos a empezar probando algo sencillo: capturar una ruta y hacer una salida HTML desde ella. Esto no es lo habitual en una aplicación: solo se trata de una prueba rápida. Edita el archivo ENRUTADOR (/routes/web.php) y añade esto: . Route::get('/hola', function() { return \"Hola, mundo\"; }); . Esto significa que, cuando escribas la ruta “hola” en la barra de direcciones del navegador, se ejecutará esta función anónima (denominadas closures) y, como resultado, se recibirá el texto “Hola, mundo” en la ventana del navegador. Pruébalo en la URL http://tu-servidor/hola . Solución 2: saludar en un controlador . Esta solución tampoco es ideal: solo se trata de otra prueba rápida. Los closures o funciones sin nombre, como la que acabamos de usar, raramente se usan en el enrutador. Lo que suele hacer el enrutador es redirigir la ejecución hacia un controlador. Es justo lo que vamos ahora. ENRUTADOR (/routes/web.php) . Sustituye la ruta anterior por esto: . use App\\Http\\Controllers\\HolaController; Route::get('/hola', [HolaController::class, 'index']); . Esto indica al enrutador que, al recibir la ruta “hola”, se debe ejecutar el método index() del controlador HolaController. CONTROLADOR (/app/Http/Controllers/HolaController.php) . El controlador HolaController aún no existe, así que vamos a crearlo con este comando de Artisan: . $ php artisan make:controller HolaController . Por último, edita el controlador (/app/Http/Controllers/HolaController.php) y añádele el método index(): . namespace App\\Http\\Controllers; class HolaController extends Controller { public function index() { return \"Hola, mundo\"; } } . Comprueba que funciona en tu navegador: http://tu-servidor/hola . Solución 3: saludar en una vista . Esta es la solución adecuada, puesto que: 1) Captura una ruta, 2) El enrutador redirige la ejecución a un controlador, y 3) El enrutador renderiza una vista . Parece mucho follón para un “Hola, mundo”, pero recuerda que solo es un ejemplo. En la arquitectura MVC, el controlador no debería producir ninguna salida HTML. Pues bien, nuestro controlador anterior la está produciendo, así que vamos a modificarlo para que no genere directamente el texto “Hola, mundo”, sino que renderice una vista que se encargue de ello. Además, vamos a inyectar en la URL una variable con el nombre del usuario para mostrar cómo se capturan esos valores y cómo se pasan a las vistas en Laravel. ENRUTADOR (/routes/web.php) . Observa cómo se usan las llaves { y } para indicar la presencia de una variable en la ruta: . use App\\Http\\Controllers\\HolaController; Route::get('/hola/{nombre}', [HolaController::class, 'show']); . CONTROLADOR (/app/Http/Controllers/HolaController.php) . Vamos a añadir un método show() al controlador: . namespace App\\Http\\Controllers; class HolaController { public function index() { return \"Hola, mundo\"; } public function show($nombre) { return view('hola', ['nombre' =&gt; $nombre]); } } . Como ves, estamos invocando una vista llamada hola (return view('hola')) y le estamos pasando un array con los datos necesarios (el nombre del usuario, en este caso). VISTA BLADE (/resources/views/hola.blade.php) . El archivo con la vista debe crearse en /resources/views/hola.blade.php y puede un aspecto como este: . &lt;body&gt; Saludos, {{$nombre}}. ¿Le apetece una partidita de ajedrez? &lt;/body&gt; . Puedes probar esta nueva ruta cargando en el navegador una URL como: http://tu-servidor/hola/ProfesorFalken . La respuesta debería ser esta: . Saludos, ProfesorFalken. ¿Le apetece una partidita de ajedrez? . (Solo pillarás la referencia si has visto Juegos de guerra (John Badham, 1983)) . ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/hola-mundo-con-laravel.html#25-hola-mundo",
    "relUrl": "/laravel/hola-mundo-con-laravel.html#25-hola-mundo"
  },"70": {
    "doc": "2.5 Hola mundo",
    "title": "2.5 Hola mundo",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/hola-mundo-con-laravel.html",
    "relUrl": "/laravel/hola-mundo-con-laravel.html"
  },"71": {
    "doc": "2.6 Enrutamiento",
    "title": "2.6. Enrutamiento",
    "content": ". | 2.6.1. ¿Qué es el enrutador? | 2.6.2. Enrutamiento básico | 2.6.3. Rutas con nombre | 2.6.4. Verbos http: GET, POST, PUT, PATCH y DELETE | 2.6.5. Orden de las rutas | 2.6.6. Servidor RESTful | . Llegados a este punto, ya debes haber creado tu primera aplicación Laravel (“Hola, mundo”) y habrás aprendido algo fundamental sobre el enrutador: cómo hacer que la solicitud de una URL termine ejecutando un método de un controlador. En esta sección, profundizaremos en el enrutador, un componente fundamental de cualquier aplicación web. 2.6.1. ¿Qué es el enrutador? . El enrutador de Laravel es el componente que captura las URL solicitadas al servidor y las traduce a invocaciones a métodos de los controladores. El enrutador es capaz, además, de mapear fragmentos de la URL a variables PHP que serán inyectadas como parámetros a los métodos del controlador. Esto significa que, si le pides al servidor una ruta como esta: . https://mi-servidor/user/delete/12 . …el enrutador puede “trocear” esa URL para extraer los segmentos (“user”, “delete” y “12”). Y tú puedes decidir qué hacer con cada uno de esos segmentos. Lo normal en este ejemplo sería que: . | Se invoque el método delete() del controlador UserController. | Ese método reciba como parámetro el dato 12 (se supone que será el id del usuario que se pretende borrar). | Se proceda al borrado de ese usuario y a la creación de una vista como respuesta (tal vez indicando “usuario borrado con éxito” o algo parecido). | . Hay otra cosa que el enrutador puede hacer: distinguir el verbo http empleado para solicitar una página al servidor. Es decir, para el enrutador no es lo mismo una solicitud enviada por GET que otra enviada por POST. Incluso admite verbos que aún no están soportados por HTML, como DELETE o PUT, y que teóricamente van a formar parte de futuras implementaciones de HTML. Un poco más abajo explicaremos qué narices significa todo esto. 2.6.2. Enrutamiento básico . Como vimos en el ejemplo del “Hola, mundo”, hay varias formas de generar una salida HTML desde el enrutador (/routes/web.php). En este código de ejemplo vemos las cuatro formas básicas: . // Forma 1: generar la salida con un closure (función sin nombre) // (No suele usarse, solo con propósitos de prueba rápida) Route::get('/hola', function() { return \"Hola, mundo\"; }); // Forma 2: llamar a un controlador sin pasarle parámetros use App\\Http\\Controllers\\HolaController; Route::get('/hola', [HolaController::class, 'show']); // Forma 3: llamar a un controlador pasándole parámetros use App\\Http\\Controllers\\HolaController; Route::get('/hola/{nombre}', [HolaController::class, 'show']); // Forma 4: llamar a un controlador con un parámetro optativo use App\\Http\\Controllers\\HolaController; Route::get('/hola/{nombre?}', [HolaController::class, 'show']); . La diferencia esntre la forma 3 y la 4 es que, en la forma 3, la ruta debe llevar forzosamente un dato a continuación de “/hola” (algo como: https://mi-servidor/hola/juan). Si no lo lleva, el enrutador considerará que no se trata de esa ruta y seguirá buscando alguna ruta coincidente en el resto del archivo. En cambio, en la forma 4, el dato final es optativo, así que el enrutador invocará el método show() del controlador tanto si ese dato aparece en la URL como si no lo hace. 2.6.3. Rutas con nombre . Es MUY recomendable asignar un nombre a las rutas en el enrutador. Esto hace que, más adelante, podamos cambiar la URL de los enlaces sin tener que modificar el código fuente de nuestras vistas. El nombre se le asigna a una ruta añadiendo -&gt;name('nombre') al final: . use App\\Http\\Controllers\\ContactoController; Route::get('/contactame', [ContactoController::class, 'contacto'])-&gt;name('contact'); . En tu código fuente, debes referirte a esta ruta siempre con la expresión route('contact') (ya veremos exactamente cómo se hace esto), pero el usuario verá la dirección https://servidor/contactame. En el futuro se puede cambiar la forma en la que lo ve el usuario. Por ejemplo, puedes cambiar Route::get('/contactame'...) por Route::get('/acerca-de'...), pero no tendrás que modificar ni una línea de código más en tu aplicación, porque internamente esa ruta seguirá llamándose route('contact'). 2.6.4. Verbos http: GET, POST, PUT, PATCH y DELETE . Además de GET, en el enrutador se pueden enrutar otras acciones: . Route::get(); // Solicitudes habituales Route::post(); // Recepción de datos de formulario (para insert) Route::put(); // Recepción de datos para update (también puede escribirse Route::patch(), que no es lo mismo, pero casi) Route::delete(); // Recepción de datos para delete Route::match(array('GET','POST'), 'ruta', acción) // Responderá tanto a GET como a POST . Los verbos PUT, PATCH y DELETE no están soportados aún por HTML. Las razones por las que esto ocurre son tan confusas que, sinceramente, creo que ni siquiera en el W3C lo entienden. La cuestión es que aún no existen, y punto. Es decir, no puedes crear un formulario así: &lt;form method='PUT'&gt;, porque tu navegador no lo entenderá. Solo puedes poner &lt;form method='GET'&gt; o &lt;form method='POST'&gt;. Cuando trabajes con Laravel, puedes emular PUT, PATCH o DELETE en los formularios así: . &lt;form action=\"/foo/bar\" method=\"POST\"&gt; @method('DELETE') . Tal vez, llegado a este punto, te estés preguntando qué diferencia hay entre PUT y PATCH. O tal vez no. Salta a la siguiente sección si no te interesan estas sutilezas, y continúa leyendo en caso contrario. | PUT: Una petición enviada por PUT debería culminar con la ejecución de un UPDATE en el servidor que modifique un recurso entero. Es decir, un registro completo de una tabla de la base de datos. | PATCH: Debería emplearse cuando el UPDATE vaya a modificar solo una parte de los campos de un registro, y no todos. | . 2.6.5. Orden de las rutas . El orden en el que se escriben las rutas en el enrutador es importante. Por ejemplo, si pedimos la dirección http://mi-servidor/usuario/crear, escribir estas dos rutas en este orden es un error: . Route::get('usuario/{nombre}', [UserController::class, 'show']); Route::get('usuario/crear', [UserController::class, 'create']); . El enrutador tratará de mostrar un usuario cuyo nombre sea “crear” (que seguramente no existirá) porque la petición encaja con las dos rutas y el enrutador elegirá la primera ruta que encuentre. La solución pasa por alterar el orden de las líneas en el enrutador: . Route::get('usuario/crear', [UserController::class, 'create']); Route::get('usuario/{nombre}', [UserController::class, 'show']); . De este modo, la petición http://mi-servidor/usuario/crear seguirá encajando en las dos rutas, pero el enrutador elegirá la primera. En cambio, una petición parecida pero con cualquier otro nombre (por ejemplo, http://mi-servidor/usuario/luis), solo encajará con la segunda ruta. 2.6.6. Servidor RESTful . Un servidor RESTful es aquel que responde a la arquitectura REST. La arquitectura REST no es más que una forma estandarizada de construir un servidor para que realice las tareas típicas de mantenimiento de recursos. Y los recursos pueden ser cualquier cosa que se almacene en el servidor: usuarios, clientes, productos, películas, facturas… . Es decir: el 99% de las veces, los recursos son registros en una tabla de la base de datos. El enrutador de un servidor RESTful contendrá las 7 operaciones definidas en la arquitectura REST para cada recurso accesible desde la red, y que permiten manipular el recurso: mostrarlo, buscarlo, insertarlo, modificarlo o borrarlo. Por ejemplo, para un recurso llamado “user”, esas 7 operaciones son: . Route::get('user', [UserController::class, 'index']) -&gt;name('user.index'); Route::get('user/{user}', [UserController::class, 'show']) -&gt;name('user.show'); Route::get('user/create', [UserController::class, 'create']) -&gt;name('user.create'); Route::post('user', [UserController::class, 'store']) -&gt;name('user.store'); Route::get('user/{user}/edit', [UserController::class, 'edit']) -&gt;name('user.edit'); Route::patch('user/{user}', [UserController::class, 'update']) -&gt;name('user.update'); Route::delete('user/{user}', [UserController::class, 'destroy']) -&gt;name('user.destroy'); . Ten encuenta que, si estás construyendo un servidor RESTful, debes respetar escrupulosamente los nombres y URLs de las rutas. Así, cualquier otro usuario o aplicación que use tu servidor sabrá cómo manipular los recursos sin necesidad de consultar la documentación técnica. Laravel te permite resumir esas entradas del enrutador en una sola línea que engloba a las siete rutas REST: . Route::resource('user', UserController::class); . ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/enrutamiento.html#26-enrutamiento",
    "relUrl": "/laravel/enrutamiento.html#26-enrutamiento"
  },"72": {
    "doc": "2.6 Enrutamiento",
    "title": "2.6 Enrutamiento",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/enrutamiento.html",
    "relUrl": "/laravel/enrutamiento.html"
  },"73": {
    "doc": "2.7 Vistas y plantillas con Blade",
    "title": "2.7. Vistas y plantillas con Blade",
    "content": ". | 2.7.1. Un primer ejemplo | 2.7.2. Master layout | 2.7.3. Vistas que heredan del master layout | 2.7.4. Cómo pasar variables a las vistas | 2.7.5. Cómo usar las variables en las vistas | 2.7.6. Condiciones en las vistas | 2.7.7. Bucles en las vistas | 2.7.8. Invocación de funciones PHP | 2.7.9. Chuleta de directivas de Blade | 2.7.10. Tratamiento de formularios con Blade | 2.7.11. Validación de formularios con Blade | 2.7.12. Añadir CSS y Javascript a nuestras vistas | 2.7.13. Vistas de error personalizadas | . Blade es un poderoso y sencillo sub-lenguaje que nos permitirá generar vistas con mucho menos código, y más limpio, del que usaríamos con PHP y HTML estándar. Las plantillas Blade admiten condiciones y bucles para operar con las variables PHP, de modo que la misma plantilla se comporta de forma diferente con diferentes conjuntos de datos. ¡Y se acabó la pesadilla de abrir y cerrar comillas en las instrucciones echo! . Con Blade, tampoco será necesario abrir y cerrar php (&lt;?php ... ?&gt;) para operar con las variables del servidor y generar la salida. El código escrito con Blade no solo es más limpio y fácil de depurar que con PHP básico, sino también más seguro, porque Blade impide cualquier ataque con XSS. Pero es no es todo. Además, unas plantillas pueden heredar de otras para reutilizar mejor el código. Así que Blade tiene un montón de ventajas y ningún inconveniente. Bueno, sí que tiene un inconveniente: que tienes que aprender a usarlo. Pero es tan sencillo que, cuando hayas trabajado con Blade un par de semanas, te preguntarás cómo habías podido sobrevivir hasta ahora sin él. 2.7.1. Un primer ejemplo . Vamos a empezar con un ejemplo de código Blade, para que veas la diferencia con el HTML/PHP convencional. Échale un vistazo detenidamente a este código y trata de averiguar lo que hace. Ten en cuenta que “success” es un variable de sesión (las veremos más adelante) y que $libros es una variable PHP que contiene un array con libros que deben ser mostrados en HTML. @extends('layouts.app') &lt;!-- Heredamos un layout base con &lt;html&gt;, &lt;head&gt;, etc. --&gt; @section('title', 'Lista de libros') @section('content') &lt;h1&gt;Lista de libros&lt;/h1&gt; &lt;!-- Mensajes de éxito o error --&gt; @if (session('success')) &lt;div class=\"alert alert-success\"&gt;{{ session('success') }}&lt;/div&gt; @endif &lt;!-- Si no hay libros, mostramos un mensaje --&gt; @if ($libros-&gt;isEmpty()) &lt;p&gt;No hay libros en la biblioteca.&lt;/p&gt; @else &lt;table border=\"1\" cellpadding=\"6\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Título&lt;/th&gt; &lt;th&gt;Género&lt;/th&gt; &lt;th&gt;Nº páginas&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;!-- Bucle Blade: más limpio que PHP puro --&gt; @foreach ($libros as $libro) &lt;tr&gt; &lt;td&gt;{{ $libro-&gt;titulo }}&lt;/td&gt; &lt;td&gt;{{ $libro-&gt;genero }}&lt;/td&gt; &lt;td&gt;{{ $libro-&gt;num_paginas }}&lt;/td&gt; &lt;/tr&gt; @endforeach &lt;/tbody&gt; &lt;/table&gt; @endif &lt;p&gt;&lt;a href=\"{{ route('libros.create') }}\"&gt;Añadir nuevo libro&lt;/a&gt;&lt;/p&gt; @endsection . 2.7.2. Master layout . Layout es una forma genérica de referirse al diseño de capas del interfaz de usuario de una aplicación. Es decir, el layout de una aplicación es el diseño de los elementos de su interfaz de usuario. (Ejemplos de layout adaptados a diferentes tamaños de pantalla. Imagen tomada de Seobility.net y publicada con licencia CC BY-SA 4.0) . El master layout es el diseño maestro del que derivan todas las vistas. Las aplicaciones web suelen tener un master layout muy definido, y todas las vistas de la aplicación lo respetan. Ese master layout suele almacenarse, por convenio, en un archivo llamado /resources/views/layouts/master.blade.php . Vamos a construir un master layout de ejemplo. Será muy simple, pero más adelante puedes complicarlo todo lo que quieras, y cada modificación afectará automáticamente a todas las vistas de tu aplicación. &lt;html&gt; &lt;head&gt; &lt;title&gt;@yield('title')&lt;/title&gt; &lt;/head&gt; &lt;body&gt; @section('sidebar') Este es mi master sidebar. @show &lt;div class=\"container\"&gt; @yield('content') &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; . Aquí nos encontramos con varias directivas importantes de Blade: . | @yield(‘Titulo’) –&gt; Esto define una sección llamada ‘Título’, que en el master layout está vacía. Las vistas que hereden del master layout tendrán que definir cuál es el valor de ‘Título’, y ese valor aparecerá escrito aquí. | @section(‘sidebar’) –&gt; Esto define una sección llamada ‘sidebar’ que NO está vacía (contiene el texto “Este es mi master sidebar”, pero podría contener cualquier otra cosa). Las vistas que hereden del master layout podrán AÑADIR contenido a esta sección. | @show –&gt; Hace que el contenido de la sección se muestre en ese punto del documento. | @yield(‘content’) –&gt; De nuevo, una sección que está vacía en el master layout y cuyo contenido tendrá que definirse en las vistas que hereden de esta. | . 2.7.3. Vistas que heredan del master layout . Después de crear nuestro master layout, lo siguiente es empezar a construir vistas que lo utilicen. Es decir, que hereden de él todos sus componentes y añadan nuevos elementos, respetando la configuración básica establecida por el master layout. El aspecto de una vista que herede del master layout de nuestro ejemplo anterior debería ser este, en un archivo que podría llamarse /resources/views/page.blade.php: . @extends('layouts.master') @section('title', 'Titulo de la página') @section('sidebar') &lt;p&gt;Esto se añadirá al master sidebar.&lt;/p&gt; @endsection @section('content') &lt;p&gt;Aquí va el contenido de mi página.&lt;/p&gt; @endsection . De nuevo tenemos varias directivas de Blade muy importantes: . | @extends(‘master’) –&gt; Esto indica que esta vista hereda del master layout. | @section(‘title, ‘Título de la página’) –&gt; Aquí se define el contenido de la sección ‘Título’ que en el master layout estaba vacía. | @section(‘sidebar’) –&gt; Aquí añade contenido a la sección ‘sidebar’, que en el master layout no estaba vacía. | @ensection –&gt; Se emplea cuando el contenido de una sección ocupa varias líneas de código y no es posible escribirlo dentro de la propia directiva. | . Puedes testear la vista anterior muy fácilmente, añadiendo esta ruta a tu enrutador (/routes/web.php): . Route::get('prueba-blade', function () { return view('page'); }); . Luego prueba esta URL en tu navegador: http://tu-dominio/prueba-blade . 2.7.4. Cómo pasar variables a las vistas . Las variables a las vistas deben enviarse empaquetadas en un array. Hay varias formas de lograr esto, todas ellas correctas, aunque en la actualidad se recomiendan las dos primeras. // FORMAS PREFERIBLES EN LA ACTUALIDAD: // Forma 1: creando un array que contenga los datos usando notación corchete: return view('vista', ['variable1'=&gt;'valor', 'variable2'=&gt;'valor']); // Forma 2: creando un array que contenga los datos usando compact(): return view('vista', compact('variable1', 'variable2')); // FORMAS ADMITIDAS PERO EN DESUSO: // Forma 3: creando un array con los datos usando array(): return view('vista', array('variable1'=&gt;'valor', 'variable2'=&gt;'valor')); // Forma 4: creando un array con los datos usando with(): return view('vista')-&gt;with(['variable1'=&gt;'valor', 'variable2'=&gt;'valor']); . 2.7.5. Cómo usar las variables en las vistas . Vale, ya hemos enviado algunas variables a las vistas. Ahora, ¿cómo las usamos? . La vista no recibe el array con las variables, sino las variables ya extraídas del array. Esto significa que, si le pasas a una vista un par de variables como ['variable1'=&gt;'valor', 'variable2'=&gt;'valor'], en la vista existirán dos variables llamadas $variable1 y $variable2, y no encontrarás ni rastro del array que las contenía. Veámoslo con un ejemplo. Supongamos que tenemos este método en un controlador cualquiera: . function show() { return view('page', ['name' =&gt; 'Manolo Escobar']); } . En la vista /resources/views/page.blade.php tendrás disponible una variable $name, y la puedes usar de este modo: . @extends('layouts.master') @section('title', 'Page Title') @section('sidebar') &lt;p&gt;Esto se añadirá al sidebar del master layout.&lt;/p&gt; @endsection @section('content') &lt;h2&gt;{{$name}}&lt;/h2&gt; &lt;p&gt;Este es el contenido de mi página.&lt;/p&gt; @endsection . Observa que hemos respetado el master layout de ejemplo que creamos más arriba. Observa también cómo se hace el echo de la variable: nada de abrir y cerrar PHP (&lt;?php ... ?&gt;) ni de abrir y cerrar comillas: simplemente, se encierra la variable entre llaves dobles ({{$variable}}), y Laravel se encargará de traducir eso al echo correspondiente. La vista queda de ese modo mucho más limpia y, por lo tanto, es más fácil de escribir, leer y depurar. 2.7.6. Condiciones en las vistas . Blade admite expresiones condicionales para modificar el aspecto de una vista dependiendo del valor de una variable o del estado de la aplicación. Por supuesto, eso también puede hacerse sin Blade: solo hay que usar un if de PHP. Pero con Blade es más fácil y limpio porque, nuevamente, no tendremos que andar abriendo y cerrando PHP ni peleándonos con las comillas del echo. En el siguiente ejemplo, el contenido de la vista depende de la variable $day enviada desde el controlador. Observa como el if de PHP se sustituye por la directiva @if de Blade. Controlador: . function show() { return view('page',['name' =&gt; 'Manolo','day' =&gt; 'Viernes']); } . Vista /resources/views/page.blade.php: . @extends('layouts.master') @section('title', 'Page Title') @section('sidebar') &lt;p&gt;Esto se añadirá al sidebar del master layout.&lt;/p&gt; @endsection @section('content') &lt;h2&gt;{{$name}}&lt;/h2&gt; &lt;p&gt;Este es el contenido de mi página.&lt;/p&gt; @if ($day == 'Viernes') &lt;p&gt;Hoy me roban el carro&lt;/p&gt; @else &lt;p&gt;Hoy me dedico a cantar&lt;/p&gt; @endif @endsection . 2.7.7. Bucles en las vistas . Igual que existen condiciones, Blade también permite hacer bucles para simplificar la generación de visas. Por ejemplo, en la siguiente vista recorremos un array llamado $bebidas y mostramos su contenido. Controlador: . function show() { $bebidas = array('Cerveza','Agua','Zumo'); return view('page',['name' =&gt; 'Manolo','day' =&gt; 'Lunes', 'bebidas' =&gt; $bebidas]); } . Vista /resources/views/page.blade.php: . @extends('layouts.master') @section('title', 'Page Title') @section('sidebar') &lt;p&gt;Esto se añadirá al sidebar del master layout.&lt;/p&gt; @endsection @section('content') &lt;h2&gt;{{$name}}&lt;/h2&gt; &lt;p&gt;Este es el contenido de mi página.&lt;/p&gt; @if ($day == 'Viernes') &lt;p&gt;Hoy me roban el carro&lt;/p&gt; @else &lt;p&gt;Hoy me dedico a cantar&lt;/p&gt; @endif &lt;h2&gt;Estas son las bebidas disponibles:&lt;/h2&gt; @foreach ($bebidas as $bebida) {{$bebida}} &lt;br&gt; @endforeach @endsection . Observa que, nuevamente, esto mismo podría hacerse con PHP clásico, pero con Blade el código queda mucho más limpio y resulta menos propenso a errores. 2.7.8. Invocación de funciones PHP . Desde una vista Blade se puede invocar cualquier función de PHP sin necesidad de abrirlo y cerrarlo (ya sabes: nada de &lt;?php ... ?&gt; en las vistas). Por ejemplo, si necesitamos usar la función date(), la invocamos así: . &lt;h2&gt;Ejemplo de llamada a función estándar de PHP&lt;/h2&gt; &lt;p&gt;La fecha del servidor es: {{date(' D M, Y')}}&lt;/p&gt; . Esto no solo es más limpio, sino también más seguro, porque Blade filtra posibles ataques por XSS. (Por cierto: si alguna vez necesitas saltarte la protección contra XSS, puedes usar {!! … !!} en lugar de {{ … }}). 2.7.9. Chuleta de directivas de Blade . Blade dispone de multitud de directivas para hacer prácticamente cualquier cosa en la vista sin tener que recurrir a PHP. En esta lista mostramos las más habituales. | @section → Marca el inicio de una sección de contenido. | @endsection → Marca el final de una sección. | @show → Marca el final de una sección y la muestra. | @yield(‘section’) → Muestra el contenido de una sección (si existe, claro). | @extends(‘view’) → Hereda de una plantilla padre. | @parent → Muestra el contenido de la sección del mismo nombre en la plantilla padre. | @include(‘view’) → Incluye una subvista. | @if - @else - @endif → Condicional. | @for - @endfor → Bucle for clásico. | @foreach - @endforeach → Buche foreach. | @forelse - @empty - @endforelse → Como foreach, pero con tratamiento de arrays que vienen vacíos. | @break - @continue → Para usar en los bucles. | @switch - @case - @break → Condicional múltiple. | @isset($variable) - @endisset → Comprueba si la variable existe. | @auth - @endauth → La sección solo se muestra si hay un usuario autenticado en la aplicación. | @php - @endphp → Para añadir código PHP plano. Usar con moderación. | {{- Comment -}} → Comentarios (no serán renderizados). | {{ $variable }} → Equivalente a echo $variable, pero no es necesario abrir y cerrar PHP, y nos protegemos contra inyección de JS. | {{ $variable ?? texto-por-defecto }} → Como el anterior, pero chequea si la variable existe. Si existe, muestra su valor. Si no, muestra texto-por-defecto. | $loop → Es una variable muy útil para usar en y/o depurar un foreach. Nos dice si estamos en el primer elemento, en el último, cuántos loops llevamos, etc. | . 2.7.10. Tratamiento de formularios con Blade . Blade también facilita un montón el tratamiento de los formularios. Y, por supuesto, filtra por nosotros cualquier código malicioso que traten de colarnos a través de ellos. Vamos a verlo con un ejemplo. Imaginemos una vista con este formulario (fíjate cómo indicamos la ruta en el action): . &lt;form method=\"POST\" action=\"{{ route('mi-ruta') }}\"&gt; @csrf &lt;!-- Para evitar ataques CSRF --&gt; &lt;input type=\"email\" name=\"email\"&gt;&lt;br&gt; &lt;input type=\"text\" name=\"asunto\"&gt;&lt;br&gt; &lt;textarea name=\"contenido\"&gt;&lt;/textarea&gt;&lt;br&gt; &lt;button type=\"submit\"&gt;Enviar&lt;/button&gt; &lt;/form&gt; . Recuerda que los métodos PUT, PATCH y DELETE no existen aún en HTML y que Laravel los simula con un campo oculto en el formulario que se crea con la directiva @method(‘PUT’) (o PATCH o DELETE). En este formulario no la hemos usado porque se envía por POST. Lo que sí hemos usado es la directiva @csrf. Todos los formularios deberían llevarla. Impide los ataques por CSRF, incrustado un token aleatorio en el formulario que Laravel se encargará de comprobar cuando los datos del formulario regresen al servidor. No te preocupes si no entiendes bien como funciona, por Laravel se encarga de hacerlo todo. Tú solo tienes que colocar la directiva @csrf en todos tus formularios. En el enrutador, definiremos la ruta “mi-ruta” del action del formulario: . Route::post('mi-ruta', [MyController::class, 'store']); . Y, en el controlador MyController.php, creamos el método store(). Observa cómo recuperamos los datos del formulario a través de la variable $r: . use Illuminate\\Support\\Facades\\Request; ... public function store(Request $r) { $email = $r-&gt;get(\"email\"); $asunto = $r-&gt;get(\"asunto\"); ...etc... } . 2.7.11. Validación de formularios con Blade . Otra cosa que Blade facilita muchísimo es la validación de formularios en el lado del servidor. Aquí toca hacer un paréntesis para responder a esta pregunta: ¿dónde deberían validarse los formularios? ¿En el cliente (con HTML y Javascript) o en el servidor (con PHP y Laravel)? . La respuesta es: en los dos sitios. Sobre todo si es un formulario con información sensible. La validación en el cliente es más sencilla de hacer. Comprobar que un campo de texto de un formulario no se envía vacío, por ejemplo, es algo trivial con HTML. Y con Javascript es solo un poquito más complicado. Hacer esas comprobaciones en el servidor resulta más trabajoso: hay que recibir el formulario, comprobar los valores de los campos y, si hay un error, tenemos que volver a enviar el formulario, pero respetando los datos que el usuario ya hubiera tecleado, todo ello junto con un mensaje informando del error. Sí, en el servidor es más complicado. Pero también más seguro. Las validaciones en el cliente pueden desactivarse (puedo usar un navegador antiguo para evitar las comprobaciones por HTML, y puedo deshabilitar temporalmente el motor de Javascript), así que son una primera barrera defensiva muy convieniente pero poco segura. Las comprobaciones en el servidor son imposibles de saltar para un atacante. Así que deberíamos hacer los dos conjuntos de comprobaciones en todos nuestros formularios. Y aquí es donde Laravel nos ayuda. Vamos a retomar la vista del ejemplo anterior y a modificar el formulario para que se valide en el servidor. Tendríamos que añadirle algunas cositas: . &lt;form method=\"POST\" action=\"{{ route('mi-ruta') }}\"&gt; @if ($errors-&gt;any()) @foreach ($errors-&gt;all() as $error) {{ $error }}&lt;br&gt; @endforeach @endif &lt;input type=\"email\" name=\"email\"&gt;&lt;br&gt; ...resto del formulario igual... &lt;/form&gt; . Fíjate en cómo mostramos los errores -si los hay- con un bucle. El objeto $errors (disponible en todas las vistas) tiene muchos más métodos útiles que puedes consultar en la documentación de Laravel. Y el controlador quedaría así. Observa cómo definimos varias reglas de validación para campos del formulario: . public function store() { $validated = $request-&gt;validate([ 'email' =&gt; ['required','email'], 'asunto' =&gt; ['required','string'] ]); // A partir de aquí, procesar el formulario igual que antes . Puedes consultar todas las reglas de validación admitidas en https://laravel.com/docs/validation. Cuando vuelve a cargarse el formulario que contenía un error, suele ser apropiado hacerlo con los datos que el usuario ya había tecleado. A esto se le llama “repopular” el formulario, y con Blade se hace así (observa el atributo value del campo email): . &lt;form method=\"POST\" action=\"{{ route('mi-ruta') }}\"&gt; @if ($errors-&gt;any()) @foreach ($errors-&gt;all() as $error) {{ $error }}&lt;br&gt; @endforeach @endif &lt;input type=\"email\" name=\"email\" value=\"{{ old('email') }}\"&gt;&lt;br&gt; ...resto del formulario igual... &lt;/form&gt; . 2.7.12. Añadir CSS y Javascript a nuestras vistas . Laravel ya trae dos archivos (app.css y app.js) basados en Bootstrap para empezar a trabajar. Para usarlos, basta con añadir esto a la cabecera de nuestras vistas: . @vite(['resources/css/app.css', 'resources/js/app.js']) . Si queremos añadir reglas CSS, NO debemos editar /public/app.css, porque es un CSS compilado y minimizado con SASS. Lo correcto para añadir nuestro CSS a ese archivo es: . | Editar /resources/sass/app.css o /resources/sass/app.js. Como alternativa, podemos crear nuestros propios archivos .css y .js en /resources/sass y enlazarlos con @vite en la cabecera de nuestras vistas. | Compilar los archivos .css y .js con SASS. | . Esa compilación la lanzará Vite por nosotro (Vite es la herramienta de Laravel para empaquetar elementos del frontend). Para lanzar la compilación, usaremos npm (el gestor de dependencias de Node.js, es decir, que npm es a Javascript lo que composer es a PHP), que se encargará de lanzar Vite: . $ npm run dev # en entornos de desarrollo $ npm run build # en producción . Si no tienes ni idea de lo que estamos hablando con esto de less, SASS y demás zarandajas, tienes dos opciones: o te empapas un poco de ello antes de continuar (lamentablemente, en este manual no tenemos espacio para verlo TODO), o te olvidas de ellos y colocas tu CSS y tu Javascript en un directorio púbico sin compilar ni nada. Para lograr esto último, simplemente, guarda tu CSS y tu Javascript en el directorio /public de Laravel. En ese caso, los archivos no estarían optimizados (tendríamos que optimizarlos a mano, si queremos) y serían accesibles de forma pública. Pero es una solución lo suficientemente buena para empezar. Un consejo: si vas a colocar tu CSS y tu Javascript en /public, al menos crea subcarpetas para organizarlo un poco. Por ejemplo, /public/css y /public/js. 2.7.13. Vistas de error personalizadas . Por último, te menciono un pequeño truco para darle a tu aplicación un toque más profesional: personalizar las vistas de error. Simplemente, crea una carpeta /resources/views/errors. Todas las vistas que metas ahí dentro se considerarán pantallas de error. Ahora solo tienes que ponerles los nombres adecuados. Por ejemplo, si creas un archivo llamado /resources/views/errors/404.blade.php, esa vista se mostrará cada vez que ocurra un error 404 (página no encontrada). Fácil, ¿no? . ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/vistas-blade.html#27-vistas-y-plantillas-con-blade",
    "relUrl": "/laravel/vistas-blade.html#27-vistas-y-plantillas-con-blade"
  },"74": {
    "doc": "2.7 Vistas y plantillas con Blade",
    "title": "2.7 Vistas y plantillas con Blade",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/vistas-blade.html",
    "relUrl": "/laravel/vistas-blade.html"
  },"75": {
    "doc": "2.8 Controladores",
    "title": "2.8. Controladores",
    "content": ". | 2.8.1. Cuatro cosas importantes sobre los controladores en Laravel | 2.8.2. Tres formas de crear un controlador | 2.8.3. Buenas prácticas de programación de controladores | . Los controladores son un elemento clave de la arquitectura MVC. En Laravel, los controladores funcionan exactamente igual que en las aplicaciones MVC hechas con PHP clásico. Es decir: son los puntos de entrada a la aplicación desde el enrutador. Los controladores deberían permanecer lo más sencillos posible: nada de accesos a la base de datos ni de generación de HTML. Esas acciones se derivarán a los modelos y las vistas. El controlador es un organizador del flujo de la aplicación: decide qué componente tiene que trabajar y el orden en el que lo debe hacer. En esta sección, vamos a aprender a construir controladores con Laravel. Vas a ver que es algo extremadamente sencillo. 2.8.1. Cuatro cosas importantes sobre los controladores en Laravel . | Los controladores en Laravel siempre heredan de la clase Controller o de una subclase de Controller. class MiControlador extends Controller { ... } . | Su nombre debería escribirse en singular, CamelCase y terminando en la palabra Controller. Por ejemplo: UserController, LoginController, ArticleController… . | Cada método del controlador debe terminar en un return. Lo que el método devuelva será convertido automáticamente en una HTTP response 200, es decir, en una respuesta válida http, excepto si es un array, en cuyo caso Laravel lo convertirá automáticamente en JSON (perfecto para responder a peticiones Ajax, como veremos más adelante). | Si lo necesitas, puedes actuar sobre la HTTP response devolviendo algo como esto: . return response('contenido', 201) -&gt;header('mi-cabecera', 'contenido') -&gt;header('otra-cabecera', 'más-contenido') -&gt;cookie('mi-cookie', 'valor'); (etc) . (Pero no nos engañemos: no lo necesitarás hacer demasiado a menudo). | . 2.8.2. Tres formas de crear un controlador . Los controladores se pueden crear a mano: vas al directorio /app/http/controllers, creas allí un archivo vacío y empiezas a escribir código como una fiera. Pero nadie lo hace así porque Artisan ya crea el esqueleto del archivo por ti. Así que es mejor que vayas a lo práctico: abre una consola en tu servidor web y ponte a escribir. Forma 1. Crear un controlador vacío. Por ejemplo, para crear un controlador para la tabla de usuarios: . $ php artisan make:controller UserController . Forma 2. Crear un controlador de tipo resource. Estos controladores se generan automáticamente con un andamiaje para construir recursos REST. Es decir, la clase ya llevará incorporados los métodos index(), create(), store(), show(), edit(), update() y destroy() del estándar REST. (Si no sabes de qué estamos hablando, revisa la sección que dedicamos al enrutamiento en Laravel) . Para crear un controlador RESTful: . $ php artisan make:controller UserController --resource . No te olvides de añadir al enrutador (/routes/web.php) las rutas REST para este tipo controlador. Te recuerdo que se pueden resumir las siete rutas en esta sola entrada del enrutador: . Route::resource('nombreRecurso', RecursoController::class); . En nuestro ejemplo: . Route::resource('usuarios', UserController::class); . Forma 3. Crear un controlador tipo API. Una API (Application Programming Interface) es un interfaz entre programas. Es decir, es la forma en la que unos programas interaccionan con otros. Algunas aplicaciones web se diseñan para que otros programas las utilicen, no para que las utilicen seres humanos. En estos casos, el interfaz de usuario no existe (o es mínimo) y lo importante es el API. Y los métodos del controlador no devuelven vistas, sino datos formateados en JSON. Se puede construir con Laravel un controlador tipo API de forma muy simple, porque es parecido a un resource, pero sin create() ni edit(), porque una API no necesita mostrar los formularios de inserción/modificación. $ php artisan make:controller UserController --api . De nuevo, no te olvides de las entradas en el enrutador. Puedes englobarlas todas en una sola entrada con este aspecto: . Route::apiResource('usuarios', UserController::class); . 2.8.3. Buenas prácticas de programación de controladores . | Usa namespacings en el archivo de rutas para referirte a los controladores. /routes/web.php . use App\\Htpp\\Controllers\\UserController; . Y también usa namespacing en los controladores. /app/Http/controllers/MyController.php . namespace App\\Http\\Controllers; . | Si el método del controlador recibe datos, recupéralos así: . use Illuminate\\Http\\Request; ... public function store(Request $request) { ... } . | Usa nombres estándar para los métodos del controlador: index(), store(), edit(), etc. Sobre todo si estás construyendo un API estándar (ver tema siguiente). | . ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/controladores.html#28-controladores",
    "relUrl": "/laravel/controladores.html#28-controladores"
  },"76": {
    "doc": "2.8 Controladores",
    "title": "2.8 Controladores",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/controladores.html",
    "relUrl": "/laravel/controladores.html"
  },"77": {
    "doc": "2.9 Migraciones",
    "title": "2.9. Migraciones",
    "content": ". | 2.9.1. Crear tablas mediante las migraciones | 2.9.2. Modificar tablas mediante migraciones | 2.9.3. Otras operaciones en las migraciones | 2.9.4. Seeding | 2.9.5. Faker: rellenar las tablas con datos realistas | 2.9.6. Automatizar el seeding | 2.9.7. Chuleta de comandos habituales | . Las migraciones constituyen una especie de control de versiones para la base de datos de la aplicación, puesto que permiten: . | Crear y modificar tablas de la BD con independencia del SGBD que estemos usando y sin usar SQL. | Controlar la versión de la base de datos, puesto que cada migración es como un commit. | Desplegar la base de datos en otros servidores y dejarla exactamente en el estado que se corresponde con el código. | . Con las migraciones, por tanto, no solo podrás reconstruir la base de datos en menos de lo que tarda en decirse “Von Neumann” (algo muy práctico cuando estás en fase de desarrollo y detrozas las tablas cada dos por tres), sino que podrás parchearla en producción en un tiempo record y con riesgo cero. (Solo el que ha tenido que parchear la base de datos de una aplicación en producción antes de la existencia de las migraciones sabe la tranquilidad de espíritu que esto produce y la cantidad de problemas embarazosos que te quita de encima). Antes de empezar, recuerda que, para que cualquier operación sobre la base de datos funcione, debes tener bien configurado el archivo .env: . DB_HOST=localhost DB_DATABASE=mi-base-de-datos DB_USERNAME=mi-usuario-de-BD DB_PASSWORD=mi-password-de-BD . 2.9.1. Crear tablas mediante las migraciones . La primera cosa para las que sirven las migraciones es para crear las tablas de tu aplicación. Olvídate de exportar e importar a mano el archivo SQL de tu base de datos. Eso lo hacían los cromañones. Vamos a trabajar con un ejemplo, como siempre. Imagina que tenemos una tabla llamada Clients con los campos típicos: id, name, address, etc. De acuerdo. Creemos, paso a paso, las migraciones de esta tabla: . Paso 1: Inicializar el sistema de migraciones de Laravel (¡no es necesario en versiones modernas de Laravel!). Si ya lo hemos hecho antes, nos dará un error al intentar hacerlo otra vez: . $ php artisan migrate:install . Paso 2: Crear la migración para la tabla Clients: . $ php artisan make:migration create_clients_table . Esto generará un fichero en la carpeta /database/migrations cuyo nombre contendrá un timestamp o marca de tiempo. Vamos, que contendrá un numerajo con la fecha y hora actual. Algo tan bonito como /database/migrations/2025_12_26_072434_create_clients_table.php . Si editas ese fichero, verás dos métodos: . | up() → se ejecuta cuando se lanza la migración. Se encarga de crear la tabla en la base de datos. | down() → se ejecuta cuando se cancela la migración. Se encarga de eliminar la tabla de la base de datos. | . Paso 3: Editar el fichero /database/migrations/2025_12_26_072434_create_clients_table.php: . En el método up() tienes que indicar las columnas que tendrá la tabla. Por ejemplo: . public function up() { Schema::create('users', function (Blueprint $table) { $table-&gt;id(); // PRIMARY KEY UNSIGNED BIGINT AUTOINCREMENT $table-&gt;string('name',75)-&gt;unique(); // VARCHAR $table-&gt;text('address')-&gt;nullable(); // TEXT $table-&gt;integer('level'); // INT $table-&gt;date('birth_date'); // DATE // La siguiente línea crea campos created_at y updated_at $table-&gt;timestamps(); }); } public function down() { Schema::drop('users'); } . Paso 4: Lanzar las migraciones. $ php artisan migrate . Esto creará las tablas que no se hayan creado aún. Es decir, si una migración ya se ha lanzado con anterioridad, no se vuelve a ejecutar para no perder los datos que pudieran existir en esas tablas. Paso 5: Revertir las migraciones (si es necesario) . Si necesitas revertir la última migración, es decir, dehacer el último commit: . $ php artisan migrate:rollback . O puedes indicar cuántas migraciones quieres deshacer con step = n. Por ejemplo, para deshacer las 3 últimas: . $ php artisan migrate:rollback --step=3 . Durante el desarrollo, es útil hacer retroceder la BD a su estado original: . $ php artisan migrate:refresh . ¡Cuidado! Estas acciones son destructivas. Pero, por supuesto, hay una forma de modificar una tabla sin borrarla y volver a crearla. Es lo que vamos a hacer a continuación. 2.9.2. Modificar tablas mediante migraciones . Si necesitas modificar una tabla que ya existe (por ejemplo, para añadir o eliminar campos), tienes dos opciones: . | Modificar la migración original (en la que se crea la tabla) para añadir o eliminar el campo afectado. Esto te obligará a lanzar la migración de nuevo y, por lo tanto, la tabla se reconstruirá y todos los datos que pudiera contener se perderán. | Crear una nueva migración en la que únicamente se haga la modificación de la tabla, sin tocar el resto. Esto respetará los datos que la tabla ya pudiera contener. | . Como es lógico, la opción 2 será la que preferiremos si la aplicación ya está en producción y necesitamos modificar la estructura de la base de datos. En cambio, durante el desarrollo, puede ser más simple utilizar la opción 1. Supongamos que queremos añadir un campo email a la tabla Clients del apartado anterior. Si optas por la opción 2, es decir, por crear una nueva migración que se encargue de hacer esa modificación en la tabla sin alterar sus datos, la forma de proceder es la siguiente: . Paso 1. Crear la migración: . $ php artisan make:migration add_email_to_clients --table=clients . (Nota: puedes asignar el nombre que quieras a las migraciones, pero Laravel aconseja utilizar las convenciones que ves en estos ejemplos para simplificarnos la vida) . Paso 2: Editar la migración /database/migration/add_email_to_clients.php para añadir, en el método up(), el campo nuevo; y, en el método down(), especificaremos qué hay que hacer en caso de que se fuerce un rollback de esta migración: . public function up() { Schema::table('clients', function (Blueprint $table) { $table-&gt;string('email')-&gt;after('address'); }); } public function down() { Schema::table('clients', function (Blueprint $table) { $table-&gt;dropColumn('email'); }); } . 2.9.3. Otras operaciones en las migraciones . Las migraciones pueden usarse para cualquier otra operación sobre la estructura de la base de datos, como: . | Cambiar tipos de columnas. | Cambiar atributos de columnas (null, unique, default…) | Cambiar o asignar claves primarias y ajenas. | . Las migraciones construídas de este modo nos permitirán reproducir la base de datos en cualquier servidor o actualizarla en cualquier momento sobre una aplicación en producción sin necesidad de programar parches o exportar la BD a un archivo SQL para importarlo en otro servidor. Como te dije al principio, solo el que ha hecho alguna vez alguna de estas cosas a mano sabe la cantidad de trabajo que las migraciones ahorran en el mantenimiento de una aplicación y la asombrosa cantidad de errores embarazosos que evita. Más info en: https://laravel.com/docs/migrations . 2.9.4. Seeding . El seeding es una técnica adicional a la de las migraciones que permite cargar con datos las tablas de la base de datos. Es muy práctico en estos supuestos: . | Si quieres tener un conjunto de datos de prueba en tu base de datos de desarrollo, esa que destrozas periódicamente cuando haces pruebas. Con un solo comando, tendrás la base de datos reconstruída después de cada destrozo. | Si necesitas cargar algunos datos mínimos en algunas tablas para que la aplicación, una vez desplegada en un servidor de producción, funcione (por ejemplo, para crear un usuario administrador en la tabla Users o para crear algunas entradas en una tabla Options). | . Para crear un seeder (por ejemplo, para la tabla users), sigue estos pasos: . Paso 1. Ejecuta el comando: . $ php artisan make:seeder UsersSeeder . Paso 2. Edita el archivo /database/seeders/UsersSeeder.php y añade algo como esto al método up() (por supuesto, modifica el código para adaptarlo a tu tabla y a tus datos): . public function run() { User::truncate(); // Opativo: vacía la tabla antes de rellenarla de nuevo User::create([ 'name' =&gt; 'Stephen Falken', 'address' =&gt; 'Oregon 97, Goose Island', 'email' =&gt; 'sfalken@norad.com', 'birth_date' =&gt; '1932-09-03', ]); User::create([ 'name' =&gt; 'Jennifer Mack', 'address' =&gt; 'Richmond Av 3385, Seattle', 'email' =&gt; 'jenmack876@gmail.com', 'birth_date' =&gt; '1967-01-28', ]); } . Paso 3. Ejecuta este comando para lanzar el seeder y que los datos se carguen en tu tabla: . $ php artisan db:seed --class=UsersSeeder . Esto cargará solo dos registros en la tabla users. Si quieres más, solo tienes que crear nuevas líneas insert() en el método up(). 2.9.5. Faker: rellenar las tablas con datos realistas . Con Laravel también podemos rellenar las tablas con datos de prueba o ejemplo falsos pero que parezcan realistas, gracias a Faker, una librería externa de PHP que se instala con Laravel, creada precisamente para esto. Lo vemos con un ejemplo. Supongamos que quieres rellenar la tabla user con 100 registros de prueba realistas. Lo único que tienes que hacer es: . Paso 1. Crear el seeder para la tabla users (si no lo habías hecho ya): . $ php artisan make:seeder UsersSeeder . Paso 2. Editar el seeder (/database/seeders/UsersSeeder.php) para añadir la creación de datos con Faker. Por ejemplo, para 100 registros: . public function run() { $faker = Faker::create('en_US'); // Cambiar por 'es_ES' para español for ($i = 0; $i &lt; 100; $i++) { User::create([ 'name' =&gt; $faker-&gt;name, 'address' =&gt; $faker-&gt;address, 'email' =&gt; $faker-&gt;unique()-&gt;safeEmail, 'birth_date' =&gt; $faker-&gt;date('Y-m-d', '2010-01-01'), // genera fechas de nacimiento hasta 2010 'created_at' =&gt; now(), 'updated_at' =&gt; now(), ]); } } . Paso 3. No olvides lanzar el seeder: . $ php artisan db:seed --class=UsersSeeder . Más información sobre Faker en https://fakerphp.org/ . 2.9.6. Automatizar el seeding . Lanzar los seeders de uno en uno puede ser muy tedioso. Puedes lanzar varios seeders con un solo comando si haces lo siguiente: . Paso 1. Edita el fichero /database/seeders/DatabaseSeeder.php . Paso 2. Añade a la función run() los seeders que quieras ejecutar automáticamente: . $this-&gt;call([ UsersSeeder::class, OtroSeeder::class, etc )]; . Paso 3. ¡Y listo! Al ejecutar el comando db:seed de Artisan, sin indicar la clase, se lanzarán todos los seeders que hayas añadido a run(). $ php artisan db:seed . 2.9.7. Chuleta de comandos habituales . Por último, te muestro un resumen con los comandos más útiles sobre migraciones y seeders para que puedas consultarlos cuando lo necesites: . | Lanzar todas las migraciones pendientes: . $ php artisan migrate . | Crear la migración para crear una tabla: . $ php artisan make:migration &lt;nombre&gt; --create=&lt;tabla&gt; . | Crear una migración para modificar una tabla ya existente: . $ php artisan make:migration &lt;nombre&gt; --table=&lt;tabla&gt; . | Retroceder un paso en todas las migraciones: . $ php artisan migrate:rollback . | Retroceder N pasos en todas las migraciones: . $ php artisan migrate:rollback --step=N . | Deshacer todas las migraciones que se hayan ejecutado hasta ahora (resetear la base de datos): . $ php artisan migrate:reset . | Resetear la base de datos y volver a reconstruirla lanzando todas las migraciones: . $ php artisan migrate:refresh . | Resetear la base de datos, reconstruirla y llenarla de datos con los seeders de DatabaseSeeder: . $ php artisan migrate:refresh --seed . | Eliminar todas las tablas y lanzar todas las migraciones de nuevo: . $ php artisan migrate:fresh . | Eliminar todas las tablas y lanzar todas las migraciones y todos los seeders de nuevo: . $ php artisan migrate:fresh --seed . | . ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/migraciones.html#29-migraciones",
    "relUrl": "/laravel/migraciones.html#29-migraciones"
  },"78": {
    "doc": "2.9 Migraciones",
    "title": "2.9 Migraciones",
    "content": " ",
    "url": "https://iescelia.org/docs/fullstack/_site/laravel/migraciones.html",
    "relUrl": "/laravel/migraciones.html"
  },"79": {
    "doc": "Apéndice 1. Sistemas de control de versiones. Git",
    "title": "Apéndice 1. Sistemas de control de versiones. Git",
    "content": ". | A1.1. Sistemas de control de versiones . | A1.1.1. ¿Qué es un sistema de control de versiones? | A1.1.2. ¿Cómo funcionan los sistemas de control de versiones? | . | A1.2. Git básico . | A1.2.1. Poniendo en marcha Git | A1.2.2. Creando un repositorio nuevo | . | A1.3. Trabajo básico con Git . | A1.3.1. Un momento… ¿Staging quéeee? | A1.3.2. Hacer commit | A1.3.3. Subir el commit: hacer push | A1.3.4. Bajar la última versión del código: hacer pull | A1.3.5. Resumiéndolo todo: flujo de trabajo habitual con git | . | A1.4. Algunas cosillas avanzadas sobre git . | A1.4.1. Regreso al pasado: cómo revertir los cambios | A1.4.2. Cuando dos personas se encaprichan del mismo archivo | A1.4.3. Proyectos que se complican: cómo crear ramas | A1.4.4. ¿Aún quieres saber más? | . | . ",
    "url": "https://iescelia.org/docs/fullstack/_site/scv-git/",
    "relUrl": "/scv-git/"
  },"80": {
    "doc": "Apéndice 1. Sistemas de control de versiones. Git",
    "title": "A1.1. Sistemas de control de versiones",
    "content": "Es inconcebible que un desarrollador trabaje en la actualidad sin un sistema de control de versiones. Fíjate que en la frase anterior no tiene cabida tu opinión. Lo siento, pero es lo que hay. No importa si te gustan estos sistemas o no. No importa si estás los usas de forma habitual o siempre has huido de ellos como de la peste. No importa si ni siquiera sabes qué son o cómo funcionan. Si quieres dedicarte profesionalmente al desarrollo de software, tienes que conocerlos porque te los vas a encontrar vayas donde vayas. ",
    "url": "https://iescelia.org/docs/fullstack/_site/scv-git/#a11-sistemas-de-control-de-versiones",
    "relUrl": "/scv-git/#a11-sistemas-de-control-de-versiones"
  },"81": {
    "doc": "Apéndice 1. Sistemas de control de versiones. Git",
    "title": "A1.1.1. ¿Qué es un sistema de control de versiones?",
    "content": "Un sistema de control de versiones es un almacén en la nube pensado para equipos de desarrollo de software. Es decir, como Google Drive, pero a lo bestia. El sistema de control de versiones no solo sirve para que un puñado de usuarios (entre uno y miles) suban su código fuente a la nube para ponerlo a salvo de posibles problemas con las máquinas locales, sino que, además, permite: . | Conservar absolutamente todo el historial de versiones previas. | Documentar cada cambio, de manera que siempre sea posible saber quién, cómo, dónde, cuándo y por qué escribió cada línea de código. | Revertir el software a un estado anterior en cualquier momento. | Crear ramas o “estados alternativos” del software, que luego podrán fusionarse con otras ramas o abandonarse sin llegar a nada. | Crear “forks” o réplicas del sistema que luego podrán evolucionar de forma independiente (o volver a fusionarse con el contenido original). | Evitar conflictos cuando el mismo código fuente ha sido editado simultánemente por dos personas. Y, en caso de que estos conflictos ocurran, ayudar a resolverlos. | . Se trata de un buen puñado de funciones, ¿verdad? Ese es el motivo por el que absolutamente todas las organizaciones serias que se dedican a desarrollar software utilizan algún sistema de control de versiones. Pero es que incluso para un programador/a solitario, que trabaja de forma autónoma, las ventajas de usar uno de estos sistemas superan de lejos a los inconvenientes, porque… espera un momento… ¡Resulta que no tienen ningún inconveniente! . Así que ya lo sabes: si aún no los usas, este es el momento de hacer un esfuerzo e incorporar un sistema de control de versiones a tu vida. ",
    "url": "https://iescelia.org/docs/fullstack/_site/scv-git/#a111-qu%C3%A9-es-un-sistema-de-control-de-versiones",
    "relUrl": "/scv-git/#a111-qué-es-un-sistema-de-control-de-versiones"
  },"82": {
    "doc": "Apéndice 1. Sistemas de control de versiones. Git",
    "title": "A1.1.2. ¿Cómo funcionan los sistemas de control de versiones?",
    "content": "Existen muchos sistemas de control de versiones, aunque el mercado está dominado por unos pocos de ellos: CVS, Subversion, Mercurial, Bazaar y, sobre todo, Git. Cada uno tiene sus propias peculiaridades, pero suelen compartir varias características comunes: . | El código fuente del proyecto (y todas sus versiones previas) se guarda en uno o varios servidores. Esa colección de código fuente se denomina repositorio. El servidor puede estar en Internet y pertenecer a una compañía externa. También puede estar en nuestra intranet, instalado en una de nuestras máquinas. O puede estar en nuestro propio ordenador. | Los repositorios pueden ser remotos (si están en otra máquina distinta de la nuestra) o locales (si están en nuestra máquina). | Siempre se trabaja sobre el repositorio local. Cuando una funcionalidad del código se termina, el código fuente modificado se sube al repositorio remoto, para que el resto de miembros del equipo puedan disponer de él. | Si otra persona del equipo ha modificado los mismos archivos fuente que nosotros, el sistema de control de versiones nos avisará del conflicto durante la sincronización y nos obligará a hacer manualmente una fusión de los archivos afectados, mostrándonos las diferentes versiones del mismo, antes de completar la sincronización. | . La sincronización con el repositorio remoto, por lo tanto, no puede ser automática (como en Google Drive o Dropbox), sino que hemos de hacerla explícita, momento en el cual el sistema nos avisará de posibles conflictos. Esta es la única manera de resolver adecuadamente esos conflictos en proyectos donde haya mucha gente trabajando simultáneamente. ",
    "url": "https://iescelia.org/docs/fullstack/_site/scv-git/#a112-c%C3%B3mo-funcionan-los-sistemas-de-control-de-versiones",
    "relUrl": "/scv-git/#a112-cómo-funcionan-los-sistemas-de-control-de-versiones"
  },"83": {
    "doc": "Apéndice 1. Sistemas de control de versiones. Git",
    "title": "A1.2. Git básico",
    "content": "Git es, en la actualidad, el sistema de control de versiones más utilizado del mundo con diferencia. También es uno de los más completos y complejos. Así que, si aprendes a utilizar Git, podrás apañártelas con cualquier otro sistema de control de versiones. En esta sección vamos a ver cómo se usa Git a nivel básico. El acceso a las funciones avanzadas irá viniendo solo, con el tiempo y el uso. ",
    "url": "https://iescelia.org/docs/fullstack/_site/scv-git/#a12-git-b%C3%A1sico",
    "relUrl": "/scv-git/#a12-git-básico"
  },"84": {
    "doc": "Apéndice 1. Sistemas de control de versiones. Git",
    "title": "A1.2.1. Poniendo en marcha Git",
    "content": "Git es un sistema de control de versiones que se creó inicialmente para desarrollar el núcleo de Linux. Es de código abierto (opensource). Eso quiere decir que cualquiera puede coger el código, modificarlo, adaptalo y distribuirlo. Por eso encontrarás multitud de implementaciones de Git, así como muchos servidores y clientes que lo usan. Todos son compatibles entre sí. Git crea repositorios locales y remotos que hay que mantener sincronizados manualmente. Para usar Git, necesitas al menos: . | Instalar un cliente de Git en tu ordenador de trabajo. | Instalar un servidor de Git en el ordenador donde vayas a alojar el repositorio remoto. | . Para el servidor Git, mucha gente utiliza servidores gratuitos disponibles en Internet. Los más conocidos de ellos son GitHub y GitLab. Son sitios web donde te registras y ¡voilà!, ya tienes disponible un servidor Git en línea para que funcione de repositorio remoto. Además, estos sitios proporcionan características adicionales muy convenientes, como sistemas de gestión de issues o tareas pendientes, gestión de proyectos, estadísticas, evaluación de la calidad de software, etc. También funcionan como redes sociales para desarrolladores. En fin, que, salvo que seas un paranoico de la seguridad o estés desarrollando código ultrasecreto para la NSA o el CSIF, usar GitHub o GitLab como repositorio remoto es la opción más interesante. Así que ya puedes dejar de leer esto y registrarte ahora mismo en alguno de los dos. ¿Ya estás de regreso? Vale, ahora tienes que instalarte en tu ordenador un cliente Git. Clientes Git hay muchos, algunos más bonitos que otros. Yo te recomiendo el cliente básico en modo texto, con el que tendrás que salirte a la consola y teclear comandos. Teclear comandos incomprensibles de forma rápida y segura siempre queda muy bien para presumir. Aparte de eso, aprenderse los comandos básicos de Git te salvará la vida en algún momento de tu futuro profesional, te lo aseguro, así que es una buena inversión de tiempo. Puedes encontrar los clientes oficiales de Git en la web del proyecto: https://git-scm.com/ . Cuando hayas aprendido a apañarte con los comandos, es posible que te gusten tanto que ya no quieras recurrir a los clientes gráficos. Pero, por si acaso no es así, te comento que existen mogollón de ellos que te permitirán sincronizar tus archivos con un solo clic y resolver conflictos de forma rápida y muy visual. Algunos de ellos son: GitHub Desktop (ofrecido por GitHub), GitKraken, Git Cola o Tortoise Git. Por último, ten en cuenta que todos los entornos de desarrollo medianamente potentes ofrecen una integración absoluta con Git. Es decir, que si usas Visual Studio Code, Eclipse, NetBeans o muchos otros, no necesitarás ningún cliente git adicional, porque ya lo traen incorporado. Tan solo debes configurar la ruta el repositorio remoto y al local, y hala, a programar y a sincronizar como si no hubiera un mañana. ",
    "url": "https://iescelia.org/docs/fullstack/_site/scv-git/#a121-poniendo-en-marcha-git",
    "relUrl": "/scv-git/#a121-poniendo-en-marcha-git"
  },"85": {
    "doc": "Apéndice 1. Sistemas de control de versiones. Git",
    "title": "A1.2.2. Creando un repositorio nuevo",
    "content": "Bien, pues ya tenemos nuestra cuenta en GitHub o GitLab y hemos instalado un cliente Git en nuestra máquina. ¿Ahora qué? . Podemos encontrarnos ante dos escenarios diferentes: . | Voy a empezar un proyecto nuevo y quiero inicializar un repositorio en blanco. | Ya tengo mi código fuente (todo o una parte) escrito y quiero añadirlo a un repositorio git. | . Vamos a ver cómo proceder en cada caso. Lo haremos mostrando cómo se usa el cliente git de línea de comando. Desde los clientes gráficos, el proceso será parecido, pero tendrás que trastear con el cliente en cuestión o leerte su documentación para ver los detalles. Caso 1: Voy a empezar un proyecto nuevo y quiero inicializar un repositorio en blanco. | Abre un terminal de línea de comandos y muévete al directorio o carpeta donde tienes pensado crear tu código fuente. Usa para ello los comandos cd carpeta (para cambiar de carpeta) o mk carpeta (para crear una carpeta nueva). | Para crear un repositorio git local en la carpeta elegida, simplemente teclea este comando: . $ git init . | Para conectar este repositorio local con un repositorio remoto en GitHub o GitLab, escribe a continuación este comando: . $ git remote add origin &lt;URI&gt; . Sustituye “URI” por la dirección de tu repositorio que te habrá proporcionado GitHub o GitLab. Por ejemplo, en GitHub, una URI de repositorio tiene un aspecto como este: https://github.com/usuario/nombre-repositorio.git). Obviamente, el repositorio remoto deberías haberlo creado antes desde la web de GitHub o GitLab. | . Eso es todo. A partir de ahora, podrás empezar a desarrollar tu código en local y a sincronizar tus archivos con el repositorio remoto cada vez que lo necesites. El procedimiento para hacer esto último lo describimos un poco más adelante. Caso 2: Ya tengo mi código fuente y quiero añadirlo a un repositorio git . Este caso es un poquito más complejo, pero tampoco mucho. Asegúrate de tener ya creado un repositorio (vacío) en GitHub o GitLab antes de seguir esta guía. | Abre un terminal de línea de comandos y muévete a la carpeta donde tengas tu código fuente. Usa para ello el comando cd carpeta. | Para crear un repositorio git local en esa carpeta, simplemente teclea este comando: . $ git init . | Para conectar este repositorio local con un repositorio remoto en GitHub o GitLab, escribe esto: . $ git remote add origin &lt;URI&gt; . Sustituye “URI” por la dirección de tu repositorio que te habrá proporcionado GitHub o GitLab. Por ejemplo, en GitHub, una URI de repositorio tiene un aspecto como este: https://github.com/usuario/nombre-repositorio.git) . | Edita el archivo .gitignore para incluir en él los archivos y carpetas que no quieres incluir en el repositorio. Más adelante hablaremos del archivo .gitignore con más detalle, porque es muy importante. | Haz tu primer commit para añadir todo el código fuente que ya tienes: . $ git add * $ git commit -m \"Primer commit con todo el código preexistente\" . | Sube el código de ese commit a tu repositorio remoto (te pedirá tu usuario y contraseña en GitHub o GitLab): . $ git push . | . Si ahora entras en tu perfil de GitHub o GitLab, verás que el repositorio remoto ya contiene todos los archivos que tenías en tu proyecto (excepto los que señalaste en .gitignore). Los repositorios local y remoto ya están creados y puedes empezar a trabajar con normalidad, escribiendo código y subiéndolo al repositorio remoto cuando lo necesites. Este proceso lo describiremos en detalle enseguida. Si no has entendido alguno de estos pasos, no te agobies. Enseguida te quedarán más claros. Más cosas sobre la inicialización de un repositorio . Hay otro par de cosas que te interesa hacer al iniciarlizar un repositorio. Solo tendrás que hacerlo una vez y, después, tu repositorio lo recordará. Después del git init, puedes indicarle al repositorio qué usuario de GitHub o GitLab va a realizar los commits. Esto se hace así: . $ git --config user.name \"Mi-nombre-de-usuario\" $ git --config user.email \"Mi-email\" . Para comprobar que la información es correcta, simplemente teclea: . $ git --config list . ¡Antes de continuar! No te olvides de .gitignore . Una última cosita antes de describir cómo es el trabajo cotidiano con git y qué significa todo eso de los commits. Esa cosita es sobre el archivo .gitignore. Es un archivo muy importante que debería estar en el directorio raíz de tu proyecto. Si no existe, créalo. Ten en cuenta que en los sistemas GNU/Linux y Mac, los archivos cuyo nombre empiezan por un punto se consideran ocultos, por lo que es posible que el archivo esté ahí sin que lo veas. Ese archivo contiene una lista de todas las cosas que no se deben subir al repositorio remoto. Esto incluye, entre otros: . | Los archivos de configuración. Es habitual en una aplicación web tener un archivo de configuración (llamado config.php o algo parecido) con un puñado de variables donde se guarda el host de la base de datos, el usuario y la contraseña para ese host, el nombre de la base de datos, etc. Y, vamos a ver, ¿de verdad quieres que cualquiera que acceda a tu repositorio de GitHub o GitLab vea esa información? . Además del problema de seguridad que puede suponerte (sobre todo si, como el 99% de los desarrolladores, usas el acceso root a tu servidor local de bases de datos mientras estás desarrollando un nuevo proyecto), es que no tiene sentido subir esa información al repositorio remoto, porque será diferente en cada servidor donde la aplicación se ponga en producción. Lo que sí suele hacerse es crear un archivo de configuración de ejemplo (algo como config-example.php), donde se muestre la estructur que debe tener config.php pero se dejen en blanco los valores de las variables. Ese archivo sí que puede sincronizarse con el resto del código y subirse a GitHub o GitLab. | Archivos de recursos que no forman parte de la aplicación. Imagina que estás programando una aplicación web para una biblioteca. Esa aplicación usa algunas imágenes para construir sus vistas (por ejemplo, una hermosa fotografía de un libro antiguo para el encabezamiento). Esas imágenes sí forman parte de la aplicación y sí deben subirse al repositorio remoto. Pero ahora supón que, como es lógico, para probar la aplicación has creado un montón de libros falsos en tu base de datos local. Cada vez que añades un libro falso, le asignas una imagen de la portada (falsa también), que la aplicación almacenará en algún directorio del servidor local. Esas imágenes forman parte de los datos de prueba, no de la propia aplicación, y, por tanto no deberían subirse a GitHub ni GitLab. El directorio completo donde almacenes esas imagenes debería incluirse en .gitignore. Si no lo haces así, llenarás el repositorio remoto de basurilla y, además, harás que ocupe mucho más espacio del necesario, hasta el extremo que una clonación del repositorio puede tardar varias horas y ocupar muchos gigabytes. Ten en cuenta que el repositorio no solo contiene el estado actual del proyecto, sino también todos los estados anteriores, lo que incluye todas las imágenes de libros falsos que hayas podido añadir alguna vez durante el desarrollo. Esto no solo es aplicable a imágenes, sino a cualquier otro recurso que use la aplicación y que no forme parte de la propia aplicación: sonidos, fuentes tipográficas, vídeos, etc. | Bibliotecas de terceros. A menudo, recurrimos a bibliotecas de terceros para usarlas en nuestra aplicación. Incluir ese código en nuestro repositorio nos puede meter en un embrollo legal (mírate bien la licencia de uso de todas las bibliotecas que vayas a utilizar) y, además, nos puede hacer engordar innecesariamente el repositorio. Tendrás que valorar una a una si es conveniente incluir determinada librería o no. Las librerías no incluidas deberán ser instaladas manualmente cuando la aplicación se despliegue en un servidor, lo cual deberás explicar muy bien en la documentación. Por ejemplo, en el caso de Laravel, se aconseja no incluir la carpeta “vendor” en el repositorio remoto. Es decir, hay que añadir la carpeta “vendor” a .gitignore antes de la primera sincronización. En “vendor” se encuentran todas las librerías de terceros que usa Laravel. Entonces, para desplegar esta aplicación en un servidor, ¿de dónde sacamos todas esas librerías? Fácil: cuando despleguemos el código en un servidor, solo tendremos que ejecutar “composer update” en el directorio raíz de la aplicacion, y el propio composer se encargará de instalar las librerías que sean necesarias en las versiones más adecuadas para ese servidor. | . ",
    "url": "https://iescelia.org/docs/fullstack/_site/scv-git/#a122-creando-un-repositorio-nuevo",
    "relUrl": "/scv-git/#a122-creando-un-repositorio-nuevo"
  },"86": {
    "doc": "Apéndice 1. Sistemas de control de versiones. Git",
    "title": "A1.3. Trabajo básico con Git",
    "content": "Ya tenemos nuestros repositorios local y remoto inicializados y conectados, y el archivo .gitignore a punto. ¿Qué hacemos ahora? . Muy fácil: ponernos a trabajar como si git no existiera. Y luego, cuando des por finalizada una parte de la aplicación (un método, una clase, una funcionalidad concreta: tú decides cada cuánto tiempo haces esto), pasarla a la Staging Area. ",
    "url": "https://iescelia.org/docs/fullstack/_site/scv-git/#a13-trabajo-b%C3%A1sico-con-git",
    "relUrl": "/scv-git/#a13-trabajo-básico-con-git"
  },"87": {
    "doc": "Apéndice 1. Sistemas de control de versiones. Git",
    "title": "A1.3.1. Un momento… ¿Staging quéeee?",
    "content": "La Staging Area es como la pista de despegue de Git. La idea es la siguiente: Git no quiere sincronizar tus archivos con el repositorio remoto de forma automática (como hacen las plataformas para el público general, como Google Drive o Dropbox), porque sabe que los programadores producimos mucha basura al cabo del día. Si cada vez que escribimos una basurilla, Git la sincronizara con el remoto, el resto de personas del proyecto estarían recibiendo nuestra basura de forma permanente. Y nosotros la de esas personas. Y esparcir basura no es una buena política. Así que Git quiere que seas muy consciente de cuándo deseas sincronizar algo, y de qué es lo que deseas sincronizar. Quiere que te tomes el trabajo (que tampoco es para tanto, la verdad) de emplear medio minuto de tu tiempo para decirle: “eh, Git, he estado currándome estos dos archivos esta mañana y creo que ahora ya no son una basura”. Para eso sirve la Staging Area. Tienes que pasar los archivos que ya no son una basura a la Staging Area. Y tienes que hacerlo tú, generalmente cuando hayas terminado una funcionalidad y la hayas probado adecuadamente. Lo bastante como para que no te avergüence que otras personas del equipo reciban tu código. Para añadir archivos a la Staging Area se usa el comando git add, así: . $ git add archivo1 archivo2 archivo3 ... Se pueden añadir carpetas completas: . $ git add carpeta1 carpeta2 ... Y también se pueden usar símbolos comodín, como el asterisco. De modo que, si estás muy, pero que muy seguro/a de que todos los archivos que han andado tocando desde el último commit están en un estado aceptable, puedes hacer esto para que git se encargue de añadir todos los archivos modificados recientemente a la Staging Area: . $ git add * . Por fin, cuando tengas una o varias cosas preparadas en la Staging Area… Bueno, entonces llega el momento de hacer un commit. ",
    "url": "https://iescelia.org/docs/fullstack/_site/scv-git/#a131-un-momento-staging-qu%C3%A9eee",
    "relUrl": "/scv-git/#a131-un-momento-staging-quéeee"
  },"88": {
    "doc": "Apéndice 1. Sistemas de control de versiones. Git",
    "title": "A1.3.2. Hacer commit",
    "content": "Un commit (palabra que podríamos traducir por “perpetrar”) consiste en empaquetar todos los cambios de la Staging Area para enviarlos a otro repositorio, normalmente el repositorio remoto. El decir, con el commit le decimos a Git: “quiero que prepares todo el código que te he puesto en la Staging Area a para enviarlo a GitHub” (o a dónde sea). Se puede hacer un commit por cada pequeña modificación que introducimos en la Staging Area, o se pueden preparar muchos archivos en la Staging Area y luego empaquetarlos en un único mega-commit. Eso lo decidís tú y tu equipo de desarrollo. Pero suele ser buena idea hacer commits de funcionalidades o tareas individuales. Es decir, si esta mañana he estado trabajando en dos funcionalidades, “Añadir usuarios nuevos” y “Modificar la vista de edición de usuarios”, es mejor que haga dos commits separados para cada una de esas funcionalidades. Esto es así porque, a cada commit, le tengo que añadir obligatoriamente un texto descriptivo donde indique qué cambios estoy subiendo con ese commit. El comando para hacer un commit es: . $ git commit -m \"Mensaje\" . Ahora saco mi bola de cristal y te digo: no tardarás ni una semana en empezar a hacer commits cuyo texto descriptivo será algo como “aslkdaslkjda”, “aaa”, “yoquésé”. Eso es una pésima idea. Antes o después, alguien del equipo meterá la pata, subirá un cambio indebido y todo el repositorio explotará. Entonces, intentaréis regresar a un estado en el que el código aún funcionaba, pero encontraréis que los últimos commits tienen explicaciones incomprensibles como “aslkdaslkjda”, “aaa” y “yoquésé”. Y sudaréis tinta para descubrir cuál fue el commit explosivo. Los commits deben llevar textos descriptivos breves pero informativos. Por ejemplo: “Arreglo el fallo del id de usuario inexistente al actualizar foto de perfil” o “Elimino el botón de modificar de la vista de libros”. Pero, ¡ojo!, hacer commit no sube los archivos al repositorio remoto. Todavía no. Recuerda que Git quiere que estés muy seguro/a de que subes lo que realmente tienes que subir, así que aún te falta un último paso: hacer push. ",
    "url": "https://iescelia.org/docs/fullstack/_site/scv-git/#a132-hacer-commit",
    "relUrl": "/scv-git/#a132-hacer-commit"
  },"89": {
    "doc": "Apéndice 1. Sistemas de control de versiones. Git",
    "title": "A1.3.3. Subir el commit: hacer push",
    "content": "El último paso para enviar nuestros cambios locales al repositorio remoto (típicamente, GitHub o GitLab) consiste en hacer push. Es decir, literalmente, “empujar” los cambios al repositorio remoto. La operación push enviará todos los commits que aún no se hayan enviado al repositorio remoto. A partir de ese momento, estarán disponibles para el resto de miembros del equipo. Pero solo a partir de ese momento. Para hacer push, basta con escribir: . $ git push . Lo normal es que el repositorio remoto te pida tu nombre de usuario y contraseña, pero eso dependerá de si el acceso a ese repositorio está autenticado o no. Por supuesto, tanto GitHub como GitLab te solicitarán que te identifiques. ",
    "url": "https://iescelia.org/docs/fullstack/_site/scv-git/#a133-subir-el-commit-hacer-push",
    "relUrl": "/scv-git/#a133-subir-el-commit-hacer-push"
  },"90": {
    "doc": "Apéndice 1. Sistemas de control de versiones. Git",
    "title": "A1.3.4. Bajar la última versión del código: hacer pull",
    "content": "Si podemos subir nuestros cambios al repositorio remoto, tendremos que tener una forma de bajar los cambios del resto de miembros del equipo, ¿verdad? . Por supuesto, existe un comando para ello. Es este: . $ git pull . Es recomendable hacer pull antes de hacer push, por si alguien ha tocado alguno de los archivos que nosotros pretendemos subir. En ese caso, Git nos avisará del conflicto y nos ayudará a resolverlo (más adelante veremos cómo). No podremos hacer push hasta resolver ese conflicto, para evitar pérdidas de código. ",
    "url": "https://iescelia.org/docs/fullstack/_site/scv-git/#a134-bajar-la-%C3%BAltima-versi%C3%B3n-del-c%C3%B3digo-hacer-pull",
    "relUrl": "/scv-git/#a134-bajar-la-última-versión-del-código-hacer-pull"
  },"91": {
    "doc": "Apéndice 1. Sistemas de control de versiones. Git",
    "title": "A1.3.5. Resumiéndolo todo: flujo de trabajo habitual con git",
    "content": "Si resumimos lo dicho hasta ahora, tenemos que, después de inicializar el repositorio (cosa que hay que hacer solo una vez), el trabajo cotidiano con Git consiste en: . | Desarrollar nuestra aplicación con normalidad, como si git no existiera. | Cuando terminamos de hacer algo, añadirlo a la Staging Area (git add). | Cada cierto tiempo, o cuando acabamos una funcionalidad, empaquetar todos los cambios que esperan en la Staging Area en un commit (git commit). | Bajarnos los commits del resto de miembros del equipo (git pull) | Subir nuestros commits al repositorio remoto (git push) | . Podemos verlo gráficamente en el siguiente esquema. Las tres primeras columnas (workspace, Staging Area y Local Repo) están en nuestro ordenador de trabajo. El repositorio remoto (Remote Repo) está en un servidor, como GitHub o GitLab. Workspace Staging area (INDEX) Local repo (HEAD) Remote repo | | | git add → | | | git commit → | | | | ← ← ← ← ← | ← ← ← ← ← | ← git pull | | | | git push → | | | | | . Un último apunte: te voy a chivar un comando muy útil de git cuando no estás muy seguro de qué archivos has estado tocando últimamente (¿a quién no le ha pasado eso? ¿Eh?). Este comando te resumirá el estado de tu repositorio local, indicándote qué archivos han sido modificados (pero no están en la Staging Area), qué archivos están preparados en la Staging Area (pero no en un commit) y, por supuesto, qué commits están hechos pero aún sin subir. Todo eso, gratis y tecleando este humilde comando: . $ git status . ¿Es potente o no es potente este Git? Pues aún no has visto nada. ",
    "url": "https://iescelia.org/docs/fullstack/_site/scv-git/#a135-resumi%C3%A9ndolo-todo-flujo-de-trabajo-habitual-con-git",
    "relUrl": "/scv-git/#a135-resumiéndolo-todo-flujo-de-trabajo-habitual-con-git"
  },"92": {
    "doc": "Apéndice 1. Sistemas de control de versiones. Git",
    "title": "A1.4. Algunas cosillas avanzadas sobre git",
    "content": "Solo con lo que hemos visto hasta ahora (add, commit, push y pull) ya tienes suficiente para empezar a funcionar con git. Luego, conforme te surjan otras necesidades, puedes ir curioseando por internet para profundizar en ciertos aspectos. Una de esas “necesidades” que te surgirán antes o después consiste en lo siguiente: . Imagínate la escena: un día llegas a clase después de haberte acosatado a las tantas trabajando en tu proyecto. Antes de acostarte hiciste un push para subir todos tus cambios y puedes jurar que todo funcionaba perfectamente. Pero ahora, tú y el resto de miembros de tu equipo acabáis de hacer pull y… ¡BUM! El proyecto entero salta por los aires. El homepage no carga. Otras rutas que estás seguro de que funcionaban hace unas horas ahora no responden. ¿Qué narices ha pasado? . Tranquilidad: ahí está Git para sacarte del embrollo. ",
    "url": "https://iescelia.org/docs/fullstack/_site/scv-git/#a14-algunas-cosillas-avanzadas-sobre-git",
    "relUrl": "/scv-git/#a14-algunas-cosillas-avanzadas-sobre-git"
  },"93": {
    "doc": "Apéndice 1. Sistemas de control de versiones. Git",
    "title": "A1.4.1. Regreso al pasado: cómo revertir los cambios",
    "content": "Las causas de un desastre como ese pueden ser tantas que, en la práctica, es como si fueran infinitas. Un problema con el proxy, un merge mal hecho, una desconfiguración de uno de los servidores locales que ha afectado a algún archivo clave, un error de algún miembro del equipo que ha sobreescrito cientos de archivos con versiones incorrectas… Causas infinitas, como te digo. No suele compensar el esfuerzo de buscar la razón última de lo que ha ocurrido, salvo que os pase esto con cierta regularidad: entonces sí que es cuestión de preocuparse. La mayoría de las veces es un problema puntual que puede resolverse de un modo muy simple: volviendo a la última versión estable. En primer lugar, si lo que quieres es revertir cambios de los que aún no has hecho commit, es tan fácil como: . $ git reset --hard . Pero, la mayor parte de las veces, el problema viene de cambios de los que no solo ya se ha hecho commit, sino que incluso se han subido al repositorio remoto. ¿Cómo descartamos esos cambios para volver a un estado anterior? . En primer lugar, si aún no lo has hecho, ejecuta un git pull para traerte la última versión del código a tu repositorio local. Luego, utiliza el comando git log: . $ git log (muestra historial de cambios) $ git log --oneline (muestra historial de cambios simplificado) . Con esto obtendrás una lista, ordenada por cronología inversa (de más reciente a más antiguo), de todos los commits que has hecho en el repositorio. Observa que cada commit está identificado con un id único en hexadecimal. Cada id de commit está acompañado de su descripción. Si habéis sido cuidadosos con los commits y les habéis puesto descripciones representativas (y no “asdfasdf” o “aaa”), resutará fácil localizar en esa lista el commit causante del destrozo. A continuación, usa el comando git revert para regresar al commit inmediatamente anterior a aquel en el que se produjo el caos: . $ git revert HEAD [main id-de-commit] revert \"Mensaje del revert\" . Lo que hace este comando es devolver tu repositorio local (HEAD) al commit “id-del-commit”. Pero, ojo, que no elimina todos los commits posteriores, sino que crea un nuevo commit (main) con el “Mensaje del revert” que le hayas indicado. En este nuevo commit habrá desaparecido todo el código conflictivo. El proyecto volverá a estar en un estado estable. Ahora bastará con hacer git push para subir el nuevo commit al repositorio remoto y que todos los miembros del equipo puedan replicarlo en sus máquinas. Es posible que, en el proceso, hayáis perdido algo de código valioso: todo depende de cuánto hayáis tenido que retroceder en el historial de commits hasta alcanzar un estado válido. Pero ese código en realidad no se ha perdido, porque los commits siguen ahí, en el historial de git. Existe una forma de poner el repositorio local en un commit concreto. Si lo haces y abres cualquier archivo fuente, lo encontrarás como estaba en ese commit, no como está en el último. ¿No es maravilloso? Así, podrás recuperar manualmente el código que pudiera haberse perdido al hacer el git revert. El comando que te permite saltar momentáneamente a cualquier commit es git checkout: . $ git checkout id-del-commit . Ahora puedes ver y rescatar el código fuente válido sin temor: nada de lo que hagas en este estado afectará al tu proyecto, porque los cambios se perderán cuando salgas de este “viaje en el tiempo” (salvo que crees una nueva rama del proyecto, pero esa es otra historia). Y, para regresar al presente, es decir, al último commit, basta con teclear: . $ git checkout main . ",
    "url": "https://iescelia.org/docs/fullstack/_site/scv-git/#a141-regreso-al-pasado-c%C3%B3mo-revertir-los-cambios",
    "relUrl": "/scv-git/#a141-regreso-al-pasado-cómo-revertir-los-cambios"
  },"94": {
    "doc": "Apéndice 1. Sistemas de control de versiones. Git",
    "title": "A1.4.2. Cuando dos personas se encaprichan del mismo archivo",
    "content": "Cuando ejecutas git pull, traes a tu repositorio local las versiones más recientes de todos los archivos del proyecto. Esto ya lo sabíamos. Si git pull se ejecuta sin contratiempos, aparecerá un mensaje informándote de ello. Pero los contratiempos existen, qué le vamos a hacer. La vida sería muy aburrida y predecible sin ellos. El contratiempo más habitual, con diferencia, al hacer git pull es el aviso de un conflicto el alguno de los archivos modificados en el repositorio remoto. Eso quiere decir que tú has estado tocando el código de un archivo al mismo tiempo que otra persona de tu equipo. Supongamos que, en un archivo A, tú has añadido las líneas A1, A2 y A3, mientras que otra persona ha añadido las líneas A4, A5 y A6. Si la otra persona ha subido el archivo A al repositorio remoto antes que tú, git se dará cuenta cuando intentes hacer git pull de que tu copia local del archivo y la que hay en el repositorio remoto no coinciden: no solo porque la tuya tiene las nuevas líneas A1, A2 y A3, sino porque a la tuya le faltan las líneas A4, A5 y A6. En ese caso, y para no perder ninguna de las nuevas líneas de código, git te mostrará un mensaje de advertencia y creará una versión nueva del archivo A en la que estarán todas las líneas de código nuevas, tanto las tuyas como las de la otra persona, rodeadas de unas marcas de texto como estas: . &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD espacio ============ Espacio &gt;&gt;&gt;&gt;&gt;&gt;&gt; nueva-rama . Ahora, lo único que tienes que hacer es buscar manualmente esas líneas conflictivas y resolverlas a mano, es decir, quedarte con las líneas correctas y borrar las que no lo sean. Borra también todas las marcas que ha puesto ahi git para indicarte el conflicto. Si usas cualquier editor de texto medianamente potente, te mostrará esas líneas resaltadas e incluso te ayudará a encontrarlas. Una vez que hayas resuelto manualmente las líneas en conflicto, basta con guardar los cambios y hacer git add y git commit -m “Resolviendo el conflicto bla,bl,bla” para que el git pull y el git push vuelvan a funcionar a la perfección. ",
    "url": "https://iescelia.org/docs/fullstack/_site/scv-git/#a142-cuando-dos-personas-se-encaprichan-del-mismo-archivo",
    "relUrl": "/scv-git/#a142-cuando-dos-personas-se-encaprichan-del-mismo-archivo"
  },"95": {
    "doc": "Apéndice 1. Sistemas de control de versiones. Git",
    "title": "A1.4.3. Proyectos que se complican: cómo crear ramas",
    "content": "Imagina esta situación: tienes un proyecto ya en marcha, con una versión más o menos estable funcionando, y entonces surge la necesidad de desarrollar una nueva funcionalidad. Y esta nueva funcionalidad va a poner patas arriba una parte importante del código y va a dejar la aplicación hecha unos zorros durante un tiempo. Si trabajas con tu repositorio como hemos hecho hasta ahora, el resultado es que, durante ese tiempo, todo tu proyecto dejará de funcionar. No podrás hacer demos a los clientes (ni a tus profesores/as), no podrás probar la aplicación, no podrás cargarla con datos reales, etc. ¡Todo quedará paralizado hasta que la nueva funcionalidad esté en marcha! . En un equipo de desarrollo grande, esta es una situación cotidiana que provocaría que gran parte de la gente se tuviera que quedar de brazos cruzados a la espera de la finalización de la nueva funcionalidad. Pero incluso en un equipo pequeño es un engorro llegar a este extremo. Para evitarlo, existen las ramas (branches) de Git. Una rama no es más que una copia del repositorio que puede evolucionar por su cuenta mientras la rama original permanece inalterada. Los desarrolladores/as que trabajen en esa rama pueden así trabajar en la nueva funcionalidad sin que el resto del equipo se vea afectado. Cuando la nueva funcionalidad se termine, lo único que hay que hacer es fusionar las dos ramas. Esto puede ser un trabajo ímprobo si se han estado modificando los mismos archivos en la rama principal y en la rama nueva, pero no se trata de un fallo de Git, que quede claro, sino de un fallo de organización del equipo. Y si la nueva funcionalidad nunca llega a terminarse (cosa que puede ocurrir por miles de razones), no pasa nada: la rama se elimina, o simplemente se abandona, y la rama principal sigue intacta. Crear una rama nueva es tan sencillo como usar este comando: . $ git branch nombre-nueva-rama . El comando git branch tiene muchas otras posibilidades. Aquí te pongo unas cuantas: . $ git branch --list (saca un listado de todas las ramas existentes) $ git branch -d nombre-rama (elimina una rama) $ git branch -D nombre-rama (elimina una rama a lo bestia, incluso si tiene cambios sin fusionar) $ git branch -m nuevo-nombre (cambia en nombre de la rama actual) . Ten en cuenta que, cuando creas una rama, aún no estás trabajando en ella. Si quieres cambiar a esa rama para empezar a trastear con ella sin tocar a la principal, debes hacer un git checkout: . $ git checkout nombre-rama . Por último, para fusionar una rama con otra (típicamente, con la rama principal o main), tienes que seguir estos pasos: . | Asegúrate de estar situado en la rama que va a recibir la fusión. Si esa rama es main, tienes que hacer: $ git checkout main . | Haz un git pull para tener disponible la última versión del código. | Realiza la fusión de las dos ramas con git merge: $ git merge nombre-rama . | . En este punto, tendrás que resolver manualmente los conflictos que puedan surgir (si los hay), como hemos explicado más arriba. ",
    "url": "https://iescelia.org/docs/fullstack/_site/scv-git/#a143-proyectos-que-se-complican-c%C3%B3mo-crear-ramas",
    "relUrl": "/scv-git/#a143-proyectos-que-se-complican-cómo-crear-ramas"
  },"96": {
    "doc": "Apéndice 1. Sistemas de control de versiones. Git",
    "title": "A1.4.4. ¿Aún quieres saber más?",
    "content": "Git es un sistema de control de versiones increíblemente completo. Sus creadores parecen haber pensado en escenarios de lo más aberrante y han tenido en cuenta casi cada cosa que puede suceder en un proyecto complejo. Si no, no se explica la enorme cantidad de comandos y posibilidades que ofrece. Si necesitas saber más cosas sobre Git, internet está plagada de contenidos de calidad (y otros bastante penosos) sobre este sistema. Como siempre te recomiendo, acude en primer lugar a la referencia oficial: https://git-scm.com/docs . Personalmente, a mí me gustan mucho los tutoriales de Atlassian. Aunque están orientados a BitBucket (un servicio competidor de GitHub o GitLab), casi todas sus recomendaciones son aplicables a cualquier servidor Git. Los puedes encontrar aquí: https://www.atlassian.com/es/git/tutorials . ",
    "url": "https://iescelia.org/docs/fullstack/_site/scv-git/#a144-a%C3%BAn-quieres-saber-m%C3%A1s",
    "relUrl": "/scv-git/#a144-aún-quieres-saber-más"
  },"97": {
    "doc": "Apéndice 2. Virtualización con Docker",
    "title": "Apéndice 2. Virtualización con Docker",
    "content": ". | A2.1. ¿Qué es Docker? | A2.2. Comandos usuales de Docker | A2.3. Persistencia de datos | A2.4. Montando con Docker un servidor web con persistencia de datos . | Paso 1. Crear ./docker-compose.yml | Paso 2. Crear un ./Dockerfile para PHP | Paso 3. Crear ./apache-custom/httpd.conf | Paso 4. Crear ./apache-custom/myapp.conf | Paso 5. Crear el archivo custom.ini | Paso 6. Levantar los contenedores con docker-compose up | Paso 7. Probar los contenedores | Paso 8. Detener los contenedores | . | . ",
    "url": "https://iescelia.org/docs/fullstack/_site/docker/",
    "relUrl": "/docker/"
  },"98": {
    "doc": "Apéndice 2. Virtualización con Docker",
    "title": "A2.1. ¿Qué es Docker?",
    "content": "Docker es una herramienta de virtualización basada en contenedores. Un contenedor es un paquete de software completamente independiente del sistema donde se ejecuta. Recibe ese nombre por los contenedores que se utilizan en el transporte marítimo, que tienen unas medidas y una forma estandarizada y que aislan por completo la carga que llevan dentro del exterior. Un contenedor Docker hace lo mismo, pero con un conjunto de software: lo aisla por completo del exterior. El software que hay dentro del contenedor se puede ejecutar en cualquier máquina gracias al runtime de Docker, que se comporta como un mini-sistema operativo virtualizado que corre sobre la máquina anfitrión. Un contenedor puede contener cualquier cosa. Por ejemplo, Apache. De ese modo, podemos ejecutar Apache en cualquier máquina (siempre que tenga previamente instalado Docker) sin necesidad de instalarlo realmente, con todo lo que ello conlleva de configuración de la máquina, consumo de recursos, etc. El contenedor Docker puede ponerse en marcha cuando queramos y detenerse en cualquier momento, sin dejar ningún rastro en la máquina anfitriona. En definitiva, puedes usar y/o testear cualquier programa sin tener que instalarlo realmente en tu máquina. Los contenedores Docker vienen empaquetados en imágenes, a partir de los cuales pueden lanzarse todos los contenedores que necesitemos. Es decir, las imágenes con como las clases en programación orientada a objetos, y los contenedores son como los objetos que se instancian a partir de esas clases. Cada cual puede construir las imágenes que necesite o usar imágenes ya hechas, con todo lo necesario en su interior para ejecutar cualquier software sin necesidad de instalarlo ni configurarlo. Hay repositorios públicos de imágenes, como DockerHub, donde uno puede encontrar imágenes de prácticamente cualquier cosa. ",
    "url": "https://iescelia.org/docs/fullstack/_site/docker/#a21-qu%C3%A9-es-docker",
    "relUrl": "/docker/#a21-qué-es-docker"
  },"99": {
    "doc": "Apéndice 2. Virtualización con Docker",
    "title": "A2.2. Comandos usuales de Docker",
    "content": "Aunque Docker puede usarse desde un interfaz gráfico (como Docker Desktop), lo habitual es hacerlo desde la línea de comandos. Esto no es un manual de Docker, pero sí vamos a enumerar aquí los comandos principales que nos serán útiles como desarrolladores web para que puedas usarlos como referencia rápida cuando tengas que trabajar con Docker. | docker run [nombre-imagen] - Lanza un contenedor a partir de la imagen especificada. Si la imagen no está descargada en el ordenador, la buscará en el repositorio configurado (por defecto, DockerHub). | docker ps - Muestra un listado con los contenedores que hay actualmente en el sistema. Un contenedor no tiene por qué estar necesariamente corriendo, sino que existen otros estados (detenido, preparado, finalizado, etc). Con docker ps -a podemos ver todos los contenedores, también los detenidos. | docker stop [id-del-contenedor] - Detiene un contenedor. Su id puede obtenerse con docker ps. | docker start [id-del-contenedor] - Reanuda un contenedor. | docker exec -it [id-del-contenedor] bash - Abrir un terminal en el contenedor. | docker-compose up -d - Inicia todos los contenedores especificados en el archivo docker-compose.yml del directorio actual. Necesitas tener instalado, además de Docker, el programa docker-compose. | docker-compose down - Detiene todos los contenedores especificados en el archivo docker-compose.yml del directorio actual. | . ",
    "url": "https://iescelia.org/docs/fullstack/_site/docker/#a22-comandos-usuales-de-docker",
    "relUrl": "/docker/#a22-comandos-usuales-de-docker"
  },"100": {
    "doc": "Apéndice 2. Virtualización con Docker",
    "title": "A2.3. Persistencia de datos",
    "content": "Cualquier cosa que guardes en un contenedor de Docker se perderá cuando el contenedor se detenga. Por ejemplo, si estás haciendo una aplicación web que usa una base de datos MySQL, y tu servidor MySQL está en un contenedor Docker, toda la información de esa base de datos se perderá cada vez que destruyas el contenedor. Es posible evitar eso usando la persistencia de datos. Consiste en pedirle a Docker que guarde datos fuera del contenedor, para que estos no se pierdan al reiniciarlo o eliminarlo. Por ejemplo, los datos de la base de datos. La persistencia se puede habilitar con docker run. Por ejemplo: . $ docker run -d --name mysql-container -e MYSQL_ROOT_PASSWORD=clave123 -v mysql-data:/var/lib/mysql mysql:latest . La persistencia se habilita con -v mysql-data:/var/lib/mysql, que crea (o usa) un volumen llamado mysql-data y lo monta en la ruta /var/lib/mysql de la máquina real, que es donde MySQL suele guardar los datos. Personalmente, encuentro más sencillo hacerlo todo a través de docker-compose. Por ejemplo, mira este archivo de configuración docker-compose.yml: . services: mysql: image: mysql:latest container_name: mysql-container volumes: - mysql-data:/var/lib/mysql ports: - \"3306:3306\" volumes: mysql-data: . Con este archivo de configuración se lanzará un contenedor de mysql en cuanto tecleemos docker-compose up. Observa estas dos líneas: . | La línea volumes dentro del servicio mysql monta el volumen virtual mysql-data en /var/lib/mysql, el lugar de la máquina real donde MySQL suele guardar los datos. | La línea volumes al final del archivo declara el volumen llamado mysql-data, que Docker creará si no existe. | . Así, los datos persisten en /var/lib/mysql aunque detengas o elimines el contenedor. ",
    "url": "https://iescelia.org/docs/fullstack/_site/docker/#a23-persistencia-de-datos",
    "relUrl": "/docker/#a23-persistencia-de-datos"
  },"101": {
    "doc": "Apéndice 2. Virtualización con Docker",
    "title": "A2.4. Montando con Docker un servidor web con persistencia de datos",
    "content": "En esta sección vamos a mostrar cómo montar un servidor web con imágenes Docker y levantarlo o apagarlo con docker-compose. Usaremos las imágenes oficiales de cada desarrollador, y necesitaremos poner en marcha cuatro contenedores simultáneamente, por lo que será mucho más cómodo hacerlo con docker-compose para poder levantarlas todas a la vez y no de una en una: . | Servidor Apache | Intérprete PHP | Servidor MariaDB | PHPMyAdmin | . Además, necesitamos que los datos de MariaDB sean persistentes, es decir, que no se pierdan cuando detengamos los contenedores. Lograr esto es complicadillo, pero trabajar con los servidores siempre lo es. A cambio, tendremos un entorno fácilmente transportable a otros servidores. Te dejo las instrucciones paso a paso para que lo consigas sin desesperarte demasiado: . Paso 1. Crear ./docker-compose.yml . Crea un archivo docker-compose.yml en tu directorio de trabajo con este contenido exacto, para trabajar con las imágene de nuestros cuatro servicios. Usaremos solo las imágenes oficiales. Algunas las tendremos que modificar un poco para que sirvan a nuestros propósitos: para eso montaremos los archivos custom.ini (en la imagen de PHP) y httpd.conf y myapp.conf (en la imagen de Apache). services: php: build: . volumes: - ./app:/app - ./custom.ini:/usr/local/etc/php/conf.d/custom.ini depends_on: - mariadb apache: image: httpd:2.4 ports: - \"8080:80\" volumes: - ./app:/app - ./apache-custom/httpd.conf:/usr/local/apache2/conf/httpd.conf:ro - ./apache-custom/myapp.conf:/usr/local/apache2/conf/extra/myapp.conf:ro depends_on: - php mariadb: image: mariadb:10.6 environment: MYSQL_ROOT_PASSWORD: 1234 MYSQL_DATABASE: pruebas MYSQL_USER: user MYSQL_PASSWORD: 1234 volumes: - mariadb_data:/var/lib/mysql phpmyadmin: image: phpmyadmin/phpmyadmin ports: - \"8000:80\" environment: PMA_HOST: mariadb depends_on: - mariadb volumes: mariadb_data: . Paso 2. Crear un ./Dockerfile para PHP . La imagen oficial de PHP-FPM es muy minimalista y viene con muy pocas extensiones instaladas. Tenemos que instalar algunas librerías adicionales en ese contenedor (como pdo_mysql para acceso a bases de datos MySQL con PDO). Esto se logra creando un archivo llamado Dockerfile en el directorio raíz (en la misma carpeta donde tengas docker-compose.yml) con este contenido: . FROM php:8.2-fpm # Instalar dependencias necesarias RUN apt-get update &amp;&amp; apt-get install -y \\ default-mysql-client \\ libzip-dev \\ unzip \\ git \\ &amp;&amp; docker-php-ext-install pdo pdo_mysql mysqli zip \\ &amp;&amp; apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/* . Así informamos a Docker de que: . | a) Queremos usar php:8.2-fpm, la imagen oficial de PHP (versión 8.2) como base para el contenedor. | b) Queremos instalar (con el comando RUN apt-get) varias extensiones útiles al levantar el contenedor por primera vez (puede tardar un poco). | . Paso 3. Crear ./apache-custom/httpd.conf . Por defecto, la imagen oficial de Apache no interpreta el código PHP, sino que lo sirve en texto plano, como si fuera HTML. Podemos reconfigurar esta imagen sin tener que meter mano también a este contenedor: . | Crea el directorio apache-custom en tu carpeta de trabajo. | Crea el archivo ./apache-custom/httpd.conf con este contenido: | . # httpd.conf mínimo preparado para usar Apache httpd:2.4 + PHP-FPM ServerRoot \"/usr/local/apache2\" # Puerto en el que Apache escuchará dentro del contenedor Listen 80 # Módulos esenciales LoadModule mpm_event_module modules/mod_mpm_event.so LoadModule authn_core_module modules/mod_authn_core.so LoadModule authz_core_module modules/mod_authz_core.so LoadModule unixd_module modules/mod_unixd.so LoadModule dir_module modules/mod_dir.so LoadModule mime_module modules/mod_mime.so LoadModule log_config_module modules/mod_log_config.so LoadModule env_module modules/mod_env.so LoadModule setenvif_module modules/mod_setenvif.so LoadModule alias_module modules/mod_alias.so LoadModule negotiation_module modules/mod_negotiation.so LoadModule autoindex_module modules/mod_autoindex.so LoadModule headers_module modules/mod_headers.so # Módulos necesarios para proxying a PHP-FPM LoadModule proxy_module modules/mod_proxy.so LoadModule proxy_fcgi_module modules/mod_proxy_fcgi.so # Información del servidor ServerAdmin you@example.com ServerName localhost:80 # Archivos de tipos mime TypesConfig conf/mime.types # Logs: enviar a stdout/stderr para que docker-compose logs funcione bien ErrorLog /proc/self/fd/2 CustomLog /proc/self/fd/1 common # Seguridad por defecto &lt;Directory /&gt; AllowOverride none Require all denied &lt;/Directory&gt; # DocumentRoot por defecto DocumentRoot \"/usr/local/apache2/htdocs\" &lt;Directory \"/usr/local/apache2/htdocs\"&gt; Options Indexes FollowSymLinks AllowOverride None Require all granted &lt;/Directory&gt; # Índices (queremos que index.php tenga preferencia sobre index.html) &lt;IfModule dir_module&gt; DirectoryIndex index.php index.html &lt;/IfModule&gt; # Incluimos el virtualhost personalizado que defines en apache-custom/myapp.conf Include conf/extra/myapp.conf # Fin del archivo . Paso 4. Crear ./apache-custom/myapp.conf . En este archivo de configuración adicional redirigiremos todas las peticiones de archivos .php hacia el contenedor con el intérprete PHP. El resto de archivos serán servidos por Apache. Crea el archivo ./apache-custom/myapp.conf con este contenido: . &lt;VirtualHost *:80&gt; DocumentRoot \"/app\" &lt;Directory \"/app\"&gt; Options Indexes FollowSymLinks AllowOverride All Require all granted DirectoryIndex index.php &lt;/Directory&gt; # Enviar todas las peticiones a .php al FPM del contenedor `php` ProxyPassMatch ^/(.*\\.php(/.*)?)$ fcgi://php:9000/app/$1 &lt;/VirtualHost&gt; . Paso 5. Crear el archivo custom.ini . Este archivo contiene las opciones de configuración adicionales para PHP. PHP se configura dentro del contenedor correspondiente, en un archivo llamado php.ini. Podemos agregar configuraciones adicionales sin necesidad de tocar el contenedor con un archivo de configuración adicional que mapearemos al interior del contenedor. Crea un archivo llamado custom.ini en tu directorio de trabajo con este contenido: . display_errors = On display_startup_errors = On error_reporting = E_ALL opcache.enable = 0 opcache.enable_cli = 0 output_buffering = Off . Esto habilitará las opciones de depuración de errores de PHP. En un entorno de producción, estas opciones se deshabilitarían, claro. También deshabilitará la caché, imprescindible para que, al desarrollar, nuestros cambios se vean inmediatamente en el servidor. Si más adelante necesitas configuraciones adicionales para PHP (como incrementar el tamaño máximo de archivos subidos al servidor o el tiempo de procesamiento de un script), puedes hacerlo fácilmente en este custom.ini. Paso 6. Levantar los contenedores con docker-compose up . Ya lo tenemos todo preparado. Ahora podemos poner en marcha los cuatro contenedores tecleando (en el directorio de trabajo): . $ docker-compose up --build # Lanzar contenedores la primera vez (o después cambiar docker-compose.yml o Dockerfile) . O bien, si no hemos tocado la configuración de los contenedores recientemente: . $ docker-compose up # Lanzar contenedores habitualmente . También podemos lanzarlo en segundo plano, para que la consola no se quede bloqueada: . $ docker-compose up -d # Lanzar contenedores en segundo plano . Paso 7. Probar los contenedores . Si todo ha ido bien, deberías tener estos servicios activos: . | http://localhost:8080 -&gt; Aquí debería estar escuchando Apache/PHP. Si pones un archivo .php en la carpeta ./app de tu proyecto, tendría que verse el resultado. | http://localhost:8000 -&gt; Aquí debería estar escuchando PHPMyAdmin. El usuario y contraseña de la base de datos están en el docker-compose.yml (los puedes cambiar allí si no te gustan). | . Paso 8. Detener los contenedores . Para detener los contenedores, tan solo teclea: . $ docker-compose down . O bien pulsa CTRL + C si inciaste docker-compose en segundo plano (con la opción -d). ",
    "url": "https://iescelia.org/docs/fullstack/_site/docker/#a24-montando-con-docker-un-servidor-web-con-persistencia-de-datos",
    "relUrl": "/docker/#a24-montando-con-docker-un-servidor-web-con-persistencia-de-datos"
  },"102": {
    "doc": "Apéndice 3. Despliegue con Openstack",
    "title": "Apéndice 3. Despliegue con Openstack",
    "content": ". | A3.1. ¿Qué es Openstack? | A3.2. Creando servidores en Openstack para desplegar aplicaciones web . | A3.2.1. Caso 1: mi aplicación está escrita en PHP clásico | A3.2.2. Caso 2: mi aplicación está escrita con Laravel | . | . ",
    "url": "https://iescelia.org/docs/fullstack/_site/openstack/",
    "relUrl": "/openstack/"
  },"103": {
    "doc": "Apéndice 3. Despliegue con Openstack",
    "title": "A3.1. ¿Qué es Openstack?",
    "content": "OpenStack es un proyecto open source que permite gestionar recursos virtuales de computación, redes, almacenamiento e imágenes, para diseñar y gestionar nubes privadas y públicas. Proporciona una virtualización de “infraestructura como servicio” o IaaS (Infraestructure as a Service). En palabras más simples, Openstack nos permite desplegar una nube en la que virtualizar cualquier infraestructura hardware razonablemente concebible: ordenadores, redes, dispositivos de almacenamiento, etc. Y, además, nos permite interconectar todos esos componentes entre sí. Por lo tanto, Openstack es perfecto para montar servidores web y de bases de datos adaptados a nuestras necesidades, de manera que podamos desplegar en ellos nuestras aplicaciones web. Como son servidores virtuales, es fácil crearlos, replicarlos, eliminarlos o modificarlos, incluso en caliente. Por ejemplo, puedes añadir más memoria RAM a un servidor sin necesidad siquiera de apagarlo. ",
    "url": "https://iescelia.org/docs/fullstack/_site/openstack/#a31-qu%C3%A9-es-openstack",
    "relUrl": "/openstack/#a31-qué-es-openstack"
  },"104": {
    "doc": "Apéndice 3. Despliegue con Openstack",
    "title": "A3.2. Creando servidores en Openstack para desplegar aplicaciones web",
    "content": "José Juan Sánchez ha elaborado una completísima documentación sobre Openstack. La podéis encontrar aquí: . https://josejuansanchez.org/openstack-celia/ . No vamos a repetir aquí lo que ya pone en esa guía, porque además corresponde al módulo de “Despliegue de Aplicaciones Web”. Aquí solo resumiremos los pasos necesarios para crear un servidor en Openstack adecuado para desplegar tus aplicaciones: . | Accede a Openstack en https://172.16.0.11. Lógicamente, necesitarás una cuenta de usuario en vigor. | Crea una instancia nueva (por ejemplo, un Ubuntu 22.04 con 10 GB de disco y 1 GB de RAM debería ser suficiente para un servidor normalito). | Asocia una IP flotante a la instancia. Es la única forma de poder entrar a tu máquina virtual posteriormente. | Lanza la instancia y conéctate por SSH con ella. Necesitarás crear un par de claves SSH y guardar tu clave privada en un archivo llamado “id_rsa” de tu usuario (la ubicación de este archivo depende del sistema operativo; tendrás que consultar dónde hacerlo según que sistema uses): . $ ssh ubuntu@dirección_IP . | Añade una regla al grupo de seguridad de Openstack para poder acceder al servidor por http. Esto se hace desde el panel de administración de Openstack, siguiendo esta ruta: Red -&gt; Grupos de seguridad -&gt; Administrar reglas -&gt; Agregar regla. Después, elije la regla predefinida que se llama “HTTP”. | Añade una regla al grupo de seguridad de Openstack para poder acceder a MySQL. Como antes, se hace desde el panel de administración de Openstack (Red -&gt; Grupos de seguridad -&gt; Administrar reglas -&gt; Agregar regla). En esta ocasión, elije la regla predefinida “MySQL”. | Instala docker, docker-compose, git y composer en la máquina virtual (bueno, y cualquier otra cosa que te sea necesaria para tu aplicación). Para ello, recuerda conectarte antes a tu máquina virtual por SSH y teclea esto: . $ sudo apt install docker docker-compose git composer $ sudo adduser ubuntu docker (Añadir usuario \"ubuntu\" al grupo \"docker\") . | Instala el software necesario para que tu aplicación web funcione. Esto se puede hacer de forma nativa, instalado Apache, MySQL y todo lo que tu aplicación necesite, o virtualizando todos esos componentes con Docker, que es más fácil, escalable y recomendable. Como es diferente desplegar una aplicación web escrita en PHP clásico que hacerlo con una escrita con Laravel, vamos a mostrar los siguientes pasos de forma diferenciada para cada situación. | . A3.2.1. Caso 1: mi aplicación está escrita en PHP clásico . Asegúrate de que has seguido correctamente los pasos previos expuestos en el apartado A3.2 antes de continuar por aquí. | Monta los contenedores Docker necesarios para crear un servidor web. Para ello, puedes seguir los pasos que detallamos en el ejemplo del Apéndice 2, donde montamos un servidor con Apache, PHP, MariaDB y PHPMyAdmin. Por supuesto, estos pasos los tienes que ejecutar en tu máquina virtual de Openstack, conectándote a ella por SSH, no en tu máquina local. | Lanza los contenedores con docker-compose. Si has seguido correctamente los pasos para montar el servidor que detallamos en el Apéndice 2, con esto tu servidor estará escuchando en la IP flotante que hayas asignado a tu máquina virtual. | Despliega tu código. Si usas git (como deberías estar haciendo), es tan simple como hacer git clone en el directorio donde hayas lanzado Docker. | . ¡Listo! Tu aplicación estará respondiendo en la IP flotante que hayas configurado. Compruébalo con tu navegador web preferido. A3.2.2. Caso 2: mi aplicación está escrita con Laravel . Asegúrate de que has seguido correctamente los pasos previos expuestos en el apartado A3.2 antes de continuar por aquí. Para usar Laravel, debes instalar todas las dependencias en el servidor. Esto puede ser complicado, porque Laravel requiere de bastantes componentes. Por eso es recomendable instalarlo también con Docker (es decir, instalar Laravel Sail). Los pasos para lograrlo serían los siguientes (recuerda que debes ejecutarlos en tu servidor, conectándote a él por SSH): . | Si queremos una instalación de Laravel limpia haremos esto en la máquina virtual: . $ curl -s https://laravel.build/mi-app | bash (cambiar \"mi-app\" por otro nombre para la app) $ cd mi-app (o el directorio que hayas elegido en la instrucción anterior) $ ./vendor/bin/sail up -d . En cambio, si ya tienes una aplicación Laravel funcionando (por ejemplo, en tu localhost), bastará con que la clones con git clone o, si no usas git (mal hecho), que copies el código manualmente a tu máquina virtual con scp. | Instalar las dependencias de PHP y lanzar migraciones. Si tu aplicación Laravel no tiene directorio “vendor”, tendrás que generarlo con composer. Y crear la estructura de la base de datos lanzando tus migraciones: . $ ./vendor/bin/sail composer update (necesitas tener al menos \"sail\" dentro de \"vendor\") $ php artisan migrate:fresh --seed (necesitarás configurar antes el .env) . | Resolver problemas de permisos. Si la aplicación Laravel da un error de acceso al directorio “storage”, concédele permisos 777: . $ sudo chmod -R 777 storage $ ./vendor/bin/sail artisan cache:clear $ ./vendor/bin/sail artisan config:clear $ ./vendor/bin/sail artisan config:cache . | Resolver problemas con sesiones, caché y vistas. Si la aplicación Laravel da errores con la sesiones, la caché o las vistas, asegúrate de que dentro del directorio /storage/framework existen los subdirectorios cache, sessions y views, los tres con permisos 777. Si no existen, créalos. | Lanzar Node (si es necesario). Si tu aplicación Laravel usa Node (por ejemplo, porque hayas instalado Laravel Breeze), tendrás que lanzar Node en el servidor: . $ ./vendor/bin/sail npm install $ ./vendor/bin/sail npm run dev . Eso dejará el servidor Node corriendo. No lo detengas: necesitará estár permanentemente activo (como Sail) para que la aplicación Laravel funcione bien. Hemos observado que, en el servidor Ubuntu de Openstack, el comando npm run dev puede dar el error “ENOSPC: System limit for number of file watchers reached”. Si te sucede esto, haz lo siguiente: . $ sudo nano /etc/sysctl.conf . Ahora añade esta línea al final de archivo: . fs.inotify.max_user_watches = 524288 . Con eso, npm run dev debería funcionar bien. | . ¡Listo! Con esto, deberías tener tu servidor escuchando en la IP flotante que hayas asignado a tu máquina virtual. ",
    "url": "https://iescelia.org/docs/fullstack/_site/openstack/#a32-creando-servidores-en-openstack-para-desplegar-aplicaciones-web",
    "relUrl": "/openstack/#a32-creando-servidores-en-openstack-para-desplegar-aplicaciones-web"
  },"105": {
    "doc": "About",
    "title": "About",
    "content": "Estos apuntes han sido elaborados por [Alfredo Moreno Vozmediano] y se publican aquí con licencia CC BY 4.0, lo que quiere decir que eres libre de usar este material, copiarlo, distribuirlo y modificarlo siempre que el resultado de todo eso mantenga la misma licencia y cites la autoría original. Algunos fragmentos (pocos) están tomados y adaptados de otras fuentes. Cuando eso ocurre, lo indico claramente en el texto. Debes atenerte a la licencia de los sitios web de origen para esos fragmentos. ",
    "url": "https://iescelia.org/docs/fullstack/_site/about/",
    "relUrl": "/about/"
  },"106": {
    "doc": "Desarrollo web full stack",
    "title": "Desarrollo web full stack",
    "content": "Esta es la documentación (apuntes) del módulo optativo de Desarrollo web full stack del Ciclo Formativo de Grado Superior de Desarrollo de Aplicaciones Web/Multiplataforma impartido en el IES Celia Viñas de Almería (España). ",
    "url": "https://iescelia.org/docs/fullstack/_site/",
    "relUrl": "/"
  }
}
