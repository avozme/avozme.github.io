I"≥<h1 class="no_toc" id="ap√©ndice-1-sistemas-de-control-de-versiones-git">Ap√©ndice 1. Sistemas de control de versiones. Git</h1>

<ul id="markdown-toc">
  <li><a href="#a11-sistemas-de-control-de-versiones" id="markdown-toc-a11-sistemas-de-control-de-versiones">A1.1. Sistemas de control de versiones</a>    <ul>
      <li><a href="#a111-qu√©-es-un-sistema-de-control-de-versiones" id="markdown-toc-a111-qu√©-es-un-sistema-de-control-de-versiones">A1.1.1. ¬øQu√© es un sistema de control de versiones?</a></li>
      <li><a href="#a112-c√≥mo-funcionan-los-sistemas-de-control-de-versiones" id="markdown-toc-a112-c√≥mo-funcionan-los-sistemas-de-control-de-versiones">A1.1.2. ¬øC√≥mo funcionan los sistemas de control de versiones?</a></li>
    </ul>
  </li>
  <li><a href="#a12-git-b√°sico" id="markdown-toc-a12-git-b√°sico">A1.2. Git b√°sico</a>    <ul>
      <li><a href="#a121-poniendo-en-marcha-git" id="markdown-toc-a121-poniendo-en-marcha-git">A1.2.1. Poniendo en marcha Git</a></li>
      <li><a href="#a122-creando-un-repositorio-nuevo" id="markdown-toc-a122-creando-un-repositorio-nuevo">A1.2.2. Creando un repositorio nuevo</a></li>
    </ul>
  </li>
  <li><a href="#a13-trabajo-b√°sico-con-git" id="markdown-toc-a13-trabajo-b√°sico-con-git">A1.3. Trabajo b√°sico con Git</a>    <ul>
      <li><a href="#a131-un-momento-staging-qu√©eee" id="markdown-toc-a131-un-momento-staging-qu√©eee">A1.3.1. Un momento‚Ä¶ ¬øStaging qu√©eee?</a></li>
      <li><a href="#a132-hacer-commit" id="markdown-toc-a132-hacer-commit">A1.3.2. Hacer commit</a></li>
      <li><a href="#a133-subir-el-commit-hacer-push" id="markdown-toc-a133-subir-el-commit-hacer-push">A1.3.3. Subir el commit: hacer push</a></li>
      <li><a href="#a134-bajar-la-√∫ltima-versi√≥n-del-c√≥digo-hacer-pull" id="markdown-toc-a134-bajar-la-√∫ltima-versi√≥n-del-c√≥digo-hacer-pull">A1.3.4. Bajar la √∫ltima versi√≥n del c√≥digo: hacer pull</a></li>
      <li><a href="#a135-resumi√©ndolo-todo-flujo-de-trabajo-habitual-con-git" id="markdown-toc-a135-resumi√©ndolo-todo-flujo-de-trabajo-habitual-con-git">A1.3.5. Resumi√©ndolo todo: flujo de trabajo habitual con git</a></li>
    </ul>
  </li>
  <li><a href="#a14-algunas-cosillas-avanzadas-sobre-git" id="markdown-toc-a14-algunas-cosillas-avanzadas-sobre-git">A1.4. Algunas cosillas avanzadas sobre git</a>    <ul>
      <li><a href="#a141-regreso-al-pasado-c√≥mo-revertir-los-cambios" id="markdown-toc-a141-regreso-al-pasado-c√≥mo-revertir-los-cambios">A1.4.1. Regreso al pasado: c√≥mo revertir los cambios</a></li>
      <li><a href="#a142-cuando-dos-personas-se-encaprichan-del-mismo-archivo" id="markdown-toc-a142-cuando-dos-personas-se-encaprichan-del-mismo-archivo">A1.4.2. Cuando dos personas se encaprichan del mismo archivo</a></li>
      <li><a href="#a143-proyectos-que-se-complican-c√≥mo-crear-ramas" id="markdown-toc-a143-proyectos-que-se-complican-c√≥mo-crear-ramas">A1.4.3. Proyectos que se complican: c√≥mo crear ramas</a></li>
      <li><a href="#a144-a√∫n-quieres-saber-m√°s" id="markdown-toc-a144-a√∫n-quieres-saber-m√°s">A1.4.4. ¬øA√∫n quieres saber m√°s?</a></li>
    </ul>
  </li>
</ul>

<h1 id="a11-sistemas-de-control-de-versiones">A1.1. Sistemas de control de versiones</h1>

<p>Es <em>inconcebible</em> que un desarrollador trabaje en la actualidad sin un sistema de control de versiones.</p>

<p>F√≠jate que en la frase anterior no tiene cabida tu opini√≥n. Lo siento, pero es lo que hay. No importa si te gustan estos sistemas o no. No importa si est√°s los usas de forma habitual o siempre has huido de ellos como de la peste. No importa si ni siquiera sabes qu√© son o c√≥mo funcionan. Si quieres dedicarte profesionalmente al desarrollo de software, tienes que conocerlos porque te los vas a encontrar vayas donde vayas.</p>

<h2 id="a111-qu√©-es-un-sistema-de-control-de-versiones">A1.1.1. ¬øQu√© es un sistema de control de versiones?</h2>

<p>Un <strong>sistema de control de versiones</strong> es un <em>almac√©n en la nube pensado para equipos de desarrollo de software</em>.</p>

<p>Es decir, como Google Drive, pero a lo bestia.</p>

<p>El sistema de control de versiones no solo sirve para que un pu√±ado de usuarios (entre uno y miles) suban su c√≥digo fuente a la nube para ponerlo a salvo de posibles problemas con las m√°quinas locales, sino que, adem√°s, permite:</p>

<ul>
  <li>Conservar absolutamente todo el historial de versiones previas.</li>
  <li>Documentar cada cambio, de manera que siempre sea posible saber qui√©n, c√≥mo, d√≥nde, cu√°ndo y por qu√© escribi√≥ cada l√≠nea de c√≥digo.</li>
  <li>Revertir el software a un estado anterior en cualquier momento.</li>
  <li>Crear ramas o ‚Äúestados alternativos‚Äù del software, que luego podr√°n fusionarse con otras ramas o abandonarse sin llegar a nada.</li>
  <li>Crear ‚Äúforks‚Äù o r√©plicas del sistema que luego podr√°n evolucionar de forma independiente (o volver a fusionarse con el contenido original).</li>
  <li>Evitar conflictos cuando el mismo c√≥digo fuente ha sido editado simult√°nemente por dos personas. Y, en caso de que estos conflictos ocurran, ayudar a resolverlos.</li>
</ul>

<p>Se trata de un buen pu√±ado de funciones, ¬øverdad? Ese es el motivo por el que absolutamente todas las organizaciones serias que se dedican a desarrollar software utilizan alg√∫n sistema de control de versiones.</p>

<p>Pero es que incluso para un programador/a solitario, que trabaja de forma aut√≥noma, las ventajas de usar uno de estos sistemas superan de lejos a los inconvenientes, porque‚Ä¶ espera un momento‚Ä¶ ¬°Resulta que no tienen ning√∫n inconveniente!</p>

<p>As√≠ que ya lo sabes: si a√∫n no los usas, este es el momento de hacer un esfuerzo e incorporar un sistema de control de versiones a tu vida.</p>

<h2 id="a112-c√≥mo-funcionan-los-sistemas-de-control-de-versiones">A1.1.2. ¬øC√≥mo funcionan los sistemas de control de versiones?</h2>

<p>Existen muchos sistemas de control de versiones, aunque el mercado est√° dominado por unos pocos de ellos: CVS, Subversion, Mercurial, Bazaar y, sobre todo, Git. Cada uno tiene sus propias peculiaridades, pero suelen compartir varias caracter√≠sticas comunes:</p>

<ul>
  <li>El c√≥digo fuente del proyecto (y todas sus versiones previas) se guarda en uno o varios servidores. Esa colecci√≥n de c√≥digo fuente se denomina <strong><em>repositorio</em></strong>. El servidor puede estar en Internet y pertenecer a una compa√±√≠a externa. Tambi√©n puede estar en nuestra intranet, instalado en una de nuestras m√°quinas. O puede estar en nuestro propio ordenador.</li>
  <li>Los repositorios pueden ser <strong>remotos</strong> (si est√°n en otra m√°quina distinta de la nuestra) o <strong>locales</strong> (si est√°n en nuestra m√°quina).</li>
  <li><strong>Siempre se trabaja sobre el repositorio local</strong>. Cuando una funcionalidad del c√≥digo se termina, el c√≥digo fuente modificado se sube al repositorio remoto, para que el resto de miembros del equipo puedan disponer de √©l.</li>
  <li>Si otra persona del equipo ha modificado los mismos archivos fuente que nosotros, el sistema de control de versiones nos avisar√° del conflicto durante la sincronizaci√≥n y nos obligar√° a hacer manualmente una fusi√≥n de los archivos afectados, mostr√°ndonos las diferentes versiones del mismo, antes de completar la sincronizaci√≥n.</li>
</ul>

<p>La sincronizaci√≥n con el repositorio remoto, por lo tanto, no puede ser autom√°tica (como en Google Drive o Dropbox), sino que hemos de hacerla expl√≠cita, momento en el cual el sistema nos avisar√° de posibles conflictos. Esta es la √∫nica manera de resolver adecuadamente esos conflictos en proyectos donde haya mucha gente trabajando simult√°neamente.</p>

<h1 id="a12-git-b√°sico">A1.2. Git b√°sico</h1>

<p>Git es, en la actualidad, el sistema de control de versiones m√°s utilizado del mundo con diferencia. Tambi√©n es uno de los m√°s completos y complejos. As√≠ que, si aprendes a utilizar Git, podr√°s apa√±√°rtelas con cualquier otro sistema de control de versiones.</p>

<p>En esta secci√≥n vamos a ver c√≥mo se usa Git a nivel b√°sico. El acceso a las funciones avanzadas ir√° viniendo solo, con el tiempo y el uso.</p>

<h2 id="a121-poniendo-en-marcha-git">A1.2.1. Poniendo en marcha Git</h2>

<p>Git es un sistema de control de versiones que se cre√≥ inicialmente para desarrollar el n√∫cleo de Linux. Es de c√≥digo abierto (<em>opensource</em>). Eso quiere decir que cualquiera puede coger el c√≥digo, modificarlo, adaptalo y distribuirlo.</p>

<p>Por eso encontrar√°s multitud de implementaciones de Git, as√≠ como muchos servidores y clientes que lo usan. Todos son compatibles entre s√≠.</p>

<p>Git crea repositorios locales y remotos que hay que mantener sincronizados manualmente. Para usar Git, necesitas al menos:</p>

<ul>
  <li>Instalar un <strong>cliente de Git</strong> en tu ordenador de trabajo.</li>
  <li>Instalar un <strong>servidor de Git</strong> en el ordenador donde vayas a alojar el repositorio remoto.</li>
</ul>

<p>Para el servidor Git, mucha gente utiliza <strong>servidores gratuitos disponibles en Internet</strong>. Los m√°s conocidos de ellos son <strong>GitHub</strong> y <strong>GitLab</strong>. Son sitios web donde te registras y ¬°voil√†!, ya tienes disponible un servidor Git en l√≠nea para que funcione de repositorio remoto. Adem√°s, estos sitios proporcionan caracter√≠sticas adicionales muy convenientes, como sistemas de gesti√≥n de <em>issues</em> o tareas pendientes, gesti√≥n de proyectos, estad√≠sticas, evaluaci√≥n de la calidad de software, etc. Tambi√©n funcionan como redes sociales para desarrolladores.</p>

<p>En fin, que, salvo que seas un paranoico de la seguridad o est√©s desarrollando c√≥digo ultrasecreto para la NSA o el CSIF, usar GitHub o GitLab como repositorio remoto es la opci√≥n m√°s interesante. As√≠ que ya puedes dejar de leer esto y registrarte ahora mismo en alguno de los dos.</p>

<p>¬øYa est√°s de regreso? Vale, ahora tienes que instalarte en tu ordenador un cliente Git.</p>

<p>Clientes Git hay muchos, algunos m√°s bonitos que otros. Yo te recomiendo el cliente b√°sico en modo texto, con el que tendr√°s que salirte a la consola y teclear comandos. Teclear comandos incomprensibles de forma r√°pida y segura siempre queda muy bien para presumir. Aparte de eso, aprenderse los comandos b√°sicos de Git te salvar√° la vida en alg√∫n momento de tu futuro profesional, te lo aseguro, as√≠ que es una buena inversi√≥n de tiempo.</p>

<p>Puedes encontrar los clientes oficiales de Git en la web del proyecto: <strong>https://git-scm.com/</strong></p>

<p>Cuando hayas aprendido a apa√±arte con los comandos, es posible que te gusten tanto que ya no quieras recurrir a los clientes gr√°ficos. Pero, por si acaso no es as√≠, te comento que existen mogoll√≥n de ellos que te permitir√°n sincronizar tus archivos con un solo clic y resolver conflictos de forma r√°pida y muy visual. Algunos de ellos son: <strong>GitHub Desktop</strong> (ofrecido por GitHub), <strong>GitKraken</strong>, <strong>Git Cola</strong> o <strong>Tortoise Git</strong>.</p>

<p>Por √∫ltimo, ten en cuenta que todos los entornos de desarrollo medianamente potentes ofrecen una integraci√≥n absoluta con Git. Es decir, que si usas <strong>Visual Studio Code</strong>, <strong>Eclipse</strong>, <strong>NetBeans</strong> o muchos otros, no necesitar√°s ning√∫n cliente git adicional, porque ya lo traen incorporado. Tan solo debes configurar la ruta el repositorio remoto y al local, y hala, a programar y a sincronizar como si no hubiera un ma√±ana.</p>

<h2 id="a122-creando-un-repositorio-nuevo">A1.2.2. Creando un repositorio nuevo</h2>

<p>Bien, pues ya tenemos nuestra cuenta en GitHub o GitLab y hemos instalado un cliente Git en nuestra m√°quina. ¬øAhora qu√©?</p>

<p>Podemos encontrarnos ante dos escenarios diferentes:</p>

<ol>
  <li>Voy a empezar un proyecto nuevo y quiero inicializar un repositorio en blanco.</li>
  <li>Ya tengo mi c√≥digo fuente (todo o una parte) escrito y quiero a√±adirlo a un repositorio git.</li>
</ol>

<p>Vamos a ver c√≥mo proceder en cada caso. Lo haremos mostrando c√≥mo se usa el cliente git de l√≠nea de comando. Desde los clientes gr√°ficos, el proceso ser√° parecido, pero tendr√°s que trastear con el cliente en cuesti√≥n o leerte su documentaci√≥n para ver los detalles.</p>

<h4 id="caso-1-voy-a-empezar-un-proyecto-nuevo-y-quiero-inicializar-un-repositorio-en-blanco">Caso 1: Voy a empezar un proyecto nuevo y quiero inicializar un repositorio en blanco.</h4>

<ol>
  <li>Abre un terminal de l√≠nea de comandos y mu√©vete al directorio o carpeta donde tienes pensado crear tu c√≥digo fuente. Usa para ello los comandos <code class="language-plaintext highlighter-rouge">cd carpeta</code> (para cambiar de carpeta) o <code class="language-plaintext highlighter-rouge">mk carpeta</code> (para crear una carpeta nueva).</li>
  <li>
    <p>Para crear un repositorio git local en la carpeta elegida, simplemente teclea este comando:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ git init
</code></pre></div>    </div>
  </li>
  <li>
    <p>Para conectar este repositorio local con un repositorio remoto en GitHub o GitLab, escribe a continuaci√≥n este comando:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ git remote add origin &lt;URI&gt;
</code></pre></div>    </div>
    <p>Sustituye ‚ÄúURI‚Äù por la direcci√≥n de tu repositorio que te habr√° proporcionado GitHub o GitLab. Por ejemplo, en GitHub, una URI de repositorio tiene un aspecto como este: https://github.com/usuario/nombre-repositorio.git).</p>

    <p>Obviamente, el repositorio remoto deber√≠as haberlo creado antes desde la web de GitHub o GitLab.</p>
  </li>
</ol>

<p>Eso es todo. A partir de ahora, podr√°s empezar a desarrollar tu c√≥digo en local y a sincronizar tus archivos con el repositorio remoto cada vez que lo necesites. El procedimiento para hacer esto √∫ltimo lo describimos un poco m√°s adelante.</p>

<h4 id="caso-2-ya-tengo-mi-c√≥digo-fuente-y-quiero-a√±adirlo-a-un-repositorio-git">Caso 2: Ya tengo mi c√≥digo fuente y quiero a√±adirlo a un repositorio git</h4>

<p>Este caso es un poquito m√°s complejo, pero tampoco mucho. Aseg√∫rate de tener ya creado un repositorio (vac√≠o) en GitHub o GitLab antes de seguir esta gu√≠a.</p>

<ol>
  <li>Abre un terminal de l√≠nea de comandos y mu√©vete a la carpeta donde tengas tu c√≥digo fuente. Usa para ello el comando <code class="language-plaintext highlighter-rouge">cd carpeta</code>.</li>
  <li>
    <p>Para crear un repositorio git local en esa carpeta, simplemente teclea este comando:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ git init
</code></pre></div>    </div>
  </li>
  <li>
    <p>Para conectar este repositorio local con un repositorio remoto en GitHub o GitLab, escribe esto:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ git remote add origin &lt;URI&gt;
</code></pre></div>    </div>

    <p>Sustituye ‚ÄúURI‚Äù por la direcci√≥n de tu repositorio que te habr√° proporcionado GitHub o GitLab. Por ejemplo, en GitHub, una URI de repositorio tiene un aspecto como este: https://github.com/usuario/nombre-repositorio.git)</p>
  </li>
  <li>
    <p>Edita el archivo .gitignore para incluir en √©l los archivos y carpetas que no quieres incluir en el repositorio. M√°s adelante hablaremos del archivo .gitignore con m√°s detalle, porque es muy importante.</p>
  </li>
  <li>
    <p>Haz tu primer commit para a√±adir todo el c√≥digo fuente que ya tienes:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ git add *
 $ git commit -m "Primer commit con todo el c√≥digo preexistente"
</code></pre></div>    </div>
  </li>
  <li>
    <p>Sube el c√≥digo de ese commit a tu repositorio remoto (te pedir√° tu usuario y contrase√±a en GitHub o GitLab):</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ git push
</code></pre></div>    </div>
  </li>
</ol>

<p>Si ahora entras en tu perfil de GitHub o GitLab, ver√°s que el repositorio remoto ya contiene todos los archivos que ten√≠as en tu proyecto (excepto los que se√±alaste en .gitignore). Los repositorios local y remoto ya est√°n creados y puedes empezar a trabajar con normalidad, escribiendo c√≥digo y subi√©ndolo al repositorio remoto cuando lo necesites. Este proceso lo describiremos en detalle enseguida.</p>

<p>Si no has entendido alguno de estos pasos, no te agobies. Enseguida te quedar√°n m√°s claros.</p>

<h4 id="m√°s-cosas-sobre-la-inicializaci√≥n-de-un-repositorio">M√°s cosas sobre la inicializaci√≥n de un repositorio</h4>

<p>Hay otro par de cosas que te interesa hacer al iniciarlizar un repositorio. Solo tendr√°s que hacerlo una vez y, despu√©s, tu repositorio lo recordar√°.</p>

<p>Despu√©s del <em>git init</em>, puedes indicarle al repositorio qu√© usuario de GitHub o GitLab va a realizar los commits. Esto se hace as√≠:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git --config user.name "Mi-nombre-de-usuario"
$ git --config user.email "Mi-email"
</code></pre></div></div>

<p>Para comprobar que la informaci√≥n es correcta, simplemente teclea:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git --config list
</code></pre></div></div>

<h4 id="antes-de-continuar-no-te-olvides-de-gitignore">¬°Antes de continuar! No te olvides de .gitignore</h4>

<p>Una √∫ltima cosita antes de describir c√≥mo es el trabajo cotidiano con git y qu√© significa todo eso de los commits.</p>

<p>Esa cosita es sobre el archivo <strong><em>.gitignore</em></strong>. Es un archivo muy importante que deber√≠a estar en el directorio ra√≠z de tu proyecto. Si no existe, cr√©alo. Ten en cuenta que en los sistemas GNU/Linux y Mac, los archivos cuyo nombre empiezan por un punto se consideran ocultos, por lo que es posible que el archivo est√© ah√≠ sin que lo veas.</p>

<p>Ese archivo <strong>contiene una lista de todas las cosas que no se deben subir al repositorio remoto</strong>. Esto incluye, entre otros:</p>

<ul>
  <li>
    <p><strong>Los archivos de configuraci√≥n</strong>. Es habitual en una aplicaci√≥n web tener un archivo de configuraci√≥n (llamado <em>config.php</em> o algo parecido) con un pu√±ado de variables donde se guarda el host de la base de datos, el usuario y la contrase√±a para ese host, el nombre de la base de datos, etc. Y, vamos a ver, ¬øde verdad quieres que cualquiera que acceda a tu repositorio de GitHub o GitLab vea esa informaci√≥n?</p>

    <p>Adem√°s del problema de seguridad que puede suponerte (sobre todo si, como el 99% de los desarrolladores, usas el acceso root a tu servidor local de bases de datos mientras est√°s desarrollando un nuevo proyecto), es que no tiene sentido subir esa informaci√≥n al repositorio remoto, porque ser√° diferente en cada servidor donde la aplicaci√≥n se ponga en producci√≥n.</p>

    <p>Lo que s√≠ suele hacerse es crear un archivo de configuraci√≥n de ejemplo (algo como config-example.php), donde se muestre la estructur que debe tener config.php pero se dejen en blanco los valores de las variables. Ese archivo s√≠ que puede sincronizarse con el resto del c√≥digo y subirse a GitHub o GitLab.</p>
  </li>
  <li>
    <p><strong>Archivos de recursos que no forman parte de la aplicaci√≥n</strong>. Imagina que est√°s programando una aplicaci√≥n web para una biblioteca. Esa aplicaci√≥n usa algunas im√°genes para construir sus vistas (por ejemplo, una hermosa fotograf√≠a de un libro antiguo para el encabezamiento). Esas im√°genes <strong>s√≠</strong> forman parte de la aplicaci√≥n y <strong>s√≠</strong> deben subirse al repositorio remoto.</p>

    <p>Pero ahora sup√≥n que, como es l√≥gico, para probar la aplicaci√≥n has creado un mont√≥n de libros falsos en tu base de datos local. Cada vez que a√±ades un libro falso, le asignas una imagen de la portada (falsa tambi√©n), que la aplicaci√≥n almacenar√° en alg√∫n directorio del servidor local. Esas im√°genes forman parte de los datos de prueba, no de la propia aplicaci√≥n, y, por tanto <strong>no</strong> deber√≠an subirse a GitHub ni GitLab. El directorio completo donde almacenes esas imagenes deber√≠a incluirse en .gitignore.</p>

    <p>Si no lo haces as√≠, llenar√°s el repositorio remoto de basurilla y, adem√°s, har√°s que ocupe mucho m√°s espacio del necesario, hasta el extremo que una clonaci√≥n del repositorio puede tardar varias horas y ocupar muchos gigabytes. Ten en cuenta que el repositorio no solo contiene el estado actual del proyecto, sino tambi√©n <em>todos los estados anteriores</em>, lo que incluye todas las im√°genes de libros falsos que hayas podido a√±adir alguna vez durante el desarrollo.</p>

    <p>Esto no solo es aplicable a im√°genes, sino a cualquier otro recurso que use la aplicaci√≥n y que no forme parte de la propia aplicaci√≥n: sonidos, fuentes tipogr√°ficas, v√≠deos, etc.</p>
  </li>
  <li>
    <p><strong>Bibliotecas de terceros</strong>. A menudo, recurrimos a bibliotecas de terceros para usarlas en nuestra aplicaci√≥n. Incluir ese c√≥digo en nuestro repositorio nos puede meter en un embrollo legal (m√≠rate bien la licencia de uso de <em>todas</em> las bibliotecas que vayas a utilizar) y, adem√°s, nos puede hacer engordar innecesariamente el repositorio. Tendr√°s que valorar una a una si es conveniente incluir determinada librer√≠a o no. Las librer√≠as no incluidas deber√°n ser instaladas manualmente cuando la aplicaci√≥n se despliegue en un servidor, lo cual deber√°s explicar muy bien en la documentaci√≥n.</p>

    <p>Por ejemplo, en el caso de Laravel, se aconseja no incluir la carpeta ‚Äúvendor‚Äù en el repositorio remoto. Es decir, hay que a√±adir la carpeta ‚Äúvendor‚Äù a .gitignore antes de la primera sincronizaci√≥n. En ‚Äúvendor‚Äù se encuentran todas las librer√≠as de terceros que usa Laravel. Entonces, para desplegar esta aplicaci√≥n en un servidor, ¬øde d√≥nde sacamos todas esas librer√≠as? F√°cil: cuando despleguemos el c√≥digo en un servidor, solo tendremos que ejecutar ‚Äúcomposer update‚Äù en el directorio ra√≠z de la aplicacion, y el propio composer se encargar√° de instalar las librer√≠as que sean necesarias en las versiones m√°s adecuadas para ese servidor.</p>
  </li>
</ul>

<h1 id="a13-trabajo-b√°sico-con-git">A1.3. Trabajo b√°sico con Git</h1>

<p>Ya tenemos nuestros repositorios local y remoto inicializados y conectados, y el archivo .gitignore a punto. ¬øQu√© hacemos ahora?</p>

<p>Muy f√°cil: ponernos a trabajar como si git no existiera.</p>

<p>Y luego, cuando des por finalizada una parte de la aplicaci√≥n (un m√©todo, una clase, una funcionalidad concreta: t√∫ decides cada cu√°nto tiempo haces esto), pasarla a la <strong><em>Staging Area</em></strong>.</p>

<h2 id="a131-un-momento-staging-qu√©eee">A1.3.1. Un momento‚Ä¶ ¬øStaging qu√©eee?</h2>

<p>La <strong><em>Staging Area</em></strong> es como la pista de despegue de Git.</p>

<p>La idea es la siguiente: Git no quiere sincronizar tus archivos con el repositorio remoto de forma autom√°tica (como hacen las plataformas para el p√∫blico general, como Google Drive o Dropbox), porque sabe que los programadores producimos mucha basura al cabo del d√≠a.</p>

<p>Si cada vez que escribimos una basurilla, Git la sincronizara con el remoto, el resto de personas del proyecto estar√≠an recibiendo nuestra basura de forma permanente. Y nosotros la de esas personas.</p>

<p>Y esparcir basura no es una buena pol√≠tica.</p>

<p>As√≠ que Git quiere que seas muy consciente de cu√°ndo deseas sincronizar algo, y de qu√© es lo que deseas sincronizar. Quiere que te tomes el trabajo (que tampoco es para tanto, la verdad) de emplear medio minuto de tu tiempo para decirle: ‚Äúeh, Git, he estado curr√°ndome estos dos archivos esta ma√±ana y creo que <em>ahora</em> ya no son una basura‚Äù.</p>

<p>Para eso sirve la <em>Staging Area</em>.</p>

<p>Tienes que pasar los archivos que ya no son una basura a la <em>Staging Area</em>. Y tienes que hacerlo t√∫, generalmente cuando hayas terminado una funcionalidad y la hayas probado adecuadamente. Lo bastante como para que no te averg√ºence que otras personas del equipo reciban tu c√≥digo.</p>

<p>Para <strong>a√±adir archivos a la <em>Staging Area</em></strong> se usa el comando <strong>git add</strong>, as√≠:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git add archivo1 archivo2 archivo3 ...
</code></pre></div></div>

<p>Se pueden a√±adir carpetas completas:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git add carpeta1 carpeta2 ...
</code></pre></div></div>

<p>Y tambi√©n se pueden usar s√≠mbolos comod√≠n, como el asterisco. De modo que, si est√°s muy, pero que muy seguro/a de que todos los archivos que han andado tocando desde el √∫ltimo commit est√°n en un estado aceptable, puedes hacer esto para que git se encargue de <em>a√±adir todos los archivos modificados recientemente a la Staging Area</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git add *
</code></pre></div></div>

<p>Por fin, cuando tengas una o varias cosas preparadas en la <em>Staging Area</em>‚Ä¶ Bueno, entonces llega el momento de hacer un <strong>commit</strong>.</p>

<h2 id="a132-hacer-commit">A1.3.2. Hacer commit</h2>

<p>Un <strong>commit</strong> (palabra que podr√≠amos traducir por ‚Äúperpetrar‚Äù) consiste en empaquetar todos los cambios de la <em>Staging Area</em> para enviarlos a otro repositorio, normalmente el repositorio remoto.</p>

<p>El decir, con el commit le decimos a Git: ‚Äúquiero que prepares todo el c√≥digo que te he puesto en la <em>Staging Area</em> a para enviarlo a GitHub‚Äù (o a d√≥nde sea).</p>

<p>Se puede hacer un commit por cada peque√±a modificaci√≥n que introducimos en la <em>Staging Area</em>, o se pueden preparar muchos archivos en la <em>Staging Area</em> y luego empaquetarlos en un √∫nico mega-commit. Eso lo decid√≠s t√∫ y tu equipo de desarrollo. Pero suele ser buena idea hacer commits de funcionalidades o tareas individuales.</p>

<p>Es decir, si esta ma√±ana he estado trabajando en dos funcionalidades, ‚ÄúA√±adir usuarios nuevos‚Äù y ‚ÄúModificar la vista de edici√≥n de usuarios‚Äù, es mejor que haga dos commits separados para cada una de esas funcionalidades.</p>

<p>Esto es as√≠ porque, a cada commit, le tengo que a√±adir <strong><em>obligatoriamente</em></strong> un texto descriptivo donde indique qu√© cambios estoy subiendo con ese commit.</p>

<p>El comando para hacer un commit es:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git commit -m "Mensaje"
</code></pre></div></div>

<p>Ahora saco mi bola de cristal y te digo: no tardar√°s ni una semana en empezar a hacer commits cuyo texto descriptivo ser√° algo como ‚Äúaslkdaslkjda‚Äù, ‚Äúaaa‚Äù, ‚Äúyoqu√©s√©‚Äù. Eso es una p√©sima idea. Antes o despu√©s, alguien del equipo meter√° la pata, subir√° un cambio indebido y todo el repositorio explotar√°. Entonces, intentar√©is regresar a un estado en el que el c√≥digo a√∫n funcionaba, pero encontrar√©is que los √∫ltimos commits tienen explicaciones incomprensibles como ‚Äúaslkdaslkjda‚Äù, ‚Äúaaa‚Äù y ‚Äúyoqu√©s√©‚Äù. Y sudar√©is tinta para descubrir cu√°l fue el commit explosivo.</p>

<p>Los commits deben llevar textos descriptivos breves pero informativos. Por ejemplo: ‚ÄúArreglo el fallo del id de usuario inexistente al actualizar foto de perfil‚Äù o ‚ÄúElimino el bot√≥n de modificar de la vista de libros‚Äù.</p>

<p>Pero, ¬°ojo!, hacer commit <strong>no sube los archivos al repositorio remoto</strong>. Todav√≠a no. Recuerda que Git quiere que est√©s muy seguro/a de que subes lo que realmente tienes que subir, as√≠ que a√∫n te falta un √∫ltimo paso: hacer <strong><em>push</em></strong>.</p>

<h2 id="a133-subir-el-commit-hacer-push">A1.3.3. Subir el commit: hacer push</h2>

<p>El √∫ltimo paso para enviar nuestros cambios locales al repositorio remoto (t√≠picamente, GitHub o GitLab) consiste en hacer <strong><em>push</em></strong>. Es decir, literalmente, ‚Äúempujar‚Äù los cambios al repositorio remoto.</p>

<p>La operaci√≥n <em>push</em> enviar√° todos los commits que a√∫n no se hayan enviado al repositorio remoto. A partir de ese momento, estar√°n disponibles para el resto de miembros del equipo. Pero solo a partir de ese momento.</p>

<p>Para hacer push, basta con escribir:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git push
</code></pre></div></div>

<p>Lo normal es que el repositorio remoto te pida tu nombre de usuario y contrase√±a, pero eso depender√° de si el acceso a ese repositorio est√° autenticado o no. Por supuesto, tanto GitHub como GitLab te solicitar√°n que te identifiques.</p>

<h2 id="a134-bajar-la-√∫ltima-versi√≥n-del-c√≥digo-hacer-pull">A1.3.4. Bajar la √∫ltima versi√≥n del c√≥digo: hacer pull</h2>

<p>Si podemos subir nuestros cambios al repositorio remoto, tendremos que tener una forma de bajar los cambios del resto de miembros del equipo, ¬øverdad?</p>

<p>Por supuesto, existe un comando para ello. Es este:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git pull
</code></pre></div></div>

<p>Es recomendable hacer pull antes de hacer push, por si alguien ha tocado alguno de los archivos que nosotros pretendemos subir. En ese caso, Git nos avisar√° del conflicto y nos ayudar√° a resolverlo (m√°s adelante veremos c√≥mo). No podremos hacer push hasta resolver ese conflicto, para evitar p√©rdidas de c√≥digo.</p>

<h2 id="a135-resumi√©ndolo-todo-flujo-de-trabajo-habitual-con-git">A1.3.5. Resumi√©ndolo todo: flujo de trabajo habitual con git</h2>

<p>Si resumimos lo dicho hasta ahora, tenemos que, despu√©s de inicializar el repositorio (cosa que hay que hacer solo una vez), el trabajo cotidiano con Git consiste en:</p>

<ol>
  <li>Desarrollar nuestra aplicaci√≥n con normalidad, como si git no existiera.</li>
  <li>Cuando terminamos de hacer algo, a√±adirlo a la <em>Staging Area</em> (git add).</li>
  <li>Cada cierto tiempo, o cuando acabamos una funcionalidad, empaquetar todos los cambios que esperan en la <em>Staging Area</em> en un commit (git commit).</li>
  <li>Bajarnos los commits del resto de miembros del equipo (git pull)</li>
  <li>Subir nuestros commits al repositorio remoto (git push)</li>
</ol>

<p>Podemos verlo gr√°ficamente en el siguiente esquema. Las tres primeras columnas (workspace, Staging Area y Local Repo) est√°n en nuestro ordenador de trabajo. El repositorio remoto (Remote Repo) est√° en un servidor, como GitHub o GitLab.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Workspace   Staging area (INDEX)  Local repo (HEAD)   Remote repo
    |             |                     |                  |
    | git add ‚Üí   |                     |                  |
    |             |    git commit ‚Üí     |                  |
    |             |                     |                  |
    | ‚Üê ‚Üê ‚Üê ‚Üê ‚Üê   |     ‚Üê ‚Üê ‚Üê ‚Üê ‚Üê       |   ‚Üê git pull     |
    |             |                     |                  |
    |             |                     |    git push ‚Üí    |
    |             |                     |                  |
    |             |                     |                  |
</code></pre></div></div>

<p>Un √∫ltimo apunte: te voy a chivar un comando muy √∫til de git cuando no est√°s muy seguro de qu√© archivos has estado tocando √∫ltimamente (¬øa qui√©n no le ha pasado eso? ¬øEh?). Este comando te resumir√° el estado de tu repositorio local, indic√°ndote qu√© archivos han sido modificados (pero no est√°n en la Staging Area), qu√© archivos est√°n preparados en la Staging Area (pero no en un commit) y, por supuesto, qu√© commits est√°n hechos pero a√∫n sin subir.</p>

<p>Todo eso, gratis y tecleando este humilde comando:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git status
</code></pre></div></div>

<p>¬øEs potente o no es potente este Git? Pues a√∫n no has visto nada.</p>

<h1 id="a14-algunas-cosillas-avanzadas-sobre-git">A1.4. Algunas cosillas avanzadas sobre git</h1>

<p>Solo con lo que hemos visto hasta ahora (add, commit, push y pull) ya tienes suficiente para empezar a funcionar con git. Luego, conforme te surjan otras necesidades, puedes ir curioseando por internet para profundizar en ciertos aspectos.</p>

<p>Una de esas ‚Äúnecesidades‚Äù que te surgir√°n antes o despu√©s consiste en lo siguiente:</p>

<p>Imag√≠nate la escena: un d√≠a llegas a clase despu√©s de haberte acosatado a las tantas trabajando en tu proyecto. Antes de acostarte hiciste un push para subir todos tus cambios y puedes jurar que todo funcionaba perfectamente. Pero ahora, t√∫ y el resto de miembros de tu equipo acab√°is de hacer pull y‚Ä¶ ¬°BUM! El proyecto entero salta por los aires. El homepage no carga. Otras rutas que <em>est√°s seguro</em> de que funcionaban hace unas horas ahora no responden.</p>

<p>¬øQu√© narices ha pasado?</p>

<p>Tranquilidad: ah√≠ est√° Git para sacarte del embrollo.</p>

<h2 id="a141-regreso-al-pasado-c√≥mo-revertir-los-cambios">A1.4.1. Regreso al pasado: c√≥mo revertir los cambios</h2>

<p>Las causas de un desastre como ese pueden ser tantas que, en la pr√°ctica, es como si fueran infinitas. Un problema con el proxy, un merge mal hecho, una desconfiguraci√≥n de uno de los servidores locales que ha afectado a alg√∫n archivo clave, un error de alg√∫n miembro del equipo que ha sobreescrito cientos de archivos con versiones incorrectas‚Ä¶ Causas infinitas, como te digo.</p>

<p>No suele compensar el esfuerzo de buscar la raz√≥n √∫ltima de lo que ha ocurrido, salvo que os pase esto con cierta regularidad: entonces s√≠ que es cuesti√≥n de preocuparse.</p>

<p>La mayor√≠a de las veces es un problema puntual que puede resolverse de un modo muy simple: volviendo a la √∫ltima versi√≥n estable.</p>

<p>En primer lugar, si lo que quieres es revertir cambios de los que <strong>a√∫n no has hecho commit</strong>, es tan f√°cil como:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git reset --hard
</code></pre></div></div>

<p>Pero, la mayor parte de las veces, el problema viene de cambios de los que no solo ya se ha hecho commit, sino que incluso se han subido al repositorio remoto. ¬øC√≥mo descartamos esos cambios para volver a un estado anterior?</p>

<p>En primer lugar, si a√∫n no lo has hecho, ejecuta un <strong>git pull</strong> para traerte la √∫ltima versi√≥n del c√≥digo a tu repositorio local.</p>

<p>Luego, utiliza el comando <strong>git log</strong>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git log (muestra historial de cambios)
$ git log --oneline (muestra historial de cambios simplificado)
</code></pre></div></div>

<p>Con esto obtendr√°s una lista, ordenada por cronolog√≠a inversa (de m√°s reciente a m√°s antiguo), de todos los commits que has hecho en el repositorio. Observa que cada commit est√° identificado con un id √∫nico en hexadecimal. Cada id de commit est√° acompa√±ado de su descripci√≥n.</p>

<p>Si hab√©is sido cuidadosos con los commits y les hab√©is puesto descripciones representativas (y no ‚Äúasdfasdf‚Äù o ‚Äúaaa‚Äù), resutar√° f√°cil localizar en esa lista el commit causante del destrozo.</p>

<p>A continuaci√≥n, usa el comando <strong>git revert</strong> para regresar al commit <em>inmediatamente anterior</em> a aquel en el que se produjo el caos:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git revert HEAD [main id-de-commit] revert "Mensaje del revert"
</code></pre></div></div>

<p>Lo que hace este comando es devolver tu repositorio local (HEAD) al commit ‚Äúid-del-commit‚Äù. Pero, ojo, que no elimina todos los commits posteriores, sino que crea un nuevo commit (main) con el ‚ÄúMensaje del revert‚Äù que le hayas indicado. En este nuevo commit habr√° desaparecido todo el c√≥digo conflictivo. El proyecto volver√° a estar en un estado estable.</p>

<p>Ahora bastar√° con hacer <strong>git push</strong> para subir el nuevo commit al repositorio remoto y que todos los miembros del equipo puedan replicarlo en sus m√°quinas.</p>

<p>Es posible que, en el proceso, hay√°is perdido algo de c√≥digo valioso: todo depende de cu√°nto hay√°is tenido que retroceder en el historial de commits hasta alcanzar un estado v√°lido. Pero ese c√≥digo en realidad no se ha perdido, porque los commits siguen ah√≠, en el historial de git.</p>

<p>Existe una forma de poner el repositorio local en un commit concreto. Si lo haces y abres cualquier archivo fuente, lo encontrar√°s como estaba en ese commit, no como est√° en el √∫ltimo. ¬øNo es maravilloso? As√≠, podr√°s recuperar manualmente el c√≥digo que pudiera haberse perdido al hacer el <em>git revert</em>.</p>

<p>El comando que te permite saltar moment√°neamente a cualquier commit es <strong>git checkout</strong>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git checkout id-del-commit
</code></pre></div></div>

<p>Ahora puedes ver y rescatar el c√≥digo fuente v√°lido sin temor: nada de lo que hagas en este estado afectar√° al tu proyecto, porque los cambios se perder√°n cuando salgas de este ‚Äúviaje en el tiempo‚Äù (salvo que crees una nueva rama del proyecto, pero esa es otra historia).</p>

<p>Y, para regresar al presente, es decir, al √∫ltimo commit, basta con teclear:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git checkout main
</code></pre></div></div>

<h2 id="a142-cuando-dos-personas-se-encaprichan-del-mismo-archivo">A1.4.2. Cuando dos personas se encaprichan del mismo archivo</h2>

<p>Cuando ejecutas <em>git pull</em>, traes a tu repositorio local las versiones m√°s recientes de todos los archivos del proyecto. Esto ya lo sab√≠amos.</p>

<p>Si <em>git pull</em> se ejecuta sin contratiempos, aparecer√° un mensaje inform√°ndote de ello.</p>

<p>Pero los contratiempos existen, qu√© le vamos a hacer. La vida ser√≠a muy aburrida y predecible sin ellos.</p>

<p>El contratiempo m√°s habitual, con diferencia, al hacer <em>git pull</em> es el aviso de un conflicto el alguno de los archivos modificados en el repositorio remoto. Eso quiere decir que <em>t√∫</em> has estado tocando el c√≥digo de un archivo <em>al mismo tiempo que otra persona de tu equipo</em>.</p>

<p>Supongamos que, en un archivo A, t√∫ has a√±adido las l√≠neas A1, A2 y A3, mientras que otra persona ha a√±adido las l√≠neas A4, A5 y A6. Si la otra persona ha subido el archivo A al repositorio remoto antes que t√∫, git se dar√° cuenta cuando intentes hacer <em>git pull</em> de que tu copia local del archivo y la que hay en el repositorio remoto no coinciden: no solo porque la tuya tiene las nuevas l√≠neas A1, A2 y A3, sino porque a la tuya <em>le faltan</em> las l√≠neas A4, A5 y A6.</p>

<p>En ese caso, y para no perder ninguna de las nuevas l√≠neas de c√≥digo, git te mostrar√° un mensaje de advertencia y crear√° una versi√≥n nueva del archivo A en la que estar√°n <strong>todas las l√≠neas de c√≥digo nuevas, tanto las tuyas como las de la otra persona</strong>, rodeadas de unas marcas de texto como estas:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
        espacio
    ============
        Espacio
    &gt;&gt;&gt;&gt;&gt;&gt;&gt; nueva-rama
</code></pre></div></div>

<p>Ahora, lo √∫nico que tienes que hacer es buscar manualmente esas l√≠neas conflictivas y resolverlas a mano, es decir, quedarte con las l√≠neas correctas y borrar las que no lo sean. Borra tambi√©n todas las marcas que ha puesto ahi git para indicarte el conflicto.</p>

<p>Si usas cualquier editor de texto medianamente potente, te mostrar√° esas l√≠neas resaltadas e incluso te ayudar√° a encontrarlas.</p>

<p>Una vez que hayas resuelto manualmente las l√≠neas en conflicto, basta con guardar los cambios y hacer <em>git add</em> y <em>git commit -m ‚ÄúResolviendo el conflicto bla,bl,bla‚Äù</em> para que el <em>git pull</em> y el <em>git push</em> vuelvan a funcionar a la perfecci√≥n.</p>

<h2 id="a143-proyectos-que-se-complican-c√≥mo-crear-ramas">A1.4.3. Proyectos que se complican: c√≥mo crear ramas</h2>

<p>Imagina esta situaci√≥n: tienes un proyecto ya en marcha, con una versi√≥n m√°s o menos estable funcionando, y entonces surge la necesidad de desarrollar una nueva funcionalidad.</p>

<p>Y esta nueva funcionalidad va a poner patas arriba una parte importante del c√≥digo y va a dejar la aplicaci√≥n hecha unos zorros durante un tiempo.</p>

<p>Si trabajas con tu repositorio como hemos hecho hasta ahora, el resultado es que, durante ese tiempo, todo tu proyecto dejar√° de funcionar. No podr√°s hacer demos a los clientes (ni a tus profesores/as), no podr√°s probar la aplicaci√≥n, no podr√°s cargarla con datos reales, etc. ¬°Todo quedar√° paralizado hasta que la nueva funcionalidad est√© en marcha!</p>

<p>En un equipo de desarrollo grande, esta es una situaci√≥n cotidiana que provocar√≠a que gran parte de la gente se tuviera que quedar de brazos cruzados a la espera de la finalizaci√≥n de la nueva funcionalidad. Pero incluso en un equipo peque√±o es un engorro llegar a este extremo.</p>

<p>Para evitarlo, existen <strong>las ramas</strong> (<em>branches</em>) de Git.</p>

<p>Una rama no es m√°s que una copia del repositorio que puede evolucionar por su cuenta mientras la rama original permanece inalterada.</p>

<p>Los desarrolladores/as que trabajen en esa rama pueden as√≠ trabajar en la nueva funcionalidad sin que el resto del equipo se vea afectado. Cuando la nueva funcionalidad se termine, lo √∫nico que hay que hacer es fusionar las dos ramas. Esto puede ser un trabajo √≠mprobo si se han estado modificando los mismos archivos en la rama principal y en la rama nueva, pero no se trata de un fallo de Git, que quede claro, sino de un fallo de organizaci√≥n del equipo.</p>

<p>Y si la nueva funcionalidad nunca llega a terminarse (cosa que puede ocurrir por miles de razones), no pasa nada: la rama se elimina, o simplemente se abandona, y la rama principal sigue intacta.</p>

<p>Crear una rama nueva es tan sencillo como usar este comando:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git branch nombre-nueva-rama
</code></pre></div></div>

<p>El comando <em>git branch</em> tiene muchas otras posibilidades. Aqu√≠ te pongo unas cuantas:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git branch --list          (saca un listado de todas las ramas existentes)
$ git branch -d nombre-rama  (elimina una rama)
$ git branch -D nombre-rama  (elimina una rama a lo bestia, incluso si tiene cambios sin fusionar)
$ git branch -m nuevo-nombre (cambia en nombre de la rama actual)
</code></pre></div></div>

<p>Ten en cuenta que, cuando creas una rama, <em>a√∫n no est√°s trabajando en ella</em>. Si quieres cambiar a esa rama para empezar a trastear con ella sin tocar a la principal, debes hacer un <em>git checkout</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git checkout nombre-rama
</code></pre></div></div>

<p>Por √∫ltimo, para fusionar una rama con otra (t√≠picamente, con la rama principal o <em>main</em>), tienes que seguir estos pasos:</p>

<ol>
  <li>Aseg√∫rate de estar situado en la rama que va a recibir la fusi√≥n. Si esa rama es <em>main</em>, tienes que hacer:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ git checkout main
</code></pre></div>    </div>
  </li>
  <li>Haz un <em>git pull</em> para tener disponible la √∫ltima versi√≥n del c√≥digo.</li>
  <li>Realiza la fusi√≥n de las dos ramas con <em>git merge</em>:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ git merge nombre-rama
</code></pre></div>    </div>
  </li>
</ol>

<p>En este punto, tendr√°s que resolver manualmente los conflictos que puedan surgir (si los hay), como hemos explicado m√°s arriba.</p>

<h2 id="a144-a√∫n-quieres-saber-m√°s">A1.4.4. ¬øA√∫n quieres saber m√°s?</h2>

<p>Git es un sistema de control de versiones incre√≠blemente completo. Sus creadores parecen haber pensado en escenarios de lo m√°s aberrante y han tenido en cuenta casi cada cosa que puede suceder en un proyecto complejo. Si no, no se explica la enorme cantidad de comandos y posibilidades que ofrece.</p>

<p>Si necesitas saber m√°s cosas sobre Git, internet est√° plagada de contenidos de calidad (y otros bastante penosos) sobre este sistema.</p>

<p>Como siempre te recomiendo, acude en primer lugar a la referencia oficial: https://git-scm.com/docs</p>

<p>Personalmente, a m√≠ me gustan mucho los tutoriales de Atlassian. Aunque est√°n orientados a BitBucket (un servicio competidor de GitHub o GitLab), casi todas sus recomendaciones son aplicables a cualquier servidor Git. Los puedes encontrar aqu√≠: https://www.atlassian.com/es/git/tutorials</p>
:ET