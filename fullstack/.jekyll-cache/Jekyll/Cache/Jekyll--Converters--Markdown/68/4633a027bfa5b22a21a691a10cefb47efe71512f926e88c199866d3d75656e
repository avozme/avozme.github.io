I"æ<h1 class="no_toc" id="4-vuejs">4. Vue.js</h1>


<p>Vue.js es un <strong>framework para Javascript</strong> orientado al <strong>dise√±o de interfaces de usuario</strong> para aplicaciones web y a la <strong>creaci√≥n de aplicaciones OVA</strong> (One View Application) o SPA (Single Page Application).</p>

<p>Es similar a otros frameworks como <strong>Angular</strong> o <strong>React</strong>, aunque m√°s f√°cil de aprender (o, al menos, un poco m√°s f√°cil). Al igual que estos dos, tiene licencia de software libre.</p>

<p>En este tema vamos a aprender a usar Vue.js para consumir los API REST que ya sabemos construir, de modo que podamos crear una aplicaci√≥n de tipo OVA o SPA de forma r√°pida, eficiente y flexible.</p>

<div style="color: red; font-size: 120%"><strong>MATERIAL EN PREPARACI√ìN</strong></div>

<!--


## A3.1. ¬øQu√© es Vue.js?


Para usar Vue.js en un proyecto se puede optar, al menos, por tres v√≠as diferentes:

1. **Incluirlo como una librer√≠a Javascript m√°s** (mejor desde un CDN). Por ejemplo:

   ```html
   <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
   ```

2. **Usarlo en combinaci√≥n con un servidor Node**. Hay que instalar Node.js y npm en el lado del servidor. Esto permite desarrollar toda la aplicaci√≥n web con Javascript, de modo que el c√≥digo sea, al menos en teor√≠a, m√°s f√°cil de desarrollar y mantener, adem√°s de m√°s eficiente.

3. **Usarlo en combinaci√≥n con Laravel**. En este caso, como es l√≥gico, hay que tener Laravel corriendo en el servidor. Laravel proporciona su propio servidor Node. De este modo, conseguimos combinar la facilidad para la construcci√≥n de interfaces de usuario que proporciona Vue con la potencia de PHP y Laravel.

## A3.2. Algunos ejemplos sencillos

Antes de explicar cu√°l es la estructura t√≠pica de una aplicaci√≥n echa con Vue, vamos a ver algunos ejemplos sencillos de entender. As√≠ quedar√° luego mucho m√°s claro c√≥mo se escriben este tipo de aplicaciones.

### Ejemplo 1: hola, mundo

Por supuesto, tenemos que empezar por *Hola mundo*. Observa detenidamente este c√≥digo:

```html
<!DOCTYPE html>
<html lang="es">

<head>
    <title>Pruebas Vue.js</title>
</head>

<body>
    <div id="app">
        {{ message }}
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/vue@3.0.0/dist/vue.global.prod.js"></script>
    <script>
        const app = Vue.createApp({
            data() {
                return {
                    message: '¬°Hola mundo!'
                }
            }
        }).mount('#app')
    </script>

</body>

</html>
```

Observa c√≥mo la p√°gina consta √∫nicamente de un <div> con el id "app", y dentro solo aparece el contenido ``````. Se parece a Blade, pero no lo es: se trata de un dato de Vue.js.

M√°s abajo, despu√©s de incluir Vue 3 a trav√©s de un CDN, creamos una instancia de un objeto Vue con el m√©todo est√°tico ***createApp()***, al que le definimos un m√©todo ***data()*** que contiene los datos de Vue.js. 

En este ejemplo, el √∫nico dato es *message*. Al establecer el valor de *message* como "Hola mundo", autom√°ticamente aparecer√° el texto "Hola mundo" en el contenido ```{{message}}``` de nuestro <div>.

Por √∫ltimo, mediante el m√©todo ***mount()*** enlazamos el objeto Vue con un elemento del √°rbol DOM de la p√°gina, en este caso el div *#app*.

Por supuesto, un objeto Vue podr√≠a tener muchos m√°s datos adem√°s de *message* (tantos como necesitemos), cuya procedencia puede ser una base de datos del servidor, por ejemplo.

Con este sencillo ejemplo tal vez ya puedas vislumbrar la facilidad con la que pueden construirse vistas usando Vue para crear plantillas HTML y PHP para extraer datos del servidor. Pero, si a√∫n no lo ves, no te preocupes que vamos a poner ejemplos un poco m√°s complejos.

### Ejemplo 2: pregunta y respuesta

En el siguiente ejemplo, puedes ver un <div> parecido al anterior pero que usa dos variables, llamadas `````` y  ``````, cuyos valores se asignan desde Vue. Si cambiamos din√°micamente los valores de "pregunta" y "respuesta", el c√≥digo HTML tambi√©n cambiar√°.

```html
<!DOCTYPE html>
<html lang="es">

<head>
    <title>Pruebas Vue.js</title>
</head>

<body>
    <div id="app">
        <p>La pregunta es: {{ pregunta }}</p> 
        <p>La respuesta es: {{ respuesta }}</p> 
    </div>

    <script src="https://cdn.jsdelivr.net/npm/vue@3.0.0/dist/vue.global.prod.js"></script>
    <script>
        const app = Vue.createApp({
            data() {
                return {
                    pregunta: "¬øC√≥mo te llamas?",
                    respuesta: "Pepito P√©rez"
                }
            }
        }).mount('#app')
    </script>
</body>

</html>
```

### Ejemplo 3: condicional simple

Con Vue tambi√©n puede hacerse una salida HTML condicional, que dependa de los valores de las variables de Vue.

Aqu√≠ puedes ver un ejemplo sencillo. Si la variable *visible* vale *true*, se ver√° el texto "Ahora puedes verme". En el momento en el que cambie el valor de *visible* a *false*, el texto despaparecer√°. Ten en cuenta que esto sucede din√°micamente, es decir, con la p√°gina ya cargada.

```html
<!DOCTYPE html>
<html lang="es">
<head>
    <title>Pruebas Vue.js</title>
</head>
<body>
    <div id="app">
        <p v-if="visible">Ahora puedes verme</p>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/vue@3.0.0/dist/vue.global.prod.js"></script>
    <script>
        const app = Vue.createApp({
            data() {
                return {
                    visible: true
                }
            }
        }).mount('#app')
    </script>

</body>

</html>
```

### Ejemplo 4: bucle for

Igual que puede hacerse una salida HTML condicional, tambi√©n puede generarse una salida HTML a partir de un array recorrido con un bucle de tipo for.

Observa el siguiente ejemplo, donde un array con nombres de animales genera la salida HTML a partir de su contenido:

```html
<!DOCTYPE html>
<html lang="es">

<head>
    <title>Pruebas Vue.js</title>
</head>

<body>
    <div id="app">
        <p v-for="animal in arrayAnimales"> {{ animal }} </p>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/vue@3.0.0/dist/vue.global.prod.js"></script>
    <script>
        const app = Vue.createApp({
            data() {
                return {
                    arrayAnimales: ['Perro', 'Gato', 'Oveja', 'Caballo']
                }
            }
        }).mount('#app')
    </script>
    
</body>

</html>
```

### Ejemplo 5: formularios

Con Vue.js se pueden asociar campos de formulario a variables de Vue, de modo que si cambia una, cambiar√° tambi√©n la otra din√°micamente.

En el siguiente ejemplo hemos asociado un campo de un formulario ("nombre") con un atributo del objeto Vue llamado tambi√©n "nombre".

Observa que, para hacer ese enlace efectivo, hay que definir una propiedad HTML llamada *v-model* con el mismo identificador que el dato de Vue.

```html
<!DOCTYPE html>
<html lang="es">

<head>
    <title>Pruebas Vue.js</title>
</head>

<body>
    <div id="app">
        <p>Nombre: <input type="text" v-model="nombre"></p>
        <p>Tu nombre es: {{ nombre }}</p>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/vue@3.0.0/dist/vue.global.prod.js"></script>
    <script>
        const app = Vue.createApp({
            data() {
                return {
                    nombre: 'Pepito'
                }
            }
        }).mount('#app');
    </script>
</body>

</html>
```

A partir de este momento, si cambiamos din√°micamente el valor de *data.nombre*, el campo del formulario tambi√©n cambiar√°, as√≠ como el texto "Tu nombre es: ...". Y, al contrario, si escribimos algo en el campo del formulario, cambiar√° el valor de la variable *data.nombre* y, en consecuencia, el texto "Tu nombre es: ..."

### Ejemplo 6: evento click

Otra cosa que puede hacerse con Vue, como es l√≥gico, es capturar los eventos y asociarlos a m√©todos.

Vue tiene abreviaturas para todos los eventos HTML, de modo que resulta f√°cil asocialos a m√©todo de nuestro objeto Vue.

Observa c√≥mo en el siguiente ejemplo se asocia el evento "click" de un bot√≥n al m√©todo *saludar()* del objeto Vue:

```html
<!DOCTYPE html>
<html lang="es">

<head>
    <title>Pruebas Vue.js</title>
</head>

<body>
    <div id="app">
        <p>Nombre: <input type="text" v-model="nombre"></p>
        <p><button v-on:click="saludar">P√∫lsame</button></p>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/vue@3.0.0/dist/vue.global.prod.js"></script>
    <script>
        const app = Vue.createApp({
            data() {
                return {
                    nombre: ''
                }
            },
            methods: {
                saludar() {
                    alert('Hola, ' + this.nombre);
                }
            }
        }).mount('#app')
    </script>    
</body>

</html>
```

### Ejemplo 7: evento key

Otro evento habitual que conviene capturar es el de pulsaci√≥n de una tecla concreta sobre un elemento HTML. 

En el siguiente ejemplo, capturaremos la pulsaci√≥n de la tecla *Enter* en el campo "nombre" del formulario. Al hacerlo, se ejecutar√° el m√©todo *saludar()*.

F√≠jate en que el evento "pulsar la tecla *Enter*" se abrevia, en Vue, *@keyup.enter*, y mira lo f√°cil que resulta asociarlo a un m√©todo el objeto Vue:

```html
<!DOCTYPE html>
<html lang="es">

<head>
    <title>Pruebas Vue.js</title>
</head>

<body>
    <div id="app">
        <p>Nombre: <input type="text" @keyup.enter="saludar" v-model="nombre"></p>
        <p><button @click="saludar">P√∫lsame</button></p>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/vue@3.0.0/dist/vue.global.prod.js"></script>
    <script>
        const app = Vue.createApp({
            data() {
                return {
                    nombre: ''
                }
            },
            methods: {
                saludar() {
                    alert('Hola, ' + this.nombre);
                }
            }
        }).mount('#app')
    </script>    
</body>

</html>
```

### Ejemplo 8: componente "Hola mundo"

Algo fundamental en los frameworks como Vue son los **componentes**.

Un **componente** es un trozo de c√≥digo HTML asociado a un objeto Vue y, por tanto, con sus propios datos y m√©todos que pueden actuar sobre el HTML. 

Los componentes pueden reutilizarse cuantas veces sea necesario. Son como las piezas que componente una web.

M√°s adelante hablaremos m√°s despacio de los componentes. Por ahora, te presento el ejemplo m√°s sencillo posible. Se trata de un <div> con el t√≠pico texto "Hola mundo" en su interior. Observa c√≥mo se registra el componente usando la expresi√≥n **Vue.createApp().component**. Durante ese registro se le asocia un nombre ('hola-mundo') y un c√≥digo HTML (declarado previamente como ```const holaMundo```).

Ese componente puede usarse todas las veces que haga falta. En este ejemplo lo usamos tres veces, por lo que el texto "Hola mundo" aparecer√° tres veces en la ventana del navegador.

```html
<!DOCTYPE html>
<html lang="es">

<head>
    <title>Pruebas Vue.js</title>
</head>

<body>
    <div id="app">
        <hola-mundo></hola-mundo>
        <hola-mundo></hola-mundo>
        <hola-mundo></hola-mundo>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/vue@3.0.0"></script>
    <script>
        const holaMundo = {
            template: `<div>¬°Hola, mundo!</div>`
        }
        const app = Vue.createApp({}).component('hola-mundo', holaMundo).mount('#app');
    </script>

</body>

</html>

```

### Ejemplo 9: componente "Lista de tareas"

Vamos a crear un componente un poco m√°s complejo, que contenga datos y m√©todos.

Se trata de un componente llamado "mis-tareas", que servir√° para a√±adir una lista de tareas a una persona.

El componente dispondr√° de un dato, llamado *tareas*, que ser√° un array de strings. Tambi√©n tendr√° un m√©todo, que llamaremos *crearTarea()*, cuyo cometido ser√° agregar al array de tareas una tarea nueva.

Esa tarea nueva la tomaremos de un *input* de texto de un formulario, cuyo evento *keyup.enter* asociaremos al m√©todo *crearTarea()*. Tambi√©n a√±adiremos un bot√≥n "A√±adir tarea" con su evento *click* asociado al mismo m√©todo.

En este c√≥digo puedes ver c√≥mo se har√≠a todo esto con Vue:

* Primero se declara el **template HTML** con y se asocia a una constante (```const misTareas```).
* Despu√©s se declaran los **datos** del objeto Vue: *tareas*, que es un array vac√≠o al principio, y *nuevaTarea*, que quedar√° enlazada con el campo de texto del formulario.
* Por √∫ltimo se declara el **m√©todo** *crearTarea()*, que a√±ade el contenido de *nuevaTarea* al array *tareas*.

Observa c√≥mo, al final del c√≥digo, se registra el componente "mis-tareas" de forma muy parecida a la que usamos con "hola-mundo".

```html
<!DOCTYPE html>
<html lang="es">

<head>
    <title>Pruebas Vue.js</title>
</head>

<body>
    <div id="app">
        <h1>Tareas del equipo de trabajo</h1>
        <h2>Pepito P√©rez</h2>
        <mis-tareas></mis-tareas>
        <h2>Susana S√°nchez</h2>
        <mis-tareas></mis-tareas>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/vue@3.0.0"></script>
    <script>
        const misTareas = {
            template: `<div>
                            <ul>
                                <li v-for="tarea in tareas"> {{ tarea }} </li>
                            </ul>
                            Nueva tarea: <input type="text" v-model="nuevaTarea" @keyup.enter="crearTarea">
                            <button @click="crearTarea">A√±adir tarea</button>
                      </div>`,
            data() {
                return {
                    nuevaTarea: '',
                    tareas: []
                }
            },
            methods: {
                crearTarea() {
                    this.tareas.push(this.nuevaTarea);
                    this.nuevaTarea = '';
                }
            }                      
        }
        const app = Vue.createApp({}).component('mis-tareas', misTareas).mount('#app');
    </script>

</body>

</html>
```

El componente "mis-tareas" puede **reutilizarse** cuantas veces sean necesarias, y cada componente tendr√° sus propios datos. Por ejemplo, podemos crear dos listas de tareas independientes, una para Juan P√©rez y otra para Susana S√°nchez, as√≠:

```html
    <div id="app">
        <h1>Tareas del equipo de trabajo</h1>
        <h2>Juan P√©rez</h2>
        <mis-tareas></mis-tareas>
        <h2>Susana S√°nchez</h2>
        <mis-tareas></mis-tareas>
    </div>
```

## A3.3. Estructurando una aplicaci√≥n hecha con Vue: los componentes

Ahora que hemos visto y comprendido algunos ejemplos, estamos en mejores condiciones para hablar de cu√°l es la estructura t√≠pica de una p√°gina hecha con Vue.js y c√≥mo se crea una jerarqu√≠a de componentes.

Los **componentes** de Vue, como la lista de tareas de los √∫ltimos ejemplos, se usan t√≠picamente para construir elementos del interfaz que sean como **piezas reutilizables**.

Es decir, cada componente es una pieza del interfaz que cumple que:

* Tiene sus propios datos y l√≥gica interna
* Puede manipularse independientemente del resto de piezas.
* Puede contener otras piezas m√°s peque√±as.

¬øQu√© significa todo esto? Sigue leyendo y lo comprender√°s.

### A3.3.1. ¬øQu√© componentes deber√≠a tener mi aplicaci√≥n?

Debes tener muy claro el **interfaz de usuario** de tu aplicaci√≥n para poder descomponerlo en componentes. Esto es fundamental, as√≠ que saca papel y l√°piz y dise√±a el interfaz con detalle.

Por ejemplo, imagina que est√°s dise√±ando una web sencillita (y bastante t√≠pica) con esta distribuci√≥n de elementos:

![Dise√±o t√≠pico de una web](/docs/dwes/_site/assets/images/a3-vue-01.png)

Arriba tenemos un encabezado (*Header*), en el centro el √°rea principal (*Main*) que contiene dos elementos (que llamaremos *Articles*), y a la derecha hay un panel lateral (lo llamaremos *Aside*) con tres elementos (*Items*).

Pues bien; para este dise√±o de interfaz tendr√≠amos que crear estos componentes:

![Componentes t√≠picos de una web](/docs/dwes/_site/assets/images/a3-vue-02.png)

Como ves, dise√±ar y relacionar los componentes Vue entre s√≠ se parece bastante a dise√±ar y relacionar los elementos HTML de una web tradicional: 

* En HTML, hay un **componente ra√≠z** que llamado ```<body>``` que contiene a todos los dem√°s elementos HTML. Con Vue, puedes tener un componente "Root" o "App" que contenga a los dem√°s.
* En HTML, puedes tener **dentro del componente ra√≠z** ```<body>``` varias capas hechas con ```<div>```, tales como ```<div class='header'>``` para el encabezado, ```<div class='main'>``` para el contenido principal y ```<div class='aside'>``` para la barra lateral. En Vue, puedes tener tres componentes dentro de "Root" llamados "Header", "Main" y "Aside"
* En HTML, **algunos elementos pueden tener dentro otros elementos**. Es decir, algunos ```<div>``` pueden tener dentro otros ```<div>``` o cualquier otra cosa. Por ejemplo, el ```<div class='main'>``` puede tener dentro dos ```<div class='article'>```. En Vue ocurre lo mismo: el componente "Main" puede tener dentro dos componentes "Article". Y as√≠ sucesivamente.

En Vue, **cada componente se guarda en un archivo .vue** independiente con una estructura como esta:

```html
<template>
  <button @click="count++">Has hecho click {{ count }} veces.</button>
</template>

<script>
export default {
  name: 'nombre del componente',
  data() {
    return {
      dato1: 'valor-1',
      dato2: 'valor-2',
      ...
      datoN: 'valor-n'
    }
  },
  methods: {
    metodo1() {
      // C√≥digo del m√©todo
    }
    metodo2() {
      // C√≥digo del m√©todo
    }
    ...
    metodoN() {
      // C√≥digo del m√©todo
    }
  }
}
</script>
```

F√≠jate que **el *template* con el c√≥digo HTML del componente se coloca entre los tags** ```<template>``` **y** ```</template>```, a diferencia de los ejemplos sencillitos del principio del tema, donde lo insert√°bamos como parte del objeto Vue. Eso solo se hace cuando el componente Vue no se escribe en un archivo independiente.

Ni que decir tiene que lo m√°s habitual es que s√≠ se escriba en un archivo independiente, es decir, con el formato que te acabo de mostrar.

### A3.3.2. Estructura t√≠pica de una aplicaci√≥n Vue

Aunque, como acabamos de decir, una aplicaci√≥n Vue se debe organizar en funci√≥n del interfaz de usuario que hayas dise√±ado, generalmente constar√° de los siguientes elementos:

* **Un archivo HTML** que contiene la estructura b√°sica de la p√°gina y un contenedor (```<div id="app">```) para la aplicaci√≥n Vue. Este archivo, por supuesto, se puede generar en un servidor web como una aplicaci√≥n PHP.

* **Un archivo JavaScript** que contiene la l√≥gica de la aplicaci√≥n Vue, incluyendo la configuraci√≥n, los componentes y los m√©todos. Aunque en los ejemplos hemos incluido esto en el mismo archivo que el HTML, lo normal es sacarlo a un archivo JS.

* **Un archivo .vue** con la estructura base de la aplicaci√≥n Vue, donde se importen y registros otros componentes. Este ser√≠a nuestro componente "Root" o "App".

* **Archivos .vue** independientes para cada uno de los componentes. Si tenemos muchos, podemos distribuirlos en directorios y subdirectorios.

* Adem√°s, tendremos los archivos .css con los estilos para la p√°gina, como en cualquier web, y, opcionalmente, pueden usarse archivos vue adicionales para manejar rutas, para el almacenamiento de datos y o para otras funcionalidades. Veremos el enrutador de Vue al final de este ap√©ndice.

Por lo tanto, la estructura de archivos de una aplicaci√≥n Vue puede ser m√°s o menos as√≠:

```
-index.html
-main.js
-App.vue
-components/
    -header.vue
    -example.vue
    -footer.vue
-assets/
    -css/
        -main.css
    -img/
```

* El archivo *index.html* contiene la estructura b√°sica de la p√°gina y un contenedor para la aplicaci√≥n Vue (```<div id="app">```).

* El archivo *main.js* contiene la configuraci√≥n de la aplicaci√≥n y las funciones Javascript. Aqu√≠ se importa el archivo *App.vue*, donde estar√°n registrados los componentes Vue.

* El archivo *App.vue* contiene la estructura base de la aplicaci√≥n Vue. Aqu√≠ se importan los dem√°s componentes, que se colocan en archivos individuales.

* En la carpeta *components* se tienen todos los componentes de Vue que se usan en la aplicaci√≥n (un componente por archivo, todo con extensi√≥n .vue).

* En la carpeta *assets*, como es habitual, est√°n todos los dem√°s recursos necesarios para la aplicaci√≥n, como css adicional, im√°genes, audios, etc.

### A3.3.3. Componente principal: el archivo App.vue

El archivo ***App.vue*** o ***Root.vue*** del ejemplo anterior (ten en cuenta que, por convenio, suele usarse m√°s el nombre *App.vue*) deber√≠a ser el componente que contenga la **estructura base** de la aplicaci√≥n Vue en forma de **plantilla**, adem√°s de importar todos los componentes Vue que estar√°n almacenados en archivos independientes.

Es decir, es el "Root" de nuestra aplicaci√≥n.

Podr√≠a ser algo como esto:

```html
<template>
  <div id="app">
    <header-component />
    <example-component /> 
    <footer-component />
  </div>
</template>

<script>
import HeaderComponent from './components/header.vue'
import ExampleComponent from './components/example.vue'
import FooterComponent from './components/footer.vue'

export default {
  name: 'app',
  components: {
    'header-component': HeaderComponent,
    'example-component': ExampleComponent,
    'footer-component': FooterComponent
  }
}
</script>
```

Observa como, en el ***template* o plantilla**, se indica la estructura base de la aplicaci√≥n, donde se usan los componentes ```<header-component>```, ```<example-component>``` y ```<footer-component>```. Por supuesto, podr√≠a haber m√°s componentes, o alguno de estos podr√≠a usarse varias veces.

Inmediatamente despu√©s, en el script, se **importan** los archivos que contienen esos componentes (*header.vue*, *example.vue* y *footer.vue*). Despu√©s, los componentes se **registran** como parte de la aplicaci√≥n Vue. Esto es necesario para poder usarlos.

En este archivo tambi√©n podr√≠a incluirse el **CSS** u otros archivos de configuraci√≥n necesarios para la aplicaci√≥n. No lo hemos hecho en este ejemplo para simplificarlo.

### A3.3.4. Componentes de Vue

Por √∫ltimo, necesitar√≠amos escribir el c√≥digo Vue de los **componentes**. 

Mostramos a modo de ejemplo c√≥mo podr√≠a ser el c√≥digo de ***example-component***, donde usaremos la estructura t√≠pica de un componente que vimos m√°s arriba:

```html
<template>
  <div>
    <h1>{{ title }}</h1>
    <p>{{ message }}</p>
    <button @click="changeMessage">Cambiar mensaje</button>
  </div>
</template>

<script>
export default {
  name: 'example-component',
  data() {
    return {
      title: 'Example Component',
      message: '¬°Hola, mundo! Soy example component'
    }
  },
  methods: {
    changeMessage() {
      this.message = 'El mensaje ha cambiado'
    }
  }
}
</script>
```

En el ***template*** se tiene una estructura HTML del componente, con su t√≠tulo, un p√°rrafo y un bot√≥n, los cuales est√°n ligados a las propiedades del componente *title* y *message* que aparecen m√°s abajo. El bot√≥n se asocia al evento *click*, de manera que, cuando ocurra ese evento, se lanzar√° el m√©todo *changeMessage()*.

En el ***script*** se configura todo el componente: se le asigna un **nombre** (*example-component*), un objeto ***data*** con las propiedades *title* y *message* y un objeto ***methods*** con el m√©todo *changeMessage()*.

Este componente se usa en la plantilla de la aplicaci√≥n (*App.vue*) pero tambi√©n podr√≠a usarse como parte de otro componente m√°s complejo.

Y, de este modo, montando componentes, se construyen los interfaces de usuario con Vue.

### A3.3.5. Manejo de eventos con Vue

En todos los ejemplos anteriores hemos utilizado eventos como *@click* o *@keyup* para enlazar m√©todos de Vue con eventos de usuario.

Vue dispone de muchos otros eventos que podemos usar en nuestros interfaces de usuario. En realidad, son **eventos nativos del navegador** manejados al "estilo Vue". Aunque esto no pretende ser una lista exhaustiva, te pongo aqu√≠ los m√°s habituales:

* **click**: Se activa cuando se hace clic en un elemento.
* **input**: Se activa cuando el valor de un elemento de entrada (input, select, textarea) cambia.
* **submit**: Se activa cuando se env√≠a un formulario.
* **keydown**: Se activa cuando se presiona una tecla en un elemento.
* **keyup**: Se activa cuando se suelta una tecla en un elemento.
* **mouseenter**: Se activa cuando el cursor entra en un elemento.
* **mouseleave**: Se activa cuando el cursor sale de un elemento.
* **focus**: Se activa cuando un elemento obtiene el foco.
* **blur**: Se activa cuando un elemento pierde el foco.

Todos ellos se pueden manejar con Vue utilizando la directiva ***v-on*** o el atajo ***@***. Por lo tanto, estos dos ejemplos son equivalentes:

```html
<template>
  <button v-on:click="myMethod">Click me</button>
</template>

<template>
  <button @click="myMethod">Click me</button>
</template>
```

## A3.4. ¬øY si quiero que el componente Vue tome sus datos del servidor?

La verdadera potencia de Vue.js para crear aplicaciones web de una sola vista comienza a verse si logramos **alimentar los componentes con datos procedentes del servidor**. Entonces estaremos cerca de lograr una OVA con una sola vista que pueda ir actualiz√°ndose de forma din√°mica seg√∫n los datos que se reciban de un servidor web.

La situaci√≥n habitual en este caso es tener ya una vista cargada (creada con componentes de Vue) que tenemos que actualizar con datos procedentes del servidor. Por lo tanto, **todas las peticiones al servidor deben ser as√≠ncronas**.

Como vimos en el [tema 7](/docs/dwes/_site/ajax/), para hacer peticiones as√≠ncronas puedes utilizar **Ajax** de dos maneras diferentes:

1. En su forma tradicional, es decir, con el objeto ***XMLHttpResponse***.
2. O bien mediante alguna liber√≠a moderna como ***fetch*** o ***axios***.

Como siempre, vamos a ver c√≥mo se actualiza un componente Vue con datos del servidor mediante un ejemplo sencillo que puedas usar como base para tus propios desarrollos. Despu√©s veremos un ejemplo un poco m√°s completo: un CRUD hecho con Vue.

### A3.4.1. Un ejemplo sencillo

En el siguiente ejemplo, tendremos un *input* de tipo *text* para teclear un DNI. Cuando se introduzca algo en ese *input*, se cargar√° el nombre y apellidos de la persona desde el servidor, es decir, mediante una consulta a una base de datos remota, y se mostrar√°n en la pantalla.

```html
<template>
  <div>
    <input type="text" v-model="dni" @input="getNameAndLastname" placeholder="Ingresa el DNI">
    <p>Nombre: {{ name }}</p>
    <p>Apellido: {{ lastname }}</p>
  </div>
</template>

<script>
export default {
  data() {
    return {
      dni: '',
      name: '',
      lastname: ''
    }
  },
  methods: {
    async getNameAndLastname() {
      try {
        const response = await fetch(`http://mi-servidor.com/person/${this.dni}`);
        const data = await response.json();
        this.name = data.name;
        this.lastname = data.lastname;
      } catch (error) {
        console.error(error);
      }
    }
  }
}
</script>
```

Si observas el c√≥digo con detenimiento, ver√°s que el m√©todo *getNameAndLastName()* se ejecuta al introducir cualquier cosa en el campo de texto. La abreviatura para ese evento en Vue es ***@input***, aunque un evento tradicional de Javascript tambi√©n funcionar√≠a.

El m√©todo *getNameAndLastName()* est√° declarado como ***async***, lo que significa que contiene una operaci√≥n as√≠ncrona en su interior. Un m√©todo declarado as√≠ permite utilizar el controlador *await* para esperar a que una promesa se resuelva antes de continuar la ejecuci√≥n del c√≥digo.

La funci√≥n *fetch()* devuelve una promesa que se resuelve cuando el servidor responde. Al usar *await*, se espera a que la promesa se resuelva antes de continuar la ejecuci√≥n del c√≥digo, lo que nos permite escribir el c√≥digo de la funci√≥n **como si fuera s√≠ncrono**. Esto hace que el c√≥digo sea m√°s f√°cil de entender y mantener. 

Si no utiliz√°semos la palabra *async* delante del nombre del m√©todo, el *await* se ejecutar√≠a de forma as√≠ncrona y tendr√≠amos que trabajar con *callbacks* o encadenando promesas para acceder a los datos, como hicimos en los [ejemplos con *fetch* del tema 7](http://localhost:4000/docs/dwes/_site/ajax/#75-ajax-y-la-api-fetch).

Una vez que se recibe la respuesta del servidor (un JSON con el nombre y el apellido de la persona a la que corresponde ese DNI), se coloca en los dos elementos <p> reservados para ello dentro de la plantilla.

### A3.4.2. Un ejemplo completo: CRUD con Vue y un servidor RESTful

Vamos a mostrar ahora un ejemplo m√°s completo. Supongamos ahora que tenemos una base de datos con una tabla llamada *Libros* cuyos campos son *id, t√≠tulo, autor* y *editorial*. Supongamos tambi√©n que tenemos un **servidor REST** programado con PHP (o con lo que sea, porque en realidad no importa) que trabaja con esa tabla.

No es un ejemplo realista, desde luego (la tabla est√° horrorosamente dise√±ada), pero s√≠ que nos servir√° para ilustrar c√≥mo puede interactuar Vue con un servidor RESTful.

En el siguiente c√≥digo, vamos a usar ***axios*** en lugar de *fetch*. Se trata de otra librer√≠a Javascript para hacer peticiones as√≠ncronas al servidor. Es muy similar a *fetch* o al m√©todo *ajax* de jQuery. Como se utiliza mucho, te la muestro en este ejemplo para que veas qu√© aspecto tiene. Comp√°rala con el ejemplo anterior, en el que utilizamos *fetch*, y ver√°s que hay muy pocas diferencias pr√°cticas.

```html
<template>
  <div>
    <table>
      <tr>
        <th>ID</th>
        <th>T√≠tulo</th>
        <th>Autor</th>
        <th>Editorial</th>
      </tr>
      <tr v-for="libro in libros" :key="libro.idLibro">
        <td>{{ libro.idLibro }}</td>
        <td>{{ libro.titulo }}</td>
        <td>{{ libro.autor }}</td>
        <td>{{ libro.editorial }}</td>
      </tr>
    </table>
  </div>
</template>

<script>
export default {
  data() {
    return {
      libros: []
    }
  },
  created() {
    this.cargarLibros();
  },
  methods: {
    async cargarLibros() {
      try {
        const response = await axios.get('https://tu-api-rest.com/libros');
        this.libros = response.data;
      } catch (error) {
        console.error(error);
      }
    }
  }
}
</script>
```

En el c√≥digo anterior puedes ver c√≥mo, usando *axios*, se puede hacer din√°micamente la carga de libros y asignarla al array *libros*, que a su vez est√° asociado al template HTML. El m√©todo *cargarLibros()*, como en el ejemplo anterior, se ha declarado como *async* para poder escribir el c√≥digo linealmente, como si fuera s√≠ncrono, lo cual facilita mucho la labor de desarrollo.

A√±adamos ahora las **funcionalidades t√≠picas de un CRUD**, como "Editar", "Borrar", etc. De ese modo, conseguiremos un CRUD completo que trabaje con este servidor REST.

En el siguiente ejemplo puedes ver c√≥mo construir ese CRUD con Vue. Observa bien c√≥mo se etiquetan los campos de la tabla y de los formularios para enlazarlos con los datos de Vue, y qu√© f√°cil y limpio queda el c√≥digo de los m√©todos usando *async* y una librer√≠a como *axios*:

```html
<template>
  <div>
    <table>
      <thead>
        <tr>
          <th>ID</th>
          <th>T√≠tulo</th>
          <th>Autor</th>
          <th>Editorial</th>
          <th>Acciones</th>
        </tr>
      </thead>
      <tbody>
        <tr v-for="book in books">
          <td>{{ book.id }}</td>
          <td>{{ book.title }}</td>
          <td>{{ book.author }}</td>
          <td>{{ book.editorial }}</td>
          <td>
            <button @click="editBook(book)">Editar</button>
            <button @click="deleteBook(book.id)">Borrar</button>
          </td>
        </tr>
      </tbody>
    </table>
    <hr>
    <h3>Crear un nuevo libro</h3>
    <form @submit.prevent="createBook">
      <label>T√≠tulo:</label>
      <input type="text" v-model="newBook.title">
      <label>Autor:</label>
      <input type="text" v-model="newBook.author">
      <label>Editorial:</label>
      <input type="text" v-model="newBook.editorial">
      <button type="submit">Crear</button>
    </form>
    <hr>
    <h3>Actualizar un libro existente</h3>
    <form @submit.prevent="updateBook">
      <input type="hidden" v-model="currentBook.id">
      <label>T√≠tulo:</label>
      <input type="text" v-model="currentBook.title">
      <label>Autor:</label>
      <input type="text" v-model="currentBook.author">
      <label>Editorial:</label>
      <input type="text" v-model="currentBook.editorial">
      <button type="submit">Actualizar</button>
    </form>
  </div>
</template>

<script>
import axios from 'axios';

export default {
  data() {
    return {
      books: [],
      newBook: {
        id: null,
        title: '',
        author: '',
        editorial: ''
      },
      currentBook: {
        id: null,
        title: '',
        author: '',
        editorial: ''
      },
      bookIdToDelete: null
    }
  },
  created() {
    this.getBooks();
  },
  methods: {
    async getBooks() {
      try {
        const response = await axios.get('http://mi-servidor.com/books');
        this.books = response.data;
      } catch (error) {
        console.error(error);
      }
    },
    async createBook() {
      try {
        const response = await axios.post('http://mi-servidor.com/books', this.newBook);
        this.books.push(response.data);
        this.newBook = { id: null, title: '', author: '', editorial: '' };
      } catch (error) {
        console.error(error);
      }
    },
    async updateBook() {
      try {
        const response = await axios.put(`http://mi-servidor.com/books/${this.currentBook.id}`, this.currentBook);
        this.getBooks();
        this.currentBook = { id: null, title: '', author: '', editorial: '' };
      } catch (error) {
        console.error(error);
      }
    },
    async deleteBook(bookId) {
      try {
        await axios.delete(`http://mi-servidor.com/books/${bookId}`);
        this.getBooks();
      } catch (error) {
        console.error(error);
      }
    },
    editBook(book) {
      this.currentBook = Object.assign({}, book);
    }
  }
}
</script>
```

### A3.4.3. Otro ejemplo completo: un componente capaz de mostrar cualquier tabla

Otro caso t√≠pico en el que los frameworks como Vue, React o Angular demuestran lo mucho que nos pueden facilitar la vida, es en el dise√±o de un *template* HTML capaz de mostrar los datos de **cualquier tabla** que un servidor REST est√© dispuesto a servirnos.

¬øTe lo imaginas? Se acab√≥ hacer una vista para cada una de las tablas que tu aplicaci√≥n tenga que manejar. Ahora puedes hacer una plantilla que funcione con *cualquier* tabla y marcharte a tomar un caf√©.

Te muestro un ejemplo muy sencillo. El nombre de la tabla se escribe en un campo de texto, pero bien podr√≠a seleccionarse por medio de un men√∫ o de cualquier otra forma.

El ejemplo solo muestra el contenido de la tabla y no permite modificar, borrar ni a√±adir datos, pero no ser√≠a muy complicado agregarle estas funciones. Pi√©nsalo y ver√°s (es un excelente ejercicio). 

Ah, se supone que el servidor devuelve los datos en forma de JSON.

```html
<template>
  <div>
    <label>Nombre de la tabla:</label>
    <input v-model="tableName" type="text" />
    <button @click="fetchTableData">Consultar</button>
    <table v-if="tableData.length">
      <thead>
        <tr>
          <th v-for="key in Object.keys(tableData[0])" :key="key">{{ key }}</th>
        </tr>
      </thead>
      <tbody>
        <tr v-for="row in tableData" :key="row.id">
          <td v-for="key in Object.keys(row)">{{ row[key] }}</td>
        </tr>
      </tbody>
    </table>
    <div v-else>No hay datos para mostrar</div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      tableName: "",
      tableData: []
    };
  },
  methods: {
    fetchTableData() {
      let url = `http://mi-servidor.com/${this.tableName}`;
      fetch(url)
        .then(res => res.json())
        .then(data => {
          this.tableData = data;
        })
        .catch(error => {
          console.error(error);
        });
    }
  }
};
</script>
```

## A3.5. Vue.js con Laravel

Laravel dispone de un servidor Node integrado (llamado **Laravel Echo**) para poder, entre otras cosas, usar *web sockets*, unos componentes que permiten recibir y emitir eventos entre el cliente y el servidor en tiempo real.

En realidad, no nos importa demasiado por qu√© Laravel tiene un servidor Node integrado. El caso es que lo tiene. Y, si lo tiene, eso significa que podemos tener Vue, React, Angular o cualquier otra librer√≠a Javascript tambi√©n integrada con Laravel.

As√≠ que, s√≠, **se puede instalar Vue en nuestra aplicaci√≥n Laravel a trav√©s de *artisan***.

Tambi√©n podemos usar Vue en una aplicaci√≥n Laravel sin necesidad de instalarlo en el servidor, desde luego, pero si lo haces al "estilo Laravel" obtendr√°s ciertas **ventajas adicionales**, tales como: 

* Mayor control sobre la versi√≥n de Vue que estamos usando.
* Mejor rendimiento.
* Mayor flexibilidad de desarrollo (investiga qu√© es *vue-cli* para saber por qu√©).
* Mayor seguridad (al no depender de elementos externos).
* Mayores posibilidades de personalizaci√≥n.

### A3.5.1. Instalar Vue en Laravel

El modo m√°s sencillo de tener Vue en Laravel es instalar ***laravel/ui*** (aunque existen otras maneras). Este paquete sirve para hacer autenticaci√≥n de usuarios (como Breeze o Jetstream).

```
$ composer require laravel/ui
```

A continuaci√≥n lanzamos *artisan*, instalamos las dependencias de Node y recompilamos todo:

```
$ php artisan ui vue
$ npm install
$ npm run dev
```

Una vez hecho esto, el archivo *public/js/app.js* contendr√° los contenedores de Vue. Por lo tanto, debes incluirlo en tus vistas:

```html
<script src="{{ mix('/js/app.js') }}"></script>
```

Ya puedes usar Vue en esa vista (aseg√∫rate de utilizar el id ‚Äúapp‚Äù):

```html
<div id="app">
   <example-component></example-component>
</div>
```

El componente "example-component" viene creado por defecto pero, por supuesto, puedes crear tus propios componentes. Vamos a ver c√≥mo.

### A3.5.2. Crear componentes Vue con Laravel

Para **crear un componente**, solo tienes que crear un archivo .vue en el directorio *resources/js/components*. All√≠ ya encontrar√°s un archivo llamado *example-component.vue*. Puedes usarlo como plantilla para crear componentes adicionales.

Despu√©s de crearlo, debes **registrar el componente** en *resources/js/app.js*. Nuevamente, encontrar√°s que ya est√° registrado el componente "example-component", as√≠ que puedes usar ese registro como plantilla para los tuyos.

Una vez creados y registrados, los componentes estar√°n disponibles para usarlos en cualquier vista.

### A3.5.3. Un ejemplo completo: CRUD con Laravel y Vue

En este ejemplo vamos a seguir todos los pasos necesarios para crear un CRUD sencillo con Laravel y Vue. Lo vamos a hacer con el Vue integrado en Laravel, pero ten en cuenta que tambi√©n funcionar√≠a si cargamos la versi√≥n de Vue que queramos desde un CDN o desde nuestros propios archivos Javascript.

Los pasos que vamos a describir para crear el CRUD son:

1. Crear proyecto Laravel
2. Configurar conexi√≥n con base de datos
3. Crear modelos y lanzar las migraciones
4. Crear al menos un controlador
5. A√±adir las rutas
6. Instalar Laravel Vue UI
7. Iniciar Vue en Laravel
8. Construir los componentes Vue
9. Enrutamiento con Vue

#### PASO 1. Crear proyecto Laravel

```
$ composer create-project laravel/laravel laravel-vue-crud --prefer-dist
```

#### PASO 2. Configurar conexi√≥n con BD

Editamos el archivo .env:

```
DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=???
DB_USERNAME=???
DB_PASSWORD=???
```

#### PASO 3. Crear modelos / Lanzar migraciones

Por ejemplo, vamos a centrarnos en una tabla llamada *products*:

```
$ php artisan make:model Product -m
$ php artisan migrate
```

(l√≥gicamente, hay que escribir la migraci√≥n antes de lanzarla)

#### PASO 4. Crear controlador

Seguimos trabajando con la tabla *products*, ahora creando su controlador:

```
$ php artisan make:controller ProductController
```

Los m√©todos del controlador devolver√°n solo datos, no vistas, puesto que van a trabajar con Vue en el lado del cliente. 

Por ejemplo, podr√≠an ser algo as√≠:

```php
    public function index()
    {
        $products = Product::all()->toArray();
        return response()->json($products);      
    }
    public function store(Request $request)
    {
        $product = new Product([
            'name' => $request->input('name'),
            'detail' => $request->input('detail')
        ]);
        $product->save();
        return response()->json('Product created!');
    }

    public function show($id)
    {
        $product = Product::find($id);
        return response()->json($product);
    }

    public function update($id, Request $request)
    {
        $product = Product::find($id);
        $product->update($request->all());
        return response()->json('Product updated!');
    }

    public function destroy($id)
    {
        $product = Product::find($id);
        $product->delete();
        return response()->json('Product deleted!');
    }
```

Observa que no hemos escrito los m√©todo *create()* ni *edit()*, puesto que no tienen sentido en una API REST controlada desde el cliente: esos formularios de creaci√≥n y edici√≥n los construir√° el cliente, no el servidor.

#### PASO 5. A√±adir rutas

Editamos nuestro archivo *routes/web.php*. Podr√≠a quedar como esto:

```php
Route::post('/producto',
       [App\Http\Controllers\ProductController::class, 'store']);
Route::get('/producto/{product_id}',
       [App\Http\Controllers\ProductController::class, 'show']);
Route::delete('/eliminar-producto/{product_id}',
       [App\Http\Controllers\ProductController::class, 'delete']);
Route::get('/todos-productos',
       [App\Http\Controllers\ProductController::class, 'all']));
Route::put('/actualizar-producto/{product_id}',
       [App\Http\Controllers\ProductController::class, 'update']);
```

#### PASO 6. Instalar Laravel Vue UI

***laravel/ui*** es un componente de Laravel que incluye varios paquetes orientados a la creaci√≥n del interfaz de usuario, entre ellos Vue.

Si instalas *laravel/ui*, se crear√° la carpeta *resources/js/components* para colocar ah√≠ los componentes de Vue.

```
$ composer require laravel/ui
$ php artisan ui vue
$ npm run dev
```

Adem√°s de *laravel/ui*, en muchos casos se instala tambi√©n:

* **Vue-router**: un enrutador para Vue. Facilita la selecci√≥n de los componentes que hay que cargar en cada ruta.
* **Vue-axios**: un cliente HTTP para lanzar peticiones as√≠ncronas al servidor, es decir, peticiones por Ajax. Es parecido a *fetch* y hay quien lo prefiere usar en su lugar.

Para instalar estos dos componentes tendremos que recurrir a *npm*, el gestor de paquetes de Node, puesto que trabajan en el lado del cliente:

```
$ npm install vue-router vue-axios
```

#### PASO 7. Iniciar Vue en Laravel

Tenemos que crear un layout para nuestra aplicaci√≥n en *resources/views/layout/app.blade.php*. 

Ese layout debe incluir el archivo ***js/app.js***, que es donde estar√° la librer√≠a Vue.

Un layout muy sencillito podr√≠a ser algo como esto:

```html
<head>
    <meta name="csrf-token" value="{{ csrf_token() }}" />
    <title>Ejemplo de CRUD con Vue y Laravel</title>
    <link href="{{ mix('css/app.css') }}" type="text/css" 
          rel="stylesheet" />
</head>
<body>
    <div id="app"></div>
    <script src="{{ mix('js/app.js') }}" type="text/javascript">
    </script>
</body>
```

#### PASO 8. Construir componentes Vue

Este es el paso m√°s largo. 

Los componentes que necesitemos se crean en archivos individuales en el directorio *resources/js/components*. Por ejemplo, vamos a crear componentes como:

* *AllProduct.vue*: para mostrar todos los productos.
* *CreateProduct.vue*: formulario para creaci√≥n de un nuevo producto.
* *EditProduct.vue*: formulario para edici√≥n de productos existentes.

Una vez creados, se pueden reutilizar en cualquier punto de la aplicaci√≥n.

Cada componente de Vue en Laravel tiene esta estructura:

```html
<template>
    Aqu√≠ ir√≠a el HTML del componente
</template>
<script>
    Aqu√≠ ir√≠a el c√≥digo del componente
</script>
<style>
    Aqu√≠ ir√≠an los estilos del componente
</style>
```

Por ejemplo, el componente *CreateProduct.vue* podr√≠a ser as√≠: 

```html
<template>
   <div class="panel panel-default" >
      <div class="panel-heading">Nuevo producto</div>
      <div class="panel-body">
         <form action="" v-on:submit.prevent="newProduct()">                
             <div class="form-group">
                 Referencia: <input type="text" class="form-control" name="reference" v-model="reference">
             </div>
             <div class="form-group">
                 Categor√≠a: <input type="text" class="form-control" name="category" v-model="category">
             </div>
             <div class="form-group">
                 Precio: <input type="text" class="form-control" name="cost" v-model="cost">
             </div>
             <div class="form-group">
                 Cantidad: <input type="text" class="form-control" name="quantity" v-model="quantity">
             </div>
             <button type="submit" class="btn btn-primary">
                 Enviar Producto
             </button>
         </form>
      </div>
   </div>
</template>
<script>
    export default {
        data() {   // Datos que recogemos del componente
            return {
                reference: '',
                category: '',
                cost: '',
                quantity: ''
            }
        },
        methods: {
            newProduct() {
                const params = {
                    reference: this.reference,
                    category: this.category,
                    cost: this.cost,
                    quantity: this.quantity
                };
                this.reference = '';  //eliminamos los valores para que los campos del formulario se vacien
                this.category = '';
                this.cost = '';
                this.quantity = '';
                axios.post('/producto', params)
                    .then((response) => {
                        const product = response.data;
                        this.$emit('new', product);
                    });
            }
        }
    }
</script>
```

Observa que hemos asociado el m√©todo *newProduct()* con el evento *v-on:submit.prevent*. Esto hace que el evento *submit* del formulario se redirija al m√©todo que nos interesa. La palabra *prevent* se refiere a que queremos prevenir (evitar) su comportamiento por defecto, es decir, evitar que el navegador env√≠e directamente el formulario al servidor.

Por lo tanto, al pulsar "submit", se pasar√° el control al m√©todo *newProduct()*, que ser√° quien se encargue de enviar el formulario al servidor de forma as√≠ncrona mediante *axios*.

#### PASO 9: enrutamiento con Vue

Vue dispone en Laravel de su propio enrutador en un paquete llamado ***vue-router***. Como dijimos antes, si lo instalas puedes enrutar tambi√©n en el lado del cliente.

El enrutador de Vue con Laravel est√° ubicado en el archivo *resources/js/routes.js*.

El enrutamiento con Vue permite seleccionar los componentes cuyos datos se deben cargar en cada ruta. Esto facilita mucho el trabajo en las aplicaciones OVA (*one view application*).

El enrutador de Vue est√° escrito en Javascript, claro, no en PHP, y tiene un aspecto como este:

```javascript
export const routes = [
    {
        name: 'home',
        path: '/',
        component: AllProduct
    },
    {
        name: 'create',
        path: '/create',
        component: CreateProduct
    },
    {
        name: 'edit',
        path: '/edit/:id',
        component: EditProduct
    }
];
```

Observa c√≥mo, para cada ruta, se indica un nombre (de uso interno para la aplicaci√≥n), una URL y el componente (o componentes) que se cargar√°n en el *layout* en caso de solicitar esa ruta.

Cada componente, a su vez, se encargar√° de pedir los datos al servidor mediante alguna de las rutas definidas en el enrutador de Laravel (*web.php*), por lo que el uso del enrutador de Vue no implica que dejemos de usar el enrutamiento en el servidor.



-->
:ET