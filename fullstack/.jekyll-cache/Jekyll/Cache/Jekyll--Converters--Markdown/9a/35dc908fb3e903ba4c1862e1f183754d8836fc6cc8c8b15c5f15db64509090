I"ÁM<h2 class="no_toc" id="24-interacci√≥n-entre-mariadb-y-php">2.4. Interacci√≥n entre MariaDB y PHP</h2>

<ul id="markdown-toc">
  <li><a href="#241-mysqlmariadb-con-php4" id="markdown-toc-241-mysqlmariadb-con-php4">2.4.1. MySQL/MariaDB con PHP4</a></li>
  <li><a href="#242-mysqlmariadb-a-partir-de-php5" id="markdown-toc-242-mysqlmariadb-a-partir-de-php5">2.4.2. MySQL/MariaDB a partir de PHP5</a></li>
</ul>

<p>A partir de ahora, vamos a referirnos a MySQL/MariaDB indistintamente. Este ser√° el gestor de bases de datos relacionales que vamos a usar a lo largo del curso. La adaptaci√≥n a otros gestores, en cualquier caso, es muy simple.</p>

<p>MySQL/MariaDB, como ya hemos visto, es un SGBD relacional de probada eficacia. La interacci√≥n con √©l resulta eficiente y segura para casi cualquier aplicaci√≥n web que podamos concebir.</p>

<p>Hay b√°sicamente tres m√©todos de utilizar MySQL/MariaDB:</p>

<ul>
  <li>
    <p><strong>A trav√©s de un cliente de l√≠nea de comandos:</strong></p>

    <p>El cliente mysql de l√≠nea de comandos puede ser tu tabla de salvaci√≥n en m√°s de una ocasi√≥n. Cuando todo lo dem√°s se ha ca√≠do, este cliente todav√≠a suele responder, as√≠ que m√°s te vale saber defenderte con √©l.</p>

    <p>Como viste en primer curso, basta con abrir una sesi√≥n MySQL escribiendo esto:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ mysql -h servidor -u nombre_usuario -p
</code></pre></div>    </div>

    <p>Y luego tenemos a nuestra disposici√≥n montones de comandos para hacer cosas con la base de datos, incluyendo ejecutar cualquier instrucci√≥n v√°lida en SQL.</p>
  </li>
  <li>
    <p><strong>A trav√©s de un cliente con interfaz gr√°fico</strong>, como MysqlWorkBench o PHPMyAdmin. Esta √∫ltiam es una aplicaci√≥n web escrita en PHP que proporciona un interfaz bastante c√≥modo para trabajar con MySQL o MariaDB. Como suele estar presente en casi todos los servidores web, te aconsejo que, si no la conoces, la uses a partir de ahora porque te la vas a encontrar a menudo en tu vida profesional.</p>
  </li>
  <li>
    <p><strong>A trav√©s de un programa escrito en PHP</strong> o alg√∫n otro lenguaje con posibilidad de acceso a MySQL. Este m√©todo de acceso ser√° el que nosotros usaremos en nuestros programas para convertirlos en aut√©nticas aplicaciones web.</p>
  </li>
</ul>

<p>En esta secci√≥n, vamos a ver lo fundamental para usar MySQL desde un programa en PHP. Iremos perfeccionando nuestras habilidades al respecto a lo largo del resto del curso.</p>

<h3 id="241-mysqlmariadb-con-php4">2.4.1. MySQL/MariaDB con PHP4</h3>

<p>Si PHP4 est√° obsoleto, ¬øpor qu√© hay un apartado dedicado al acceso a MySQL desde PHP4?</p>

<p>Buena pregunta. La respuesta es simple: <span style="color: red"><em>para que sepas lo que <strong>NO</strong> tienes que hacer</em></span>.</p>

<p>El hecho es que encontrar√°s a√∫n mucho c√≥digo PHP4 pululando por internet. Los sitios donde haya c√≥digo de ese estilo deben ser evitados. Suele tratarse de blogs antiguos, tutoriales obsoletos o, simplemente, gente ignorante con ganas de ayudar pero que anda bastante perdida.</p>

<h4 id="acceso-a-mysql-con-php4-obsoleto">Acceso a MySQL con PHP4 (¬°OBSOLETO!)</h4>

<p>El modo en que se acced√≠a a bases de datos en PHP4 era mediante <strong>bibliotecas de funciones diferentes para cada SGBD</strong>.</p>

<p>Lo digo otra vez: <em>esta forma de programar est√° obsoleta y se desaconseja su uso</em>. No tiene soporte oficial. Si aparecen problemas de seguridad o estabilidad, nadie los va a resolver. Si encuentras c√≥digo de este estilo en internet, l√°rgate de ese sitio, porque no vas a aprender nada √∫til.</p>

<p>PHP4 utilizaba una biblioteca de funciones PHP cuyo nombre empiezaba por las letras <em>mysql_</em>.</p>

<p>Por ejemplo, para insertar un registro en una BD MySQL, se hac√≠a as√≠:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>
<span class="c1">// Conectamos con MySQL</span>
<span class="nb">mysql_connect</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">,</span><span class="s2">"nombre_usuario"</span><span class="p">,</span><span class="s2">"contrase√±a"</span><span class="p">);</span>

<span class="c1">// Seleccionamos la base de datos con la que vamos a trabajar</span>
<span class="nb">mysql_select_db</span><span class="p">(</span><span class="s2">"nombre_base_de_datos"</span><span class="p">);</span>

<span class="c1">// Ejecutamos una sentencia SQL</span>
<span class="nb">mysql_query</span><span class="p">(</span><span class="s2">"INSERT INTO clientes (nombre,telefono) VALUES ('</span><span class="nv">$nombre</span><span class="s2">','</span><span class="nv">$telefono</span><span class="s2">')"</span><span class="p">);</span>
<span class="cp">?&gt;</span>
</code></pre></div></div>

<p>Y para ejecutar consultas (SELECT), se hac√≠a m√°s o menos como en este ejemplo. No es necesario que lo entiendas todo. Basta con que te hagas una idea de la manera en la que trabajaba PHP4 para que sepas identificarlo si te lo encuentras por ah√≠:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>
<span class="c1">//Nos conectamos con MySQL</span>
<span class="nb">mysql_connect</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">,</span><span class="s2">"user"</span><span class="p">,</span><span class="s2">"password"</span><span class="p">);</span>

<span class="c1">//Seleccionamos la base de datos con la que vamos a trabajar</span>
<span class="nb">mysql_select_db</span><span class="p">(</span><span class="s2">"nombre_base_datos"</span><span class="p">);</span>

<span class="c1">//Ejecutamos la consulta SQL para obtener toda la tabla de Clientes</span>
<span class="nv">$result</span><span class="o">=</span><span class="nb">mysql_query</span><span class="p">(</span><span class="s2">"SELECT * FROM Clientes"</span><span class="p">);</span>
<span class="cp">?&gt;</span>

<span class="nt">&lt;table</span> <span class="na">align=</span><span class="s">"center"</span><span class="nt">&gt;&lt;tr&gt;</span>
<span class="nt">&lt;th&gt;</span>Nombre<span class="nt">&lt;/th&gt;</span>
<span class="nt">&lt;th&gt;</span>Tel√©fono<span class="nt">&lt;/th&gt;&lt;/tr&gt;</span>

<span class="cp">&lt;?</span>
<span class="c1">//Mostramos los nombres y tel√©fonos de los clientes</span>
<span class="k">while</span> <span class="p">(</span><span class="nv">$registro</span><span class="o">=</span><span class="nb">mysql_fetch_array</span><span class="p">(</span><span class="nv">$result</span><span class="p">))</span> <span class="p">{</span>
<span class="k">echo</span> <span class="s1">'&lt;tr&gt;&lt;td&gt;'</span><span class="mf">.</span><span class="nv">$registro</span><span class="p">[</span><span class="s2">"nombre"</span><span class="p">]</span><span class="mf">.</span><span class="s1">'&lt;/td&gt;'</span><span class="p">;</span>
<span class="k">echo</span> <span class="s1">'&lt;td&gt;'</span><span class="mf">.</span><span class="nv">$registro</span><span class="p">[</span><span class="s2">"telefono"</span><span class="p">]</span><span class="mf">.</span><span class="s1">'&lt;/td&gt;&lt;/tr&gt;'</span><span class="p">;</span>
<span class="p">}</span>
<span class="nb">mysql_free_result</span><span class="p">(</span><span class="nv">$result</span><span class="p">)</span>
<span class="cp">?&gt;</span>

<span class="nt">&lt;/table&gt;</span>
<span class="nt">&lt;/body&gt;</span>
</code></pre></div></div>

<h3 id="242-mysqlmariadb-a-partir-de-php5">2.4.2. MySQL/MariaDB a partir de PHP5</h3>

<p>Desde PHP5, se utiliza <strong>una biblioteca de clases para acceder a los diferentes SGBDs</strong>.</p>

<p>Todos los nuevos desarrollos deber√≠an usar las bibliotecas de clases y prescindir de las viejas librer√≠as de funciones.</p>

<p><span style="color: red"><em>Vuelvo a repetirlo: mucho c√≥digo de ejemplo de PHP que circula por la red es PHP4 y DEBE SER EVITADO.</em></span></p>

<h4 id="formas-de-acceder-a-bases-de-datos-en-php">Formas de acceder a bases de datos en PHP</h4>

<p>PHP proporciona varios mecanismos para acceder a bases de datos (ya te lo dije antes: en PHP, casi todo se puede hacer de varias maneras distintas):</p>

<ul>
  <li>
    <p><strong>Forma 1: Usar la extensi√≥n mysqli en su forma procedimental.</strong></p>

    <p>Esta forma recuerda mucho a PHP4, pero cambiando la palabra ‚Äúmysql‚Äù por ‚Äúmysqli‚Äù.</p>

    <p>Por ejemplo, la funci√≥n <em>mysql_connect()</em> ahora se llama <em>mysqli_connect()</em> (la ‚Äúi‚Äù significa ‚Äúimproved‚Äù, es decir, ‚Äúmejorado‚Äù).</p>

    <p>Esta forma es apta para programadores/as perezosos y anticuados, que no quieren pasarse a la programaci√≥n orientada a objetos y se sienten c√≥modos con la forma de codificaci√≥n tradicional. Pero ese no es tu caso, ¬øverdad? As√≠ que nunca utilizaremos la forma procedimental.</p>
  </li>
  <li>
    <p><strong>Forma 2: Usar la extensi√≥n mysqli en su forma orientada a objetos.</strong></p>

    <p>Se accede a la base de datos a trav√©s de un objeto de la clase <em>mysqli</em>. Es decir, se crea una instancia (con <code class="language-plaintext highlighter-rouge">new mysqli()</code>) y, a trav√©s de ella, se tiene acceso a todos los m√©todos para interactuar con la base de datos.</p>

    <p>Si en lugar de una base de datos MySQL, trabajamos con otro gestor de base de datos, hay que crear un objeto de otro tipo. Por ejemplo, la clase <em>SQLite3</em> sirve para conectar con bases de datos SQLite. Hay otros gestores que solo ofrecen la forma procedimental.</p>

    <p>Nosotros, como somos muy modernos, usaremos esta forma de conectar a MySQL durante el resto de este texto.</p>
  </li>
  <li>
    <p><strong>Forma 3: Usar la extensi√≥n PDO.</strong></p>

    <p>A partir de PHP 5.1, existe una clase gen√©rica, llamada <em>PDO</em>, que permite acceder a cualquier gestor de bases de datos mediante el mismo conjunto de m√©todos. Es lo que se llama una <em>capa de abstracci√≥n de acceso a datos</em></p>

    <p>Esto significa que, independientemente de la base de datos que se est√© utilizando, PDO permite utilizar los mismos m√©todos para realizar consultas y obtener datos, por lo que es una forma de trabajo perfectamente v√°lida y que podr√≠amos haber usado en lugar de la extensi√≥n mysqli.</p>
  </li>
</ul>

<h4 id="inserci√≥n-modificaci√≥n-y-borrado-de-datos">Inserci√≥n, modificaci√≥n y borrado de datos</h4>

<p>Vamos a ver c√≥mo funciona la clase <em>mysqli</em> mediante unos cuantos ejemplos. En primer lugar, lanzaremos una inserci√≥n de datos.</p>

<p>Imagina que tenemos una base de datos MySQL o MariaDB llamada <em>mi-base-de-datos</em> que contiene una tabla de clientes donde guardamos, entre otras cosas, los nombres y los tel√©fonos de los clientes.</p>

<p>Insertar un registro en esa tabla desde PHP se logra en solo dos pasos:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>
<span class="c1">// Conectamos con el servidor y abrimos la BD</span>
<span class="nv">$conexdb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">mysqli</span><span class="p">(</span><span class="s1">'servidor'</span><span class="p">,</span><span class="s1">'nombre-de-usuario'</span><span class="p">,</span><span class="s1">'password'</span><span class="p">,</span><span class="s1">'mi-base-de-datos'</span><span class="p">);</span>

<span class="c1">// Insertamos un registro en una tabla (aqu√≠ se podr√≠a escribir cualquier sentencia SQL v√°lida)</span>
<span class="nv">$conexdb</span><span class="o">-&gt;</span><span class="nf">query</span><span class="p">(</span><span class="s2">"INSERT INTO clientes (nombre,telefono) VALUES ('</span><span class="nv">$nombre</span><span class="s2">','</span><span class="nv">$telefono</span><span class="s2">')"</span><span class="p">);</span>
<span class="cp">?&gt;</span>
</code></pre></div></div>

<p>Si sustituyes la sentencia INSERT por cualquier otra instrucci√≥n SQL v√°lida, tambi√©n funcionar√°. Con una excepci√≥n: SELECT se ejecuta de otra manera que enseguida veremos.</p>

<p>Por lo tanto, el c√≥digo anterior te puede servir de base para ejecutar cualquier INSERT, UPDATE o DELETE sobre tu base de datos. O incluso sentencias de definici√≥n de la base de datos, como CREATE TABLE o ALTER TABLE (siempre que el usuario con el que te est√©s conectando tenga permisos para ejecutarlas, claro)</p>

<h4 id="consultas">Consultas</h4>

<p>Hemos dicho que las sentencias SELECT se lanzan desde PHP de un modo diferente al resto. ¬øPor qu√© ser√°?</p>

<p>La respuesta es sencilla de entender: la ejecuci√≥n de consultas (SELECT) produce la devoluci√≥n de un conjunto de registros, mientras que cualquier otra instucci√≥n (INSERT, UPDATE, DELETE o lo que sea) no devuelve ning√∫n registro.</p>

<p>Los registros obtenidos como resultado de un SELECT se manejan en PHP con un objeto denominado <strong>cursor</strong>. Un cursor no es m√°s que un puntero al conjunto de resultados que se√±ala al registro que se va a procesar a continuaci√≥n.</p>

<p>Es decir: se parece al cursor de tu procesador de textos, que te indica el lugar en el que vas a insertar o borrar caracteres.</p>

<p>En el caso de los cursores MySQL, no te permiten borrar nada. El cursor solo se√±ala un registro concreto dentro de los resultados del SELECT.</p>

<p>Observa c√≥mo se hace un SELECT en este ejemplo:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;body&gt;</span>
<span class="cp">&lt;?php</span>
<span class="c1">//Nos conectamos con MySQL</span>
<span class="nv">$db</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">mysqli</span><span class="p">(</span><span class="s2">"servidor"</span><span class="p">,</span><span class="s2">"user"</span><span class="p">,</span><span class="s2">"password"</span><span class="p">,</span> <span class="s2">"database"</span><span class="p">);</span>

<span class="c1">// Comprobamos que la conexi√≥n se ha realizado</span>
<span class="k">if</span><span class="p">(</span><span class="nv">$db</span><span class="o">-&gt;</span><span class="n">connect_error</span><span class="p">){</span>
    <span class="k">die</span><span class="p">(</span><span class="s2">"Error en la conexion : "</span><span class="mf">.</span><span class="nv">$db</span><span class="o">-&gt;</span><span class="n">connect_error</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//Ejecutamos la consulta SQL</span>
<span class="nv">$result</span><span class="o">=</span><span class="nv">$db</span><span class="o">-&gt;</span><span class="nf">query</span><span class="p">(</span><span class="s2">"SELECT * FROM Clientes"</span><span class="p">);</span>
<span class="cp">?&gt;</span>

<span class="nt">&lt;table</span> <span class="na">align=</span><span class="s">"center"</span><span class="nt">&gt;&lt;tr&gt;</span>
   <span class="nt">&lt;th&gt;</span>Nombre<span class="nt">&lt;/th&gt;</span>
   <span class="nt">&lt;th&gt;</span>Tel√©fono<span class="nt">&lt;/th&gt;&lt;/tr&gt;</span>
<span class="cp">&lt;?</span>
<span class="c1">//Mostramos los registros de SELECT</span>
<span class="k">while</span> <span class="p">(</span><span class="nv">$registro</span><span class="o">=</span><span class="nv">$result</span><span class="o">-&gt;</span><span class="nf">fetch_array</span><span class="p">())</span> <span class="p">{</span>
   <span class="k">echo</span> <span class="s1">'&lt;tr&gt;&lt;td&gt;'</span><span class="mf">.</span><span class="nv">$registro</span><span class="p">[</span><span class="s2">"nombre"</span><span class="p">]</span><span class="mf">.</span><span class="s1">'&lt;/td&gt;'</span><span class="p">;</span>
   <span class="k">echo</span> <span class="s1">'&lt;td&gt;'</span><span class="mf">.</span><span class="nv">$registro</span><span class="p">[</span><span class="s2">"telefono"</span><span class="p">]</span><span class="mf">.</span><span class="s1">'&lt;/td&gt;&lt;/tr&gt;'</span><span class="p">;</span>
<span class="p">}</span>
<span class="nv">$db</span><span class="o">-&gt;</span><span class="nf">free</span><span class="p">(</span><span class="nv">$result</span><span class="p">);</span>  <span class="c1">// Libera memoria usada por cursor</span>
<span class="nv">$db</span><span class="o">-&gt;</span><span class="nf">close</span><span class="p">();</span>   <span class="c1">// Cierra la conexi√≥n con el servidor</span>
<span class="cp">?&gt;</span>
<span class="nt">&lt;/table&gt;</span>
<span class="nt">&lt;/body&gt;</span>
</code></pre></div></div>

<p>Probablemente ya lo hayas captado sin necesidad de explicaciones adicionales, pero, por si acaso no es as√≠, ah√≠ va una explicaci√≥n adicional gratuita.</p>

<p>Cuando se lanza una consulta contra una base de datos desde PHP, la base de datos nos devuelve el resultado en un <em>cursor</em>, como hemos dicho. Ese objeto de tipo cursor lo almacenamos en una variable que, en este ejemplo, hemos llamado <em>$result</em>.</p>

<p>Recuerda que un cursor es un apuntador a un conjunto de resultados. Cuando un cursor est√° reci√©n abierto, <em>siempre apunta al primer registro de ese conjunto de resultados</em>.</p>

<p>Nuestra variable <em>result</em> es un objeto (su clase se llama <em>mysqli_result</em>, por cierto). Y, como cualquier objeto, contiene una serie de m√©todos. Entre esos m√©todos, cualquier cursor siempre nos ofrecer√° un m√©todo important√≠simo llamado <strong><em>fetch()</em></strong> o algo semejante.</p>

<p>El m√©todo <em>fetch()</em> hace lo siguiente: nos devuelve el siguiente dato almacenado en el cursor (en nuestro caso, un registro completo) y hace avanzar al cursor para que apunte al siguiente dato (en nuestro caso, el siguiente registro). As√≠, lo deja preparado para recuperar otro registro en la siguiente iteraci√≥n.</p>

<p>Por eso hemos colocado la instrucci√≥n <em>fetch()</em> en un bucle. Ahora todo empieza a encajar, ¬øverdad?</p>

<p>Cuando el cursor est√° reci√©n abierto, el primer <em>fetch()</em> nos devuelve el primer registro del resultado. Es decir, el primer cliente. Podemos acceder a los campos de ese registro (como ‚Äúnombre‚Äù o ‚Äútel√©fono‚Äù) accediendo al registro como si fuera un array ($registro[‚Äúnomnre‚Äù], $registro[‚Äútelefono‚Äù], etc). Por eso el m√©todo no se llama solo <em>fetch()</em>, sino <em>fetch_array()</em>.</p>

<p>Pero <em>fetch()</em> no solo recupera el primer registro, sino que hace avanzar el cursor para que se quede apuntando al segundo. De este modo, en la siguiente iteraci√≥n del bucle, <em>fetch_array()</em> nos recupera <em>el segundo</em> registro (el segundo cliente), y el cursor queda apuntando al tercero, listo para la siguiente iteraci√≥n.</p>

<p>Cuando no quedan m√°s registros que procesar, <em>fetch()</em> devuelve <em>false</em> y el bucle termina. De ese modo, habremos procesado f√°cilmente todo el conjunto de resultados devueltos por la consulta.</p>

<p>El m√©todo <em>fetch()</em> tiene varias formas. Nosotros usaremos sobre todo estas dos:</p>
<ul>
  <li><strong><em>fetch_array()</em></strong>, como en el ejemplo anterior. Cada registro del resultado tiene forma de array. Para acceder, por ejemplo, al nombre de un cliente, escribimos algo como <code class="language-plaintext highlighter-rouge">$registro["nombre"]</code>.</li>
  <li><strong><em>fetch_object()</em></strong>, que funciona igual, pero cada registro del resultado tiene forma de objeto. Para acceder, por ejemplo, al nombre de un cliente, escribimos algo como <code class="language-plaintext highlighter-rouge">$registro-&gt;nombre</code>.</li>
</ul>

:ET