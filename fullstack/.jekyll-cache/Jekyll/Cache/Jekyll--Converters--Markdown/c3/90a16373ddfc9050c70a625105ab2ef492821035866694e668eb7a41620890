I"ÒG<h2 class="no_toc" id="16-cookies-y-sesiones">1.6. Cookies y sesiones</h2>

<ul id="markdown-toc">
  <li><a href="#161-qu√©-son-las-cookies" id="markdown-toc-161-qu√©-son-las-cookies">1.6.1. ¬øQu√© son las cookies?</a></li>
  <li><a href="#162-manejando-cookies-con-php" id="markdown-toc-162-manejando-cookies-con-php">1.6.2. Manejando cookies con PHP</a></li>
  <li><a href="#163-variables-de-sesi√≥n" id="markdown-toc-163-variables-de-sesi√≥n">1.6.3. Variables de sesi√≥n</a></li>
  <li><a href="#164-abrir-sesiones-session_start" id="markdown-toc-164-abrir-sesiones-session_start">1.6.4. Abrir sesiones: session_start()</a></li>
  <li><a href="#165-usar-variables-de-sesi√≥n-_session" id="markdown-toc-165-usar-variables-de-sesi√≥n-_session">1.6.5. Usar variables de sesi√≥n: $_SESSION</a></li>
  <li><a href="#166-eliminar-variables-de-sesi√≥n-unset-y-session_destroy" id="markdown-toc-166-eliminar-variables-de-sesi√≥n-unset-y-session_destroy">1.6.6. Eliminar variables de sesi√≥n: unset() y session_destroy()</a></li>
  <li><a href="#167-control-de-acceso-a-las-aplicaciones-web" id="markdown-toc-167-control-de-acceso-a-las-aplicaciones-web">1.6.7. Control de acceso a las aplicaciones web</a></li>
  <li><a href="#168-autenticaci√≥n-mediante-acl" id="markdown-toc-168-autenticaci√≥n-mediante-acl">1.6.8. Autenticaci√≥n mediante ACL</a></li>
</ul>

<p>En esta secci√≥n vamos a ver qu√© son las <em>cookies</em> y c√≥mo podemos acceder a ellas para crearlas o manipularlas desde PHP.</p>

<h3 id="161-qu√©-son-las-cookies">1.6.1. ¬øQu√© son las cookies?</h3>

<p>Las <strong><em>cookies</em></strong> son peque√±os archivos de texto enviados desde el servidor que se almacenan en el lado del cliente. Es decir, en el navegador.</p>

<p>Permiten guardar informaci√≥n de forma persistente, de manera que se mantenga entre una petici√≥n al servidor y otra. Una <em>cookie</em> puede estar viva durante minutos, horas, d√≠as o incluso indefinidamente.</p>

<p>Desde PHP, se pueden usar las <em>cookies</em> usando la funci√≥n <strong><em>setcookie()</em></strong> y el array global <strong><em>$_COOKIE</em></strong>. Vamos a ver c√≥mo.</p>

<h3 id="162-manejando-cookies-con-php">1.6.2. Manejando cookies con PHP</h3>

<h4 id="enviar-una-cookie-setcookie">Enviar una cookie: setcookie()</h4>

<p>Esta funci√≥n define una <em>cookie</em> que se enviar√° al cliente junto con el resto de las cabeceras de HTTP. Devuelve <em>true</em> si la cookie se env√≠a con √©xito o <em>false</em> en caso contrario.</p>

<p>Su sintaxis es:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bool</span> <span class="nb">setcookie</span> <span class="p">(</span> <span class="n">string</span> <span class="nv">$name</span> <span class="p">[,</span> <span class="n">string</span> <span class="nv">$value</span> <span class="p">[,</span> <span class="n">int</span> <span class="nv">$expire</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">[,</span> <span class="n">string</span> <span class="nv">$path</span> <span class="p">[,</span> <span class="n">string</span> <span class="nv">$domain</span> <span class="p">[,</span> <span class="n">bool</span> <span class="nv">$secure</span> <span class="o">=</span> <span class="kc">false</span> <span class="p">[,</span> <span class="n">bool</span> <span class="nv">$httponly</span> <span class="o">=</span> <span class="kc">false</span> <span class="p">]]]]]]</span> <span class="p">)</span>
</code></pre></div></div>

<p>Las <em>cookies</em> deben enviarse <strong>antes de que el programa genere ninguna salida</strong>. Esto no es un capricho de PHP, sino una restricci√≥n del protocolo http. Por lo tanto, debes llamar a esta funci√≥n antes de hacer <em>cualquier</em> salida, incluidos espacios en blanco. En caso contrario, la <em>cookie</em> no estar√° disponible hasta que la p√°gina se recargue.</p>

<p>La funci√≥n <em>setcookie()</em> admite un mont√≥n de par√°metros, la mayor parte de ellos optativos:</p>

<ul>
  <li><strong>name</strong>: El nombre de la <em>cookie</em>. Este es el √∫nico obligatorio.</li>
  <li><strong>value</strong>: El valor de la <em>cookie</em>.</li>
  <li><strong>expire</strong>: El tiempo que la <em>cookie</em> tardar√° en expirar. Se trata de una fecha expresada en <a href="https://es.wikipedia.org/wiki/Tiempo_Unix">formato Unix</a>.</li>
  <li><strong>path</strong>: La ruta del servidor para la que la <em>cookie</em> estar√° disponible. Si se utiliza ‚Äò/‚Äô, la <em>cookie</em> estar√° disponible en la totalidad del dominio.</li>
  <li><strong>domain</strong>: El dominio para el cual la <em>cookie</em> est√° disponible.</li>
  <li><strong>secure</strong>: Si la <em>cookie</em> solo deber√≠a enviarse en caso de conexi√≥n https, pon este argument a <em>true</em>.</li>
  <li><strong>httponly</strong>: Esta <em>cookie</em> solo ser√° accesible a trav√©s de http. Es decir, no podr√° accederse a la <em>cookie</em> desde Javascript.</li>
</ul>

<p>Aqu√≠ tienes tres ejemplos de env√≠o de la misma cookie:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span> 
<span class="nv">$value</span> <span class="o">=</span> <span class="s2">"I'm your father"</span><span class="p">;</span> 

<span class="nb">setcookie</span><span class="p">(</span><span class="s2">"VaderQuote"</span><span class="p">,</span> <span class="nv">$value</span><span class="p">);</span> 
<span class="nb">setcookie</span><span class="p">(</span><span class="s2">"VaderQuote"</span><span class="p">,</span> <span class="nv">$value</span><span class="p">,</span> <span class="nb">time</span><span class="p">()</span><span class="o">+</span><span class="mi">3600</span><span class="p">);</span>  <span class="c1">// la cookie expira en una hora </span>
<span class="nb">setcookie</span><span class="p">(</span><span class="s2">"VaderQuote"</span><span class="p">,</span> <span class="nv">$value</span><span class="p">,</span> <span class="nb">time</span><span class="p">()</span><span class="o">+</span><span class="mi">3600</span><span class="p">,</span> <span class="s2">"/quotes/"</span><span class="p">,</span> <span class="s2">"bestquotes.com"</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> 
<span class="cp">?&gt;</span>
</code></pre></div></div>

<h4 id="recuperar-una-cookie-_cookies">Recuperar una cookie: $_COOKIES[]</h4>

<p>Para ver el contenido de una <em>cookie</em>, simplemente hay que acceder al array global <em>$_COOKIES</em>. Por ejemplo:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span> 
<span class="c1">// Imprimir una cookie individual </span>
<span class="k">echo</span> <span class="nv">$_COOKIE</span><span class="p">[</span><span class="s2">"VaderQuote"</span><span class="p">];</span> 
<span class="cp">?&gt;</span> 
</code></pre></div></div>

<h4 id="borrar-una-cookie">Borrar una cookie</h4>

<p>Para forzar el borrado de una cookie en el cliente basta con enviarla con una fecha de expiraci√≥n anterior a la fecha actual. Por ejemplo:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span> 
<span class="nb">setcookie</span> <span class="p">(</span><span class="s2">"VaderQuote"</span><span class="p">,</span> <span class="s2">""</span><span class="p">,</span> <span class="nb">time</span><span class="p">()</span> <span class="o">-</span> <span class="mi">3600</span><span class="p">);</span>  <span class="c1">// Establece la fecha de expiraci√≥n una hora en el pasado</span>
<span class="cp">?&gt;</span>
</code></pre></div></div>

<h3 id="163-variables-de-sesi√≥n">1.6.3. Variables de sesi√≥n</h3>

<p>Las <strong>sesiones</strong> de PHP son un mecanismo para que un script almacene variables (llamadas <strong>variables de sesi√≥n</strong>) en el servidor de manera persistente, de modo que posteriores ejecuciones de programas en el servidor solicitadas desde el mismo cliente pueden acceder a esas variables.</p>

<p>Es decir: en la pr√°ctica, <strong>las variables de sesi√≥n se comportan como si fueran variables globales a toda la aplicaci√≥n web</strong>.</p>

<p>Seguro que te hab√≠an dicho que usar variables globales es una mala idea y una p√©sima pr√°ctica de programaci√≥n. Eso es cierto y, al mismo tiempo, usarlas resulta inevitable. <em>Bienvenido/a al extravagante mundo de las aplicaciones web</em>.</p>

<p>Por ese motivo, debe reducirse el uso de las variables de sesi√≥n a lo estrictamente imprescindible. ¬øQu√© cosas resulta √∫til guardar en variables de sesi√≥n? Cosas como el ID o el nombre de un usuario logueado en un sistema o el estado de la aplicaci√≥n. Poco m√°s. Cosas peque√±as pero tremendamente importantes.</p>

<p>Cada cliente tiene su propio espacio de variables de sesi√≥n en el servidor, de manera que no se mezclan unas con otras, ni un cliente puede acceder a las variables de otro cliente.</p>

<p>La forma en la que PHP logra distinguir a los clientes entre s√≠ es envi√°ndoles, de forma transparente, una <em>cookie</em> con un valor aleatorio distinto para cada cliente. ‚ÄúDe forma transparente‚Äù significa que ni el programador ni el usuario se enteran de que esa <em>cookie</em> existe: PHP se encarga de hacerlo por su cuenta.</p>

<p>En el archivo <em>php.ini</em> se puede configurar la manera en la que PHP almacenar√° las variables de sesi√≥n (en memoria, en un fichero, etc), pero esto es irrelevante de cara a su funcionamiento y compete m√°s al administrador del sistema que al programador. Lo que a nosotros nos interesa es aprender a crear variables de sesi√≥n, asignarles valor y recuperarlo posteriormente.</p>

<h3 id="164-abrir-sesiones-session_start">1.6.4. Abrir sesiones: session_start()</h3>

<p>Antes de acceder a cualquier variable de sesi√≥n (ya sea para crearla, para modificarla o para eliminarla) necesitamos indicarle a PHP que queremos usar variables de sesi√≥n en ese programa.</p>

<p>La funci√≥n <strong><em>session_start()</em></strong> se usa para eso: habilita el acceso a las variables de sesi√≥n, es decir, crea una nueva sesi√≥n o reanuda una sesi√≥n preexistente.</p>

<p>Las sesiones admiten un nombre, por si necesitas crear sesiones separadas para el mismo cliente. No obstante, la mayor parte de las veces te bastar√° con crear sesiones sin nombre, sin necesidad de pasar ning√∫n argumento a <em>session_start()</em>.</p>

<h3 id="165-usar-variables-de-sesi√≥n-_session">1.6.5. Usar variables de sesi√≥n: $_SESSION</h3>

<p>Las variables de sesi√≥n se manipulan a trav√©s del array superglobal <strong><em>$_SESSION</em></strong>.</p>

<p>Si necesitas una variable de sesi√≥n llamada, por ejemplo, <em>nombre_usuario</em>, simplemente haz esto:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">session_start</span><span class="p">();</span>
<span class="nv">$_SESSION</span><span class="p">[</span><span class="s1">'nombre_usuario'</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"valor-de-la-variable"</span><span class="p">;</span>
</code></pre></div></div>

<p>Por supuesto, el valor de esa posici√≥n del array $_SESSION puede consultarse o modificarse cuando lo necesitemos, porque se trata de un array como otro cualquiera‚Ä¶ salvo que es <em>superglobal</em>, es decir, es accesible desde cualquier punto del programa.</p>

<h3 id="166-eliminar-variables-de-sesi√≥n-unset-y-session_destroy">1.6.6. Eliminar variables de sesi√≥n: unset() y session_destroy()</h3>

<p>La funci√≥n <strong>unset()</strong> se utiliza para destruir cualquier variable, incluidas las de sesi√≥n:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">unset</span><span class="p">(</span><span class="nv">$_SESSION</span><span class="p">[</span><span class="s1">'nombre_usuario'</span><span class="p">]);</span>
</code></pre></div></div>

<p>Si lo que deseas es destruir <em>todas</em> las variables de sesi√≥n, es preferible recurrir a <strong><em>session_destroy()</em></strong>.</p>

<p>Ahora bien, session_destroy() destruye la informaci√≥n asociada a la sesi√≥n actual, pero no elimina realmente las variables de la memoria del servidor ni borra la <em>cookie</em> de sesi√≥n del cliente.</p>

<p>Si eres un fan√°tico de la seguridad y quieres asegurarte de destruir todas las variables de sesi√≥n, puedes usar la funci√≥n <strong><em>session_unset()</em></strong>. Y, para borrar la cookie de sesi√≥n, debes usar <strong><em>setcookie()</em></strong>, como en este ejemplo:</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cp">&lt;?php</span>
<span class="nb">session_start</span><span class="p">();</span>

<span class="c1">// Destruimos todas las variables de sesi√≥n (optativo)</span>
<span class="nb">session_unset</span><span class="p">();</span>

<span class="c1">// Si queremos destruir la sesi√≥n completamente, borramos tambi√©n la cookie de sesi√≥n.</span>
<span class="nv">$params</span> <span class="o">=</span> <span class="nb">session_get_cookie_params</span><span class="p">();</span>
<span class="nb">setcookie</span><span class="p">(</span><span class="nb">session_name</span><span class="p">(),</span> <span class="s1">''</span><span class="p">,</span> <span class="nb">time</span><span class="p">()</span> <span class="o">-</span> <span class="mi">42000</span><span class="p">,</span>
        <span class="nv">$params</span><span class="p">[</span><span class="s2">"path"</span><span class="p">],</span> <span class="nv">$params</span><span class="p">[</span><span class="s2">"domain"</span><span class="p">],</span>
        <span class="nv">$params</span><span class="p">[</span><span class="s2">"secure"</span><span class="p">],</span> <span class="nv">$params</span><span class="p">[</span><span class="s2">"httponly"</span><span class="p">]</span>
<span class="p">);</span>

<span class="c1">// Finalmente, cerramos 0la sesi√≥n</span>
<span class="nb">session_destroy</span><span class="p">();</span>
<span class="cp">?&gt;</span>
</code></pre></div></div>

<h3 id="167-control-de-acceso-a-las-aplicaciones-web">1.6.7. Control de acceso a las aplicaciones web</h3>

<p><em>Cookies</em> y variables de sesi√≥n se usan a menudo, por separado o de forma combinada, para controlar el acceso a una aplicaci√≥n web. Es decir, para hacer el <em>login</em>.</p>

<p>En este punto conviene que te hagas esta pregunta: ¬øqu√© significa ‚Äúloguearse‚Äù en una aplicaci√≥n?</p>

<p>Pi√©nsalo un momento. ¬øQu√© significa eso <em>realmente</em>?</p>

<p>Por supuesto, implica superar un formulario donde se nos pregunta nuestro nombre de usuario (o nuestro email, o alguna otra identificaci√≥n) y una contrase√±a. Pero, si lo superamos, ¬øqu√© sucede entonces?</p>

<p><strong>Autenticarse o ‚Äúloguearse‚Äù en una aplicaci√≥n significa que esa aplicaci√≥n <em>cambia de estado</em> y pasa a reconocernos como usuarios registrados</strong>. <em>Algo</em> tiene que cambiar dentro de la aplicaci√≥n, porque a partir de ese momento, y solo para nosotros, se comportar√° de un modo distinto.</p>

<p>Ese ‚Äúalgo‚Äù implica que la aplicaci√≥n recordar√° qui√©nes somos nosotros y cuales son nuestros privilegios en la aplicaci√≥n hasta que cerremos la sesi√≥n. Y sobre nosotros puede recordar muchas cosas: el nombre, los apellidos, nuestra foto de perfil‚Ä¶ Pero, sobre todas esas cosas, hay una fundamental: nuestro ID de usuario.</p>

<p>Todos los usuarios registrados tienen un ID en todos los sistemas. A la aplicaci√≥n le basta con conocer nuestro ID para recordar qui√©nes somos.</p>

<p>¬øY c√≥mo ‚Äúrecuerda‚Äù una aplicaci√≥n web un dato como ese? Muy f√°cil: almacen√°ndolo en una <em>cookie</em> o en una variable de sesi√≥n, que son persistentes hasta que el programa decide destruirlas. Es decir, cuando el usuario abandona la aplicaci√≥n, el programa debe destruir la <em>cookie</em> o destruir la sesi√≥n.</p>

<p>Justo en este momento hay una cosa que tiene que quedarte muy clara: <strong>¬°ninguno de estos m√©todos es completamente seguro!</strong>.</p>

<p>Las <em>cookies</em> pueden rastrearse o modificarse en el ordenador del cliente. Adem√°s, algunos clientes las tienen desactivadas. ¬°No te puedes fiar de ellas!</p>

<p>Las variables de sesi√≥n, en principio m√°s seguras, pueden ser atacadas capturando el ID de sesi√≥n, como veremos m√°s adelante.</p>

<p>El m√©todo m√°s seguro, y el m√°s complicado de programar, es el que combina:</p>

<ul>
  <li>Cookies y/o variables de sesi√≥n.</li>
  <li>Variables guardadas en una tabla de la BD.</li>
</ul>

<p>El uso de <em>frameworks</em> solventes (como Laravel, que estudiaremos m√°s adelante) hace innecesario tomarse este trabajo, puesto que todos habilitan un mecanismo de sesiones seguras que mejora notablemente las prestaciones de las sesiones nativas de PHP.</p>

<p>No obstante, en las actividades resueltas y propuestas del final del tema plantearemos una soluci√≥n para la autenticaci√≥n de usuarios desarrollada por nosotros mismos y que resultar√° razonablemente segura.</p>

<h3 id="168-autenticaci√≥n-mediante-acl">1.6.8. Autenticaci√≥n mediante ACL</h3>

<p>Casi todas las aplicaciones web, como hemos visto, tienen un subsistema de autenticaci√≥n de usuarios. El m√°s completo de esos subsistemas es el de las <strong>listas de control de acceso</strong> (ACL = Access Control List).</p>

<p>Ese subsistema suele estar basado en este dise√±o de base de datos:</p>

<p><img src="../assets/images/03-acl.jpg" alt="Tablas ACL" /></p>

<p>Esto significa que necesitas <strong>cinco tablas</strong> para implementar un ACL completo.</p>

<p>Sin embargo, muchas veces tendremos suficiente con solo tres tablas (users, roles y roles-users), o incluso solo con una (users, a√±adiendo quiz√° un campo ‚Äútype‚Äù).</p>

<p><strong>Optar por una soluci√≥n m√°s o menos compleja depender√° del tipo de sistema que estemos implementando.</strong></p>

<p>En cualquier caso, es conveniente que conozcas el esquema ACL completo (es decir, el de 5 tablas) para que lo pongas en pr√°ctica cuando lo necesites. Por eso te lo he presentado. Ahora ya sois oficialmente amigos.</p>
:ET