{"0": {
    "doc": "0. Presentación de la asignatura",
    "title": "0. Presentación de la asignatura",
    "content": ". | 0.1. Contextualización y horario | 0.2. Competencias específicas | 0.3. Contenido | 0.4. Evaluación y calificación | 0.5. Profesor y contacto | . ",
    "url": "https://iescelia.org//docs/tico/_site/presentacion/",
    "relUrl": "/presentacion/"
  },"1": {
    "doc": "0. Presentación de la asignatura",
    "title": "0.1. Contextualización y horario",
    "content": ". | Asignatura: Tecnologías de la información y la comunicación II | Curso: 2º de Bachillerato | Duración: 72 horas (2 horas semanales). | Horario: por determinar. | Profesor: Alfredo Moreno Vozmediano | Contacto: alfredomoreno@iescelia.org (también a través de Moodle Centros o de Pasen). | . ",
    "url": "https://iescelia.org//docs/tico/_site/presentacion/#01-contextualizaci%C3%B3n-y-horario",
    "relUrl": "/presentacion/#01-contextualización-y-horario"
  },"2": {
    "doc": "0. Presentación de la asignatura",
    "title": "0.2. Competencias específicas",
    "content": "Las competencias específicas de esta asignatura son las siguientes: . | Comprender el impacto de la tecnología informática y de comunicaciones en la sociedad actual. | Comprender qué es un algoritmo y cómo puede convertirse en un programa informático. | Desarrollar y depurar aplicaciones informáticas para resolver problemas concretos. | Crear proyectos web utilizando una diversidad de herramientas informáticas. | Comprender el funcionamiento de Internet. | Configurar equipos informáticos y usar programas de forma segura, responsable y respetuosa. | Emplear la creatividad en el desarrollo de aplicaciones informáticas para resolver problemas y fomentar la capacidad de expresión personal. | Fomentar el trabajo en equipo y la comunicación interpersonal. | . ",
    "url": "https://iescelia.org//docs/tico/_site/presentacion/#02-competencias-espec%C3%ADficas",
    "relUrl": "/presentacion/#02-competencias-específicas"
  },"3": {
    "doc": "0. Presentación de la asignatura",
    "title": "0.3. Contenido",
    "content": "Los contenidos de la asignatura se dividen en tres bloques y 11 unidades didácticas. Los resumimos a continuación. Bloque 1. Desarrollo de software . | UD1. Introducción a la programación. | UD2. Programación con diagramas de flujo. | UD3. Programación con pseudocódigo. | . Bloque 2. Publicación de contenidos . | UD4. Internet y la web. | UD5. Diseño de páginas web. | UD6. Hojas de estilos. | . Bloque 3. Seguridad informática . | UD7. Principios de seguridad informática. | UD8. Recuperación de datos. | UD9. Criptografía y cifrado. | UD10. Software malicioso. | . ",
    "url": "https://iescelia.org//docs/tico/_site/presentacion/#03-contenido",
    "relUrl": "/presentacion/#03-contenido"
  },"4": {
    "doc": "0. Presentación de la asignatura",
    "title": "0.4. Evaluación y calificación",
    "content": "A lo largo de curso se usarán los siguientes instrumentos de evaluación: . | Observación del trabajo diario en el aula (calificación de 1 a 10). | Actividades, prácticas y proyectos (calificación de 1 a 10). | Test de conocimientos (exámenes) (calificación de 1 a 10). | . Las diferentes competencias se evaluarán con uno o varios de los instrumentos anteriores. Cada competencia tendrá un peso diferente en la nota final. Puedes consultar la programación de la asignatura, que se publicará en la web del instituto a lo largo del primer trimestre, para ver cuales son esos pesos exactamente. La nota final del curso se obtendrá mediante una media aritmética de las calificaciones obtenidas en cada trimestre, ponderados adecuadamente (40% del primer trimestre, 40% del segundo y 20% del tercero, que es más corto). Se hará un examen teórico-práctico final, con actividades de un nivel similar a las propuestas en las prácticas y proyectos, para las personas que no hayan superado alguna de las evaluaciones trimestrales. También se podrá habilitar un calendario adicional de entrega de prácticas a final de curso para aquellas personas que no hayan superado alguna de las prácticas obligatorias a lo largo del año. Asimismo, habrá una recuperación en junio con la misma naturaleza y que abarcará toda la materia impartida durante el curso, incluyendo la entrega de las prácticas necesarias para superar la asignatura. ",
    "url": "https://iescelia.org//docs/tico/_site/presentacion/#04-evaluaci%C3%B3n-y-calificaci%C3%B3n",
    "relUrl": "/presentacion/#04-evaluación-y-calificación"
  },"5": {
    "doc": "0. Presentación de la asignatura",
    "title": "0.5. Profesor y contacto",
    "content": "El profesor de esta asignatura es D. Alfredo Moreno Vozmediano, del Departamento de Informática del IES Celia Viñas, Ingeniero Técnico en Informática de Sistemas por la Universidad de Castilla - La Mancha e Ingeniero en Informática por la Universidad de Málaga. Trabaja como profesor de enseñanza secundaria para la Junta de Andalucía desde el año 2000. Tanto el alumnado como las familias pueden contactar directamente con él a través de alguno de estos medios: . | Por email a la dirección alfredomoreno@iescelia.org | A través de la mensajería interna Moodle Centros (solo para alumnado) | A través de la mensajería interna de iPasen (para alumnado y para familias, puesto que cada uno cuenta con sus propias credenciales de acceso) | . ",
    "url": "https://iescelia.org//docs/tico/_site/presentacion/#05-profesor-y-contacto",
    "relUrl": "/presentacion/#05-profesor-y-contacto"
  },"6": {
    "doc": "1. Introducción a la programación",
    "title": "1. Introducción a la programación",
    "content": ". | 1.1. El pensamiento computacional . | 1.1.2. Características del pensamiento computacional | 1.1.3. El pensamiento computacional vs la programación | . | 1.2. ¿Qué es exactamente eso de “programar un ordenador”? | 1.3. Algunos conceptos fundamentales (antes de empezar) . | 1.3.1. Codificación de la infirmación | 1.3.2. El código binario | 1.3.3. El código ASCII | 1.3.4. El código UTF-8 de Unicode | 1.3.5. El código hexadecimal | 1.3.6. Unidades de medida de información | . | 1.4. Programas y algoritmos . | 1.4.1. Datos y tipos de datos | 1.4.2. Variables y constantes | 1.4.3. Subalgoritmos | 1.4.4. Expresiones y operadores | 1.4.5. Tipos de instrucciones | . | 1.5. Diagramas de flujo y pseudocódigo . | 1.5.1. Formas de escribir algoritmos | 1.5.2. Un ejemplo real | . | 1.6. Los lenguajes de programación . | 1.6.1. Tipos de lenguaje según el nivel de abstracción: alto y bajo nivel | 1.6.2. Tipos de lenguaje según su generación | 1.6.3. Tipos de lenguaje según su forma de traducción | 1.6.4. Tipos de lenguaje según su tipado | 1.6.5. El top ten de los lenguajes de programación | . | 1.7. Ejercicios propuestos | . ",
    "url": "https://iescelia.org//docs/tico/_site/introduccion-a-la-programacion/",
    "relUrl": "/introduccion-a-la-programacion/"
  },"7": {
    "doc": "1. Introducción a la programación",
    "title": "1.1. El pensamiento computacional",
    "content": "El pensamiento computacional es un proceso de formulación y resolución de problemas que utiliza los conceptos de la ingeniería informática. Es decir, consiste en pensar como lo haría un científico-informático cuando está frente un problema y tener la habilidad y la actitud para que nos sea útil tanto en nuestra vida personal como profesional. Hemos dicho “vida personal”, sí. Uno de los errores más frecuentes cuando se habla de pensamiento computacional es considerar que solo se aplica a la Informática. El pensamiento computacional sirve para resolver problemas cotidianos haciendo uso de las técnicas y habilidades de los programadores/as informáticos y obtener así soluciones que pueden ser representadas mediante una serie de pasos o instrucciones. Aquí tienes un vídeo que desarrolla esta interesante idea en tres minutos: . 1.1.2. Características del pensamiento computacional . Según las definiciones que hemos visto en el apartado anterior, el pensamiento computacional es un proceso de resolución de problemas que incluye las siguientes características: . | Reformular problemas de forma que se permita el uso de un ordenador y otras herramientas para ayudar a resolverlos. | Organizar y analizar lógicamente la información. | Representar la información a través de abstracciones como los modelos y las simulaciones. | Automatizar soluciones haciendo uso del pensamiento algorítmico (estableciendo una serie de pasos ordenados para llegar a la solución). | Identificar, analizar e implementar posibles soluciones con el objetivo de lograr la combinación más efectiva y eficiente de pasos y recursos. | Generalizar y transferir este proceso de resolución de problemas para ser capaz de resolver una gran variedad de familias de problemas. | . Ejemplo de pensamiento computacional . Escribir una receta de cocina siguiendo unos pasos o instrucciones sería un buen primer ejemplo de aplicación para el pensamiento computacional. Por ejemplo, supongamos que queremos cocinar un risotto utilizando un sobre de comida preparada (para que sea más rápido). No te preocupes si no tienes ni idea de lo que es un risotto. En realidad, y gracias al pensamiento computacional, no necesitas saber lo que es para prepararlo, puesto que el pensamiento computacional te permite disponer de una receta. En este caso, los pasos de la receta serían más o menos estos: . | Abrir el sobre | Poner a calentar el agua | Esperar a que el agua hierva | Si hierve, verter el sobre | Remover el contenido de la olla | Apagar el fuego y dejar reposar | Servir en el plato para “x” personas | . Si sigues esos pasos, seguro que puedes obtener algo comestible aunque no tengas ni idea de qué estás cocinando en realidad, ¿verdad? . El pensamiento computacional consiste en enfrentarse a un problema (como “cocinar un risotto”) y obtener una solución (como una “receta”) que permita solucionarlo todas las veces que sean necesarias. Si la “receta” anterior la escribiéramos usando un lenguaje de programación, tendríamos en nuestras manos un programa de ordenador. De hecho, podemos “escribirla” en un lenguaje de programación por bloques gráficos, como el popular Scratch, y nos quedaría algo así: . 1.1.3. El pensamiento computacional vs la programación . Los términos “pensamiento computacional” y “programación” no son sinónimos. Esta es una confusión muy habitual. La programación solo es una de las posibles herramientas con la que se pone en práctica el pensamiento computacional. Por eso la programación y el pensamiento computacional comparten los mismos procesos cognitivos. La programación limita sus procesos de resolución de problemas al ámbito de la informática. Para ello, hace uso de diferentes lenguajes de programación. Puedes pedir a un ordenador que haga muchas cosas, pero no que prepare un risotto. Así que el pensamiento computacional puede aplicarse a problemas más allá de la informática. Curiosidad: ¿sabías que las peronas que aprenden a utilizar un lenguaje de programación muestran mayor capacidad de atención y autonomía, y obtienen en promedio mejores resultados en pruebas matemáticas, que las que no saben programar? . Diversos estudios han demostrado que, mediante los lenguajes de programación, se desarrollan ciertas habilidades cognitivas como: . | El pensamiento lógico. | La creatividad. | El razonamiento abstracto. | La capacidad de resolución de problemas. | . Así que, si quieres orientar tu vida académica hacia las ciencias o la ingeniería, aprender a programar puede ser una herramienta muy útil para ti. Pero incluso si tus preferencias académicas van por otro camino, las rutinas de pensamiento computacional que adquirirás programando te reportarán muchos beneficios que quizá no sospechabas. ",
    "url": "https://iescelia.org//docs/tico/_site/introduccion-a-la-programacion/#11-el-pensamiento-computacional",
    "relUrl": "/introduccion-a-la-programacion/#11-el-pensamiento-computacional"
  },"8": {
    "doc": "1. Introducción a la programación",
    "title": "1.2. ¿Qué es exactamente eso de “programar un ordenador”?",
    "content": "Programar un ordenador no es más que proporcionarle a la máquina un conjunto de instrucciones y datos para que realice una tarea. Esa tarea, generalmente, resuelve un problema concreto, que puede ir desde realizar complicados cálculos matemáticos hasta entretenernos con un videojuego en nuestros ratos de ocio. El conjunto de las instrucciones que conforma el programa se denomina código fuente, y tiene que estar escrito en un lenguaje comprensible por la máquina, es decir, un lenguaje de programación. Esas instrucciones se traducen a código binario (que, recuerda, es lo único que puede comprender el ordenador). La CPU de un ordenador está construida de manera que puede entender y ejecutar ciertas instrucciones binarias, gracias a lo cual nuestro programa acaba ejecutándose en las entrañas de la máquina. Este es un fragmento de un programa informático real escrito en lenguaje PHP. Implementa un algoritmo de ordenación de elementos llamado Bubble Sort o, en español, método de la burbuja. No es necesario, ni mucho menos, que lo entiendas de momento. Solo quiero que le eches un vistazo para que veas el aspecto que tiene un programa real (o un fragmento) escrito en un lenguaje real. function bubble_Sort($my_array ) { do { $swapped = false; for( $i = 0, $c = count( $my_array ) - 1; $i &lt; $c; $i++ ) { if( $my_array[$i] &gt; $my_array[$i + 1] ) { list( $my_array[$i + 1], $my_array[$i] ) = array( $my_array[$i], $my_array[$i + 1] ); $swapped = true; } } } while( $swapped ); return $my_array; } $test_array = array(3, 0, 2, 5, -1, 4, 1); echo \"Original Array :\"; echo implode(', ',$test_array ); echo \"Sorted Array:\"; echo implode(', ',bubble_Sort($test_array)). PHP_EOL; . (Fuente: php.net) . ",
    "url": "https://iescelia.org//docs/tico/_site/introduccion-a-la-programacion/#12-qu%C3%A9-es-exactamente-eso-de-programar-un-ordenador",
    "relUrl": "/introduccion-a-la-programacion/#12-qué-es-exactamente-eso-de-programar-un-ordenador"
  },"9": {
    "doc": "1. Introducción a la programación",
    "title": "1.3. Algunos conceptos fundamentales (antes de empezar)",
    "content": "Antes de lanzarse a programar un ordenador, es necesario conocer algunos conceptos fundamentales relacionados con los ordenadores. Estos conceptos forman parte de la “culturilla” popular, pero no todo el mundo los tiene claros. En esta sección, vamos a aclarar qué cosas como: . | ¿Qué narices es el código binario (o código máquina) y por qué es tan importante en informática? | ¿Qué es el código ASCII, el UTF-8 o el Unicode? | ¿Qué diferencia hay entre bit o byte? ¿Y entre un GB y un TB? ¿Y entre un GB (con B mayúscula) y un Gb (con b minúscula)? O, más difícil aún, ¿es lo mismo un GB que un GiB? Menudo lío de letras, ¿verdad? | . 1.3.1. Codificación de la infirmación . Un código es un método de representación de la información. Se compone de un conjunto de símbolos, llamado alfabeto, y de un conjunto de reglas para combinar esos símbolos de forma correcta. Estos son algunos ejemplos de códigos que utilizas todos los días o que, al menos, conoces: . | Ejemplo 1: la lengua castellana es un código. Su alfabeto es el abecedario (a, b, c, d, e … z), pero los símbolos del alfabeto no se pueden combinar a lo loco, sino que existen unas reglas, y sólo siguiendo esas reglas se codifica correctamente la información, dando lugar a mensajes con sentido. Esas reglas las habéis estudiado en la asignatura de lengua castellana desde la enseñanza primaria. | Ejemplo 2: el código morse también es un código. Su alfabeto es muy reducido: sólo el punto (.) y la raya (–), pero combinando los dos símbolos correctamente, se puede transmitir cualquier información. | Ejemplo 3: el sistema de numeración decimal es un código. Tiene un alfabeto de 10 símbolos (0, 1, 2, 3, 4, 5, 6, 7, 8 y 9). Combinándolos según ciertas reglas, puede usarse para transmitir información. Pero ojo, no cualquier información, solamente información numérica. Hemos dicho que los códigos sirven para representar información, pero no que tengan que servir para representar toda la información posible. Aunque sólo sirva para los números, el sistema de numeración también es un código. | . 1.3.2. El código binario . Pues bien, el sistema de numeración binario también es un código. Es muy parecido al sistema de numeración decimal, con la única diferencia de la cantidad de símbolos del alfabeto. Si el decimal tiene diez, el binario sólo tiene dos: el 0 y el 1. En todo lo demás son iguales, así que el sistema binario también sirve para representar información numérica. Pero, ¿puede representarse cualquier número con sólo dos símbolos? . La respuesta es sí. El modo de hacerlo consiste en combinar los símbolos 0 y 1 adecuadamente, igual que hacemos con los números decimales. En el sistema decimal contamos así: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9. Cuando queremos pasar a la siguiente cantidad, empezamos a agrupar los dígitos de dos en dos: 10, 11, 12, 13, 14, 15, 16, 17, 18, 19. Al volver a terminar las unidades, vamos incrementando las decenas: 20, 21, 22, etc. (Esto se debe a que, en los sistemas de numeración, cada dígito tiene un valor posicional, es decir, tiene un valor diferente dependiendo del lugar que ocupe en el número general. Por ejemplo, en el número 283, el 3 tiene valor de tres, pero el 8 no tiene valor de ocho, sino de ochenta, y el 2 no tiene valor de dos, sino de doscientos) . En binario, el razonamiento es el mismo. Empezamos a contar por 0 y 1, pero entonces ya hemos agotado los símbolos, así que empezamos a agruparlos: 10, 11. Como hemos vuelto a agotarlos, seguimos combinándolos: 100, 101, 110, 111, 1000, 1001, 1010, y así sucesivamente. Así, los 16 primeros números binarios comparados con sus equivalentes decimales son: . | Decimal | Binario | . | 0 | 0000 | . | 1 | 0001 | . | 2 | 0010 | . | 3 | 0011 | . | 4 | 0100 | . | 5 | 0101 | . | 6 | 0110 | . | 7 | 0111 | . | 8 | 1000 | . | 9 | 1001 | . | 10 | 1010 | . | 11 | 1011 | . | 12 | 1100 | . | 13 | 1101 | . | 14 | 1110 | . | 15 | 1111 | . Los números escritos en código binario tienen el mismo valor que en decimal, y sólo cambia la representación. Es decir, “15” en decimal y “1111” en binario representan exactamente a la misma idea: quince. Convertir números binarios a decimales . Para obtener la representación decimal de un número binario hay que proceder según el Teorema Fundamental de la Normalización, del siguiente modo: . | Numeramos la posición que ocupa cada dígito binario de derecha a izquierda, empezando por 0. Por ejemplo, en el número binario 1010011, numeraremos las posiciones así: . Posiciones --&gt; 6 5 4 3 2 1 0 Dígitos --&gt; 1 0 1 0 0 1 1 . | Multiplicamos cada dígito binario por 2 elevado a la posición del dígito y sumamos todos los resultados. Con el número del ejemplo anterior: . 1 x 26 + 0 x 25 + 1 x 24 + 0 x 23 + 0 x 22 + 1 x 21 + 1 x 20 . | Ahora sólo nos quedaría sumar los resultados de todas las multiplicaciones: . 64 + 0 + 16 + 0 + 0 + 2 + 1 = 83 . | . Por lo tanto, el número binario 1010011 es equivalente al número decimal 83. Es habitual indicar con un subíndice el sistema de numeración al que pertenece cada número, así: . 10100112 = 8310 . Convertir números decimales a binarios . El proceso contrario se realiza dividiendo sucesivamente el número decimal entre dos, y cogiendo el último cociente y todos los restos en el orden inverso al que los obtuvimos. Por ejemplo, vamos hallar la representación binaria del número 8310: . Tomando el último cociente (que siempre es 1) y todos los restos desde el último hacia el primero (es decir, 010011, siguiendo la dirección de la flecha), obtenemos el número binario 1010011. Por lo tanto, podemos decir que: . 8310 = 10100112 . Operaciones aritméticas binarias . La operaciones aritméticas binarias se realizan exactamente igual que las decimales, aunque teniendo la precaución de usar sólo los dos símbolos permitidos (0 y 1), lo que puede parecernos un poco extraño al principio. Por ejemplo, para realizar una suma de dos números binarios, escribiremos ambos números uno encima de otro, alineados a la derecha, como hacíamos cuando estábamos aprendiendo a sumar. Luego, iremos sumando los dígitos de derecha a izquierda, como haríamos con dos números decimales, con la precaución de sumar también el acarreo cuando se produzca. Vamos a sumar los números 110012 y 10112: . 1 1 1 &lt;-- acarreos 1 1 0 0 1 + 1 0 1 1 ---------------- 1 0 0 1 0 0 . Del mismo modo, pueden realizarse otras operaciones aritméticas como restas, productos o divisiones. 1.3.3. El código ASCII . Hasta ahora hemos visto que mediante el código binario se pueden representar números, pero no sabemos cómo se las apaña un ordenador para representar las letras, o, dicho en terminología informática, los caracteres alfanuméricos (que incluyen números, letras y otros símbolos, como los signos de puntuación). El código ASCII consiste en una correspondencia entre números binarios de 8 dígitos y caracteres alfanuméricos. (Bueno, en realidad el código ASCII original usaba números binarios de 7 dígitos, pero eso es otra historia. El ASCII que ha llegado hasta nuestros días es el ASCII extendido de 8 bits). Así, por ejemplo, al número 6510 (expresado en binario, 010000012) se le hace corresponder la letra “A”, al 6610 la “B”, al 6710 la “C”, etc. De este modo, el ordenador puede también manejar letras, y lo hace del mismo modo en que maneja números: mediante combinaciones de ceros y unos. La siguiente tabla muestra los 127 primeros caracteres del código ASCII junto con el número al que corresponden en decimal, binario, octal y hexadecimal (estos dos últimos son sistemas de numeración que veremos enseguida): . (Fuente: Wikimedia Commons - Dominio público) . Es importante resaltar que los códigos ASCII siempre tienen 8 dígitos binarios, rellenándose con ceros a la izquierda si fuera necesario. Así ocurre en el caso de la letra A, que, como hemos dicho, se representa con el código 01000001. Si te tomas la molestia de calcular cuántos caracteres diferentes pueden representarse con el código ASCII, verás que son exactamente 256. Suficientes para todos los caracteres habituales, ¿verdad? Aunque, un momento… ¿Y qué hay de los caracteres griegos? ¿O los caracteres cirílicos del ruso? Eso por no hablar del chino y o el japonés. Si queremos dar cabida a cualquier idioma del mundo, el código ASCII se nos queda rápidamente pequeño. Por eso se ideó otra forma de codificación de caracteres que es la que más se usa en la actualidad: Unicode. 1.3.4. El código UTF-8 de Unicode . El código ASCII no es, desde luego, el único que existe para representar letras en binario, pero sí el más popular por motivos históricos. A finales de la década de 1980, se empezó a desarrollar un proyecto para codificar de forma unívoca todos los caracteres de todas las lenguas del mundo (¡incluidas lenguas muertas!). A ese proyecto se lo denominó Unicode. Unicode se ha impuesto con fuerza en la actualidad. Por ejemplo, este documento que estás leyendo ahora mismo está codificado con Unicode, en su versión UTF-8. Y es que Unicode tiene varias implementaciones: . | UTF-8: los caracteres se codifican en grupos de 8 bits. Algunos solo necesitan 8 bits, pero otros necesitan 16, 24 o incluso 32 bits. Por ejemplo, la “N” se codifica con 8 bits (los mismos que en el viejo ASCII), pero la “Ñ” se codifica con 16: los 8 correspondientes a la “N” más los 8 correspondientes al símbolo “~” | UTF-16: los caracteres se codifican en grupos de 16 bits. Algunos solo necesitan 16 bits, pero otros necesitan el doble, es decir, 32. | UTF-32: los caracteres se codifican en grupos de 32 bits. Eso da un total de 232 caracteres posibles, más que suficientes para codificar todas las lenguas existentes en el mundo. Es la forma de Unicode más simple que existe. | . La codificación más popular es la UTF-8 de Unicode. Aunque es algo más compleja que la UTF-32, los textos codificados de este modo ocupan mucho menos espacio. Los primeros 127 caracteres del UTF-8 se corresponden con el viejo código ASCII. Por eso mismo, y para propósitos prácticos, las tablas clásicas de código ASCII siguen siendo vigentes, al menos hasta el carácter número 127. 1.3.5. El código hexadecimal . Es importante conocer y saber manejar el código binario al ser el método de codificación que emplean los ordenadores digitales, pero este código tiene dos serios inconvenientes: . | Resulta difícil de manipular para nuestros cerebros, que destán habituados a pensar en decimal (o habituados a no pensar en absoluto, que también se da el caso). | Los números binarios pueden llegar a tener cantidades enormes de dígitos. Es habitual trabajar con números de 16, 32 o 64 dígitos binarios, lo cual los convierte en inmanejables. | . Por este motivo, suelen usarse, en programación, otros dos sistemas de numeración llamados octal y hexadecimal. | El sistema octal maneja 8 símbolos distintos: 0, 1, 2, 3, 4, 5, 6 y 7. | El sistema hexadecimal, por su parte, tiene 16 símbolos: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E y F. | . Sin duda, el más utilizado de los dos es el hexadecimal y por este motivo nos vamos a detener en él, aunque haciendo notar que el octal funciona de la misma manera. En hexadecimal, por tanto, es normal ver números cuyos dígitos son letras del alfabeto. Por ejemplo: 2AF5 es un número válido escrito en hexadecimal (exactamente, 10997 en decimal). La forma de contar, por supuesto, es la misma: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, y después empezamos a agrupar los símbolos: 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 1A, 1B, 1C, 1D, 1E, 1F. Seguiríamos con 20, 21, 22, etc. Podemos construir una tabla para comparar los primeros números en los tres sistemas de numeración que conocemos. Hemos rellenado los primeros números binarios con ceros a la izquierda por razones que pronto se verán, pero en realidad los números no cambian (recuerda que un cero a la izquierda no tiene ningún valor, ni en binario ni en el resto de sistemas) . | Decimal | Binario | Hexadecimal | . | 0 | 0000 | 0 | . | 1 | 0001 | 1 | . | 2 | 0010 | 2 | . | 3 | 0011 | 3 | . | 4 | 0100 | 4 | . | 5 | 0101 | 5 | . | 6 | 0110 | 6 | . | 7 | 0111 | 7 | . | 8 | 1000 | 8 | . | 9 | 1001 | 9 | . | 10 | 1010 | A | . | 11 | 1011 | B | . | 12 | 1100 | C | . | 13 | 1101 | D | . | 14 | 1110 | E | . | 15 | 1111 | F | . Si te fijas, cada dígito hexadecimal se corresponde exactamente con una combinación de 4 dígitos binarios. Así, por ejemplo, el número binario 1001 1101 se puede escribir más resumidamente como 9D en hexadecimal (porque 10012 equivale a 916 y 11012 equivale a D16). Y esa es la gran utilidad del sistema hexadecimal: permite manipular números binarios de forma más escueta y resumida, de manera que nos sean más fáciles de manejar a nosotros, los humanos, que somos muy propensos a cometer errores. Convertir números hexadecimales a decimales . El mecanismo es el mismo que ya utilizamos para convertir números binarios, sólo que cambiando la base del sistema de numeración de 2 a 16, ya que ahora vamos a manejar números hexadecimales. Por lo tanto, los pasos a seguir son: . | Numeramos las posiciones que ocupa cada dígito hexadecimal de derecha a izquierda, empezando por 0. Por ejemplo, en el número hexadecimal 2AF, numeraremos las posiciones así: . Posiciones --&gt; 2 1 0 2 A F . | Multiplicamos cada dígito hexadecimal por 16 elevado a la posición del dígito y sumamos todos los resultados. Con el número 2AF lo haríamos así: . | . 2 x 162 + A x 161 + F x 160 . Según la tabla de anterior, tenemos que el dígito hexadecimal A equivale a 10 en decimal, y que F equivale a 15. Por lo tanto la operación quedaría así: . 2 x 162 + 10 x 161 + 15 x 160 . Ahora sólo nos falta resolver la operaciones y sumar: . 2 x 256 + 10 x 16 + 15 x 1 = 687 . Por lo tanto, el número hexadecimal 2AF es equivalente al número decimal 687. Indicándolo con subíndices, lo expresaríamos así: . 2AF16 = 68710 . Convertir números decimales a hexadecimales . El proceso también es idéntico al realizado con números binarios, pero sustituyendo la división entre 2 por divisiones entre 16, que es la base del sistema hexadecimal. Relación entre números hexadecimales y binarios . La verdadera utilidad del sistema hexadecimal es que se puede utilizar en lugar del binario, siendo más fácil de manejar. Para que ello sea posible, el paso de hexadecimal a binario y viceversa debe poder hacerse con mucha rapidez. Para convertir un número hexadecimal a binario, basta con sustituir cada dígito hexadecimal por sus cuatro cifras binarias correspondientes, según la tabla de correspondencias que hemos visto más arriba. Por ejemplo: . 2AF16 = 0010 1010 11112 . Del mismo modo, para convertir un número binario a hexadecimal, lo agruparemos en bloques de 4 cifras binarias (empezando por la derecha) y buscaremos la correspondencia en la tabla. Por ejemplo, el número binario 100100 se convierte así: . 0010 01002 = 2416 . Observa que hemos rellenado con ceros a la izquierda para obtener bloques de 4 dígitos binarios sin alterar la esencia del número. Por supuesto, no es obligatorio usar este truco de rellenar con ceros a la izquierda, pero las primeras veces puede facilitar las cosas. Con un poco de práctica conseguirás convertir binarios a hexadecimales y viceversa de un sólo vistazo y sin necesidad de consultar la tabla. 1.3.6. Unidades de medida de información . Como hemos visto, el código binario es el fundamento del funcionamiento de los ordenadores: toda la información que el ordenador maneja, ya sea numérica o alfanumérica, se encuentra codificada en binario. Del mismo modo que para medir distancias se utiliza el metro, o para medir masas se utiliza el gramo, para medir la cantidad de información almacenada o procesada en un ordenador existe una unidad de medida. Como el ordenador representa toda la información en binario, la unidad fudamental de medida de la cantidad de información es el dígito binario (es decir, 0 ó 1), también llamado BIT (de BInary digiT) . Un bit es realmente muy poca cantidad de información. Recuerda que, por ejemplo, para almacenar un sólo carácter en código ASCII son necesarios 7 u 8 bits. ¡Para un único carácter! . Del mismo modo que el metro dispone de múltiplos (el decámetro, el hectómetro, el kilómetro, etc), también los tiene el bit, y son los siguientes: . | Bit: Unidad fundamental de medida de la cantidad de información. | Byte: 1 byte equivale a 8 bits (un carácter). Esto no siempre ha sido así, pero, en la actualidad, se acepta la cifra de 8 como estándar. Cuidado con el nombre, porque se parecen y es un error común confundir el bit con el byte. | Kibibyte (KiB): 1 kilobyte son 1024 bytes. Fïjate que es parecido al kilómetro (1000 metros), pero no exactamente igual. | Mebibyte (MiB): 1 megabyte equivale a 1024 kilobytes. | Gibibyte (GiB): 1 gigabyte equivale a 1024 megabytes. | Tebibyte (TiB): 1 terabyte equivale a 1024 gigabytes | Pebibyte (PiB): 1 pebibyte equivale a 1024 tebibytes. | Exbibyte (EiB): 1 exbibyte equivale a 1024 pebibytes. | . Podemos resumir las unidades de medida de información en la siguiente tabla: . 1 Byte = 8 bits 1 KiB = 1024 Bytes 1 MiB = 1024 KiB 1 GiB = 1024 MiB 1 TiB = 1024 GiB 1 PiB = 1024 TiB 1 EiB = 1024 PiB . Existe otra colección de múltiplos del Byte que se incrementan en potencias de 10, como sucede con los múltiplos de otras magnitudes físicas (tales como el kilómetro, el kilogramo, etc). Se introdujeron hace unos años para acabar con la confusión que provocaba el hecho de que algunos fabricantes consideraban que 1 KB eran 1024 Bytes, mientras que otros decían que eran 1000 Bytes. Estas otras unidades son: . | Kilobyte (KB): 1 kilobyte son 1000 bytes. | Megabyte (MB): 1 megabyte equivale a 1000 kilobytes. | Gigabyte (GB): 1 gigabyte equivale a 1000 megabytes. | Terabyte (TB): 1 terabyte equivale a 1000 gigabytes | Petabyte (PB): 1 petabyte equivale a 1000 terabytes. | Exabyte (EB): 1 exabyte equivale a 1000 petabytes. | . Podemos resumir las unidades de medida de información en la siguiente tabla: . 1 Byte = 8 bits 1 KB = 1000 Bytes 1 MB = 1000 KB 1 GB = 1000 MB 1 TB = 1000 GB 1 PB = 1000 TB 1 EB = 1000 EB . Las unidades decimales son más pequeñas que las correspondientes binarias. Es decir, 1 GB, por ejemplo, son menos Bytes que 1 GiB. La diferencia es tanto mayor cuanto más grande es la unidad. Por ejemplo, 1 KB es un 2,35% más pequeño que 1 KiB, pero 1 EB es un 13,3% más pequeño que 1 EiB. ¡Entre 1 EB y 1 EiB hay 150 millones de GB de diferencia! Por lo tanto, no es de extrañar que las compañías de telefonía o los fabricantes de dispositivos de almacenamiento publiciten sus capacidades en las unidades más pequeñas posible, para que lo que te ofertan parezca más de lo que es. Por último, hacemos notar que, en ocasiones, también se usan los mismos múltiplos para el bit, no para el Byte. Así, puedes encontrarte con megabits (Mb) o mebibits (Mib), que son, respectivamente, un millón (1.000.000) de bits y 220 bits (1.048.576). O con gigabits (Gb) o gigibits (Gib). La conversión entre los múltiplos del bit los del Byte se realiza multiplicando o dividiendo entre 8, como es lógico. Observa como se usa la “b” minúscula para distinguir los bits de los Bytes. ",
    "url": "https://iescelia.org//docs/tico/_site/introduccion-a-la-programacion/#13-algunos-conceptos-fundamentales-antes-de-empezar",
    "relUrl": "/introduccion-a-la-programacion/#13-algunos-conceptos-fundamentales-antes-de-empezar"
  },"10": {
    "doc": "1. Introducción a la programación",
    "title": "1.4. Programas y algoritmos",
    "content": "Para realizar un programa es necesario idear previamente un algoritmo. Esto es importante hasta el extremo de que, sin algoritmo, no existiría el programa. Un algoritmo, como hemos visto, es una secuencia ordenada de acciones que conducen a la solución de un problema en un número finito de pasos simples. Por ejemplo, vamos a escribir un algoritmo para determinar si un número entero cualquiera (que llamaremos N) es par o impar: . - Inicio del algoritmo - Paso 1. Preguntar qué número concreto es N. - Paso 2. Si N es divisible entre 2, entonces la solución es \"PAR\". - Paso 3. Si N no es divisible entre 2, entonces la solución es \"IMPAR\". - Paso 4. Imprimir la solución. - Fin del algoritmo . Recuerda que este algoritmo está escrito para que lo ejecute un ordenador, no para que lo ejecute una persona. Por eso el Paso 1 es “Preguntar qué número es N”: porque el ordenador tendrá que preguntarnos a nosotros, los humanos, el número. Y por eso el Paso 4 es “Imprimir la solución”: porque el ordenador nos ofrecerá el resultado imprimiéndolo en la pantalla o en un papel. Este algoritmo resuelve el problema planteado en un número finito de pasos simples. Lógicamente, al ordenador no le podemos dar estas instrucciones tal y como las hemos escrito, sino que habrá que expresarlo en un lenguaje de programación, pero esto es algo que trataremos más adelante. 1.4.1. Datos y tipos de datos . Los algoritmos, como hemos dicho, son colecciones de instrucciones que resuelven un problema. Pero esas instrucciones siempre trabajan con datos, es decir, con información formalizada para su uso en un ordenador: . | Los datos de entrada son datos que el algoritmo necesita para trabajar. En el ejemplo anterior, el número “N” es un dato de entrada. | Los datos de salida son datos que el algoritmo produce como resultado de sus cálculos. En el ejemplo anterior, “solución” es un dato de salida. | . Los datos siempre pertenecen a un tipo de datos, que es el rango de valores que ese dato puede tomar. Existen multitud de tipos de datos posibles, pero empezaremos trabajando solo con estos: . | Enteros. Los datos de este tipo solo pueden tomar como valores números enteros (positivos o negativos). Ejemplos: 3, 28, -15, 0, 4982… | Reales. Números con decimales. Ejemplos: 18.25, -3.198887 | Caracteres. Letras, números, signos de puntuación… Ojo, si un dato es de tipo “carácter”, solo puede contener en cada momento un único carácter. Ejemplos: ‘a’, ‘Z’, ‘&amp;’, ‘?’ | Cadenas de caracteres. O, simplemente, cadenas. Son colecciones de letras, números, signos de puntuación… Es decir, palabras y cualquier cosa que se le parezca. Ejemplos: “Hoy es lunes”, “sgcv08 e98 ie7f83 ?so9&amp;/”. Suelen distinguirse de los caracteres individuales por la doble comilla, aunque esto depende del lenguaje de programación. | Lógicos o booleanos. Estos datos solo pueden tener dos valores: verdadero o falso. | . 1.4.2. Variables y constantes . Las variables de un algoritmo son como las variables en una ecuación matemática: representaciones de un dato a las que asignamos un nombre o identificador. En el algoritmo para averiguar si un número es par o impar, N es una variable y solución es otra variable. Las variables pueden tomar un valor perteneciente a un tipo de datos. Ese valor puede cambiar a lo largo del algoritmo (por eso se denominan variables). Lo que no puede cambiar es el tipo de datos al que pertenecen. Es decir: si una variable es entera, no puede cambiar y pasar a ser real durante la ejecución del programa. (Bueno, hay lenguajes que sí permiten hacer esto, pero esa es otra historia). Por eso, la mayoría de los lenguajes de programación exigen que les indiquemos a qué tipo de datos pertenece cada variable antes de usarlas por primera vez. Es algo que también haremos en pseudocódigo. Eso se denomina declarar una variable. Así pues, podemos mejorar el algoritmo anterior con la declaración de las variables “N” y “solución”: . - Inicio del algoritmo - Declaración de variables: - N es un número entero. - solución es una cadena de caracteres. - Paso 1. Averiguar qué número es N. - Paso 2. Si N es divisible entre 2, entonces la solución es \"PAR\". - Paso 3. Si N no es divisible entre 2, entonces la solución es \"IMPAR\". - Paso 4. Imprimir la solución. - Fin del algoritmo . Las constantes se parecen a las variables: tienen un nombre y un tipo, y se les asigna un valor. La única diferencia es que una constante no puede cambiar de valor durante la ejecución del algoritmo y una variable sí. 1.4.3. Subalgoritmos . Cuando un algoritmo es muy complejo, lo dividimos en trozos más simples que denominamos subalgoritmos. En programación, esos subalgoritmos se denominan procedimientos o funciones. Son casi la misma cosa, con una sutil diferencia que ya veremos cuando llegue el momento. Los lenguajes de programación reales, además de las instrucciones básicas que enseguida vamos a ver, tienen unas colecciones de funciones predefinidas llamadas bibliotecas. Esas funciones se encargan de realizar tareas habituales y repetitivas, de modo que nos ahorran un montón de trabajo. Por ejemplo, es posible escribir algoritmos para hacer cálculos matemáticos complejos, tales como logaritmos o raíces cuadradas. Para evitarnos ese trabajo, todos los lenguajes de programación disponen de una biblioteca de funciones matemáticas que incluye, entre otras muchas cosas, el cálculo de logaritmos y de raíces cuadradas para cuando los necesitemos. Así que vamos a suponer, cuando escribamos pseudocódigo, que también tenemos a nuestra disposición de esas bibliotecas de funciones. Algunos subalgoritmos o funciones que existen en todos los lenguajes de programación y que podemos considerar que también existen en pseudocódigo son las siguientes: . | abs(x). Calcula el valor absoluto de x. Funciona con números reales y con enteros. | sen(x). Calcula el seno de x. Devuelve valores reales. | cos(x). Calcula el coseno de x. Devuelve valores reales. | exp(x). Calcula ex. Devuelve un real. | ln(x). Calcula el logaritmo neperiano de x. Devuelve un valor real. | redon(x). Redondea el número x al valor entero más próximo. El valor x será real, y la función devolverá un entero. | trunc(x). Trunca el número x, es decir, le elimina la parte decimal. El valor x será real, y la función devolverá un entero. | rc(x). Calcula la raíz cuadrada de x. Devuelve un valor real | azar(x). Genera un número al azar entre 0 y x. Supondremos que solo funciona con números enteros. | . 1.4.4. Expresiones y operadores . Una expresión es una combinación de constantes, variables, operadores y funciones. Por ejemplo, esto es una expresión: . rc((5 + x) / 2) . En esta expresión, aparecen dos constantes literales (5 y 2), una variable (x), dos operadores aritméticos (+ y /) y una función (rc, para calcular la raíz cuadrada), además de los paréntesis, que sirven para manipular la prioridad de las operaciones. Lógicamente, para resolver la expresión, es decir, para evaluar su resultado, debemos conocer cuál es el valor de la variable x. Si suponemos que la variable x tiene el valor 7, el resultado de la expresión será 2,449. La forma más habitual de encontrar una expresión es combinada con una sentencia de asignación a una variable. Por ejemplo: . y &lt;- raiz((5 + x) / 2) . En estos casos, la expresión (lo que hay a la derecha del signo “&lt;-“) se evalúa y su resultado es asignado a la variable situada a la izquierda del “&lt;-“. En el ejemplo anterior, suponiendo que la variable x valiera 7, la expresión se evaluaría como 2,449, y, por lo tanto, ese es el valor que se asignaría a la variable y. En las expresiones anteriores se han realizado algunas operaciones matemáticas (como sumas o divisiones). Los símbolos que se usan para ello se denominan operadores. En programación, existen distintos tipos de operadores: . | Operadores aritméticos: para hacer operaciones matemáticas convencionales. Los más habituales son + (suma), - (resta), * (producto), / (división) y MOD (resto de la división entera). | Operadores relacionales: se utilizan para comparar números, aunque también pueden comparar caracteres o cadenas alfabéticamente. Los más habituales son &lt; (menor que), &gt; (mayor que), = (igual que), != (distinto de), &lt;= (menor o igual que) y &gt; (mayor o igual que). El resultado de estas comparaciones siempre es un valor lógico, es decir, verdadero o falso. | Operadoresl lógicos: se utilizan para comparar otros datos lógicos y relacionarlos entre sí. Los más habituales son Y, O y NO. Estas palabras tienen el mismo significado que en la lengua natural. | . Observa, por ejemplo, este fragmento de pseudocódigo muy fácil de entender: . puntos_carnet = &lt;poner-aquí-un-número-entero&gt; edad = &lt;poner-aquí-otro-número-entero&gt; Si edad &gt;= 18 y puntos_carnet &gt; 0 Entonces escribir \"Puedes conducir\" FinSi Si edad &lt; 18 o puntos_carnet = 0 Entonces escribir \"No puedes conducir\" FinSi . Aquí se usan dos variables, puntos_carnet y edad (que pueden tomar el valor que quieras ponerle) y luego se hacen dos comparaciones que implican operadores relacionales y lógicos. | En la primera comparación, se tienen que cumplir a la vez las dos condiciones (que la edad sea mayor o igual que 18 años y que los puntos del carnet sean superiores a cero) para que el programa nos diga “Puedes conducir”. | En la segunda comparación, basta con que una de las dos condiciones se cumpla para que el programa diga “No puedes conducir”. | . Es habitual encontrar varias operaciones juntas en una misma línea. En estos casos es imprescindible conocer la prioridad de los operadores, porque las operaciones se calcularán en el orden de prioridad y el resultado puede ser muy distinto del esperado. En general, los operadores aritméticos tienen la máxima prioridad y, entre ellos, la multiplicación y la división son más prioritarias que la suma o la resta. Los siguientes operadores por prioridad son los relacionales y, por último, los lógicos. Sin embargo, esto puede variar según el lenguaje de programación concreto. Lo más apropiado, si tenemos dudas sobre el orden en el que se van a ejecutar las operaciones, es usar paréntesis, exactamente igual que hacemos en matemáticas. 1.4.5. Tipos de instrucciones . Hemos dicho varias veces que los algoritmos constan de dos elementos: un conjunto de datos (representados por constantes y variables) y un conjunto de instrucciones. Son muy pocas, en realidad, las instrucciones que necesitamos para construir algoritmos que funcionen. Increíblemente pocas: . | Instrucciones de entrada de datos. Sirven para indicar que, en ese punto, hay que proporcionar un dato al algoritmo. En el Paso 1 del algoritmo para determinar si un número es par o impar hay una instrucción de entrada. | Instrucciones de salida de datos. Sirven para que el algoritmo nos facilite el resultado de sus cálculos. En el Paso 4 del algoritmo par-impar hay una instrucción de salida. | Instrucciones de asignación. Sirven para asignar un valor a una variable. | Instrucciones para crear subalgoritmos. Sirven para declarar subalgoritmos y darles un nombre. | Instrucciones condicionales. Sirven para bifurcar el posible flujo de ejecución del algoritmo. Las instrucciones condicionales contienen siempre una condición que puede ser verdadera o falsa. Si es verdadera, el algoritmo continúa por un camino. Si es falsa, continúa por otro. Antes o después, esa bifurcación finaliza y el flujo del algoritmo vuelve a reunirse. | Instrucciones iterativas. Sirven para repetir una o varias instrucciones un número finito de veces. Son la estructura más difícil de manejar para los programadores principiantes. | . ",
    "url": "https://iescelia.org//docs/tico/_site/introduccion-a-la-programacion/#14-programas-y-algoritmos",
    "relUrl": "/introduccion-a-la-programacion/#14-programas-y-algoritmos"
  },"11": {
    "doc": "1. Introducción a la programación",
    "title": "1.5. Diagramas de flujo y pseudocódigo",
    "content": "1.5.1. Formas de escribir algoritmos . Necesitamos un método de escritura de algoritmos que sea independiente del lenguaje de programación que luego se vaya a utilizar. Así se podrán traducir más tarde a cualquier lenguaje. Cuatro posibles maneras de escribir un algoritmo son: . | Lenguaje natural (como hicimos con el algoritmo para decidir si un número es o no par). | Diagramas de flujo | Pseudocódigo | Un lenguaje de programación real | . Por supuesto, también podríamos escribir los algoritmos directamente con un lenguaje de programación real, pero, si eres principiante, es más fácil aprender a programar usando pseudocódigo o diagramas de flujo que hacerlo con un lenguaje de programación. No tengas prisa: el lenguaje de programación llegará muy pronto. El lenguaje natural (castellano, en nuestro caso) no es apropiado porque, como todos los lenguajes naturales humanos, tiene muchas ambigüedades que provocarían que, a veces, no quedara claro lo que queremos decir. Los diagramas de flujo son representaciones gráficas de los algoritmos que ayudan a comprender de forma visual su funcionamiento. Tienen el inconveniente de que ocupan mucho espacio, por lo que no son apropiados para programas muy grandes. El pseudocódigo es un lenguaje de codificación de algoritmos basado en la lengua castellana, pero donde solo se permite un conjunto reducido de palabras con un significado muy concreto. El pseudocódigo tiene dos propiedades que nos interesarán mucho: facilita considerablemente el aprendizaje de las técnicas de programación y logra que la traducción a un lenguaje de programación real sea casi instantánea. Los lenguajes de programación reales son más complejos que el pseudocódigo, pero la transición de uno a otro se hace con mucha facilidad. 1.5.2. Un ejemplo real . A continuación, vamos a mostrar el algoritmo que determina si un número es par escrito como un diagrama de flujo, como pseudocódigo y con un lenguaje de programación real (Python). Solo es un ejemplo, pero deberías echarle un vistazo con detenimiento para comprobar si lo entiendes o no. “Con detenimiento” significa que no lo leas deprisa y corriendo para marcharte a hacer otra cosa en dos minutos. Respira hondo y tómate tu tiempo. Si no lo entiendes todo, no te agobies todavía. Aprenderás a escribir pseudocódigo y diagramas de flujo muy pronto. 1. El algoritmo “Par-Impar” escrito en lenguaje natural: . - Inicio del algoritmo - Declaración de variables: - N es un número entero. - solución es una cadena de caracteres. - Paso 1. Averiguar qué número es N. - Paso 2. Si N es divisible entre 2, entonces la solución es \"PAR\". - Paso 3. Si N no es divisible entre 2, entonces la solución es \"IMPAR\". - Paso 4. Imprimir la solución. - Fin del algoritmo . 2. El algoritmo “Par-Impar” escrito como diagrama de flujo: . 3. El algoritmo “Par-Impar” escrito como pseudocódigo: . Algoritmo par_impar Definir N como Entero Definir solucion como Cadena Escribir \"Dime un número:\" Leer N Si N MOD 2 = 0 Entonces solucion &lt;- \"PAR\" SiNo solucion &lt;- \"IMPAR\" FinSi Escribir \"El número \", N, \" es \", solucion FinAlgoritmo . 4. El algoritmo “Par-Impar” escrito con un lenguaje real (Python): . def par_impar(): n = int() solucion = \"\" print(\"Dime un número:\") n = int(input()) if n % 2 == 0: solucion = \"PAR\" else: solucion = \"IMPAR\" print(\"El número {} es {}\".format(n, solucion)) . ",
    "url": "https://iescelia.org//docs/tico/_site/introduccion-a-la-programacion/#15-diagramas-de-flujo-y-pseudoc%C3%B3digo",
    "relUrl": "/introduccion-a-la-programacion/#15-diagramas-de-flujo-y-pseudocódigo"
  },"12": {
    "doc": "1. Introducción a la programación",
    "title": "1.6. Los lenguajes de programación",
    "content": "Acabas de ver un ejemplo de código escrito en un lenguaje de programación real (Python, en ese caso). Pero literalmente hay cientos de lenguajes de programación: constituyen un ecosistema muy extenso y en constante evolución. Para orientarse un poco en esa jungla, nada mejor que clasificar los lenguajes igual que los biólogos clasifican a las criaturas vivas. 1.6.1. Tipos de lenguaje según el nivel de abstracción: alto y bajo nivel . Hay lenguajes de programación muy próximos al lenguaje binario: a éstos los llamamos lenguajes de bajo nivel de abstracción. Y los hay más próximos al lenguaje natural: son los lenguajes de alto nivel de abstracción. Lenguajes de bajo nivel . Son los lenguajes más cercanos a la máquina. Los programas directamente escritos en código binario se dice que están en lenguaje máquina que, por lo tanto, es el lenguaje de más bajo nivel que existe. Las instrucciones del lenguaje máquina realizan tareas muy sencillas, como, por ejemplo, sumar dos números, detectar qué tecla se ha pulsado en el teclado o escribir algo en la pantalla del ordenador. Cuando se combinan adecuadamente muchas de estas instrucciones sencillas se obtiene un programa de ordenador que puede realizar tareas muy complejas. Por ejemplo, este puede ser el aspecto de una instrucción en lenguaje máquina para sumar dos números: . 0001 000100000101 110100110101 . Incomprensible, ¿verdad? . A pesar de la simplicidad de las instrucciones del lenguaje máquina, la forma de escribirlas es muy complicada, ya que hay que hacerlo en binario. En los primeros años de la informática los ordenadores se programaban directamente en lenguaje máquina, lo cual convertía la tarea de programar en una verdadera pesadilla. Hoy en día nadie lo hace. Cuando los ordenadores fueron haciéndose más potentes, surgió la idea de utilizar el propio ordenador como traductor: ¿por qué no escribir instrucciones en un lenguaje más parecido al natural y que un programa de ordenador se encargue de traducir esa instrucción a su correspondiente instrucción en lenguaje máquina? . Así apareció el lenguaje ensamblador, cuyas instrucciones son equivalentes a las del lenguaje máquina, pero se escriben con palabras similares a las del lenguaje humano. Por ejemplo, para sumar dos números, la instrucción en ensamblador puede tener un aspecto como este: . ADD D1 D2 . Lenguajes de alto nivel . Siguiendo el razonamiento anterior (utilizar el propio ordenador como traductor), en la década de 1960 y, sobre todo, de 1970, se empezaron a desarrollar lenguajes cada vez más complejos, en los que cada instrucción ya no se correspondía exactamente con una instrucción del lenguaje máquina, sino con varias. Estos son los lenguajes de alto nivel. Lógicamente, la traducción desde un lenguaje de alto nivel a lenguaje máquina es mucho más compleja que desde lenguaje ensamblador, por lo que los traductores se han hecho cada vez más complicados. Una característica muy importante de los lenguajes de alto nivel es que son independientes del hardware, lo que implica que los programas desarrollados con estos lenguajes pueden ser ejecutados en ordenadores con hardware totalmente distinto. A esto se le llama portabilidad. Los programas encargados de traducir el código de alto nivel a código máquina se llaman compiladores e intérpretes. Son programas muy complejos que generan el código binario equivalente al código de alto nivel para una máquina concreta. Por lo tanto, el programa de alto nivel, que es portable de un hardware a otro, debe ser traducido a código máquina en cada tipo de máquina en la que se pretenda ejecutar. Los ejemplos de lenguajes de alto nivel son innumerables, y la lista incluye casi todos de los que has oído hablar alguna vez: Basic, Cobol, Fortran, Ada, C/C++, PHP, Python, Java, Perl, Ruby, Javascript, etc. Ventajas e inconvenientes de los lenguajes de alto y bajo nivel . | LENGUAJES DE BAJO NIVEL | LENGUAJES DE ALTO NIVEL | . | Ventajas | Inconvenientes | . | Son comprensibles directamente por la máquina (aunque el ensamblador necesita una pequeña traducción) | Necesitan ser traducidos por medio de complicados programas (compiladores e intérpretes) | . | Los programas se ejecutan muy rápidamente (si están bien escritos, claro) | La traducción automática del código de alto nivel al código máquina siempre genera programas menos eficientes que si se escribieran directamente en binario | . | Ocupan menos espacio en memoria | Ocupan más espacio en memoria | . | Permiten controlar directamente el hardware, por lo que son apropiados para la programación de sistemas | En general, solo pueden acceder al hardware utilizando al sistema operativo como intermediario. Pero, entonces, ¿cómo programar el sistema operativo, que necesita controlar directamente el hardware? | . | Inconvenientes | Ventajas | . | Son completamente dependientes del hardware. Un programa escrito para determinado tipo de máquina no funcionará en un ordenador con diferente arquitectura. | Son portables, es decir, independientes del hardware. Un programa escrito en una máquina puede funcionar en otra con hardware distinto, siempre que se vuelva a traducir a binario en la máquina nueva. | . | Incluso los programas más sencillos son largos y farragosos | Los programas son más sencillos, ya que una sola instrucción puede equivaler a varias instrucciones binarias. | . | Los programas son difíciles de escribir, depurar y mantener | Los programas son más fáciles de escribir, depurar y mantener | . | Es imposible resolver problemas muy complejos | Es posible, aunque difícil, enfrentarse a problemas muy complejos | . Si echas un vistazo a la tabla anterior comprenderás que, en general, es preferible usar lenguajes de alto nivel la gran mayoría de las veces, reservando los de bajo nivel para casos muy concretos, como el desarrollo de ciertas partes de los sistemas operativos. También hay que destacar que no todos los lenguajes de alto nivel son iguales. Los hay de más alto nivel que otros. El lenguaje C, por ejemplo, tiene menor nivel de abstracción que, por ejemplo, Java. Esto hace que los programas escritos en C sean más rápidos y eficientes que los escritos en Java, aunque también pueden llegar a ser más difíciles de escribir y depurar. 1.6.2. Tipos de lenguaje según su generación . Los lenguajes de programación también se clasifican según la generación a la que pertenecen. El lenguaje máquina fue el lenguaje de primera generación. Los ensambladores fueron los lenguajes de segunda generación. A partir de ahí, surgió una explosión de lenguajes diferentes que podemos clasificar como: . | Lenguajes de tercera generación (o imperativos), en los que el programador escribe una secuencia de instrucciones que el ordenador debe ejecutar en un orden preestablecido. Son los lenguajes más “clásicos”: C, Basic, Cobol, Fortran, Pascal, etc. | Lenguajes de cuarta generación (o 4GL), dirigidos a facilitar la creación de interfaces con el usuario y con otras aplicaciones, como las bases de datos. Un ejemplo de estos lenguajes es SQL, universalmente utilizado para manipular bases de datos y omnipresente en muchas aplicaciones web actuales. | Lenguajes orientados a objetos, que son una evolucuión de los lenguajes de tercera generación y que permiten construir con mayor facilidad y robustez programas modulares complejos. Ejemplos de lenguajes orientados a objetos son C++, C#, Java, Javascript, Python, PHP o Ruby. Algunos de ellos son multiparadigma, es decir, permiten programar con orientación a objetos pero también permiten hacer programación estructurada clásica, sin objetos. | Lenguajes declarativos y lenguajes funcionales, propios de la inteligencia artificial, como Prolog o Lisp. | Lenguajes de bloques. Están pensados para el aprendizaje del pensamiento computacional desde muy corta edad, pero son cada vez más potentes. El más conocido es Scratch. | Otros tipos aún más específicos: lenguajes concurrentes, paralelos, distribuidos, etc. | . En general, podemos decir que un programador acostumbrado a trabajar con un lenguaje de tercera generación puede aprender con poco esfuerzo cualquier otro lenguaje de tercera generación y, con algo más de trabajo, un lenguaje orientado a objetos. Sin embargo, el “salto” a otros tipos de lenguajes, como los declarativos, cuesta más porque las fundamentos de estos lenguajes son muy diferentes. 1.6.3. Tipos de lenguaje según su forma de traducción . Cuando programamos en un lenguaje distinto del lenguaje máquina, nuestro código debe ser traducido a binario para que el ordenador pueda entenderlo y ejecutarlo. Existe un programa específico encargado de hacer esa traducción y que, dependiendo del lenguaje en el que hayamos escrito nuestro programa, puede ser un ensamblador, un compilador o un intérprete. Ensambladores . Se llaman ensambladores los programas encargados de traducir los programas escritos en ensamblador a código binario. Sí, ya lo sé: se usa el mismo nombre para referirse al lenguaje de programación y al traductor de ese lenguaje a código máquina. Es un lío. Como el lenguaje ensamblador es muy próximo al binario, estos traductores son programas relativamente sencillos. Compiladores . El compilador es un programa que traduce el código de alto nivel a código binario. Es, por tanto, parecido al ensamblador, pero mucho más complejo, ya que las diferencias entre los lenguajes de alto nivel y el código binario son muy grandes. El programa escrito en lenguaje de alto nivel se denomina programa fuente o código fuente. El programa traducido a código binario se llama programa objeto o código objeto. Por lo tanto, el compilador se encarga de convertir el programa fuente en un programa objeto. Una vez que se ha obtenido el código objeto ya no es necesario volver a realizar la traducción (o compilación), a menos que se haga alguna modificación en el programa fuente, en cuyo caso habría que volver a compilarlo. El código objeto, una vez generado, puede ejecutarse en la máquina en la que fue compilado, o en otra de similares características (procesador, sistema operativo, etc.). Cuando se usa programación modular, puede ser necesario un proceso previo de enlace de los diferentes módulos antes de poder construir el programa ejecutable. Intérpretes . El intérprete es un programa que traduce el código de alto nivel a código binario pero, a diferencia del compilador, lo hace en tiempo de ejecución. Es decir, no existe un proceso previo de traducción de todo el código fuente a código binario, sino que se va traduciendo y ejecutando instrucción por instrucción. Compiladores frente a intérpretes . El intérprete es notablemente más lento que el compilador, ya que realiza la traducción al mismo tiempo que la ejecución. Además, esa traducción se lleva a cabo siempre que se ejecuta el programa, mientras que el compilador sólo la hace una vez. Hay un evidente malgasto de recursos. Sin embargo, los intérpretes tienen una gran ventaja sobre los compiladores, y es que logran que los programas sean más portables, es decir, que puedan ejecutarse en diferentes máquinas con diferentes sistemas operativos sin apenas cambios. Así, un programa compilado en una máquina PC bajo Windows no funcionará en un Mac o en un PC bajo Linux, a menos que se vuelva a compilar el programa fuente en el nuevo sistema. En cambio, un programa interpretado funcionará en todas las plataformas, siempre que dispongamos del intérprete en cada una de ellas. C/C++ es un ejemplo de lenguaje compilado. Python es un ejemplo de lenguaje interpretado. Eso significa que un programa escrito, por ejemplo, con Python, puede funcionar en cualquier máquina que disponga de un intérperte Python, que, hoy en día, es casi cualquiera. Por eso, cualquier programa escrito en Python puede ejecutarse prácticamente en cualquier ordenador del mundo sin tocarle ni una coma. En cambio, los programas desarrollados con C/C++ se ejecutan más rápido (¡muuucho más rápido!) que sus equivalentes en Python. Sin embargo, tendrás que volver a compilarlos si deseas ejecutarlos en una máquina con diferente hardware o diferente sistema operativo. 1.6.4. Tipos de lenguaje según su tipado . Por tipado nos referimos a la forma en la que los lenguajes de programación usan los tipos de datos. Ya sabes: entero, carácter, lógico, etc. Es decir, las categorías a las que puede pertenecer una variable. Pues bien, según su tipado, los lenguajes pueden ser: . | De tipado fuerte: los tipos de datos no pueden mezclarse. Por ejemplo, no puedes sumar un entero y un real, porque son números de distinto tipo. Y mucho menos sumar un entero con un carácter. | De tipado débil: los tipos de datos pueden mezclarse y el lenguaje hace las conversiones de tipos implícitas que le parezca oportunas. Así, en estos lenguajes podrías sumar un entero con un real, o incluso un entero con un carácter. ¿Que cuál sería el resultado? Buena pregunta. Tendrás que probarlo, porque eso depende de las conversiones de tipo que haga el lenguaje. | De tipado estático: los tipos de datos se asignan al escribir el código y no pueden cambiarse durante la ejecución. Esto es típico de los compiladores (aunque no de todos). | De tipado dinámico: los tipos de datos pueden cambiarse alegremente durante la ejecución. Esto es típico de los intérpretes. | . Las dos primeras categorías y las dos segundas no son excluyentes. Por ejemplo, pueden existir lenguajes de tipado débil y dinámico, o bien fuerte y estático. Las otras combinaciones (fuerte y dinámico, débil y estático) pueden darse pero son menos habituales. 1.6.5. El top ten de los lenguajes de programación . Es difícil saber cuales son los lenguajes más populares en un determinado momento porque no existen estadísticas fiables a nivel mundial. Además, las cosas pueden cambiar mucho de un territorio a otro. Sin embargo, ciertos sitios de internet, como GitHub, almacenan enormes cantidades de proyectos de software. GitHub, de hecho, es el mayor almacén de código fuente conocido, de modo que sus estadísticas nos pueden dar una idea bastante exacta de cuál es el grado de uso de cada lenguaje. Según Madnight, un proyecto que recopila y publica estadísticas de uso de lenguajes en GitHub, el top ten de lenguajes de programación más usados en GitHub es: . | Puesto | Lenguaje | Porcentaje de uso | Variación de uso en 12 meses | . | 1 | JavaScript | 17.955% | -2.192% | . | 2 | Python | 15.943% | +0.071% | . | 3 | Java | 12.977% | +1.573% | . | 4 | Go | 8.203% | -0.612% | . | 5 | TypeScript | 7.212% | -0.276% | . | 6 | C++ | 6.683% | -0.251% | . | 7 | Ruby | 6.488% | +0.303% | . | 8 | PHP | 4.937% | -0.093% | . | 9 | C# | 3.366% | -0.350% | . | 10 | C | 2.958% | +0.068% | . El porcentaje de uso indica la proporción de proyectos en GitHub que usan ese lenguaje de programación sobre el total de proyectos. La última cifra señala la variación interanual del porcentaje de uso. Estos datos son de tercer cuatrimestre de 2021. Para obtener datos de otras fechas, puedes visitar la web https://madnight.github.io/ . Ten en cuenta de nuevo que esto no son cifras de uso absoluto de los lenguajes a nivel mundial. Solo se trata de una pista de cuál es la situación. De hecho, si consultas otras estadísticas como el TIOBE index, encontrarás datos diferentes. Según estas cifras, el conjunto de proyectos que usan lenguaje C o cualquiera de sus variantes (C++ o C#) es muy significativo, sobre todo teniendo en cuenta que C es un lenguaje de la década de 1970, lo cual constituye una eternidad en informática. Que un lenguaje mantenga su vigencia durante tanto tiempo indica lo robusto y confiable que es. Seguramente seguirá con nosotros dentro de muchos años, cuando otros competidores de esta lista ya hayan caído en el olvido. ",
    "url": "https://iescelia.org//docs/tico/_site/introduccion-a-la-programacion/#16-los-lenguajes-de-programaci%C3%B3n",
    "relUrl": "/introduccion-a-la-programacion/#16-los-lenguajes-de-programación"
  },"13": {
    "doc": "1. Introducción a la programación",
    "title": "1.7. Ejercicios propuestos",
    "content": "Ejercicios de codificación de la información y unidades de medida . Ejercicio 1. Investiga y responde a las siguientes cuestiones: . a) ¿Por qué los ordenadores digitales sólo utilizan ceros y unos, es decir, códigos binarios, en lugar de manejar internamente códigos decimales, como hacemos los humanos? . b) ¿Por qué los humanos estamos habituados a un sistema de numeración basado en 10 símbolos y no a cualquier otro, por ejemplo, uno con 8 símbolos, o con 5, o con 12? . Ejercicio 2. Tenemos un viejo ordenador con una capacidad de almacenamiento en la memoria principal de 2 GB. Suponiendo que un nombre ocupe 30 caracteres y un apellido ocupe 25, ¿cuántos nombres y apellidos puede almacenar este ordenador? . Ejercicio 3. Convierte las siguientes cantidades de información: . a) 30 GB a MB . b) 128 KB a bits . c) 2 MB a bits . d) 64512 KiB a MiB . Ejercicio 4. Convierte los siguientes números al sistema de numeración indicado: . a) 1001012 a decimal . b) 25410 a binario . c) 11111112 a decimal . d) 19110 a binario . Ejercicio 5. Convierte los siguientes números entre los sistemas hexadecimal y binario, utilizando la tabla de conversión que hemos visto en este tema. Si puedes hacerlo sin mirar la tabla, mucho mejor. a) 100111012 a hexadecimal . b) 1101001110110011012 a hexadecimal . c) 38C16 a binario . d) FDCA16 a binario . Ejercicio 6. Escribe las palabras “CELIA VIÑAS” en código ASCII (en decimal y en hexadecimal). Ejercicio 7. La cantidad de memoria RAM de un ordenador personal medio ha ido creciendo imparablemente desde que los ordenadores personales se popularizaron en los años 80. Estas son algunas de esas cantidades: . | Año 1982: 256 KiB | Año 1992: 4 MiB | Año 2002: 512 MiB | Año 2012: 4 GiB | Año 2022: 8 GiB | . Dibuja en un gráfico la evolución de estas cantidades y haz una proyección aproximada hasta el año 2032. ¿Cuánta memoria RAM usarán los ordenadores dentro de 10 años? Puedes usar un programa de hoja de cálculo para ayudarte. Ejercicio 8. El tamaño de los discos duros promedios de los ordenadores también ha ido creciendo desde hace cuarenta años. Haz una proyección parecida a la anterior para averiguar qué capacidad de almacenamiento en disco tendrán los ordenadores personales, previsiblemente, dentro de 10 años. | Año 1982: 10 MiB (los pocos ordenadores que tenían disco duro) | Año 1992: 1 GiB | Año 2002: 40 GiB | Año 2012: 240 GiB | Año 2022: 2 TiB | . Ejercicios sobre algoritmos y lenguajes de programación . Ejercicio 9. Si x = 5, y = 3 y z = 0, ¿cuál será el valor de las siguientes expresiones? . a) x * y + z . b) x + y * z . c) (x + y) / z . d) raiz(y * x + 10) . e) (x + y) * (z + 2) . f) x + y * z + 2 . Ejercicio 10. Examina este diagrama de flujo y trata de explicar con palabras qué crees que hace este programa. Ejercicio 11. Examina este diagrama de flujo y trata de explicar con palabras qué crees que hace este programa. Ejercicio 12. Examina este diagrama de flujo y trata de explicar con palabras qué crees que hace este programa. Ejercicio 13. Busca, en al menos dos sitios web diferentes, información sobre cuáles son los lenguajes de programación que más se utilizan en la actualidad. ¡Asegúrate de que sean inforamación actualizada! . Luego haz una lista con los 10 lenguajes más utilizados según cada web. ¿Las listas coinciden entre ellas? ¿Y difieren mucho de los que hemos mencionado en el tema? . ",
    "url": "https://iescelia.org//docs/tico/_site/introduccion-a-la-programacion/#17-ejercicios-propuestos",
    "relUrl": "/introduccion-a-la-programacion/#17-ejercicios-propuestos"
  },"14": {
    "doc": "2. Programación con diagramas de flujo",
    "title": "2. Programación con diagramas de flujo",
    "content": ". | 2.1. Simbología de los diagramas de flujo | 2.2. Normas de escritura de diagramas de flujo | 2.3. Programando con PseInt . | 2.3.1. Instalación de PseInt | 2.3.2. Dibujar y ejecutar diagramas de flujo con PseInt | . | 2.4. Ejercicios propuestos | . El diagrama de flujo es una de las herramientas más poderosas para describir algoritmos. El diagrama de flujo permite escribir gráficamente un algoritmo, de manera que podemos comprobar de un golpe de vista si hemos cubierto todos los caminos que ese algoritmo puede tomar. Es una forma intuitiva y muy sencilla de escribir programas. Una vez creado el diagrama de flujo, es sencillísimo transformarlo algoritmo a cualquier lenguaje de programación. Los diagramas de flujo son herramientas descriptivas tan potentes que se utilizan con asiduidad en la vida diaria para entender mejor la lógica de un problema o su solución. Por ejemplo, en este diagrama de flujo se propone gráficamente un proceso de toma de decisiones para determinar si se realiza o no una intervención quirúrjica a un paciente en el contexto de la pandemia del COVID-19 (fuente: Patient Safety in Surgery Journal): . ",
    "url": "https://iescelia.org//docs/tico/_site/diagramas-de-flujo/",
    "relUrl": "/diagramas-de-flujo/"
  },"15": {
    "doc": "2. Programación con diagramas de flujo",
    "title": "2.1. Simbología de los diagramas de flujo",
    "content": "En los diagramas de flujo, cada símbolo representa una operación específica. Las operaciones se conectan entre ellas con flechas, que indican el orden de ejecución. Los símbolos de los diagramas de flujo orientados a programación están estandarizados, aunque puedes encontrar pequeñas diferencias según qué fuente consultes. Nosotros vamos a usar los de PSeInt, igual que haremos con el pseudocódigo, para luego no tener problemas cuando usemos esa herramienta para resolver nuestros ejercicios prácticos. Los símbolos más importantes (pero no todos) de un diagrama de flujo, junto con su equivalencia en pseudocódigo, son estos: . | Símbolo | Equivalencia en pseudocódigo | Significado | . | | Algoritmo nombre | Marca el comienzo de un algoritmo y le adjudica un nombre | . | | FinAlgoritmo | Marca el final del algoritmo | . | | Definir variable Como tipo | Declara una variable y le asigna un tipo. | . | | Leer variable | Entrada de datos. | . | | Escribir expresión | Salida de datos. | . | | variable = expresionvariable &lt;- expresion | Asignación. | . | | Si condición Entonces &nbsp;&nbsp;&nbsp;&nbsp;acciones-1 SiNo &nbsp;&nbsp;&nbsp;&nbsp;acciones-2 FinSi | Estructura condicional. | . | | Mientras Condición &nbsp;&nbsp;&nbsp;&nbsp;acciones FinMientras | Bucle con condición al princio. | . | | Repetir &nbsp;&nbsp;&nbsp;&nbsp;acciones Hasta Que Condición | Bucle con condición al final. | . | | Para variable &lt;- valor_inicial Hasta valor_final Hacer &nbsp;&nbsp;&nbsp;&nbsp;acciones FinPara | Bucle con iterador. | . Recuerda que también existen símbolos para definir y utilizar subalgoritmos, destinados a dividir el algoritmo en trozos cuando resolvemos problemas complejos. Por ahora, nuestros problemas serán simples y no usaremos subalgoritmos. Cuando llegue el momento, explicaremos cómo se utilizan. Para terminar, te muestro el algoritmo para contar números enteros entre dos números cualesquiera, A y B, escrito como un diagrama de flujo. No dejes de comparar esta solución con la que planteamos en pseudocódigo un poco más arriba. Ambas son exactamente iguales, pero están descritas con una herramienta diferente. Es como si hubiéramos escrito la misma frase en dos idiomas distintos. ",
    "url": "https://iescelia.org//docs/tico/_site/diagramas-de-flujo/#21-simbolog%C3%ADa-de-los-diagramas-de-flujo",
    "relUrl": "/diagramas-de-flujo/#21-simbología-de-los-diagramas-de-flujo"
  },"16": {
    "doc": "2. Programación con diagramas de flujo",
    "title": "2.2. Normas de escritura de diagramas de flujo",
    "content": "Los diagramas de flujo son herramientas intuitivas de leer y utilizar, pero, no obstante, conviene tener presentes algunas relgas básicas a la hora de hacerlo: . | Los diagramas de flujo se escriben (y se leen) de arriba a abajo y de izquierda a derecha. | Los símbolos deben unirse entre sí por flechas (líneas de flujo) que indican el orden de ejecución. | Los símbolos deben llevar en el interior información que indiquen su función exacta. | Cada símbolo debe tener un único flujo de entrada y un único flujo de salida, excepto el rombo, que tiene dos flujos de salida (verdadero y falso). | Es conveniente no cruzar las líneas de flujo. | . ",
    "url": "https://iescelia.org//docs/tico/_site/diagramas-de-flujo/#22-normas-de-escritura-de-diagramas-de-flujo",
    "relUrl": "/diagramas-de-flujo/#22-normas-de-escritura-de-diagramas-de-flujo"
  },"17": {
    "doc": "2. Programación con diagramas de flujo",
    "title": "2.3. Programando con PseInt",
    "content": "PSeInt es una herramienta para el aprendizaje de la programación de gran éxito en el mundo hispano (ha sido desarrollada en Argentina). Permite escribir programas en varios dialectos de pseudocódigo y convertirlos a diagrama de flujo, o bien dibujar el diagrama de flujo y obtener de forma automática el pseudocódigo correspondiente. Además, lo más alucinante es que, con PseInt, puedes ejecutar tu programa como si de un lenguaje de programación real se tratase. PseInt es software libre y gratuito, y soporta múltiples plataformas (Windows, Linux y Mac), así que es perfecta para practicar con diagramas de flujo y pseudocódigo y ver tus programas en funcionamiento en el ordenador. 2.3.1. Instalación de PseInt . Si tu sistema operativo es Educandos/Guadalinex: . Si estás usando un sistema operativo Educandos o Guadalinex de la Junta de Andalucía, lo más conveniente es instalar PseInt desde el repositorio oficial. Solo tienes que seguir estos pasos: . | Haz clic en el botón “eos” (ver imagen más abajo). | Busca “Centro de software”. | Busca “PseInt”. | Haz clic en “Instalar”. | . Ya tienes PseInt instalado en tu sistema. Puedes lanzar el programa desde el propio Centro de software (haciendo clic en “Lanzar”) o bien desde el buscador de aplicaciones (botón “eos”). Si tu sistema operativo es otro: . Para cualquier otro sistema operativo (Windows, Linux o Mac) distinto de Educandos/Guadalinex, tendrás que descargar PseInt de la web del desarrollador e instalarlo manualmente siguiendo las instrucciones. Es posible que, dependiendo del sistema operativo, necesites permisos de administrador para hacerlo. | Para descargar PSeInt: http://pseint.sourceforge.net/ | Para leer el manual de usuario: http://pseint.sourceforge.net/index.php?page=documentacion.php | . ¡OJO! Primera ejecución de PseInt . En la primera ejecución del PseInt, el programa te hará algunas preguntas para configurar tus preferencias. Es importante que respondas adecuadamente a estas preguntas. Si te equivocas, se puede reconfigurar más tarde, pero resulta más complicado. | Cuando te pregunte si quieres crear un icono en el escritorio o una entrada en el menú de aplicaciones, elige como mínimo “Crear icono en el escritorio”. Así podrás iniciar PseInt con rapidez la próxima vez que lo necesites. | Cuando te pregunte por tu perfil, elige “Opción 3: no seleccionar perfil”. Los perfiles se refieren al dialecto de pseudocódigo que PseInt entenderá. De momento, te interesa usar la Opción 3, que es la más flexible y con menos complicaciones. | . 2.3.2. Dibujar y ejecutar diagramas de flujo con PseInt . 1) Haz clic en el botón “Dibujar diagrama de flujo”. 2) Arrastra los símbolos y colócalos en el lugar correcto del diagrama. 3) Haz doble clic para escribir dentro de cada símbolo. 4) Haz clic en el botón “Ejecutar” para probar tu programa. ",
    "url": "https://iescelia.org//docs/tico/_site/diagramas-de-flujo/#23-programando-con-pseint",
    "relUrl": "/diagramas-de-flujo/#23-programando-con-pseint"
  },"18": {
    "doc": "2. Programación con diagramas de flujo",
    "title": "2.4. Ejercicios propuestos",
    "content": "A partir de este punto, necesitarás instalar PSeInt en tu ordenador. En todos los ejercicios que vienen a continuación se te pide escribir un programa que resuelva un determinado problema. Puedes escribirlo en pseudocódigo o con un diagrama de flujo, como prefieras, ya que, con PSeInt, ambas herramientas son intercambiables. No dejes de comprobar que tu solución funciona antes de pasar al siguiente. No es necesario que hagas todos los ejercicios. Están ordenados en un grado de dificultad creciente, de modo que, si los primeros te resultan muy sencillos, puedes saltar a otro un poco más complicado. Céntrate solo en los que te parezcan más interesantes, o incluso puedes inventarte tus propios programas. En realidad, esto último es lo más adecuado. Recuerda que para aprender a programar necesitarás practicar, practicar y practicar. Y para lograr practicar tanto, es imprescindible que te guste lo que estás haciendo. Ejercicio 0. Instala PseInt en tu ordenador siguiendo las instrucciones que hemos dado antes. Comprueba que el programa arranca con normalidad y sin errores. No olvides configurar adecuadamente PseInt durante la primera ejecución. Si te equivocas, se puede reconfigurar más tarde, pero es más engorroso. Si el programa ya está instalado en tu ordenador, puedes pasar al siguiente ejercicio. Ejercicios con estructura secuencial . Ejercicio 1. Calcular el área y la circunferencia de un círculo cuyo radio será proporcionado a través del teclado. Recuerda que área = 3.14 x r x r y circunferencia = 2 x 3.14 x r Ejercicio 2. Pedir las cuatro notas de los exámenes del primer trimestre de un alumno y mostrar la nota media obtenida. Ejercicio 3. Calcular el precio de llenar una piscina de agua. Para ello se tienen que pedir al usuario las medidas de la piscina (largo, ancho y alto) y el precio del m​3​ del agua. Se mostrará el precio total. Supondremos que la piscina es de forma regular. Ejercicios con estructuras condicionales . Ejercicio 4. Determinar si un número leído del teclado es positivo, negativo o cero. Ejercicio 5. Calcular la raíz cuadrada de un número introducido por teclado. Hay que tener la precaución de comprobar que el número sea positivo. Ejercicio 6. Leídos dos números por teclado, A y B, calcular la resta del mayor menos el menor. Por ejemplo, si A = 8 y B = 3, el resultado debe ser A – B, es decir, 5. Pero si A = 4 y B = 7, el resultado debe ser B – A, es decir, 3. Ejercicio 7. Averiguar si un número real introducido por teclado tiene o no parte fraccionaria (utilícese la función trunc() que aparece descrita en los apuntes) . Ejercicio 8. Leer un número real y un tipo de moneda, que puede ser \"euro\" o \"peseta\". Convertir la cantidad al tipo de moneda indicado, suponiendo que está expresada en la otra. Por ejemplo, si la cantidad es 15 y la moneda es \"peseta\", se supondrá que se trata de 15 € y que hay que convertirlos a pesetas y, por lo tanto, el resultado debe ser 2495. Ejercicio 9. Leer tres números por teclado, X, Y y Z, y decidir si están ordenados de menor a mayor. Ejercicio 10. Como el anterior, pero para averiguar si los números son consecutivos. Ejercicio 11. Determinar si un año es bisiesto o no (los años bisiestos son múltiplos de 4; utilícese el operador módulo) . Ejercicio 12. Determinar el número de cifras de un número entero. El algoritmo debe funcionar para números de hasta 5 cifras, considerando los negativos. Por ejemplo, si se introduce el número 5342, la respuesta del programa debe ser 4. Si se introduce –250, la respuesta debe ser 3. Ejercicio 13. Calcular las dos soluciones de una ecuación de segundo grado, del tipo ax2 + bx + c = 0. Los coeficientes a, b y c deberá introducirlos el usuario a través del teclado. Ejercicios con estructuras condicionales e iterativas . Ejercicio 14. Escribir todos los números entre 1 y n, siendo n un entero introducido por teclado. Ejercicio 15. Escribir todos los números pares entre 1 y n. Ejercicio 16. Escribir todos los números impares entre dos números a y b introducidos por teclado. Antes habrá que comprobar cuál de los dos números (a o b) es mayor. Ejercicio 17. Calcular la suma de todos los números pares entre 1 y n, siendo n un entero introducido por teclado. Es decir, hay que calcular 2 + 4 + 6 + … hasta n (o n-1, si n es un número impar). Ejercicio 18. Realiza un programa que calcule la suma de los n primeros números, donde n es un número introducido por teclado. Al terminar, el programa nos mostrará el mensaje \"¿Desea terminar? (S/N)\". Si el usuario escribe \"S\", el programa terminará, pero, si escribe \"N\", volverá a comenzar. Ejercicio 19. Calcular la nota media de un alumno a partir de las notas de todos sus exámenes a lo largo del curso. El programa nos irá pidiendo notas, pero no sabemos cuántas son. Para terminar de introducir valores, el usuario debe teclear un número negativo. Entonces, el programa calculará el promedio de todas las notas introducidas. Ejercicio 20. El usuario de este programa será un profesor, que introducirá las notas de sus 30 alumnos de una en una. El algoritmo debe decirle cuántos suspensos y cuántos aprobados hay. Ejercicio 21. Calcular el valor máximo de una serie de 10 números introducidos por teclado. Ejercicio 22. Generalizar el ejercicio anterior para que también se averigüe el valor mínimo y el medio. Ejercicio 23. Calcular el factorial de un número entero N. Recuerda que el factorial de un número es el producto de ese número por todos los enteros menores que él. Por ejemplo, el factorial de 5 (simbolizado 5!) se calcula como: 5! = 5 x 4 x 3 x 2 x 1. Ejercicio 24. Generar combinaciones al azar para la lotería primitiva (6 números entre 1 y 49). Debes utilizar la función azar(x) que vimos en los apuntes. Por ahora, no te preocupes porque los números puedan repetirse. Ejercicio 25. Generar combinaciones al azar para la quiniela (14 valores dentro del conjunto 1, X o 2). Ejercicios más avanzados . Ejercicio 26. Determinar si un número N introducido por teclado es o no primo. Recuerda que un número primo es aquél que sólo es divisible por sí mismo y por la unidad. Ejercicio 27. Generalizar el algoritmo anterior para averiguar todos los números primos que existen entre 2 y N, siendo N un número introducido por teclado. Ejercicio 28. Introducida una hora por teclado (horas, minutos y segundos), se pretende sumar un segundo a ese tiempo e imprimir en la pantalla la hora que resulta (también en forma de horas, minutos y segundos). Ejercicio 29. La calculadora. Diseñar un algoritmo que lea dos números, A y B, y un operador (mediante una variable de tipo carácter), y calcule el resultado de operar A y B con esa operación. Por ejemplo, si A = 5 y B = 2, y operación = “+”, el resultado debe ser 7. El algoritmo debe seguir pidiendo números y operaciones indefinidamente, hasta que el usuario decida terminar (utilizar un valor centinela para ello) . Algunos juegos sencillos . Ejercicio 30. Juego del número secreto. El ordenador elegirá un número al azar entre 1 y 100. El usuario irá introduciendo números por teclado, y el ordenador le irá dando pistas: “mi número es mayor” o “mi número es menor”, hasta que el usuario acierte. Entonces el ordenador le felicitará y le comunicará el número de intentos que necesitó para acertar el número secreto**. Ejercicio 31. Número de la suerte . El número de la suerte o lucky number es una tontuna que se han inventado los numerólogos y que se obtiene sumando todas las cifras de la fecha de nacimiento de un modo azaroso. Por ejemplo, como yo nací el 15 de octubre de 1974 (15-10-1974), se supone que mi número de la suerte es 15+10+1974 = 1999. Ahora sumo todas las cifras de 1999 así: 1+9+9+9 = 28. Como aún tengo dos dígitos, vuelvo a sumarlos. 2 + 8 = 10. Y, por último, 1 + 0 = 1. Por lo tanto, 1 es mi número de la suerte. Si alguna vez me toca la lotería y llevo un número acabado en 1, os aviso. Por ahora, nos conformamos con escribir un programa que, dada una fecha de nacimiento (día, mes y año), calcule el número de la suerte de esa persona. Ejercicio 32. El juego de la ruleta . Escribe un programa que permita jugar a la ruleta con el ordenador. Supondremos que la ruleta tiene 20 números rojos y 20 negros. El jugador, que tendrá una suma de dinero inicial, apostará una cantidad (siempre menor que el dinero que le quede) a un número y un color. La ruleta, que puedes simular con el método azar(), la manejará el ordenador y comunicará al jugador el resultado. Si el jugador acierta, multiplicará por 10 el dinero apostado. Si falla, perderá el dinero apostado. El proceso se repetirá hasta que el jugador decida abandonar el juego, o bien se quede sin dinero. Por favor, abstenerse ludópatas. Ejercicio 33. Juego de dados . Escribe un programa para jugar a los dados con el ordenador. Las reglas del juego son las siguientes: . | El jugador humano dispondrá de una cantidad inicial de dinero que se introducirá por teclado. | El jugador apostará una cantidad de dinero (siempre igual o menor del que le queda) | Después, se tirarán tres dados (lo cual se puede simular con el método azar()) | Si en los tres dados sale la misma cantidad, el dinero apostado por el jugador: . | Se multiplica por 5 si en los dados ha salido un 6 | Se multiplica por 3 si sale cualquier otra cantidad | . | Si en dos dados de los tres sale la misma cantidad, el dinero apostado se multiplica por 2 | En cualquier otro caso, el dinero apostado se pierde | El proceso se repite hasta que el jugador se queda sin dinero o hasta que decide dejar de jugar. | . Ejercicio 34. Juego de las Tres en Raya . Vamos a hacer una versión del popular juego de las Tres en Raya para jugar contra el ordenador. No será un juego con inteligencia artificial como el de la WOPR (si no sabes qué es la WOPR, bueno, ¿para qué sirve wikipedia?), pero te permitirá pasar un buen rato programando, que es de lo que se trata. El juego se desarrolla en un tablero de 3 x 3 casillas en el que los jugadores van disponiendo sus fichas tratando de formar una línea vertical, horizontal o diagonal. Las fichas del jugador humano tendrán forma de aspa (X) y, las del ordenador, forma de círculo (O) . Al principio, el tablero está en blanco. Comenzará jugando el jugador humano, que colocará una ficha en el tablero. Después, será el turno del ordenador. El proceso se repite hasta que uno de los dos consigue colocar tres fichas formando una línea, o hasta que ya no es posible colocar más fichas (situación de “tablas”) Aviso: este juego es más difícil de programar que los anteriores. Ejercicio 35. Dibujar con asteriscos. Se trata de escribir un programa que sea capaz de dibujar en la pantalla, mediante bucles, estos bonitos diseños. Añade alguno de tu propia cosecha, por favor. (Por si queda alguna duda: el último se supone que es un árbol de navidad) . * *** ***** ******* * *** ***** ******* ***** *** * * * * * * * * * * * * * * *** * *** ***** ******* * *** ***** ******* ********* *********** ************* *** *** *** *** . Ejercicio 36. Máquina tragaperras . Vamos a escribir ahora un programa que simule el funcionamiento de una máquina tragaperras. No es que yo tenga ningún problema con los juegos de azar, ¿eh?, es solo que son simples y adecuados para simular con un ordenador en el momento del curso en el que nos encontramos. Además, puedo dejarlos cuando quiera. El programa debe tener el siguiente comportamiento: . a) Preguntará al usuario con cuánto dinero inicial desea jugar (en euros). Esta cantidad no puede ser menor que 1 euro ni mayor que 50. b) Cada jugada costará 0,50 euros, que se descontarán automáticamente del saldo que el jugador tenga en cada momento. c) Cada jugada consiste en una combinación de tres frutas elegidas al azar entre estas seis: . | Manzana | Naranja | Fresa | Cereza | Limón | Sandía | . d) El jugador no gana nada si las tres frutas que salen son distintas. e) En cambio, si varias frutas coinciden, el jugador gana un premio, que pasa a incrementar su saldo. El premio será: . | Si dos frutas cualesquiera son iguales: . | 1) Si son dos cerezas, 3 euros | 2) Si son dos sandías, 2 euros | 3) Si no son ni sandías ni cerezas, 1 euro | . | Si las tres frutas son iguales: . | 1) Si son tres cerezas, 30 euros | 2) Si son tres sandías, 20 euros | 3) Si son tres fresas, 10 euros | 4) Si no son ni cerezas, ni sandías, ni fresas, 5 euros | . | . f) Después de cada jugada, la máquina comunicará al jugador la combinación que ha salido y le dirá si ha ganado algún premio. g) Después de eso, la máquina le dirá al jugador cuál es su saldo actual y le preguntará si desea seguir jugando. Si el jugador se queda sin dinero, el juego terminará automáticamente sin preguntar nada. Este es un ejemplo de ejecución del programa: . *** BIENVENIDO AL JUEGO DE LA TRAGAPERRAS *** ¿Con cuánto dinero desea empezar (de 1 a 50 euros) ? 60 Cantidad incorrecta ¿Con cuánto dinero desea empezar (de 1 a 50 euros) ? 20 COMIENZA EL JUEGO... La combinación de esta jugada es: NARANJA – CEREZA – SANDÍA Lo siento, no ha obtenido ningún premio Su saldo actual es de 19,5 euros. ¿Desea jugar otra vez (S/N) ? S La combinación de esta jugada es: SANDÍA – SANDÍA - LIMÓN ¡Enhorabuena! Ha ganado 20 euros. Su saldo actual es de 39,5 euros. ¿Desea jugar otra vez (S/N) ? N ¡Hasta la próxima! . Desafíos matemáticos para personas valientes . Ejercicio 37. Mínimo común múltiplo. El programa nos pedirá dos números y calculará el mínimo común múltiplo de ambos. Atención: este ejercicio es de dificultad elevada. Ejercicio 38. Máximo común divisor. Como el anterior, pero calculando el máximo común divisor. Atención: este ejercicio es de dificultad elevada. Ejercicio 39. Escribe un programa que pregunte al usuario su fecha de nacimiento y la fecha del día de hoy, y calcule la edad del usuario en años. (Aviso: no es tan fácil como parece) . Este programa se puede mejorar haciendo que calcule la edad en años, meses y días (¡incluso en horas, minutos y segundos!), pero es una labor por ahora solo apta para los más atrevidos/as. ",
    "url": "https://iescelia.org//docs/tico/_site/diagramas-de-flujo/#24-ejercicios-propuestos",
    "relUrl": "/diagramas-de-flujo/#24-ejercicios-propuestos"
  },"19": {
    "doc": "3. Programación con pseudocódigo",
    "title": "3. Programación con pseudocódigo",
    "content": ". | 3.1. Qué es y qué no es el pseudocódigo | 3.2. Instrucciones típicas en pseudocódigo (versión PSeInt) | 3.3. Un ejemplo sencillo de algoritmo escrito en pseudocódigo | 3.4. Errores frecuentes entre principiantes | 3.5. Ejercicios propuestos | 3.6. Ejercicios resueltos | . ",
    "url": "https://iescelia.org//docs/tico/_site/pseudocodigoXXX/",
    "relUrl": "/pseudocodigoXXX/"
  },"20": {
    "doc": "3. Programación con pseudocódigo",
    "title": "3.1. Qué es y qué no es el pseudocódigo",
    "content": "El pseudocódigo, ya lo hemos dicho, no es un lenguaje formal de programación, sino un pseudolenguaje. Es decir, se asemeja a los lenguajes de programación, pero cada cual se lo monta un poco como quiere. No hay una única forma correcta y universalmente aceptada de escribir el pseudocódigo. Nosotros vamos a usar una sintaxis concreta tomada de una utilidad llamada PSeInt. Se trata de una herramienta aprender programación que permite escribir el pseudocódigo como si fuera un lenguaje de programación real, e incluso ejecutarlo para comprobar si funciona. Vamos a usar PSeInt para hacer las prácticas de esta sección y por eso aprenderemos su pseudocódigo y no otro cualquiera. Hablaremos más de PSeInt en el apartado de ejercicios propuestos. ",
    "url": "https://iescelia.org//docs/tico/_site/pseudocodigoXXX/#31-qu%C3%A9-es-y-qu%C3%A9-no-es-el-pseudoc%C3%B3digo",
    "relUrl": "/pseudocodigoXXX/#31-qué-es-y-qué-no-es-el-pseudocódigo"
  },"21": {
    "doc": "3. Programación con pseudocódigo",
    "title": "3.2. Instrucciones típicas en pseudocódigo (versión PSeInt)",
    "content": "La siguiente tabla muestra una lista de las instrucciones principales del pseudocódigo estándar de PSeInt. | Instrucción | Significado | . | Algoritmo nombre | Marca el comienzo de un algoritmo y le adjudica un nombre | . | FinAlgoritmo | Marca el final del algoritmo | . | Definir variable Como tipo | Declara una variable y le asigna un tipo. Los tipos válidos son Entero, Real, Carácter, Lógico y Cadena. | . | Leer variable | Entrada de datos. El programa lee un dato desde un dispositivo de entrada (si no se indica otra cosa, el teclado), asignando ese dato a la variable. | . | Escribir expresión | Salida de datos. La expresión se calcula y su resultado se muestra en la pantalla. | . | variable &lt;- expresion | Asignación. Se evalúa la expresión y el resultado se guarda en la variable. | . | Si condición Entonces &nbsp;&nbsp;&nbsp;&nbsp;acciones-1 SiNo &nbsp;&nbsp;&nbsp;&nbsp;acciones-2 FinSi | Estructura condicional. Se evalúa la condición. Si es verdadera, se ejecutan las \"acciones-1\". Si es falsa, se ejecutan las \"acciones-2\". | . | Segun expresión hacer &nbsp;&nbsp;&nbsp;&nbsp;valor-1: acciones-1; &nbsp;&nbsp;&nbsp;&nbsp;valor-2: acciones-2; &nbsp;&nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;&nbsp;&nbsp;valor-n: acciones-N; &nbsp;&nbsp;&nbsp;&nbsp;De otro modo: acciones-por-defecto; FinSegun | Condicional múltiple. Si la expresión se evaúa como\"valor-1\", se ejecutan las acciones-1. Si vale \"valor-2\", se ejecutan las acciones-2, y así sucesivamente. Si la expresión no coincide con ningún valor, se ejecutan las acciones-por-defecto. | . | Mientras condición &nbsp;&nbsp;&nbsp;&nbsp;acciones FinMientras | Bucle con condición al princio. Se realizan las acciones repetidamente mientras la condición siga siendo verdadera. | . | Repetir &nbsp;&nbsp;&nbsp;&nbsp;acciones Hasta Que condición | Bucle con condición al final. Se realizan las acciones repetidamente mientras la condición siga siendo verdadera. Observa que el cuerpo de este bucle se ejecuta al menos una vez, mientras que el del bucle anterior podría no ejecutarse nunca (si la condición es falsa desde el principio). | . | Para variable &lt;- valor_inicial Hasta valor_final Hacer &nbsp;&nbsp;&nbsp;&nbsp;acciones FinPara | Bucle con iterador. Se asigna el valor_inicial a la variable. El bucle se repite hasta que la variable llega al valor_final. En cada iteración, la variable se incrementa en una unidad (se puede indicar otro incremento, pero, de momento, nos quedamos con ese). | . También existen instrucciones para crear y manejar subalgoritmos. Como nuestros programas, de momento, van a ser muy simples, aún no vamos a verlas. Nos dedicaremos a ellas cuando llegue el momento. ",
    "url": "https://iescelia.org//docs/tico/_site/pseudocodigoXXX/#32-instrucciones-t%C3%ADpicas-en-pseudoc%C3%B3digo-versi%C3%B3n-pseint",
    "relUrl": "/pseudocodigoXXX/#32-instrucciones-típicas-en-pseudocódigo-versión-pseint"
  },"22": {
    "doc": "3. Programación con pseudocódigo",
    "title": "3.3. Un ejemplo sencillo de algoritmo escrito en pseudocódigo",
    "content": "Vamos a terminar esta sección mostrando un ejemplo sencillo pero muy completo de algoritmo escrito en pseudocódigo. Se trata de escribir un algoritmo tal que, dados dos números enteros (que llamaremos A y B), nos dirá cuáles son los números enteros que existen entre A y B ordenados de menor a mayor. Lo primero que el algoritmo tendrá que hacer será pedirnos los valores de A y B. Después, tendrá que averiguar cuál de los dos es el menor (A o B), para poder luego meterse en un bucle que vaya desde el número menor hasta el número mayor, pasando por todos los valores intermedios e imprimiéndolos. Las instrucciones de ese algoritmo serían estas: . Algoritmo contar_numeros Definir A,B,inicio,final,i Como Entero Escribir 'Dime un número' Leer A Escribir 'Dime otro número' Leer B Si (A&lt;B) Entonces inicio &lt;- A final &lt;- B SiNo inicio &lt;- B final &lt;- A FinSi Escribir 'Estos son los números desde ',inicio,' hasta ',final i &lt;- inicio Mientras (i&lt;=final) Hacer Escribir i i &lt;- i+1 FinMientras FinAlgoritmo . Léelo con atención y asegúrate de entenderlo antes de continuar. En la siguiente sección, veremos cómo representar este mismo algoritmo mediante un diagrama de flujo. ",
    "url": "https://iescelia.org//docs/tico/_site/pseudocodigoXXX/#33-un-ejemplo-sencillo-de-algoritmo-escrito-en-pseudoc%C3%B3digo",
    "relUrl": "/pseudocodigoXXX/#33-un-ejemplo-sencillo-de-algoritmo-escrito-en-pseudocódigo"
  },"23": {
    "doc": "3. Programación con pseudocódigo",
    "title": "3.4. Errores frecuentes entre principiantes",
    "content": "En esta sección recopilo para ti algunas de las dudas, errores y pifias más frecuentes que, según mi experiencia como profesor de programación, suelen asaltar a los principantes. No es lo mismo 20 que “20” . Así es. Cuando estás programando, no es lo mismo la instrucción Escribir 20 (o cualquier otro número) que la instrucción Escribir \"20\", con el número entre comillas. Las cadenas de caracteres siempre se ponen entre comillas. Los números NO. Por eso, Escribir 20 significa literalmente mostrar en pantalla el número 20, mientras que Escribir \"20\" significa mostrar en pantalla la cadena de caracteres “20”. Puede parecer lo mismo, pero no lo es. En una, 20 es un texto y, en otra, un número, y para el ordenador son cosas muy distintas (por ejemplo, no puedes sumar dos textos, pero sí dos números). Escribir “a” no es lo mismo que Escribir a . Un caso particular de la confusión anterior, y muy frecuente cuando se empieza a programar, es confundir Escribir \"a\" (o cualquier otro carácter) con Escribir a. La primera instrucción pide al ordenador que escriba un texto (en este ejemplo, una letra “a”). La segunda instrucción pide al ordenador que escriba el contenido de una variable. Es decir, en Escribir a, la a debe ser una variable preexistente. Y, como todas las variables, debe tener un valor. La instrucción Escribir a pide al ordenador que escriba ese valor, no una letra “a”. ¡Me hago un lío entre Escribir y Leer! . A menudo me he encontrado con que las personas que se inician en la programación de ordenadores confunden escribir y leer: ¡no tienen claro cuándo utilizar una y cuándo la otra! . Esta confusión se debe a un problema de punto de vista. El programador/a novato piensa los algoritmos desde su punto de vista, es decir, como si fuera él o ella quien debe ejecutar el algoritmo. La solución pasa por cambiar el punto de vista. El algoritmo lo ejecutará un ordenador, no nosotros. Los algoritmos son colecciones de órdenes para el ordenador, no para nosotros. Podemos pensar en el ordenador como en un esclavo obediente que hará todo lo que le pidamos (siempre que se lo pidamos en un lenguaje que pueda entender). Así, cuando le pedimos que ejecute una instrucción escribir ‘Hola’, no somos nosotros los que vamos a escribir “Hola”, sino que será la máquina la que lo hará. Y lo escribirá en su pantalla, que es la manera estandarizada en la que un ordenador escribe cosas. Y cuando le pidamos que ejecute leer n, será el ordenador el que leerá el valor de la variable n. ¿Y cómo se las apaña un ordenador para leer cosas? A través de un dispositivo de entrada. Es decir, a través del teclado. La instrucción leer n hará que el programa se detenga hasta que tecleemos algo, y ese algo se almacenará en la variable n. Errores lógicos: confundir Y con O . Este también es un problema frecuente, incluso entre programadores experimentados. Recuerda que los operadores lógicos Y y O tienen exactamente el mismo significado que en español. A partir de ahí, solo te queda utilizar el sentido común. Si, aún así, te enfrentas con una expresión que no acabas de comprender, trata de descomponerla en expresiones más simples para asimilar mejor la lógica del problema. Confundir condición con iteración . Otro error recurrente entre principiantes consiste en confundir la estructura condicional con la iterativa. En concreto, confudir Si… Entonces con Mientras… Hacer. Creo que se debe a que ambas instrucciones comparten la misma estructura: tienen una condición al principio y ejecutan una serie de acciones o no en función de esa condición. Pero hay una diferencia fundamental: las acciones de un Si… Entonces solo se ejecutarán una o ninguna vez, y luego el programa continuará. Las acciones de un Mientras… Hacer se ejecutarán cero, una o muchas veces, dependiendo de la condición. Por lo tanto, para saber si debes usar una u otra, pregúntate esto: “¿tiene sentido que estas acciones se ejecuten muchas veces o, como máximo, se ejecutarán una vez?”. Si la respuesta es “muchas veces”, necesitas un Mientras… Hacer. Si la respuesta es “una vez”, necesitas un Si… Entonces. Pongamos un ejemplo. Imagina que estás escribiendo un programa que pida un número y determine si es negativo. Puedes tener la tentación de escribir esto: . leer N Mientras N &lt; 0 Hacer ---&gt; ¡¡¡CUIDADO, ESTO ES UN ERROR!!! escribir \"El número es negativo\" FinMientras . Si haces eso, habrás provocado involuntariamente un bucle infinito, ya que, cuando el programa entre en el bucle, no logrará salir jamás de él porque la condición siempre será verdadera. Para no caer en este error, trata de responder a la pregunta que planteábamos antes. La única accion que hay dentro de este bucle es Escribir “El número es negativo”, así que debes preguntarte: “¿mi programa tiene que escribir El número es negativo muchas veces, o solo una (en caso de que el número, en efecto, sea negativo)?” . La respuesta, obviamente, es que basta con una. Así que la solución correcta a este problema es: . leer N Si N &lt; 0 Entonces escribir \"El número es negativo\" FinSi . La plaga del Copy &amp; Paste . A menudo sorprendo a mis estudiantes copiando y pegando fragmentos de su propio código para resolver un problema. Cuando eso ocurre, siempre les digo: “¡Alto! Seguro que hay una forma mejor de hacerlo”. Y te aseguro que siempre la hay. Copiar y pegar grandes trozos de código es una pésima práctica de programación. Y lo es por una razón muy sencilla de entender. Imagina que has copiado tu código en veinte sitios diferentes y, un buen día, descubres un error en él. Te va a tocar corregir el error veinte veces. No parece una estrategia muy eficiente. Si estamos copiando y pegando código en varios lugares, seguro que hay otra manera más inteligente de organizar el código para evitar esas repeticiones. Normalmente, la solución pasa por usar subalgoritmos. Funciona, pero ¿a qué precio? . Supongo que has oído la expresión “matar moscas a cañonazos”. A veces, un algoritmo funciona pero es tremendamente ineficiente. Cuando se lo hago notar a mis estudiantes, se rascan la cabeza, encojen los hombros y dicen: sí, pero funciona. Es como si para ir de Almería a Madrid diésemos un rodeo por Nueva York y Calcuta. O por Júpiter y Saturno. Al final llegamos a Madrid. Dos semanas o dos milenios más tarde, pero llegamos. “Sí, pero funciona”. Bueno, pues no. No funciona. Si llego a Madrid con dos milenios de retraso, no funciona. Si una solución es extremadamente ineficiente, no funciona. Hay que buscar otra manera. Soy un desordenado/a . ¿Eres de esas personas que tiene su escritorio hecho un desastre? ¿Cuando abres el cajón de los calcetines parece que ha explotado una bomba nuclear en su interior? ¿Guardas comida caducada en el frigorífico durante meses antes de darte cuenta? . Entonces tienes todas las papeletas para ser el típico programador/a-desastre. El programador/a-desastre escribe su código de cualquier manera, sin respetar las mínimas nociones de orden ni organización: sin sangrías, sin comentarios, sin estructura. Intentar bucear en su código es como entrar en la casa de un afectado por el síndrome de Diógenes. En tu vida personal puedes se un poco desastre si quieres, pero en tu código fuente no. Tienes que escribir código fuente pensando siempre que lo van a leer otras personas. Me da pereza poner nombres significativos a las variables . Las variables y constantes (así como los algoritmos y subalgoritmos) deberían tener nombres significativos, que den una idea de qué contiene esa variable. Sin embargo, me he encontrado con muchos estudiantes que sienten una pereza congénita a la hora de inventar nombres para variables. O que no quieren escribir nombres muy largos, como si teclear un par de caracteres más les costase dinero. Usar identificadores de variables tales como a, aa, aaa, a2, a3, a4 y otras variaciones sobre la letra a es una pésima idea. Usar identificadores como edad, coste_total, numero_de_vidas y cosas por el estilo es un síntoma de estabilidad mental y de buena educación hacia otros programadores que algún día puedan leer tu código. Confudir variables y cadenas . Los identificadores de variables solo pueden contener letras, números y el símbolo “_” (subrayado). Nunca comillas. Recuerda que las comillas se reservan exclusivamente para el contenido de las cadenas de caracteres. Así que, si tienes una variable que se llama, por ejemplo, x, nunca aparecerá escrita como “x”, porque esto último es una cadena de caracteres que contiene un único carácter (la equis). Utilizar variables sin inicializar . Esto es un error común incluso entre programadores experimentados. Más que un error, se trata de un despiste habitual. Todas las variables, antes de ser usadas, tienen que: . | Declararse, esto eso, indicar su nombre y el tipo de datos al que pertenecen (entero, real, carácter, etc). | Inicializarse, es decir, asignarles un valor inicial antes de su primer uso. | . Si te olvidas de inicializar una variable, ¿qué valor tiene? . Imagínate esta situación: declaras una variable llamada x de tipo entero, te olvidas de inicializarla y luego la usas en una operación aritmética como esta: . Definir x, y Como Entero ..... y = x * 2 . ¿Cuál será el valor que tomará la variable y? Es imposible determinarlo, ¿verdad? . Muchos lenguajes de programación impedirán hacer esto porque producirán un error durante la traducción o durante la ejecución. Otros, en cambio, no se preocupan de hacer este tipo de comprobaciones y te dejarán ejecutar ese código, pero el resultado será impredecible. Utilizar variables sin declarar . Aún más grave que no inicializar una variable es no declararla. La mayoría de los lenguajes no permitirán usar una variable sin haberla declarado previamente, pero algunos sí. Asignar de izquierda a derecha . Este es otro error frecuente entre principiantes. Por suerte, tiene fácil solución. El error consiste en confundir los términos de una asignación. Recuerda que, en las asignaciones: . | A la izquierda del símbolo &lt;- tiene que aparecer una única variable. | A la derecha del símobo &lt;- puede aparecer una variable o una expresión compleja. | . Una asignación válida es esta: x &lt;- y * 2 + (rc(z)/8). Fíjate que a la izquierda aparece una variable solitaria (x) y a la derecha una expresión compleja. El error consiste en hacer la asignación al revés, es decir, colocando la variable solitaria a la derecha y la expresión a la izquierda. Esto, por supuesto, no puede ejecutarse en ningún ordenador. Usar palabras reservadas como identificadores . Otro despiste que todos cometemos a veces es usar una palabra reservada por el lenguaje de programación como identificador. Por ejemplo, no es buena idea ponerle de nombre a una de mis variables cosas como si, entonces, algoritmo o hacer, puesto que son palabras reservadas de mi lenguaje (pseudocódigo). Cuando programes en un lenguaje de programación real, esto se hace extensible a cualquier palabra reservada de ese lenguaje. Tampoco es buena idea usar tildes ni caracteres especiales (como vocales acentuadas) en los identificadores. La mayor parte de los lenguajes de programación reales no los aceptarán, así que mejor que nos acostumbremos a ello desde el principio, aunque infrinjamos algunas reglas ortográficas. ¡Ojo!, que solo seremos flexibles con la ortografía en el código fuente. El resto de nuestros textos no tienen permiso para vapulear la lengua. La multiplicación se escribe *, no x . Recuerda que el símbolo para multiplicar, en informática, es el asterisco (*). Ni equis (x) ni punto (.) . Practicar, practicar y practicar . A programar se aprende programando. Esto es así de sencillo, y si alguien te dice lo contrario te está mintiendo. No te creerías a nadie que te ofreciera un método mágico para aprender chino en solo un mes, practicando cinco minutos al día, ¿verdad? Pues a programar, lo mismo. Ninguna cosa que merezca la pena aprender se aprende sin esfuerzo. Puede que no te guste esta idea, pero es lo que hay. Así que, si estás dispuesto/a a aprender a programar, prepárate para pasar mucho tiempo peleando con tu ordenador (¡y con tu cabeza!) y a sudar tinta. Por eso es imprescindible disfrutar del proceso: si no, se vuelve una tarea tan ardua como escalar el Everest. Así que mi principal consejo para todos los principiantes es: practica, practica y practica. Y si, mientras practicas, te das cuenta de que no estás disfrutando, plantéate si de verdad quieres aprender a programar. ",
    "url": "https://iescelia.org//docs/tico/_site/pseudocodigoXXX/#34-errores-frecuentes-entre-principiantes",
    "relUrl": "/pseudocodigoXXX/#34-errores-frecuentes-entre-principiantes"
  },"24": {
    "doc": "3. Programación con pseudocódigo",
    "title": "3.5. Ejercicios propuestos",
    "content": "A partir de este punto, necesitarás instalar PSeInt en tu ordenador. En todos los ejercicios que vienen a continuación se te pide escribir un programa que resuelva un determinado problema. Puedes escribirlo en pseudocódigo o con un diagrama de flujo, como prefieras, ya que, con PSeInt, ambas herramientas son intercambiables. No dejes de comprobar que tu solución funciona antes de pasar al siguiente. No es necesario que hagas todos los ejercicios. Están ordenados en un grado de dificultad creciente, de modo que, si los primeros te resultan muy sencillos, puedes saltar a otro un poco más complicado. Céntrate solo en los que te parezcan más interesantes, o incluso puedes inventarte tus propios programas. En realidad, esto último es lo más adecuado. Recuerda que para aprender a programar necesitarás practicar, practicar y practicar. Y para lograr practicar tanto, es imprescindible que te guste lo que estás haciendo. A partir de este punto, necesitarás instalar PSeInt en tu ordenador. En todos los ejercicios que vienen a continuación se te pide escribir un programa que resuelva un determinado problema. Puedes escribirlo en pseudocódigo o con un diagrama de flujo, como prefieras, ya que, con PSeInt, ambas herramientas son intercambiables. No dejes de comprobar que tu solución funciona antes de pasar al siguiente. No es necesario que hagas todos los ejercicios. Están ordenados en un grado de dificultad creciente, de modo que, si los primeros te resultan muy sencillos, puedes saltar a otro un poco más complicado. Céntrate solo en los que te parezcan más interesantes, o incluso puedes inventarte tus propios programas. En realidad, esto último es lo más adecuado. Recuerda que para aprender a programar necesitarás practicar, practicar y practicar. Y para lograr practicar tanto, es imprescindible que te guste lo que estás haciendo. Ejercicio 0. Instala PseInt en tu ordenador siguiendo las instrucciones que hemos dado antes. Comprueba que el programa arranca con normalidad y sin errores. No olvides configurar adecuadamente PseInt durante la primera ejecución. Si te equivocas, se puede reconfigurar más tarde, pero es más engorroso. Si el programa ya está instalado en tu ordenador, puedes pasar al siguiente ejercicio. Ejercicios con estructura secuencial . Ejercicio 1. Calcular el área y la circunferencia de un círculo cuyo radio será proporcionado a través del teclado. Recuerda que área = 3.14 x r x r y circunferencia = 2 x 3.14 x r Ejercicio 2. Pedir las cuatro notas de los exámenes del primer trimestre de un alumno y mostrar la nota media obtenida. Ejercicio 3. Calcular el precio de llenar una piscina de agua. Para ello se tienen que pedir al usuario las medidas de la piscina (largo, ancho y alto) y el precio del m​3​ del agua. Se mostrará el precio total. Supondremos que la piscina es de forma regular. Ejercicios con estructuras condicionales . Ejercicio 4. Determinar si un número leído del teclado es positivo, negativo o cero. Ejercicio 5. Calcular la raíz cuadrada de un número introducido por teclado. Hay que tener la precaución de comprobar que el número sea positivo. Ejercicio 6. Leídos dos números por teclado, A y B, calcular la resta del mayor menos el menor. Por ejemplo, si A = 8 y B = 3, el resultado debe ser A – B, es decir, 5. Pero si A = 4 y B = 7, el resultado debe ser B – A, es decir, 3. Ejercicio 7. Averiguar si un número real introducido por teclado tiene o no parte fraccionaria (utilícese la función trunc() que aparece descrita en los apuntes) . Ejercicio 8. Leer un número real y un tipo de moneda, que puede ser \"euro\" o \"peseta\". Convertir la cantidad al tipo de moneda indicado, suponiendo que está expresada en la otra. Por ejemplo, si la cantidad es 15 y la moneda es \"peseta\", se supondrá que se trata de 15 € y que hay que convertirlos a pesetas y, por lo tanto, el resultado debe ser 2495. Ejercicio 9. Leer tres números por teclado, X, Y y Z, y decidir si están ordenados de menor a mayor. Ejercicio 10. Como el anterior, pero para averiguar si los números son consecutivos. Ejercicio 11. Determinar si un año es bisiesto o no (los años bisiestos son múltiplos de 4; utilícese el operador módulo) . Ejercicio 12. Determinar el número de cifras de un número entero. El algoritmo debe funcionar para números de hasta 5 cifras, considerando los negativos. Por ejemplo, si se introduce el número 5342, la respuesta del programa debe ser 4. Si se introduce –250, la respuesta debe ser 3. Ejercicio 13. Calcular las dos soluciones de una ecuación de segundo grado, del tipo ax2 + bx + c = 0. Los coeficientes a, b y c deberá introducirlos el usuario a través del teclado. Ejercicios con estructuras condicionales e iterativas . Ejercicio 14. Escribir todos los números entre 1 y n, siendo n un entero introducido por teclado. Ejercicio 15. Escribir todos los números pares entre 1 y n. Ejercicio 16. Escribir todos los números impares entre dos números a y b introducidos por teclado. Antes habrá que comprobar cuál de los dos números (a o b) es mayor. Ejercicio 17. Calcular la suma de todos los números pares entre 1 y n, siendo n un entero introducido por teclado. Es decir, hay que calcular 2 + 4 + 6 + … hasta n (o n-1, si n es un número impar). Ejercicio 18. Realiza un programa que calcule la suma de los n primeros números, donde n es un número introducido por teclado. Al terminar, el programa nos mostrará el mensaje \"¿Desea terminar? (S/N)\". Si el usuario escribe \"S\", el programa terminará, pero, si escribe \"N\", volverá a comenzar. Ejercicio 19. Calcular la nota media de un alumno a partir de las notas de todos sus exámenes a lo largo del curso. El programa nos irá pidiendo notas, pero no sabemos cuántas son. Para terminar de introducir valores, el usuario debe teclear un número negativo. Entonces, el programa calculará el promedio de todas las notas introducidas. Ejercicio 20. El usuario de este programa será un profesor, que introducirá las notas de sus 30 alumnos de una en una. El algoritmo debe decirle cuántos suspensos y cuántos aprobados hay. Ejercicio 21. Calcular el valor máximo de una serie de 10 números introducidos por teclado. Ejercicio 22. Generalizar el ejercicio anterior para que también se averigüe el valor mínimo y el medio. Ejercicio 23. Calcular el factorial de un número entero N. Recuerda que el factorial de un número es el producto de ese número por todos los enteros menores que él. Por ejemplo, el factorial de 5 (simbolizado 5!) se calcula como: 5! = 5 x 4 x 3 x 2 x 1. Ejercicio 24. Generar combinaciones al azar para la lotería primitiva (6 números entre 1 y 49). Debes utilizar la función azar(x) que vimos en los apuntes. Por ahora, no te preocupes porque los números puedan repetirse. Ejercicio 25. Generar combinaciones al azar para la quiniela (14 valores dentro del conjunto 1, X o 2). Ejercicios más avanzados . Ejercicio 26. Determinar si un número N introducido por teclado es o no primo. Recuerda que un número primo es aquél que sólo es divisible por sí mismo y por la unidad. Ejercicio 27. Generalizar el algoritmo anterior para averiguar todos los números primos que existen entre 2 y N, siendo N un número introducido por teclado. Ejercicio 28. Introducida una hora por teclado (horas, minutos y segundos), se pretende sumar un segundo a ese tiempo e imprimir en la pantalla la hora que resulta (también en forma de horas, minutos y segundos). Ejercicio 29. La calculadora. Diseñar un algoritmo que lea dos números, A y B, y un operador (mediante una variable de tipo carácter), y calcule el resultado de operar A y B con esa operación. Por ejemplo, si A = 5 y B = 2, y operación = “+”, el resultado debe ser 7. El algoritmo debe seguir pidiendo números y operaciones indefinidamente, hasta que el usuario decida terminar (utilizar un valor centinela para ello) . Algunos juegos sencillos . Ejercicio 30. Juego del número secreto. El ordenador elegirá un número al azar entre 1 y 100. El usuario irá introduciendo números por teclado, y el ordenador le irá dando pistas: “mi número es mayor” o “mi número es menor”, hasta que el usuario acierte. Entonces el ordenador le felicitará y le comunicará el número de intentos que necesitó para acertar el número secreto**. Ejercicio 31. Número de la suerte . El número de la suerte o lucky number es una tontuna que se han inventado los numerólogos y que se obtiene sumando todas las cifras de la fecha de nacimiento de un modo azaroso. Por ejemplo, como yo nací el 15 de octubre de 1974 (15-10-1974), se supone que mi número de la suerte es 15+10+1974 = 1999. Ahora sumo todas las cifras de 1999 así: 1+9+9+9 = 28. Como aún tengo dos dígitos, vuelvo a sumarlos. 2 + 8 = 10. Y, por último, 1 + 0 = 1. Por lo tanto, 1 es mi número de la suerte. Si alguna vez me toca la lotería y llevo un número acabado en 1, os aviso. Por ahora, nos conformamos con escribir un programa que, dada una fecha de nacimiento (día, mes y año), calcule el número de la suerte de esa persona. Ejercicio 32. El juego de la ruleta . Escribe un programa que permita jugar a la ruleta con el ordenador. Supondremos que la ruleta tiene 20 números rojos y 20 negros. El jugador, que tendrá una suma de dinero inicial, apostará una cantidad (siempre menor que el dinero que le quede) a un número y un color. La ruleta, que puedes simular con el método azar(), la manejará el ordenador y comunicará al jugador el resultado. Si el jugador acierta, multiplicará por 10 el dinero apostado. Si falla, perderá el dinero apostado. El proceso se repetirá hasta que el jugador decida abandonar el juego, o bien se quede sin dinero. Por favor, abstenerse ludópatas. Ejercicio 33. Juego de dados . Escribe un programa para jugar a los dados con el ordenador. Las reglas del juego son las siguientes: . | El jugador humano dispondrá de una cantidad inicial de dinero que se introducirá por teclado. | El jugador apostará una cantidad de dinero (siempre igual o menor del que le queda) | Después, se tirarán tres dados (lo cual se puede simular con el método azar()) | Si en los tres dados sale la misma cantidad, el dinero apostado por el jugador: . | Se multiplica por 5 si en los dados ha salido un 6 | Se multiplica por 3 si sale cualquier otra cantidad | . | Si en dos dados de los tres sale la misma cantidad, el dinero apostado se multiplica por 2 | En cualquier otro caso, el dinero apostado se pierde | El proceso se repite hasta que el jugador se queda sin dinero o hasta que decide dejar de jugar. | . Ejercicio 34. Juego de las Tres en Raya . Vamos a hacer una versión del popular juego de las Tres en Raya para jugar contra el ordenador. No será un juego con inteligencia artificial como el de la WOPR (si no sabes qué es la WOPR, bueno, ¿para qué sirve wikipedia?), pero te permitirá pasar un buen rato programando, que es de lo que se trata. El juego se desarrolla en un tablero de 3 x 3 casillas en el que los jugadores van disponiendo sus fichas tratando de formar una línea vertical, horizontal o diagonal. Las fichas del jugador humano tendrán forma de aspa (X) y, las del ordenador, forma de círculo (O) . Al principio, el tablero está en blanco. Comenzará jugando el jugador humano, que colocará una ficha en el tablero. Después, será el turno del ordenador. El proceso se repite hasta que uno de los dos consigue colocar tres fichas formando una línea, o hasta que ya no es posible colocar más fichas (situación de “tablas”) Aviso: este juego es más difícil de programar que los anteriores. Ejercicio 35. Dibujar con asteriscos. Se trata de escribir un programa que sea capaz de dibujar en la pantalla, mediante bucles, estos bonitos diseños. Añade alguno de tu propia cosecha, por favor. (Por si queda alguna duda: el último se supone que es un árbol de navidad) . * *** ***** ******* * *** ***** ******* ***** *** * * * * * * * * * * * * * * *** * *** ***** ******* * *** ***** ******* ********* *********** ************* *** *** *** *** . Ejercicio 36. Máquina tragaperras . Vamos a escribir ahora un programa que simule el funcionamiento de una máquina tragaperras. No es que yo tenga ningún problema con los juegos de azar, ¿eh?, es solo que son simples y adecuados para simular con un ordenador en el momento del curso en el que nos encontramos. Además, puedo dejarlos cuando quiera. El programa debe tener el siguiente comportamiento: . a) Preguntará al usuario con cuánto dinero inicial desea jugar (en euros). Esta cantidad no puede ser menor que 1 euro ni mayor que 50. b) Cada jugada costará 0,50 euros, que se descontarán automáticamente del saldo que el jugador tenga en cada momento. c) Cada jugada consiste en una combinación de tres frutas elegidas al azar entre estas seis: . | Manzana | Naranja | Fresa | Cereza | Limón | Sandía | . d) El jugador no gana nada si las tres frutas que salen son distintas. e) En cambio, si varias frutas coinciden, el jugador gana un premio, que pasa a incrementar su saldo. El premio será: . | Si dos frutas cualesquiera son iguales: . | 1) Si son dos cerezas, 3 euros | 2) Si son dos sandías, 2 euros | 3) Si no son ni sandías ni cerezas, 1 euro | . | Si las tres frutas son iguales: . | 1) Si son tres cerezas, 30 euros | 2) Si son tres sandías, 20 euros | 3) Si son tres fresas, 10 euros | 4) Si no son ni cerezas, ni sandías, ni fresas, 5 euros | . | . f) Después de cada jugada, la máquina comunicará al jugador la combinación que ha salido y le dirá si ha ganado algún premio. g) Después de eso, la máquina le dirá al jugador cuál es su saldo actual y le preguntará si desea seguir jugando. Si el jugador se queda sin dinero, el juego terminará automáticamente sin preguntar nada. Este es un ejemplo de ejecución del programa: . *** BIENVENIDO AL JUEGO DE LA TRAGAPERRAS *** ¿Con cuánto dinero desea empezar (de 1 a 50 euros) ? 60 Cantidad incorrecta ¿Con cuánto dinero desea empezar (de 1 a 50 euros) ? 20 COMIENZA EL JUEGO... La combinación de esta jugada es: NARANJA – CEREZA – SANDÍA Lo siento, no ha obtenido ningún premio Su saldo actual es de 19,5 euros. ¿Desea jugar otra vez (S/N) ? S La combinación de esta jugada es: SANDÍA – SANDÍA - LIMÓN ¡Enhorabuena! Ha ganado 20 euros. Su saldo actual es de 39,5 euros. ¿Desea jugar otra vez (S/N) ? N ¡Hasta la próxima! . Desafíos matemáticos para personas valientes . Ejercicio 37. Mínimo común múltiplo. El programa nos pedirá dos números y calculará el mínimo común múltiplo de ambos. Atención: este ejercicio es de dificultad elevada. Ejercicio 38. Máximo común divisor. Como el anterior, pero calculando el máximo común divisor. Atención: este ejercicio es de dificultad elevada. Ejercicio 39. Escribe un programa que pregunte al usuario su fecha de nacimiento y la fecha del día de hoy, y calcule la edad del usuario en años. (Aviso: no es tan fácil como parece) . Este programa se puede mejorar haciendo que calcule la edad en años, meses y días (¡incluso en horas, minutos y segundos!), pero es una labor por ahora solo apta para los más atrevidos/as. ",
    "url": "https://iescelia.org//docs/tico/_site/pseudocodigoXXX/#35-ejercicios-propuestos",
    "relUrl": "/pseudocodigoXXX/#35-ejercicios-propuestos"
  },"25": {
    "doc": "3. Programación con pseudocódigo",
    "title": "3.6. Ejercicios resueltos",
    "content": "A continuación, vamos a mostrar la solución de algunos de los ejercicios anteriores. No de todos, porque entonces este texto sería interminable, pero si de bastantes de ellos. Ten en cuenta que, en muchas ocasiones, hay más de una solución posible igualmente válida. Si tú has logrado resolver el ejercicio por otra vía, puede que hayas dado con una de esas otras soluciones. Sin embargo, también hay soluciones inaceptables por su poca eficiencia aunque, en apariencia, parezcan funcionar bien. Ten en cuenta que, para ir de Almería a Granada, se puede ir por la autovía A-92 o se puede dar un rodeo por Barcelona. O por Júpiter y Saturno. De todos esos modos conseguiremos llegar a Granada, pero las últimas soluciones son tan ineficientes que no resultan aceptables. Lo mismo ocurre con los programas informáticos. Cuando tu solución sea muy diferente de la mía, pregúntate si la tuya da un rodeo mucho mayor que la mía para llegar al mismo sitio, o si, por el contrario, es igual de eficiente (¡o incluso más!). En este caso, enhorabuena: has dado con una de esas soluciones alternativas de las que hablaba. Por último, permíteme un consejo: intenta resistir la tentación de mirar la solución a los ejercicios antes de hacerlos. Es muy conveniente que pases un rato tratando de resolver los problemas por ti mismo/a antes de mirar la solución. Al menos, es muy conveniente si tu intención es aprender a programar. Ejercicios con estructura secuencial . Ejercicio 1. Calcular el área y la circunferencia de un círculo cuyo radio será proporcionado a través del teclado. Recuerda que área = 3.14 x r x r y circunferencia = 2 x 3.14 x r . Solución en pseudocódigo: . Algoritmo area_circulo Definir radio, area, circunferencia Como Real Escribir \"Dime el radio\" Leer radio area &lt;- PI * radio ^ 2 circunferencia &lt;- 2 * PI * radio Escribir \"El área es: \", area Escribir \"La circunferencia mide: \", circunferencia FinAlgoritmo . Solución en diagrama de flujo: . Ejercicio 2. Pedir las cuatro notas de los exámenes del primer trimestre de un alumno y mostrar la nota media obtenida. Solución en pseudocódigo: . Algoritmo media_examenes Definir nota1, nota2, nota3, nota4 como entero Definir media como real Escribir \"Dime las cuatro notas\" Leer nota1, nota2, nota3, nota4 media &lt;- (nota1 + nota2 + nota3 + nota4) / 4 Escribir \"La nota media es: \", media Si media &gt;= 5 Entonces escribir \"Has aprobado, enhorabuena\" SiNo escribir \"Has suspendido, sigue jugando\" FinSi FinAlgoritmo . Solución en diagrama de flujo: . Ejercicio 3. Calcular el precio de llenar una piscina de agua. Para ello se tienen que pedir al usuario las medidas de la piscina (largo, ancho y alto) y el precio del m​3​ del agua. Se mostrará el precio total. Supondremos que la piscina es de forma regular. Solución en pseudocódigo: . Algoritmo piscina Definir largo, ancho, alto como real Definir preciom3 como real Definir costeTotal Como Real Escribir \"¿Cuál es el largo de la piscina (en cm)?\" Leer largo Escribir \"¿Cuál es el ancho de la piscina (en cm)?\" Leer ancho Escribir \"¿Cuál es el alto de la piscina (en cm)?\" Leer alto Escribir \"¿Cuál es el precio del metro cúbico de agua (en euros)?\" Leer preciom3 coste &lt;- largo/100 * ancho/100 * alto/100 * preciom3 Escribir \"El coste de llenar la piscina es: \", coste, \" euros\" FinAlgoritmo . Solución en diagrama de flujo: . Ejercicio 4. Determinar si un número leído del teclado es positivo, negativo o cero. Solución en pseudocódigo: . Algoritmo positivo_negativo Definir n como entero Escribir \"Dime un número\" Leer n si n &gt; 0 Entonces escribir \"El número es POSITIVO\" FinSi si n &lt; 0 Entonces escribir \"El número es NEGATIVO\" FinSi si n = 0 Entonces escribir \"El número no es ni positivo ni negativo\" FinSi FinAlgoritmo . Solución en diagrama de flujo: . Ejercicio 8. Leer un número real y un tipo de moneda, que puede ser “euro” o “peseta”. Convertir la cantidad al tipo de moneda indicado, suponiendo que está expresada en la otra. Por ejemplo, si la cantidad es 15 y la moneda es “peseta”, se supondrá que se trata de 15 € y que hay que convertirlos a pesetas y, por lo tanto, el resultado debe ser 2495. Solución en pseudocódigo: . Algoritmo euros_pesetas Definir cantidad, euros, pesetas como real Definir moneda como cadena Escribir \"Dime una cantidad\" Leer cantidad Escribir \"¿La quieres convertir a euros o a pesetas?\" Leer moneda Si moneda = \"euros\" Entonces euros &lt;- cantidad / 166 Escribir cantidad, \" pesetas son \", euros, \" euros\" SiNo pesetas &lt;- cantidad * 166 Escribir cantidad, \" euros son \", pesetas, \" pesetas\" FinSi FinAlgoritmo . Solución en diagrama de flujo: . Ejercicio 12. Determinar el número de cifras de un número entero. El algoritmo debe funcionar para números de hasta 5 cifras, considerando los negativos. Por ejemplo, si se introduce el número 5342, la respuesta del programa debe ser 4. Si se introduce –250, la respuesta debe ser 3. Solución en pseudocódigo: . Algoritmo contar_cifras Definir n como entero Definir numCifras como entero Escribir \"Dime una número entero de hasta 5 cifras\" Leer n si n &gt; -10 y n &lt; 10 Entonces numCifras &lt;- 1 FinSi si (n &lt;= -10 y n &gt; -100) o (n &gt;= 10 y n &lt; 100) Entonces numCifras &lt;- 2 FinSi si (n &lt;= -100 y n &gt; -1000) o (n &gt;= 100 y n &lt; 1000) Entonces numCifras &lt;- 3 FinSi si (n &lt;= -1000 y n &gt; -10000) o (n &gt;= 1000 y n &lt; 10000) Entonces numCifras &lt;- 4 FinSi si (n &lt;= -10000 y n &gt; -100000) o (n &gt;= 10000 y n &lt; 100000) Entonces numCifras &lt;- 5 FinSi si n &lt;= -100000 o n &gt;= 100000 Entonces Escribir \"Error, ese número tiene más de 5 cifras\" SiNo Escribir \"El número de cifras del número \", n, \" es \", numCifras FinSi FinAlgoritmo . Solución en diagrama de flujo: . Ejercicio 14. Escribir todos los números entre 1 y n, siendo n un entero introducido por teclado. Solución en pseudocódigo: . Algoritmo contar_de_uno_a_n Definir n,i Como Entero Escribir 'Dime un número' Leer n i &lt;- 1 Mientras i&lt;=n Hacer Escribir i i &lt;- i+1 FinMientras FinAlgoritmo . Solución en diagrama de flujo: . Ejercicio 15. Escribir todos los números pares entre 1 y n. Solución en pseudocódigo: . Algoritmo contar_pares Definir n,i Como Entero Escribir 'Dime un número' Leer n i &lt;- 2 Mientras i&lt;=n Hacer Escribir i i &lt;- i+2 FinMientras FinAlgoritmo . Solución en diagrama de flujo: . Ejercicio 16. Escribir todos los números impares entre dos números a y b introducidos por teclado. Antes habrá que comprobar cuál de los dos números (a o b) es mayor. Solución en pseudocódigo: . Algoritmo contar_de_a_a_b Definir a, b, i Como Entero Definir menor, mayor como Entero // Pedimos los dos números por teclado Escribir 'Dime el primer número' Leer a Escribir 'Dime el segundo número' Leer b // Miramos cuál es el menor y cuál el mayor Si a &lt; b Entonces menor &lt;- a mayor &lt;- b SiNo menor &lt;- b mayor &lt;- a FinSi // Si el menor es un número PAR, le sumamos uno para empezar // por el siguiente IMPAR Si menor mod 2 = 0 Entonces menor &lt;- menor + 1 FinSi // Por fin, mostramos los impares que hay entre el número menor y el mayor i &lt;- menor Mientras i &lt;= mayor Hacer Escribir i i &lt;- i + 2 FinMientras FinAlgoritmo . Solución en diagrama de flujo: . Ejercicio 18. Realiza un programa que calcule la suma de los n primeros números, donde n es un número introducido por teclado. Al terminar, el programa nos mostrará el mensaje “¿Desea terminar? (S/N)”. Si el usuario escribe “S”, el programa terminará, pero, si escribe “N”, volverá a comenzar. Solución en pseudocódigo: . Algoritmo sumar_n_numeros Definir n, i, suma Como Entero Definir terminar Como Caracter Repetir Escribir 'Por favor, escribe un número entero positivo:' Leer n i &lt;- 1 suma &lt;- 0 Mientras i &lt;= n Hacer suma &lt;- suma+i i &lt;- i + 1 FinMientras Escribir 'La suma de los ',n,' primeros números es: ',suma Escribir '¿Quieres terminar? (S/N)' Leer terminar Hasta Que terminar = 'S' O terminar = 's' FinAlgoritmo . Solución en diagrama de flujo: . Ejercicio 22. Calcular el valor máximo de una serie de 10 números introducidos por teclado. Generalizar la solución anterior para que también se averigüe el valor mínimo y el medio. Solución en pseudocódigo: . Algoritmo maximo_minimo_medio Definir maximo,minimo Como Entero Definir medio Como Real Definir suma,n,i Como Entero Escribir 'Dime un número' Leer n maximo &lt;- n minimo &lt;- n suma &lt;- 0 Para i&lt;-1 Hasta 9 Hacer Escribir 'Dime otro número' Leer n Si (n&gt;maximo) Entonces maximo &lt;- n FinSi Si (n&lt;minimo) Entonces minimo &lt;- n FinSi suma &lt;- suma+n FinPara medio &lt;- suma/10 Escribir 'El valor máximo es: ',maximo Escribir 'El valor medio es: ',medio Escribir 'El valor mínimo es: ',minimo FinAlgoritmo . Solución en diagrama de flujo: . Ejercicio 23. Calcular el factorial de un número entero N. Recuerda que el factorial de un número es el producto de ese número por todos los enteros menores que él. Por ejemplo, el factorial de 5 (simbolizado 5!) se calcula como: 5! = 5 x 4 x 3 x 2 x 1. Solución en pseudocódigo: . Algoritmo factorial Definir f,n,i Como Entero Escribir 'Dime un número' Leer n f &lt;- n Para i&lt;-n-1 Hasta 1 Con Paso -1 Hacer f &lt;- f*i FinPara Escribir 'El factorial de ',n,' es ',f FinAlgoritmo . Solución en diagrama de flujo: . Ejercicio 24 (Solución 1 - Los números pueden repetirse). Generar combinaciones al azar para la lotería primitiva (6 números entre 1 y 49). Debes utilizar la función azar(x) que vimos en los apuntes. Por ahora, no te preocupes porque los números puedan repetirse. Solución en pseudocódigo: . Algoritmo loteria_primitiva_version_1 Definir n, i Como Entero Escribir \"Generador de combinaciones de la lotería primitiva\" Escribir \"(Versión 1 - Puede repetirse algún número)\" Para i desde 1 hasta 6 hacer n &lt;- azar(48)+1 Escribir n FinPara FinAlgoritmo . Solución en diagrama de flujo: . Ejercicio 24 (Solución 2 - Los números NO PUEDEN repetirse). Generar combinaciones al azar para la lotería primitiva (6 números entre 1 y 49). Debes utilizar la función azar(x) que vimos en los apuntes . Solución en pseudocódigo: . Algoritmo loteria_primitiva_version_2 Definir n,i,j Como Entero Dimension n[6] Definir esta_repetido Como Logico Escribir 'Generador de combinaciones de la lotería primitiva' Escribir '(Versión 2 - No pueden repetirse números)' Para i&lt;-1 Hasta 6 Hacer Repetir n[i] &lt;- azar(48)+1 esta_repetido &lt;- falso Para j&lt;-1 Hasta i-1 Hacer Si n[j]=n[i] Entonces esta_repetido &lt;- verdadero FinSi FinPara Si esta_repetido=verdadero Entonces n[i] &lt;- azar(48)+1 FinSi Hasta Que esta_repetido=falso Escribir n[i] FinPara FinAlgoritmo . Solución en diagrama de flujo: . Ejercicio 25. Generar combinaciones al azar para la quiniela (14 valores dentro del conjunto 1, X o 2). Solución en pseudocódigo: . (NOTA: supondremos que la función azar() devuelve un valor aleatorio entre 0 y n-1. Con PSeInt, esta función se puede configurar para que los devuelva entre 1 y n, y la solución sería ligeramente distinta) . Algoritmo quiniela Definir n,i Como Entero Escribir 'Tu combinación para la quiniela es:' Para i&lt;-1 Hasta 14 Hacer n &lt;- azar(3) Si n=0 Entonces Escribir 'X' SiNo Escribir n FinSi FinPara FinAlgoritmo . Solución en diagrama de flujo: . Ejercicio 26. Determinar si un número N introducido por teclado es o no primo. Recuerda que un número primo es aquél que sólo es divisible por sí mismo y por la unidad. Solución en pseudocódigo: . Algoritmo primo Definir n,i Como Entero Definir es_primo Como Logico Escribir 'Por favor, teclea un número entero positivo' Leer n es_primo &lt;- verdadero Para i&lt;-2 Hasta n/2 Hacer Si n MOD i=0 Entonces es_primo &lt;- falso FinSi FinPara Si es_primo Entonces Escribir 'El número ',n,' ES PRIMO' SiNo Escribir 'El número ',n,' NO ES PRIMO' FinSi FinAlgoritmo . Solución en diagrama de flujo: . Ejercicio 32. Escribe un programa que permita jugar a la ruleta con el ordenador. Supondremos que la ruleta tiene 20 números rojos y 20 negros. El jugador, que tendrá una suma de dinero inicial, apostará una cantidad (siempre menor que el dinero que le quede) a un número y un color. La ruleta, que puedes simular con el método azar(), la manejará el ordenador y comunicará al jugador el resultado. Si el jugador acierta, multiplicará por 10 el dinero apostado. Si falla, perderá el dinero apostado. El proceso se repetirá hasta que el jugador decida abandonar el juego, o bien se quede sin dinero. Por favor, abstenerse ludópatas. Solución en pseudocódigo: . Algoritmo ruleta Definir dinero, numero_apuesta, color_apuesta, cantidad_apuesta, numero_ruleta, color_ruleta como entero Definir seguir_jugando Como Caracter dinero &lt;- 500 Repetir Repetir Escribir \"¿A qué número apuestas? (1-20)\" Leer numero_apuesta Hasta Que numero_apuesta &gt;= 1 y numero_apuesta &lt;= 20 Repetir Escribir \"¿A qué color apuestas? (1 = negro o 2 = rojo)\" Leer color_apuesta Hasta Que color_apuesta = 1 o color_apuesta = 2 Repetir Escribir \"¿Cuánta cantidad apuestas? (1 - \", dinero, \")\" Leer cantidad_apuesta Hasta Que cantidad_apuesta &gt; 0 y cantidad_apuesta &lt;= dinero numero_ruleta &lt;- azar(20) color_ruleta &lt;- azar(2) Si numero_ruleta = numero_apuesta y color_ruleta = color_apuesta Entonces dinero &lt;- dinero + cantidad_apuesta * 10 Escribir \"¡Enhorabuena! Has ganado \", cantidad_apuesta * 10 SiNo dinero &lt;- dinero - cantidad_apuesta Escribir \"Oooh, has perdido\" FinSi Escribir \"Ahora mismo tienes \", dinero, \" euros\" Escribir \"¿Quieres seguir jugando? (S/N)\" Leer seguir_jugando Hasta Que dinero &lt;= 0 o seguir_jugando = \"N\" Escribir \"Espero volver a verte pronto\" FinAlgoritmo . (No mostramos la solución en diagrama de flujo porque ocupa demasiado espacio. No obstante, si te interesa verla, solo tienes que escribir el programa en PSeInt y pedirle que te muestre el diagrama de flujo equivalente) . Ejercicio 34. Juego de las 3 en raya. El juego se desarrolla en un tablero de 3 x 3 casillas en el que los jugadores van disponiendo sus fichas tratando de formar una línea vertical, horizontal o diagonal. Las fichas del jugador humano tendrán forma de aspa (X) y, las del ordenador, forma de círculo (O). Al principio, el tablero está en blanco. Comenzará jugando el jugador humano, que colocará una ficha en el tablero. Después, será el turno del ordenador. El proceso se repite hasta que uno de los dos consigue colocar tres fichas formando una línea, o hasta que ya no es posible colocar más fichas (situación de “tablas”). Solución en pseudocódigo: . En esta solución hemos utilizado arrays y subalgoritmos, dos elementos muy importantes en programación de lo que hablaremos en el próximo tema. Sin embargo, los introducimos ya aquí para que los vayas conociendo. Trata de leer y comprender el código fuente, aunque aparezcan esos elementos desconocidos. Verás que, a pesar de su longitud, es más fácil de lo que parece y puedes entender gran parte de lo que está aquí escrito. Algoritmo tres_en_raya Definir tablero Como Caracter Dimension tablero[10] Definir ganador como Cadena Definir tablas como Logico inicializar(tablero) // Esto es un subalgoritmo. Está escrito más abajo Repetir mostrar(tablero) colocar_pieza_humano(tablero) ganador &lt;- comprobar_ganador(tablero) tablas &lt;- comprobar_tablas(tablero) Si ganador = \"Ninguno\" y tablas = Falso Entonces colocar_pieza_ordenador(tablero) ganador &lt;- comprobar_ganador(tablero) tablas &lt;- comprobar_tablas(tablero) FinSi Hasta Que ganador &lt;&gt; \"Ninguno\" o tablas = Verdadero mostrar(tablero) Si ganador = \"Ninguno\" Entonces Escribir \"El juego ha terminado en tablas\" SiNo Escribir \"El juego ha terminado. El ganador es: \", ganador FinSi FinAlgoritmo // -------------------------------------------- // Inicializa el tablero con espacios en blanco // -------------------------------------------- SubAlgoritmo inicializar(tablero por referencia) Definir i como entero Para i &lt;- 1 hasta 9 Hacer tablero[i] &lt;- \" \" FinPara FinSubAlgoritmo // -------------------------------------------- // Muestra el estado actual del tablero // -------------------------------------------- SubAlgoritmo mostrar(tablero) Escribir \"ESTADO ACTUAL DEL TABLERO\" Escribir \"+---+---+---+\" Escribir \"| \",tablero[1],\" | \",tablero[2],\" | \",tablero[3],\" |\" Escribir \"+---+---+---+\" Escribir \"| \",tablero[4],\" | \",tablero[5],\" | \",tablero[6],\" |\" Escribir \"+---+---+---+\" Escribir \"| \",tablero[7],\" | \",tablero[8],\" | \",tablero[9],\" |\" Escribir \"+---+---+---+\" FinSubAlgoritmo // --------------------------------------------------- // Coloca una pieza del jugador humano en el tablero // --------------------------------------------------- SubAlgoritmo colocar_pieza_humano(tablero por referencia) Definir casilla Como Entero Definir casilla_correcta como Logico Repetir Escribir \"¿En qué casilla quieres poner una pieza? (1-9)\" Leer casilla casilla_correcta &lt;- falso Si tablero[casilla] = \" \" Entonces tablero[casilla] &lt;- \"X\" casilla_correcta &lt;- verdadero SiNo Escribir \"Error: Esa casilla ya está ocupada\" FinSi Hasta Que casilla_correcta = Verdadero FinSubAlgoritmo // --------------------------------------------------- // Coloca una pieza del ordenador en el tablero // --------------------------------------------------- SubAlgoritmo colocar_pieza_ordenador(tablero por referencia) Definir casilla Como Entero Definir casilla_correcta como Logico Escribir \"Es mi turno. Estoy pensando...\" Esperar 2 Segundos casilla_correcta &lt;- falso Repetir casilla &lt;- azar(9)+1 Escribir \"Voy a colocar mi pieza en la casilla \", casilla Esperar 2 Segundos Si tablero[casilla] = \" \" Entonces tablero[casilla] &lt;- \"O\" casilla_correcta &lt;- verdadero SiNo Escribir \"¡Está ocupada!\" FinSi Hasta Que casilla_correcta = Verdadero FinSubAlgoritmo // --------------------------------------------------- // Comprueba si hay un ganador según el estado del // tablero. Devuelve \"Ninguno\", \"Humano\" u \"Ordenador\" // --------------------------------------------------- SubAlgoritmo ganador &lt;- comprobar_ganador(tablero) Definir ganador como cadena ganador &lt;- \"Ninguno\" // Comprobamos primera fila Si tablero[1] = tablero[2] y tablero[1] = tablero[3] Entonces Si tablero[1] = \"X\" Entonces ganador &lt;- \"Humano\" FinSi Si tablero[1] = \"O\" Entonces ganador &lt;- \"Ordenador\" FinSi FinSi // Comprobamos segunda fila Si tablero[4] = tablero[5] y tablero[4] = tablero[6] Entonces Si tablero[4] = \"X\" Entonces ganador &lt;- \"Humano\" FinSi Si tablero[4] = \"O\" Entonces ganador &lt;- \"Ordenador\" FinSi FinSi // Comprobamos tercera fila Si tablero[7] = tablero[8] y tablero[7] = tablero[9] Entonces Si tablero[7] = \"X\" Entonces ganador &lt;- \"Humano\" FinSi Si tablero[7] = \"O\" Entonces ganador &lt;- \"Ordenador\" FinSi FinSi // Comprobamos primera columna Si tablero[1] = tablero[4] y tablero[1] = tablero[7] Entonces Si tablero[1] = \"X\" Entonces ganador &lt;- \"Humano\" FinSi Si tablero[1] = \"O\" Entonces ganador &lt;- \"Ordenador\" FinSi FinSi // Comprobamos segunda columna Si tablero[2] = tablero[5] y tablero[2] = tablero[8] Entonces Si tablero[2] = \"X\" Entonces ganador &lt;- \"Humano\" FinSi Si tablero[2] = \"O\" Entonces ganador &lt;- \"Ordenador\" FinSi FinSi // Comprobamos tercera columna Si tablero[3] = tablero[6] y tablero[3] = tablero[9] Entonces Si tablero[3] = \"X\" Entonces ganador &lt;- \"Humano\" FinSi Si tablero[3] = \"O\" Entonces ganador &lt;- \"Ordenador\" FinSi FinSi // Comprobamos una diagonal Si tablero[1] = tablero[5] y tablero[1] = tablero[9] Entonces Si tablero[1] = \"X\" Entonces ganador &lt;- \"Humano\" FinSi Si tablero[1] = \"O\" Entonces ganador &lt;- \"Ordenador\" FinSi FinSi // Comprobamos la otra diagonal Si tablero[3] = tablero[5] y tablero[3] = tablero[7] Entonces Si tablero[3] = \"X\" Entonces ganador &lt;- \"Humano\" FinSi Si tablero[3] = \"O\" Entonces ganador &lt;- \"Ordenador\" FinSi FinSi FinSubAlgoritmo // ------------------------------------------- // Comprueba si hay una situación de tablas // según el estado actual del tablero. Devuelve // verdadero si hay tablas o falso en otro caso. // ------------------------------------------- SubAlgoritmo tablas &lt;- comprobar_tablas(tablero) Definir tablas Como Logico Definir i, contador Como Entero contador &lt;- 0 Para i &lt;- 1 hasta 9 Hacer Si (tablero[i] &lt;&gt; \" \") Entonces contador &lt;- contador + 1 FinSi FinPara // Si todas las casillas están ya ocupadas y no hay ganador, // entonces estamos en tablas. Si contador = 9 Entonces tablas &lt;- Verdadero SiNo tablas &lt;- Falso FinSi FinSubAlgoritmo . (No mostramos la solución en diagrama de flujo porque ocupa demasiado espacio. No obstante, si te interesa verla, solo tienes que escribir el programa en PSeInt y pedirle que te muestre el diagrama de flujo equivalente) . ",
    "url": "https://iescelia.org//docs/tico/_site/pseudocodigoXXX/#36-ejercicios-resueltos",
    "relUrl": "/pseudocodigoXXX/#36-ejercicios-resueltos"
  },"26": {
    "doc": "3. Programación con pseudocódigo y Python",
    "title": "3. Programación con pseudocódigo y Python",
    "content": ". | 3.1. Pseudocódigo . | 3.1.1. Instrucciones típicas en pseudocódigo (versión PSeInt) | 3.1.2. Un ejemplo sencillo de algoritmo escrito en pseudocódigo | 3.1.3. Cómo ejecutar un programa escrito en Pseudocódigo | . | 3.2. Python . | 3.2.1. Correspondencia entre pseudocódigo y Python | 3.2.2. Un ejemplo sencillo de algoritmo escrito en Python | 3.2.3. Cómo ejecutar un programa escrito Python | . | 3.3. Errores frecuentes entre principiantes | 3.4. Ejercicios propuestos | . ",
    "url": "https://iescelia.org//docs/tico/_site/pseudocodigo-y-python/",
    "relUrl": "/pseudocodigo-y-python/"
  },"27": {
    "doc": "3. Programación con pseudocódigo y Python",
    "title": "3.1. Pseudocódigo",
    "content": "El pseudocódigo no es un lenguaje formal de programación, sino un pseudolenguaje. Es decir, se asemeja a los lenguajes de programación, pero cada cual se lo monta un poco como quiere. No hay una única forma correcta y universalmente aceptada de escribir el pseudocódigo. Nosotros vamos a usar una sintaxis concreta tomada de una utilidad llamada PSeInt. Así podremos no solo escribir nuestros programas, sino ejecutarlos, depurarlos e incluso ver su diagrama de flujo. 3.1.1. Instrucciones típicas en pseudocódigo (versión PSeInt) . Las instrucciones de pseudocódigo tienen una correspondiencia directa con los símbolos de los diagramas de flujo. La siguiente tabla muestra una lista de las instrucciones principales del pseudocódigo estándar de PSeInt. | Instrucción | Significado | . | Algoritmo nombre | Marca el comienzo de un algoritmo y le adjudica un nombre | . | FinAlgoritmo | Marca el final del algoritmo | . | Definir variable Como tipo | Declara una variable y le asigna un tipo. Los tipos válidos son Entero, Real, Carácter, Lógico y Cadena. | . | Leer variable | Entrada de datos. El programa lee un dato desde un dispositivo de entrada (si no se indica otra cosa, el teclado), asignando ese dato a la variable. | . | Escribir expresión | Salida de datos. La expresión se calcula y su resultado se muestra en la pantalla. | . | variable &lt;- expresion | Asignación. Se evalúa la expresión y el resultado se guarda en la variable. | . | Si condición Entonces &nbsp;&nbsp;&nbsp;&nbsp;acciones-1 SiNo &nbsp;&nbsp;&nbsp;&nbsp;acciones-2 FinSi | Estructura condicional. Se evalúa la condición. Si es verdadera, se ejecutan las \"acciones-1\". Si es falsa, se ejecutan las \"acciones-2\". | . | Segun expresión hacer &nbsp;&nbsp;&nbsp;&nbsp;valor-1: acciones-1; &nbsp;&nbsp;&nbsp;&nbsp;valor-2: acciones-2; &nbsp;&nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;&nbsp;&nbsp;valor-n: acciones-N; &nbsp;&nbsp;&nbsp;&nbsp;De otro modo: acciones-por-defecto; FinSegun | Condicional múltiple. Si la expresión se evaúa como\"valor-1\", se ejecutan las acciones-1. Si vale \"valor-2\", se ejecutan las acciones-2, y así sucesivamente. Si la expresión no coincide con ningún valor, se ejecutan las acciones-por-defecto. | . | Mientras condición &nbsp;&nbsp;&nbsp;&nbsp;acciones FinMientras | Bucle con condición al princio. Se realizan las acciones repetidamente mientras la condición siga siendo verdadera. | . | Repetir &nbsp;&nbsp;&nbsp;&nbsp;acciones Hasta Que condición | Bucle con condición al final. Se realizan las acciones repetidamente mientras la condición siga siendo verdadera. Observa que el cuerpo de este bucle se ejecuta al menos una vez, mientras que el del bucle anterior podría no ejecutarse nunca (si la condición es falsa desde el principio). | . | Para variable &lt;- valor_inicial Hasta valor_final Hacer &nbsp;&nbsp;&nbsp;&nbsp;acciones FinPara | Bucle con iterador. Se asigna el valor_inicial a la variable. El bucle se repite hasta que la variable llega al valor_final. En cada iteración, la variable se incrementa en una unidad (se puede indicar otro incremento, pero, de momento, nos quedamos con ese). | . También existen instrucciones para crear y manejar subalgoritmos. Como nuestros programas, de momento, van a ser muy simples, aún no vamos a verlas. Nos dedicaremos a ellas cuando llegue el momento. 3.1.2. Un ejemplo sencillo de algoritmo escrito en pseudocódigo . Lo mejor para comprender cómo se escribe un programa en pseudocódigo es ver un ejemplo. Vamos a mostrando un ejemplo sencillo pero muy completo de algoritmo escrito en pseudocódigo. Se trata de escribir un algoritmo tal que, dados dos números enteros (que llamaremos A y B), nos dirá cuáles son los números enteros que existen entre A y B ordenados de menor a mayor. Lo primero que el algoritmo tendrá que hacer será pedirnos los valores de A y B. Después, tendrá que averiguar cuál de los dos es el menor (A o B), para poder luego meterse en un bucle que vaya desde el número menor hasta el número mayor, pasando por todos los valores intermedios e imprimiéndolos. Las instrucciones de ese algoritmo serían estas: . Algoritmo contar_numeros Definir A,B,inicio,final,i Como Entero Escribir 'Dime un número' Leer A Escribir 'Dime otro número' Leer B Si (A&lt;B) Entonces inicio &lt;- A final &lt;- B SiNo inicio &lt;- B final &lt;- A FinSi Escribir 'Estos son los números desde ',inicio,' hasta ',final i &lt;- inicio Mientras (i&lt;=final) Hacer Escribir i i &lt;- i+1 FinMientras FinAlgoritmo . Léelo con atención y asegúrate de entenderlo antes de continuar. También es buena idea que intentes representar este mismo algoritmo mediante un diagrama de flujo y compares esa representación con el pseudocódigo anterior. Te darás cuenta de que, en realidad, son dos formas de describir exactamente el mismo programa. 3.1.3. Cómo ejecutar un programa escrito en Pseudocódigo . Si has escrito el programa usando el dialecto de PseInt, no hay nada más fácil: basta con que pegues el código fuente en el editor de texto de PseInt y pulses el botón de “Ejecutar”. Ten en cuenta que, si tu programa tiene errores de escritura, la ejecución no se lanzará, sino que PseInt te marcará en rojo las líneas donde ha detectado el error o errores. Tendrás que corregirlos antes de poder ejecutar el programar. ",
    "url": "https://iescelia.org//docs/tico/_site/pseudocodigo-y-python/#31-pseudoc%C3%B3digo",
    "relUrl": "/pseudocodigo-y-python/#31-pseudocódigo"
  },"28": {
    "doc": "3. Programación con pseudocódigo y Python",
    "title": "3.2. Python",
    "content": "Los lenguajes de programación reales son algo más complejos que el pseudocódigo. Unos más y otros menos. Uno de los lenguajes más semejantes a pseudocódigo que, además, está muy de moda últimamente es el lenguaje Python. Puedes crear programas sencillos con Python de forma muy semejante a cómo lo harías con pseudocódigo (aunque, por supuesto, Python tiene muchas otras características adicionales que lo hacen muy potente y en las que no vamos a entrar aquí). 3.2.1. Correspondencia entre pseudocódigo y Python . En la siguiente tabla se muestran las correspondencias entre las principales instrucciones de pseudocódigo y las de Python: . | PSEUDOCÓDIGO | PYTHON | . | // Condicional simple Si condición entonces &nbsp;&nbsp;&nbsp;acciones-1 FinSi | # Condicional simple if condicion: &nbsp;&nbsp;&nbsp;acciones | . | // Condicional doble Si condición entonces &nbsp;&nbsp;&nbsp;acciones-1 Sino &nbsp;&nbsp;&nbsp;acciones-2 FinSi | # Condicional doble if condicion: &nbsp;&nbsp;&nbsp;acciones-1 else: &nbsp;&nbsp;&nbsp;acciones-2 | . | // Bucle tipo “mientras” Mientras condición hacer &nbsp;&nbsp;&nbsp;acciones FinMientras | # Bucle tipo “mientras” while condición: &nbsp;&nbsp;&nbsp;acciones | . | // Bucle tipo “para” Para variable &lt;- valor_inicial hasta valor_final Hacer &nbsp;&nbsp;&nbsp;acciones FinPara | # Bucle tipo “para” for elemento in secuencia: &nbsp;&nbsp;&nbsp;acciones | . | // Asignación a &lt;- 20 | # Asignación a = 20 | . | // Salida de datos Escribir \"El resultado es \", x | # Salida de datos print(\"El resultado es \", x) | . | // Entrada de datos Escribir \"Dime un número\" Leer variable | # Entrada de datos variable = input(\"Dime un número\") | . Como puedes observar, para escribir Python en lugar de Pseudocódigo basta con cambiar ligeramente la sintaxis de las instrucciones y, por supuesto, escribirlas en inglés en lugar de usar el castellano. Observa que Python no tiene instrucciones del tipo “FinSi” o “FinMientras”. Para marcar el final de un bloque, Python usa la sangría izquierda, es decir, el espacio que hay a la izquierda del texto: si un texto está más sangrado que la instrucción anterior, significa que ha comenzado un bloque de código. Si el texto regresa a la sangría que tenía antes, significa que ese bloque ha terminado. Lo mostramos en el siguiente ejemplo, donde se puede ver un bucle while escrito con Pseudocódigo y con Python. Fíjate en cómo marca cada lenguaje el comienzo y el final del bucle: . | PSEUDOCÓDIGO | PYTHON | . | i &lt;- 0 Mientras i &lt; 100 hacer // Aquí empieza el cuerpo bucle. // La sangría izquierda es optativa, y sirve // para facilitar la lectura del código. Escribir i i &lt;- i + 1 FinMientras // Esta instrucción ya está fuera del bucle Escribir \"El bucle ha terminado\" . | i = 0 while i &lt; 100: # Aquí empieza el cuerpo del bucle. # La sangría izquierda es OBLIGATORIA. # Sirve para marcar el cuerpo del bucle. print i i = i + 1 # Esta instrucción ya está fuera del bucle # porque no tiene sangría izquierda print \"El bucle ha terminado\" . | . 3.2.2. Un ejemplo sencillo de algoritmo escrito en Python . Teniendo en cuenta la tabla anterior, es fácil escribir en Python el mismo programa que hicimos antes con pseudocódigo; ya sabes, aquel que mostraba todos los números enteros que hay entre dos números cualesquiera, A y B, que se introducen por teclado. Aquí lo tienes: . # Definir las variables A, B, inicio, final e i A = int(input(\"Dime un número: \")) B = int(input(\"Dime otro número: \")) # Determinar los valores de inicio y final if A &lt; B: inicio = A final = B else: inicio = B final = A # Mostrar los números desde inicio hasta final print(\"Estos son los números desde\", inicio, \"hasta\", final) i = inicio while i &lt;= final: print(i) i = i + 1 . Observa cómo se hace la entrada de datos en las dos primeras instrucciones del algoritmo: no solo hay que usar la intrucción input(), sino que hay que usar una segunda instrucción int(). Esto ocurre porque, en Python, cualquier cosa que se lea por el teclado se considera una cadena de caracteres. Para manipularla como otra cosa (por ejemplo, un número entero), es necesario convertirla explícitamente a ese tipo de datos. Y eso es exactamente lo que hace int(): convertir lo que le pases entre paréntesis en un número entero. 3.2.3. Cómo ejecutar un programa escrito Python . Existen muchas maneras de ejecutar un programa con Python. Aquí te vamos a mencionar dos de las más simples: . 1) Usando Thonny . Thonny es un IDE, es decir, un Entorno Integrado de Desarrollo, especialmente simple y pensado para trabajar con Python. Lo de IDE significa que incluye en un solo programa todo lo necesario para desarrollar aplicaciones (editor, intérprete, depurador y otro montón de herramientas que no hemos visto). Por lo tanto, solo tienes que instalar Thonny (si aún no lo tienes) y escribir el código Python en su editor. Después, bastará con pulsar el botón de “Ejecución”. 2) Mediante un intérprete online de Python . Existen muchos intérpretes online de Python que, sin necesidad de instalar nada en tu máquina, son capaces de ejecutar tu código fuente escrito en Python. Solo tienes que acceder a uno de estos intérpretes y (a veces registrándote antes, a veces sin registro) copiar y pegar tu código y pulsar el botón de ejecución. Algunos intérpretes online de Python bastante confiables son el de W3Schools o el de Porgramiz. ",
    "url": "https://iescelia.org//docs/tico/_site/pseudocodigo-y-python/#32-python",
    "relUrl": "/pseudocodigo-y-python/#32-python"
  },"29": {
    "doc": "3. Programación con pseudocódigo y Python",
    "title": "3.3. Errores frecuentes entre principiantes",
    "content": "En esta sección recopilo para ti algunas de las dudas, errores y pifias más frecuentes que, según mi experiencia como profesor de programación, suelen asaltar a los principantes. Tanto si estás aprendiendo a programar con pseudocódigo como si lo haces con un lenguaje de programación real (como Python), es muy probable que hayas caído o vayas a caer en alguno de los siguientes errores, así que es buena idea que les eches un vistazo antes de lanzarte a hacer tu próximo programa. No es lo mismo 20 que “20” . Así es. Cuando estás programando, no es lo mismo la instrucción Escribir 20 (o cualquier otro número) que la instrucción Escribir \"20\", con el número entre comillas. Las cadenas de caracteres siempre se ponen entre comillas. Los números NO. Por eso, Escribir 20 significa literalmente mostrar en pantalla el número 20, mientras que Escribir \"20\" significa mostrar en pantalla la cadena de caracteres “20”. Puede parecer lo mismo, pero no lo es. En una, 20 es un texto y, en otra, un número, y para el ordenador son cosas muy distintas (por ejemplo, no puedes sumar dos textos, pero sí dos números). Escribir “a” no es lo mismo que Escribir a . Un caso particular de la confusión anterior, y muy frecuente cuando se empieza a programar, es confundir Escribir \"a\" (o cualquier otro carácter) con Escribir a. La primera instrucción pide al ordenador que escriba un texto (en este ejemplo, una letra “a”). La segunda instrucción pide al ordenador que escriba el contenido de una variable. Es decir, en Escribir a, la a debe ser una variable preexistente. Y, como todas las variables, debe tener un valor. La instrucción Escribir a pide al ordenador que escriba ese valor, no una letra “a”. ¡Me hago un lío entre Escribir y Leer! . A menudo me he encontrado con que las personas que se inician en la programación de ordenadores confunden escribir y leer: ¡no tienen claro cuándo utilizar una y cuándo la otra! . Esta confusión se debe a un problema de punto de vista. El programador/a novato piensa los algoritmos desde su punto de vista, es decir, como si fuera él o ella quien debe ejecutar el algoritmo. La solución pasa por cambiar el punto de vista. El algoritmo lo ejecutará un ordenador, no nosotros. Los algoritmos son colecciones de órdenes para el ordenador, no para nosotros. Podemos pensar en el ordenador como en un esclavo obediente que hará todo lo que le pidamos (siempre que se lo pidamos en un lenguaje que pueda entender). Así, cuando le pedimos que ejecute una instrucción escribir ‘Hola’, no somos nosotros los que vamos a escribir “Hola”, sino que será la máquina la que lo hará. Y lo escribirá en su pantalla, que es la manera estandarizada en la que un ordenador escribe cosas. Y cuando le pidamos que ejecute leer n, será el ordenador el que leerá el valor de la variable n. ¿Y cómo se las apaña un ordenador para leer cosas? A través de un dispositivo de entrada. Es decir, a través del teclado. La instrucción leer n hará que el programa se detenga hasta que tecleemos algo, y ese algo se almacenará en la variable n. Errores lógicos: confundir Y con O . Este también es un problema frecuente, incluso entre programadores experimentados. Recuerda que los operadores lógicos Y y O tienen exactamente el mismo significado que en español. A partir de ahí, solo te queda utilizar el sentido común. Si, aún así, te enfrentas con una expresión que no acabas de comprender, trata de descomponerla en expresiones más simples para asimilar mejor la lógica del problema. Confundir condición con iteración . Otro error recurrente entre principiantes consiste en confundir la estructura condicional con la iterativa. En concreto, confudir Si… Entonces con Mientras… Hacer. Creo que se debe a que ambas instrucciones comparten la misma estructura: tienen una condición al principio y ejecutan una serie de acciones o no en función de esa condición. Pero hay una diferencia fundamental: las acciones de un Si… Entonces solo se ejecutarán una o ninguna vez, y luego el programa continuará. Las acciones de un Mientras… Hacer se ejecutarán cero, una o muchas veces, dependiendo de la condición. Por lo tanto, para saber si debes usar una u otra, pregúntate esto: “¿tiene sentido que estas acciones se ejecuten muchas veces o, como máximo, se ejecutarán una vez?”. Si la respuesta es “muchas veces”, necesitas un Mientras… Hacer. Si la respuesta es “una vez”, necesitas un Si… Entonces. Pongamos un ejemplo. Imagina que estás escribiendo un programa que pida un número y determine si es negativo. Puedes tener la tentación de escribir esto: . leer N Mientras N &lt; 0 Hacer ---&gt; ¡¡¡CUIDADO, ESTO ES UN ERROR!!! escribir \"El número es negativo\" FinMientras . Si haces eso, habrás provocado involuntariamente un bucle infinito, ya que, cuando el programa entre en el bucle, no logrará salir jamás de él porque la condición siempre será verdadera. Para no caer en este error, trata de responder a la pregunta que planteábamos antes. La única accion que hay dentro de este bucle es Escribir “El número es negativo”, así que debes preguntarte: “¿mi programa tiene que escribir El número es negativo muchas veces, o solo una (en caso de que el número, en efecto, sea negativo)?” . La respuesta, obviamente, es que basta con una. Así que la solución correcta a este problema es: . leer N Si N &lt; 0 Entonces escribir \"El número es negativo\" FinSi . La plaga del Copy &amp; Paste . A menudo sorprendo a mis estudiantes copiando y pegando fragmentos de su propio código para resolver un problema. Cuando eso ocurre, siempre les digo: “¡Alto! Seguro que hay una forma mejor de hacerlo”. Y te aseguro que siempre la hay. Copiar y pegar grandes trozos de código es una pésima práctica de programación. Y lo es por una razón muy sencilla de entender. Imagina que has copiado tu código en veinte sitios diferentes y, un buen día, descubres un error en él. Te va a tocar corregir el error veinte veces. No parece una estrategia muy eficiente. Si estamos copiando y pegando código en varios lugares, seguro que hay otra manera más inteligente de organizar el código para evitar esas repeticiones. Normalmente, la solución pasa por usar subalgoritmos. Funciona, pero ¿a qué precio? . Supongo que has oído la expresión “matar moscas a cañonazos”. A veces, un algoritmo funciona pero es tremendamente ineficiente. Cuando se lo hago notar a mis estudiantes, se rascan la cabeza, encojen los hombros y dicen: sí, pero funciona. Es como si para ir de Almería a Madrid diésemos un rodeo por Nueva York y Calcuta. O por Júpiter y Saturno. Al final llegamos a Madrid. Dos semanas o dos milenios más tarde, pero llegamos. “Sí, pero funciona”. Bueno, pues no. No funciona. Si llego a Madrid con dos milenios de retraso, no funciona. Si una solución es extremadamente ineficiente, no funciona. Hay que buscar otra manera. Soy un desordenado/a . ¿Eres de esas personas que tiene su escritorio hecho un desastre? ¿Cuando abres el cajón de los calcetines parece que ha explotado una bomba nuclear en su interior? ¿Guardas comida caducada en el frigorífico durante meses antes de darte cuenta? . Entonces tienes todas las papeletas para ser el típico programador/a-desastre. El programador/a-desastre escribe su código de cualquier manera, sin respetar las mínimas nociones de orden ni organización: sin sangrías, sin comentarios, sin estructura. Intentar bucear en su código es como entrar en la casa de un afectado por el síndrome de Diógenes. En tu vida personal puedes se un poco desastre si quieres, pero en tu código fuente no. Tienes que escribir código fuente pensando siempre que lo van a leer otras personas. Me da pereza poner nombres significativos a las variables . Las variables y constantes (así como los algoritmos y subalgoritmos) deberían tener nombres significativos, que den una idea de qué contiene esa variable. Sin embargo, me he encontrado con muchos estudiantes que sienten una pereza congénita a la hora de inventar nombres para variables. O que no quieren escribir nombres muy largos, como si teclear un par de caracteres más les costase dinero. Usar identificadores de variables tales como a, aa, aaa, a2, a3, a4 y otras variaciones sobre la letra a es una pésima idea. Usar identificadores como edad, coste_total, numero_de_vidas y cosas por el estilo es un síntoma de estabilidad mental y de buena educación hacia otros programadores que algún día puedan leer tu código. Confudir variables y cadenas . Los identificadores de variables solo pueden contener letras, números y el símbolo “_” (subrayado). Nunca comillas. Recuerda que las comillas se reservan exclusivamente para el contenido de las cadenas de caracteres. Así que, si tienes una variable que se llama, por ejemplo, x, nunca aparecerá escrita como “x”, porque esto último es una cadena de caracteres que contiene un único carácter (la equis). Utilizar variables sin inicializar . Esto es un error común incluso entre programadores experimentados. Más que un error, se trata de un despiste habitual. Todas las variables, antes de ser usadas, tienen que: . | Declararse, esto eso, indicar su nombre y el tipo de datos al que pertenecen (entero, real, carácter, etc). | Inicializarse, es decir, asignarles un valor inicial antes de su primer uso. | . Si te olvidas de inicializar una variable, ¿qué valor tiene? . Imagínate esta situación: declaras una variable llamada x de tipo entero, te olvidas de inicializarla y luego la usas en una operación aritmética como esta: . Definir x, y Como Entero ..... y = x * 2 . ¿Cuál será el valor que tomará la variable y? Es imposible determinarlo, ¿verdad? . Muchos lenguajes de programación impedirán hacer esto porque producirán un error durante la traducción o durante la ejecución. Otros, en cambio, no se preocupan de hacer este tipo de comprobaciones y te dejarán ejecutar ese código, pero el resultado será impredecible. Utilizar variables sin declarar . Aún más grave que no inicializar una variable es no declararla. La mayoría de los lenguajes no permitirán usar una variable sin haberla declarado previamente, pero algunos sí. Asignar de izquierda a derecha . Este es otro error frecuente entre principiantes. Por suerte, tiene fácil solución. El error consiste en confundir los términos de una asignación. Recuerda que, en las asignaciones: . | A la izquierda del símbolo &lt;- tiene que aparecer una única variable. | A la derecha del símobo &lt;- puede aparecer una variable o una expresión compleja. | . Una asignación válida es esta: x &lt;- y * 2 + (rc(z)/8). Fíjate que a la izquierda aparece una variable solitaria (x) y a la derecha una expresión compleja. El error consiste en hacer la asignación al revés, es decir, colocando la variable solitaria a la derecha y la expresión a la izquierda. Esto, por supuesto, no puede ejecutarse en ningún ordenador. Usar palabras reservadas como identificadores . Otro despiste que todos cometemos a veces es usar una palabra reservada por el lenguaje de programación como identificador. Por ejemplo, no es buena idea ponerle de nombre a una de mis variables cosas como si, entonces, algoritmo o hacer, puesto que son palabras reservadas de mi lenguaje (pseudocódigo). Cuando programes en un lenguaje de programación real, esto se hace extensible a cualquier palabra reservada de ese lenguaje. Tampoco es buena idea usar tildes ni caracteres especiales (como vocales acentuadas) en los identificadores. La mayor parte de los lenguajes de programación reales no los aceptarán, así que mejor que nos acostumbremos a ello desde el principio, aunque infrinjamos algunas reglas ortográficas. ¡Ojo!, que solo seremos flexibles con la ortografía en el código fuente. El resto de nuestros textos no tienen permiso para vapulear la lengua. La multiplicación se escribe *, no x . Recuerda que el símbolo para multiplicar, en informática, es el asterisco (*). Ni equis (x) ni punto (.) . Practicar, practicar y practicar . A programar se aprende programando. Esto es así de sencillo, y si alguien te dice lo contrario te está mintiendo. No te creerías a nadie que te ofreciera un método mágico para aprender chino en solo un mes, practicando cinco minutos al día, ¿verdad? Pues a programar, lo mismo. Ninguna cosa que merezca la pena aprender se aprende sin esfuerzo. Puede que no te guste esta idea, pero es lo que hay. Así que, si estás dispuesto/a a aprender a programar, prepárate para pasar mucho tiempo peleando con tu ordenador (¡y con tu cabeza!) y a sudar tinta. Por eso es imprescindible disfrutar del proceso: si no, se vuelve una tarea tan ardua como escalar el Everest. Así que mi principal consejo para todos los principiantes es: practica, practica y practica. Y si, mientras practicas, te das cuenta de que no estás disfrutando, plantéate si de verdad quieres aprender a programar. ",
    "url": "https://iescelia.org//docs/tico/_site/pseudocodigo-y-python/#33-errores-frecuentes-entre-principiantes",
    "relUrl": "/pseudocodigo-y-python/#33-errores-frecuentes-entre-principiantes"
  },"30": {
    "doc": "3. Programación con pseudocódigo y Python",
    "title": "3.4. Ejercicios propuestos",
    "content": "Vamos a resolver con pseudocódigo (o con Python, si lo prefieres) varios de los ejercicios que ya propusimos hacer con diagramas de flujo. La idea es que ahora los escribas, depures y pruebes tecleando el código, no dibujando del diagrama de flujo. Por lo tanto, necesitarás PseInt (si usas pseudocódigo) o Thonny (si usas Python) para realizar los siguientes ejercicios. Ejercicio introductorio . Ejercicio 0. Escribe un programa que, simplemente, muestre el mensaje \"Hola, mundo\" por la consola de texto. Este programa, por tradición, es el primero que se escribe cuando un programador/a está probando un lenguaje o un entorno de desarrollo nuevo. Ejercicios con condicionales . Ejercicio 9. Escribe un programa que lea tres números por teclado, X, Y y Z, y te diga si están ordenados de menor a mayor, es decir, si X es menor que Y y, además, Y es menor que Z. Ejercicio 10 (optativo para ampliar). Modifica el programa anterior para que, además de decirte si X, Y y Z están ordenados, te diga si son consecutivos. Ejercicios con bucles . Ejercicio 17. Escribe un programa que calcule el sumatorio entre 1 y n, siendo n un entero introducido por teclado. Es decir, tiene que calcular 1 + 2 + 3 + ... + n y mostrar el resultado en la pantalla. Ejercicio 25. Escribe un programa que genere una combinación al azar para la quiniela (es decir, 14 valores dentro del conjunto 1, X o 2). Puedes generar un número aleatorio entre 1 y n con PseInt usando la función azar(n). Con Python, eso mismo se hace escribiendo randint(1,n) Ejercicio 30. Juego del número secreto (optativo para ampliar). En este programa, el ordenador elegirá un número al azar entre 1 y 100. El usuario irá introduciendo números por teclado, y el ordenador le irá dando pistas: \"mi número es mayor\" o \"mi número es menor\", hasta que el usuario acierte. Entonces el ordenador le felicitará y le comunicará el número de intentos que necesitó para acertar el número secreto**. Ejercicio 33. Juego de dados (optativo: solo para valientes). Escribe un programa para jugar a los dados con el ordenador. Las reglas del juego son las siguientes: . | El jugador humano dispondrá de una cantidad inicial de dinero que se introducirá por teclado. | El jugador apostará una cantidad de dinero (siempre igual o menor del que le queda) | Después, se tirarán tres dados (lo cual se puede simular con el método azar()) . | Si en los tres dados sale la misma cantidad, el dinero apostado por el jugador: . | Se multiplica por 5 si en los dados ha salido un 6 | Se multiplica por 3 si sale cualquier otra cantidad | . | Si en dos dados de los tres sale la misma cantidad, el dinero apostado se multiplica por 2 | . | En cualquier otro caso, el dinero apostado se pierde | El proceso se repite hasta que el jugador se queda sin dinero o hasta que decide dejar de jugar. | . ",
    "url": "https://iescelia.org//docs/tico/_site/pseudocodigo-y-python/#34-ejercicios-propuestos",
    "relUrl": "/pseudocodigo-y-python/#34-ejercicios-propuestos"
  },"31": {
    "doc": "4. Internet y la web - HTML y CSS",
    "title": "4. Internet y la web: HTML y CSS",
    "content": "HTML es el lenguaje que se utiliza para definir la estructura y el contenido de las páginas web. CSS es el lenguaje que se utiliza para dotar de un diseño atractivo y reutilizable a esas mismas páginas. Ya hemos visto estos lenguajes en clase. En esta sección os dejo solo unos resúmenes. Para ampliar información, puedes consultar multitud de manuales y tutoriales online. Por ejemplo, los de W3C. | Resumen de HTML | Ejemplos de uso de HTML | Resumen de CSS | Ejemplos de uso de CSS | . ",
    "url": "https://iescelia.org//docs/tico/_site/internet-web-html-css/#4-internet-y-la-web-html-y-css",
    "relUrl": "/internet-web-html-css/#4-internet-y-la-web-html-y-css"
  },"32": {
    "doc": "4. Internet y la web - HTML y CSS",
    "title": "4. Internet y la web - HTML y CSS",
    "content": " ",
    "url": "https://iescelia.org//docs/tico/_site/internet-web-html-css/",
    "relUrl": "/internet-web-html-css/"
  },"33": {
    "doc": "5. Gestores de contenido",
    "title": "5. Gestores de contenido",
    "content": "Este capítulo aún está en construcción. ",
    "url": "https://iescelia.org//docs/tico/_site/cms/",
    "relUrl": "/cms/"
  },"34": {
    "doc": "6. Trabajo colaborativo",
    "title": "6. Trabajo colaborativo",
    "content": "Este capítulo aún está en construcción. ",
    "url": "https://iescelia.org//docs/tico/_site/trabajo-colaborativo/",
    "relUrl": "/trabajo-colaborativo/"
  },"35": {
    "doc": "7. Principios de seguridad informática",
    "title": "7. Principios de seguridad informática",
    "content": "Este capítulo aún está en construcción. ",
    "url": "https://iescelia.org//docs/tico/_site/seguridad-informatica/",
    "relUrl": "/seguridad-informatica/"
  },"36": {
    "doc": "8. Criptografía y cifrado",
    "title": "8. Criptografía y cifrado",
    "content": "Este capítulo aún está en construcción. ",
    "url": "https://iescelia.org//docs/tico/_site/criptografia/",
    "relUrl": "/criptografia/"
  },"37": {
    "doc": "9. Software malicioso",
    "title": "9. Software malicioso",
    "content": "Este capítulo aún está en construcción. ",
    "url": "https://iescelia.org//docs/tico/_site/malware/",
    "relUrl": "/malware/"
  },"38": {
    "doc": "9.2. Introducción a C",
    "title": "9.2. Introducción a C",
    "content": ". | 9.2.1. Características básicas de C | 9.2.2. Breve historia de C | 9.2.3. Sintaxis básica de C | 9.2.4. Conversiones de tipo | 9.2.5. Asignación | 9.2.6. Operadores y expresiones | 9.2.7. Estructuras de control | 9.2.8. Algoritmo principal y Subalgoritmos | 9.2.9. Entrada y salida en C | 9.2.10. Cadenas de caracteres | 9.2.11. Arrays | 9.2.12. Funciones de la librería estándar | . C es un lenguaje muy antiguo pero plenamente vigente en muchos ámbitos de la informática y diversas ingenierías. ¡C tiene más de 50 años, lo que es una auténtica burrada en informática! . Sin embargo, sigue usándose en la actualidad. Por algo será. Por un lado, C genera código máquina tan eficiente que ningún otro lenguaje puede igualarlo. Y puedes acceder directamente al hardware de tu máquina desde C, o incluso incrustar código ensamblador. Por si esto fuera poco, C (o su hermano mayor, C++, que veremos en el siguiente tema) se utiliza mucho en la actualidad en diversos ámbitos donde se necesita acceder al hardware o que los programas se ejecuten muy, muy rápido: . | Desarrollo de sistemas. Gran parte de Windows, Linux, iOS o Android están programados en C. | Desarrollo de drivers para los sistemas operativos. | Robótica y automática. | Sistemas integrados en electrodomésticos: televisores, microondas, frigoríficos, routers, etc. | Sistemas integrados en los automóviles: ABS, ESP, climatización, visualización de información en tiempo real, control de los sensores… | Aprendizaje. Con C aprenderás a programar de verdad, sin que librerías enormes o frameworks te oculten lo que pasa en las entrañas de la máquina. | . Por todas estas razones, C es un lenguaje estupendo para iniciarse en la programación, así que ¡vamos a ello! . 9.2.1. Características básicas de C . | C es un lenguaje de nivel intermedio. Tiene características de los lenguajes de alto nivel pero, al mismo tiempo, permite manipular detalles del hardware que para otros lenguajes resultan innacesibles y genera código máquina ultrarrápido. | Es imperativo y estructurado. Admite orientación a objetos (aunque entonces se llama C++). | Su tipado es estático y débil. Eso significa que hay que indicar el tipo de datos de las variables antes de usarlas y que se pueden hacer mezclas de tipos. | La sintaxis de sus estructuras de control se parece a las de Java, Javascript, PHP o Python, porque todos estos lenguajes son herederos naturales de C. | Es un lenguaje compilado, pensado para producir código máquina rápido y eficiente. Si quieres velocidad de ejecución, C es tu lenguaje. | Es altamente portable (para ser un lenguaje compilado). Existen compiladores de C para todos los sistemas y arquitecturas. Si respetas el estándar de C, no tendrás dificultad para migrar las aplicaciones a cualquier sistema. | Es un lenguaje de programación muy popular y muy veterano. Aunque se ha intentado reemplazar muchas veces, ningún lenguaje lo ha conseguido y tiene una base de programadores muy fieles. | . 9.2.2. Breve historia de C . A principios de la década de 1970, los laboratorios Bell necesitaban un nuevo sistema operativo. Hasta ese momento, la mayoría de los sistemas operativos estaban escritos en lenguaje ensamblador (muy parecido al lenguaje máquina) para que el resultado fuera un programa lo suficientemente rápido. Pero los programas escritos en ensamblador son difíciles de mantener y Bell quería que su nuevo sistema operativo se pudiera mantener y modificar con facilidad. Por lo tanto, se decidieron a inventar un lenguaje nuevo con el que programar su sistema operativo. Tras varios intentos, Brian Kerningham y Dennis Ritchie, dos ingenieros de laboratorios Bell, terminaron de diseñar el lenguaje C en un ordenador DEC PDP-11 y, con él, desarrollaron el sistema operativo Unix. El tándem C - Unix ha sido una referencia fundamental en el mundo de la programación en el último medio siglo, y C se ha convertido en uno de los lenguajes de programación más populares y longevos de la historia de la informática. C creció en popularidad muy rápidamente y sigue siendo uno de los lenguajes fundamentales tanto en el mundo educativo como en el mundo profesional. El primer estándar de C (ANSI C) no apareció hasta 1990, por lo que es posible encontrar diferentes dialectos de C ligeramente incompatibles entre sí. Una evolución de C fue el lenguaje C++ que, a parte de todas las características del ANSI C, incluye la posibilidad de orientación a objetos, una técnica de programación ligeramente diferente de la programación estructurada. Algo más tarde, en el año 2000, Microsoft patentó el lenguaje C#, otra evolución de C++ orientada al desarrollo de aplicaciones en red para la plataforma .NET de esta compañía. Otros lenguajes han sido diseñados para permitir que los no programadores puedan leer y comprender los programas y, presumiblemente, aprender a escribir los suyos propios para resolver problemas sencillos. Por el contrario, C fue creado, influenciado y probado en vivo por programadores profesionales. El resultado es que C da al programador lo que muchos programadores piden: unas pocas y bien escogidas palabras clave, una biblioteca poderosa y estandarizada, unas mínimas restricciones y un máximo control sobre lo que sucede en el interior de la máquina. Si a esto unimos que el código objeto generado por C es casi tan eficiente como el ensamblador, se entenderá por qué lleva medio siglo siendo uno de los lenguajes más populares entre los programadores profesionales. C también tiene sus detractores que lo acusan de ser confuso, críptico y demasiado flexible. En efecto, con C se pueden desarrollar las técnicas de programación estructurada, pero también se puede programar “código espagueti”. Esto, sin embargo, ocurre con todos los lenguajes: incluso los que tienen una sintaxis más estilizada y elegante, como Python o Ruby, pueden generar código absolutamente ininteligible en manos de un programador manazas. 9.2.3. Sintaxis básica de C . En este apartado vamos a aprender cómo se escriben en C las estructuras de control y el resto de instrucciones básicas. Generalidades sintácticas . Hay algunas normas básicas de la sintaxis de C que tienes que conocer: . | Los bloques de código se marcan con las llaves ( { y } ). Por ejemplo, después de una sentencia while (equivalente al mientras de pseudocódigo) hay que abrir una llave. El cuerpo de bucle comprenderá desde esa llave de apertura hasta la siguiente llave de cierre, así: | . while (condicion) { Instrucción 1 del bucle Instrucción 2 del bulce ... Instrucción N del bucle } . La llave de cierre, por tanto, sería el equivalente al FinMientras de pseudocódigo. | Todas las instrucciones terminan con un punto y coma ( ; ). Excepción: si una instrucción contiene un bloque marcado con llaves ( { … } ), se considera que esa instrucción termina al cerrar el bloque, y en ese caso no hace falta poner punto y coma. a = 10; /* La instrucción de asignación termina con ; */ while (condicion) { /* Cuerpo del bucle */ } /* El bucle termina con }, así que no necesita ; */ . | Los identificadores de variables, funciones, etc., no pueden empezar con un número ni contener espacios o símbolos especiales, salvo el de subrayado ( _ ) . a5 = 1; /* Identificador de variable válido */ 5a = 1; /* Identificador de variable NO válido */ . | Las cadenas de caracteres deben encerrarse entre comillas dobles ( “…” ). Los caracteres individuales se encierran entre comillas simples. \"Soy una cadena\"; /* Cadena de caracteres */ 'C'; /* Carácter individual */ . | El lenguaje es sensitivo a las mayúsculas. Es decir, no es lo mismo que una variable se llame edad que Edad o EDAD. | . Tipos de datos simples . C utiliza varios tipos de datos simples porque solo pueden contener un valor en cada momento (como en pseudocódigo). Los más importantes son: . | int: números enteros. Admite modificadores como long (para enteros largos) o short (para enteros cortos). Por ejemplo, el tipo int permite usar números entre –32768 a 32767, mientras que el tipo long int admite números entre –2147483648 a 2147483647. | float: número reales. El tipo double se usa para lo mismo, pero tiene más precisión y admite números mayores. | char: caracteres. | void: vacío. Se usa en funciones que no devuelven nada o que tienen una lista de parámetros vacía. | . Observa que en C no existe el tipo de dato lógico o booleano. Se utiliza en su lugar el tipo int, representando el 0 el valor falso y cualquier otra cantidad (normalmente 1) el valor verdadero. Declaración de variables . Todas las variables tienen que declararse antes de su primer uso. Esto se hace así: . int a; /* Declaración de la variable a, de tipo entero */ char b; /* Declaración de la variable b, de tipo carácter */ a = 10; /* Uso de la variable a */ b = 'z'; /* Uso de la variable b */ . Observa que, al declarar una variable, hay que especificar su tipo. Todas las variables son locales a la función o bloque de código donde estén definidas, salvo que se indique otra cosa, dejando de existir al finalizar el bloque actual. Aunque pueden crearse variables globales, su uso está tan desaconsejado que ni siquiera te voy a explicar cómo se hace. 9.2.4. Conversiones de tipo . C es un lenguaje débilmente tipado, es decir, no hace comprobaciones estrictas de tipos a la hora de asignar un valor a una variable o de comparar dos expresiones. Por ejemplo, estas instrucciones son correctas: . float a; int b; b = 5; a = b; . ¡Hemos asignado un valor entero a la variable a, que es de tipo float! . En otros lenguajes esto no está permitido, pero en C se realizan conversiones automáticas de tipo cuando en una misma expresión aparecen datos de tipos diferentes. Esto, que en principio es una ventaja, pues elimina algunas limitaciones engorrosas, otras veces es peligroso porque algunos datos pueden cambiar extrañamente de valor al hacerse esa conversión automática. La conversión puede ser de dos clases: . | Asignación de un valor a una variable que permita más precisión. Por ejemplo, asignar un número entero a una variable float. En este caso, el número se convierte a real añadiendo “.0” a la parte decimal. No hay pérdida de información. | Asignación de un valor a una variable que permita menos precisión. Por ejemplo, asignar un número long int a una variable de tipo int. En este caso, el número se recorta, perdiendo sus bits más significativos, es decir, los dígitos binarios que estén más a la izquierda. Por lo tanto, hay pérdida de información. Hay que tener mucho cuidado con este tipo de conversiones. | . Además de las conversiones automáticas de tipo, el programador puede forzar la conversión de tipos a voluntad utilizando moldes. Un molde es una expresión de un tipo de datos entre paréntesis que aparece delante de un dato. Entonces, antes de evaluar la expresión, el dato es convertido al tipo especificado en el molde. Por ejemplo: . float a; int b; a = 5; b = (float)a/2; . Sin el molde (float), la división a/2 sería entera, ya que a es una variable de tipo int, y se perdería la parte decimal. Al aplicar el molde, se convierte momentáneamente el valor entero 5 al valor real 5.0 y se evalúa la expresión, que ahora sí se realiza como división real, conservando sus decimales. 9.2.5. Asignación . La asignación de valores a variables en C es fácil de explicar: se hace con el símbolo igual (=), no con el símbolo &lt;= que usábamos en pseudocódigo: . int a; /* Declaración de la variable a */ int b = 1; /* Declaración y asignación de valor a la variable b */ a = b + 5; /* Asignación de valor a la variable a */ . Observa cómo, en la segunda instrucción, hemos declarado y asignado valor a una variable en la misma línea. 9.2.6. Operadores y expresiones . Los operadores y expresiones en C son iguales que los que hemos empleado en pseudocódigo: . | Operadores aritméticos: +, -, *, /, % (este último significa módulo de la división). | Operadores relacionales: &gt;, &lt;, &gt;=, &lt;=… | . Sin embargo, hay algunas diferencias importantes entre el pseudocódigo de PseInt y C. Son estas: . | La asignación, como ya hemos visto más arriba, se hace con el símbolo igual (=), no con &lt;=. a = 5; /* A la variable a se le asigna el valor 5 */ b = a + 1; /* A la variable b se le asigna el valor a + 1 */ . | La comparación de igualdad se hace con un doble igual (==), no con un solo igual (=). Esto es así para distinguir la comparación de la asignación. if (a == 5) { /* Comparación: ¿es a igual a 5? */ b = a + 1; /* Asignación: b toma el valor a + 1 */ } . | Existe el operador incremento (++). Se utiliza para sumar una unidad a una variable. while (i &lt; 10) { i++; /* Esto es equivalente a: i = i + 1 */ } . | También existe el operador decremento (- -), para restar una unidad a una variable. while (i &gt; 0) { i--; /* Equivalente a: i = i - 1 */ } . | Los operadores lógicos (Y, O, NO) se escriben de forma distinta: . | Y se escribe &amp;&amp;. | O se escribe ||. | NO se escribe ! (sí, sí, es una admiración). | . if (a &gt; 0) &amp;&amp; (b &gt; 0) { /* Operador Y: tienen que darse las dos condiciones a la vez */ ... } . | . Hay algunas otras diferencias, desde luego, pero con esto ya tienes para hacer un buen montón de programas. 9.2.7. Estructuras de control . Las estructuras de control en C son muy similares a las que hemos utilizado en pseudocódigo, cambiando ligeramente la notación empleada. A continuación te muestro una tabla con las más habituales y su equivalente en pseudocódigo, sin entrar en explicaciones, porque supondremos que ya sabes manejarlas. Si no recuerdas para qué servía alguna de ellas, quizá sería buena idea que le dieras un repaso al capítulo dedicado al pseudocódigo. | Instrucción | Pseudocódigo | Lenguaje C | . | Condicional simple | Si condición entonces &nbsp;&nbsp;&nbsp;acciones FinSi | if (condicion) { &nbsp;&nbsp;&nbsp;acciones } | . | Condicional doble | Si condicion entonces &nbsp;&nbsp;&nbsp;acciones SiNo &nbsp;&nbsp;&nbsp;acciones FinSi | if (condicion) { &nbsp;&nbsp;&nbsp;acciones } else { &nbsp;&nbsp;&nbsp;acciones } | . | Bucle tipo mientras | Mientras condicion hacer &nbsp;&nbsp;&nbsp;acciones FinMientras | while (condicion) { &nbsp;&nbsp;&nbsp;acciones } | . | Bucle tipo repetir | Repetir &nbsp;&nbsp;&nbsp;acciones Hasta Que condicion | do { &nbsp;&nbsp;&nbsp;acciones } while (condicion) | . | Bucle tipo para | Para variable &lt;- valor_inicial hasta valor_final con paso incremento hacer &nbsp;&nbsp;&nbsp;acciones FinPara | for (variable = valor_inicial; variable != valor_final; variable = variable + incremento) { &nbsp;&nbsp;&nbsp;acciones } | . Fíjate en que casi todo se escribe del mismo modo que en pseudocódigo con un par de diferencias notables: . | DIFERENCIA 1: En el bucle tipo repetir, la condición de salida se expresa al revés (“repetir mientras..” en lugar de “repetir hasta que…”. Lo verás mejor en este ejemplo que muestra los números del 1 al 100. Observa la condición del final del bucle: . En pseudocódigo: . i &lt;- 1 Repetir Escribir i i &lt;- i + 1 Hasta que i &gt;= 100 . En C: . i = 1; do { printf(\"%i\", i); i++; } while (i &lt; 100); . | DIFERENCIA 2: En el bucle tipo para hay que indicar la asignación a la variable que controla el bucle, la condición de salida y la forma en la que esa variable cambiará en cada iteración. Observa este ejemplo: . En pseudocódigo: . Para i &lt;- 1 hasta 10 hacer Escribir i FinPara . En C: . for (i = 1; i &lt;= 10; i = i + 1) { printf(\"%i\", i); } . Si el paso del bucle no es +1 (es decir, si la variable que controla el bucle no incrementa su valor de 1 en 1 en cada iteración), hay que indicarlo de este modo: . En pseudocódigo: . Para i &lt;- 1 hasta 10 con paso 2 hacer Escribir i FinPara . En C: . for (i = 1; i &lt;= 10; i = i + 2) { printf(\"%i\", i); } . Por último, recuerda que en C existe una abreviatura para i = i + 1, que se escribe i++, por lo que lo más habitual es encontrar los bucles de tipo para escritos así: . for (i = 1; i &lt;=10; i++) { printf(\"%i\", i); } . | . 9.2.8. Algoritmo principal y Subalgoritmos . C es un lenguaje modular hasta el extremo de que todas las líneas de código deben pertenecer a alguna función, incluyendo las instrucciones del algoritmo principal, que se escriben en una función llamada principal (main en inglés) . La función main() . La función main() contiene el algoritmo o módulo principal del programa. La ejecución de un programa siempre empieza por la primera línea de la función main(). Esta función, como todas las funciones de C, puede devolver un valor. El valor devuelto por main() debe ser de tipo entero (int). Esto se utiliza para pasar algún valor al programa que haya llamado al nuestro, que suele ser el sistema operativo. Si main() no devuelve un número entero al sistema operativo mediante una sentencia return, entonces nuestro programa devolverá un número desconocido. (Moraleja: es una buena idea incluir un return al final de la función main(). Generalmente, la devolución de un 0 indica al sistema operativo que el programa a finalizado sin problemas, mientras que cualquier otro valor señala que se ha producido algún error). Por lo tanto, la forma habitual de la función main() será: . int main(void) { ...instrucciones del algoritmo principal... return 0; } . Observa que main() no tiene argumentos, por lo que aparece el identificador void entre paréntesis en la declaración. También se pueden utilizar argumentos en main(), pero eso es algo que no trataremos de momento. Las funciones en C . La declaración de funciones se hace de forma similar a la empleada en pseudocódigo: . tipo_devuelto nombre_función (parámetros_formales) { ...instrucciones... return expresión; } . Observa que las únicas diferencias con el pseudocódigo son que no se usa la palabra “función”, que las llaves { y } sustituyen a inicio y fin, y que se emplea la palabra return en lugar de devolver. Si el tipo_devuelto es void, se considera que la función no devuelve ningún valor y que, por lo tanto, es un procedimiento. Entonces, un procedimiento en C se declara así: . void nombre_procedimiento (parámetros_formales) { ...instrucciones... } . Paso de parámetros . Los parámetros formales son, como en pseudocódigo, una lista de tipos e identificadores que se sustituirán por los parámetros actuales y se usarán como variables dentro de la función. Los parámetros se pasan normalmente por valor, pero también se pueden pasar por referencia. El paso de parámetros por referencia admite dos sitaxis ligeramente diferentes en C: anteponiendo el operador * (asterisco) al nombre del parámetro (equivalente a usar la expresión por referencia en pseudocódigo) o anteponiendo el operador &amp;. Paso de parámetros por valor . Por ejemplo, en esta función el paso de parámetros es por valor: . int funcion1 (int x, int y) { ...código de la función } . Esto quiere decir que funcion1() recibirá únicamente el valor de los dos parámetros, x e y. Podrá utilizar esos valores a lo largo de su código, e incluso podrá cambiarlos. Pero cualquier cambio en x e y no afectará a los parámetros actuales, es decir, a los parámetros del programa que llamó a funcion1(). Paso de parámetros por referencia con el operador * . En la siguiente función, el paso del parámetro “x” es por valor y el del parámetro “y”, por referencia: . int funcion2 (int x, int *y) { ...código de la función } . En este caso, cada vez que se vaya a usar el parámetro “y” dentro del código de la función, será necesario acompañarlo del asterisco. Por ejemplo: . *y = 5; x = 17 + *y; . (Hay algunas excepciones a esta regla, pero ahora no vienen a cuento). En la llamada a la función hay que indicar explícitamente qué parámetro se está pasando por referencia utilizando el operador &amp;. Por lo tanto, para llamar a funcion2() con los parámetros a y b habrá que escribir: . resultado = funcion2 (a, &amp;b); . Observa que el segundo parámetro (el que se pasa por referencia), lleva delante el operador &amp;. Si dentro de la función se cambia el valor de y, también cambiará el valor de b fuera de la función, ya que ambas variables han quedado ligadas por el paso por referencia. En cambio, las variables x y a son independientes. (Si todo esto te suena a chino, repásate el apartado dedicado al paso de parámetros en el tema de introducción a la programación en pseudocódigo, donde se explicaba con más detalle). Paso de parámetros por referencia con el operador &amp; . Otra forma de pasar un parámetro por referencia es usar el operador &amp; en los parámetros formales, así: . int funcion3 (int x, int &amp;y) { ...código de la función } . En esta función, el parámetro x se pasa por valor y el parámetro y se pasa por referencia. Utilizando esta sintaxis no es necesario añadir asteriscos cada vez que se usa la y en el cuerpo de la función, ni tampoco usar “&amp;” en la llamada a la función. Esta tercera forma de paso por referencia no es estándar en C, sino que es propia de C++, por lo que evitaremos utilizarla de momento. Juntándolo todo en un ejemplo . En el siguiente ejemplo se ilustran los dos tipos de paso de parámetros y, en el paso por referencia, las dos sintaxis alternativas de que dispone C. El ejemplo muestra tres funciones muy similares que reciben dos parámetros, a y b. Las tres intentan intercambiar el valor de a y b mediante una tercera variable llamada tmp. Sin embargo, en la primera de ellas el intercambio no tiene ningún efecto en el programa main(), ya que los parámetros están pasados por valor. En las otras dos funciones sí que se consigue el intercambio, ya que los parámetros está pasados por referencia. No te preocupes si no entiendes toda la sintaxis de este ejemplo. Lo interesante ahora es que veas cuál es la forma correcta de escribir cada tipo de paso de parámetros. #include &lt;stdio.h&gt; // Paso de parámetros por valor. // En este ejemplo, esta función no tendrá el efecto deseado, porque las variables // del programa principal no se verán afectadas. void intercambiar1(int a, int b) { int tmp = a; a = b; b = tmp; } // Paso de parámetros por referencia, sintaxis 1. // Esta función sí que consigue intercambiar los valores de las variables // del programa principal. void intercambiar2(int *a, int *b) { int tmp = *a; *a = *b; *b = tmp; } // Paso de parámetros por referencia, sintaxis 2. // Esta función también consigue su objetivo. A todos los efectos, // es idéntica a la función anterior. void intercambiar3(int &amp;a, int &amp;b) { int tmp = a; a = b; b = tmp; } // Programa principal int main() { int dato1 = 30, dato2 = 90; printf(\"Antes de la llamada a las funcioens: dato1 = %i, dato2 = %i\\n\", dato1, dato2); intercambiar1(dato1, dato2); printf(\"Después de intercambiar1: dato1 = %i, dato2 = %i\\n\", dato1, dato2); intercambiar2(&amp;dato1, &amp;dato2); printf(\"Después de intercambiar2: dato1 = %i, dato2 = %i\\n\", dato1, dato2); intercambiar3(dato1, dato2); printf(\"Después de intercambiar3: dato1 = %i, dato2 = %i\\n\", dato1, dato2); return 0; } . Prototipos de funciones . En C no es necesario escribir las funciones (subalgoritmos) antes de su primera invocación. El mecanismo de compilación y enlace de C permite, de hecho, que las funciones puedan estar físicamente en un archivo distinto del lugar desde el que se invocan. En la práctica, esto plantea un problema: C no tiene forma de saber si la llamada a una función se hace correctamente, es decir, si se le pasan los argumentos debidos y con el tipo correcto, ni si el resutado devuelto es asignado a una variable del tipo adecuado. Para conseguir que C realice esas comprobaciones durante la compilación se utilizan los prototipos de función. Un prototipo de función es, simplemente, la declaración de una función. Es decir, la primera línea del código la función. El prototipo debe aparecer antes de que la función se invoque por primera vez, aunque el código completo de la función esté en otra parte. Los prototipos permiten al compilador comprobar que los argumentos de la función coinciden en tipo y número con los de la invocación de la misma, y que el tipo devuelto es el correcto. Los prototipos suelen aparecer al principio del programa, antes de la función main(). Observa, en el siguiente ejemplo, que el prototipo de la función calcular_area() se coloca delante de main(). Sin embargo, el código concreto de esta función no aparece hasta después (incluso podría estar situado en otro archivo diferente): . float calcular_area (float base, float altura); // Prototipo de la función int main() // Algoritmo principal { ...instrucciones... area = calcular_area (x,y); ...más instrucciones... return 0; } float calcular_area(float base, float altura) // Código de la función (podría estar incluso en otro archivo) { ... instrucciones... } . Cuando se vayan a usar funciones de librería, como fabs() (valor absoluto), sqrt() (raíz cuadrada) o cualquier otra, hay que escribir sus prototipos antes de la función main(). Sin embargo, como estas funciones no las hemos escrito nosotros, desconocemos cuales son sus prototipos. En C se soluciona este problema con los archivos de cabecera, que son archivos que incluyen en su interior los prototipos de las funciones, entre otras cosas. Hay muchos archivos de cabecera en la librería estándar de C. Por ejemplo, el archivo math.h tiene los prototipos de todas las funciones matemáticas. Todos los archivos de cabecera tienen la extensión .h en su nombre (h de “header”). Para incluir un archivo de cabecera en nuestro programa se utiliza #include, que no es exactamente una instrucción de C, sino una directiva de compilación. Ya hemos visto otra directiva de compilación: #define, que usábamos para definir constantes. Las directivas de compilación indican al compilador cómo se debe comportar y, aunque estrictamente hablando no son instrucciones de C, para nosotros es como si lo fueran. Por ejemplo, esta línea de código sirve para incluir todos los prototipos de las funciones de librería matemática en nuestro programa: . #include &lt;math.h&gt; . 9.2.9. Entrada y salida en C . La entrada y salida de datos en C, es decir, la traducción de las instrucciones leer() y escribir() de pseudocódigo, es uno de los aspectos más difíciles de C para los principiantes. El estándar ANSI C dispone de muchas funciones para hacer las entradas y salidas de datos. En concreto, dispone de un subconjunto de ellas para hacer la entrada y salida por consola, es decir, por teclado y pantalla. Podemos clasificar estas funciones de E/S en dos grupos: . | Funciones de E/S simples: getchar(), putchar(), gets(), puts() | Funciones de E/S con formato: printf(), scanf() | . Las más utilizadas y versátiles son sin duda las segundas, así que nos detendremos en ellas. Salida de datos con printf() . La función printf() (de “print” = imprimir y “f” = formato) sirve para escribir datos en el dispositivo de salida estándar (generalmente la pantalla) con un formato determinado por el programador. La forma general de utilizarla es la siguiente: . printf(cadena_de_formato, datos); . El prototipo de printf() se encuentra en el archivo de cabecera &lt;stdio.h&gt; (de “std” = standard e “io” = input/output, es decir, “stdio” es un acrónimo de “entrada/salida estándar”). El primer argumento, la cadena_de_formato, especifica el modo en el que se deben mostrar los datos que aparecen a continuación. Esta cadena se compone de una serie de códigos de formato que indican a C qué tipo de datos son los que se desean imprimir. Todos los códigos están precedidos del símbolo de porcentaje (“%”). Por ejemplo, el código “%i” indica a la función que se desea escribir un número de tipo int, y el código “%f”, que se desea escribir un número real de tipo float. La forma más simple de utilizar printf() es: . int a; a = 5; printf(\"%i\", a); . Esto escribirá el valor de la variable entera a en la pantalla, es decir, 5. Fíjate que el primer argumento de printf() es una cadena (y, por lo tanto, se escribe entre comillas) cuyo contenido es el código del tipo de dato que se pretende escribir. El segundo argumento es el dato mismo. En una sola instrucción printf() pueden escribirse varios datos. Por ejemplo: . int a; float x; a = 5; x = 10.33; printf(\"%i%f\", a, x); . Observa detenidamente la cadena de formato: primero aparece “%i” y luego “%f”. Esto indica que el primer dato que debe imprimirse es un entero, y el segundo, un real. Después, aparecen esos datos separados por comas y exactamente en el mismo orden que en la cadena de formato: primero la variable entera y luego la variable real. El resultado será que en la pantalla se escribirán los números 5 y 10.33. Algunos de los códigos de formato que se pueden utilizar en printf() son: . | %c: para imprimir caracteres individuales. | %i o %d: para imprimir números enteros. | %u: para imprimir números enteros sin signo. | %f: para imprimir números reales. | %e: para imprimir números reales en notación científica. | %s: para imprimir cadenas de caracteres (strings). | %o y %x: para imprimir números en octal y en hexadecimal, respectivamente. | . Algunos de estos código admiten modificadores. Los más habituales son: . | Los códigos numéricos como “%i” o “%f” permiten insertar modificadores de longitud como “l” (longitud doble) o “h” (longitud corta). Así, por ejemplo, “%ld” indica que se va a imprimir un entero de longitud doble (long int); “%hu” sirve para enteros cortos sin signo (unsigned short int); “%lf” indica que se imprimirá un número real de longitud doble (double), etc. | El código “%f” (números reales) se pueden usar con un modificador de posiciones decimales que se desean mostrar. Por ejemplo, con “%3.4f” obligamos a que se impriman tres dígitos a la izquierda de la coma decimal y cuatro a la derecha. La escritura se justifica a la derecha. Para justificarla a la izquierda se utiliza el modificador “-“, de esta forma: “%-10.4f”. | El código “%s” (cadenas de caracteres) se puede combinar con un especificador de longitud máxima y mínima de la cadena. Por ejemplo, “%4.8s” escribe una cadena de al menos cuatro caracteres y no más de ocho. Si la cadena tiene más, se pierden los que excedan de ocho. También se puede utilizar el modificador “-“ para alinear el texto a la izquierda. | . Además de los códigos de formato, en la cadena de formato puede aparecer cualquier texto entremezclado con los códigos. A la hora de escribir en la pantalla, los códigos serán sustituidos por los datos correspondientes. Por ejemplo: . int a; float x; a = 5; x = 10.33; printf(\"El número entero es %i y el real es %f\", a, x); . Lo que aparecerá en la pantalla al ejecutar este fragmento de código será: . El número entero es 5 y el real es 10.33 . Una última observación sobre printf(): hay ciertos caracteres que no son directamente imprimibles desde el teclado. Uno de ellos es el salto de línea. Para poder ordenar a printf() que escriba un salto de línea (o cualquier otro carácter no imprimible) se utilizan los códigos de barra invertida, que con códigos especiales precedidos del carácter “\". En concreto, el carácter “salto de línea” se indica con el código “\\n”. Observa las diferencias entre estos dos bloques de instrucciones para intentar comprender la importancia del salto de línea: . int a; a = 5; printf(\"La variable a vale %i\", a); a = 14; printf(\"La variable a vale %i\", a); . El resultado en la pantalla de la ejecución de estas instrucciones es: . La variable a vale 5La variable a vale 14 . Veamos el mismo ejemplo usando el código del salto de línea (\\n): . int a; a = 5; printf(\"La variable a vale %i\\n\", a); a = 14; printf(\"La variable a vale %i\", a); . El resultado en la pantalla será: . La variable a vale 5 La variable a vale 14 . Entrada de datos con scanf() . La función scanf() es, en muchos sentidos, la inversa de printf(). Puede leer desde el dispositivo de entrada estándar (normalmente el teclado) datos de cualquier tipo de los manejados por el compilador, convirtiéndolos al formato interno apropiado. Funciona de manera análoga a printf(), por lo que su sintaxis es: . scanf(cadena_de_formato, datos); . El prototipo de scanf() se encuentra en el archivo de cabecera &lt;stdio.h&gt;, como printf(). La cadena_de_formato tiene la misma composición que la de printf(). Los datos son las variables donde se desea almacenar el dato o datos leidos desde el teclado. ¡Cuidado! Con los tipos simples, es necesario utilizar el operador &amp; delante del nombre de la variable, porque esa variable se pasa por referencia a scanf() para que ésta pueda modificarla. Por ejemplo: . int a, b; float x; char s[100]; printf(\"Escribe un número entero:\"); scanf(\"%d\", &amp;a); printf(\"Ahora escribe un número entero y un número real:\"); scanf(\"%d%f\", &amp;b, &amp;x); printf(\"Escribe una cadena:\"); scanf(\"%s\", s); . La función scanf() tiene alguna otra funcionalidad añadida para el manejo de cadenas de caracteres que ya veremos en su momento. Ejemplo de uso de scanf() y printf() . Debido a la relativa complejidad de estas funciones de entrada y salida, vamos a presentar un pequeño ejemplo de traducción de pseudocódigo a C. Se trata de un algoritmo que lee dos números enteros, A y B. Si A es mayor que B los resta, y en otro caso los suma. Observa detenidamente la correspondencia entre cada pareja de instrucciones, especialmente las de entrada y salida. Pseudocódigo: . algoritmo suma_y_resta definir a, b como entero escribir \"Introduzca dos números enteros\"; leer a leer b si a &lt; b entonces escribir \"La suma de a y b es:\", a+b sino escribir \"La resta de a menos b es:\", a–b finAlgoritmo . Lenguaje C: . /* Programa suma y resta */ #include stdio.h int main() { int a, b; printf (\"Introduzca dos números enteros\\n\"); scanf(\"%d%d\", &amp;a, &amp;b); if (a &lt; b) printf(\"La suma de %d y %d es: %d\", a, b, a+b); else printf(\"La resta de %d menos %d es: %d\", a, b, a–b); return 0; } . Funciones para E/S simple por consola . Técnicamente, con printf() y scanf() es posible escribir y leer cualquier tipo de datos desde cualquier dispositivo de salida o entrada, no solo la pantalla y el teclado. En la práctica, aunque printf() resulta bastante efectiva y versátil, scanf() puede darte muchos dolores de cabeza. Para hacerte una idea, sólo tienes que probar a hacer un scanf() de un número entero e inmediatamente después otro scanf() de una cadena de caracteres. El segundo scanf() fallará. La razón es bastante rocambolesca: el flujo de entrada no consumirá el carácter de retorno de carro al leer el número entero, por lo que dicho carácter se adjudicará al segundo scanf() automáticamente. Por suerte, existe otro grupo de funciones en ANSI C específicamente diseñadas para hacer la E/S por consola, es decir, por teclado y pantalla, de manera más simple. Las resumimos en el siguiente cuadro. Los prototipos de estas funciones, como el de scanf(), se encuentran en el archivo de cabecera stdio.h, así que tendrás que incluirlo en tu código para poder usarlas. | getchar(): Espera a que se pulse una tecla seguida de INTRO y devuelve su valor. Muestra el eco en la pantalla, es decir, la tecla pulsada aparece en la pantalla. char car; car = getchar(); printf(\"Tecla pulsada:\\n\"); . | putchar(c): Escribe el carácter c en la pantalla. | gets(cadena): Lee del teclado una cadena de caracteres seguida de INTRO. char cadena[50]; gets(cadena); printf(\"Cadena tecleada:\\n\"); puts(cadena); . | puts(cadena): Escribe una cadena de caracteres en la pantalla (ver ejemplo anterior). | . Por lo tanto, para evitar los problemas que a menudo causa scanf(), podemos recurrir a gets() para leer las cadenas de caracteres. Si necesitamos leer un número, podemos usar gets() y luego convertir la cadena a un tipo de dato numérico con las funciones de conversión atoi() y atof(), como se muestra en el siguiente ejemplo: . char cadena[50]; int a; float x; gets(cadena); // Leemos una cadena de caracteres a = atoi(cadena); // Convertimos la cadena en un número entero x = atof(cadena); // Convertimos la cadena en un número real . Las funciones de conversión atoi() y atof() tratarán de convertir la cadena en un número, si ello es posible (es decir, si la cadena realmente contiene números). Pero cuidado: si se teclean más caracteres de los que caben en la cadena, el resultado es imprevisible (a menudo el programa fallará durante la ejecución). Esto puede solucionarse utilizando fgets() en lugar de gets(), que es una función más compleja y no vamos a explicar aquí. Puedes buscar información en internet si te interesa el tema. Tal vez pienses que resulta demasiado complicado hacer algo muy simple como una entrada de datos por teclado. Tienes razón. Pero ten en cuenta dos cosas: las entradas de datos nunca son simples (son el punto donde el usuario interacciona con más libertad con el programa, y los usuarios humanos tendemos a hacer cosas impredecibles y complicadas), y C es un lenguaje de nivel intermedio más que de alto nivel, por lo que muchas tareas de alto nivel, simplemente, no las resolverá por nosotros. En ese sentido, C requiere del programador prestar atención a ciertos detalles que podría obviar en otros lenguajes. 9.2.10. Cadenas de caracteres . Las cadenas de caracteres en C son, en realidad, arrays de caracteres. Aunque veremos los arrays en el próximo apartado, si ya sabes pseudocódigo quizá no te sorprenda saber que una cadena se declara así: . char cadena[50]; /* Declaración de una cadena de 50 caracteres */ . La cadenas tienen ciertas peculiaridades que comentaremos en este apartado, pero todo lo que digamos en el siguiente sobre arrays también será aplicable a las cadenas. Declaración y manipulación de cadenas . Las cadenas pueden manipularse elemento por elemento, como cualquier array. Por ejemplo: . char cadena[50]; cadena[0] = 'H'; cadena[1] = 'o'; cadena[2] = 'l'; cadena[3] = 'a'; . Las cadenas deben tener, después de su último carácter válido, un carácter especial llamado nulo. Este carácter marca el final de la cadena. El carácter nulo se simboliza con el código \\0. Por lo tanto, en el ejemplo anterior habría que agregar la siguiente línea para que la cadena estuviera completa: . cadena[4] = '\\0'; . Todas las cadenas deben terminar en un carácter nulo. De lo contrario, podemos tener problemas al imprimirlas en la pantalla o al realizar con ellas cualquier otro proceso. En consecuencia, en una cadena definida como la anterior, de 50 caracteres, en realidad sólo tienen cabida 49, ya que siempre hay que reservar una posición para el carácter nulo. La declaración de una cadena puede ir acompañada de una inicialización mediante una constante. En este caso, la constante debe ir encerrada entre comillas dobles, al tratarse de una cadena y no de caracteres sueltos. Por ejemplo: . char cadena[50] = \"Hola\"; . En inicializaciones de este tipo, el compilador se encarga de añadir el carácter nulo. Por último, señalemos que no es necesario indicar el tamaño de la cadena si se inicializa al mismo tiempo que se declara. Por ejemplo, la declaración anterior puede sustituirse por esta otra: . char cadena[] = \"Hola\"; . Esto se denomina array de longitud indeterminada. El compilador, al encontrar una declaración así, crea una cadena del tamaño suficiente para contener todos los caracteres. Esto vale no sólo para las cadenas, sino que también es aplicable a cualquier otro tipo de array que se inicialice al mismo tiempo que se declare. Funciones para manejo de cadenas . La mayor parte de las veces las cadenas son manipuladas mediante el uso de funciones de librería específicas. En este apartado comentaremos las más comunes. Funciones de lectura y escritura . Para leer por teclado una cadena de caracteres se puede utilizar también la función scanf() con la cadena de formato “%s”. Como las cadenas son arrays, no es preciso anteponer el símbolo &amp; al nombre de la variable. Sin embargo, es preferible emplear la función gets() por estar específicamente diseñada para la lectura de cadenas. Por ejemplo: . char cadena[50]; printf(\"Introduzca su nombre \"); gets(cadena); . Tanto scanf() como gets() insertan automáticamente el carácter “\\0” al final de la cadena. De manera análoga podemos emplear la función printf() para escribir el contenido de una cadena en la pantalla, pero preferiremos la función puts(), específica de las cadenas. Por ejemplo: . char cadena[50] = \"Hola, mundo\"; puts(cadena); . Funciones de tratamiento de cadenas . Las funciones de librería ANSI C para manejar cadenas suelen empezar por las letras “str” (de “string”, que significa “cadena” en inglés) y utilizan el archivo de cabecera string.h. Entre las funciones más habituales encontramos las siguientes: . | strcpy(): Copia el contenido de una cadena en otra, incluyendo el carácter nulo. Su sintaxis es: . El siguiente ejemplo es otra versión (artificialmente enrevesada) del “hola, mundo”: . char cad1[50]; char cad2[50] = \"Hola\"; strcpy(cad1, cad2); strcpy(cad2, \"mundo\"); printf(\"%s, %s\", cad1, cad2); . | strlen(): Devuelve la longitud de una cadena, es decir, el número de caracteres de que consta, sin contar el carácter nulo. Por ejemplo, en este fragmento de código el resultado debe ser 11. Fíjate que la variable cadena tiene una longitud total de 50 caracteres, pero strlen() sólo cuenta los que efectivamente se están usando, es decir, los que hay hasta el carácter nulo: . char cadena[50] = \"Hola, mundo\"; int longitud; longitud = strlen(cadena); printf(\"La longitud es %i\", longitud); . | strcmp(): Compara dos cadenas. Devuelve el valor 0 si son iguales, un valor mayor que 0 si la primera es alfabéticamente mayor que la segunda, o un valor menor que 0 en caso contrario. Por ejemplo: . char cad1[50], cad2[50]; int comparacion; printf(\"Introduzca dos cadenas\"); scanf(\"%s %s\", cad1, cad2); comparacion = strcmp(cad1, cad2); if (comparacion == 0) printf(\"Las dos cadenas son iguales\"); . | strcat(): Concatena dos cadenas. Esta función añade la cadena2 al final de la cadena1, incluyendo el carácter nulo. El resultado del siguiente ejemplo debe ser, otra vez, “hola, mundo”: . char cad1[50] = \"Hola, \"; char cad2[50] = \"mundo\"; strcat(cad1, cad2); prinft(\"%s\", cad1); . | . Las cadenas y la validación de los datos de entrada . Una de las principales fuentes de error de los programas son los datos de entrada incorrectos. Por ejemplo, si un programa está preparado para leer un número entero pero el usuario, por error o por mala fe, introduce un carácter, la función scanf() fallará y el programa se detendrá. En otros lenguajes de más alto nivel, el propio lenguaje tiene mecanismos para prevenir estos errores. Pero recuerda que C es un lenguaje de nivel intermedio, pensado para producir código máquina supereficiente y rápido. El precio a pagar por ello es que el lenguaje no hará ninguna comprobación de este tipo de errores: es responsabilidad del programador preverlos. Hay un modo bastante sencillo de hacer esto: leer todos los datos de entrada como cadenas y, luego, convertirlos al tipo de dato adecuado. Observa el siguiente ejemplo. Sirve para leer un número entero por teclado, pero previniendo los errores provocados por el usuario que antes mencionábamos. Se utiliza la función atoi(), que convierte una cadena a un número entero: . int n; // El número entero que se pretende leer por teclado char cad[50]; // La cadena que se usará para prevenir errores de lectura printf(\"Introduzca un número entero\"); gets(cad); // No se lee un número entero, sino una cadena n = atoi(cad); // Se convierte la cadena a entero . 9.2.11. Arrays . Un array, como ya vimos en pseudocódigo, es una agrupación de muchos datos individuales del mismo tipo bajo el mismo nombre. Cada dato individual de un array es accesible mediante un índice. El caso más simple de array es el array unidimensional. Por ejemplo, un array unidimensional de números enteros es una colección de muchos números enteros a los que les adjudicamos un único identificador. Declaración de arrays . La declaración de un array en C se hace así: . tipo_de_datos nombre_array[número_de_elementos]; . Por ejemplo: . int serie[10]; . La variable serie será un array que contendrá 10 números enteros. Los 10 números reciben el mismo nombre, es decir, serie. Se puede acceder a cada uno de los números que forman el array escribiendo a continuación del nombre un número entre corchetes. Ese número se denomina índice. Lo puedes ver en el siguiente ejemplo: . int serie[10]; serie[2] = 20; serie[3] = 15; serie[4] = serie[2] + serie[3]; printf(\"%i\", serie[4]); . El array serie puede almacenar hasta 10 números enteros. Las posiciones empiezan a numerarse en el 0, así que serie[2] se refiere, en realidad, a la tercera posición. En ella se almacena el número 20. En la cuarta posición (serie[3]) se almacena el número 15. Luego se suman ambos valores, y el resultado se almacena en la quinta posición (serie[4]). Finalmente, se imprime en la pantalla el resultado de la suma, es decir, 35. +------------+----+----+----+----+----+ | Posiciones | 0 | 1 | 2 | 3 | 4 | serie = +------------+----+----+----+----+----+ | Valores | ? | ? | 20 | 15 | 35 | +------------+----+----+----+----+----+ . C no realiza comprobación de los índices de los arrays, por lo que es perfectamente posible utilizar un índice fuera del rango válido (por ejemplo, serie[17]). Es responsabilidad del programador evitar que esto ocurra, porque los efectos serán desastrosos para el programa. Como es lógico, se pueden construir arrays cuyos elementos sean de cualquier otro tipo simple, como float o double, con la única restricción de que todos los elementos sean del mismo tipo. Los arrays de caracteres se denominan cadenas de caracteres, y ya hablamos de ellos en el apartado anterior. También es posible construir arrays cuyos elementos sean de un tipo complejo. Así, podemos tener arrays de arrays o de otros tipos que no vamos a estudiar en este curso de introducción. Manipulación de los elementos individuales de un array . Los arrays en C deben manipularse elemento a elemento. No se pueden modificar todos los elementos a la vez. Para asignar valores a los elementos de un array, por lo tanto, el mecanismo es este: . int serie[5]; serie[0] = 5; serie[1] = 3; serie[2] = 7; ...etc... La inicialización de los valores de un array también puede hacerse conjuntamente en el momento de declararlo, así: . int serie[5] = {5, 3, 7, 9, 14}; . El resultado de esta declaración será un array de 5 elementos de tipo entero a los que se les asigna los valores 5, 3, 7, 9 y 14. Cada elemento del array es, a todos los efectos, una variable que puede usarse independientemente de los demás elementos. Así, por ejemplo, un elemento del array serie puede usarse en una instrucción de salida igual que cualquier variable simple de tipo int: . int serie[5]; serie[0] = 21; printf(\"%i\", serie[0]); . Del mismo modo, pueden usarse elementos de array en una instrucción de entrada. Por ejemplo: . int serie[5]; scanf(\"%i\", &amp;serie[0]); serie[1] = serie[0] + 15; printf(\"%i\", serie[1]); . Recorrido de un array . Una forma habitual de manipular un array es acceder secuencialmente a todos sus elementos, uno tras otro. Para ello, se utiliza un bucle con contador, de modo que la variable contador nos sirve como índice para acceder a cada uno de los elementos del array. Supongamos, por ejemplo, que tenemos un array de 10 números enteros declarado como int v[10] y una variable entera declarada como int i. Por medio de un bucle, con ligeras modificaciones, podemos realizar todas estas operaciones: . 1) Inicializar todos los elementos a un valor cualquiera (por ejemplo, 0): . for (i = 0; i &lt;= 9; i++) { v[i] = 0; } . 2) Inicializar todos los elementos con valores introducidos por teclado: . for (i = 0; i &lt;= 9; i++) { printf(\"Escribe el valor del elemento nº %i: \", i); scanf(\"%i\", &amp;v[i]); } . 3) Mostrar todos los elementos en la pantalla: . for (i = 0; i &lt;= 9; i++) { printf(\"El elemento nº %i vale %i\\n\", i, v[i]); } . 4) Realizar alguna operación que implique a todos los elementos. Por ejemplo, sumarlos: . suma = 0; for (i = 0; i &lt;= 9; i++) { suma = suma + v[i]; } . Arrays y funciones . Para pasar un array como argumento a una función, en la llamada a la función se escribe simplemente el nombre del array, sin índices. Los arrays en C siempre se pasan por referencia, nunca por valor. Por lo tanto, si algún elemento del array se modifica en una función, también será modificado en la función desde la que fue invocada. Como siempre se pasan por referencia, no es necesario utilizar el símbolo &amp; delante del parámetro. Por ejemplo, supongamos que serie es un array de 15 números enteros. Para pasarlo como parámetro a una función llamada funcion1() escribiríamos simplemente esto: . int serie[15]; funcion1(serie); . En cuanto a la declaración de la función, el parámetro de tipo array se especifica esta maneras: . void funcion1 (int serie[15]) { ...código de la función... } . Dentro de la función, el array serie puede usarse del mismo modo que en el programa que la llama, es decir, no es preciso utilizar el operador asterisco ni nada por el estilo. Un programa de ejemplo que usa arrays y funciones . Para ilustrar todo esto, te muestro programa que sirve para leer 50 números por teclado y calcular la suma, la media y la desviación típica de todos los valores. Lee el código detenidamente, prestando sobre todo atención al uso de los arrays y a cómo se pasan como parámetros. Los números de la serie se almacenarán en un array de tipo float de 50 posiciones llamado valores. La introducción de datos en el array se hace en la función introducir_valores(). Como los arrays siempre se pasan por referencia, al modificar el array valores dentro de la función, también se modificará en el algoritmo principal. Después, se llama a 3 funciones que calculan las tres magnitudes (suma, media y desviación). El array también se pasa por referencia a estas funciones, ya que en C no hay modo de pasar un array por valor. #include &lt;stdio.h&gt; #include &lt;math.h&gt; int main(void) { float valores[50]; float suma, media, desviacion; introducir_valores(valores); suma = calcular_suma(valores); media = calcular_media(valores, suma); desviacion = calcular_desviacion(valores, media); printf(\"La suma es %f, la media es %f y la desviación es %f\", suma, media, desviacion); return 0; } /* Lee 50 números y los almacena en el array N pasado por referencia */ void introducir_valores(float n[50]) { int i; for (i=1; i&lt;=49; i++) { printf(\"Introduzca el valor nº %d: \", i); scanf(\"%f\", &amp;n[i]); } } /* Devuelve la suma todos los elementos del array n */ float calcular_suma(float n[50]) { int i; float suma; suma = 0; for (i=1; i&lt;=49; i++) suma = suma + n[i]; return suma; } /* Devuelve el valor medio de los elementos del array n. Necesita conocer la suma de los elementos para calcular la media */ float calcular_media(float n[50], float suma) { int i; float media; media = suma / 50; return media; } /* Calcula la desviación típica de los elementos del array n. Necesita conocer la media para hacer los cálculos */ float calcular_desviacion(float n[50], float media) { int i; float diferencias; diferencias = 0; for (i=1; i&lt;=49; i++) diferencias = diferencias + abs(n[i] – media) ; diferencias = diferencias / 50; return diferencias; } . 9.2.12. Funciones de la librería estándar . La siguiente lista resume algunas funciones de uso frecuente de ANSI C. Para cada función se muestra su prototipo y se explica brevemente cuál es su cometido y cuáles sus datos de entrada y salida. También se indica el archivo de cabecera donde se encuentra el prototipo. Debes tener en cuenta que ANSI C dispone de muchas otras funciones. Si en algún momento las necesitas, una búsqueda rápida por internet te proporcionará información de sobra. Eso sí, asegúrate que la función que vayas a usar pertenezca al estándar ANSI C. Solo así tendrás la garantía de que tu compilador la reconocerá y de que tu programa será portable a otros sistemas. Funciones de entrada/salida . | Función | Prototipo | Utilidad | Archivo de cabecera | . | getchar() | int getchar(void) | Devuelve un carácter leido por teclado mostrando el eco. Es necesario pulsar INTRO | stdio.h | . | gets() | char* gets(char* cadena) | Lee una cadena de caracteres del dispositivo estándar de entrada y la sitúa en la posición apuntada por cadena | stdio.h | . | printf() | int printf(const char* formato, lista_argumentos) | Salida estándar con formato. Véase el texto del capítulo para más detalles | stdio.h | . | putchar() | int putchar(int carácter) | Escribe carácter en la pantalla | stdio.h | . | puts() | int puts(const char* cadena) | Escribe cadena en el dispositivo estándar de salidastdio.h |   | . | scanf() | int scanf(const char* formato, lista_argumentos) | Entrada estándar con formato. Véase el texto del capítulo para más detalles | stdio.h | . Funciones de caracteres . | Función | Prototipo | Utilidad | Archivo de cabecera | . | isalnum() | int isalnum(int carácter) | Devuelve 1 si el carácter es alfanumérico (letra o número), o 0 si no lo es | ctype.h | . | isalpha() | int isalpha(int carácter) | Devuelve 1 si el carácter es alfabético (una letra mayúscula o minúscula), o 0 si no lo es | ctype.h | . | isdigit() | int isdigit(int carácter) | Devuelve 1 si el carácter es numérico, o 0 si no lo es | ctype.h | . | isupper() e islower() | int isupper(int carácter); int islower(int carácter); | La primera devuelve 1 si el carácter es una letra mayúscula y 0 en otro caso. La segunda, al revés | ctype.h | . Funciones matemáticas . | Función | Prototipo | Utilidad | Archivo de cabecera | . | abs() | int abs(int número) | Devuelve el valor absoluto de número | stdlib.h | . | cos()sin()tan()acos()asin()atan() | double acos(double argumento) | Todas tienen un prototipo similar. Calculan y devuelven, respectivamente, el arcocoseno, el arcoseno, el arcotangente, el coseno, el seno y la tangente de argumento. Los ángulos se expresan en radianes | math.h | . | ceil() | double ceil(double número) | Redondea número por exceso. P. ej: ceil(3.2) devuelve 4 | math.h | . | exp() | double exp(double potencia) | Calcula el exponencial epotencia | math.h | . | fabs() | double fabs(double número) | Devuelve el valor absoluto de número | math.h | . | floor() | double floor(double número) | Redondea número por defecto. P. ej: floor(3.8) devuelve 3 | math.h | . | log() | double log(double número) | Devuelve el logaritmo natural de número | math.h | . | log10() | double log10(double número) | Devuelve el logaritmo decimal de número | math.h | . | pow() | double log(double base, double exp) | Devuelve la potencia de base elevado a exp | math.h | . | sqrt() | double sqrt(double número) | Devuelve la raiz cuadrada de número | math.h | . Funciones variadas . | Función | Prototipo | Utilidad | Archivo de cabecera | . | atof() | double atof(char* cadena) | Convierte la cadena en un número real. Si la cadena no contiene un número real válido, devuelve 0 | stdlib.h | . | atoi() | int atoi(char* cadena) | Convierte la cadena en un número entero. Si la cadena no contiene un número entero válido, devuelve 0 | stdlib.h | . | atof() | double atof(char* cadena) | Convierte la cadena en un número real. Si la cadena no contiene un número real válido, devuelve 0 | stdlib.h | . | itoa() | char* itoa(int número, int base) | Convierte el número en una cadena. La base de la cadena resultante se determina en base | stdlib.h | . | rand() | int rand(void) | Devuelve un número entero al azar entre 0 y RAND_MAX (RAND_MAX es una constante definida en stdlib.h) | stdlib.h | . | randomize() | void randomize(void) | Inicializa el generador de números aleatorio. Es necesario invocar esta función si después se va a usar random() | stdlib.h | . | random() | int random(int máximo) | Devuelve un número al azar entre 0 y máximo – 1 | stdlib.h | . ",
    "url": "https://iescelia.org//docs/tico/_site/introduccion-a-c/",
    "relUrl": "/introduccion-a-c/"
  },"39": {
    "doc": "9.3. Escribiendo programas en C",
    "title": "9.3. Escribiendo programas en C",
    "content": ". | 9.3.1. Estructura de un programa en C | 9.3.2. Compilar y ejecutar un programa sencillo desde la consola: gcc/g++ | 9.3.3. Compilar y ejecutar un programa no tan sencillo desde la consola: make | 9.3.4. Compilar y ejecutar un programa con un IDE: Visual Studio Code con Code Runner | 9.3.5. Flujo de trabajo habitual | . Ya conocemos cómo se manejan los principales elementos de un programa con C: variables, instrucciones de control, asignaciones, funciones, etc. Ahora nos queda saber cómo juntamos todo eso para escribir nuestros programas, ¿no te parece? . 9.3.1. Estructura de un programa en C . Ya estamos en condiciones de echar un vistazo a cual será el aspecto de (casi) todos los programas que escribamos en C. Los programas escritos en C suelen guardarse en dos tipos de archivo: . | Archivos con extensión .c. Estos archivos contienen el grueso del código fuente. | Archivos con extensión .h. Estos archivos contienen los prototipos de funciones y otras definiciones necesarias para que el programa funcione bien. Al principio, no escribirás ningún archivo de este tipo, pero sí que tendrás que incluir (con #include) muchos de ellos. | . Todo programa C, desde el más pequeño hasta el más complejo, tiene un programa principal ubicado en la función main(), que debe ubicarse en un archivo con extensión .c. Además, por encima de main() deben aparecer los prototipos de funciones (y esto implica a los archivos de cabecera, si se utilizan funciones de librería) y las variables y constantes globales, si las hay. Por debajo de main() encontraremos el código de las funciones de usuario. Por lo tanto, la estructura habitual de nuestros programas en C debería ser esta: . /* Comentario inicial: nombre del programa, del programador, fecha, etc */ /* Archivos de cabecera (prototipos de funciones de librería) */ #include &lt;archivo_cabecera.h&gt; #include &lt;archivo_cabecera.h&gt; /* Prototipos de funciones escritas por nosotros */ float función1 (argumentos); float función2 (argumentos); /* Variables globales */ int variable_global1; char variable_global2; /* Algoritmo principal */ int main(void) { /* Variables locales del algoritmo principal */ int a, b; float x, y; ..... /* Instrucciones del algoritmo principal */ ... función1(argumentos); ... función2(argumentos); ... return 0; } /* Código completo de las funciones escritas por nosotros */ float función1 (argumentos) { /* Variables locales e instrucciones de este subalgoritmo */ } float función2 (argumentos) { /* Variables locales e instrucciones de este subalgoritmo */ } . 9.3.2. Compilar y ejecutar un programa sencillo desde la consola: gcc/g++ . Vamos a aprender a compilar con gcc/g++, un compilador rápido, muy flexible y riguroso con el estándar de C/C++. En realidad, gcc compila C y g++ compila C++, pero por lo demás se usan de forma muy semejante. Se consideran dos de los mejores compiladores del mundo. Ten en cuenta que son herramientas de consola, es decir, que se usan escribiendo comandos, lo cual demuestra que un gran programa no tiene por qué ser un programa “bonito”. ¡Todo depende de a qué tipo de usuario vaya dirigido! . En adelante, nos vamos a referir sobre todo a gcc, pero g++ es muy similar. Compilación básica con gcc . Casi siempre, gcc es invocado desde la herramienta make, cuyo funcionamiento se explica más adelante, pero antes debemos saber manejarlo mínimamente de forma manual. Vamos a compilar nuestro primer programa con gcc, que, como no podía ser de otra manera, será “hola mundo”. Supongamos que el código fuente de “hola mundo” se encuentra almacenado en el archivo holamundo.c. La compilación se realizaría con este comando: . $ gcc holamundo.c -o hola . Esto compilará el código fuente de holamundo.c y generará un programa ejecutable llamado hola, que puedes ejecutar escribiendo: . $ ./hola . Errores y warnings . Si el compilador detecta en el código fuente errores en tiempo de compilación, lo comunica al programador del siguiente modo: . $ gcc holamundo.c holamundo.c: In function 'main': holamundo.c:7: 'a' undeclared (first use in this function) holamundo.c:7: (Each undeclared identifier is reported only once holamundo.c:7: for each function it appears in.) holamundo.c:7: parse error before 'return' . Como ves, gcc te indica el fichero y la línea en la que ha detectado el error. Obviamente, cuando esto ocurre, no se crea archivo ejecutable como resultado. Debes corregir los errores e intentar la compilación de nuevo. Las advertencias (warnings) del compilador, en cambio, se consideran errores no críticos, por lo que no impiden la compilación del código. Las advertencias se muestran de un modo similar a los errores, indicando el archivo, la línea y la causa de la advertencia. Aunque no sean críticas, es una buena idea que las revises y las corrijas en caso necesario. Opciones comunes . A continuación mostramos algunas otras opciones habituales al usar gcc. | -help: Indica a gcc que muestre su salida de ayuda (muy reducida). | -o fichero: Especifica el nombre del archivo ejecutable que se generará como resultado de la compilación. Si no se indica ninguno, gcc creará un archivo llamado a.out. | -O nivel: Indica a gcc que utilice optimizaciones en el código. Los niveles posibles van desde 0 (no optimizar) hasta 3 (optimización máxima). Utilizar el optimizador aumenta el tiempo de compilación, pero suele generar ejecutables más rápidos. | -I directorio: Especifica un directorio adicional donde gcc debe buscar los archivos de cabecera indicados en el código fuente. | -L directorio: Especifica un directorio adicional donde gcc debe buscar las librerías necesarias en el proceso de enlazado. | -lLibrería: Especifica el nombre de una librería adicional que deberá ser utilizada en el proceso de enlazado. | . Por ejemplo, para compilar el programa holamundo.c con el nivel máximo de optimización y de manera que el ejecutable se llame “hola” y se enlace con la librería ncurses, el comando sería: . $ gcc -O3 -o hola -lncurses holamundo.c . 9.3.3. Compilar y ejecutar un programa no tan sencillo desde la consola: make . Cualquier proyecto de programación complejo consta de varios archivos fuente, puede incluso que de centenares de ellos. En este tipo de proyectos, los archivos se van compilando conforme se van construyendo, creándose un archivo binario a partir de cada archivo fuente. El archivo ejecutable final no se puede crear hasta que no se tienen disponibles todos los archivos binarios compilados. El proceso de composición de todos los archivos binarios en un archivo ejecutable final se denomina enlace o linkado (del inglés link). Hacer la compilación y enlace de múltiples archivos a mano es muy tedioso. Además, en proyectos complejos suele ocurrir que, cuando modificamos el código fuente de un archivo, otros archivos que dependan del que acabamos de modificar y también deben ser recompilados. En consecuencia, llevar un control sobre qué debe compilarse y qué no resulta complicado, y la opción de recompilar el proyecto entero todo el rato no es viable porque puede consumir muchísimo tiempo. La herramienta make permite automatizar todo esto. Nos evita la tarea de comprobar las dependencias entre ficheros y se encarga de compilar solo lo que en cada momento debe ser compilado. Para ello se sirve de un fichero (cuyo nombre suele ser Makefile, aunque puede cambiarse) en el el programador tiene que especificar las dependencias entre ficheros de código fuente, así como las órdenes necesarias para actualizar cada fichero. Una vez escrito el fichero Makefile, cada vez que cambiemos algún fichero fuente, nos bastará invocar el comando make para que él solito revise todas las dependencias y recompile y enlace todos los archivos que sean necesarios. El fichero Makefile . El fichero Makefile más simple está compuesto por reglas de este aspecto: . objetivo ... : prerrequisitos ... comando ..... | Un objetivo suele ser el nombre de un archivo generado por un programa; ejemplos de objetivos son los archivos de código objeto. Un objetivo puede ser también el nombre de una acción que debe llevarse a cabo, como clean, que veremos más adelante en un ejemplo. | Un prerrequisito es un archivo que se usa como entrada para crear un objetivo. Un objetivo con frecuencia depende de varios archivos, así que en esta sección puede aparecer una lista de archivos. | Un comando es una acción que make ejecuta cuando detecta que alguno de los prerrequisitos ha sido modificado. Debe ser un comando válido para el sistema operativo. Una regla puede tener más de un comando, cada uno en su propia línea. Atención: ¡hay que poner un tabulador al principio de cada línea de comando! . | . ¿Que no entiendes nada? ¡Normal! Lo verás mucho más claro con un ejemplo. Un ejemplo práctico . Nuestro ejemplo es un Makefile que describe la manera en la que un fichero ejecutable llamado trivia depende de tres ficheros objeto (binarios) que a su vez dependen de tres ficheros de código fuente C (.c) y uno cabecera (.h). El fichero Makefile debe indicar qué hay que recompilar cada vez que se modifica un archivo cualquiera. Échale un vistazo y lo comentamos más abajo: . trivia: main.o display.o utils.o gcc -o trivia main.o display.o utils.o main.o : main.c config.h gcc -c main.c display.c : display.c config.h buffer.h gcc -c display.c utils.o : utils.c config.h gcc -c utils.c clean : rm -f trivia *.o . Observa la primera línea. Ahí hemos dicho que el programa ejecutable (trivia) depende de los tres ficheros objeto (main.o, display.o y utils.o). Es decir, que si cambia cualquiera de ellos, make lo detectará y ejecutará el comando que aparece en la segunda línea. Y ese comando se encarga precisamente de volver a enlazar todos los ficheros objeto para generar de nuevo el archivo ejecutable trivia. La siguiente regla explica cómo se construye el archivo binario main.o: depende de main.c y de config.h, es decir, que se cambia cualquier cosa en alguno de esos dos archivos, main.o volverá a crearse con la línea que se indica justo debajo. Y lo mismo ocurre en todas las líneas del Makefile. La última regla (clean) es una regla especial que explicaremos enseguida. Cómo usar make . Cuando ya dispones de tu archivo Makefile como el anterior, usar la herramienta make para compilar es sencillísimo: . | Para crear el archivo ejecutable bastará con escribir en la línea de comandos: $ make . Al ejecutar make, solo se compilarán los archivos necesarios en cada momento (según lo que esté descrito en el Makefile). | Para borrar el archivo ejecutable y todos los ficheros objeto del directorio, escribiremos: . make clean . Para que make clean funcione, debe existir una sección clean en el archivo Makefile. Observa de nuevo el ejemplo de Makefile anterior y encontrarás al final la sección clean, donde se indica el comando que debe ejecutarse para borrar todos los archivos compilados. | . Esto es lo más esencial de la herramienta make, pero, por supuesto, tiene otras muchas funciones que puedes investigar por tu cuenta cuando te vayan haciendo falta. 9.3.4. Compilar y ejecutar un programa con un IDE: Visual Studio Code con Code Runner . Un IDE o Entorno Integrado de Desarrollo es un programa que contiene todo lo necesario para programar: un editor de texto, un compilador, un depurador, una consola de ejecución, una consola de errores y muchas otras cosas que no vamos a llegar a usar. Visual Studio Code es un IDE muy popular desde hace un par de años. Es rápido, ligero, muy configurable, multiplataforma (funciona en Windows, Linux y Mac) y sirve para cualquier lenguaje imaginable. Con la extensión Code Runner, es facilísimo compilar y ejectuar código C/C++ con Visual Studio Code. Solo tienes que: . | Instalar Visual Studio Code y, dentro de él, la extensión Code Runner. | Escribir tu programa en C. | Pulsar el botón “Play” que aparecerá en la esquina superior derecha. | Ver tu programa en funcionamiento en el terminal de la parte inferior. | . Puedes ver a Visual Studio Code en funcionamiento en esta capura de pantalla. Arriba y a la derecha están los botones de “Play” y “Stop” para lanzar y detener el programa. En el panel superior, el código fuente. En el panel inferior, el programa en ejecución. Y, a la izquierda, el navegador de archivos. 9.3.5. Flujo de trabajo habitual . Cuando se trabaja con C, la implementación de un programa suele dividirse en varias subfases: edición, compilación, enlace y depuración. Te las describo brevemente: . | Edición del código fuente. Editar consiste en escribir el código fuente del programa en el lenguaje seleccionado, en nuestro caso C. Usaremos para ello Visual Studio Code con la extensión Code Runner. | Compilación. Una vez escrito el programa, debe traducirse a binario en el proceso llamado compilación. Esto puede hacerse desde la línea de comandos, como ya hemos visto, o de forma gráfica desde nuestro IDE. Este es el botón “Compile &amp; Run” de Code Runner, por ejemplo: . | Enlace. Si tu programa es muy complejo, tu código fuente ocupará varios archivos. En tal caso, hay que compilarlos de uno en uno y después enlazarlos entre sí para generar un único programa ejecutable. Como vimos, esto puede hacerse con la herramienta make o, en caso de usar un IDE, dejar que sea él quien se encargue de hacer el enlace automáticamente. | Depuración. Ningún programa está bien escrito a la primera. Nunca. Lo normal es que el compilador te informe de que hay multitud de errores en tu código fuente. Tendrás que leer cuidadosamente los mensajes de error para corregirlos. Por fortuna, el compilador te informará de la línea exacta donde localizó el error, e incluso te dirá de qué tipo de error se trata. Una vez corregidos los errores de escritura, cuando el programa empiece a funcionar, es posible que no haga exactamente lo que tú pretendías que hiciera. También tendrás que corregir estos errores de ejecución. Por lo tanto, después de pasar por estos 4 pasos, tendrás que regresar de nuevo al paso 1 y volver a repetir el proceso hasta que tu programa funcione como es debido. | . ",
    "url": "https://iescelia.org//docs/tico/_site/escribiendo-programas-en-c/",
    "relUrl": "/escribiendo-programas-en-c/"
  },"40": {
    "doc": "9.4. Un poco de C avanzado",
    "title": "9.4. Un poco de C avanzado",
    "content": ". | 9.4.1. Punteros | 9.4.2. Comprendiendo los punteros | 9.4.3. Declaración e inicialización de punteros | 9.4.4. Asignación de punteros | 9.4.5. Punteros y arrays | 9.4.6. Paso de punteros como parámetros | 9.4.7. Devolución de punteros | 9.4.8. Punteros a punteros | 9.4.9. Gestión dinámica de la memoria: arrays dinámicos | 9.4.10. Librerías no estándar que molan: ncurses | 9.4.11. Librerías no estándar que molan: SDL | . En esta sección vamos a ver algunas cosas (¡no todas!) sobre C avanzado: una introducción a los punteros, algo sobre gestión dinámica de memoria, un poco acerca de los arrays dinámicos y cómo usar librerías no estándar importantes tales como Ncurses (para añadir color y otros efectos a nuestros programas de texto) o SDL (para añadir gráficos y sonidos). 9.4.1. Punteros . Comprender y usar correctamente los punteros es con seguridad lo más complicado del lenguaje C, pero también se trata de un mecanismo muy poderoso. Tan poderoso que un simple puntero descontrolado (hay quien los llama punteros locos) puede provocar que el programa se cuelgue o se comporte de forma extraña e impredecible. Todos los programadores con cierta experiencia en C reconocerán que, a veces, programar con punteros es como quedarse atrapado en un ascensor con un montón de serpientes pitón enloquecidas. Pero, cuando se les coge el tranquillo y se les ata en corto, permiten hacer auténticas virguerías. 9.4.2. Comprendiendo los punteros . Dentro de la memoria del ordenador, cada dato almacenado ocupa una o más celdas contiguas de memoria. El número de celdas de memoria requeridas para almacenar un dato depende de su tipo. Por ejemplo, un dato de tipo entero puede ocupar 32 bits (es decir, 4 bytes), mientras que un dato de tipo carácter ocupa 8 bits (es decir, 1 byte). Un puntero no es más que una variable cuyo contenido no es un dato, sino la dirección de memoria donde está almacenado un dato. Veámoslo a través de un ejemplo. Imaginemos que v es una variable de tipo carácter y que, por tanto, necesita 1 byte para ser almacenada. La declaración e inicialización de la variable será como la siguiente: . char v; v = 'A'; . Al ejecutar este código, el sistema operativo asigna automáticamente una celda de memoria para el dato. Supongamos que la celda asignada tiene la dirección 1200. Al hacer la asignación v = ‘A’, el sistema almacena en la celda 1200 el valor 65, que es el código ASCII de la letra ‘A’: . | Dirección de memoria | Contenido | . | 1198 |   | . | 1199 |   | . | 1200 | 65 | . | 1201 |   | . | … | … | . Cuando usamos la variable v a lo largo del programa, el sistema consulta el dato contenido en la celda de memoria asignada a la variable. Esa celda será siempre la misma a lo largo de la ejecución: la 1200. Por ejemplo, al encontrar esta instrucción: . printf(\"%c\", v); .. el compilador acude a la celda 1200 de la memoria, consulta el dato almacenado en ella en ese momento y sustituye la variable v por ese dato. El programador no tiene modo de saber en qué posición de memoria se almacena cada dato, a menos que utilice punteros. Los punteros sirven, entonces, para conocer la dirección de memoria donde se almacena el dato, y no el dato en sí. La dirección ocupada por una variable v se determina escribiendo &amp;v. Por lo tanto, el operador &amp; es un operador unario, llamado operador dirección, que proporciona la dirección de memoria de una variable. La dirección de v se le puede asignar a otra variable mediante esta instrucción: . char* p; p = &amp;v; . Resultará que esta nueva variable es un puntero a v, es decir, una variable cuyo contenido es la dirección de memoria ocupada por la variable v. Representa la dirección de v y no su valor. Por lo tanto, el contenido de p será 1200, mientras que el contenido de v será 65. El dato almacenado en la celda apuntada por la variable puntero puede ser accedido mediante el operador asterisco aplicado al puntero. Así pues, la expresión *p devuelve el valor 65, que es el contenido de la celda apuntada por p. El operador * es un operador unario, llamado operador indirección, que opera sólo sobre una variable puntero. Resumiendo: podemos tener variables “normales” y utilizar el operador &amp; para conocer su dirección de memoria. O podemos tener variables puntero, que ya son en sí mismas direcciones de memoria, y utilizar el operador * para acceder al dato que contienen: . | El operador dirección (&amp;) sólo puede actuar sobre variables que no sean punteros. En el ejemplo anterior, la variable v vale 65 y la expresión &amp;v vale 1200. | El operador indirección (*) sólo puede actuar sobre variables que sean punteros. En el ejemplo anterior, la expresión *p vale 65 y la variable p vale 1200. | . Las variables puntero pueden apuntar a direcciones donde se almacene cualquier tipo de dato: enteros, flotantes, caracteres, cadenas, arrays, estructuras, etc. Esto es tremendamente útil y proporciona una enorme potencia al lenguaje C, pero también es una fuente inagotable de errores de programación difíciles de detectar y corregir, como iremos viendo en los siguientes temas . 9.4.3. Declaración e inicialización de punteros . Las variables de tipo puntero, como cualquier otra variable, deben declararse antes de ser usadas. Cuando una variable puntero es definida, el nombre de la variable debe ir precedido por un *. El tipo de dato que aparece en la declaración se refiere al tipo de dato que se almacena en la dirección representada por el puntero, en vez del puntero mismo. Así, una declaración de puntero general es: . Por ejemplo: . int *numero; char *letra; . La variable numero no contiene un número entero, sino la dirección de memoria donde se almacenará un número entero. La variable letra tampoco contiene un carácter, sino la dirección de memoria donde se almacenará un carácter. Cuando un puntero ha sido declarado pero no inicializado, apunta a una dirección de memoria indeterminada. Si tratamos de usarlo en esas condiciones obtendremos resultados impredecibles (y casi siempre desagradables). Antes de usar cualquier puntero hay que asegurarse de que está apuntando a una dirección válida, es decir, a la dirección de alguna variable del tipo adecuado. Por ejemplo, así: . int *numero; int a; numero = &amp;a; . El puntero numero ahora sí está en condiciones de ser usado, porque está apuntado a la dirección de la variable a, que es de tipo int, como el puntero. Otra posibilidad es hacer que un puntero apunte a NULL. El identificador NULL es una constante definida en el lenguaje que indica que un puntero no está apuntando a ninguna dirección válida y que, por lo tanto, no se debe utilizar: . int *numero = NULL; . 9.4.4. Asignación de punteros . Se puede asignar una variable puntero a otra siempre que ambas apunten al mismo tipo de dato. Al realizar la asignación, ambos punteros quedarán apuntando a la misma dirección de memoria. Observa este ejemplo y trata de determinar qué resultado se obtiene en la pantalla (antes de leer la solución que aparece más abajo): . int a, b, c; int *p1, *p2; a = 5; p1 = &amp;a; /* p1 apunta a la dirección de memoria de la variable a */ p2 = p1; /* a p2 se le asigna la misma dirección que tenga p1 */ b = *p1; c = *p1 + 5; /* Suma 5 a lo que contenga la dirección apuntada por p1 */ printf(\"%i %i %i %p %p\", a, b, c, p1, p2); . En la pantalla se imprimirá “5 5 10”, que es el contenido de las variables a, b y c al terminar la ejecución de este bloque de instrucciones, y la dirección a la que apuntan p1 y p2, que debe ser la misma. Observa que con printf y la cadena de formato “%p” se puede mostrar la dirección de memoria de cualquier variable. 9.4.5. Punteros y arrays . Punteros y arrays de una dimensión . Los punteros y los arrays tienen una relación muy estrecha en C, ya que el nombre de un array es en realidad un puntero al primer elemento de ese array. Es decir, si x es un array undimensional, la dirección del primer elemento puede ser expresada como &amp;x[0] o simplemente como x. Y, del mismo modo, la dirección del elemento i-ésimo se puede expresar como &amp;x[i] o como (x+i). En este caso, la expresión (x+i) no es una operación aritmética convencional, sino una operación con punteros. Si &amp;x[i] y (x+i) representan la dirección del i-ésimo elemento de x, podemos decir que x[i] y *(x+i) representan el contenido de esa dirección, es decir, el valor del i-ésimo elemento de x. Observa que la forma x[i] es la que hemos estado utilizando hasta ahora para acceder a los elementos de un vector. Los arrays, por lo tanto, pueden utilizarse con índices o con punteros. Al programador suele resultarle mucho más cómodo utilizar la forma x[i] para acceder al elemento i-ésimo de un array. Sin embargo, hay que tener en cuenta que la forma *(x+i) es mucho más eficiente que x[i], por lo que suele preferirse cuando la velocidad del ejecución es un factor determinante. Punteros y arrays multidimensionales . Un array multidimensional es en realidad una colección de varios arrays unidimensionales (vectores). Por tanto, se puede definir un array multidimensional como un puntero a un grupo contiguo de arrays unidimensionales. El caso más simple de array de varias dimensiones es el bidimiensional. Supongamos que x es un array bidimensional de enteros con 10 filas y 20 columnas. Podemos declarar x de dos formas: . int x[10][20]; /* Declaración convencional */ int (*x)[20]; /* Declaración como puntero */ . En la segunda declaración, x se define como un puntero a un grupo de array unidimensionales de 20 elementos enteros. Así x apunta al primero de los arrays de 20 elementos, que es en realidad la primera fila (fila 0) del array bidimensional original. Del mismo modo (x+1) apunta al segundo array de 20 elementos, y así sucesivamente. Por ejemplo, el elemento de la columna 2 y la fila 5 puede ser accedido de estas dos maneras: . x[2][5]; /* Acceso convencional */ *(*(x+2)+5); /* Acceso mediante punteros */ . Esta instrucción parece muy complicada pero es fácil de desentrañar: . | (x+2) es un puntero a la columna 2 | *(x+2) es el objeto de ese puntero y refiere a toda la columna. Como la columna 2 es un array unidimensional, *(x+2) es realmente un puntero al primer elemento de la columna 2. | (*(x+2)+5) es un puntero al elemento 5 de la columna 2. | El objeto de este puntero ((x+2)+5) refiere al elemento 5 de la columna 2. | . 9.4.6. Paso de punteros como parámetros . A menudo los punteros son pasados a las funciones como argumentos. Esto permite que datos de la porción de programa desde el que se llama a la función sean accedidos por la función, alterados dentro de ella y devueltos de forma alterada. Este uso de los punteros se conoce como paso de parámetros por variable o referencia y lo hemos estado utilizando hasta ahora sin saber muy bien lo que hacíamos. Cuando los punteros son usados como argumento de una función, es necesario tener cuidado con la declaración y uso de los parámetros dentro de la función. Los argumentos formales que sean punteros deben ir precedidos por un asterisco. Observa detenidamente el siguiente ejemplo: . #include &lt;stdio.h&gt; void funcion1(int, int); void funcion2(int*, int*); int main(void) { int u, v; u = 1; v = 3; funcion1(u,v); printf(\"Después de la llamada a funcion1: u=%d v=%d\\n\", u, v); funcion2(&amp;u,&amp;v); printf(\"Después de la llamada a funcion2: u=%d v=%d\\n\", u, v); } void funcion1(int u, int v) { u=0; v=0; } void funcion2(int *pu, int *pv) { *pu=0; *pv=0; } . La función de funcion1() utiliza paso de parámetros por valor. Cuando es invocada, los valores de las variables u y v del programa principal son copiados en los parámetros u y v de la función. Al modificar estos parámetros dentro de la función, el valor de u y v en el programa principal no cambia. En cambio, funcion2() utiliza paso de parámetros por por referencia. Lo que se pasa a la función no es el valor de las variables sino su dirección de memoria, es decir, un puntero a las celdas de memoria donde u y v están almacenadas. Dentro de la función, se utiliza el operador asterisco para acceder al contenido de pu y pv y, en consecuencia, se altera el contenido de las posiciones de memoria apuntadas por pu y pv. El resultado es que las variables u y v del programa principal quedan modificadas. Por lo tanto, la salida del programa debe ser: . Después de la llamada a funcion1: u=1 v=3 Después de la llamada a funcion2: u=0 v=0 . ¿Recuerdas que la función scanf() requiere que sus argumentos vayan precedidos por &amp;, mientras que printf() no lo necesita? Hasta ahora no podíamos comprender por qué, pero ahora podemos dar una razón: scanf() necesita que sus argumentos vayan precedidos del símbolo &amp; porque necesita las direcciones de los datos que van a ser leídos, para poder colocar en esas posiciones de memoria los datos introducidos por teclado. En cambio, printf() no necesita las direcciones, sino únicamente los valores de los datos para poder mostrarlos en la pantalla. Al estudiar los arrays y las estructuras ya vimos en detalle cómo se deben pasar como parámetros a las funciones. Recuerda que los arrays siempre se pasan por variable y no es necesario usar el símbolo &amp; en la llamada, ya que el propio nombre del array se refiere, en realidad, a la dirección del primer elemento. 9.4.7. Devolución de punteros . Una función también puede devolver un puntero. Para hacer esto, la declaración de la función debe indicar que devolverá un puntero. Esto se realiza precediendo el nombre de la función con un asterisco. Por ejemplo: . double *pf; pf = funcion(argumentos); printf(\"%lf\", *pf); . Cuando esta función sea invocada, devolverá un puntero a un dato de tipo double, y por lo tanto debe ser asignada a una variable de ese tipo. Por ejemplo, así: . 9.4.8. Punteros a punteros . Un último aspecto (a la vez confuso y potente) de los punteros es la posibilidad de definir punteros que, a su vez, apunten a otros punteros. Esto no es un trabalenguas, sino que, técnicamente, se denomina indirección múltiple. Por ejemplo, el resultado del siguiente fragmento de código en C debe ser que se imprima el número 15 en la pantalla: . int n; int* p1; /* puntero a un número entero */ int** p2; /* puntero a un puntero de números enteros */ p1 = &amp;n; /* p1 contiene la dirección de n */ p2 = &amp;p1; /* p2 contiene la dirección de p1 */ **p2 = 15; printf(\"%i\", n); . 9.4.9. Gestión dinámica de la memoria: arrays dinámicos . Según hemos visto hasta ahora, la memoria reservada para cada variable se define en el momento de escribir el código del programa. Por ejemplo, si declaramos una variable de tipo int, ésta tendrá asignados 2 o 4 bytes de memoria (esa cantidad puede variar dependiendo del compilador y del sistema operativo). Entonces, si declaramos un array de 100 números enteros, el array tendrá reservados 200 o 400 bytes de memoria. ¿Pero qué ocurre si no sabemos de antemano cuántos elementos puede llegar a tener el array? . Por ejemplo, imaginemos un problema consistente en leer por teclado (u otro dispositivo de entrada) una cantidad indefinida de números para almacenarlos en un array y luego hacer ciertas operaciones con ellos. ¿De qué tamaño podemos definir el array? ¿De 100 elementos? ¿Y si el usuario introduce 101 elementos? . Para estas situaciones, que son muy frecuentes, existe la asignación dinámica de memoria, que consiste en reservar memoria para las variables en tiempo de ejecución, es decir, mientras el programa está funcionando. Así, es posible “estirar” o “encoger” sobre la marcha el espacio reservado para el array, dependiendo de las necesidades de cada momento. Veremos enseguida que, para manejar la memoria dinámicamente, es imprescindible el uso de punteros. De hecho, este es uno de los grandes frutos que vamos a obtener de ellos. Como los arrays son la estructura de datos más simple y fácil de entender, vamos a centrarnos en crear y manipular arrays dinámicos, pero los principios que veamos aquí son aplicables a cualquier otra estructura dinámica simple, como pilas, listas o colas, o complejas, como árboles o grafos. Reserva de memoria con malloc() . Ya que un nombre de array es en realidad un puntero a su primer elemento, es posible definir un array como una variable puntero en vez de como un array convencional. Así, estas dos definiciones sirven para un vector de números enteros: . int vector1[100]; int* vector2; . | El vector1 se define del modo convencional de un array. Esto produce la reserva de un bloque fijo de memoria al empezar la ejecución del programa lo suficientemente grande como para almacenar 100 números enteros. | El vector2 se define como puntero a entero. En este caso, no se reserva ninguna cantidad de memoria para almacenar los números enteros. | . Si intentamos acceder a los elementos de los vectores obtendremos resultados diferentes: . vector1[5] = 83; vector2[5] = 27; /* Esto es un error */ . La primera asignación funcionará correctamente, ya que el quinto elemento del vector1 tiene un espacio de memoria asignado. La segunda asignación producirá un efecto impredecible, ya que vector2 no tiene ningún espacio de memoria asignado y, por lo tanto, el dato 27 se escribirá en una posición de memoria correspondiente a otro dato u otro programa. La consecuencia puede llegar a ser bastante desagradable. Se necesita, pues, reservar un fragmento de memoria antes de que los elementos del array sean procesados. Tales tipos de reserva se realizan mediante la función malloc() o alguna de sus variedades. Observa bien su uso en este ejemplo: . int *x; x = (int *) malloc (100 * sizeof(int)); . La función malloc() reserva un especio de memoria consistente en 100 veces el tamaño de un número entero. Fíjate bien en el uso del sizeof(int): se trata de un operador unario que devuelve el tamaño de un tipo de dato cualquiera, tanto simple como complejo. Suponiendo que sizeof(int) fuera 2 (es decir, que cada número de tipo int ocupase 2 bytes), lo que se le está pidiendo a malloc() es que reserve 100 * 2 bytes, es decir, 200 bytes de memoria. Además, es necesario usar el molde (int *), ya que malloc() devuelve un puntero sin tipo (es decir, un puntero a void), así que hay que convertirlo a puntero a entero antes de asignarlo a la variable x, que efectivamente es un puntero a entero. De esta manera, la variable vector2 pasa a ser un array dinámico: se comporta como un array y puede usarse como tal, pero su tamaño ha sido definido durante la ejecución del programa. Y más adelante, en el mismo programa, podemos redefinir el tamaño del array para acortarlo o alargarlo. Si la función malloc() falla devolverá un puntero a NULL. Utilizar un puntero a NULL es la forma más segura de hacer explotar tu programa, así que siempre debemos comprobar que el puntero devuelto es correcto. Una vez hecho esto, podemos utilizar x con toda tranquilidad como si fuera un array de 100 números enteros. Por ejemplo: . int *x, i; x = (int *) malloc (100 * sizeof(int)); if (x == NULL) printf(\"Error en la asignación de memoria\"); else { printf(\"Se ha reservado con éxito espacio para 100 números\"); for (i=0; i&lt;100; i++) { printf(\"Introduzca un número:\"); scanf(\"%i\", &amp;x[i]); } } . Liberación de memoria con free() . El programador debe tener dos precauciones básicas a la hora de manejar la memoria dinámicamente: . | Asignar memoria a un puntero antes de usarlo con malloc() u otra función similar | Liberar la memoria asignada, cuando ya no va a usarse más, con free() u otra función similar. | . Si no se libera la memoria asignada a un puntero, teóricamente no ocurre nada grave, salvo que podemos terminar por agotar la memoria disponible si reservamos continuamente y nunca liberamos. Es, en cualquier caso, una costumbre muy saludable. Para liberar la memoria reservada previamente con malloc() u otra función de su misma familia, se utiliza la función free(). Observa su uso en este ejemplo: . int *x, i; x = (int *) malloc (100 * sizeof(int)); ... instrucciones de manipulación de x ... free(x); . Toda la memoria reservada con malloc() quedará liberada después de hacer free() y se podrá utilizar para guardar otros datos o programas. El puntero x quedará apuntado a NULL y no debe ser utilizado hasta que se le asigne alguna otra dirección válida. Funciones básicas para la gestión dinámica de la memoria . Además de malloc() y free() existen otras funciones similares pero con pequeñas diferencias. A continuación resumimos las más usuales y mostramos un ejemplo de su uso. Pero antes haremos una advertencia: todas las funciones de reserva de memoria devuelven un puntero a NULL si no tienen éxito. Por lo tanto, deben ir seguidas de un condicional que compruebe si el puntero apunta a NULL antes de utilizarlo. | calloc(): Reserva un bloque de memoria para almacenar num elementos de tam bytes y devuelve un puntero void al comienzo del bloque. El siguiente ejemplo reserva espacio para 35 números enteros: . int* p; p = (int*) calloc(35, sizeof(int)); . | free(): Libera el bloque de memoria apuntado por un puntero y que previamente había sido reservado. | malloc(): Reserva un bloque de memoria de tam bytes y devuelve un puntero void al comienzo del mismo. Por ejemplo, para reservar espacio para una cadena de 100 caracteres: . char* texto; texto = (char*) malloc(100 * sizeof(char)); . | realloc(): Cambia el tamaño de un bloque de memoria apuntado por puntero. Dicho bloque ha debido ser previamente asignado con malloc() u otra función similar. El nuevo tamaño será de tam bytes. Devuelve un puntero void al comienzo del bloque. En el siguiente ejemplo, se reserva espacio para 100 caracteres, pero luego se modifica el tamaño del bloque para dar cabida hasta 500 caracteres: . char* texto; texto = (char*) malloc(100 * sizeof(char)); /* Aquí irían las instrucciones que utilicen el puntero texto con un tamaño de 100 caracteres */ texto = (char*) realloc(texto, 500 * sizeof(char)); /* A partir de aquí, el mismo puntero texto puede usarse para manejar hasta 500 caracteres */ . | . 9.4.10. Librerías no estándar que molan: ncurses . Además de las librerías estándar ANSI, existen muchas (¡muchísimas!) librerías de terceros que se pueden usar en nuestros programas. Las que vamos a ver a continuación nos permitirán introducir colores, sonidos y movimientos en nuestros programas, pero debes tener presente una cosa: al no ser librerías estándar, los programas creados con estas librerías serán más difícilmente portables a otros sistemas. Qué es Ncurses . Ncurses es una librería para el manejo de interfaces basadas en texto. Es decir, se trata de un conjunto de funciones ya programadas que podemos utilizar en nuestros programas de texto para mejorar su aspecto. Con Ncurses podemos añadir colores, escribir en cualquier parte de la pantalla o borrar caracteres concretos. Por ejemplo, este programa para generar y resolver sudokus está escrito con Ncurses: . Desde luego, la pantalla anterior sería imposible de obtener con las librerías estándar de C. Compilación y enlace . Como Ncurses no es una librería estándar, es necesario ordenar al compilador que la enlace con nuestro programa. Si compilas desde la consola, esto se hace añadiendo la opción –lncurses al comando gcc. Por ejemplo: . | gcc holamundo.c: compila holamundo.c sin enlazarlo con la librería Ncurses | gcc -lncurses holamundo.c: compila holamundo.c enlazándolo con Ncurses | . Si trabajas desde desde Visual Studio Code y tienes la librería Ncurses instalada en tu sistema, no es necesario que hagas nada en especial. Un simple #include &lt;ncurses.h&gt; bastará para poder usar la librería. Ncurses tiene muchísimas funciones, pero nosotros sólo nos referiremos aquí a las más básicas, que nos permitirán añadir color a nuestros textos y controlar libremente la posición del cursor de escritura. Pero Ncurses va mucho más allá, permitiendo la creación de capas de texto superpuestas, menús desplegables y muchas otras cosas en la consola de texto. Inicialización de Ncurses . Para utilizar las funciones de Ncurses en nuestro programa, basta con que incluyamos la siguiente llamada: . initscr(); . Esta función crea una ventana de texto. La ventana se llama stdscr (que significa “standard screen”, es decir, “pantalla estándar”). A partir de aquí podremos utilizar cualquier función de Ncurses, pues todas actúan sobre esa ventana (se pueden crear varias ventanas sobre stdscr, pero nosotros no profundizaremos en esa posibilidad). Por ejemplo, una función que suele ir justo después es: . keypad (stdscr, 1); . Esto sirve para activar la recepción de teclas especiales (como F1, F2, ESC, etc). Si no llamamos a keypad(), no podremos utilizar ese tipo de teclas en nuestro programa. El segundo parámetro sirve para activar (1) o desactivar (0) la recepción de teclas especiales. A continuación te dejo una lista con las principales funciones de inicialización de Ncurses: . | initscr(). Inicializa Ncurses y crea la pantalla estándar. Debe ser invocada antes que cualquier otra función de la librería. | keypad(). Activa / desactiva la recepción de teclas especiales, como F1, ESC, Intro, etc. Si activar = 1, se activa la recepción. Si activar = 0, se desactiva. | echo() y noecho(). Activa / desactiva el eco de caracteres. Si el eco está activo, lo que se escriba en el teclado aparece en la pantalla. Si está inactivo, no. | cbreak() y nocbreak(). Activa / desactiva el envío inmediato de teclas. Normalmente, cuando se teclea algo no es enviado al programa hasta que no se pulsa “intro”. La función cbreak() hace que todo cuanto se teclee sea enviado al programa sin necesidad de “intro”. La función nocbreak() desactiva este comportamiento | nodelay(stdscr). Activa / desactiva la espera para lectura de teclado. Las funciones para leer un solo carácter, como getch(), detienen la ejecución del programa hasta que se pulsa alguna tecla. Llamando a esta función con el parámetro activar = 1, conseguiremos que el programa no se detenga en getch() aunque no se pulse tecla alguna. Para desactivarlo, llamaremos a la función con activar = 0. | endwin(). Finaliza Ncurses. Hay que llamar a esta función antes de terminar el programa para liberar la memoria ocupada y restaurar la consola al estado inicial. | . Escribir y leer con ncurses . Cuando utilicemos Ncurses debemos olvidarnos de las funciones de entrada/salida estándar, como scanf(), printf(), gets() o puts(). En su lugar usaremos estas otras funciones: . | printw() y putstr(). Para escribir usaremos la función printw(), que funciona igual que printf() pero sobre una ventana de Ncurses. También podemos usar putstr(), que es como puts(), es decir, sirve para imprimir cadenas | getstr() y getch(). Para leer disponemos de getstr(), que es como gets(), es decir, sirve para leer cadenas por teclado. De modo que, si queremos leer un número, debemos leerlo como cadena y luego convertirlo a número (con las funciones estándar atoi(), atof(), etc). También podemos usar getch(), que lee un único carácter. | move(). Posiciona el cursor de texto en la columna x y la fila y de la pantalla. ¡Atención! Se indica primero la fila y luego la columna. | refresh(). Actualiza la pantalla. Es el único modo de asegurarnos de que los cambios realizados se muestren instantáneamente. Si no, Ncurses decidirá cuándo actualizar la pantalla por su cuenta, y te aseguro que no lo hace continuamente. | . Dar color a nuestro texto . Antes de utilizar los colores en la terminal de texto hay que inicializarlos llamando a la función start_color() sin argumentos, así: . if (has_colors()) start_color(); . La llamada previa a has_colors() se realiza para asegurarnos de que nuestra consola soporta el uso de colores. Es raro encontrar una consola que no permita colores, pero existen, así que no está de más hacer la comprobación. Una vez hecho esto, podemos utilizar los colores básicos definidos en ncurses.h, cuyas constantes son COLOR_BLACK, COLOR_WHITE, COLOR_YELLOW, etc. Para utilizar esos colores se deben agrupar en parejas: un color para el texto junto con un color para el fondo. A cada pareja se le asigna un número a través de la función init_pair(). Por ejemplo: . init_pair(1, COLOR_YELLOW, COLOR_BLUE); . Esto define a la pareja de colores nº 1 como texto amarillo sobre fondo azul. De este modo podemos definir, por lo general, hasta 64 parejas. Después, para activar una pareja de color, haremos esta llamada: . attron(COLOR_PAIR(1)); . Esto activa la pareja de colores nº 1, de manera que todo el texto que aparezca en la pantalla a partir de este momento se verá amarillo con el fondo azul. La función attron(), además de para activar parejas de colores, sirve para cambiar otros atributos del texto. Por ejemplo, lo siguiente se utiliza para escribir en negrita: . attron(A_BOLD); . Puedes obtener más información sobre attron() en las páginas de manual (escribiendo $ man attron en la consola) o en internet (por ejemplo, aquí). Ejemplo de uso de Ncurses . Para terminar esta breve introducción a la librería Ncurses mostraremos un ejemplo ilustrativo del uso de algunas de las funciones que aquí se han visto. El siguiente programa utiliza Ncurses para escribir el texto HOLA en color rojo sobre fondo azul y el texto MUNDO en color amarillo sobre fondo verde. El texto HOLA aparece en la línea 11, y MUNDO en la 12. Luego, el programa espera hasta que se pulsa la tecla “flecha arriba”, y entonces termina. #include &lt;ncurses.h&gt; int main(void) { char carácter; initscr(); // Inicializa Ncurses keypad(stdscr, 1); // Activa teclas especiales (como las flechas) cbreak(); // Para no tener que pulsar Intro tras cada carácter if (has_colors()) start_color(); // Inicializa colores init_pair(1, COLOR_RED, COLOR_BLUE); // Pareja 1 = Texto rojo, fondo azul init_pair(2, COLOR_YELLOW, COLOR_GREEN); // Pareja 2 = Texto amarillo, fondo verde attron(COLOR_PAIR(1)); // Activa pareja 1 move(11, 1); printw(\"HOLA\"); attron(COLOR_PAIR(2)); // Activa pareja 2 move(12, 1); printw(\"MUNDO\"); do { carácter = getch(); // Lee un carácter desde el teclado } while (carácter != KEY_UP); endwin(); // Finaliza Ncurses return 0; } . 9.4.11. Librerías no estándar que molan: SDL . SDL (iniciales de Single DirectMedia Layer) es una biblioteca de C libre y disponible para múltiples plataformas (entre ellas, Linux y Windows). Puedes bajarte la última versión de http://www.libsdl.org. Esta biblioteca contiene un conjunto muy completo de funciones para manejar gráficos, además de sonidos y distintos dispositivos multimedia (ratón, CD-ROM, etc). Muchos programas escritos en C (en particular, videojuegos) se han desarrollado con SDL. Además, la librería es razonablemente sencilla de usar. La siguiente captura pertenece a un juego llamado Unknown Horizons, desarrollado en 2008 con la librería SDL y cuya última versión es del año 2019. Puedes encontrar en internet muchos otros ejemplos de programas escritos con SDL, tanto antiguos como recientes: . Nosotros sólo nos vamos a centrar en la parte de SDL dedicada a los gráficos. Si quieres más información, en la página web reseñada antes encontrarás una completa documentación. NOTA IMPORTANTE: todo lo que sigue se refiere a la versión 1.2 de la librería SDL. La versión más reciente podría tener algunas pequeñas diferencias que debes consultar en la documentación. Instalación de SDL . SDL no es una librería C estándar, es decir, no viene “de serie” con el compilador de C. En realidad, tampoco ncurses lo es, pero su uso está tan extendido en entornos Unix que viene incorporada a las librerías del compilador gcc. En cambio, la librería SDL debe ser instalada antes de poder utilizarla. A continuación describimos el proceso de instalación en Linux y en Windows . Existen dos paquetes de SDL: el runtime, necesario para ejecutar aplicaciones que usen SDL, y el development, necesario para escribir y compilar programas que usen SDL. Nosotros necesitaremos los dos, claro. Instalación de SDL en Linux . | Instala el paquete libSDLX.X-dev (X.X es el número de la versión; por ejemplo, puede ser 1.2) desde la tienda de aplicaciones de tu distribución Linux. Eso será suficiente para que se instalen los paquetes de desarrollo y de runtime. | Si estos paquetes no estuvieran en tu repositorio (algo muy raro), puedes bajártelos de libsdl.org e instalarlos manualmente. Consulta el manual de tu Linux para aprender a hacer esto último. | Además, puedes necesitar paquetes adicionales. Los más habituales son libSDL-imageX.X-dev (para manipular imágenes), libSDL-ttfX-X-dev (para manejar fuentes y renderizar textos) y libSDL-mixerX.X-dev (para utilizar sonidos). Ten en cuenta que los nombres de los paquetes pueden variar ligeramente dependiendo de tu distribución de Linux. | Para instalar todos estos paquetes de SDL 1.2 en una distribución como Ubuntu, puedes usar este comando: . $ sudo apt update $ sudo apt install libsdl1.2-dev libsdl-image1.2-dev libsdl-ttf1.2-dev libsdl-mixer1.2-dev . Si tu distribución no usa apt como gestor de paquetes, tendrás que buscar en la documentación de la misma cómo instalar paquetes de los respositorios. | . Instalación de SDL en Windows . | Bájate la última versión de la librería de la web de SDL. Necesitarás la librería de vínculos dinámicos (denominada dll), que es el runtime para Windows, y el paquete de desarrollo. | La librería de vínculos dinámicos suele venir comprimida en un archivo cuyo nombre es similar a: SDL-x.x.x.zip, donde “x.x.x” es la versión de la libería. Existirán varios paquetes de desarrollo para varios compiladores. Mi consejo es que bajes el que está preparado para el compilador de GNU, cuyo nombre es SDL-devel-x.x.x-mingw32.tar o algo similar. | Descomprime la librería de vínculos dinámicos. Debes obtener un archivo llamado sdl.dll. Copia este archivo al directorio /windows/system32, o bien ubícalo en la misma carpeta en la que se encuentre el programa que estás escribiendo. | Descomprime el paquete de desarrollo. Encontrarás varios directorios y, dentro de ellos, multitud de archivos. Copia los archivos en los directorios del mismo nombre de tu compilador. Por ejemplo, el copia el directorio “include” del paquete de desarrollo al directorio “include” de la carpeta donde esté instalado tu compilador. Repite la operación para todos los directorios cuyo nombre coincida. | Si vas a usar otras librerías auxiliares, como image, ttf o mixer (para manipular imágenes, fuentes y sonidos con SDL), repite el proceso con cada una de ellas. | . Compilación y enlace de SDL . Al no ser SDL una librería estándar, el enlace entre nuestro programa y las funciones de SDL no se produce automáticamente. Hay que indicarle al enlazador (o linker) lo que debe hacer. Para empezar, como con cualquier librería, tienes que incluirla en tu código fuente, así: . #include &lt;SDL/SDL.h&gt; . Si usas otras librerías auxiliares de SDL, como SDL-mixer, también tendrás que incluir el archivo de cabecera. Por ejemplo: . #include &lt;SDL/SDL_mixer.h&gt; . Luego, durante la compilación, tienes que indicar al compilador que enlace tu programa con la librería SDL. Si estás compilando desde la línea de comandos esto se hace así: . $ gcc mi_programa.c -o mi_ejecutable -lSDL . Si estás usando otras librerías, como SDL_mixer, tendrás que añadirlas también: . $ gcc mi_programa.c -o mi_ejecutable -lSDL -lSDL_mixer . En cambio, si para compilar utilizas Visual Studio Code con la extensión Code Runner, tendrás que agregar “-lSDL” a la lista de argumentos de la tarea de compilación. Para eso, abre el archivo .json que encontrarás en el directorio .vscode de tu proyecto. Encontrarás algo como esto: . { \"configurations\": [ { \"name\": \"Linux\", \"includePath\": [ \"${workspaceFolder}/**\" ], \"defines\": [], \"compilerPath\": \"/usr/bin/gcc\", \"cStandard\": \"gnu17\", \"cppStandard\": \"gnu++17\", \"intelliSenseMode\": \"linux-gcc-x64\", \"compilerArgs\": [ \"-lSDL\", \"-lSDL_mixer\" ] } ], \"version\": 4 } . Mira en la sección “compilerArgs”. Si esa sección no existe o existe pero no contiene la línea “-lSDL”, añádela. Si necesitas otras librerías, como SDL-mixer, añádela también. Guarda el archivo y reinicia Visual Studio Code. Si utilizas otro entorno de desarrollo distinto de Visual Studio Code, u otra extensión distinta de Code Runner dentro de Visual Studio Code, el proceso debe ser muy parecido, pero tendrás que mirar la documentación de ese entorno o de esa extensión para ver los detalles. Inicialización y terminación de la pantalla gráfica . Una vez instalada la libería y preparado el compilador, podemos usar las funciones de SDL como cualquier otra función estándar de C. Su uso es exactamente igual en Windows y en Linux, por lo que el programa que obtendremos debería compilar sin necesidad de hacerle ningún cambio en ambos sistemas. Para usar los gráficos, hay que hacer un #include &lt;SDL/SDL.h&gt; en el archivo fuente, como es natural. Aparece dos veces el nombre “SDL” porque el archivo SDL.h está dentro de una carpeta llamada SDL. Lo siguiente que hay que hacer es inicializar la pantalla gráfica. Para eso disponemos de dos funciones: SDL_Init() y SDL_SetVideoMode(): . | SDL_Init(). Debe ser la primera función en invocarse. No se puede usar ninguna otra función de SDL si antes no se ha llamado a esta. Hay que pasarle un parámetro que indica qué tipo de sistema multimedia queremos manejar (la tarjeta de vídeo, la de sonido, el CD-ROM, etc). En nuestro caso será la tarjeta de vídeo, ya que sólo nos interesa manipular gráficos. La constante para ello es SDL_INIT_VIDEO: . SDL_Init(SDL_INIT_VIDEO); . La fución SDL_Init() devuelve –1 si ocurre algún error al iniciar el sistema de gráficos. En ese caso, el programa no podrá continuar, de modo que debemos comprobar el valor devuelto por SDL_Init(). | SDL_SetVideoMode(). Esta debe ser la segunda función en invocarse, justo a continuación de SDL_Init(). Sirve para establecer el tipo de pantalla gráfica que queremos. Hay que indicarle el tamaño en píxels, el número de bits de color y los atributos de la pantalla. Por ejemplo: . SDL_SetVideoMode(1200, 960, 24, SDL_ANYFORMAT | SDL_DOUBLEBUFFER); . Esto crea una ventana gráfica de 1200x960 píxeles, con 24 bits de profundidad de color. El último parámetro, SDL_ANYFORMAT, es una constante que indica a SDL que puede seleccionar otra profundidad de color si la elegida no está disponible. Este cuarto parámetro puede tomar otros muchos valores que no vamos a ver, pero sí señalaremos que es conveniente añadir la constante SDL_DOUBLEBUFFER por motivos de rendimiento (ver ejemplo más abajo). SDL_SetVideoMode() devuelve un puntero a una estructura llamada SDL_Surface, definida en SDL.h, o NULL si ocurre algún error. Este puntero nos será imprescidible para manejar la pantalla gráfica, así que debes guardarlo en una variable. Esta variable, además, debe ser global si se va a usar en otras partes del programa, contraviniendo una de las buenas prácticas de programación más universales que existen. Sin embargo, si no lo haces así, la variable no funcionará correctamente. Aquí tienes un ejemplo de inicialización de la pantalla gráfica: . | . #include &lt;SDL/SDL.h&gt; ... SDL_Surface *pantalla; // Esta variable debe ser GLOBAL ... if (SDL_Init(SDL_INIT_VIDEO) == -1) { puts(\"Error en la inicialización del sistema de vídeo\\n\"); SDL_Quit(); exit(-1); } pantalla = SDL_SetVideoMode(1280, 960, 16, SDL_ANYFORMAT|SDL_DOUBLEBUF); if (pantalla == NULL) { puts(\"Fallo al establecer el modo de vídeo\\n\"); SDL_Quit(); exit(-1); } ... SDL_Quit(); // Esto se hace al final del programa . Tan importante como inicializar la pantalla gráfica es finalizarla. Ten en cuenta que la pantalla gráfica consume muchos recursos, y éstos deben ser liberados antes de que el programa termine su ejecución. Para eso tenemos la función SDL_Quit(), que se invoca sin argumentos (observa el ejemplo) . Dibujar gráficos en la pantalla . Ya tenemos nuestra pantalla gráfica inicializada y lista para empezar a dibujar en ella. Pero, ¿qué tipo de objetos se pueden dibujar? . Aunque las librerías gráficas permiten al programador pintar píxels individuales en cualquier punto de la pantalla, lo habitual es trabajar con imágenes previamente existentes llamadas sprites. Un sprite es una imagen guardada en un archivo que puede ser cargada por el programa y mostrada en cualquier parte de la pantalla gráfica y tantas veces como sea necesario. Por lo tanto, lo primero que necesitas es hacerte con una colección de sprites para tu programa. Si, por ejemplo, suponemos que estamos desarrollando un de ajedrez, necesitaríamos los siguientes: . | Una imagen del tablero. | Una imagen de cada una de las piezas. | Opcionalmente, una imagen de fondo para decorar la pantalla. | . Los archivos con las imágenes deben estar en formato BMP. SDL admite otros formatos, pero el BMP es fácil de manipular, así que es buena idea empezar por las imágenes BMP y luego, cuando ya las manejes bien, dar el salto a otros formatos con compresión, como JPG o PNG. Cualquier editor de imágenes te permitirá convertir tus sprites a BMP. Para dibujar una imagen en cualquier punto de la pantalla, hay que hacer dos cosas que pasamos a describir con detalle: . | Cargar la imagen en la memoria (procedente de un archivo BMP) | Mostrar la imagen en la pantalla | . 1. Cargar imágenes en la memoria . Sólo es necesario cargar las imágenes una vez. Normalmente, se hará al principio del programa, justo después de la inicialización de SDL. Una vez cargadas en la memoria, podremos utilizarlas tantas veces como las necesitemos, a menos que liberemos el espacio de memoria que ocupan. La liberación de espacio, por tanto, debería hacerse al final del programa, justo antes de terminar. Para cargar una imagen BMP se usa la función SDL_LoadBMP(), de esta forma: . SDL_Surface *tablero; tablero = SDL_LoadBMP(\"tablero.bmp\"); if (tablero == NULL) { printf(\"Error al cargar el archivo tablero.bmp\"); SDL_Quit(); exit(-1); } . Observa que SDL_LoadBMP() devuelve un puntero a SDL_Surface. Este puntero será necesario para luego mostrar la imagen en cualquier lugar de la pantalla. La variable “tablero” debe ser global si se va a usar en más de una función (si es local y la pasamos como parámetro a otra función, SDL fallará). Las imágenes son rectangulares. En muchas ocasiones, necesitamos mostrar una imagen encima de otra. Es el caso de las piezas, que se mostrarán encima del tablero. Cuando esto ocurre, el color de fondo de la pieza (que decidimos que fuera negro) aparecerá encima del tablero como un desagradable recuadro de color negro. En estas situaciones, hay que avisar a SDL de que, para este sprite en concreto, el color negro (o el que decidamos) va a ser transparente, es decir, no debe ser mostrado. Esto se hace así: . SDL_Surface *peon_blanco; Uint32 color; // Para definir el color de transparencia (donde proceda) // Cargamos la imagen del peón blanco peon_blanco = SDL_LoadBMP(\"peon_blanco.bmp\"); if (peon_blanco == NULL) { printf(\"Error al cargar el archivo peon_blanco.bmp\"); SDL_Quit(); exit(-1); } // Definimos la transparencia (color negro = (0,0,0) ) color = SDL_MapRGB(peon_blanco-&gt;format, 0, 0, 0); SDL_SetColorKey(cuadro1, SDL_SRCCOLORKEY | SDL_RLEACCEL, color); . Las imágenes cargadas en memoria deben ser liberadas antes de finalizar el programa con una llamada a SDL_FreeSurface(). Por ejemplo, para liberar la memoria ocupada por la imagen “tablero.bmp” que hemos cargado antes usaremos el puntero que obtuvimos al cargarla, así: . SDL_FreeSurface(tablero); . 2. Mostrar imágenes en la pantalla . Una vez cargada una imagen BMP en la memoria, podemos mostrarla en la pantalla a través del puntero SDL_Surface que obtuvimos al cargarla. Una imagen cargada puede ser mostrada todas las veces que queramos en cualquier posición de la pantalla. Por ejemplo, para mostrar la imagen del tablero (que cargamos en un ejemplo del apartado anterior) haríamos lo siguiente (luego comentamos el código): . SDL_Rect rect; rect = (SDL_Rect) {10, 10, 400, 400}; SDL_BlitSurface(tablero, NULL, pantalla, &amp;rect); SDL_Flip(pantalla); . La variable rect es de tipo SDL_Rect, y define un área rectangular de la pantalla. El área rectangular empieza en las coordenadas (10, 10) (esquina superior izquierda de la pantalla) y mide 400 píxels de ancho y 400 de alto, es decir, termina en (410, 410). SDL_BlitSurface() es la función que se encarga de mostrar en la pantalla un sprite. La variable tablero es de tipo SDL_Surface, y debe ser la que nos devolvió SDL_LoadBMP() al cargar la imagen del tablero. La variable pantalla también es una SDL_Surface, y debe ser la que nos devolvió SDL_SetVideoMode() al inicializar la pantalla gráfica. Ya dijimos que los punteros que nos devuelven estas funciones son imprescidibles y que debíamos definirlos como variables globales. La variable rect es el área rectangular que acabamos de definir. Fíjate que rect es la que indica en qué lugar de la pantalla va a aparecer el sprite. En este ejemplo, aparecerá en (10,10). Se le han reservado 400x400 píxels para dibujarse, es decir, hasta la posición (410, 410). Si el sprite es más pequeño, no pasará nada (ocupará lo que mida realmente). Si es más grande, se truncará. Por último, SDL_Flip() hace que lo que acabamos de dibujar se muestre realmente en la pantalla. Su efecto es parecido al de la función refresh() de ncurses. En realidad, todo lo que dibujamos se escribe en una zona de memoria específica y, al hacer SDL_Flip(), esa zona de memoria se vuelca sobre la memoria de vídeo, apareciendo todo en la pantalla. Esto representa el movimiento de gran cantidad de información entre distintas zonas de memoria, lo cual es un proceso relativamente lento. Por eso, si vamos a dibujar varios sprites consecutivos, es mejor hacer una sola vez SDL_Flip(), al final, cuando los hayamos dibujado todos. Llamar a SDL_Flip() después de dibujar cada sprite ralentizará notablemente el funcionamiento de nuestro programa. Control del teclado . Para leer el teclado en una ventana gráfica creada con SDL no se pueden usar las funciones estándar (como getchar() o gets()), ni mucho menos las de ncurses (como getstr()). SDL solo permite leer los caracteres de uno en uno, y no muestra eco por la pantalla (si queremos eco, tenemos que mostrar los caracteres nosotros mismos después de leerlos). Por lo demás, la forma de capturar un carácter tecleado es similar a la de ncurses, solo que un poco más complicada. A continuación se muestra un código de ejemplo: . SDL_Event evento; // Para leer el teclado // Leer teclado if (SDL_PollEvent(&amp;evento)) // Comprobar si se ha pulsado una tecla { if (evento.type == SDL_KEYDOWN) // Efectivamente, se ha pulsado una tecla { switch (evento.key.keysym.sym) // Vamos a mirar qué ecla es { case SDLK_UP: ...acciones...; break; // Flecha arriba case SDLK_DOWN: ...acciones...; break; // Flecha abajo case SDLK_LEFT: ...acciones...; break; // Felcha izquierda case SDLK_RIGHT: ...acciones...; break; // Flecha derecha case SDLK_RETURN: ...acciones...; break; // Intro case SDLK_ESCAPE: ...acciones...; break; // ESC case SDLK_m: ...acciones...; break; // Tecla \"m\" (menú) } } } . Existen constantes para cualquiera de las otras teclas del teclado. Todas empiezan por SDLK_. Por ejemplo, la tecla “a” tendrá el código SDLK_a. Definición de colores . Aunque a menudo trabajes con sprites basados en imágenes preexistentes, es posible que también necesites definir algún color para usarlo directamente sobre la pantalla gráfica (por ejemplo, para usar transparencias o para escribir un texto). En SDL no hay colores predefinidos, como en ncurses. Los colores debemos definirlos nosotros mezclando los colores básicos RGB (rojo, verde y azul). Hay dos formas de definir un color: con una variable de tipo SDL_Color o con una variable de tipo Uint32. El uso de una u otra dependerá de para qué queramos usar ese color: . a) Con una variable de tipo SDL_Color: . SDL_Color color; color = (SDL_Color) {50, 150, 200, 255}; . Los cuatro números definen el color. Deben ser números comprendidos entre 0 y 255. El primero es el nivel de rojo (R), el segundo el nivel de verde (G) y el tercero, el nivel de azul (B). El cuarto número es el brillo. El color definido en este ejemplo tiene mucho azul, bastante verde y poco rojo. El resultado debe ser un azul amarillento. b) Con una variable de tipo Uint32: . Uint32 color; color = SDL_MapRGB(pantalla-&gt;format, 50, 150, 200); . En esta ocasión, pantalla debe ser un puntero a una imagen SDL_Surface que hayamos cargado previamente. Los tres valores siguientes son los niveles RGB. No hay nivel de brillo, porque éste se toma de la imagen apuntada por pantalla. De las dos maneras se pueden definir colores para usarlos posteriormente. Si el color lo necesitamos para una transparencia, recurriremos al segundo método (de hecho, ya vimos un ejemplo de ello al estudiar cómo se cargaban y mostaban las imágenes en SDL; allí usamos el color negro como transparencia). Si el color lo necesitamos para escribir un texto en la pantalla gráfica, usaremos el primer método (como se podrá ver en el siguiente apartado) . Mostrar texto en la pantalla gráfica: instalación y uso de la librería SDL_TTF . La librería SDL no permite directamente la escritura de texto en la pantalla gráfica. Esto se debe a que la pantalla gráfica, por definición, no admite caracteres, sino únicamente imágenes. Por fortuna, a la sombra de SDL se han creado multitud de librerías adicionales que, partiendo de SDL, complementan y mejoran sus prestaciones. Una de ellas es SDL_TTF. La libería SDL_TTF permite cargar fuentes true type que estén guardadas en archivos .ttf y manejarlas como si fueran imágenes BMP en la pantalla gráfica generada por SDL. Necesitamos SDL_TTF, por lo tanto, para escribir los mensajes de usuario y las opciones del menú. La instalación de la librería SDL_TTF es similar a la de SDL, tanto en Linux como en Windows, de modo que puedes remitirte al apartado correspondiente para recordar cómo se hacía. Lo mismo puede decirse en cuanto a la compilación y el enlace. Igual que SDL, la librería SDL_TTF necesita ser inicializada antes de usarla, y finalizada antes de terminar el programa para liberar los recursos adquiridos. Como SDL_TTF corre por debajo de SDL, debe ser inicializada después de SDL, y debe ser terminada antes que SDL. Observa cómo se hace en este ejemplo: . if(TTF_Init() == -1) { printf(\"Fallo al inicializar SDL_TTF\"); exit(-1); } . Inmediatamente después, ya podemos cargar una fuente true type de un archivo TTF, así: . TTF_Font* fuente; .... fuente = TTF_OpenFont(\"arial.ttf\", 14); if(fuente == NULL) { printf(\"Fallo al abrir la fuente\"); exit(-1); } TTF_SetFontStyle(fuente, TTF_STYLE_BOLD); . La variable fuente es un puntero a TTF_Font. Debe ser una variable global por el mismo motivo que las variables SDL_Surface. La función TTF_OpenFont() abre el archivo “arial.ttf” y carga el tipo de letra Arial en tamaño 14 para su uso en el programa. Después es conveniente comprobar que el puntero fuente contenga un valor válido y no NULL. | Por último, la función TTF_SetFontStyle() puede usarse para determinar el estilo de la fuente. Tenemos varias posibilidades: TTF_STYLE_BOLD (negrita), TTF_STYLE_ITALIC (cursiva), TTF_STYLE_UNDERLINE (subrayado) y TTF_STYLE_NORMAL. Si queremos combinar varios estilos, podemos separarlos por el operador “ | ”. Por ejemplo, para poner la fuente en negrita y cursiva escribiríamos esto: | . TTF_SetFontStyle(fuente, TTF_STYLE_BOLD | TTF_STYLE_ITALIC); . El proceso de finalización del SDL_TTF es inverso y complementario al de inicialización. Primero habrá que liberar todas las fuentes cargadas durante la inicialización, y luego hay que terminar el subsistema SDL_TTF: . TTF_CloseFont(fuente); TTF_Quit(); . La variable fuente será de tipo TTF_Font, y debe coincidir con la que nos devolvió la función TTF_OpenFont(). Esta operación la repetiremos con cada una de las fuentes que hayamos cargado. Recuerda que todo esto debe hacerse ANTES de SDL_Quit(), ya que SDL_TTF depende de SDL. Escribir texto con SDL_TTF . Todo esto lo hacemos con un objetivo: poder escribir texto en la pantalla gráfica y sustituir así todas las funciones printw() y similares. Para escribir un texto hay que hacer dos cosas: primero, convertirlo en una imagen; segundo, mostrar la imagen en la pantalla. La conversión de un texto en una imagen se hace con la función TTF_Render(): . SDL_Color color; SDL_Surface* txt_img; color = (SDL_Color) {255,100,100,255}; txt_img = TTF_RenderText_Blended(fuente, \"Hola mundo\", color); if(txt_img == NULL) { printf(\"Fallo al renderizar el texto\"); exit(-1); } . Como ves, hay que hacer bastantes cosas para mostrar un texto en la pantalla gráfica, pero todo es acostumbrarse. Primero, hay que definir un color para el texto (cómo se definen los colores es algo que vimos en el epígrafe anterior). En este caso, hemos escogido un rojo brillante. Después se invoca a TTF_RenderText(), pasándole como parámetros el puntero a la fuente que obtuvimos con TTF_OpenFont(), el texto que queremos mostrar y el color. La función nos devuelve un puntero de tipo SDL_Surface que, si recuerdas, es exactamente el mismo que usábamos con las imágenes cargadas desde un archivo BMP. En realidad, la función TTF_RenderText() tiene tres formas: . | TTF_RenderText_Solid() - realiza una conversión del texto en imagen rápida pero de poca calidad. | TTF_RenderText_Shaded() - la imagen resultante es de gran calidad pero tiene un recuadro negro alrededor | TTF_RenderText_Blended() - la imagen resultante es de gran calidad y sin recuadro negro | . En general preferiremos el modo Blended, que es el que proporciona mejores resultados. El modo Shaded se puede usar en determinados lugares (si no hay otra imagen debajo del texto). El modo Solid sólo debe usarse si hay que mostrar mucho texto y el modo Blended se revela demasiado lento. Hasta aquí, sólo hemos convertido el texto “Hola mundo” en una imagen, pero aún no la hemos mostrado en la pantalla. Para hacerlo procederemos como con cualquier otra imagen: . // Mostramos el texto como si fuera una imagen rect = (SDL_Rect) { 500, 280, 100, 30 }; SDL_BlitSurface(txt_img, NULL, pantalla, &amp;rect); SDL_Flip(scr); . Se supone que rect es de tipo SDL_Rect y que pantalla es el puntero a SDL_Surface que nos devolvió SDL_SetVideoMode() al inicializar SDL. Así, el texto “Hola mundo” se mostrará en la posición (500, 280) de la pantalla gráfica, reservándose para él 100 píxels de ancho y 30 de alto. ",
    "url": "https://iescelia.org//docs/tico/_site/c-avanzado/",
    "relUrl": "/c-avanzado/"
  },"41": {
    "doc": "9.5. Un ejemplo completo. Las tres en raya",
    "title": "9.5. Un ejemplo completo: las tres en raya",
    "content": ". | 9.6.1. El código fuente | 9.6.2. ¿Cómo ejecutar y depurar este programa? | . Llegó la hora de poner manos a la obra. Si hay una sección de este capítulo que tienes que leer con atención, es esta. Así que es un mal momento para tener prisa. Vamos a escribir un programa completo en C. Te puede servir de plantilla para desarrollar tus propios programas a partir de este código fuente. El programa en cuestión será una versión del juego de las tres en raya que encontrarás resuelta en pseudocódigo el tema de introducción a la programación. No dudes en repasar aquel ejercicio resuelto para ver el pseudocódigo, puesto que nuestro programa será una traducción literal de ese pseudocódigo a C. Aquí tienes el código fuente completo. Estúdialo con atención y asegúrate de entenderlo todo (o un gran porcentaje) antes de continuar. Ah, y no dejes de compararlo línea a línea con el mismo código en pseudocódigo. 9.6.1. El código fuente . #include &lt;stdio.h&gt; //------------------------- // ALGORITMO PRINCIPAL //------------------------- int main(void) { char tablero[10]; int ganador = 0; // 0 = ninguno, 1 = humano, 2 = ordenador int tablas; // 0 = no hay tablas, 1 = sí hay tablas inicializar(tablero); // Esto es un subalgoritmo. Está escrito más abajo do { mostrar(tablero); colocar_pieza_humano(tablero); ganador = comprobar_ganador(tablero); tablas = comprobar_tablas(tablero); if ((ganador == 0) &amp;&amp; (tablas == 0)) { colocar_pieza_ordenador(tablero); ganador = comprobar_ganador(tablero); tablas = comprobar_tablas(tablero); } } while ((ganador == 0) &amp;&amp; (tablas == 0)); mostrar(tablero); if (ganador == 0) { printf(\"EL JUEGO HA TERMINADO EN TABLAS\\n\"); } else if (ganador == 1) { printf(\"EL JUEGO HA TERMINADO Y HAS GANADO TÚ\\n\"); } else { printf(\"EL JUEGO HA TERMINADO Y HE GANADO YO\\n\"); } } // -------------------------------------------- // Inicializa el tablero con espacios en blanco // -------------------------------------------- void inicializar(char tablero[10]) { int i; for (i = 1; i &lt;= 9; i++) { // Como tablero es un array, se pasa por referencia y los cambios que // hagamos aquí se reflejarán en el algoritmo principal tablero[i] = ' '; } } // -------------------------------------------- // Muestra el estado actual del tablero // -------------------------------------------- void mostrar(char tablero[10]) { printf(\"ESTADO ACTUAL DEL TABLERO\\n\"); printf(\"+-+-+-+\\n\"); printf(\"|%c|%c|%c|\\n\", tablero[1], tablero[2], tablero[3]); printf(\"+-+-+-+\\n\"); printf(\"|%c|%c|%c|\\n\", tablero[4], tablero[5], tablero[6]); printf(\"+-+-+-+\\n\"); printf(\"|%c|%c|%c|\\n\", tablero[7], tablero[8], tablero[9]); printf(\"+-+-+-+\\n\"); } // --------------------------------------------------- // Coloca una pieza del jugador humano en el tablero // --------------------------------------------------- void colocar_pieza_humano(char tablero[10]) { int casilla; int casilla_correcta = 0; do { printf(\"¿En qué casilla quieres poner una pieza? (1-9)\"); scanf(\"%d\", &amp;casilla); if (tablero[casilla] == ' ') { tablero[casilla] = 'X'; casilla_correcta = 1; } else { printf(\"Error: Esa casilla ya está ocupada\\n\"); } } while (casilla_correcta == 0); } // --------------------------------------------------- // Coloca una pieza del ordenador en el tablero // --------------------------------------------------- void colocar_pieza_ordenador(char tablero[10]) { int casilla; int casilla_correcta = 0; srand(time(NULL)); do { casilla = rand() % 10; printf(\"Voy a colocar mi pieza en la casilla \", casilla); if (tablero[casilla] == ' ') { tablero[casilla] = 'O'; casilla_correcta = 1; } else { printf(\"¡Está ocupada! Voy a elegir otra\"); } } while (casilla_correcta == 0); } // --------------------------------------------------- // Comprueba si hay un ganador según el estado del // tablero. Devuelve \"Ninguno\", \"Humano\" u \"Ordenador\" // --------------------------------------------------- int comprobar_ganador(char tablero[10]) { int ganador = 0; // Comprobamos primera fila if ((tablero[1] == tablero[2]) &amp;&amp; (tablero[1] == tablero[3])) { if (tablero[1] == 'X') { ganador = 1; } if (tablero[1] == 'O') { ganador = 2; } } // Comprobamos segunda fila if ((tablero[4] == tablero[5]) &amp;&amp; (tablero[4] == tablero[6])) { if (tablero[4] == 'X') { ganador = 1; } if (tablero[4] == 'O') { ganador = 2; } } // Comprobamos tercera fila if ((tablero[7] == tablero[8]) &amp;&amp; (tablero[7] == tablero[9])) { if (tablero[7] == 'X') { ganador = 1; } if (tablero[7] == 'O') { ganador = 2; } } // Comprobamos primera columna if ((tablero[1] == tablero[4]) &amp;&amp; (tablero[1] == tablero[7])) { if (tablero[1] == 'X') { ganador = 1; } if (tablero[1] == 'O') { ganador = 2; } } // Comprobamos segunda columna if ((tablero[2] == tablero[2]) &amp;&amp; (tablero[2] == tablero[8])) { if (tablero[2] == 'X') { ganador = 1; } if (tablero[2] == 'O') { ganador = 2; } } // Comprobamos tercera columna if ((tablero[3] == tablero[6]) &amp;&amp; (tablero[3] == tablero[9])) { if (tablero[3] == 'X') { ganador = 1; } if (tablero[3] == 'O') { ganador = 2; } } // Comprobamos una diagonal if ((tablero[1] == tablero[5]) &amp;&amp; (tablero[1] == tablero[9])) { if (tablero[1] == 'X') { ganador = 1; } if (tablero[1] == 'O') { ganador = 2; } } // Comprobamos la otra diagonal if ((tablero[3] == tablero[5]) &amp;&amp; (tablero[3] == tablero[7])) { if (tablero[3] == 'X') { ganador = 1; } if (tablero[3] == 'O') { ganador = 2; } } return ganador; } // ------------------------------------------- // Comprueba si hay una situación de tablas // según el estado actual del tablero. Devuelve // verdadero si hay tablas o falso en otro caso. // ------------------------------------------- int comprobar_tablas(char tablero[10]) { int tablas = 0; int i, contador = 0; for (i = 1; i &lt;= 9; i++) { if (tablero[i] != ' ') { contador++; } } // Si todas las casillas están ya ocupadas y no hay ganador, // entonces estamos en tablas. if (contador == 9) { tablas = 1; } else { tablas = 0; } return tablas; } . 9.6.2. ¿Cómo ejecutar y depurar este programa? . Guarda el programa anterior en un archivo de texto con extensión .c (por ejemplo, 3enraya.c). Si estás trabajando con Visual Studio Code con la extensión Code Runner, como hemos recomendado, puedes ejecutar tu programa directamente desde ahí. Basta con que pulses el botón “Play” de la esquina superior derecha. Se abrirá una consola en la parte de abajo donde tu programa se ejecutará. ¡Socorro! El programa no funciona . ¿El resultado no es el esperado? Es lo habitual. Habrá algún error en el código y te tocará depurarlo. En la ventana inferior de Visual Studio Code verás varias pestañas. | En la pestaña Terminal verás el resultado de la ejecución de tu programa. | En la pestaña Problems verás la lista de errores que el compilador ha encontrado en tu programa. En tal caso, en el Terminal solo verás un lenguaje de tipo “La compilación ha terminado con errores”. | . Los mensajes pueden estar en español o en inglés, dependiendo del compilador, pero ¿qué esperabas? Si quieres aprender a programar, tienes que acostumbrarte a manejar el inglés técnico. El mensaje de error te dará información sobre lo que hay de malo en tu código y te dirá en qué línea, aproximadamente, está el error. Cuando lo hayas localizado, regresa a tu editor de texto, haz los cambios necesarios, guarda las modificaciones y vuelve a compilar y ejecutar el programa (pulsando de nuevo el botón “Play”). Y así hasta que funcione. ¡Mucha paciencia y sangre fría! Recuerda siempre que la mayor parte del tiempo de programación se va en depurar programas, no en escribirlos. ",
    "url": "https://iescelia.org//docs/tico/_site/ejemplo-completo-3-en-raya/#95-un-ejemplo-completo-las-tres-en-raya",
    "relUrl": "/ejemplo-completo-3-en-raya/#95-un-ejemplo-completo-las-tres-en-raya"
  },"42": {
    "doc": "9.5. Un ejemplo completo. Las tres en raya",
    "title": "9.5. Un ejemplo completo. Las tres en raya",
    "content": " ",
    "url": "https://iescelia.org//docs/tico/_site/ejemplo-completo-3-en-raya/",
    "relUrl": "/ejemplo-completo-3-en-raya/"
  },"43": {
    "doc": "9.6. Ejercicios propuestos",
    "title": "9.6. Ejercicios propuestos",
    "content": ". | 9.6.1. Ejercicios básicos | 9.6.2. Ejercicios avanzados | . 9.6.1. Ejercicios básicos . Ejercicio 1. Hola mundo . En este ejercicio, vamos a preparar nuestro entorno de trabajo. | Instala Visual Studio Code. Puedes descargarlo de https://code.visualstudio.com/download o bien instalarlo desde la tienda de aplicaciones de tu sistema operativo. | Abre Visual Studio Code y haz clic en el botón de extensiones (en el panel izquierdo). Busca una extensión llamada “C/C++ IntelliSense” e instálala. | Escribe un programa que salude con un “Hola, mundo”. Encontrarás el código más abajo. Este programa es un clásico en el mundillo de la programación; siempre se usa para comprobar si un nuevo entorno de desarrollo está funcionando bien. | Ejecútalo y asegúrate de que el resultado es el esperado. Si algo falla, llama al profesor y no pases al siguiente ejercicio hasta dejar tu Visual Studio Code en perfecto estado de funcionamiento. | . #include &lt;stdio.h&gt; int main() { printf(\"Hola, mundo\\n\"); return 0; } . Ejercicio 2. Convertir de euros a dólares . Vamos a empezar por algo sencillito. Escribe un programa en C capaz de leer un número real y un tipo de moneda, que puede ser “euro” o “dólar”, y que convierta al tipo de moneda indicado, suponiendo que está expresada en la otra. Por ejemplo, si la cantidad es 15 y la moneda es “dólar”, se supondrá que se trata de 15 € y que hay que convertirlos a dólares. Utiliza el tipo de cambio que esté vigente el día en el que escribas el programa.&lt;/div&gt; . Ejercicio 3. Tabla de multiplicar . Escribe un programa en C que pida un número y muestre la tabla de multiplicar de ese número. Por ejemplo, si el usuario del programa escribe el número 3, la salida del programa debe ser: . 3 x 1 = 3 3 x 2 = 6 3 x 3 = 9 3 x 4 = 12 3 x 5 = 15 3 x 6 = 18 3 x 7 = 21 3 x 8 = 24 3 x 9 = 27 3 x 10 = 30 . Entre los ejercicios resueltos encontrarás uno que utiliza bucles y que puedes usar como modelo para hacer este. Ejercicio 4. Juego del número secreto . Ahora algo solo un poquito más complicado: una versión en C del clásico juego del número secreto. Se trata de un juego en el que el ordenador “piensa” un número al azar entre 1 y 100 y el jugador tiene que adivinarlo. Cada vez que el jugador escribe un número, el programa le dice: “Mi número secreto es mayor” o “Mi número secreto es menor”. Cuando el jugador por fin acierta, el ordenador le dice: “Enhorabuena, has acertado”, y añade el número de intentos que ha necesitado para acertar el número secreto. Ejercicio 5. Calculadora de edad . Escribe un programa que te pregunte tu fecha de nacimiento y la fecha actual. Luego, tiene que decirte cuál es tu edad EXACTA, en años, meses y días. Ejercicio 6. Estadística básica . Escribe un programa que utilice un array de 30 números enteros para almacenar la estatura de los 30 estudiantes de una clase de bachillerato. Posteriormente, el programa preguntará al usuario las estaturas de los 30 estudiantes (en centímetros) y las almacenará en el array. Después, mostrará la estatura del más alto, la del más bajo, el promedio, la mediana y la moda. Recuerda que: . | El promedio se calcula sumando todas las estaturas y dividiéndolas entre 30. | La mediana es el número intermedio de un grupo de números. | La moda es el número de la serie que aparece con mayor frecuencia. | . Entre los ejercicios resueltos, encontrarás uno que utiliza arrays y que puedes usar como modelo para hacer este. 9.6.2. Ejercicios avanzados . Ejercicio 7. Pelota que rebota . Escribe un programa en C que muestre una pelota moviéndose por la pantalla y rebotando en sus bordes. La pelota se puede simular con el carácter “O”, escribiéndolo en diferentes celdas de la pantalla cada vez. (Para este ejercicio necesitarás usar la librería ncurses) . Puedes realizar el programa en tres fases sucesivas. Para aprobar la actividad debes completar al menos la primera fase. Para sacar un 10 tienes que terminar la tercera fase. | FASE 1: la “pelota” se mueve y rebota por la pantalla, pero va dejando un “rastro” de Oes. | . O O O O O O O O O O O O O O O . | FASE 2: la “pelota” se mueve por la pantalla sin dejar rastro. Es decir, cada vez que se escribe la “O” en una nueva posición, se borra de la posición que ocupaba anteriormente. El resultado debe dar sensación de movimiento sin parpadeos. | . O . FASE 3: la “pelota” se mueve por la pantalla dejando una “estela” de cuatro o cinco “Oes” (u otros caracteres, como en la figura) a su paso. o o O . Ejercicio 8. Juego de automovilismo . Escribe un programa que simule un sencillo juego de automovilismo. La pantalla del juego debe tener un aspecto parecido a este: . | | | | | | | | | | | | H | . El jugador (cuyo vehículo representaremos con una H) puede mover su coche hacia la izquierda y hacia la derecha. Su objetivo es no salirse de la carretera, que tiene los límites marcados por un carácter “|” a cada lado. Si se sale, pierde una vida. Si pierde tres vidas, la partida termina y el programa debe mostrar el tiempo que el conductor ha conseguido aguantar sin perder sus vidas. La carretera se va desplazando de abajo a arriba, aprovechándose del scroll propio de la pantalla de texto. La carretera no debe ser recta, sino que tendrá irregularidades, como las mostradas en la figura, generadas al azar. Ejercicio 9: Proyecto. En lugar de continuar haciendo ejercicios de programación chorras, vamos a plantear un pequeño proyecto individual. La idea es que cada uno/una elija un proyecto y lo desarrolle en lo que queda de curso. Se trata de programas un poco más grandes que los ejercicios anteriores, pero no tan grandes que no se puedan afrontar con éxito. A continuación te propongo una lista de proyectos posibles basados en juegos clásicos. Si no encuentras nada que te guste, puedes elegir tu propio proyecto (antes de darlo por bueno, coméntalo con el profesor). Puedes empezar por una versión muy simple del programa (sin usar gráficos, que funcione mínimamente, etc) y, dependiendo del tiempo que tengas disponible, ir ampliando sus funcionalidades y mejorando su aspecto visual. O incluso añadir efectos de sonido. | Hundir la flota | Snake | Buscaminas | Pong | Ahorcado | Damas | Ajedrez | Space Invaders | Tetris | Tenis | Palabras cruzadas | Otros (libre elección -&gt; comentar con el profesor). | . ",
    "url": "https://iescelia.org//docs/tico/_site/ejercicios-propuestos-c/",
    "relUrl": "/ejercicios-propuestos-c/"
  },"44": {
    "doc": "9.7. Ejercicios resueltos",
    "title": "9.7. Ejercicios resueltos",
    "content": "Aquí iremos poniendo los ejercicios que resolvamos en clase. Contar números . Este programa cuenta números desde 1 hasta n, siendo n un número introducido por el usuario. Puedes usarlo como modelo para escribir el programa de la tabla de multiplicar. #include &lt;stdio.h&gt; int main(void) { int n, i; printf(\"Dime un número: \\n\"); scanf(\"%d\", &amp;n); printf(\"Los números entre 1 y %d son:\\n\", n); for (i = 1; i &lt;= n; i++) { printf(\"%d\\n\", i); } return 0; } . Factorial . Este programa calcula el factorial de un número n introducido por teclado. Ten en cuenta que el factorial crece exponencialmente con el valor de n, de modo que, si escribes un número muy grando, el cálculo se desboradará y obtendrás un resultado erróneo. Este es otro ejemplo de uso de los bucles que puedes usar como modelo para resolver los ejercicios propuestos. #include &lt;stdio.h&gt; int main(void) { int n, i, acumulador; do { printf(\"Dime un número mayor que 0: \\n\"); scanf(\"%d\", &amp;n); } while (n &lt;= 0); acumulador = n; for (i = n-1; i &gt;= 1; i--) { acumulador = acumulador * i; } printf(\"El factorial de %d es %d\\n\", n, acumulador); return 0; } . Calcular media y mediana . El siguiente programa crea un array de 5000 números enteros y les asigna valores al azar entre 1 y 1000. Después, recorre el array para calcular el valor medio y la mediana de todos los números generados. Recuerda que la mediana es el valor de la serie que más se aproxima al promedio. Si la serie es lo suficientemente grande, el promedio debería ser muy cercano a 500 y la mediana coincidir con el promedio. En cambio, si disminuyes la longitud del array, el promedio se alejará más de 500 y la mediana solo coincidirá con la media a veces. int main(void) { int i, array[5000]; int minima_diferencia; long int suma = 0; float media, mediana; srand(time(NULL)); // Inicializa el generador de números aleatorios // Genera el array al azar for (i = 0; i &lt; 5000; i++) { array[i] = rand() % 1000 + 1; suma = suma + array[i]; } // Muestra el array for (i = 0; i &lt; 5000; i++) { printf(\"%d - \", array[i]); } // Calcula el promedio media = suma / 5000; // Calcula la mediana (el valor más cercano al promedio) minima_diferencia = media; for (i = 0; i &lt; 5000; i++) { if (abs(array[i] - media) &lt; minima_diferencia) { minima_diferencia = abs(array[i] - media); mediana = array[i]; } } // Muestra los resultados printf(\"\\n\\n\"); printf(\"La suma de los 5000 números es: %ld\\n\", suma); printf(\"La media de los 5000 números es: %f\\n\", media); printf(\"La mediana de los 5000 números es: %f\\n\", mediana); return 0; } . ",
    "url": "https://iescelia.org//docs/tico/_site/ejercicios-resueltos-c/",
    "relUrl": "/ejercicios-resueltos-c/"
  },"45": {
    "doc": "1. Bases de datos",
    "title": "1. Bases de datos",
    "content": ". | 1.1. Almacenamiento de la información . | 1.1.1. Sistemas lógicos de almacenamiento | 1.1.2. Sistemas de ficheros | 1.1.3. Bases de datos | . | 1.2. El modelo de datos . | 1.2.1. Diagramas E-R | 1.2.2. Elementos de los diagramas E-R | . | 1.3. Paso del diagrama E-R al modelo relacional . | 1.3.1. Qué es el modelo relacional | 1.3.2. Pasos para convertir un diagrama E-R en un modelo relacional | 1.3.3. Conceptos clave del modelo relacional | 1.3.6. Paso a tablas y normalización | . | 1.4. Ejercicios | . ",
    "url": "https://iescelia.org//docs/tico/_site/bases-de-datos/",
    "relUrl": "/bases-de-datos/"
  },"46": {
    "doc": "1. Bases de datos",
    "title": "1.1. Almacenamiento de la información",
    "content": "1.1.1. Sistemas lógicos de almacenamiento . Desde los primeros tiempos de la informática ha sido necesario almacenar grandes cantidades de información en soportes fisicos utilizando mecanismos que fueran independientes del propio soporte. Esos métodos de almacenamiento se denominan sistemas de almacenamiento lógico. Sistema de almacenamiento físico del IBM 360, un ordenador de la década de 1960. Este ordenador utilizaba principalmente cintas magnéticas en lugar de discos duros para almacenar la información. En teoría, los usuarios no deberían ser conscientes de ello. Los sistemas de almacenamiento lógico nos permiten olvidarnos de cuál es el dispositivo físico donde se almacena realmente la información. El sistema lógico de almacenamiento más habitual es el sistema de ficheros. En él, la información se organiza en directorios (o carpetas) y ficheros, y luego un componente software del sistema operativo se encarga de traducir las operaciones lógicas sobre la información (por ejemplo, añadir un dato al final de un fichero) en operaciones físicas (por ejemplo, escribir un byte en determinado sector del disco duro). Las bases de datos que estudiaremos en este capítulo también son sistemas lógicos de almacenamiento, solo que más complejos que los sistemas de ficheros. El componente software encargado de traducir operaciones lógicas en físicas se denomia sistema gestor de bases de datos, y en este capítulo y el siguiente vamos a aprender a familiarizarnos con él. 1.1.2. Sistemas de ficheros . Antes de comenzar a pelearnos con las bases de datos, conviene conocer por encima a su hermano pobre: el sistema de ficheros. Los archivos o ficheros son almacenes de información con una estructura determinada que se organizan en directorios (o carpetas) con organización jerárquica. Existen muchos sistemas de ficheros, dependiendo del sistema operativo: . | FAT16: del antiguo MS-DOS y Windows 95. | FAT32: se introdujo en Windows 95 OSR2 y aún se usa masivamente a pesar de sus limitaciones. ¿Qué limitaciones son esas? Por ejemplo, no puede menejar archivos de más de 4 GB. | exFAT: un sistema FAT extendido, sin las limitaciones de FAT32, usado por Windows de forma nativa desde Windows 7. Generalmente se utiliza en memorias USB. | NTFS: usado por los sistemas Windows desde Windows NT. | ext2, ext3 y ext4: sistemas por defecto en la mayoría de las distribuciones Linux. | ReiserFS: otro sistema de ficheros soportado por las distribuciones Linux. | CDFS o ISO 9660: Es el sistema de ficheros nativo de los CD-ROM. | UDF o ISO 13346: Es un sistema de ficheros estandarizado usado en CDs, DVDs y Blu-Rays. | HFS+: sistema de ficheros nativo de MacOS. | . Los ficheros, a su vez, pueden ser de diferente tipo, según cómo se codifique la información en su interior: . | Ficheros de texto: almacenan la información como texto, generalmente codificado como UTF-8. Estos ficheros pueden contener información de configuración de aplicaciones (ficheros .ini, .inf, .conf, etc), de código fuente (.html, .sql, .java, .php, etc), de texto plano o enriquecido (.txt, .rtf, .ps, etc) o información compleja codificada como XML o JSON (.xml, .json). | Ficheros binarios: son colecciones de bits con un formato específico que sólo pueden ser interpretadas por el programa adecuado. Hay incontables tipos de fichero binario: de imagen (.jpg, .gif, .png, etc), de vídeo (.avi, .mpg, .mp4, etc), comprimidos o empaquetados (.zip, .rar, .tar, .gz, etc), ejecutables y compilados (.exe, .com, .o, etc) y muchísimos más. | . Cada programa suele tener su propio formato de fichero nativo. Y los gestores de bases de datos no son una excepción. Por ejemplo . | Access guarda las bases de datos en un fichero con extensión .mdb o .accdb | MySQL guarda las bases de datos en tres ficheros de extensión .frm, .myd y .myi | . 1.1.3. Bases de datos . Una base de datos es una colección de ficheros relacionados entre sí que almacenan tanto la representación abstracta de un fragmento de información del mundo real como los datos correspondientes a ese fragmento del mundo. Las bases de datos, por lo tanto, son sistemas de almacenamiento de información más complejos y elaborados que los ficheros, puesto que no solo guardan la información en sí, sino también la forma en la que unos datos se relacionan con otros, y además proporcionan mecanismos para manipular esos datos. No se debe confundir la base de datos (los ficheros que guardan la información) con el sistema gestor de base de datos (el software que manipula esos ficheros). Existen varios tipos de bases de datos, pero las más extendidas desde hace décadas son las bases de datos relacionales. Durante este capítulo y el siguiente, nos referiremos exclusivamente a este tipo de bases de datos. Sistemas gestores de bases de datos . Un Sistema Gestor de Bases de Datos (SGBD o DBMS en inglés) es el programa (o conjunto de programas) encargados de almacenar y manipular la información de una base de datos. Las funciones de un SGBD son: . | Permitir el acceso sencillo y eficiente a los datos | Garantizar la integridad de los datos | Garantizar la seguridad de los datos | Almacenar no solo los datos, sino la estructura de los mismos y la forma en la que se relacionan unos con otros | Mantener estadísticas de uso | Permitir la concurrencia de usuarios (accesos múltiples simultáneos) | Independizar los datos físicos de las aplicaciones de usuario | Ofercer conectividad con el exterior | Incorporar herramientas de copia de seguridad | . Existen muchos sistemas gestores de bases de datos relacionales, algunos creados para manejar de forma sencilla bases de datos pequeñas y con pocos accesos, como Microsoft Access o Libreoffice Base, y otros pensados para soportar grandes volúmenes de información y muchos accesos simultáneos, como MySQL, MariaDB, Oracle, SQL Server o PostgreSQL. Conceptos clave en bases de datos relacionales . Si hablamos exclusivamente de bases de datos relacionales (recuerda: existen otros tipos, pero las mayoritarias son las relacionales), hay ciertos conceptos que van a aparecer de forma recurrente a partir de ahora. Vamos a definirlos, pero no trates de retenerlos todos: te familiarizarás con ellos poco a poco a lo largo del capítulo. | Tabla (o relación): la información en las bases de datos relacionales se organiza en tablas compuestas por filas y columnas. | Registro: un registro es cada una de las filas de cada tabla. Por ejemplo, en la base de datos de los clientes de una empresa, la tabla de clientes contendrá un cliente en cada fila. Pues bien, cada fila es un registro. | Campo: cada registro puede descomponerse casi siempre en fragmentos más pequeños. Por ejemplo, en la tabla de clientes, para cada cliente podemos almacenar su DNI, su nombre, sus apellidos, su domicilio, email, teléfono, etc. Cada uno de estos fragmentos de información se denomina campo. | Tipo de dato: es el dominio al que pertenece cada dato almacenado en cada campo, es decir, el tipo de dato (número entero, número real, cadena de caracteres, fecha, hora, etc) | Campo clave: es un campo que permite diferenciar unívocamente cada registro. Por ejemplo, el DNI es un posible campo clave de la tabla de clientes. | Consulta: las consultas sirven para buscar y extraer información de la base de datos. Son un mecanismo muy sencillo para hacer algo muy complicado: bucear entre toneladas de información para localizar justo lo que buscamos. | Índice: la base de datos construirá índices para acelerar el acceso a las tablas más voluminosas. Es un mecanismo interno de la base de datos que casi nunca necesitaremos manipular. | . Componentes de una base de datos relacional . Los SGBD relacionales son programas muy complejos. Tanto que, independientemente de su desarrollador, suelen tener varios componentes: . | Lenguaje de definición de datos (DDL): nos permite crear la representación lógica de los datos y sus relaciones. | Lenguaje de control de datos (DCL): sirve para gestionar los permisos de acceso. | Lenguaje de control de transacciones (TCL): se utiliza para asegurar la integridad de los datos. | Lenguaje de manipulación de datos (DML): nos permite insertar datos, borrarlos, modificarlos, etc. Pueden ser lenguajes procedimentales (el programador indica cómo se van a manipular los datos) o no procedimentales (el programador indica qué manipulación desea, y el SGBD se encarga de determinar los procedimientos más apropiados). | Diccionario de datos: es una base de datos especial, porque contiene información sobre el resto de bases de datos existentes en el sistema. | Motor o monitor de la base de datos: es el interfaz entre los datos y los programas de usuario. Se encarga del acceso seguro, íntegro y eficiente a los datos físicos. | Administrador de la base de datos (DBA): es la persona encargada de controlar la privacidad y seguridad de los datos y realizar el mantenimiento de la base de datos. | . En el resto del capítulo aprenderemos a usar algunos de estos componentes y, en particular, nos centraremos en el lenguaje DML (de manipulación de datos), que es el que se utiliza la gran parte del tiempo que estamos trabajando con una base de datos. La implementación más popular de DML es, sin duda, el lenguaje SQL, al que dedicaremos bastante tiempo. ",
    "url": "https://iescelia.org//docs/tico/_site/bases-de-datos/#11-almacenamiento-de-la-informaci%C3%B3n",
    "relUrl": "/bases-de-datos/#11-almacenamiento-de-la-información"
  },"47": {
    "doc": "1. Bases de datos",
    "title": "1.2. El modelo de datos",
    "content": "Antes de aprender el lenguaje SQL, tenemos que hacer otra cosa que muchos programadores detestan: diseñar la base de datos con la que vamos a trabajar. O, al menos, conocer un par de reglas básicas de diseño de bases de datos para poder afrontar con éxito la creación de bases de datos sencillas y para poder interpretar los diseños de otros programadores. Un modelo de datos es una simplificación (o modelización) de la parte del mundo que queremos convertir en una base de datos. Dicho de otra manera, los modelos de datos se parecen a los planos de una casa que traza un arquitecto: no son la casa en sí, sino una representación de la misma, y su objetivo es poder construir la casa conforme a unas especificaciones dadas. 1.2.1. Diagramas E-R . Los diagramas E-R o diagramas entidad-relación son una representación gráfica de los datos del mundo real que pretendemos modelar. ¿Has visto alguna vez los planos de un arquitecto para una casa? El arquitecto no se limita a dibujar la planta de la casa, sino que elabora multitud de planos diferentes de la misma casa: instalaciones, cimentación, evacuación de agua, etc. Pues bien, para crear una aplicación informática, los “arquitectos” (que, en informática, se denominan ingenieros) también elaboran multitud de “planos” diferentes de la misma aplicación. El diagrama E-R es uno de esos “planos”. No es labor del programador elaborar esos planos. Siguiendo con la analogía anterior, si el ingeniero informático es como el arquitecto, en programador es como el albañil. Es decir, el programador se limita a seguir los planos que le facilita el arquitecto y, en todo caso, a realizar alguna pequeña corrección o sugerencia sobre el terreno. Entonces, si el diagrama E-R pertenece al dominio de la ingeniería informática, ¿por qué tenemos que aprender a hacerlos? . Por una razón muy sencilla: si la aplicación es pequeña, no suele existir un proceso de ingeniería previa (igual que no contratamos a un arquitecto para construir la caseta del perro). Y es el programador/a quien debe hacer todo el trabajo. De entre todos los “planos” de la aplicación, el diagrama E-R es uno de los más importantes, sobre todo si hablamos de aplicaciones web. Así que es muy conveniente que aprendas a elaborarlos y a interpretarlos. Además, son muy sencillos de hacer. 1.2.2. Elementos de los diagramas E-R . Los símbolos concretos de los diagramas E-R puede diferir ligeramente entre metodologías, pero en realidad significan lo mismo. Aquí veremos los llamados diagramas de Chen, por el taiwanés Peter P. Chen, que fue quién los creó en 1976 cuando trabajaba en la Universidad de Harvard (EEUU) y que son de los más extendidos en la industria. Son diagramas tan, tan sencillos, que se elaboran con solo tres elementos: . | Elemento | Significado | Símbolo | . | Entidades | Son los datos de interés para el sistema: categorías de objetos reales o abstractos de los que se necesita mantener información | | . | Atributos | Son las características propias de las entidades. Cada entidad puede tener varios atributos asociados | | . | Relaciones | Son las conexiones lógicas entre las entidades. Representan relaciones que existen en el mundo real y que son relevantes para nuestra aplicación | | . Aquí te dejo un ejemplo de diagrama E-R. ¡No te asustes! No vas a tener que hacerlos, solo comprenderlos. En este diagrama: . | LIBROS, BIBLIOTECAS o SOCIOS son entidades. Representan los datos que queremos almacenar. | entán en, tienen o préstamos son relaciones. Representan cómo los datos del mundo real se relacionan entre sí. | Cada entidad (y algunas relaciones) tienen su propios atributos. Por ejemplo, la entidad LIBROS tiene como atributos cod_libro, titulo o sinpsis. Son fragmentos de información que pertenecen a esa entidad o relación. | En las relaciones puedes ver unos números. Esos números se refieren a la cardinalidad o cantidad de elementos de cada entidad que participan en una relación. Por ejemplo, entre LIBROS y BIBLIOTECAS puedes ver la cardinalidad (1,N) en el lado LIBROS. Eso significa que cada biblioteca tiene entre 1 y muchos (N) libros. En el otro lado puedes ver (0,N), lo que significa que cada libro puede estar en 0 o muchas (N) bibliotecas. La cardinalidad global de esta relación se obtiene con el máximo de cada uno de los lados. Por eso se dice que la relación está en tiene una cardinalidad N:N o de “muchos a muchos”. | . ",
    "url": "https://iescelia.org//docs/tico/_site/bases-de-datos/#12-el-modelo-de-datos",
    "relUrl": "/bases-de-datos/#12-el-modelo-de-datos"
  },"48": {
    "doc": "1. Bases de datos",
    "title": "1.3. Paso del diagrama E-R al modelo relacional",
    "content": "Los diagramas E-R son una herramienta para representar gráficamente el modelo conceptual de una base de datos. Es decir, para crear un modelo abstracto y no ambiguo de la realidad. Pero un diagrama E-R no se puede implementar directamente en un ordenador. Antes hay que convertirlo a un modelo lógico, es decir, a un modelo implementable en un ordenador. El modelo lógico más popular desde hace décadas es el modelo relacional. En esta sección vamos a ver en qué consiste y cómo convertir nuestros diagramas E-R en tablas relacionales que podamos transformar en bases de datos reales. 1.3.1. Qué es el modelo relacional . El modelo relacional es una de las posibles maneras de convertir un diagrama E-R en una base de datos real que pueda funcionar en un ordenador. Además, es la más extendida desde hace décadas. Consiste en convertir las entidades y relaciones a tablas bidimensionales. Esas tablas también se llaman relaciones, lo cual puede inducir a errores, porque en los diagramas E-R llamábamos relaciones a la conexiones entre entidades. Para evitar confusiones, nosotros llamaremos tablas a las relaciones del modelo relacional. Por lo tanto, en el modelo relacional toda la información se almacena en tablas: . | Cada tabla está compuesta por filas, que se llaman registros o tuplas. | Cada tabla tiene columnas, denominadas campos. | Cada campo tiene asignado un dominio o tipo de datos (número entero, número real, cadena de caracteres, etc). | Cada registro contiene la información correspondiente a una ocurrencia de una entidad o de una relación del diagrama E-R. Por ejemplo, la entidad CLIENTES puede convertirse en una tabla como esta: | . El paso de los diagramas E-R a tablas se hace mediante unas reglas que nosotros no vamos a ver porque es una materia demasiado avanzada. 1.3.2. Pasos para convertir un diagrama E-R en un modelo relacional . La conversión de un diagrama E-R a un modelo relacional, es decir, a un conjunto de tablas, debe ser un proceso en el que no se pierda información y en el que obtengamos como resultado una base de datos lo más optimizada posible. Para lograr esos dos objetivos, seguiremos siempre estos dos pasos: . | Convertir el diagrama E-R (modelo conceptual) en un conjunto de tablas (modelo lógico) con las reglas de paso a tablas. En esta transformación no se debe perder ninguna información, es decir, el modelo resultante debe ser semánticamente equivalente al modelo original. Este proceso se suele denominar paso a tablas y existen unas reglas muy sencillas para hacerlo bien. Las veremos enseguida. Solo tienes que seguirlas y obtendrás una base de datos relacional bien diseñada (siempre que tu diagrama E-R también estuviera bien diseñado, claro). | Normalizar la base de datos. Este proceso sirve para asegurar que la redundancia se mantiene a un nivel mínimo y que no se van a producir problemas durante la utilización de la base de datos. | . A continuación, vamos a ver cómo dar estos dos pasos. Pero antes necesitamos familiarizarnos con la terminología del modelo relacional. 1.3.3. Conceptos clave del modelo relacional . Antes de comenzar a ver las reglas de paso a tablas, tienes que tener muy clara la terminología del modelo relacional. Si ya conoces estos términos, puedes saltar sin ningún problema al siguiente apartado. Muchos de estos conceptos ya han aparecido antes en diferentes momentos. Aquí vamos a organizarlos y a definirlos claramente antes de continuar. | Tabla o relación . Es un conjunto de celdas dispuesto en filas (registros) y columnas (campos). | Cada tabla guarda la información correspondiente a una entidad o una relación del modelo ER. | Cada registro guarda una ocurrencia de la entidad o relación. Por ejemplo, en una tabla de CLIENTES, cada registro guarda la información de un cliente. | Cada campo guarda un atributo de la entidad o relación. Por ejemplo, en una tabla de CLIENTES, cada campo guarda una parte de la información de los clientes. Así, existirá un campo DNI, un campo nombre, un campo apellido1, un campo apellido2, etc. | . Las celdas de la tabla deben contener valores atómicos. | Dominio . Es el conjunto de valores que puede tomar un campo. Es decir, es el tipo de datos al que pertenece un campo. | Clave primaria . Es un campo o conjunto de campos cuyos valores determinan unívocamente el valor del resto de campos del registro. Dicho de otra manera: el resto de campos del registro dependen funcionalmente de la clave primaria (véase “Normalización”). Por ejemplo, en una tabla CLIENTES, la clave primaria puede ser el DNI de los clientes, porque cada cliente tendrá un DNI diferente y es imposible que se repita. Suele crearse un campo específico para la clave primaria, al que casi siempre se le llama, por convenio, ID (de “identificador”). A veces se le agrega el nombre de la tabla: idCliente o id_cliente. | Clave candidata . Es un campo o conjunto de campos que podrían ser clave primaria, pero no lo son. En algunas tablas encontraremos varias claves candidatas, pero solo una puede ser elegida como clave primaria. | Clave ajena, externa o foránea . Es un campo o conjunto de campos de una tabla que, sin ser clave en dicha tabla, sí que forman la clave primaria en alguna otra tabla de la base de datos. | . En el siguiente ejemplo puedes ver todos esos elementos señalados en una tabla de ALUMNOS que puede pertenecer a la base de datos de un instituto, una universidad, una escuela de educación primaria, una academia de idiomas, etc. 1.3.6. Paso a tablas y normalización . Cualquier diagrama E-R puede convertirse en un conjunto de tablas mediante una serie de reglas que a nosotros, de momento, no nos interesan (para verlas tendrás que estudiar un ciclo formativo de informática o un grado universitario). Una vez obtenidas esas tablas, hay que revisarlas para evitar duplicidades y posibles errores. Una de las revisiones más importantes es la normalización, un proceso que previene ciertos problemas habituales en las bases de datos mal diseñadas. Esos problemas suelen tener que ver con la redundancia en los datos y las anomalías en modificaciones, inserciones y borrados. La normalización consiste en un conjunto de técnicas que transforman un conjunto de tablas en otro equivalente donde las redundancias de información están minimizadas. Para lograrlo, el nuevo conjunto de tablas debe cumplir determinadas restricciones conocidas como formas normales. Concepto intuitivo de forma normal (mediante un ejemplo) . La normalización es un asunto bastante avanzado. Aquí solo vamos a entender lo que significan las formas normales (y la normalización) de manera intuitiva mediante un ejemplo . La primera forma normal (abreviada 1NF), por ejemplo, establece la siguiente restricción: “no puede haber grupos de datos compuestos en un campo”. He aquí un ejemplo de una tabla de ALUMNOS que no está en 1FN: . | id_alumno | nombre | asignaturas | . | 1028 | Susana Martínez López | Matemáticas, Lengua | . | 1029 | Raquel Molinero Sánchez | Matemáticas, Física, Química | . | 1030 | Antonio Suárez Bermúdez | Latín, Griego | . | 1031 | Juan Miguel Rubio Castro | Economía, Latín, Matemáticas | . | etc | etc | etc | . Esta tabla no está en 1FN porque el campo asignaturas contiene valores múltiples: no es atómico e indivisible. ¿Cómo se puede modificar para que esté en 1FN? Tenemos dos posibilidades. POSIBILIDAD 1. Esta solución resuelve el problema de la 1NF, pero introduce redundancia en la tabla (en este caso, los nombres de los alumnos/as repetidos varias veces), que es uno de los mayores pecados que puede cometer un diseñador de bases de datos. | id_alumno | nombre | asignaturas | . | 1028 | Susana Martínez López | Matemáticas | . | 1028 | Susana Martínez López | Lengua | . | 1029 | Raquel Molinero Sánchez | Matemáticas | . | 1029 | Raquel Molinero Sánchez | Física | . | 1029 | Raquel Molinero Sánchez | Química | . | 1030 | Antonio Suárez Bermúdez | Latín | . | 1030 | Antonio Suárez Bermúdez | Griego | . | 1031 | Juan Miguel Rubio Castro | Economía | . | 1031 | Juan Miguel Rubio Castro | Latín | . | 1031 | Juan Miguel Rubio Castro | Matemáticas | . | etc | etc | etc | . POSIBILIDAD 2: Esta solución también consigue alcanzar la 1FN sin perder información. Pero tampoco es gratis: ha aumentado el número de tablas y, por tanto, la complejidad de nuestra base de datos. TABLA DE ALUMNOS . | id_alumno | nombre | . | 1028 | Susana Martínez López | . | 1029 | Raquel Molinero Sánchez | . | 1030 | Antonio Suárez Bermúdez | . | 1031 | Juan Miguel Rubio Castro | . | etc | etc | . TABLA DE MATRÍCULAS . | id_alumno | asignatura | . | 1028 | Matemáticas | . | 1028 | Lengua | . | 1029 | Matemáticas | . | 1029 | Física | . | 1029 | Química | . | 1030 | Latín | . | 1030 | Griego | . | 1031 | Economía | . | 1031 | Latín | . | 1031 | Matemáticas | . | etc | etc | . CONCLUSIÓN: ninguna solución es perfecta. Así que la pregunta que hay que hacerse siempre es: ¿Cuál de las soluciones es mejor? . Afortunadamente, esa pregunta siempre tiene una respuesta clara: siempre será preferible la solución que esté en una forma normal superior. Y existen hasta 6 formas normales (1NF, 2NF, 3NF, 4NF y 5NF; entre la tercera y la cuarta, hay una forma intermedia llamada forma normal de Boyce-Codd o BCNF). En el ejemplo anterior, la segunda solución es mejor porque está en BCNF, mientras que la primera solo está en 2NF. ¿Quieres saber más sobre todo esto? Nuevamente te animo a estudiar un ciclo formativo de informática (de grado superior) o un grado universitario, donde se profundiza en todos estos asuntos. ",
    "url": "https://iescelia.org//docs/tico/_site/bases-de-datos/#13-paso-del-diagrama-e-r-al-modelo-relacional",
    "relUrl": "/bases-de-datos/#13-paso-del-diagrama-e-r-al-modelo-relacional"
  },"49": {
    "doc": "1. Bases de datos",
    "title": "1.4. Ejercicios",
    "content": "Ejercicio 1: Biblioteca . Echa un vistazo a este diagrama E-R e intenta obtener las tablas relacionales correspondientes para crear una base de datos: . Solución: . Las tablas que resultan de la aplicación de las reglas de paso a tablas son estas: . CLIENTES(nif#, nombre, apellidos, dirección, teléfono) SOLICITAN(nif_cliente#, cod_libro#, fecha) LIBROS(codigo#, titulo, autor, editorial, pvp, num_ejemplares) SON_PEDIDOS(cod_libro#, cod_distribuidor) DISTRIBUIDORES(codigo#, nombre, dirección, teléfono) . Observa un par de cosas: . | La tabla SOLICITAN surge de una relación N:N. Estas relaciones siempre generan una tabla. | La tabla SON_PEDIDOS surge de una relación 1:N. Estas relaciones no suelen generar una tabla, pero en este caso la hemos creado para evitar posibles valores nulos en la tabla LIBROS. | . Ejercicio 2: Cajero automático . Mira este diagrama E-R e intenta obtener las tablas que se derivan de él: . Solución: . Las tablas que resultan de la aplicación de las reglas de paso a tablas son estas: . CLIENTES_PROPIOS(dni#, nombre, apellido1, apellido2, dirección, teléfono) CUENTAS(num_cuenta#, saldo, maximo_diario, num_tarjeta, contraseña, dni_cliente) OPERACIONES(num_operacion#, id_cajero, tipo_operación, fecha, hora, num_cuenta) . Observa como, en esta ocasión, las dos relaciones son de tipo 1:N. En esos casos no se suele crear una tabla para la relación, si no que se resuelve llevando la clave de la entidad que participa con 1 a la tabla de la entidad que participa con N. Por ejemplo, entre CLIENTES y CUENTAS (relación “tiene”) hay una relación 1:N. Eso significa que: . | Cada CLIENTE puede tener entre 1 y muchas cuentas (1:N) | Cada CUENTA pertenece a 1 y solo 1 cliente (1:1) | . En estas relaciones, la clave de la parte 1 (CLIENTE) se lleva a la tabla de la parte N (CUENTA). Por eso el dni del cliente aparece en la tabla CUENTAS. Ejercicio obligatorio: Series de TV . Ahora te toca a ti. Vamos a hacer una pequeña base de datos para almacenar información sobre nuestras series de televisión preferidas. Teniendo en cuenta lo que acabamos de ver, intenta convertir este diagrama E-R en un conjunto de tablas relacionales: . ",
    "url": "https://iescelia.org//docs/tico/_site/bases-de-datos/#14-ejercicios",
    "relUrl": "/bases-de-datos/#14-ejercicios"
  },"50": {
    "doc": "X. Entornos integrados de desarrollo",
    "title": "7. Entornos integrados de desarrollo",
    "content": ". | 7.1. Editores de texto | 7.2. Editores de código | 7.3. Entornos integrados de desarrollo | . Entornos integrados de desarrollo. Depuración. Ciclo de vida del software. Trabajo en equipo y mejora continua. Control de versiones. Metodologías ágiles: Scrum. XXX . ",
    "url": "https://iescelia.org//docs/tico/_site/entornos-integrados-de-desarrollo/#7-entornos-integrados-de-desarrollo",
    "relUrl": "/entornos-integrados-de-desarrollo/#7-entornos-integrados-de-desarrollo"
  },"51": {
    "doc": "X. Entornos integrados de desarrollo",
    "title": "7.1. Editores de texto",
    "content": "XXX . ",
    "url": "https://iescelia.org//docs/tico/_site/entornos-integrados-de-desarrollo/#71-editores-de-texto",
    "relUrl": "/entornos-integrados-de-desarrollo/#71-editores-de-texto"
  },"52": {
    "doc": "X. Entornos integrados de desarrollo",
    "title": "7.2. Editores de código",
    "content": "Estrictamente hablando, Visual Studio Code es un editor de código, no un IDE. Los editores de código son soluciones intermedias entre los editores de texto (más sencillos) y los IDEs (más sofisticados). Los editores de código no solo permiten editar el texto, sino que proporcionan herramientas adicionales para el programador: atajos de teclado, resalto de la sintaxis del lenguaje, autocompleción del texto, etc. XXX . la hora de codear que le facilita a la vida a los devs. ¿Por ejemplo? syntax highlighting (coloreado de sintaxis) o code completion (que ayuda a completar los nombres de clases, métodos, campos y palabras clave). ¿Cuál es la particularidad de los IDE? Son entornos de desarrollo mucho más complejos que integran varias herramientas para el desarrollo de software en una sola aplicación. Y tan solo uno de sus componentes es editor de código. ¿Qué es Visual Studio Code? . Como dijimos, para cada editor de código existe una subcultura asociada. Los programadores se encargan de mantener vivos estos editores, ofrecen mejoras y actualizaciones y promueven su uso entre aquellas personas que recién se inician en el mundo del desarrollo. Lo que es seguro, es que, para quienes recién comienzan, Visual Studio Code es la puerta de entrada. Este editor de código fue desarrollado por Windows -aunque también funciona muy bien en Mac-. ¿Qué ofrece? Una consola integrada, atajos y comandos que te ayudan a codear más rápido y extensiones muy útiles. Este editor es gratuito, open-source, muy estable y rápido, y proporciona acciones y recursos muy interesantes que lo convierten en uno de los preferidos por los desarrolladores. ¿Qué podemos hacer con VS Code? . Autocompletar con IntelliSense Descripción automática en tiempo real de la API Abrir y ordenar múltiples carpetas Realizar una comparación de versión lado a lado Editar de manera colaborativa y en vivo Es compatible con más de 30 lenguajes. Visual Studio Code es muy amigable para quienes recién comienzan a aprender a programar, así que si recién estás dando tus primeros pasos en programación y quieres una herramienta que te potencie, ya sabes. Introducción . Como desarrollador, es importante disponer de las mejores herramientas para realizar el trabajo. En el pasado, Salesforce ofreció muchas herramientas y cada una de ellas proporcionaba algo que faltaba en otras del mercado. Esta guía de inicio rápido le ayudará a familiarizarse en el próximo paso hacia nuestras increíbles herramientas para desarrolladores: Salesforce Extensions con Visual Studio Code. Pero primero, ¿qué es un IDE? . Un IDE, o entorno de desarrollo integrado, se compone de un editor de código, herramientas de automatización de creación, un depurador y una finalización de código inteligente. Visual Studio Code ofrece todos estos componentes. Seguir la ruta juntos . ¿Desea seguir con un instructor a medida que trabaja en este paso? Eche un vistazo a este video, que forma parte de la serie Trail Together en Trailhead Live. Encontrará un vínculo a la sesión completa en la sección Recursos. Instalación de Visual Studio Code . Puede instalar Visual Studio Code en cualquier computadora que utilice macOS, Windows o Linux. Los requisitos del sistema son relativamente asequibles, por lo que puede ejecutarse en cualquier computadora. Descargue e instale la versión más reciente de Visual Studio Code para su sistema operativo. Si ya instaló Visual Studio Code, no es necesario volver a instalarlo. Inicie Visual Studio Code. Familiarizarse con la interfaz . Página de bienvenida de Visual Studio Code. La página de bienvenida de Visual Studio Code se abrirá automáticamente la primera vez que ejecute la aplicación. Esta página ofrece numerosos vínculos de acceso directo que permiten comenzar a trabajar con nuevos archivos, aprender acerca de Visual Studio Code o incluso personalizar la interfaz en función de sus preferencias. En Learn (Aprender), haga clic en Interface Overview (Descripción general de la interfaz) para abrir una descripción visual de las distintas características de Visual Studio Code. La superposición Interface Overview (Descripción general) de la interfaz destaca elementos clave de navegación en el IDE de VS.Esta superposición le permite visualizar todo lo que es capaz de hacer Visual Studio Code. La barra inferior muestra las notificaciones, las advertencias y los errores actuales. También permite cambiar al terminal integrado. En la parte izquierda del editor podrá utilizar el explorador de archivos, buscar archivos, gestionar su código fuente, iniciar o depurar su código y gestionar extensiones. (En un futuro, también se instalarán varias extensiones para ayudar con el desarrollo.) Por último, también hay un menú que permite ejecutar comandos en el editor. Esta es otra sección que exploraremos muy pronto. Haga clic en cualquier punto de la pantalla para descartar la superposición visual. En Iniciar, haga clic en New file (Nuevo archivo). Haga clic en Text Editor (Editor de texto). En este espacio podemos comenzar a escribir. Agregue el texto Hello World en la línea 1. Documento sin título con Hello World en la primera línea de código. Cierre el archivo sin guardar. Nota . Puesto que aún no guardó el código, Visual Studio Code no destaca nada. ",
    "url": "https://iescelia.org//docs/tico/_site/entornos-integrados-de-desarrollo/#72-editores-de-c%C3%B3digo",
    "relUrl": "/entornos-integrados-de-desarrollo/#72-editores-de-código"
  },"53": {
    "doc": "X. Entornos integrados de desarrollo",
    "title": "7.3. Entornos integrados de desarrollo",
    "content": "Un IDE o Entorno intrado de desarrollo es un programa informático que proporciona, dentro del mismo programa, acceso a todas las funciones fundamentales para el desarrollo de software: edicion del código fuente, compilación, depuración, ejecución.. Con estas herramientas resulta mucho más cómodo y rápido programar que utilizando cada una de esas herramientas por separado. Algunos IDEs son monstruos devorarrecursos que disponen de herramientas adicionales potentísimas, como autocompleción de sentencias, generador automático de código, analizador del rendimiento, refactorizador, soporte multilenguaje… Otros son más simples y ligeros, y disponen de un editor sencillo y unos pocos menús para guardar, editar y ejecutar los programas. La elección del IDE es algo muy personal. Llegarás a una conclusión después de tener alguna experiencia con varios de ellos. En este capítulo vamos a introducir el uso de un IDE con una enorme aceptación en los últimos años: Visual Studio Code. Hay muchísimos IDEs en el mercado, algunos muy complejos como Netbeans o Eclipse, otros muy livianos como Geany, Vim o Atom. ¿En qué se diferencian unos de otros? . Hay varios factores cruciales: velocidad, versatilidad, rendimiento, complementos, funcionalidad, compatibilidad con determinados lenguajes, apariencia, etc. Cada desarrollador ha tenido siempre sus preferencias, pero en los últimos tiempos parece haber un consenso imposible entre los programadores de todo el mundo: Visual Studio Code es el IDE número uno del mundo. ",
    "url": "https://iescelia.org//docs/tico/_site/entornos-integrados-de-desarrollo/#73-entornos-integrados-de-desarrollo",
    "relUrl": "/entornos-integrados-de-desarrollo/#73-entornos-integrados-de-desarrollo"
  },"54": {
    "doc": "X. Entornos integrados de desarrollo",
    "title": "X. Entornos integrados de desarrollo",
    "content": " ",
    "url": "https://iescelia.org//docs/tico/_site/entornos-integrados-de-desarrollo/",
    "relUrl": "/entornos-integrados-de-desarrollo/"
  },"55": {
    "doc": "20. Estructuras de datos. Subalgoritmos",
    "title": "8. Estructuras de datos. Subalgoritmos",
    "content": ". | 8.1. Estructuras de almacenamiento de datos | 8.2. Arrays unidimensionales (vectores) . | 8.2.1. Declaración de vectores | 8.2.2. Manipulación de elementos de un vector | 8.2.3. Recorrido de un vector | 8.2.4. Ordenación de vectores | 8.2.5. Búsqueda en vectores | . | 8.3. Arrays bidimiensionales (matrices) | 8.4. Arrays de múltiples dimensiones | 8.5. Programación modular: subalgoritmos . | 8.5.1. Algoritmo principal y subalgoritmos | 8.5.2. Funciones | 8.5.3. Procedimientos | 8.5.4. Invocación de subalgoritmos | 8.5.5. Paso de parámetros | 8.5.6. Ámbito de las variables | 8.5.7. Reutilización de código | . | 8.6. El estilo de escritura . | 8.6.1. Partes de un algoritmo | 8.6.2. Documentación | 8.6.3. Convenciones de escritura | . | 8.6. Ejercicios propuestos | 8.7. Ejercicios resueltos | . Hasta ahora, hemos conocido las estructuras de control básicas de cualquier programa estructurado: secuencia, condición e iteración. Pero los programas no se componen solo de instrucciones, sino también de datos. Todos los datos que hemos manejado hasta ahora eran simples, es decir, se almacenaban en variables en las que solo podíamos guardar un valor en cada momento. Las variables simples se nos quedan cortas en muchas ocasiones (repasa el programa de las 3 en raya, sin ir más lejos, para comprobarlo). En esos casos necesitamos una variable de tipo complejo o estructura de datos. En este capítulo hablaremos de las estructuras de datos y nos centraremos en la más utilizada con diferencia: el array. Después, introduciremos los conceptos de subalgoritmo, función y biblioteca de funciones, para terminar hablando de uno de los principios básicos de la ingeniería del software: la reutilización del código. ",
    "url": "https://iescelia.org//docs/tico/_site/estructuras-de-datos/#8-estructuras-de-datos-subalgoritmos",
    "relUrl": "/estructuras-de-datos/#8-estructuras-de-datos-subalgoritmos"
  },"56": {
    "doc": "20. Estructuras de datos. Subalgoritmos",
    "title": "8.1. Estructuras de almacenamiento de datos",
    "content": "Hemos trabajado, por el momento, con los tipos de datos básicos: enteros, reales, caracteres, lógicos… Es el momento de dar el salto a los tipos de datos complejos, también llamados estructuras de datos. Las estructuras de datos pueden ser de dos tipos: . | Estáticas: son aquellas que ocupan un espacio determinado en la memoria del ordenador. Este espacio es invariable y se especifica durante la escritura del código fuente. | Dinámicas: son aquellas cuyo espacio ocupado en la memoria puede modificarse durante la ejecución del programa. | . Existe todo un universo de estructuras de datos: desde los arrays, presentes en casi cualquier programa, hasta estructuras mucho más exóticas como pilas, colas, listas enlazadas, árboles, grafos, etc. Nosotros no pretendemos verlas todas, ni mucho menos, pero sí que conozcas la más importante de todas: el array. ",
    "url": "https://iescelia.org//docs/tico/_site/estructuras-de-datos/#81-estructuras-de-almacenamiento-de-datos",
    "relUrl": "/estructuras-de-datos/#81-estructuras-de-almacenamiento-de-datos"
  },"57": {
    "doc": "20. Estructuras de datos. Subalgoritmos",
    "title": "8.2. Arrays unidimensionales (vectores)",
    "content": "Un array (también llamado arreglo, sobre todo en América latina) es una agrupación de muchos datos individuales del mismo tipo bajo el mismo nombre. Cada dato individual de un array es accesible mediante un índice. Por ejemplo, un array de números enteros es una colección de muchos números enteros a los que les adjudicamos un único identificador. El caso más simple de array es el array unidimensional, también llamado vector. Se trata, sin duda, del rey de las estructuras de almacenamiento. 8.2.1. Declaración de vectores . La declaración de un vector en pseudocódigo (seguiremos usando la sintaxis de PSeInt) se hace así: . Definir nombre_variable Como tipo Dimension nombre_variable[tamaño] . Por ejemplo: . Definir serie como Entero Dimension serie[10] . La variable serie será un vector que contendrá 10 números enteros. Todos los números recibirán el mismo nombre, es decir, serie. Se puede acceder a cada uno de los números que forman el vector escribiendo a continuación del nombre un número entre corchetes. Ese número se denomina índice. Observa el siguiente ejemplo: . Definir serie como Entero Dimension serie[5] serie[2] &lt;- 20 serie[3] &lt;- 15 serie[4] &lt;- serie[2] + serie[3] Escribir serie[4] . El vector serie de este ejemplo puede almacenar hasta 5 números enteros. En su posición 2 se almacena el número 20, y en su posición 3, el 15. Luego se suman ambos valores, y el resultado se almacena en la posición 4. Finalmente, se imprime en la pantalla el resultado de la suma, es decir, 35. Es muy útil representar los vectores de forma gráfica para entenderlos mejor. El vector serie del ejemplo anterior se puede representar así: . +------------+----+----+----+----+----+ | Posiciones | 0 | 1 | 2 | 3 | 4 | serie = +------------+----+----+----+----+----+ | Valores | ? | ? | 20 | 15 | 35 | +------------+----+----+----+----+----+ . Observa algo muy importante: el primer elemento del vector tiene el índice 0, es decir, el primer elemento es serie[0]. Como este vector tiene 5 elementos, el último será serie[4], no serie[5]. Observa también que los elementos 0 y 1 no han sido utilizados y, por lo tanto, tienen un valor desconocido, exactamente lo mismo que ocurre con cualquier variable de tipo simple que no se inicialice. (Nota: PSeInt se puede configurar para que el primer elemento del vector tenga índice 1, no 0, pero, como la mayor parte de los lenguajes de programación reales usan el 0, supondremos que PSeInt también lo está haciendo) . Como es lógico, se pueden construir vectores cuyos elementos sean de cualquier otro tipo simple, como números reales o caracteres, con la única restricción de que todos los elementos sean del mismo tipo. Y, por supuesto, pueden construirse vectores cuyos elementos sean otros vectores. Obtendremos así un array bidimensional, del que hablaremos un poco más adelante. 8.2.2. Manipulación de elementos de un vector . Los vectores deben manipularse elemento a elemento. No se pueden modificar todos los elementos a la vez. Por ejemplo, para asignar valores a los elementos de un vector, esta sería la manera: . Definir serie como Entero Dimension serie[5] serie[0] &lt;- 5 serie[1] &lt;- 3 serie[2] &lt;- 7 ...etc... Cada elemento del vector es, a todos los efectos, una variable que puede usarse independientemente de los demás elementos. Así, por ejemplo, un elemento del vector serie puede usarse en una instrucción de salida igual que cualquier variable simple de tipo entero: . Escribir(serie[2]) . Del mismo modo, pueden usarse elementos de un vector en una instrucción de entrada. Por ejemplo: . Escribir \"Dime un número entero\" Leer (serie[4]) . 8.2.3. Recorrido de un vector . La forma habitual de utilizar un vector es accediendo en secuencia a todos sus elementos, uno tras otro. Para ello, se utiliza un bucle con contador, de modo que la variable contador nos sirve como índice para acceder a cada uno de los elementos del vector. Supongamos, por ejemplo, que tenemos un vector de 10 números enteros declarado llamado v, y una variable entera llamada i, que será nuestro índice. Por medio de un bucle, con ligeras modificaciones, podemos realizar todas estas operaciones: . | 1. Inicializar todos los elementos a un valor cualquiera (por ejemplo, 0): . Para i &lt;- 0 hasta 9 hacer v[i] &lt;- 0 FinPara . | 2. Inicializar todos los elementos con valores introducidos por teclado: . Para i &lt;- 0 hasta 9 hacer Escribir \"Dime el valor del elemento nº \", i Leer v[i] FinPara . | 3. Mostrar todos los elementos en la pantalla: . Para i &lt;- 0 hasta 9 hacer Escribir \"El elemento nº \", i, \" vale \", v[i] FinPara . | 4. Realizar alguna operación que implique a todos los elementos. Por ejemplo, sumarlos en un acumulador: . suma &lt;- 0 Para i &lt;- 0 hasta 9 hacer suma &lt;- suma + v[i] FinPara Escribir \"La suma de todos los elementos es: \", suma . | . 8.2.4. Ordenación de vectores . Otra operación típica que se realiza con vectores es ordenar sus elementos mediante algún criterio. Por ejemplo, un vector de números enteros puede ordenarse de menor a mayor (o al revés), mientras que un vector de caracteres puede ordenarse alfabéticamente. Supongamos, por ejemplo, que tenemos un vector de números enteros con estos valores: . +----+----+----+----+----+----+----+----+----+----+ | 0 | 1 | 2 | 3 | 4 | 5 | 3 | 14 | 9 | 8 | +----+----+----+----+----+----+----+----+----+----+ . Después de la ordenación, nos quedará este otro vector: . +----+----+----+----+----+----+----+----+----+----+ | 0 | 1 | 2 | 3 | 3 | 4 | 5 | 8 | 9 | 14 | +----+----+----+----+----+----+----+----+----+----+ . Del mismo modo, se pueden ordenar los elementos con cualquier otro criterio: de mayor a menor, primero los pares y luego los impares, o cualquier otro que nos resulte útil para resolver un problema. Métodos de ordenación de vectores hay muchos, algunos muy simples (e ineficientes) y otros muy elaborados, y constituyen un área de estudio muy interesante dentro de la algorítmica. Aquí vamos a presentar uno de los métodos más sencillos que existen para ordenar un vector, de modo que te resulte fácil entenderlo. Para aprender los métodos más complejos y rápidos ya tendrás tiempo en el futuro, ¿no te parece? . Ordenación mediante selección directa . La selección directa es probablemente el método de ordenación más fácil de entender porque es lo que la mayoría de nosotros haríamos si tuviéramos que ordenar un conjunto de elementos a mano. Esto no quiere decir que sea fácil de programar para un principiante, pero vamos a intentarlo. Vamos a suponer que tratamos de ordenar un vector de números enteros de menor a mayor pero, como hemos dicho, la misma idea podría emplearse para ordenar cualquier otra cosa y mediante cualquier otro criterio. El método de selección directa recorre el vector desde el principio hasta localizar el elemento más pequeño, guardando su posición y su valor en dos variables que llamaremos posicion_minimo y valor_minimo. Al terminar, coloca ese elemento mínimo en la primera posición del vector y lo intercambia con el elemento que antes ocupaba esa primera posición. (Para hacer ese intercambio de valores, es necesario usar una variable auxiliar que llamaremos aux). El proceso se repite, pero ahora desde la segunda posición del vector original. De nuevo volvemos a buscar el elemento más pequeño mirándolos todos de uno en uno. Al terminar, colocamos ese elemento mínimo en la segunda posición del vector, intercambiándola por el número que antes estaba en la segunda posición. Volvemos a hacerlo, ahora desde la tercera posición del vector original, y así sucesivamente hasta terminar de recorrer el vector completo. Observa con detenimiento el código fuente de esta implementación. No pases por él de puntillas para dedicarte a otra cosa. Dedica unos minutos para tratar de ejecutarlo a mano, es decir, con papel y lápiz, apuntando el valor de las variables para ver cómo actúa el algoritmo y cómo construye, pasada tras pasada, el vector ordenado. Algoritmo seleccion_directa Definir i, j, aux Como Entero Definir valor_minimo, posicion_minimo Como Entero Definir vector Como Entero Dimensión vector[100] // Primero, vamos a llenar el vector_original con valores al azar entre 1 y 500, por ejemplo Para i desde 0 hasta 99 Hacer vector[i] &lt;- azar(500) FinPara // Ahora empieza el algoritmo de ordenación por selección directa Para i desde 0 hasta 99 Hacer valor_minimo &lt;- vector[i] posicion_minimo &lt;- i Para j desde 0 hasta 99 Hacer Si vector[j] &lt; valor_minimo Entonces valor_minimo &lt;- vector[j] posicion_minimo &lt;- j FinSi FinPara aux &lt;- vector[i] vector[i] &lt;- valor_minimo vector[posicion_minimo] &lt;- aux FinPara // Por fin, escribimos el vector ordenado para ver que todo ha funcionado bien Para i desde 0 hasta 99 Hacer Escribir vector[i] FinPara FinAlgoritmo . 8.2.5. Búsqueda en vectores . En los vectores, como en todas las estructuras de datos que contienen muchos datos en su interior, también es habitual encontrarse con la operación de búsqueda. Dado un vector y un dato cualquiera, la búsqueda consiste en determinar si ese dato está en alguna posición del vector y, si es necesario, averiguar cuál es esa posición. La búsqueda secuencial, es decir, elemento a elemento, puede llegar a ser muy lenta si el vector es muy grande. Si en un programa tenemos que realizar búsquedas en vectores grandes repetidas veces, debemos pensar el modo de lograr que las búsquedas sean más rápidas. Existe una forma muy simple de hacer una búsqueda en un vector de manera tremendamente rápid: con el método llamado búsqueda binaria. Pero la búsqueda binaria tiene un problema: para que funcione, el vector debe estar previamente ordenado. El proceso de ordenación, como acabamos de ver, es lento y costoso, pero, a cambio, obtendremos unos tiempos de búsqueda notablemente mejores. Resumiendo: si necesitamos hacer búsquedas de datos en vectores en algún programa: . | Si las búsquedas se realizan pocas veces, o bien los vectores son pequeños, optaremos por la búsqueda secuencial, que no necesita ordenar previamente el vector. | Si las busquedas se realizan muchas veces y los vectores son de gran tamaño, optaremos por la búsqueda binaria, pero antes debemos ordenar el vector. | . Búsqueda secuencial . Consiste, simplemente, en recorrer el vector desde el primer elemento hasta el último. Si encontramos el dato buscado, podemos interrumpir la búsqueda. Si no, continuaremos hasta el final del vector. Esta es una posible implementación en pseudocódigo, suponiendo que el vector tiene 100 elementos. Míralo despacio y ejecuta a mano el algoritmo. ¡Esas ejecuciones con lápiz y papel son un excelente ejercicio para los/las programadores/as principiantes! . // Búsqueda secuencial // Buscamos el elemento \"dato\" en el vector \"v\" Definir i, posicion, v como Entero Dimension v[100] i &lt;- 0 posicion &lt;- -1 // Si posición vale -1 significa que // aún no hemos encontrado lo que buscamos Mientras i &lt; 100 y posicion = -1 hacer Si v[i] = dato Entonces // ¡Lo hemos encontrado! posicion &lt;- i // Anotamos la posición FinSi i &lt;- i + 1 FinMientras Si posicion &gt;= 0 Entonces Escribir \"El dato \", dato, \" estaba en la posición \", posicion SiNo Escribir \"No he encontrado el dato \", dato, \" en el vector\" FinSi . Búsqueda binaria . Para que esta búsqueda funcione, como hemos dicho, el vector debe estar previamente ordenado. El método de búsqueda binaria consiste en lo siguiente: . | Paso 1. Supongamos que v es el vector y que contiene N elementos. Llamaremos izq a la posición del elemento izquierdo del array (inicialmente, izq = 0). Llamaremos der a la posición del elemento derecho del array (inicialmente, der = N-1) | Paso 2. Tomamos un x igual al punto medio entre izq y der, es decir, x &lt;- (izq/der) / 2 | Paso 3. Miramos el elemento v[x]. Si es el dato que buscábamos, ya hemos terminado. Si no, pueden ocurrir dos cosas: . | 3a. Que v[x] sea mayor que el dato que buscábamos. En ese caso, y dado que el array está ordenado, continuamos la búsqueda a la izquierda de x, haciendo que der &lt;- x. | 3b. Que v[x] sea menor que el dato que buscábamos. En ese caso, continuamos la busqueda a la derecha de x, haciendo izq &lt;- x. | . | Paso 4. Repetimos desde el paso 2 hasta que encontremos el elemento buscado o hasta que izq = der (lo que significará que el elemento no está en el vector) | . Esta es una posible implementación en pseudocódigo. Recuerda: no mires el código por encima para pasar a otra cosa. Léelo con calma, como si fueran las instrucciones para montar un mueble de Ikea, y ejecútalo con lápiz y papel hasta que te asegures de que entiendes cómo funciona. // Búsqueda binaria. // Buscamos el elemento \"busc\" en el vector \"v\", que debe estar previamente ordenado de menor a mayor. // Supondremos que \"v\" es un vector de enteros de 100 elementos, por ejemplo. Definir izq, der, mitad, encontrado como Entero // Iniciamos una búsqueda binaria encontrado &lt;- 0 izq &lt;- 0 // Primera posición del vector der &lt;- 99 // Última posición del vector Mientras izq &lt; der-1 y encontrado = 0 Hacer mitad &lt;- izq + ((der - izq) / 2) // Calculamos la posición \"mitad\" Si v[mitad] = busc Entonces // ¡Lo hemos encontrado! encontrado &lt;- 1 FinSi Si v[mitad] &gt; busc Entonces // Seguiremos buscando por la mitad izquierda der &lt;- mitad FinSi Si v[mitad] &lt; busc Entonces // Seguiremos buscando por la mitad derecha izq &lt;- mitad FinMientras Si encontrado = 1 Entonces Escribir \"El dato \", busc, \" está en la posición \", encontrado, \" del vector\" SiNo Escribir \"El dato \", busc, \" no está en el vector\" FinSi . Este algoritmo de búsqueda es más complejo que el secuencial, como puede verse, pero los tiempos de búsqueda con el método binario son mucho más pequeños. Para un vector de N elementos, el método secuencial necesita un promedio de N/2 pasos para localizar el elemento buscado, mientras que el método binario tarda una media de log2N pasos. ¿No te parece una diferencia muy impresionante? Fíjate en estos datos: . | Si el vector es pequeño (por ejemplo, N = 10): . | a. La búsqueda secuencial necesita una media de 5 pasos. | b. La búsqueda binaria necesita una media de 3 pasos. | . | Si el vector es mediano (por ejemplo, N = 100): . | a. La búsqueda secuencial necesita una media de 50 pasos. | b. La búsqueda binaria necesita una media de 6 ó 7 pasos. | . | Si el vector es grande (por ejemplo, N = 1000), la mejora de tiempo empieza a ser notable: . | a. La búsqueda secuencial necesita una media de 500 pasos. | b. La búsqueda binaria necesita una media de… ¡10 pasos! | . | Si el vector es muy grande (por ejemplo, N = 100.000), la mejora de tiempo es aún mayor: . | a. La búsqueda secuencial necesita una media de 50.000 pasos. | b. La búsqueda binaria necesita una media de sólo 16 pasos. | . | . La mejora en el tiempo de búsqueda es, por lo tanto, mayor cuanto mayor es el vector. Por eso dijimos que la búsqueda binaria se emplea cuando los vectores son muy grandes. ",
    "url": "https://iescelia.org//docs/tico/_site/estructuras-de-datos/#82-arrays-unidimensionales-vectores",
    "relUrl": "/estructuras-de-datos/#82-arrays-unidimensionales-vectores"
  },"58": {
    "doc": "20. Estructuras de datos. Subalgoritmos",
    "title": "8.3. Arrays bidimiensionales (matrices)",
    "content": "Una matriz, tabla o array bidimiensional, igual que un vector, es una colección de elementos individuales, todos del mismo tipo, agrupados bajo el mismo identificador. La diferencia con el vector es que, en el momento de declararlo y de acceder a cada elemento individual, debemos utilizar dos índices en lugar de uno. Una matriz de, por ejemplo, 4x4 elementos, se declara así: . Definir matriz como Entero Dimension matriz[4][4] . La variable matriz no consta de 4 elementos enteros, sino de 16, organizados en 4 filas y 4 columnas. Podemos representar gráficamente la matriz como una tabla: . Filas | V +----+----+----+----+----+ | 0 | 1 | 2 | 3 | &lt;-- Columnas +----+----+----+----+----+ | 0 | | | +----+----+----+----+----+ | 1 | | | +----+----+----+----+----+ | 2 | | | +----+----+----+----+----+ | 3 | | | +----+----+----+----+----+ . Cada casilla de la matriz es identificable mediante una pareja de índices. Normalmente, el primero de los índices se refiere a la fila y, el segundo, a la columna. Por ejemplo, si hacemos estas asignaciones: . matriz[0][0] &lt;- 5 matriz[1][0] &lt;- 1 matriz[3][2] &lt;- 13 . …el estado en el que quedará la matriz anterior será este: . Filas | V +----+----+----+----+----+ | 0 | 1 | 2 | 3 | &lt;-- Columnas +----+----+----+----+----+ | 0 | 5 | | +----+----+----+----+----+ | 1 | 1 | | +----+----+----+----+----+ | 2 | | | +----+----+----+----+----+ | 3 | | 13 | +----+----+----+----+----+ . Por descontado, los dos tamaños de la matriz pueden ser diferentes, obteniéndose tablas que son más anchas que altas o más altas que anchas. Por lo demás, las matrices se utilizan exactamente igual que los vectores. A modo de ejemplo, este sería el código para inicializar una matriz de 5x10 enteros con todos sus elementos a 0. Observa cómo se usan los dos bucles anidados para acceder a todos los elementos: . Definir i, j como Entero Definir m como Entero Dimension m[5][10] Para i &lt;- 0 hasta 4 hacer Para j &lt;- 0 hasta 9 hacer m[i][j] &lt;- 0 FinPara FinPara . ",
    "url": "https://iescelia.org//docs/tico/_site/estructuras-de-datos/#83-arrays-bidimiensionales-matrices",
    "relUrl": "/estructuras-de-datos/#83-arrays-bidimiensionales-matrices"
  },"59": {
    "doc": "20. Estructuras de datos. Subalgoritmos",
    "title": "8.4. Arrays de múltiples dimensiones",
    "content": "Del mismo modo que a los arrays unidimensionales (vectores) se les puede añadir un segundo índice, obteniendo las matrices, se puede generalizar esta práctica, dando lugar a arrays multidimensionales. Por ejemplo, el siguiente es un array de cinco dimensiones compuesto de números enteros: . Definir ejemplo como Entero Dimension ejemplo[10][10][4][5][7]; . Estos arrays no se pueden representar gráficamente (aunque con los de tres dimensiones se puede intentar dibujar un cubo), pero su utilización es idéntica a la de los arrays de una o dos dimensiones. ",
    "url": "https://iescelia.org//docs/tico/_site/estructuras-de-datos/#84-arrays-de-m%C3%BAltiples-dimensiones",
    "relUrl": "/estructuras-de-datos/#84-arrays-de-múltiples-dimensiones"
  },"60": {
    "doc": "20. Estructuras de datos. Subalgoritmos",
    "title": "8.5. Programación modular: subalgoritmos",
    "content": "Los algoritmos tienden a hacerse muy grandes cuando tratamos de resolver un problema complejo. Esto es lógico, ¿no te parece? Cuanto más complicado sea el problema, más difícil y largo será plantear su solución. Para enfrentar este hecho inevitable existe la programación modular. Consiste en algo tan simple como dividir el problema en subproblemas más sencillos, y estos a su vez en otros más sencillos, hasta que tengamos un conjunto de mucho problemas pequeñitos que sí podemos resolver individualmente de forma simple. Después, solo nos queda unir todas las piezas del puzle para obtener nuestra solución compleja. Cada una de esas soluciones a pequeños problemas se denomina subalgoritmo (no es un nombre muy original, lo sé). Y esta técnica de descomposición sucesiva en problemas complejos en subproblemas simples se conoce como divide y vencerás (divide and conquer, en inglés). Es muy útil no solo en programación, sino en la mayor parte de los problemas del mundo real. 8.5.1. Algoritmo principal y subalgoritmos . El problema principal siempre se resuelve en un algoritmo que denominaremos algoritmo principal. Este es el que hará de “pegamento” del puzle. Los subproblemas más sencillos se resolverán en subalgoritmos, también llamados módulos a secas. Los subalgoritmos están subordinados al algoritmo principal, de manera que éste es el que decide cuándo debe ejecutarse cada subalgoritmo y con qué conjunto de datos. El algoritmo principal realiza llamadas o invocaciones a los subalgoritmos, mientras que estos le devuelven resultados. Así, el algoritmo principal va recogiendo todos los resultados y puede generar la solución al problema global. Cuando el algoritmo principal hace una llamada al subalgoritmo (es decir, lo invoca), se empiezan a ejecutar las instrucciones del subalgoritmo. Cuando este termina, la ejecución continúa por la instrucción siguiente a la de invocación. También se dice que el subalgoritmo devuelve el control al algoritmo principal, ya que éste toma de nuevo el control del flujo de instrucciones después de habérselo cedido temporalmente al subalgoritmo. El programa principal puede invocar a cada subalgoritmo el número de veces que sea necesario. A su vez, cada subalgoritmo puede invocar a otros subalgoritmos, y éstos a otros, etc. Cada subalgoritmo devolverá el control al algoritmo que lo invocó. Lógicamente, los subalgoritmos deben tener asignado un nombre para que puedan ser invocados desde el algoritmo principal. Ahora bien, la forma de declarar un subalgoritmo varía ligeramente según el tipo de subalgoritmo de que se trate. Porque existen dos tipos de subalgoritmo, llamados funciones y procedimientos, que vamos a ver enseguida. 8.5.2. Funciones . Las funciones son subalgoritmos que resuelven un problema sencillo y devuelven un resultado al algoritmo que las invoca. Esto último es lo que las distingue de los procedimientos. Las funciones pueden tener argumentos, aunque no es obligatorio. Los argumentos son los datos que se proporcionan a la función en la invocación, y que la función utilizará para sus cálculos. Las funciones tienen, obligatoriamente, que devolver un resultado. Si no lo hacen, no son funciones. Este resultado suele almacenarse en una variable para usarlo posteriormente. Veamos un ejemplo. Nuevamente, emplearemos la sintaxis del pseudocódigo de PSeInt, pero cualquier otro pseudocódigo o lenguaje de programación real utilizará una sintaxis semejante. Supongamos que tenemos estamos escribiendo un programa para calcular los precios de unos artículos a la venta en una tienda. Vamos a escribir un subalgoritmo que se encargue de calcular el IVA de cada artículo. Algoritmo precios Definir nombre como cadena Definir precio como real Definir precio_con_iva como real Repetir Escribir \"Dime el nombre de otro artículo:\" Leer nombre Escribir \"Dime su precio (negativo para terminar):\" Leer precio precio_con_iva &lt;- precio + calcular_iva(precio) Escribir \"El precio con IVA es \", precio_con_iva Hasta Que precio &lt; 0 FinAlgoritmo SubAlgoritmo iva &lt;- calcular_iva(precio) Definir porcentaje como real Definir iva como real iva &lt;- precio * 0.21 // Suponemos que el IVA es el 21% FinSubalgoritmo . En este ejemplo puedes ver cómo se declara un subalgoritmo: . | Se utiliza la palabra SubAlgoritmo | Se indica a continuación cuál es el dato que devolverá al algoritmo principal (en este caso, la variable iva) | Luego se indica su nombre, calcular_iva y, entre paréntesis, los datos que recibirá del algoritmo principal (en este ejemplo, precio). Esos datos se denominan parámetros del subalgoritmo. | Después se escribe el código del subalgoritmo. Fíjate en que es un código completamente normal, como el de cualquier algoritmo. | . Los lenguajes de programación, de hecho, poseen un puñado de funciones predefinidas de las que ya hemos usado unas cuántas. ¿Recuerdas cuando usabas las funciones azar(), truncar() o redondear()? No son más que funciones, es decir, subalgoritmos, que ya vienen incorporados al lenguaje de programación. 8.5.3. Procedimientos . Los procedimientos son subalgoritmos que no devuelven ningún valor al algoritmo principal. Es decir, sin como las funciones, pero no devuelven ninguna variable al terminar. La declaración de un procedimiento es similar a la de una función. Lo vemos en este ejemplo, sacado el juego de las 3 en raya del tema anterior. Si repasas aquel ejercicio resuelto, verás que está lleno de procedimientos. Algoritmo tres_en_raya Definir tablero Como Caracter Dimension tablero[10] inicializar(tablero) mostrar(tablero) // Etc (el juego de las tres en raya continuaba a partir de aquí) FinAlgoritmo SubAlgoritmo inicializar(tablero por referencia) Definir i como entero Para i &lt;- 1 hasta 9 Hacer tablero[i] &lt;- \" \" FinPara FinSubAlgoritmo SubAlgoritmo mostrar(tablero) Escribir \"ESTADO ACTUAL DEL TABLERO\" Escribir \"+---+---+---+\" Escribir \"| \",tablero[1],\" | \",tablero[2],\" | \",tablero[3],\" |\" Escribir \"+---+---+---+\" Escribir \"| \",tablero[4],\" | \",tablero[5],\" | \",tablero[6],\" |\" Escribir \"+---+---+---+\" Escribir \"| \",tablero[7],\" | \",tablero[8],\" | \",tablero[9],\" |\" Escribir \"+---+---+---+\" FinSubAlgoritmo . Este algoritmo principal invoca a dos procedimientos: uno, llamado inicializar(), se encarga de poner un espacio en blanco en cada posición del tablero. Otro, llamado mostrar(), se encarga de dibujar el tablero en la pantalla. Como ves, cada subalgoritmo tiene el encargo de resolver una pequeña parte del problema global. Fíjate en que la declaración de los procedimientos es idéntica a la de las funciones, pero sin devolver ninguna variable. 8.5.4. Invocación de subalgoritmos . Para que las instrucciones escritas en un subalgoritmo sean ejecutadas es necesario, como ya hemos dicho, que el subalgoritmo se llame o invoque desde otro algoritmo. La invocación consiste en una mención al nombre del subalgoritmo seguida, entre paréntesis, de los valores que se desan asignar a los parámetros. Deben aparecer tantos valores como parámetros tenga el subalgoritmo, y además coincidir en el tipo de datos. Estos parámetros se podrán utilizar, dentro del subalgoritmo, como cualquier otra variable. Como las funciones devuelven valores, la invocación de una función debe aparecer a la derecha de una instrucción de asignación: . precio_con_iva &lt;- precio + calcular_iva(precio) . En cambio, como los procedimientos no devuelven ningún valor, la invocación de un procedimiento nunca aparece en una instrucción de asignación: . inicializar(tablero) mostrar(tablero) . 8.5.5. Paso de parámetros . El paso de parámetros, o comunicación de datos del algoritmo invocante al subalgoritmo invocado, puede hacerse mediante, al menos, dos métodos: . | Paso de parámetros por valor, que es la forma más sencilla pero no permite al subalgoritmo devolver resultados en los parámetros. | Paso de parámetros por referencia, que es más complejo pero permite a los subalgoritmos devolver resultados en los parámetros. | . Veamos cada método detenidamente. Paso de parámetros por valor . Los subalgoritmos, como hemos visto, pueden tener una serie de parámetros en su declaración. Estos parámetros se denominan parámetros formales. Por ejemplo, imaginemos un subalgoritmo llamado potencia() que calcula la potencia de dos números enteros que llamaremos base y exponente. Ese subalgoritmo se declararía así: . SubAlgoritmo potencia(base, exponente) . En esta declaración, base y exponente son los parámetros formales. Cuando el subalgoritmo es invocado, se le pasan entre paréntesis los valores de los parámetros. A éstos se les denomina parámetros actuales; por ejemplo: . a &lt;- 5 b &lt;- 3 potencia(a,b) . En esta invocación de la función potencia(), los parámetros actuales son a y b, es decir, 5 y 3. Al invocar un subalgritmo, los parámetros actuales son asignados a los parámetros formales en el mismo orden en el que fueron escritos. Dentro del subalgoritmo, los parámetros se pueden utilizar como si fueran variables. Así, en el ejemplo anterior, dentro de la función potencia(), el parámetro base puede usarse como una variable a la que se hubiera asignado el valor 5, mientras que exponente es como una variable a la que se hubiera asignado el valor 3. Cuando el subalgoritmo termina de ejecutarse, sus parámetros formales base y exponente dejan de existir. Paso de parámetros por referencia . En el paso de parámetros por referencia se produce una ligadura entre el parámetro actual y el parámetro formal, de modo que si el parámetro formal se modifica dentro del subalgoritmo, el parámetro actual, propio del algoritmo principal, también será modificado. Los argumentos siempre se pasan por valor excepto cuando indiquemos explícitamente que el paso es por referencia colocando el símbolo. Por ejemplo: . SubAlgoritmo potencia(base, exponente, resultado por referencia) resultado = base ^ exponente FinSubAlgoritmo . Observa cómo el parámetro resultado está pasado por referencia. Ahora veamos cómo se invoca a este subalgoritmo: . a &lt;- 5 b &lt;- 3 c &lt;- 0 potencia(a, b, c) . En este caso, pasamos tres parámetros actuales, ya que el subalgoritmo tiene tres parámetros formales. El tercero de ellos, llamado c, se pasa por referencia, y por lo tanto queda ligado al parámetro formal resultado. El parámetro formal es modificado en la instrucción resutado = base ^ exponente, y como está ligado con el parámetro actual c, el valor de la variable c también se modifica. Por lo tanto, c toma el valor 125. Cuando el subalgoritmo termina de ejecutarse, dejan de existir todos sus parámetros formales (base, exponente y resultado), pero la ligadura de resultado con la variable c hace que esta variable conserve el valor 125 incluso cuando el parámetro resultado ya no exista. 8.5.6. Ámbito de las variables . Variables locales . Se llama ámbito de una variable a la parte de un programa donde dicha variable puede utilizarse. En la mayoría de los lenguajes, las variables declaradas en un algoritmo son locales a ese algoritmo, es decir, no existen fuera del algoritmo y, por tanto, no pueden utilizarse más allá de sus fronteras. Cuando el algoritmo comienza, las variables se crean, reservándose un espacio en la memoria RAM del ordenador para almacenar su valor. Cuando el algoritmo termina, todas sus variables se destruyen, liberándose el espacio en la memoria RAM. Todos los resultados que un algoritmo obtenga durante su ejecución, por lo tanto, se perderán al finalizar, salvo que sean devueltos al algoritmo que lo invocó o sean dirigidos a algún dispositivo de salida (como la pantalla). Variables globales . En ocasiones, es conveniente utilizar variables cuyo ámbito exceda el del algoritmo donde se definen y puedan utilizarse en varios algoritmos y subalgoritmos. Esas variables se denominan globales. Las variables globales son bombas de relojería en potencia. Pueden paracer objetos atractivos y útiles a primera vista, pero antes o después te explotarán en la cara. Si alguna vez sientes la tentación de usar variables globales para algo, es mejor que te sientes y esperes a que se te pasen. Si, aún así, estás convencido/a de que necesitas usar alguna variable global, debes saber que todos los lenguajes proporcionan algún mecanismo para crearlas, generalmente indicando durante su declaración que esa variable es de ámbito global. 8.5.7. Reutilización de código . El diseño de un algoritmo mediante divide y vencerás tiene, además de la ventaja evidente de poder afrontar problemas de gran tamaño, otra ventaja adicional: la posibilidad de reutilizar subalgoritmos previamente escritos. Es habitual que, una vez resuelto un problema sencillo mediante una función o un procedimiento, ese mismo problema, o uno muy parecido, se nos presente más adelante, durante la realización de otro programa. Entonces nos bastará con volver a utilizar esa función o procedimiento, sin necesidad de volver a escribirlo. Es por esto, entre otras razones, que los subalgoritmos deben ser lo más independientes y autónomos posible. Es habitual agrupar varios subalgoritmos relacionados (por ejemplo: varios algoritmos que realicen diferentes operaciones matemáticas) en un mismo archivo, formando lo que se denomina una biblioteca (libraries, en inglés). Cada lenguaje trata las bibliotecas de manera distinta. Por último, señalemos que, para reutilizar con éxito el código, es importante que esté bien documentado. En concreto, en cada algoritmo deberíamos documentar claramente: . | La función del algoritmo, es decir, explicar qué hace | Los parámetros de entrada, si los hay | Los datos de salida, es decir, el resultado que devuelve o la forma de utilizar los parámetros por referencia | . ",
    "url": "https://iescelia.org//docs/tico/_site/estructuras-de-datos/#85-programaci%C3%B3n-modular-subalgoritmos",
    "relUrl": "/estructuras-de-datos/#85-programación-modular-subalgoritmos"
  },"61": {
    "doc": "20. Estructuras de datos. Subalgoritmos",
    "title": "8.6. El estilo de escritura",
    "content": "No podemos finalizar estos temas de introducción sin referirnos a algunas reglas de estilo básicas que deben observarse a la hora de escribir código fuente. Y es que la escritura de un algoritmo debe ser siempre lo más clara posible, ya se esté escribiendo en pseudocódigo o en un lenguaje de programación real. La razón es evidente: los algoritmos pueden llegar a ser muy complejos, y si a su complejidad le añadimos una escritura sucia y desordenada, se volverán ininteligibles. Todos los programadores han experimentado la frustración que se siente al ir a revisar un algoritmo redactado pocos días antes y no entender ni una palabra de lo que uno mismo escribió. Por esta razón, y ya desde el principio, debemos acostumbrarnos a respetar ciertas reglas básicas en cuanto al estilo de escritura. Por supuesto, un programa puede funcionar correctamente sin aplicar ninguna de las cosas que vamos a mencionar aquí, pero no es a la corrección a lo que nos referimos ahora, sino al estilo. 8.6.1. Partes de un algoritmo . Los algoritmos deberían tener siempre una estructura en tres partes: . | Cabecera: contiene el nombre del programa o algoritmo. | Declaraciones: contiene la declaración de las variables. | Acciones: contiene las instrucciones del algoritmo. | . 8.6.2. Documentación . La expresión “documentación de un programa” se refiere, en realidad, a dos tipos muy distintos de documentación: . | La documentación externa, formada por todos los documentos ajenos al programa: guías de instalación, guías de usuario, manuales de referencia, manuales técnicos, etc. | La documentación interna es la que se incluye en el propio código programa. Está formada por los comentarios del código fuente. | . Los comentarios del código fuente deben ser significativos. Se dice que el código fuente perfecto es aquel que no necesita ningún comentario adicional, porque se explica suficientemente bien a sí mismo y puede leerse sin necesidad de aclaraciones adicionales. Esto es un escenario utópico que nunca se da en la realidad, pero debemos programar con la vista puesta en él. Nuestro código debe ser lo más claro y autoexplicativo posible. Cuando no lo logremos, debemos acompañarlo de comentarios que expliquen lo que el código hace y faciliten su comprensión y mantenimiento posterior. Cada algoritmo, además, debería ir precedido de un comentario que explique lo que ese algoritmo hace. En los subalgoritmos, además, deberían añadirse a ese comentario otros que indiquen cuales son los parámetros de entrada (si existen) y cual es el valor devuelto (si es el caso). En PSeInt, los comentarios se escriben con una doble barra inclinada (//) al comienzo del mismo. Cada lenguaje de programación tiene su propio estilo de comentarios y deberás curiosear un poco en los manuales para averiguarlo cuando vayas a programar en un lenguaje de programación nuevo. 8.6.3. Convenciones de escritura . Se considera una buena práctica de programación seguir ciertas normas de escritura en el código fuente. Del mismo modo que al escribir en lenguaje natural no solo respetamos la ortografía y la sintaxis (o, al menos, deberíamos hacerlo), sino que también usamos signos de puntuación, dejamos márgenes a ambos lados y procuramos no hacer tachones para que el texto luzca bien y sea cómodo de leer (o, al menos, también deberíamos hacerlo), al escribir en un lenguaje de programación hay ciertas convenciones que no son imprescindibles pero sí muy recomendables. Sangrías . Las instrucciones que aparezcan dentro de un bloque deben tener una sangría mayor que las de apertura y cierre de ese bloque. Por ejemplo, las instrucciones que hay dentro de un bucle Mientras ... FinMientras deberían estar más sangradas que las propias instrucciones Mientras y FinMientras: . Mientras condición hacer Instrucción 1 Instrucción 2 ... Instrucción N FinMientras . Esto es aplicable a cualquier bloque: Algoritmo ... FinAlgoritmo, Para ... FinPara, Si ... SiNo ... FinSi, etc. En particular, este último caso, que puede llevar un bloque SiNo de forma optativa, se escribe así (fíjate bien en la sangría izquierda): . Si condición Entonces Instrucciones SiNo Otras Instrucciones FinSi . Si hay un bloque anidado dentro de otro, el bloque más interno se sangrará aún más que el bloque precedente. Por ejemplo: . Mientras i &lt; 10 Hacer Leer n Si n &gt; 0 Entonces i &lt;- i + n SiNo i &lt;- i - n FinSi FinMientras . Espacios . Algo que aumenta la legibilidad del código es espaciar suficientemente (pero no demasiado) los distintos elementos de cada instrucción. Por ejemplo, esta instrucción ya es bastante complicada y difícil de leer: . si (a &gt; b) y (c &gt; d * raiz(k) ) entonces a &lt;- k + 5.7 * b . Pero se lee mucho mejor que esta otra, en la que se han suprimido los espacios (excepto los imprescindibles): . si (a&gt;b)y(c&gt;d*raiz(k))entonces a&lt;-k+5.7*b . Al ordenador le dará igual si escribimos (a &gt; b) o (a&gt;b), pero a cualquier programador que deba leer nuestro código le resultará mucho más cómoda la primera forma. Por la misma razón, también es conveniente dejar líneas en blanco entre determinadas instrucciones del algoritmo cuando se considere que mejora la legibilidad. Identificadores . A la hora de elegir identificadores de variables (o de algoritmos y subalgoritmos) es muy importante utilizar nombres que sean significativos, es decir, que den una idea de la información que almacena esa variable. Por ejemplo, si en un programa de nóminas vamos a guardar en una variable la edad de los empleados, es una buena ocurrencia llamar a esa variable “edad”, pero no llamarla “x”, “a” o “cosa”. Ahora bien, dentro de esta política de elegir identificadores significativos, es conveniente optar por aquellos que sean lo más cortos posible, siempre que sean descifrables. Un identificador llamado “edad_de_los_empleados” es engorroso de escribir y leer, sobre todo si aparece muchas veces en el algoritmo, cuando probablemente “edad_empl” proporciona la misma información. Sin embargo, si lo acortamos demasiado (por ejemplo “ed_em”) llegará un momento en el no quede claro lo que significa. Toda esta idea de significación de los identificadores es extensible a los nombres de los algoritmos, de las funciones, de los procedimientos, de los archivos y, en general, de todos los objetos relacionados con un programa. Por último, señalar que muchos lenguajes de programación distinguen entre mayúsculas y minúsculas, es decir, que para ellos no es lo mismo el identificador “edad” que “Edad” o “EDAD”. Por convenio, los algoritmos suelen nombrarse con la primera letra en mayúscula y el resto en minúsculas, mientras que las variables y funciones suelen nombrarse con la todas las letras en minúscula. Excepción: si el identificador consta de más de una palabra. En ese caso, ¿cómo es conveniente escribirlo? Existen dos convenciones para eso: . | CamelCase: si el identificador consta de más de una palabra, se escriben todas juntas y la primera letra de cada palabra se escribe en mayúsculas. Por ejemplo: edadEmpleado. | snake_case: si el identificador consta de más de una palabra, se escriben separadas por el signo de subrayado (_). Por ejemplo: edad_empleado. | . Elegir CamelCase o snake_case es una cuestión de gustos personales. Lo importante es que, optes por el estilo que optes, lo utilices siempre y no mezcles identificadores de un tipo con identificadores de otro. ",
    "url": "https://iescelia.org//docs/tico/_site/estructuras-de-datos/#86-el-estilo-de-escritura",
    "relUrl": "/estructuras-de-datos/#86-el-estilo-de-escritura"
  },"62": {
    "doc": "20. Estructuras de datos. Subalgoritmos",
    "title": "8.6. Ejercicios propuestos",
    "content": "Resuelve los siguientes ejercicios utilizando subalgoritmos cuando la complejidad del problema así lo requiera. Puedes hacerlo con todos, excepto los números 1, 2, 7 y 8, que son tan simples que difícilmente podrás sacar un subalgoritmo de ellos. Ejercicios de vectores (arrays unidimensionales) . Ejercicio 1: Inicializar un vector. Escribe un programa en pseudocódigo en el que se defina un vector de 100 números enteros, se inicialicen todos los elementos al valor –1 y se impriman por pantalla. Ejercicio 2: Inicializar un vector (más complejo). Define dos vectores de 100 números enteros, uno llamado pares y otro impares. Inicializa el primero con los 100 primeros números pares positivos (es decir, pares[0] contendrá el valor 2, pares[1] contendrá el valor 4, pares[2] contendrá el valor 6, y así sucesivamente). Inicializa el segundo con los 100 primeros números impares positivos. Imprímelo por pantalla para comprobar que lo has hecho correctamente. Ejercicio 3: Lotería primitiva. Escribe un programa que genere al azar una combinación para jugar a la lotería primitiva asegurándote de que ningún número se repite. Pista: puedes utilizar un array de 6 números enteros, asignando a cada posición un número entero aleatorio entre 1 y 49, y comprobando que el número asignado no es igual a ninguno de los asignados anteriormente. Ejercicio 4. Estadística básica. Escribe un programa que pida al usuario N números enteros (siendo N un valor introducido por teclado) y calcule el valor medio de todos ellos, mostrando luego en la pantalla los números que están por encima de la media y los que están por debajo de ella. Ejercicio 5. Ordenar vector gigante. Escribe un programa que defina un vector de 1000 elementos y lo inicialice con valores aleatorios entre 0 y 2.000.000. Posteriormente, el programa debe ordenar los elementos del array de menor a mayor. Prueba luego a cambiar el tamaño del vector hasta los 10.000, 100.000 y 1.000.000 de elementos. ¿El tiempo de respuesta del programa crece linealmente con el tamaño del vector? . Ejercicio 6. Vector creciente. Escribe un programa que defina un vector de 10 enteros y lo rellene con números CRECIENTES al azar entre 1 y 100. Es decir, los números serán elegidos aleatoriamente pero siempre tienen que ser mayores que los anteriores: el número que ocupe la posición 1 debe ser mayor que el de la posición 0, el de la posición 2 mayor que el de la 1, y así sucesivamente. Después de eso, se pedirá al usuario un número entre 1 y el número mayor que exista en el vector. El número introducido por el usuario se insertará en la posición del vector adecuada para conservar el orden, desplazando los demás elementos hacia la derecha, de manera que se pierda el último elemento. Después de insertar el número introducido por el usuario, el contenido del vector debe mostrarse por la pantalla. El proceso se repetirá hasta que el usuario introduzca un número negativo. Por ejemplo, supongamos que el array generado al azar por el ordenador, después de ordenarlo, es este: 4 – 18 – 23 – 25 – 44 - 45 – 51 – 72 – 78 - 85 . Como el número más alto es 85, el programa debe pedir al usuario: Introduzca un número entre 1 y 85: _ . Si el usuario teclea, por ejemplo, el número 67, éste debe ser insertado en la posición adecuada para conservar el orden, es decir, entre los números 51 y 72, desplazando a los demás números hacia la derecha, con lo cual se pierde el mayor de todos ellos (85). El vector quedaría así: 4 – 18 – 23 – 25 – 44 - 45 – 51 – 67 - 72 – 78 . Ejercicios de matrices (arrays bidimensionales) . Ejercicio 7. Inicializar matriz simple. Escribe un programa en el que se defina una matriz de 10x10 números enteros. Inicializa todos los elementos al valor –1. Ejercicio 8. Inicializar matriz complejo. Repite el ejercicio anterior, inicializando ahora todas las filas pares al valor 0 y todas las filas impares al valor –1. Ejercicio 9. Sumar filas. Escribe un programa que defina una matriz de 6x3 números enteros y luego pida al usuario que introduzca los valores de cada elemento. Después, el programa debe sumar los tres números de cada fila, mostrando los resultados. Ejercicio 10. Permutar filas. Escribe un programa que defina una matriz de 3x5 números enteros y luego pida al usuario que introduzca los valores de cada elemento. Después, debe permutar el contenido de la fila 3 por el de la fila 1, y mostrar por último el contenido de la matriz. Ejercicio 11. Sumar matrices. Escribe un programa que defina dos matrices de 10x5 números enteros y las inicialice con números aleatorios entre 0 y 255. Posteriormente, cada elemento de la primera matriz debe ser sumado con el mismo elemento de la segunda matriz, guardando el resultado en una tercera matriz. Se deben sumar todas las parejas de elementos y mostrar el resultado en la pantalla. Ejercicio 12. Jugueteando con matrices. Escribe un programa que genere al azar una matriz cuadrada de NxN números enteros (siendo N un valor introducido por el usuario) y que luego haga lo siguiente: . | Mostrar. Mostrará la matriz tal y como ha sido generada. | Perímetro. Mostrará los elementos que ocupan el borde de la matriz, partiendo de la esquina superior izquierda y recorriéndola hacia la derecha y luego hacia abajo. | Centro. Mostrará los elementos que ocupan el centro geométrico de la matriz. Puede ser 1 (si N es impar) o 4 (si N es par). | Espiral. Hará un recorrido en espiral por la matriz partiendo de la esquina superior izquierda. | . Por ejemplo, si la matriz fuera de 4x4 y tuviera este contenido: . 4 6 7 8 2 4 3 9 0 1 3 4 7 3 3 5 . …las distintas operaciones deben obtener este resultado: . | Perímetro: 4 6 7 8 9 4 5 3 3 7 0 2 | Centro: 4 3 1 3 | Espiral: 4 6 7 8 9 4 5 3 3 7 0 2 4 3 3 1 | . ",
    "url": "https://iescelia.org//docs/tico/_site/estructuras-de-datos/#86-ejercicios-propuestos",
    "relUrl": "/estructuras-de-datos/#86-ejercicios-propuestos"
  },"63": {
    "doc": "20. Estructuras de datos. Subalgoritmos",
    "title": "8.7. Ejercicios resueltos",
    "content": "Ejercicio 1: Inicializar un vector. Escribe un programa en pseudocódigo en el que se defina un vector de 100 números enteros, se inicialicen todos los elementos al valor –1 y se impriman por pantalla. Algoritmo InicializarVectorSimple Definir i, vector Como Entero Dimension vector[100] // Inicializamos el array Para i &lt;- 0 hasta 99 Hacer vector[i] &lt;- -1 FinPara // Mostramos el array Para i &lt;- 0 hasta 99 Hacer Escribir \"Vector[\", i, \"] = \", vector[i] FinPara FinAlgoritmo . Ejercicio 2: Inicializar un vector (más complejo). Define dos vectores de 100 números enteros, uno llamado pares y otro impares. Inicializa el primero con los 100 primeros números pares positivos (es decir, pares[0] contendrá el valor 2, pares[1] contendrá el valor 4, pares[2] contendrá el valor 6, y así sucesivamente). Inicializa el segundo con los 100 primeros números impares positivos. Imprímelo por pantalla para comprobar que lo has hecho correctamente. Algoritmo InicializarVectorComplejo Definir i, pares, impares Como Entero Dimension pares[100] Dimension impares[100] // Inicializa los arrays Para i &lt;- 0 hasta 99 Hacer pares[i] &lt;- (i+1)*2 impares[i] &lt;- (i*2)+1 FinPara // Muestra el array de números pares Para i &lt;- 0 hasta 99 Hacer Escribir \"Pares[\", i, \"] = \", pares[i] FinPara // Muestra el array de números impares Para i &lt;- 0 hasta 99 Hacer Escribir \"Impares[\", i, \"] = \", impares[i] FinPara FinAlgoritmo . Ejercicio 3: Lotería primitiva. Escribe un programa que genere al azar una combinación para jugar a la lotería primitiva asegurándote de que ningún número se repite. Pista: puedes utilizar un array de 6 números enteros, asignando a cada posición un número entero aleatorio entre 1 y 49, y comprobando que el número asignado no es igual a ninguno de los asignados anteriormente. Algoritmo InicializarVector Definir repetido como Lógico Definir i, j, apuesta como Entero Dimension apuesta[6] // Genera la combinación al azar (sin números repetidos) Para i &lt;- 0 hasta 5 hacer Repetir apuesta[i] &lt;- azar(49)+1 // Saca un número al azar entre 1 y 49 repetido &lt;- falso // Suponemos que NO está repetido... Para j &lt;- 0 hasta i-1 con paso 1 hacer // ...pero vamos a asegurarnos mirando todos los anteriores Si apuesta[j] = apuesta[i] entonces // ¡Sí que estaba repetido! repetido &lt;- verdadero // Ponemos a \"verdadero\" la variable centinela FinSi FinPara Hasta Que repetido = falso // Sacaremos otro número al azar hasta que no esté repetido FinPara // Mostramos la combinación Escribir \"La combinación para la lotería es:\" Para i &lt;- 0 hasta 5 hacer Escribir sin saltar apuesta[i], \" \" FinPara FinAlgoritmo . Ejercicio 4. Estadística básica. Escribe un programa que pida al usuario N números enteros (siendo N un valor introducido por teclado) y calcule el valor medio de todos ellos, mostrando luego en la pantalla los números que están por encima de la media y los que están por debajo de ella. Algoritmo estadistica_basica Definir n, i, acum como Entero Definir vector Como Entero Definir media como Real // Dimensionamos el array Escribir \"¿Cuántos números vas a escribir?\" Leer n Dimension vector[n] // Leemos los valores del array Escribir \"Por favor, teclea los \", n, \" valores (pulsa Intro después de cada uno):\" Para i &lt;- 0 hasta n-1 hacer Leer vector[i] FinPara // Calculamos la media acum &lt;- vector[0] Para i &lt;- 1 hasta n-1 hacer acum &lt;- acum + vector[i] FinPara media &lt;- acum / n Escribir \"El promedio es: \", media // Mostramos los valores que están por debajo de la media Escribir \"Valores por debajo de la media:\" Para i &lt;- 1 hasta n-1 Hacer Si vector[i] &lt; media Entonces Escribir vector[i] FinSi FinPara // Mostramos los valores que están por encima de la media Escribir \"Valores por encima de la media:\" Para i &lt;- 1 hasta n-1 Hacer Si vector[i] &gt; media Entonces Escribir vector[i] FinSi FinPara FinAlgoritmo . Ejercicio 5. Ordenar vector gigante. Escribe un programa que defina un vector de 1000 elementos y lo inicialice con valores aleatorios entre 0 y 2.000.000. Posteriormente, el programa debe ordenar los elementos del array de menor a mayor. Prueba luego a cambiar el tamaño del vector hasta los 10.000, 100.000 y 1.000.000 de elementos. ¿El tiempo de respuesta del programa crece linealmente con el tamaño del vector? . Algoritmo ordenar_array Definir n, i como Entero Definir vector Como Entero // Dimensionamos el array Escribir \"¿De qué tamaño quieres el array?\" Leer n Dimension vector[n] // Inicializamos el array con valores aleatorios Para i &lt;- 0 hasta n-1 hacer vector[i] &lt;- azar(n*2) FinPara // Ordenamos el array. Lo mostramos antes y después para comprobar la diferencia Escribir \"Pulsa una tecla para ver el array desordenado\" Esperar Tecla mostrar(vector, n) Escribir \"Pulsa una tecla para iniciar la ordenación del array\" Esperar Tecla ordenar(vector, n) Escribir \"Ordenación terminada. Pulsa una tecla para ver el array ordenado\" Esperar Tecla mostrar(vector, n) FinAlgoritmo SubAlgoritmo mostrar(vector, n) Definir i Como Entero para i &lt;- 0 hasta n-1 Hacer Escribir vector[i] FinPara FinSubAlgoritmo SubAlgoritmo ordenar(vector por referencia, n) Definir i, j, aux Como Entero para i &lt;- 0 hasta n-2 Hacer para j &lt;- 0 hasta n-2 Hacer si vector[j] &gt; vector[j+1] Entonces aux &lt;- vector[j] vector[j] &lt;- vector[j+1] vector[j+1] &lt;- aux FinSi FinPara Borrar Pantalla Escribir \"Ordenando el array... \", redon(i*100/(n-2)), \"%\" FinPara FinSubAlgoritmo . Ejercicio 6. Vector creciente. Escribe un programa que defina un vector de 10 enteros y lo rellene con números CRECIENTES al azar entre 1 y 100. Es decir, los números serán elegidos aleatoriamente pero siempre tienen que ser mayores que los anteriores: el número que ocupe la posición 1 debe ser mayor que el de la posición 0, el de la posición 2 mayor que el de la 1, y así sucesivamente. Después de eso, se pedirá al usuario un número entre 1 y el número mayor que exista en el vector. El número introducido por el usuario se insertará en la posición del vector adecuada para conservar el orden, desplazando los demás elementos hacia la derecha, de manera que se pierda el último elemento. Después de insertar el número introducido por el usuario, el contenido del vector debe mostrarse por la pantalla. El proceso se repetirá hasta que el usuario introduzca un número negativo. Por ejemplo, supongamos que el array generado al azar por el ordenador, después de ordenarlo, es este: . 4 – 18 – 23 – 25 – 44 - 45 – 51 – 72 – 78 - 85 . Como el número más alto es 85, el programa debe pedir al usuario: . Introduzca un número entre 1 y 85: _ . Si el usuario teclea, por ejemplo, el número 67, éste debe ser insertado en la posición adecuada para conservar el orden, es decir, entre los números 51 y 72, desplazando a los demás números hacia la derecha, con lo cual se pierde el mayor de todos ellos (85). El vector quedaría así: . 4 – 18 – 23 – 25 – 44 - 45 – 51 – 67 - 72 – 78 . Algoritmo vector_creciente Definir i, n, posicion como entero Definir v Como Entero Dimension v[10] // Inicializamos el vector con números crecientes, para que ya salga ordenado Para i &lt;- 0 hasta 9 Hacer v[i] &lt;- i*10 + azar(10) FinPara // Mostramos el vector mostrar_vector(v) // Pedimos al usuario un número Repetir Escribir \"Introduce un número entre 1 y \", v[9] Leer n Hasta que n &gt;= 1 y n &lt;= v[9] // Localizamos la posición de inserción posicion &lt;- 0 Mientras n &gt; v[posicion] posicion &lt;- posicion + 1 FinMientras // Desplazamos el contenido del vector hacia la derecha desde esa posición Para i &lt;- 8 hasta posicion con paso -1 hacer v[i+1] &lt;- v[i] FinPara // Insertamos por fin el número y volvemos a mostrar el vector v[posicion] &lt;- n mostrar_vector(v) FinAlgoritmo SubAlgoritmo mostrar_vector(v) Definir i como entero Para i desde 0 hasta 9 Hacer escribir sin saltar v[i], \" - \" FinPara Escribir \"\" FinSubAlgoritmo . Ejercicio 7. Inicializar matriz simple. Escribe un programa en el que se defina una matriz de 10x10 números enteros. Inicializa todos los elementos al valor –1. Algoritmo inicializar_matriz_simple Definir fila, columna como entero Definir matriz como entero Dimension matriz(10,10) // Primero inicializamos la matriz Para fila &lt;- 0 hasta 9 Hacer Para columna &lt;- 0 hasta 9 Hacer matriz[fila, columna] &lt;- -1 FinPara FinPara // Después mostramos la matriz por pantalla Para fila &lt;- 0 hasta 9 Hacer Para columna &lt;- 0 hasta 9 Hacer Escribir sin saltar matriz[fila, columna], \" \" FinPara Escribir \" \" // Hace el salto de línea al final de cada columna FinPara FinAlgoritmo . Ejercicio 8. Inicializar matriz complejo. Repite el ejercicio anterior, inicializando ahora todas las filas pares al valor 0 y todas las filas impares al valor –1. Algoritmo inicializar_matriz_complejo Definir fila, columna como entero Definir matriz como entero Dimension matriz(10,10) // Primero inicializamos la matriz Para fila &lt;- 0 hasta 9 Hacer Para columna &lt;- 0 hasta 9 Hacer Si fila MOD 2 = 0 Entonces matriz[fila, columna] &lt;- 0 SiNo matriz[fila, columna] &lt;- -1 FinSi FinPara FinPara // Después mostramos la matriz por pantalla Para fila &lt;- 0 hasta 9 Hacer Para columna &lt;- 0 hasta 9 Hacer Si fila MOD 2 = 0 Entonces Escribir sin saltar \" \", matriz[fila, columna], \" \" SiNo Escribir sin saltar matriz[fila, columna], \" \" FinSi FinPara Escribir \" \" // Hace el salto de línea al final de cada columna FinPara FinAlgoritmo . Ejercicio 12. Jugueteando con matrices. Escribe un programa que genere al azar una matriz cuadrada de NxN números enteros (siendo N un valor introducido por el usuario) y que luego haga lo siguiente: . | Mostrar. Mostrará la matriz tal y como ha sido generada. | Perímetro. Mostrará los elementos que ocupan el borde de la matriz, partiendo de la esquina superior izquierda y recorriéndola hacia la derecha y luego hacia abajo. | Centro. Mostrará los elementos que ocupan el centro geométrico de la matriz. Puede ser 1 (si N es impar) o 4 (si N es par). | Espiral. Hará un recorrido en espiral por la matriz partiendo de la esquina superior izquierda. | . Por ejemplo, si la matriz fuera de 4x4 y tuviera este contenido: . 4 6 7 8 2 4 3 9 0 1 3 4 7 3 3 5 . …las distintas operaciones deben obtener este resultado: . | Perímetro: 4 6 7 8 9 4 5 3 3 7 0 2 | Centro: 4 3 1 3 | Espiral: 4 6 7 8 9 4 5 3 3 7 0 2 4 3 3 1 | . Algoritmo jugando_con_matrices // Atención: en esta solución supondremos que los arrays comienzan en el índice 0. // Si se configura PseInt para que empiecen en 1, habría que modificar el código, como es lógico. Definir matriz, tam Como Entero Escribir sin saltar \"Elige el tamaño de la matriz cuadrada: \" Leer tam Dimension matriz[tam,tam] inicializar_matriz(matriz, tam) mostrar_matriz(matriz, tam) perimetro(matriz, tam) centro(matriz, tam) espiral(matriz, tam) FinAlgoritmo SubAlgoritmo inicializar_matriz(matriz, tam) Definir f, c como entero Para f desde 0 hasta tam-1 hacer Para c desde 0 hasta tam-1 hacer matriz[f,c] &lt;- azar(10) FinPara FinPara FinSubAlgoritmo SubAlgoritmo mostrar_matriz(matriz, tam) Definir f, c como entero Escribir \"MATRIZ:\" Para f desde 0 hasta tam-1 hacer Para c desde 0 hasta tam-1 hacer Escribir sin saltar matriz[f,c], \" \" FinPara Escribir \"\" FinPara FinSubAlgoritmo SubAlgoritmo perimetro(matriz, tam) Definir f, c como entero Escribir \"PERÍMETRO:\" Para c &lt;- 0 hasta tam-1 Hacer Escribir sin saltar matriz[0, c], \" \" FinPara Para f &lt;- 1 hasta tam-1 Hacer Escribir sin saltar matriz[f, tam-1], \" \" FinPara Para c &lt;- tam-2 hasta 0 con paso -1 Hacer Escribir sin saltar matriz[tam-1, c], \" \" FinPara Para f &lt;- tam-2 hasta 1 con paso -1 Hacer Escribir sin saltar matriz[f, 0], \" \" FinPara Escribir \"\" FinSubAlgoritmo SubAlgoritmo centro(matriz, tam) Definir c como entero Escribir \"CENTRO:\" Si tam % 2 = 0 entonces // Matriz de tamaño PAR. El centro consta de cuatro números c &lt;- tam / 2 Escribir sin saltar matriz[c-1, c-1], \" \" Escribir sin saltar matriz[c-1, c], \" \" Escribir sin saltar matriz[c, c-1], \" \" Escribir sin saltar matriz[c, c] SiNo // Matriz de tamaño IMPAR. El centro es un solo número c &lt;- trunc(tam / 2) Escribir sin saltar matriz[c, c] FinSi Escribir \"\" FinSubAlgoritmo SubAlgoritmo espiral(matriz, tam) Definir f, c, inicio, final como entero Escribir \"ESPIRAL:\" inicio &lt;- 0 final &lt;- tam-1 Mientras inicio &lt; final hacer Para c &lt;- inicio hasta final Hacer Escribir sin saltar matriz[inicio, c], \" \" FinPara Para f &lt;- inicio+1 hasta final Hacer Escribir sin saltar matriz[f, final], \" \" FinPara Para c &lt;- final-1 hasta inicio con paso -1 Hacer Escribir sin saltar matriz[final, c], \" \" FinPara Para f &lt;- final-1 hasta inicio+1 con paso -1 Hacer Escribir sin saltar matriz[f, inicio], \" \" FinPara inicio &lt;- inicio + 1 final &lt;- final - 1 FinMientras Escribir \"\" FinSubAlgoritmo . ",
    "url": "https://iescelia.org//docs/tico/_site/estructuras-de-datos/#87-ejercicios-resueltos",
    "relUrl": "/estructuras-de-datos/#87-ejercicios-resueltos"
  },"64": {
    "doc": "20. Estructuras de datos. Subalgoritmos",
    "title": "20. Estructuras de datos. Subalgoritmos",
    "content": " ",
    "url": "https://iescelia.org//docs/tico/_site/estructuras-de-datos/",
    "relUrl": "/estructuras-de-datos/"
  },"65": {
    "doc": "9. El lenguaje C",
    "title": "9. El lenguaje C",
    "content": "El ordenador, como ya sabrás a estas alturas, solo puede manejar ceros y unos, es decir, código o lenguaje binario. Los seres humanos, por el contrario, utilizamos un lenguaje mucho más complejo, con montones de símbolos y reglas sintácticas y semánticas, que denominamos lenguaje natural (aunque de “natural” tiene poco). Entre estos dos extremos (lenguaje binario y lenguaje natural) se encuentran los lenguajes de programación. Tienen cierto parecido con el lenguaje natural, pero son mucho más reducidos y estrictos en su sintaxis y semántica, para acercarse a las limitaciones del lenguaje binario. En este capítulo vamos a aprender a escribir algoritmos con un lenguaje llamado C y, más adelante, con una variante de C llamada C++. Se trata, en realidad, de dos lenguajes de programación distintos, si bien C++ es un superconjunto de C, es decir, todo el lenguaje C está incluido en C++ y, además, tiene algunas cosas adicionales. Se trata de dos lenguajes muy veteranos pero que siguen gozando de una gran popularidad en el mundo profesional de la programación, sobre todo de la programación de sistemas u otros programas que requieran gran velocidad de procesamiento, como los motores de videojuegos. Lenguajes de programación hay muchos, así que también hablaremos de otros lenguajes y conoceremos los tipos y características de algunos de ellos. ",
    "url": "https://iescelia.org//docs/tico/_site/lenguaje-c/",
    "relUrl": "/lenguaje-c/"
  },"66": {
    "doc": "X. Lenguaje Javascript",
    "title": "7. El lenguaje Javascript",
    "content": ". | 7.1. Orientándose en la jungla de los lenguajes de programación . | 7.1.1. Tipos de lenguaje según el nivel de abstracción: alto y bajo nivel | 7.1.2. Tipos de lenguaje según su generación | 7.1.3. Tipos de lenguaje según su forma de traducción | 7.1.4. Tipos de lenguaje según su tipado | 7.1.5. El top ten de los lenguajes de programación | . | 7.2. ¡Bienvenidos a Javascript! . | 7.2.1. Características básicas de Javascript | 7.2.2. Breve historia de Javascript | 7.2.3. Sintaxis básica de Javascript | 7.2.4. Conversiones de tipo | 7.2.5. Asignación y ámbito de las variables | 7.2.6. Operadores y expresiones | 7.2.7. Estructuras de control | 7.2.8. Subalgoritmos | 7.2.9. Entrada y salida | 7.2.10. Arrays | 7.2.11. Los objetos predefinidos de Javascript | . | 7.3. Escribiendo programas con Javascript . | 7.3.1. Caja de herramientas | 7.3.2. Flujo de trabajo | 7.3.3. Dónde y cómo escribir el código fuente | . | 7.4. Eventos y temporizadores . | 7.4.1. Eventos de Javascript | 7.4.2. Temporizadores de Javascript | . | 7.5. Un ejemplo completo: las tres en raya . | 7.5.1. El código fuente | 7.5.2. ¿Cómo ejecutar y depurar este programa? | . | 7.6. Ejercicios propuestos | 7.7. Ejercicios resueltos | . El ordenador, como ya sabes, solo puede manejar ceros y unos, es decir, código o lenguaje binario. Los seres humanos, por el contrario, utilizamos un lenguaje mucho más complejo, con montones de símbolos y reglas sintácticas y semánticas, que denominamos lenguaje natural (aunque de “natural” tiene poco). Entre estos dos extremos (lenguaje binario y lenguaje natural) se encuentran los lenguajes de programación. Tienen cierto parecido con el lenguaje natural, pero son mucho más reducidos y estrictos en su sintaxis y semántica, para acercarse a las limitaciones del lenguaje binario. En este capítulo vamos a aprender a escribir algoritmos con un lenguaje de alto nivel llamado Javascript. Se trata de un lenguaje que ha alcanzado una popularidad enorme gracias a que se encuentra incrustado en todas las páginas web que visitas a diario. Javascript es la piedra angular de cualquier web, pero también puede usarse como un lenguaje de programación convencional para escribir algoritmos de forma rápida, que es lo que vamos a hacer en este tema. Lenguajes de programación hay muchos, así que también hablaremos de otros lenguajes y conoceremos los tipos y características de algunos de ellos. ",
    "url": "https://iescelia.org//docs/tico/_site/javascript/#7-el-lenguaje-javascript",
    "relUrl": "/javascript/#7-el-lenguaje-javascript"
  },"67": {
    "doc": "X. Lenguaje Javascript",
    "title": "7.1. Orientándose en la jungla de los lenguajes de programación",
    "content": "Los lenguajes de programación constituyen un ecosistema muy extenso y en constante evolución. Para orientarse un poco en esa jungla, nada mejor que clasificar los lenguajes igual que los biólogos clasifican a las criaturas vivas. 7.1.1. Tipos de lenguaje según el nivel de abstracción: alto y bajo nivel . Hay lenguajes de programación muy próximos al lenguaje binario: a éstos los llamamos lenguajes de bajo nivel de abstracción. Y los hay más próximos al lenguaje natural: son los lenguajes de alto nivel de abstracción. Lenguajes de bajo nivel . Son los lenguajes más cercanos a la máquina. Los programas directamente escritos en código binario se dice que están en lenguaje máquina que, por lo tanto, es el lenguaje de más bajo nivel que existe. Las instrucciones del lenguaje máquina realizan tareas muy sencillas, como, por ejemplo, sumar dos números, detectar qué tecla se ha pulsado en el teclado o escribir algo en la pantalla del ordenador. Cuando se combinan adecuadamente muchas de estas instrucciones sencillas se obtiene un programa de ordenador que puede realizar tareas muy complejas. Por ejemplo, este puede ser el aspecto de una instrucción en lenguaje máquina para sumar dos números: . 0001 000100000101 110100110101 . Incomprensible, ¿verdad? . A pesar de la simplicidad de las instrucciones del lenguaje máquina, la forma de escribirlas es muy complicada, ya que hay que hacerlo en binario. En los primeros años de la informática los ordenadores se programaban directamente en lenguaje máquina, lo cual convertía la tarea de programar en una verdadera pesadilla. Hoy en día nadie lo hace. Cuando los ordenadores fueron haciéndose más potentes, surgió la idea de utilizar el propio ordenador como traductor: ¿por qué no escribir instrucciones en un lenguaje más parecido al natural y que un programa de ordenador se encargue de traducir esa instrucción a su correspondiente instrucción en lenguaje máquina? . Así apareció el lenguaje ensamblador, cuyas instrucciones son equivalentes a las del lenguaje máquina, pero se escriben con palabras similares a las del lenguaje humano. Por ejemplo, para sumar dos números, la instrucción en ensamblador puede tener un aspecto como este: . ADD D1 D2 . Lenguajes de alto nivel . Siguiendo el razonamiento anterior (utilizar el propio ordenador como traductor), en la década de 1960 y, sobre todo, de 1970, se empezaron a desarrollar lenguajes cada vez más complejos, en los que cada instrucción ya no se correspondía exactamente con una instrucción del lenguaje máquina, sino con varias. Estos son los lenguajes de alto nivel. Lógicamente, la traducción desde un lenguaje de alto nivel a lenguaje máquina es mucho más compleja que desde lenguaje ensamblador, por lo que los traductores se han hecho cada vez más complicados. Una característica muy importante de los lenguajes de alto nivel es que son independientes del hardware, lo que implica que los programas desarrollados con estos lenguajes pueden ser ejecutados en ordenadores con hardware totalmente distinto. A esto se le llama portabilidad. Los programas encargados de traducir el código de alto nivel a código máquina se llaman compiladores e intérpretes. Son programas muy complejos que generan el código binario equivalente al código de alto nivel para una máquina concreta. Por lo tanto, el programa de alto nivel, que es portable de un hardware a otro, debe ser traducido a código máquina en cada tipo de máquina en la que se pretenda ejecutar. Los ejemplos de lenguajes de alto nivel son innumerables, y la lista incluye casi todos de los que has oído hablar alguna vez: Basic, Cobol, Fortran, Ada, C/C++, PHP, Python, Java, Perl, Ruby, Javascript, etc. Ventajas e inconvenientes de los lenguajes de alto y bajo nivel . | LENGUAJES DE BAJO NIVEL | LENGUAJES DE ALTO NIVEL | . | Ventajas | Inconvenientes | . | Son comprensibles directamente por la máquina (aunque el ensamblador necesita una pequeña traducción) | Necesitan ser traducidos por medio de complicados programas (compiladores e intérpretes) | . | Los programas se ejecutan muy rápidamente (si están bien escritos, claro) | La traducción automática del código de alto nivel al código máquina siempre genera programas menos eficientes que si se escribieran directamente en binario | . | Ocupan menos espacio en memoria | Ocupan más espacio en memoria | . | Permiten controlar directamente el hardware, por lo que son apropiados para la programación de sistemas | En general, solo pueden acceder al hardware utilizando al sistema operativo como intermediario. Pero, entonces, ¿cómo programar el sistema operativo, que necesita controlar directamente el hardware? | . | Inconvenientes | Ventajas | . | Son completamente dependientes del hardware. Un programa escrito para determinado tipo de máquina no funcionará en un ordenador con diferente arquitectura. | Son portables, es decir, independientes del hardware. Un programa escrito en una máquina puede funcionar en otra con hardware distinto, siempre que se vuelva a traducir a binario en la máquina nueva. | . | Incluso los programas más sencillos son largos y farragosos | Los programas son más sencillos, ya que una sola instrucción puede equivaler a varias instrucciones binarias. | . | Los programas son difíciles de escribir, depurar y mantener | Los programas son más fáciles de escribir, depurar y mantener | . | Es imposible resolver problemas muy complejos | Es posible, aunque difícil, enfrentarse a problemas muy complejos | . Si echas un vistazo a la tabla anterior comprenderás que, en general, es preferible usar lenguajes de alto nivel la gran mayoría de las veces, reservando los de bajo nivel para casos muy concretos, como el desarrollo de ciertas partes de los sistemas operativos. También hay que destacar que no todos los lenguajes de alto nivel son iguales. Los hay de más alto nivel que otros. El lenguaje C, por ejemplo, tiene menor nivel de abstracción que, por ejemplo, Java. Esto hace que los programas escritos en C sean más rápidos y eficientes que los escritos en Java, aunque también pueden llegar a ser más difíciles de escribir y depurar. 7.1.2. Tipos de lenguaje según su generación . Los lenguajes de programación también se clasifican según la generación a la que pertenecen. El lenguaje máquina fue el lenguaje de primera generación. Los ensambladores fueron los lenguajes de segunda generación. A partir de ahí, surgió una explosión de lenguajes diferentes que podemos clasificar como: . | Lenguajes de tercera generación (o imperativos), en los que el programador escribe una secuencia de instrucciones que el ordenador debe ejecutar en un orden preestablecido. Son los lenguajes más “clásicos”: C, Basic, Cobol, Fortran, Pascal, etc. | Lenguajes de cuarta generación (o 4GL), dirigidos a facilitar la creación de interfaces con el usuario y con otras aplicaciones, como las bases de datos. Un ejemplo de estos lenguajes es SQL, universalmente utilizado para manipular bases de datos y omnipresente en muchas aplicaciones web actuales. | Lenguajes orientados a objetos, que son una evolucuión de los lenguajes de tercera generación y que permiten construir con mayor facilidad y robustez programas modulares complejos. Ejemplos de lenguajes orientados a objetos son C++, C#, Java, Javascript, Python, PHP o Ruby. Algunos de ellos son multiparadigma, es decir, permiten programar con orientación a objetos pero también permiten hacer programación estructurada clásica, sin objetos. | Lenguajes declarativos y lenguajes funcionales, propios de la inteligencia artificial, como Prolog o Lisp. | Otros tipos aún más específicos: lenguajes concurrentes, paralelos, distribuidos, etc. | . En general, podemos decir que un programador acostumbrado a trabajar con un lenguaje de tercera generación puede aprender con poco esfuerzo cualquier otro lenguaje de tercera generación y, con algo más de trabajo, un lenguaje orientado a objetos. Sin embargo, el “salto” a otros tipos de lenguajes, como los declarativos, cuesta más porque las fundamentos de estos lenguajes son muy diferentes. 7.1.3. Tipos de lenguaje según su forma de traducción . Cuando programamos en un lenguaje distinto del lenguaje máquina, nuestro código debe ser traducido a binario para que el ordenador pueda entenderlo y ejecutarlo. Existe un programa específico encargado de hacer esa traducción y que, dependiendo del lenguaje en el que hayamos escrito nuestro programa, puede ser un ensamblador, un compilador o un intérprete. Ensambladores . Se llaman ensambladores los programas encargados de traducir los programas escritos en ensamblador a código binario. Sí, ya lo sé: se usa el mismo nombre para referirse al lenguaje de programación y al traductor de ese lenguaje a código máquina. Es un lío. Como el lenguaje ensamblador es muy próximo al binario, estos traductores son programas relativamente sencillos. Compiladores . El compilador es un programa que traduce el código de alto nivel a código binario. Es, por tanto, parecido al ensamblador, pero mucho más complejo, ya que las diferencias entre los lenguajes de alto nivel y el código binario son muy grandes. El programa escrito en lenguaje de alto nivel se denomina programa fuente o código fuente. El programa traducido a código binario se llama programa objeto o código objeto. Por lo tanto, el compilador se encarga de convertir el programa fuente en un programa objeto. Una vez que se ha obtenido el código objeto ya no es necesario volver a realizar la traducción (o compilación), a menos que se haga alguna modificación en el programa fuente, en cuyo caso habría que volver a compilarlo. El código objeto, una vez generado, puede ejecutarse en la máquina en la que fue compilado, o en otra de similares características (procesador, sistema operativo, etc.). Cuando se usa programación modular, puede ser necesario un proceso previo de enlace de los diferentes módulos antes de poder construir el programa ejecutable. Intérpretes . El intérprete es un programa que traduce el código de alto nivel a código binario pero, a diferencia del compilador, lo hace en tiempo de ejecución. Es decir, no existe un proceso previo de traducción de todo el código fuente a código binario, sino que se va traduciendo y ejecutando instrucción por instrucción. Compiladores frente a intérpretes . El intérprete es notablemente más lento que el compilador, ya que realiza la traducción al mismo tiempo que la ejecución. Además, esa traducción se lleva a cabo siempre que se ejecuta el programa, mientras que el compilador sólo la hace una vez. Hay un evidente malgasto de recursos. Sin embargo, muchos lenguajes muy populares en la actualidad, como Javascript, PHP o Python, suelen ser interpretados y no compilados. Alguna ventaja tendrá la interpretación frente a la compilación, ¿no crees? . Pues sí: la gran ventaja de los intérpretes es que hacen que los programas sean más portables. Así, un programa compilado en una máquina PC bajo Windows no funcionará en un Mac o en un PC bajo Linux, a menos que se vuelva a compilar el programa fuente en el nuevo sistema. En cambio, un programa interpretado funcionará en todas las plataformas, siempre que dispongamos del intérprete en cada una de ellas. JavaScript es un ejemplo de lenguaje interpretado tremendamente popular gracias al crecimiento de Internet. Los programas escritos con JavaScript (llamados comúnmente scripts) pueden funcionar en cualquier máquina que disponga de un intérperte Javascript, y resulta que todos los navegadores web tienen uno. Por eso, cualquier programa escrito en Javascript puede ejecutarse prácticamente en cualquier ordenador del mundo sin tocarle ni una coma. En cambio, C++, por ejemplo, es un lenguaje compilado, lo que hace que los programas desarrollados con estos lenguajes se ejecuten más rápido (¡pero mucho más rápido!) que sus equivalentes en JavaScript. Sin embargo, tendrás que volver a compilarlos si deseas ejecutarlos en una máquina con diferente hardware o diferente sistema operativo. 7.1.4. Tipos de lenguaje según su tipado . Por tipado nos referimos a la forma en la que los lenguajes de programación usan los tipos de datos. Ya sabes: entero, carácter, lógico, etc. Es decir, las categorías a las que puede pertenecer una variable. Pues bien, según su tipado, los lenguajes pueden ser: . | De tipado fuerte: los tipos de datos no pueden mezclarse. Por ejemplo, no puedes sumar un entero y un real, porque son números de distinto tipo. Y mucho menos sumar un entero con un carácter. | De tipado débil: los tipos de datos pueden mezclarse y el lenguaje hace las conversiones de tipos implícitas que le parezca oportunas. Así, en estos lenguajes podrías sumar un entero con un real, o incluso un entero con un carácter. ¿Que cuál sería el resultado? Buena pregunta. Tendrás que probarlo, porque eso depende de las conversiones de tipo que haga el lenguaje. | De tipado estático: los tipos de datos se asignan al escribir el código y no pueden cambiarse durante la ejecución. Esto es típico de los compiladores (aunque no de todos). | De tipado dinámico: los tipos de datos pueden cambiarse alegremente durante la ejecución. Esto es típico de los intérpretes. | . Las dos primeras categorías y las dos segundas no son excluyentes. Por ejemplo, pueden existir lenguajes de tipado débil y dinámico, o bien fuerte y estático. Las otras combinaciones (fuerte y dinámico, débil y estático) pueden darse pero son menos habituales. 7.1.5. El top ten de los lenguajes de programación . Es difícil saber cuales son los lenguajes más populares en un determinado momento porque no existen estadísticas fiables a nivel mundial. Además, las cosas pueden cambiar mucho de un territorio a otro. Sin embargo, ciertos sitios de internet, como GitHub, almacenan enormes cantidades de proyectos de software. GitHub, de hecho, es el mayor almacén de código fuente conocido, de modo que sus estadísticas nos pueden dar una idea bastante exacta de cuál es el grado de uso de cada lenguaje. Según Madnight, un proyecto que recopila y publica estadísticas de uso de lenguajes en GitHub, el top ten de lenguajes de programación más usados en GitHub es: . | Puesto | Lenguaje | Porcentaje de uso | Variación de uso en 12 meses | . | 1 | JavaScript | 17.955% | -2.192% | . | 2 | Python | 15.943% | +0.071% | . | 3 | Java | 12.977% | +1.573% | . | 4 | Go | 8.203% | -0.612% | . | 5 | TypeScript | 7.212% | -0.276% | . | 6 | C++ | 6.683% | -0.251% | . | 7 | Ruby | 6.488% | +0.303% | . | 8 | PHP | 4.937% | -0.093% | . | 9 | C# | 3.366% | -0.350% | . | 10 | C | 2.958% | +0.068% | . El porcentaje de uso indica la proporción de proyectos en GitHub que usan ese lenguaje de programación sobre el total de proyectos. La última cifra señala la variación interanual del porcentaje de uso. Estos datos son de tercer cuatrimestre de 2021. Para obtener datos de otras fechas, puedes visitar la web https://madnight.github.io/ . Ten en cuenta de nuevo que esto no son cifras de uso absoluto de los lenguajes a nivel mundial. Solo se trata de una pista de cuál es la situación. De hecho, si consultas otras estadísticas como el TIOBE index, encontrarás datos diferentes. Según las cifras de Madnight, Javascript continúa siendo el lenguaje preferido por la mayoría de los programadores (aunque está lejos de sus tiempos memorables, donde llegó a utilizarse en casi el 30% de los proyectos activos en Github). Viejas glorias como Java, C++, PHP y C aguantan muy bien el tipo, con unos números muy estables, porque tienen una base de programadores muy fieles a sus espaldas, mientras que algunos lenguajes recientes como Go y Typescript se han hecho un hueco en el ránking de los 10 más usados. ",
    "url": "https://iescelia.org//docs/tico/_site/javascript/#71-orient%C3%A1ndose-en-la-jungla-de-los-lenguajes-de-programaci%C3%B3n",
    "relUrl": "/javascript/#71-orientándose-en-la-jungla-de-los-lenguajes-de-programación"
  },"68": {
    "doc": "X. Lenguaje Javascript",
    "title": "7.2. ¡Bienvenidos a Javascript!",
    "content": "7.2.1. Características básicas de Javascript . | Javascript es un lenguaje de alto nivel. | Es imperativo y estructurado. Admite orientación a objetos basada en prototipos, no en clases (puede que no entiendas lo que significa esto, pero de momento no importa). | Su tipado es débil y dinámico. | La sintaxis de sus estructuras de control está heredada del lenguaje C, como la de Java, PHP o Python, por lo que guarda bastantes semejanzas con estos otros lenguajes. | Es un lenguaje interpretado, pensado para ser ejecutado dentro de un navegador web. Por lo tanto, no es particularmente eficiente, pero sí muy portable. Sin embargo, también existen compiladores y precompiladores que permiten construir con Javascript cualquier tipo de programa, no solo aplicaciones web. | Es altamente portable. Cualquier programa en Javascript debería poder ejecutarse sin ninguna adaptación particular en cualquier navegador web reciente. | Su integración con los navegadores web hace que pueda manipular cualquier página web, incluso después de estar cargada en el navegador. | Es uno de los lenguajes de programación más populares del mundo en la actualidad. Aunque se ha intentado reemplazar muchas veces, ningún otro lenguaje lo ha conseguido (de momento). | . 7.2.2. Breve historia de Javascript . Javascript fue un lenguaje creado en la década de 1990 para el ya desaparecido navegador web Netscape Navigator. En aquellos primeros tiempos de internet, las páginas web eran sitios muy poco vistosos, con mucho texto y unas pocas imágenes, y Javascript pretendía introducir un poco de movimiento y dinamismo en esas páginas tan aburridas. Internet Explorer, el principal competidor de Netscape, respondió creando el VB Script y, posteriormente, un lenguaje muy similar a Javascript (pero no igual) llamado JScript. Esos lenguajes no tuvieron éxito e Internet Explorer terminó por aceptar la existencia de Javascript. Aquella competición entre Netscape e Internet Explorer se llamó guerra de los navegadores y, aunque Netscape la perdió y acabó desapareciendo, Javascript ha permanecido hasta hoy como el heredero directo aquella época convulsa. Desde entonces, Javascript ha tenido una evolución enorme, y ha pasado de ser apenas un lenguaje de juguete con el que se podían conseguir un puñado de efectos dinámicos en los sitios web a ser un lenguaje muy potente y bien definido, capaz de sustentar la estructura de aplicaciones web complejas. Hoy en día, Javascript suele utilizarse con librerías y frameworks que mejoran su estructura y aumentan su potencia. El estándar del lenguaje está publicado por la ECMA (European Computer Manufacturers Association) y se denomina ECMAScript. Todos los navegadores web respetan ese estándar en gran medida. 7.2.3. Sintaxis básica de Javascript . Generalidades sintácticas . Hay algunas normas básicas de la sintaxis de Javascript que tienes que conocer: . | Los bloques de código se marcan con las llaves ( { y } ). Por ejemplo, después de una sentencia while (equivalente al mientras de pseudocódigo) hay que abrir una llave. El cuerpo de bucle comprenderá desde esa llave de apertura hasta la siguiente llave de cierre, así: . while (condicion) { Instrucción 1 del bucle Instrucción 2 del bulce ... Instrucción N del bucle } . La llave de cierre, por tanto, sería el equivalente al FinMientras de pseudocódigo. | Todas las instrucciones terminan con un punto y coma ( ; ). Excepción: si una instrucción contiene un bloque marcado con llaves ( { … } ), se considera que esa instrucción termina al cerrar el bloque, y en ese caso no hace falta poner punto y coma. a = 10; // La instrucción de asignación termina con ; while (condicion) { // Cuerpo del bucle } // El bucle termina con }, así que no necesita ; . | Los identificadores de variables, funciones, etc., no pueden empezar con un número ni contener espacios o símbolos especiales, salvo el de subrayado ( _ ) . a5 = 1; // Identificador de variable válido 5a = 1; // Identificador de variable NO válido . | Las cadenas de caracteres pueden encerrarse entre comillas simples ( ‘…’ ) o comillas dobles ( “…” ) . a = \"Soy una cadena\"; b = 'Yo también soy una cadena'; . | El lenguaje es sensitivo a las mayúsculas. Es decir, no es lo mismo que una variable se llame edad que Edad o EDAD. | . Tipos de datos primitivos . Javascript utiliza varios tipos de datos simples llamados primitivos. Los más importantes son: . | number: números enteros y reales, indistintamente. | string: cadenas de caracteres. | boolean: datos de tipo lógico, es decir, de los que solo pueden valer true (verdadero) o false (falso). | . Como es un lenguaje de tipado dinámico, esos tipos pueden variar durante la ejecución, dependiendo de lo que hagas con las variables. De hecho, Javascript es tan flexible que ni siquiera es necesario declarar las variables (aunque es aconsejable). Es decir, que puedes usar una variable cuando la necesites sin tener que declararla antes. Las variables en Javascript se declaran con las palabras clave var o let. Las diferencias entre una y otra tienen que ver con el ámbito de la variable y las veremos enseguida. Por ejemplo: . var a = \"Hola\"; let b = 1; var c; d = 3; . En el código anterior hemos declarado tres variables, a, b y c. Observa que, al declarar una variable, no se especifica el tipo: Javascript decidirá su tipo en función del valor que se le asigne. Así pues, el tipo de la variable a será string, y el de la variable b será number. ¿Qué pasará con el tipo de la variable c? Hasta que no se le asigne algún valor, permanecerá undefined. Fíjate, por último, en que no hemos declarado la variable d, sino que la hemos usado directamente. Esto también es válido en Javascript, aunque, en general, poco recomendable por razones que comentaremos luego. El tipo de esta variable también será number. 7.2.4. Conversiones de tipo . Javascript, como hemos dicho, es un lenguaje de tipado dinámico. Es decir, que las variables pueden variar de tipo a lo largo del programa: . var a = 1; // Variable tipo number // Aquí pueden ir varias instrucciones más a = \"Hola\"; // Ahora la variable es de tipo string . Además, Javascript también es un lenguaje débilmente tipado, lo que significa que no hace comprobaciones estrictas de tipos a la hora de asignar un valor a una variable o de comparar dos expresiones. Por ejemplo, estas instrucciones son correctas: . a = 5; // La variable a es de tipo number b = \"A\"; // La variable b es de tipo string c = a + b; // ¿Qué ocurre si las mezclamos en una expresión? . ¿Qué resultado crees que obtendrás con una mezcla de tipos como esta? ¿Por qué no haces la prueba? . Cuando mezclas tipos, estás dejando que el lenguaje de programación decida cuál será el resultado, por lo que puedes obtener resultados imprevisibles. Es mejor que tú controles qué conversiones de tipo se hacen. Para eso, Javacript dispone de varias herramientas: . | typeof: Nos dice de qué tipo es una variable. a = 5; document.write(typeof a); // En la pantalla, aparecerá escrito \"number\" . | String: Convierte la variable a un string (cadena de caracteres). a = 5; // a es el número entero 5 b = String(a); // b es la cadena \"5\" . | parseInt y parseFloat: Convierte la variable a un number entero o real (es decir, a sin decimales o con decimales). a = \"5 pollos\"; // a es una cadena b = parseInt(a); // Javascript tratará de convertir la cadena a un número entero document.write(b); // ¿Qué crees que aparecerá en la pantalla? . | . 7.2.5. Asignación y ámbito de las variables . La asignación de valores a variables en Javascript es fácil de explicar: se hace con el símbolo igual (=), no con el símbolo &lt;= que usábamos en pseudocódigo: . var a; // Declaración de la variable a var b = 1; // Declaración y asignación de valor a la variable b a = b + 5; // Asignación de valor a la variable a . El problema del ámbito de las variables es más complicado de explicar. El ámbito (o scope, en inglés) de una variable es el lugar del programa donde esa variable está disponible. Primero, la versión corta: las variables en Javascript son locales. Es decir, solo son accesibles desde el algoritmo o subalgoritmo donde se declaran. La versión larga es que Javascript ofrece una flexibilidad un poco mareante para manejar el ámbito de las variables. Vamos a tratar de explicarlo con unos cuantos ejemplos sencillos. Unas líneas más arriba dijimos que Javascript permite declarar las variables con var o con let, o bien no declararlas, ¿verdad? . Pues bien: el ámbito de la variable dependerá de dónde declaremos la variable (si lo hacemos) y de cómo lo hagamos (con var o con let). Declarar variables con var . Las variables declaradas con var son locales a la función donde se declaran, o globales si se declaran en el exterior de cualquier función. var a = 1; // Variable global function mostrarMensaje() { var b = 2; // Variable local document.write(\"La variable a vale \", a, \" y la variable b vale \", b); } . En este ejemplo, la variable a es global, lo que significa que será accesible desde cualquier parte de este programa (incluyendo el interior de la función mostrarMensaje()). La variable b, en cambio, es local a la función mostrarMensaje(). Si tratamos de acceder a ella desde el exterior de esa función, se producirá un error de ejecución. Declarar variables con let . Las variables declaradas con let son locales al bloque donde se declaran, o globales si se declaran en el exterior de cualquier bloque. Un bloque es cualquier cosa encerrada entre dos llaves ({ y }). Observa el siguiente ejemplo: . let a = 1; // Variable global function mostrarMensaje() { let b = 2; // Variable local a la función if (b &gt; 0) { let c = 3; // Variable local al bloque if document.write(\"La variable a vale \", a, \", la variable b vale \", b, \" y la variable c vale \", c); } } . En este ejemplo tenemos 3 variables: . | La variable a vuelve a ser global, lo que significa que será accesible desde cualquier parte de este programa. | La variable b es local a la función. Está disponible desde su declaración hasta la llave de cierre de la función. | La variable c es local a su bloque. Es decir, está disponible desde su declaración hasta la llave de cierre del if. | . No declarar las variables . Con Javascript, como ya hemos visto, es perfectamente posible no declarar las variables y usarlas sin más. Sin embargo, cuando haces este tipo de cosas, dejas que sea el lenguaje de programación el que tome decisiones por ti. En este caso, que decida sobre el ámbito de la variable. Por eso mi consejo es que siempre declares las variables, aunque no les asignes ningún valor inicial. Si decides usar las variables sin declarar, tienes que saber que Javascript las considerará a todas globales, independientemente del punto del programa donde hayas usado la variable por primera vez. a = 1; // Variable global function mostrarMensaje() { b = 2; // Variable global if (b &gt; 0) { c = 3; // Variable global document.write(\"La variable a vale \", a, \", la variable b vale \", b, \" y la variable c vale \", c); } } . 7.2.6. Operadores y expresiones . Los operadores y expresiones en Javascript son iguales que los que hemos empleado en pseudocódigo: . | Operadores aritméticos: +, -, *, /, % (este último significa módulo de la división). | Operadores relacionales: &gt;, &lt;, &gt;=, &lt;=… | . Sin embargo, hay algunas diferencias importantes entre el pseudocódigo de PseInt y Javascript. Son estas: . | La asignación, como ya hemos visto más arriba, se hace con el símbolo igual (=), no con &lt;=. a = 5; // A la variable a se le asigna el valor 5 b = a + 1; // A la variable b se le asigna el valor a + 1 . | La comparación de igualdad se hace con un doble igual (==), no con un solo igual (=). Esto es así para distinguir la comparación de la asignación. if (a == 5) { // Comparación: ¿es a igual a 5? b = a + 1; // Asignación: b toma el valor a + 1 } . | Existe el operador incremento (++). Se utiliza para sumar una unidad a una variable. while (i &lt; 10) { i++; // Esto es equivalente a: i = i + 1 } . | También existe el operador decremento (- -), para restar una unidad a una variable. while (i &gt; 0) { i--; // Equivalente a: i = i - 1 } . | Los operadores lógicos (Y, O, NO) se escriben de forma distinta: . | Y se escribe &amp;&amp;. | O se escribe ||. | NO se escribe ! (sí, sí, es una admiración). | . if (a &gt; 0) &amp;&amp; (b &gt; 0) { // Operador Y: tienen que darse las dos condiciones a la vez ... } . | . Hay algunas otras diferencias, desde luego, pero con esto ya tienes para hacer un buen montón de programas. 7.2.7. Estructuras de control . Las estructuras de control en Javascript son muy similares a las que hemos utilizado en pseudocódigo, cambiando ligeramente la notación empleada. A continuación te muestro una tabla con las más habituales y su equivalente en pseudocódigo, sin entrar en explicaciones, porque supondremos que ya sabes manejarlas. Si no recuerdas para qué servía alguna de ellas, quizá sería buena idea que le dieras un repaso al capítulo dedicado al pseudocódigo. | Instrucción | Pseudocódigo | Javascript | . | Condicional simple | Si condición entonces &nbsp;&nbsp;&nbsp;acciones FinSi | if (condicion) { &nbsp;&nbsp;&nbsp;acciones } | . | Condicional doble | Si condicion entonces &nbsp;&nbsp;&nbsp;acciones SiNo &nbsp;&nbsp;&nbsp;acciones FinSi | if (condicion) { &nbsp;&nbsp;&nbsp;acciones } else { &nbsp;&nbsp;&nbsp;acciones } | . | Bucle tipo mientras | Mientras condicion hacer &nbsp;&nbsp;&nbsp;acciones FinMientras | while (condicion) { &nbsp;&nbsp;&nbsp;acciones } | . | Bucle tipo repetir | Repetir &nbsp;&nbsp;&nbsp;acciones Hasta Que condicion | do { &nbsp;&nbsp;&nbsp;acciones } while (condicion) | . | Bucle tipo para | Para variable &lt;- valor_inicial hasta valor_final con paso incremento hacer &nbsp;&nbsp;&nbsp;acciones FinPara | for (variable = valor_inicial; variable != valor_final; variable = variable + incremento) { &nbsp;&nbsp;&nbsp;acciones } | . Fíjate en que casi todo se escribe del mismo modo que en pseudocódigo con un par de diferencias notables: . | DIFERENCIA 1: En el bucle tipo repetir, la condición de salida se expresa al revés (“repetir mientras..” en lugar de “repetir hasta que…”. Lo verás mejor en este ejemplo que muestra los números del 1 al 100. Observa la condición del final del bucle: . En pseudocódigo: . i &lt;- 1 Repetir Escribir i i &lt;- i + 1 Hasta que i &gt;= 100 . En Javascript: . i = 1; do { document.write(i); i++; } while (i &lt; 100); . | DIFERENCIA 2: En el bucle tipo para hay que indicar la asignación a la variable que controla el bucle, la condición de salida y la forma en la que esa variable cambiará en cada iteración. Observa este ejemplo: . En pseudocódigo: . Para i &lt;- 1 hasta 10 hacer Escribir i FinPara . En Javascript: . for (i = 1; i &lt;= 10; i = i + 1) document.write(i); } . Si el paso del bucle no es +1 (es decir, si la variable que controla el bucle no incrementa su valor de 1 en 1 en cada iteración), hay que indicarlo de este modo: . En pseudocódigo: . Para i &lt;- 1 hasta 10 con paso 2 hacer Escribir i FinPara . En Javascript: . for (i = 1; i &lt;= 10; i = i + 2) document.write(i); } . Por último, recuerda que en Javascript existe una abreviatura para i = i + 1, que se escribe i++, por lo que lo más habitual es encontrar los bucles de tipo para escritos así: . for (i = 1; i &lt;=10; i++) document.write(i); } . | . 7.2.8. Subalgoritmos . Las funciones de Javascript . Javascript es un lenguaje modular, es decir, permite la escritura de subalgoritmos. Todos los subalgoritmos en Javascript se llaman funciones, independientemente de si devuelven algo o no. Esta es la forma de declarar una función: . function nombre_funcion(parámetros) { Instrucciones de la función; return expresión; } . El return es optativo. Una función de Javascript puede no tener return y, por lo tanto, ser en la práctica un procedimiento (aunque se siga declarando con la palabra function). Los parámetros también son optativos, claro: puede haber funciones sin ningún parámetro y funciones con decenas de ellos (aunque esto último no sea demasiado recomendable). La invocación de la función se hace como en pseudocódigo: poniendo el nombre de la función y su lista de parámetros (si los tiene). Por ejemplo: . // Definición de la función function potencia(base, exponente) { var i; var resultado = 1; for (i = 1; i &lt;= exponente; i++) { resultado = resultado * base; } return resultado; } // Invocación de la función var b = 9; var e = 4; var p = potencia(9, 4); document.write(\"9 elevado a 4 es \" + p); . Paso de parámetros: ¿por valor o por referencia? . Recuerda que, cuando se invoca un subalgoritmo, hay dos modos de enviarle los parámetros y que es muy importante distinguirlos. Observa el ejemplo anterior de la función potencia(). Los parámetros formales son base y exponente. Los parámetros actuales son b y e. | Paso de parámetros por valor: el valor de los parámetros actuales (b y e) se asigna a los parámetros formales del subalgoritmo. Así, base y exponente adquieren los mismos valores que tenían b y e, pero ahí termina toda su relación: a partir de entonces, se comportan como variables independientes de base y exponente. | Paso de parámetros por referencia: los parámetros actuales (b y e) quedan ligados a los parámetros formales (base y exponente). Si el valor de base o de exponente cambia dentro de la función, también cambiarán b y e fuera de la función, porque en realidad son las mismas variables. | . Pues bien, en Javascript: . | el paso de parámetros de tipos primitivos (ya sabes, number, string, boolean, etc) siempre se hace por valor. | el paso de parámetros de tipos complejos (llamados objetos), siempre se hace por referencia. | . ¿Que qué son los famosos objetos, preguntas? Tal vez hayas oído hablar de la programación orientada a objetos. Le dedicaremos a ese tema un capítulo más adelante, pero, de momento, quédate con la idea de que un objeto es cualquier variable que no sea de un tipo primitivo. Por ejemplo, los arrays son objetos en Javascript. Así que la conclusión es que los arrays siempre se pasan por referencia en Javascript, mientras que las variables simples siempre se pasan por valor. 7.2.9. Entrada y salida . Hay varias formas de hacer la entrada y salida de datos con Javascript, es decir, hay varios equivalentes a la instrucciones Leer y Escribir de pseudocódigo. Para nuestros primeros programas, usaremos la función prompt() para hacer la entrada y la propiedad innerHTML para hacer la salida. A veces, sustituiremos esta última por la función document.write() o por la función alert(). | Instrucción | Pseudocódigo | Javascript | . | Entrada | Leer variable | variable = prompt(); | . | Salida | Escribir expresión | document.getElementById('selector').innerHTML = expresión; O bien: document.write(expresión); O bien: alert(expresión); | . Vamos a ver un poco más despacio cómo se usa cada una de estas funciones: . Entrada de datos con prompt() . La entrada de datos en Javascript puede hacerse de diversas maneras. En particular, usando formularios HTML, pero de momento no vamos a pelearnos con eso. En esta primera toma de contacto con el lenguaje, vamos a conformarnos con la función prompt(). Esta función muestra un mensaje en forma de ventana emergente y permite escribir un texto, asignándolo a una variable. Observa cómo se usa prompt() con este ejemplo escrito primero en pseudocódigo y luego en Javascript: . Pseudocódigo: . Escribir(\"Dime un número\") Leer n . Javascript: . document.write(\"Dime un número\"); n = prompt(); . Si pruebas este código, verás que sucede algo raro: el mensaje “Dime un número” sale escrito en la ventana del navegador web, pero el número nos lo pide en una ventana emergente que se sitúa por encima del mensaje. ¡Y, en algunos navegadores, el mensaje “Dime un número” ni siquiera llega a verse! . Esto hace un efecto muy raro. ¿verdad? Para evitarlo, puedes unir las dos instrucciones en una sola, puesto que prompt() te permite incluir un mensaje en la caja de texto. Así: . n = prompt(\"Dime un número\"); . Al ejecutar este código, verás que el resultado es mucho más natural: . (Nota: la forma exacta en la que veas estas pantallas dependerá de tu navegador web, puesto que cada uno hace el prompt de manera ligeramente distinta) . Salida de datos con innerHTML, document.write() y alert() . La forma más sencilla de hacer la salida de datos con Javascript es usar document.write() o su hermana melliza, document.writeln(). Mira cómo se usa en este ejemplo y el resultado que produce en la ventana del navegador: . Código: . &lt;script&gt; document.write(\"Hola, mundo\"); &lt;/script&gt; . Resultado: . La diferencia entre write() y writeln() es que la segunda insertará automáticamente un salto de línea tras la salida, y la primera no. Sin embargo, estas funciones tiene un grave problema: puede que el texto de salida no se muestre inmediatamente. La decisión de cuándo se muestra la salida la toma el navegador y hay poco que puedas hacer al respecto. Por eso, la usaremos en contadas ocasiones. Otra manera muy sencilla de hacer salida de datos es con alert(). Esta función muestra un texto en forma de ventana emergente. Parecido a prompt(), pero sin caja de texto para escribir. Observa a alert() en acción en el siguiente ejemplo: . Código: . &lt;script&gt; alert(\"Hola, mundo\"); &lt;/script&gt; . Resultado: . La salida con alert() es simple y efectiva, pero resulta muy invasiva. Si haces todo tu programa con alert(), el usuario se sentirá enseguida apabullado por esa cantidad de ventanas emergentes que le saltan a la cara. De modo que nos queda la tercera vía. Es la más enrevesada, pero también la mejor. Y, en fin, tampoco es tan complicado. Consiste en preparar una zona de la pantalla del navegador para hacer en ella la salida de datos, y luego acceder a la misma con document.getElementById().innerHTML. Si sabes un poco de HTML, el lenguaje de marcado con el que se codifican las páginas web, enseguida comprenderás lo que estamos haciendo. Si no tienes ni idea de HTML, no te preocupes. Basta con que sigas los pasos que proponemos aquí para que puedas ejecutar tus programas Javascript. Ya tendrás tiempo de aprender HTML más adelante. Paso 1. Prepara la caja donde se hará la salida. La caja se crea un la etiqueta &lt;div&gt; de HTML, a la que puedes asignar un estilo de visualización. La primeras veces, puedes limitarte copiar y pegar este código en todos los programas Javascript que vayas a hacer: . &lt;div id='salida' style='text-align: center; border-style: solid; border-color: black'&gt;&lt;/div&gt; &lt;script&gt; // Escribe aquí tu programa Javascript &lt;/script&gt; . Paso 2. Dentro de tu programa Javascript, utiliza document.getElementById(‘salida’).innerHTML = expresión para hacer la salida. Sí, lo sé, es un poco largo, pero Javascript es así. Por ejemplo, este código: . &lt;div id='salida' style='text-align: center; border-style: solid; border-color: black'&gt;&lt;/div&gt; &lt;script&gt; document.getElementById('salida').innerHTML = \"Hola, mundo\"; &lt;/script&gt; . …producirá este resultado: . Paso 3. Utiliza document.getElementById(‘salida’).innerHTML += expresión si no quieres perder la salida anterior. Es decir, si usas un igual (=), cada salida de datos borrará la pantalla. Si usas más igual (+=), la salida de datos se añadirá a la anterior, sin borrarla: . &lt;div id='salida' style='text-align: center; border-style: solid; border-color: black'&gt;&lt;/div&gt; &lt;script&gt; document.getElementById('salida').innerHTML += \"Hola, mundo\"; &lt;/script&gt; . Paso 4 (OPTATIVO). Cambia las propiedades de tu caja de salida. Intenta juguetear con las propiedades text-align, border-style o border-color del div de salida. Además, hay muchas otras propiedades que puedes asignarle a esa caja. Si te atreves, investiga un poco cómo cambiar el color del texto o la tipografía. 7.2.10. Arrays . Los arrays en Javascript son mucho más que simples arrays: se trata de elementos muy complejos y flexibles que se adaptan a multitud de soluciones. Aquí solo vamos a ver una introducción a los mismos. Conforme vayas profundizando en tu conocimiento de Javascript, descubrirás cosas nuevas sobre estas asombrosas estructuras y les sacarás más y más partido. Declaración de arrays . Los arrays en Javascript se pueden declarar de diversas formas: . // Una forma de declarar un array: var ciudades = ['Almería', 'Granada', 'Málaga']; // Otra forma de declarar un array: var ciudades = new Array('Almería', 'Granada', 'Málaga'); // Esta es otra forma: var ciudades = new Array(3); ciudades[0] = 'Almería'; ciudades[1] = 'Granada'; ciudades[2] = 'Málaga'; // Y otra forma más: var ciudades = []; ciudades[0] = 'Almería'; ciudades[1] = 'Granada'; ciudades[2] = 'Málaga'; . Realmente, no todas estas formas son equivalentes, porque Javascript a veces tratará a la variable ciudades como un Array y a veces como un objeto. La diferencia entre una y otra cosa es tan sutil que, de momento, puedes desentenderte de ello. Si algún día te vuelves un experto en Javascript, ya entenderás esa diferencia. Por ahora, quédate con la idea de que todas estas formas son válidas para declarar un array. Características de los arrays en Javascript . Como puedes observar por los ejemplos anteriores, los arrays de Javascript tienen dos características importantes: . | No es necesario indicar su tamaño al declararlos, aunque se puede hacer. Esto se debe a que los arrays en Javascript son dinámicos: pueden crecer o decrecer durante la ejecución del programa. | El índice empieza en 0. Es decir, el primer elemento es el 0, el segundo es el 1, etc. | El acceso a los elementos del array se hace como en pseudocódigo: indicando el índice del elemento entre corchetes. | . Los arrays NO son variables primitivas (simples). Recuerda que esto significa que siempre se pasan por referencia a las funciones, mientras que las variables primitivas se pasan por valor. Repasa el paso de parámetros a funciones del que hablamos un poco más arriba si no recuerdas bien todo esto. Una cosa muy peculiar de los arrays de Javascript es que sus elementos pueden ser de diferente tipo. Por ejemplo: . // Este array tiene elementos del mismo tipo (strings): var ciudades = ['Almería', 'Granada', 'Málaga']; // Este array tiene elementos de diferente tipo: var miArray = ['Lunes', 5, ciudades]; . En el ejemplo anterior, el array ciudades solo contiene elementos de tipo string, mientras que el array miArray contiene elementos de tipo dispares: un string, un number y un array. Como ves, nada impide que un elemento de un array sea otro array. De hecho, un elemento de un array puede ser cualquier cosa. Propiedades y métodos . Los arrays de Javascript, como cualquier objeto, tienen una serie de propiedades y métodos. Ya veremos exactamente qué son las propiedades y los métodos, pero de momento te basta saber que se trata de funciones y variables que están dentro del objeto de tipo array y que permiten usarlo. Algunas propiedades y métodos útiles de los arrays son: . | nombreArray.length: devuelve el número de elementos del array. | nombreArray.sort(): ordena el array. | nombreArray.push(valor): añade un elemento al array (a continuación de la última posición usada). Como consecuencia, el tamaño del array crecerá. | nombreArray.pop(): elimina el último elemento del array. Como consecuencia, el tamaño del array decrecerá. | nombreArray.indexOf(valor): busca el elemento valor en el array y devuelve su posición (si lo encuentra) o -1 (si no lo encuentra). | . Hay muchas otras propiedades y métodos que puedes consultar en la referencia oficial del lenguaje. Recorrido de un array . El recorrido de un array puede hacerse igual que en pseudocódigo, con la salvedad de que tendremos que averiguar la longitud del array antes de recorrerlo, puesto que el tamaño del array puede variar a lo largo del programa: . var ciudades = ['Almería', 'Granada', 'Málaga']; var longArray = ciudades.length; for (i = 0; i &lt; longArray; i++) { document.write(ciudades[i]); } . Existen formas alternativas de hacer esto mismo sin necesidad de averiguar la longitud del array ni usar variables índice. Por ejemplo, así: . var ciudades = ['Almería', 'Granada', 'Málaga']; var ciudad; for (ciudad of ciudades) { document.write(ciudad); } . 7.2.11. Los objetos predefinidos de Javascript . Los objetos, como hemos dicho varias veces ya, los estudiaremos en el próximo capítulo. Por ahora te basta saber que son construcciones de Javascript que encierran dentro de sí una serie de funciones y variables para manipular diferentes elementos y facilitar la vida al programador. Por ejemplo, los arrays son objetos. Pues bien, existen muchos otros objetos predefinidos en Javascript. Te voy a presentar a unos cuantos particularmente útiles, aunque debes saber que hay muchos más. Cuando vayas profundizando en tu conocimiento de este lenguaje los irás conociendo. | Date. Permite obtener la fecha y hora actual del reloj del ordenador. Por ejemplo: . var d = new Date(); // Fecha y hora actual document.write('Día de la semana', d.getDay()); document.write('Día del mes', d.getDate()); document.write('Mes', d.getMonth()); document.write('Año', d.getFullYear()); . | Math. Este objeto contiene una enorme colección de funciones matemáticas. Algunas son: . | sin(x), cos(x), tan(x): calcula el seno, el coseno y la tangente de x. | max(valor1, valor2, …, valorN), min(valor1, valor2, …, valorN): calcula el máximo o el mínimo de una lista de valores. | round(x): redondea el número x al entero más próximo. Si ya era entero, lo deja como estaba. | trunc(x): trunca el número x. Es decir, elimina los decimales, sin redondear. | pow(b, e): calcula la potencia de b elevado a e. | random(): devuelve un número real aleatorio entre 0 y 1. Si quieres que sea un aleatorio entero entre dos valores cualesquiera, tendrás que hacer algo así: . document.write(\"Aleatorio de 0 a 1: \" + Math.random()); document.write(\"Aleatorio de 0 a 99: \" + Math.trunc(Math.random()*100)); document.write(\"Aleatorio de 1 a 100:\" + Math.trunc(Math.random()*100 + 1)); document.write(\"Aleatorio de 0 a 100:\" + Math.trunc(Math.random()*101)); . | . | window. Proporciona acceso a una ventana del navegador web. Te ofrece métodos muy interesantes como: . | open(): abre una ventana del navegador nueva. | close(): cierra una ventana del navegador. | moveTo(x, y): mueve la ventana actual a la posición x, y. | resizeTo(tamañoX, tamañoY): cambia el tamaño de la ventana actual. | screenX y screenY: nos da las coordenadas X e Y donde se encuentra la ventana ubicada en este momento. | innerWidth y innerHeight: nos devuelve el espacio disponible dentro de la ventana del navegador (en píxeles). | . | document. Proporciona acceso al texto escrito dentro de la ventana del navegador. Lo hemos estado usando para generar la salida de nuestros programas. Estos son algunos métodos: . | write(): añade texto a la ventana del navegador. | writeln(): añade texto a la ventana del navegador, y termina con una salto de línea. | open(): elimina todo el contenido que haya en la ventana del navegador e inicia una nueva salida. | close(): finaliza el envío de datos a la ventana del navegador. | getElementById(): recupera un elemento del navegador a partir de su id. | . | . ",
    "url": "https://iescelia.org//docs/tico/_site/javascript/#72-bienvenidos-a-javascript",
    "relUrl": "/javascript/#72-bienvenidos-a-javascript"
  },"69": {
    "doc": "X. Lenguaje Javascript",
    "title": "7.3. Escribiendo programas con Javascript",
    "content": "Ya conocemos cómo se manejan los principales componentes de un programa con Javascript: variables, instrucciones de control, asignaciones, funciones, etc. Ahora nos queda saber cómo juntamos todo eso para escribir nuestros programas, ¿no te parece? . Por fortuna, en esto Javascript también se parece mucho a pseudocódigo. 7.3.1. Caja de herramientas . ¿Qué necesitamos para comenzar a escribir programas en Javascript? ¿Tendrás que instalar un montón de programas de desarrollo en tu ordenador? . La verdad es que no. Para desarrollar con Javascript basta con que tengas instalado: . | Un editor de texto. No te sirve Microsoft Word ni Libreoffice Writer. Tiene que ser un editor de texto plano, es decir, que no introduzca información de formato en el archivo. Solo el texto. Existen muchísimos editores de estas características, porque son programas muy simples y livianos. El bloc de notas de Windows es uno de ellos, aunque resulta poco recomendable porque no colorea el código fuente ni te ayuda a corregir errores. Un editor de texto para programación que ha tenido un crecimiento espectacular en los últimos años a nivel aficionado y profesional es Visual Studio Code. Es multiplataforma (tiene versiones para Windows, Linux y Mac) y de código abierto. Y es una auténtica maravilla, así que te recomiendo que lo descargues (¡siempre de la web oficial, por favor!) y lo instales. Si trabajas con Linux, seguramente lo encuentres en los repositorios oficiales de tu distribución. Esa, por supuesto, también es una fuente confiable desde donde instalarlo. | Un navegador web. Todos los navegadores web llevan en sus tripas un intérprete de Javascript, puesto que todas las páginas web actuales utilizan Javascript para funcionar. Puedes usar el navegador web que más te guste: Google Chrome, Mozilla Firefox, Microsoft Edge, el Safari de Apple, Opera, etc. | . 7.3.2. Flujo de trabajo . Lo habitual cuando estés escribiendo y depurando programas en Javascript es que tengas abiertos a la vez los dos programas: . | El editor de texto, para ir escribiendo y modificando tu código. | El navegador web, para ir probando tu código. | . El flujo de trabajo, al menos al principio, será este: . | Comprender bien el problema que se pretende resolver. | Pensar un rato en el algoritmo que vas a escribir. Si es necesario, hacer un boceto en papel y/o en pseudocódigo. | Abrir el editor de texto y escribir una primera versión del programa. Si es muy largo, dividirlo en trozos más pequeños y escribir solo el primero de ellos. | Comprobar que el programa o fragmento de programa funciona en el navegador web. No pasar al siguiente fragmento hasta que este no funcione correctamente. | Repetir los pasos 3 y 4 hasta que el programa esté completo. | . Ten en cuenta que, cuando los programas empiecen a volverse complejos, no podrás resolverlos de una sentada. Escribir un programa muy complejo puede llevarte días, semanas o meses. 7.3.3. Dónde y cómo escribir el código fuente . Los programas en Javascript pueden guardarse en dos tipos de archivo: . | Archivos con extensión .js. Estos archivos suelen contener bibliotecas de funciones Javascript usadas por otros programas. No se ejecutan directamente. | Archivos con extensión .html o .htm. El navegador web los interpretará como páginas web y, por lo tanto, los ejecutará. Aquí es donde colocaremos nuestro código, al menos al principio. | . Dentro del archivo .html, el código Javascript debe ir incrustado entre las etiquetas &lt;script&gt; y &lt;/script&gt;, que marcan el comienzo y el fin del programa: . &lt;script&gt; Aquí va el código Javascript &lt;/script&gt; . Escribiremos el algoritmo principal de un programa en Javascript sin ninguna palabra especial que lo identifique como tal. Es decir, el código estará sin más en el archivo fuente, entre las etiquetas &lt;script&gt; y &lt;/script&gt;. (Insisto: hay otras formas de hacer esto, pero, de momento, esta es más que suficiente para nosotros). Los subalgoritmos sí que deben identificarse con la palabra function seguida del nombre del subalgoritmo, como hemos visto más arriba. El orden en el que escribas los algoritmos es indiferente. En el archivo, puede aparecer primero el algoritmo principal y luego los subalgoritmos, o al revés. Utiliza el orden que te parezca más lógico y con el que te sientas cómodo. ",
    "url": "https://iescelia.org//docs/tico/_site/javascript/#73-escribiendo-programas-con-javascript",
    "relUrl": "/javascript/#73-escribiendo-programas-con-javascript"
  },"70": {
    "doc": "X. Lenguaje Javascript",
    "title": "7.4. Eventos y temporizadores",
    "content": "7.4.1. Eventos de Javascript . Javascript puede responder a los eventos que sucedan en la página web. ¿Qué es un evento? Esto es fácil de responder: un evento es cualquier cosa que suceda dentro del navegador a lo que el navegador pueda responder. Por ejemplo, un evento es “hacer clic con el ratón sobre un enlace”. Otro evento es “escribir un carácter en un cuadro de texto”. Y otro evento es: “cerrar la ventana del navegador”. Hay muchos eventos distintos, y cada uno puede ocurrir asociado a cualquier elemento de la página web. Pero el evento estrella es, sin duda, “hacer clic”. Observa el siguiente fragmento de código HTML. No hace falta que sepas HTML. Tú solo míralo: . &lt;button&gt;Púlsame&lt;/button&gt; . ¿Te imaginas lo que se verá en el navegador si cargas esa página? Pues sí: un botón cuyo texto será “Púlsame”. Ahora mira el mismo código, ligeramente modificado: . &lt;button onclick='procesar_boton()'&gt;Púlsame&lt;/button&gt; . Ese “onclick” a continuación del botón significa que vamos a capturar el evento clic de ratón asociado al botón. Al hacer clic sobre él, se ejecutará la función procesar_boton() de Javascript. Usaremos algún evento onclick() como este en los ejercicios para conseguir resultados curiosos. Sobre los eventos, se podría hablar muchísimo más, pero como introducción a Javascript es suficiente por ahora… . 7.4.2. Temporizadores de Javascript . Lo que te voy a contar ahora puede considerarse Javascript avanzado (o, al menos, no es Javascript básico). Pero lo vas a necesitar para hacer juegos y otras diversiones con Javascript y, en fin, tampoco es tan complicado… . Se trata de los temporizadores. Un temporizador es como el cronómetro de una bomba de relojería de las que salen en las películas. Ya sabes, esas bombas que siempre tienen una pantalla LCD donde se ve una cuenta atrás que indica cuánto falta para que explote. (El temporizador es el cronómetro, no la bomba, que conste…) . Un temporizador se pone en marcha así: . var timer = setTimeout('nombre-de-función', intervalo); . El nombre-de-función es exactamente eso: el nombre de alguna función Javascript que ya exista. El intervalo es un número entero. Lo que hace el temporizador es iniciar una cuenta atrás de intervalo milisegundos y, cuando el cronómetro llega a cero, se ejecuta la función indicada. Por ejemplo: . var timer = setTimeout('saludar', 1000); function saludar() { alert(\"Hola, mundo\"); } . Si ejecutas este código, verás que el saludo (¡Hola, mundo!) tarda exactamente un segundo en aparecer. El temporizador se ha encargado de ello. Nada más ejecutar el código, se ha puesto en marcha un temporizador cuyo encargo es ejecutar la función saludar() al cabo de 1000 milisegundos (es decir, un segundo). Programar acciones para que se realicen en el futuro abre muchísimas posibilidades. En particular, piensa en qué ocurriría si hacemos que la propia función saludar() vuelva a reestablecer el temporizador: . var timer = setTimeout('saludar', 1000); function saludar() { alert(\"Hola, mundo\"); setTimeout('saludar', 1000); } . Detente un momento a tratar de averiguar qué ocurriría al ejecutar este programa y por qué podríamos decir sin dudarlo que se trata de uno de los programas más plastas que hemos escrito hasta ahora. Si no te lo crees, pruébalo y lo comprobarás. Por último, si, por lo que sea, necesitas detener un temporizador que ya está en marcha, solo tienes que usar la función clearTimeout(): . clearTimeout(timer); . Lógicamente, la variable timer debe ser la misma que usaste al crear el temporizador. ",
    "url": "https://iescelia.org//docs/tico/_site/javascript/#74-eventos-y-temporizadores",
    "relUrl": "/javascript/#74-eventos-y-temporizadores"
  },"71": {
    "doc": "X. Lenguaje Javascript",
    "title": "7.5. Un ejemplo completo: las tres en raya",
    "content": "Llegó la hora de poner manos a la obra. Si hay una sección de este capítulo que tienes que leer con atención, es esta. Así que es un mal momento para tener prisa. Vamos a escribir un programa completo en Javascript. Te puede servir de plantilla para desarrollar tus propios programas a partir de aquí. El programa en cuestión será una versión del juego de las tres en raya que resolvimos en el tema de introducción a la programación. No dudes en repasar aquel ejercicio resuelto para ver el pseudocódigo, puesto que nuestro programa será una traducción literal de ese pseudocódigo a Javascript. Aquí tienes el código fuente completo. Estúdialo con atención y asegúrate de entenderlo todo (o un gran porcentaje) antes de continuar. Ah, y no dejes de compararlo línea a línea con el mismo código en pseudocódigo. 7.5.1. El código fuente . &lt;div id='salida' style='text-align: center; border-style: solid; border-color: black; font-family: mono'&gt;&lt;/div&gt; &lt;script&gt; //------------------------- // ALGORITMO PRINCIPAL //------------------------- var tablero = new Array(10); var ganador; var tablas; inicializar(tablero) // Esto es un subalgoritmo. Está escrito más abajo do { mostrar(tablero); colocar_pieza_humano(tablero); ganador = comprobar_ganador(tablero); tablas = comprobar_tablas(tablero); if ((ganador == \"Ninguno\") &amp;&amp; (tablas == false)) { colocar_pieza_ordenador(tablero); ganador = comprobar_ganador(tablero); tablas = comprobar_tablas(tablero); } } while ((ganador == \"Ninguno\") &amp;&amp; (tablas == false)); mostrar(tablero); if (ganador == \"Ninguno\") { document.getElementById('salida').innerHTML += \"EL JUEGO HA TERMINADO EN TABLAS\"; } else { document.getElementById('salida').innerHTML += \"EL JUEGO HA TERMINADO. EL GANADOR ES: \" + ganador; } // -------------------------------------------- // Inicializa el tablero con espacios en blanco // -------------------------------------------- function inicializar(tablero) { //let i; for (i = 1; i &lt;= 9; i++) { // Como tablero es un array, se pasa por referencia y los cambios que // hagamos aquí se reflejarán en el algoritmo principal tablero[i] = \" \"; } } // -------------------------------------------- // Muestra el estado actual del tablero // -------------------------------------------- function mostrar(tablero) { document.getElementById('salida').innerHTML = \"ESTADO ACTUAL DEL TABLERO&lt;br&gt;\"; document.getElementById('salida').innerHTML += \"+-+-+-+&lt;br&gt;\"; document.getElementById('salida').innerHTML += \"|\" + tablero[1] + \"|\" + tablero[2] + \"|\" + tablero[3] + \"|&lt;br&gt;\"; document.getElementById('salida').innerHTML += \"+-+-+-+&lt;br&gt;\"; document.getElementById('salida').innerHTML += \"|\" + tablero[4] + \"|\" + tablero[5] + \"|\" + tablero[6] + \"|&lt;br&gt;\"; document.getElementById('salida').innerHTML += \"+-+-+-+&lt;br&gt;\"; document.getElementById('salida').innerHTML += \"|\" + tablero[7] + \"|\" + tablero[8] + \"|\" + tablero[9] + \"|&lt;br&gt;\"; document.getElementById('salida').innerHTML += \"+-+-+-+&lt;br&gt;\"; } // --------------------------------------------------- // Coloca una pieza del jugador humano en el tablero // --------------------------------------------------- function colocar_pieza_humano(tablero) { var casilla, casilla_correcta; do { casilla = prompt(\"¿En qué casilla quieres poner una pieza? (1-9)\"); casilla_correcta = false; if (tablero[casilla] == \" \") { tablero[casilla] = \"X\"; casilla_correcta = true; } else { document.getElementById('salida').innerHTML += \"Error: Esa casilla ya está ocupada&lt;br&gt;\"; } } while (casilla_correcta == false); } // --------------------------------------------------- // Coloca una pieza del ordenador en el tablero // --------------------------------------------------- function colocar_pieza_ordenador(tablero) { var casilla, casilla_correcta; casilla_correcta = false; do { casilla = Math.round(Math.random()*9); alert(\"Voy a colocar mi pieza en la casilla \" + casilla); if (tablero[casilla] == \" \") { tablero[casilla] = \"O\"; casilla_correcta = true; } else { alert(\"¡Está ocupada! Voy a elegir otra\"); } } while (casilla_correcta == false); } // --------------------------------------------------- // Comprueba si hay un ganador según el estado del // tablero. Devuelve \"Ninguno\", \"Humano\" u \"Ordenador\" // --------------------------------------------------- function comprobar_ganador(tablero) { var ganador = \"Ninguno\"; // Comprobamos primera fila if ((tablero[1] == tablero[2]) &amp;&amp; (tablero[1] == tablero[3])) { if (tablero[1] == \"X\") { ganador = \"Humano\"; } if (tablero[1] == \"O\") { ganador = \"Ordenador\"; } } // Comprobamos segunda fila if ((tablero[4] == tablero[5]) &amp;&amp; (tablero[4] == tablero[6])) { if (tablero[4] == \"X\") { ganador = \"Humano\"; } if (tablero[4] == \"O\") { ganador = \"Ordenador\"; } } // Comprobamos tercera fila if ((tablero[7] == tablero[8]) &amp;&amp; (tablero[7] == tablero[9])) { if (tablero[7] == \"X\") { ganador = \"Humano\"; } if (tablero[7] == \"O\") { ganador = \"Ordenador\"; } } // Comprobamos primera columna if ((tablero[1] == tablero[4]) &amp;&amp; (tablero[1] == tablero[7])) { if (tablero[1] == \"X\") { ganador = \"Humano\"; } if (tablero[1] == \"O\") { ganador = \"Ordenador\"; } } // Comprobamos segunda columna if ((tablero[2] == tablero[2]) &amp;&amp; (tablero[2] == tablero[8])) { if (tablero[2] == \"X\") { ganador = \"Humano\"; } if (tablero[2] == \"O\") { ganador = \"Ordenador\"; } } // Comprobamos tercera columna if ((tablero[3] == tablero[6]) &amp;&amp; (tablero[3] == tablero[9])) { if (tablero[3] == \"X\") { ganador = \"Humano\"; } if (tablero[3] == \"O\") { ganador = \"Ordenador\"; } } // Comprobamos una diagonal if ((tablero[1] == tablero[5]) &amp;&amp; (tablero[1] == tablero[9])) { if (tablero[1] == \"X\") { ganador = \"Humano\"; } if (tablero[1] == \"O\") { ganador = \"Ordenador\"; } } // Comprobamos la otra diagonal if ((tablero[3] == tablero[5]) &amp;&amp; (tablero[3] == tablero[7])) { if (tablero[3] == \"X\") { ganador = \"Humano\"; } if (tablero[3] == \"O\") { ganador = \"Ordenador\"; } } return ganador; } // ------------------------------------------- // Comprueba si hay una situación de tablas // según el estado actual del tablero. Devuelve // verdadero si hay tablas o falso en otro caso. // ------------------------------------------- function comprobar_tablas(tablero) { var tablas; var i, contador = 0; for (i = 1; i &lt;= 9; i++) { if (tablero[i] != \" \") { contador++; } } // Si todas las casillas están ya ocupadas y no hay ganador, // entonces estamos en tablas. if (contador == 9) { tablas = true; } else { tablas = false; } return tablas; } &lt;/script&gt; . 7.5.2. ¿Cómo ejecutar y depurar este programa? . Guarda el programa anterior en un archivo de texto con extensión .html (por ejemplo, 3-en-raya.html). Luego, sencillamente, haz doble clic sobre él para abrirlo. El sistema operativo usará el navegador web predeterminado de tu sistema para abrir el archivo y la ejecución comenzará. ¡Socorro! El programa no funciona . ¿El resultado no es el esperado? Es lo habitual. Habrá algún error en el código y te tocará depurarlo. Las páginas web (con Javascript incluido) son extraordinariamente resistentes a los errores. No te mostrarán mensajes de error cada vez que haya algo mal escrito. Al contrario, permanecerán en silencio para no asustar al usuario de la web y provocar que salga corriendo de allí. Por ese motivo, los errores de Javascript solo se dejan ver en la “sala de máquinas” del navegador. Por supuesto, los programadores/as tienen una manera de acceder a esa “sala de máquinas”. Pulsa F12 en tu navegador para abrir la consola de errores de Javascript. Asegúrate de seleccionar la pestaña etiquetada como Console. Verás algo como esto: . En la consola de errores aparecen, en rojo, los mensajes de error que haya lanzado el intérprete de Javascript, indicándote el tipo de error y la línea en la que se ha detectado. Los mensajes estarán en inglés, por supuesto, pero ¿qué esperabas? Si quieres aprender a programar, tienes que acostumbrarte a manejar el inglés técnico. ¡Atención! Dependiendo del navegador que uses, puede que esa consola de errores se abra con otra combinación de teclas. Tendrás que bichear un poco por internet para averiguarlo. Lo habitual, sin embargo, es F12. Cuando hayas localizado el error, regresa a tu editor de texto, haz los cambios necesarios, guarda las modificaciones y recarga la página (pulsando F5 en la mayoría de los navegadores). Si el navegador se había quedado colgado, tendrás que cerrarlo, esperar unos segundos y volver a abrirlo. Y así hasta que funcione. ¡Mucha paciencia y sangre fría! Recuerda siempre que la mayor parte del tiempo de programación se va en depurar programas, no en escribirlos. ",
    "url": "https://iescelia.org//docs/tico/_site/javascript/#75-un-ejemplo-completo-las-tres-en-raya",
    "relUrl": "/javascript/#75-un-ejemplo-completo-las-tres-en-raya"
  },"72": {
    "doc": "X. Lenguaje Javascript",
    "title": "7.6. Ejercicios propuestos",
    "content": "Ejercicio 1. Tabla de multiplicar . Vamos a empezar por algo sencillito. Escribe un programa en Javascript que pida un número y muestre la tabla de multiplicar de ese número. Puedes utilizar esta plantilla para tu primer programa: . &lt;div id='salida' style='text-align: center; border-style: solid; border-color: black'&gt;&lt;/div&gt; &lt;script&gt; // Escribe aquí el programa de la tabla de multiplicar &lt;/script&gt; . Recuerda que la salida la puedes enviar al &lt;div&gt; ‘salida’ con la expresión: document.getElementById(‘salida’).innerHTML . Ejercicio 2. Juego del número secreto . Ahora algo solo un poquito más complicado: una versión en Javascript del juego del número secreto. (Puedes encontrarlo resuelto en el capítulo “Introducción a la programación”) . Ejercicio 3. Botón saltarín . Aquí empezamos a divertirnos. Vamos a hacer una página web con un botón. Al pulsar ese botón, Javascript hará que ¡el botón cambie de sitio! . Para eso, capturaremos el evento click del botón. El botón lo tienes que crear antes mediante HTML. No importa que no sepas HTML. Solo echa un vistazo a este código: . &lt;body&gt; &lt;button id='boton' onclick='mover_boton()' style='position: absolute; top: 100px; left: 200px'&gt;Púlsame&lt;/button&gt; &lt;script&gt; function mover_boton() { // Escribe aquí tu código javascript } &lt;/script&gt; &lt;/body&gt; . Ahora solo te queda programar la función mover_boton(). Para lograr que el botón se mueva, tendrás que fijarte primero en cómo está el botón creado: tiene un id, un evento onclick y un style. Dentro del este último se definen dos propiedades: . | top es la distancia desde la parte superior de la ventana del navegador hasta el botón. Lo hemos establecido en 100 píxeles (100px). | left es la distancia desde la parte izquierda de la ventana del navegador hasta el botón. Le hemos dado 200 píxeles. | . Pues bien, debes hacer que Javascript modifique esas dos propiedades. Por ejemplo, así: . function mover_boton() { document.getElementById('boton').style.top = '150px'; document.getElementById('boton').style.left = '250px'; } . Con eso, el botón se moverá al hacer clic sobre él, pero solo la primera vez. Quedará emplazado en la posición top = 150px y left = 250px y ya no se desplazará más. ¿Y si quisiéramos que se moviera siempre que hagamos clic sobre él? Es es lo que tienes que conseguir en este ejercicio. Ejercicio 4. Ventana nerviosa y botones evanescentes . Ahora vamos a conseguir que una ventana entera del navegador se mueva al pulsar un botón. Y a hacer aparecer y desaparecer botones. De hecho, vamos a crear cuatro botones: . | Botón “Saltar”: al pulsarlo, la ventana dará un salto. Es decir, cambiará de posición.. | Botón “Temblar”: al pulsarlo, la ventana se pondrá a “temblar”, como si tuviera frío o se hubiera puesto nerviosa, durante un rato. | Botón “Ocultar”: al pulsarlo, los dos botones anteriores desaparecerán de la vista. | Botón “Mostrar”: al pulsarlo, los botones desaparecidos volverán a aparecer. | . Esos cuatro botones puedes crearlos con este código HTML. También crearemos una segunda ventana del navegador, que será la que cambiará de posición: . &lt;body&gt; &lt;h1&gt;Ventana nerviosa&lt;/h1&gt; &lt;button id='btn_saltar' onclick='btn_saltar()'&gt;Saltar&lt;/button&gt; &lt;button id='btn_temblar' onclick='btn_temblar()'&gt;Temblar&lt;/button&gt; &lt;button id='btn_ocultar' onclick='btn_ocultar()'&gt;Ocultar&lt;/button&gt; &lt;button id='btn_mostrar' onclick='btn_mostrar()'&gt;Mostrar&lt;/button&gt; &lt;script&gt; myWindow = window.open('', '', 'width=300, height=200'); function btn_saltar() { // Escribe aquí tu código javascript para cuando se pulse el botón \"Saltar\" } function btn_temblar() { // Escribe aquí tu código javascript para cuando se pulse el botón \"Temblar\" } function btn_ocultar() { // Escribe aquí tu código javascript para cuando se pulse el botón \"Ocultar\" } function btn_mostrar() { // Escribe aquí tu código javascript para cuando se pulse el botón \"Mostrar\" } &lt;/script&gt; &lt;/body&gt; . Lo siguiente es programar el código de cada una de las cuatro funciones Javascript, que se ejecutarán al pulsar cada botón. No te voy a decir lo que tienes que escribir en ellas, pero sí te voy a dar un par de pistas: . | Pista nº 1. Hay un objeto en Javascript llamado window, que nos permite alterar las propiedades de la ventana del navegador. Por ejemplo, nos permite cambiar su posición y su tamaño. En el apartado 5.2.11, sobre Objetos predefinidos de Javascript, hablamos de qué modo se puede cambiar eso. Observa que, en el fragmento de código anterior, hemos creado un objeto window llamado myWindow. Es sobre ese objeto sobre el que tienes que actuar. | Pista nº 2. En el ejercicio anterior cambiábamos las propiedades top y left de un botón, pero los botones (y cualquier cosa que haya en una página web) tienen muchas otras propiedades (¡pero MUCHAS!). Una de ellas se llama visibility, y puede tomar dos valores: visible o hidden. | . Ejercicio 5. Colorines . Vamos a juguetear más con las propiedades de la página web cargada desde Javascript. En esta ocasión, construiremos una página con un cuadro de texto, un botón y un recuadro de color negro. Si escribimos en la caja de texto otro color (por ejemplo, “orange”) y hacemos click en el botón, el recuadro negro tiene que cambiar de color y volverse naranja. El código HTML que puedes usar como base es este: . &lt;html&gt; &lt;head&gt; &lt;title&gt;Colorines&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Colorines&lt;/h1&gt; &lt;div id='caja_color' style='position: absolute; top: 5%; left: 70%; width: 25%; height: 20%; background-color: black'&gt;&lt;/div&gt; &lt;input type='text' id='color' value='yellow'&gt; &lt;button id='boton' onclick='cambiar_color()'&gt;Cambiar color&lt;/button&gt; &lt;script&gt; function cambiar_color() { // Escribe aquí el código Javascript } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; . Observa que, además de preparar los tres elementos que necesitamos (el recuadro de color negro, la caja de texto y el botón), hemos añadido más elementos HTML como head o title. Esos elementos son necesarios para que la página web se considere bien formada. Si no sabes lo que significan (aunque es bastante evidente), puedes repasarlos en el capítulo dedicado a HTML. (El navegador se tragará la página web aunque no esté bien formada, pero lo correcto es hacerla bien dentro de lo posible). Ahora solo te falta escribir el código de la función Javascript para cambiar el color del recuadro. Ejercicio 6. Pelota de goma . Busca en internet una imagen de una pelota que te guste y descárgala. En esa imagen no debe aparecer nada más, excepto la pelota. Luego insértala en una página web, así: . &lt;body&gt; &lt;img id='pelota' src='nombre-del-archivo-de-la-imagen' style='position: absolute; width: 100px; height: 100px'&gt; &lt;/body&gt; . En ‘nombre-del-archivo-de-la-imagen’, como es lógico, tendrás que escribir el nombre del archivo que contiene tu pelota. Le hemos asignado 100 píxeles de ancho y 100 de alto, pero si es demasiado pequeña o demasiado grande, siéntete libre de cambiar esas cantidades. Ahora escribe en Javascript un programa para que la pelota rebote por la pantalla como si fuera una pelota de verdad. Para conseguirlo, tendrás que: . | Alterar de nuevo las propiedades top y left de la pelota | Usar las propiedades el objeto window para evitar que la pelota se salga de los márgenes de la pantalla. | Utilizar un temporizador para mover la pelota cada x milisegundos. Según el valor de x, la pelota se moverá más deprisa o más despacio. | . Mejora para los más valientes: trata de añadir un botón a este programa. Al pulsarlo, la pelota se detendrá. Al volver a pulsarlo, la pelota se pondrá en marcha de nuevo. Ejercicio 7. Tres en raya improved . Modifica el juego de las tres en raya para que sea más atractivo al usuario y más cómodo de jugar. Encontrarás el código fuente del juego más arriba, en este mismo capítulo. Tienes que eliminar todas las entradas de datos mediante prompt() y sustituirlas por cajas de texto HTML, como esta: . ¿En qué casilla quieres poner tu pieza? (1-9) &lt;input type='text' id='casilla'&gt; &lt;button onclick='colocar_pieza()'&gt;Aceptar&lt;/button&gt; &lt;script&gt; function colocar_pieza() { var casilla = document.getElementById('casilla').value; // A partir de aquí, iría el código para colocar la pieza del jugador en esa casilla } &lt;/script&gt; . Al hacer clic en el botón, se ejecutará la función colocar_pieza(). Observa cómo se extrae el texto escrito en el cuadro de texto para llevárnoslo a una variable de Javascript (llamada casilla). También puedes mejorar la apariencia del juego alterando sus colores, tipografías, etc. Tendrás que investigar un poco en internet sobre cómo puede hacerse eso. Ejercicio 8. Tenis . (Aviso: este ejercicio es de dificultad elevada) . Ya sabes hacer que una pelota rebote (ejercicio 5). Vamos a mejorar ese programa haciendo una versión del clásico juego de tenis “Pong”, el primer videojuego comercial de la historia. Si no conoces el Pong, bichea un poco por Internet para averiguar cómo es. ¡Y ahora trata de programar una versión actualizada en Javascript! . Ejercicio 9. Carretera al infierno . (Aviso: este ejercicio es de dificultad elevada) . En esta ocasión, vamos a programar un juego que llamaremos “Carretera al infierno”. En el juego, manejaremos un coche (busca en internet la imagen de un coche visto desde arriba). El coche aparecerá en la parte inferior de la pantalla, centrado y mirando hacia arriba. Una carretera irá desplazándose de arriba a abajo. La carretera no será recta, sino que tendrá irregularidades aleatorias hacia la izquierda y hacia la derecha. Nuestro objetivo es mover el coche hacia la izquierda y hacia la derecha para evitar que se salga de la carretera. La carreterá se moverá cada vez más deprisa. El objetivo del juego es aguantar la mayor cantidad posible de tiempo sin salirnos. ",
    "url": "https://iescelia.org//docs/tico/_site/javascript/#76-ejercicios-propuestos",
    "relUrl": "/javascript/#76-ejercicios-propuestos"
  },"73": {
    "doc": "X. Lenguaje Javascript",
    "title": "7.7. Ejercicios resueltos",
    "content": "Aquí iremos poniendo los ejercicios que resolvamos en clase. Ejercicio 1. Tabla de multiplicar . &lt;h1&gt;Tabla de multiplicar&lt;/h1&gt; &lt;div id='salida' style='text-align: center; border-style: solid; border-color: black'&gt;&lt;/div&gt; &lt;script&gt; var n = prompt(\"Dime un número\"); for (i = 1; i &lt;= 10; i++) { document.getElementById('salida').innerHTML += n + \" x \" + i + \" = \" + n*i + \"&lt;br&gt;\"; } &lt;/script&gt; . ",
    "url": "https://iescelia.org//docs/tico/_site/javascript/#77-ejercicios-resueltos",
    "relUrl": "/javascript/#77-ejercicios-resueltos"
  },"74": {
    "doc": "X. Lenguaje Javascript",
    "title": "X. Lenguaje Javascript",
    "content": " ",
    "url": "https://iescelia.org//docs/tico/_site/javascript/",
    "relUrl": "/javascript/"
  },"75": {
    "doc": "2. El lenguaje SQL",
    "title": "2. El lenguaje SQL",
    "content": ". | 2.1. Creando las tablas con SQL . | 2.1.1. Creación de tablas: CREATE TABLE | 2.1.2. Modificación de tablas: ALTER TABLE | 2.2.3. Borrado de tablas: DROP TABLE | 2.1.4. Algunas consideraciones sobre la integridad referencial | . | 2.2. Manipulando los datos con SQL . | 2.2.1. Inserción de datos: INSERT | 2.2.2. Modificación de datos: UPDATE | 2.2.3. Borrado de datos: DELETE | . | 2.3. Buscando información con SQL: la instrucción SELECT . | 2.3.1. Seleccionar columnas de una tabla | 2.3.2. Filtrar resultados: la cláusula WHERE | 2.3.3. Búsquedas aproximadas con caracteres comodín | 2.3.4. Ordenar resultados con ORDER BY | 2.3.5. Agrupar resultados con DISTINCT | 2.3.6. Funciones de agregado y GROUP BY | 2.3.7. Obtener resultados de varias tablas: JOIN | 2.3.8. SQL avanzado: introducción a las subconsultas | 2.3.9. Otras cuestiones avanzadas: alias y combinaciones de consultas | . | 2.4. ¿Y cómo puedo probar todo esto? | 2.5. Ejercicios | . Cuando tenemos una base de datos relacional ya diseñada, llega el momento de acceder a esa base de datos para operar con ella: . | En primer lugar, crear las tablas, es decir, las estructuras donde se van a guardar los datos. | En segundo lugar, operar con los datos: insertar, modificar, borrar y, lo más habitual de todo, buscar información y recuperarla. | . Para hacer todo eso existe un lenguaje estandarizado que soportan la mayoría de las bases de datos relaciones. Puede que tu nombre te suene: se llama SQL, y vamos a dedicar todo este capítulo a aprenderlo . ",
    "url": "https://iescelia.org//docs/tico/_site/lenguaje-sql/",
    "relUrl": "/lenguaje-sql/"
  },"76": {
    "doc": "2. El lenguaje SQL",
    "title": "2.1. Creando las tablas con SQL",
    "content": "El lenguaje SQL nos permite crear las tablas, modificarlas y borrarlas. Las instrucciones más importantes para hacer esto son: . | CREATE TABLE: para crear tablas. | ALTER TABLE: para modificar una tabla existente. | DROP TABLE: para eliminar tablas. | . Escribiremos, a partir de ahora, las palabras reservadas de SQL en MAYÚSCULA por convenio y para distinguirlas del resto. Realmente, SQL no distingue mayúsculas de minúsculas, así que puedes escribirlas como prefieras. 2.1.1. Creación de tablas: CREATE TABLE . La instrucción CREATE TABLE sirve para crear tablas en la base de datos. Tiene muchísimas posibilidades. No es mi intención mostrártelas todas, porque para eso necesitarías un curso de SQL avanzado. Pero, a través de algunos ejemplos, aprenderás a usarla a un nivel básico enseguida. La sintaxis básica (que admite montones de añadidos, pero que raramente usarás, al menos al principio) es esta: . CREATE TABLE nombre_de_tabla ( columna1 tipo, columna2 tipo, columna3 tipo, etc. ); . Por ejemplo, así se crea una tabla de clientes: . CREATE TABLE clientes ( id INTEGER, nombre VARCHAR(100), apellido1 VARCHAR(100), apellido2 VARCHAR(100), fecha_nacimiento DATE, estatura DECIMAL(1,2), email VARCHAR(200) ); . SQL maneja multitud de tipos de datos, pero por ahora basta con que conozcas estos: . | INTEGER = números enteros. Hay varios subtipos, como BIGINT (entero enorme), SMALLINT (entero pequeño), etc. Se diferencian entre sí por el número más grande que son capaces de almacenar. La mayoría de las veces, INTEGER es más que suficiente. | VARCHAR = cadenas de caracteres (se indica la longitud máxima entre paréntesis). | CHAR = cadenas de caracteres. Se diferencia de VARCHAR en que, si no se usan todos los caracteres, se rellenan con espacios. Con los VARCHAR no sucede eso: los caracteres que no se usan, simplemente, no existen. Ante la duda, usa siempre VARCHAR en lugar de CHAR. | DECIMAL = números reales (se indica entre paréntesis la cantidad de cifras antes y después de la coma decimal) | DATE = fechas. | TIME = horas. | DATETIME = fecha y hora. | BLOB = información binaria así, en general. Los campos BLOB pueden usarse para guardar imágenes, archivos ejecutables, secuencias de vídeo o de audio… | TEXT = información de texto de grandes dimensiones, que no nos quepa dentro de un VARCHAR o un CHAR. | . Ahora vamos a utilizar algunos modificadores en la tabla clientes: . CREATE TABLE clientes ( id INTEGER NOT NULL UNIQUE AUTO_INCREMENT, nombre VARCHAR(100) NOT NULL, apellido1 VARCHAR(100) NOT NULL, apellido2 VARCHAR(100) NOT NULL, fecha_nacimiento DATE, estatura DECIMAL(1,2), email VARCHAR(200), PRIMARY KEY (id) ) DEFAULT CHARACTER SET utf-8 COLLATE utf8-spanish-ci; . Fíjate en que hemos añadido algunas cosas a algunas columnas: . | NOT NULL significa que ese campo no puede quedarse en blanco, es decir, que todos los clientes deben tener obligatoriamente un valor asignado en ese campo. | UNIQUE significa que el valor de ese campo no puede repetirse, esto es, que debe ser diferente en todos los clientes de la tabla. | AUTO_INCREMENT hace que la base de datos, cada vez que se inserta un registro, asigne a este campo el número entero inmediatamente superior al que se asignó al último registro insertado. Solo funciona con campos de tipo INTEGER. Suele utilizarse en el campo ID de las tablas para no tener que ocuparnos de insertar nosotros un número manualmente. | PRIMARY KEY especifica cual es la clave primaria de la tabla. Pueden ponerse varios campos, separados por comas. Lo lógico es que la clave sea NOT NULL y UNIQUE al mismo tiempo. | . También hemos añadido algunos modificadores que afectan a toda la tabla, no solo a algunos campos: . | CHARACTER SET indica la condificación de caracteres que va a usarse en la tabla. | COLLATE indica cómo van a ordenarse los caracteres en la tabla. Por ejemplo, usando utf8-spanish-ci nos aseguramos de que la Ñ va entre la N y la P. Si usásemos otras colaciones, la Ñ se ordenaría después de la Z. | . Los modificadores que se pueden emplear con un CREATE TABLE son muy numerosos, pero la mayoría se usan con muy poca frecuencia. Los principales son los que hemos visto en este ejemplo. Otro modificadorde uso frecuente es el que se emplea para la creación de claves ajenas. Obsérvalo en este otro ejemplo: . CREATE TABLE clientes ( id INTEGER NOT NULL UNIQUE, nombre VARCHAR(100) NOT NULL, apellido1 VARCHAR(100) NOT NULL, apellido2 VARCHAR(100) NOT NULL, fecha_nacimiento DATE, estatura DECIMAL(1,2), email VARCHAR(200), id_ciudad INTEGER NOT NULL, PRIMARY KEY (id), FOREIGN KEY (id_ciudad) REFERENCES ciudades(id) ) DEFAULT CHARACTER SET utf-8 COLLATE utf8-spanish-ci; . Hemos añadido el campo id_ciudad que, obviamente, es una clave ajena que pertenece a la tabla ciudades. Pues bien, para informar a la base de datos que ese campo, en efecto, es una clave ajena, hay que usar FOREIGN KEY, indicándole la tabla (ciudades) y el campo (id) al que está enlazada nuestra clave ajena. Por último, debes saber que tanto a restricción de clave primaria como a las restricciones de claves ajenas puede asignárseles un nombre. Esto es importante si luego queremos modificar esas claves sin necesidad de borrar toda la tabla (con la consiguiente pérdida de datos) para volver a crearla. Se hace así: . CREATE TABLE clientes ( ... CONSTRAINT pk_clientes PRIMARY KEY (id), CONSTRAINT fk_clientes_ciudades FOREIGN KEY (id_ciudad) REFERENCES ciudades(id) ); . Como ves, basta con añadir CONSTRAINT nombre a la restricción de clave primaria o de clave ajena. Esto asigna un nombre a esa restricción para poder referirnos a él más adelante (ver ALTER TABLE). El nombre para las restricciones de clave primaria suele empezar por las letras pk_ (de “primary key”) y el de las restricciones de clave ajena por fk_ (de “foreign key”), pero esto solo es una convención que no tienes por qué respetar. 2.1.2. Modificación de tablas: ALTER TABLE . La modificación de la estructura de una tabla que ya existe se hace con la instrucción ALTER TABLE. Vamos a ver cómo trabaja esta instrucción con unos ejemplos basado en la tabla clientes del apartado anterior. De nuevo, ALTER TABLE tiene muchísimas opciones, pero las que te voy a mostrar en estos ejemplos cubren el 99% de los usos habituales. En primer lugar, si queremos añadir un campo (o varios) a una tabla ya existente, haremos esto: . ALTER TABLE clientes ADD telefono VARCHAR(15) NOT NULL; . También podemos eliminar un campo (o columna) existente (cuidado: todos los datos de ese campo se perderán): . ALTER TABLE clientes DROP COLUMN email; . Podemos, asimismo, renombrar campos: . ALTER TABLE clientes RENAME COLUMN email TO correo_electronico; . O podemos modificar campos, cambiando su tipo o sus restricciones (¡Ojo! Esto puede afectar a los datos que haya almacenados en ese campo, si la tabla ya tiene datos, puesto que el SGBD intentará convertirlos de un tipo de dato a otro. Si no lo consigue, la instrucción fallará): . ALTER TABLE MODIFY COLUMN telefono INTEGER; . Por último, con ALTER TABLE se pueden crear o borrar las restricciones de la tabla, tales como claves primarias o claves ajenas. ALTER TABLE ADD CONSTRAINT pk_clientes PRIMARY KEY(id); . Para borrar una restricción, tendremos que haberles asignado un nombre al crear la tabla. Así: . ALTER TABLE DROP CONSTRAINT pk_clientes; . 2.2.3. Borrado de tablas: DROP TABLE . El borrado de tablas se hace en sql con la instrucción DROP TABLE. Es muy fácil de usar, puesto que solo hay que indicar el nombre de la tabla que queremos borrar. ¡Mucho cuidado! Esta acción es destructiva y perderás todos los datos que hubiera almacenados en esa tabla. Por ejemplo, para borrar la tabla clientes de los ejemplos anteriores, escribiríamos esto: . DROP TABLE clientes; . 2.1.4. Algunas consideraciones sobre la integridad referencial . La integridad referencial es un mecanismo de seguridad de las bases de datos que asegura que la información entre las claves ajenas y las claves primarias a las que hacen referencia permanezca siempre bien sincronizada. Enseguida pondremos un ejemplo en el que lo entenderás muy bien. Ahora lo importante es que quede claro esto: perder esa sincronización entre clave ajena y clave primaria (es decir, romper la integridad referencial) es equivalente a perder datos. Y, si una base de datos va por ahí perdiendo datos, ¿para qué narices sirve? . Entendiendo qué es la integridad referencial . En el siguiente ejemplo se ve muy bien en qué consiste la pérdida de integridad referencial y los problemas de pérdida de datos que causa. Imaginemos dos tablas de una base de datos más grande (por ejemplo, de una biblioteca): la tabla libros contiene información sobre los libros (cod_libro y título, entre otros campos), mientras que la tabla autores contiene información sobre los autores de los libros (cod_autor y nombre, entre otros campos). La tabla libros tiene una clave ajena, cod_autor, que es un campo que en realidad pertenece a la tabla autores pero que expandimos hasta libros para implementar la relación 1:N entre ambas entidades. ¡Repasa el capítulo anterior, sobre diseño de bases de datos, si no sabes de lo que estamos hablando! . (En realidad, la relación entre libros y autores es N:N, porque un libro puede ser escrito por muchos autores y cada autor puede escribir muchos libros, pero aquí la consideramos una 1:N para simplificar el ejemplo) . Este es el aspecto que podrían tener esas dos tablas o, al menos, un fragmento de ellas: . No hay que se un lince para darse cuenta de que todos los códigos de autor que aparecen en la tabla libros se corresponden con autores que realmente existen en la tabla autores. ¿Pero qué pasaría si, por cualquier razón, un código de autor inexistente acabase por error en la tabla de libros? Entonces tendríamos algo como esto: . Ahí lo tenemos: el libro 484 (“Ana Karenina”) está asociado al autor 32, que no existe en la tabla de autores. ¿El resultado? Hemos perdido información. Ya no hay manera de saber quién escribió ese libro. Es lo mismo que si hubiésemos borrado un registro, o parte de un registro, de una tabla, aunque en realidad nadie ha borrado nada. Te puedes estar diciendo: “Sí, claro, ¿pero quién va a ser tan idiota de escribir un código que no existe en el campo cod_autor?” . Hay cientos de razones por las que el código equivocado puede acabar asignado a una clave ajena: puede tratarse de un error de programación en la aplicación cliente, puede haber un fallo de comunicaciones, puede ocurrir un problema de concurrencia, puede que alguien elimine, a propósito o sin querer, un autor que ya tenía libros asignados. Y sí, también hay gente idiota en el mundo, esto es incuestionable. Y algunos podrían acabar usando nuestra base de datos. Como el problema de la integridad referencial es tan frecuente y potencialmente devastador, las bases de datos se autoprotegen e impiden que la integridad referencial pueda violarse. El efecto colateral de esta obsesión por la protección de los datos es que no podrás insertar los datos en cualquier orden. En el ejemplo anterior, tendrás que insertar primero al autor del libro en la tabla autores y luego al libro en la tabla libros, y no al revés, porque en tal caso estarías violando la integridad referencial. Borrado en cascada . El borrado en cascada es una de las formas que tiene la base de datos de proteger la integridad referencial. Uno de los errores más frecuentes que provoca la violación de la integridad referencial es el borrado de un registro de una tabla que está referenciado en otra tabla como clave ajena. Para entenderlo mejor, vamos a volver sobre nuestro ejemplo de la tabla libros y la tabla autores. Supongamos que vamos a borrar un autor (el que tiene código 4): . El resultado de borrar ese registro es que se rompe la integridad referencial, porque el libro 485 hará referencia a un autor que ya no existe: . La base de datos impedirá este borrado para no violar la integridad referencial. Pero se puede hacer algo más: activar el borrado en cascada. Cuando se activa el borrado en cascada para una clave ajena, la base de datos se encargará de eliminar los registros adecuados si se borra un registro de la tabla a la que hace referencia esa clave ajena. Así también se protege la integridad referencial. En el ejemplo anterior, al borrar el autor 4, también se borrarán en cascada (¡y automáticamente!) todos los libros escritos por ese autor: . El borrado en cascada se habilita durante la creación de la tabla con el modificador ON DELETE CASCADE. Por ejemplo, si queremos habilitarlo para la tabla libros anterior: . CREATE TABLE libros ( cod_libro INTEGER NOT NULL UNIQUE, titulo VARCHAR(500), cod_autor INTEGER NOT NULL, FOREIGN KEY (cod_autor) REFERENCES autores(cod_autor) ON DELETE CASCADE ); . Modificación en cascada . La modificación de registros también puede provocar fallos de integridad referencial. Por ejemplo: ¿qué ocurre si modificamos la clave de un registro de nuestra tabla de autores? . Aquí lo tenemos otra vez: al cambiar el código del autor “Benito Pérez Galdós” de 4 a 5, el libro 485 vuelve a quedarse sin autor. ¡Hemos perdido información de nuevo! . Como en el caso del borrado, la base de datos nos prohibirá hacer este tipo de cosas para proteger la integridad referencial. Y, como en el caso del borrado, también existe la posibilidad de habilitar la actualización o modificación en cascada, de manera que, si cambia el valor de una clave primaria, pueda modificarse el valor de la clave ajena automáticamente: . Para habilitar la modificación en cascada, hay que especificarlo con ON UPDATE CASCADE durante la creación en la clave ajena: . CREATE TABLE libros ( cod_libro INTEGER NOT NULL UNIQUE, titulo VARCHAR(500), cod_autor INTEGER NOT NULL, FOREIGN KEY (cod_autor) REFERENCES autores(cod_autor) ON DELETE CASCADE ON UPDATE CASCADE ); . Como ves en este código, la actualización y el borrado en cascada pueden usarse simultáneamente. También pueden habilitarse más tarde, cuando la tabla ya está en uso, mediante un ALTER TABLE. ",
    "url": "https://iescelia.org//docs/tico/_site/lenguaje-sql/#21-creando-las-tablas-con-sql",
    "relUrl": "/lenguaje-sql/#21-creando-las-tablas-con-sql"
  },"77": {
    "doc": "2. El lenguaje SQL",
    "title": "2.2. Manipulando los datos con SQL",
    "content": "Hasta aquí hemos visto cómo SQL nos permite crear la estructura de la base de datos, es decir, las tablas con sus campos, tipos, restricciones, etc. Pero aún no lo hemos usado para almacenar y manipular datos, que es el objetivo final de toda base de datos. De eso se encarga otra parte de SQL llamada DML (lenguaje de manipulación de datos). En realidad, la creación de la estructura se hace solo una vez, cuando la base de datos se construye. Cuando la base de datos ya está en uso, raramente se altera la estructura, puesto que sería como modificar la estructura de una casa cuando ya está habitada: hay que meterse de albañiles y eso siempre es un engorro. Durante la inmensa mayoría del tiempo de explotación de una base de datos, el SQL que se utiliza es el que vamos a ver en esta sección. SQL tiene varias instrucciones para manipular datos, pero nos vamos a centrar en las cuatro más importantes: . | INSERT: sirve para insertar datos en una tabla. | UPDATE: modifica datos ya existentes. | DELETE: elimina datos de una tabla. | SELECT: consulta datos de una o varias tablas. | . Insisto en la idea: estas instrucciones actúan a nivel de datos, es decir, de registros o filas de las tablas. Insertan, modifican y borran registros. Para insertar, modificar y borrar campos está el lenguaje de definición de datos, es decir, CREATE TABLE, ALTER TABLE o DROP TABLE. 2.2.1. Inserción de datos: INSERT . La instrucción INSERT se utiliza para insertar registros en una tabla. Como siempre, vamos a aprender a utilizarla mediante algunos ejemplos. Supongamos que tenemos una tabla llamada personas con los siguientes campos: . PERSONAS(id, nombre, apellido1, apellido2, estatura, fecha_nacimiento, pais_nacimiento) . Esta tabla se habrá creado mediante esta instrucción: . CREATE TABLE personas ( id INTEGER NOT NULL UNIQUE AUTO_INCREMENT, nombre VARCHAR(100) NOT NULL, apellido1 VARCHAR(100) NOT NULL, apellido2 VARCHAR(100) NOT NULL, estatura INTEGER, fecha_nacimiento DATE, pais_nacimiento VARCHAR(100), PRIMARY KEY (id) ); . Pues bien: para insertar una fila en esta tabla, basta con escribir esta instrucción INSERT: . INSERT INTO personas(nombre, apellido1, apellido2, estatura, fecha_nacimiento, pais_nacimiento) VALUES ('José', 'Pérez', 'Sánchez', '179', '13/12/1998', 'México'); . En este código puedes observar varias cosas curiosas: . | No indicamos el valor del campo id porque lo hemos declarado como AUTO_INCREMENT y la base de datos se encargará de asignarle un valor automáticamente. | Primero indicamos una lista de campos y luego una lista de valores. Los valores se asignarán a los campos en el mismo orden en el que están escritos. | No hacemos distinción entre campos de texto, numéricos o fechas: todos los valores se escriben entre comillas. Da igual que sean comillas simples (‘) o dobles (“): SQL admite las dos. De hecho, los números pueden escribirse sin comillas, pero, para evitar errores, mi recomendación es que escribas todos los valores, siempre, entre comillas. | . Es posible no asignar valores a todos los campos. Por ejemplo, estatura, fecha_nacimiento y pais_nacimiento no están declarados como NOT NULL, es decir, que se pueden dejar en blanco, así que este INSERT también funcionaría: . INSERT INTO personas(nombre, apellido1, apellido2) VALUES ('Susana', 'García', 'Moreno'); . En cambio, si intentamos dejar en blanco el nombre o uno de los dos apellidos, el INSERT fallará. 2.2.2. Modificación de datos: UPDATE . La modificación o actualización de registros se hace mediante la instrucción UPDATE. La podemos ver en acción en este ejemplo basado en la misma tabla personas del apartado anterior: . UPDATE personas SET nombre = 'Luis' WHERE id = 18; . Lo que hace UPDATE es localizar un registro que coincida con la condición expresada en la cláusula WHERE, el decir, localiza el registro cuyo id valga 18, y modifica el valor del campo nombre de ese registro, asignándole el valor “Luis”. Se pueden actualizar varios campos a la vez: . UPDATE personas SET nombre = 'Luis', estatura = '180' WHERE id = 25; . Y también se puede usar otra condición que no sea sobre el campo id. Por ejemplo, esta instrucción UPDATE actualizará todos los nombres almacenados como “Paco” y los cambiará por “Francisco”. UPDATE personas SET nombre = 'Francisco' WHERE nombre = 'Paco'; . Por lo tanto, un UPDATE puede afectar 0, 1 o muchas filas de la tabla. ¡Mucho cuidado con ejecutar un UPDATE sin cláusula WHERE! Esa actualización afectará a todos los registros de la tabla: . UPDATE personas SET nombre = 'Francisco'; . ¡Acabamos de cambiar el nombre de todas las personas de nuestra base de datos! . 2.2.3. Borrado de datos: DELETE . Para eliminar registros utilizamos la instrucción DELETE. Aquí tienes un ejemplo sobre la tabla personas. Vamos a borrar la persona con id = 18: . DELETE FROM personas WHERE id = 18; . Al igual que UPDATE, DELETE localizará el registro (o registros) que coincida con la condición expresada en la cláusula WHERE. Y, una vez localizado, lo borrará. Obviamente, DELETE es una instrucción destructiva y debe usarse con cautela. Se pueden borrar varios registros a la vez. Por ejemplo, así borraremos a todas las personas cuyo primer apellido sea “Pérez”: . DELETE FROM personas WHERE apellido1 = 'Pérez'; . Y así borramos todos los registros de una tabla y la dejamos completamente vacía. ¡Utilízalo solo cuando estés muy seguro/a de lo que estás haciendo! . DELETE FROM personas; . ",
    "url": "https://iescelia.org//docs/tico/_site/lenguaje-sql/#22-manipulando-los-datos-con-sql",
    "relUrl": "/lenguaje-sql/#22-manipulando-los-datos-con-sql"
  },"78": {
    "doc": "2. El lenguaje SQL",
    "title": "2.3. Buscando información con SQL: la instrucción SELECT",
    "content": "Para buscar datos entre las tablas de una base de datos se usa la sentencia SELECT. Estas búsquedas suelen recibir el nombre de consultas. El resultado de una búsqueda de datos tiene forma de tabla y está constituido por el conjunto de datos que cumplen unos criterios de búsqueda, porque, para buscar datos con SQL, no hace falta indicarle a la base de datos cómo hacer la búsqueda, sino qué datos tiene que buscar. Y ella se encarga de todo. Sí, es increíble, pero funciona. La sentencia SELECT es, probablemente, la más compleja del lenguaje SQL. Sin embargo, no necesitas conocerla en profundidad para sacarle partido. La mayor parte del tiempo, SELECT se usa en alguna de sus formas más simples. Si más adelante te vuelves un experto/a en bases de datos, ya aprenderás los usos más complejos. Para comprender mejor los siguientes ejemplos, vamos a suponer que nuestra tabla personas contiene estos siete registros (que quede claro que, en un caso real, la tabla podría tener cientos o miles de registros): . | id | nombre | apellido1 | apellido2 | estatura | fecha_nacimiento | pais_nacimiento | . | 1 | Antonia | López | Zapata | 171 | 18/02/2002 | España | . | 2 | Micaela | Cruz | Ortega | 168 | 23/03/1993 | México | . | 3 | Luis Fernando | Guzmán | Rojas | 174 | 01/01/2001 | Colombia | . | 4 | Juan | López | Gutiérrez | 191 | 28/02/1997 | Argentina | . | 5 | Esteban | López | López | 166 | 07/09/2001 | México | . | 6 | Ana Lucía | Smith | López | 185 | 19/01/2000 | Argentina | . | 7 | Fernando José | Delgado | Aguas | 157 | 17/08/1969 | México | . 2.3.1. Seleccionar columnas de una tabla . La sintaxis más básica concebible de una sentencia SELECT funcional es esta: . SELECT columna1, columna2, ..., columnaN FROM nombre_tabla; . Por ejemplo, esta instrucción nos devolverá todos los registros de la tabla personas, pero seleccionando solo las columnas nombre, apellido1 y apellido2 y desechando todas las demás: . SELECT nombre, apellido1, apellido2 FROM personas; . El resultado de la consulta será: . Antonia López Zapata Micaela Cruz Ortega Luis Fernando Guzmán Rojas Juan López Gutiérrez Esteban López López Ana Lucía Smith López Fernando José Delgado Aguas . El símbolo * (asterisco) significa “todas las columnas”. De modo que esto nos devolverá todo el contenido de la tabla personas sin excepción: . SELECT * FROM personas; . El resultado de esta consulta será: . 1 Antonia López Zapata 171 18/02/2002 España 2 Micaela Cruz Ortega 168 23/03/1993 México 3 Luis Fernando Guzmán Rojas 174 01/01/2001 Colombia 4 Juan López Gutiérrez 191 28/02/1997 Argentina 5 Esteban López López 166 07/09/2001 México 6 Ana Lucía Smith López 185 19/01/2000 Argentina 7 Fernando José Delgado Aguas 157 17/08/1969 México . 2.3.2. Filtrar resultados: la cláusula WHERE . Normalmente, no vamos a necesitar todos los registros de una tabla, sino que queremos localizar alguno o algunos en concreto. Para eso sirven las búsquedas, ¿no? Para encontrar unos pocos resultados entre un montón de datos. Pues bien, para filtrar esos resultados se utiliza la cláusula WHERE. Es sencilla de comprender. Simplemente, se indica una condición que afecte a alguno de los campos de la tabla, y la base de datos se encargará de encontrar para nosotros los registros que cumplan esa condición. Por ejemplo, esta consulta nos devuelve los nombres y apellidos de todas las personas cuya estatura es igual a 168 cm (recuerda que estatura es un campo de nuestra tabla personas): . SELECT nombre, apellido1, apellido2 FROM personas WHERE estatura = '168'; . Como resultado, solo obtendremos un registro, porque solo una persona cumple esa condición: . Micaela Cruz Ortega . La condición puede utilizar los operadores de comparación habituales: . | Igual que: = | Mayor que: &gt; | Mayor o igual: &gt;= | Menor que: &lt; | Menor o igual: &lt;= | Distinto de: != | . Además, también existen operadores lógicos que ya conoces de otros lenguajes de programación: AND, OR y NOT. Con todo esto, se pueden hacer consultas bastante elaboradas con muy poco esfuerzo. Por ejemplo, vamos a pedirle a la base de datos que busque a todas las personas que miden más de 170 cm: . SELECT nombre, apellido1, apellido2 FROM personas WHERE estatura &gt; '170'; . El resultado será: . Antonia López Zapata Luis Fernando Guzmán Rojas Juan López Gutiérrez Ana Lucía Smith López . Esta otra consulta localiza a todas las personas cuyo primer apellido es “López” y que miden más de 170 cm: . SELECT nombre, apellido1, apellido2 FROM personas WHERE apellido1 = 'López' AND estatura &gt; '170'; . Resultado: . Antonia López Zapata Juan López Gutiérrez . Y esta otra busca a todas las personas que tienen “López” como primer o segundo apellido y que han nacido antes del año 2002. Observa cómo se pueden usar paréntesis para agrupar condiciones: . SELECT nombre, apellido1, apellido2 FROM personas WHERE (apellido1 = 'López' OR apellido2 = 'López') AND fecha_nacimiento &lt; '01/01/2002'; . Resultado: . Juan López Gutiérrez Esteban López López Ana Lucía Smith López . 2.3.3. Búsquedas aproximadas con caracteres comodín . Las comparaciones en la cláusula WHERE permiten usar lo que se llaman caracteres comodín, que son básicamente dos: % (símbolo del tanto por ciento) y _ (símbolo del subrayado). | % significa “cualquier conjunto de caracteres, incluyendo ningún carácter”. | _ significa “un carácter cualquiera”. En algunos gestores de bases de datos, este carácter es “?” (interrogación) | . Las comparaciones que usan carácteres comodín deben escribirse con el operador de comparación LIKE, no con los operadores habituales. Por ejemplo, esta consulta localiza personas cuyo nombre comienza por la letra A, sin importar cuántos caracteres contenga el nombre a continuación de esa A: . SELECT nombre, apellido1, apellido2 FROM personas WHERE nombre LIKE 'A%'; . Resultado: . Antonia López Zapata Ana Lucía Smith López . Esta otra consulta busca a personas que hayan en el mes de enero de cualquier año: . SELECT nombre, apellido1, apellido2 FROM personas WHERE fecha_nacimiento LIKE '__/01/____'; . Resultado: . Luis Fernando Guzmán Rojas Ana Lucía Smith López . 2.3.4. Ordenar resultados con ORDER BY . Los resultados obtenidos en una consulta pueden ordenarse por cualquier campo con la cláusula ORDER BY, independientemente de cuales sean las condiciones de búsqueda. Por ejemplo, para obtener una lista de personas ordenadas por apellido: . SELECT nombre, apellido1, apellido2 FROM personas ORDER BY apellido1; . Resultado: . Micaela Cruz Ortega Fernando José Delgado Aguas Luis Fernando Guzmán Rojas Antonia López Zapata Juan López Gutiérrez Esteban López López Ana Lucía Smith López . Fíjate que Antonia López, Juan López y Esteban López comparten el primer apellido y, por ese motivo, siguen apareciendo desordenados. O, mejor dicho, aparecen en el orden en el que están almacenados en la tabla, que no tiene por qué ser alfabético. Se puede indicar un segundo criterio de ordenación (y un tercero, y un cuarto…). Nosotros vamos a usar como segundo criterio el segundo apellido, así: . SELECT nombre, apellido1, apellido2 FROM personas ORDER BY apellido1, apellido2; . Resultado: . Micaela Cruz Ortega Fernando José Delgado Aguas Luis Fernando Guzmán Rojas Esteban López López Juan López Gutiérrez Antonia López Zapata Ana Lucía Smith López . El ordenamiento se hace, por defecto, de manera ascendente (numérica en caso de campos numéricos o alfabética en caso de campos de texto). Se puede forzar un ordenamiento descendente con el modificador DESC. Por ejemplo, aquí obtenemos la lista de las personas apellidadas “López” ordenadas de la más alta a la más bajita: . SELECT nombre, apellido1, apellido2, estatura FROM personas WHERE apellido1 = \"López\" ORDER BY estatura DESC; . Resultado: . Juan López Gutiérrez 191 Antonia López Zapata 171 Esteban López López 166 . 2.3.5. Agrupar resultados con DISTINCT . Atención, pregunta. ¿Qué ocurrirá si ejecutamos esta consulta? . SELECT apellido1 FROM personas ORDER BY apellido1; . Si has respondido que obtendremos todos los primeros apellidos de todas las personas de la tabla personas, ordenados alfabéticamente, has acertado. Pero hay varias personas que comparten el primer apellido. Por esa razón, ese apellido aparece (“López”) repetido varias veces en el resultado: . Cruz Delgado Guzmán López López López Smith . Esta repetición de resultados puede ser algo buscado o un efecto secundario indeseable de la búsqueda. Para evitar resultados repetidos se usa DISTINCT. Por ejemplo, el siguiente SELECT nos mostrará todos los primeros apellidos de la tabla, pero sin repetir ninguno: . SELECT DISTINCT apellido1 FROM personas ORDER BY apellido1; . Cruz Delgado Guzmán López Smith . 2.3.6. Funciones de agregado y GROUP BY . En la lista de campos, se pueden utilizar las llamadas funciones de agregado. Se trata de funciones que realizan cálculos sobre los resultados de la consulta. Por ejemplo, esta consulta (que no usa funciones de agregado) nos devuelve los IDs de las personas cuyo país de nacimiento es “México”: . SELECT id FROM personas WHERE pais_nacimiento = \"México\"; . Resultado: . Micaela Cruz Ortega Esteban López López Fernando José Delgado Aguas . En cambio, esta otra consulta (que usa la función de agregado COUNT()) nos devuelve el número de personas cuyo país de nacimiento es “México”: . SELECT COUNT(id) FROM personas WHERE pais_nacimiento = \"México\"; . Resultado: . 3 . Las funciones de agregado más importantes son las siguientes: . | COUNT(): cuenta el número de filas que cumplen los criterios de búsqueda de la consulta. | MIN(): calcula el valor mínimo de un campo numérico. | MAX(): calcula el valor máximo de un campo numérico. | AVG(): calcula el valor promedio de un campo numérico. | SUM(): calcula la suma de todos los valores de un campo numérico. | . Con estas funciones, es muy fácil buscar, por ejemplo, la estatura máxima de todas las personas cuyo primer apellido es “López”: . SELECT MAX(estatura) FROM personas WHERE apellido1 = \"López\"; . Resultado: . 191 . Las funciones de agregado se usan a menudo con la clásula GROUP BY, que nos permite agrupar los resultados por algún campo. Observa cómo funciona en este ejemplo: . SELECT pais_nacimiento, COUNT(id) FROM personas; GROUP BY pais_nacimiento ORDER BY pais_nacimiento; . Esta consulta nos dirá cuántas personas han nacido en cada país, ofreciéndonos un resultado con un aspecto como este: . Argentina 2 Colombia 1 España 1 México 3 . Lo que ha ocurrido aquí es que los resultados se han agrupado por paises (GROUP BY pais_nacimiento) y, para cada grupo, se ha hecho el cálculo de la función de agregado (COUNT(id)). La cláusula GROUP BY aparece, a veces, acompañada de la cláusula HAVING, que es como WHERE pero aplicable a funciones de agregado. Por ejemplo, esta consulta nos mostrará la cantidad de personas nacidas en cada país pero solo de aquellos países de los que se contabilicen al menos 3 personas en la tabla: . SELECT pais_nacimiento, COUNT(id) FROM personas; ORDER BY pais_nacimiento GROUP BY pais_nacimiento HAVING COUNT(id) &gt;= 3 ; . Resultado: . México 3 . 2.3.7. Obtener resultados de varias tablas: JOIN . Hasta ahora, solo hemos visto ejemplos de consultas que obtienen datos de una sola tabla, pero es muy frecuente que queramos extraer datos de varias tablas relacionadas entre sí. SQL permite hacer eso con la cláusula JOIN. Para comprender cómo funciona JOIN, necesitamos añadir una o dos tablas a nuestra base de datos, así que los siguientes ejemplos se basarán en estas tres tablas: . PERSONAS(id, nombre, apellido1, apellido2, estatura, fecha_nacimiento, id_pais) PAISES(id, nombre, id_continente) CONTINENTES(id, nombre) . Como puedes imaginarte, el campo id_pais de la tabla PERSONAS es una clave ajena que está relacionada con el campo id de la tabla PAISES. Del mismo modo, id_continente en la tabla PAISES es una clave ajena enlazada con id en la tabla CONTINENTES. Para que quede más claro, te muestro un ejemplo de lo que podrían contener estas tablas: . TABLA PERSONAS . | id | nombre | apellido1 | apellido2 | estatura | fecha_nacimiento | id_pais | . | 1 | Antonia | López | Zapata | 171 | 18/02/2002 | 3 | . | 2 | Micaela | Cruz | Ortega | 168 | 23/03/1993 | 1 | . | 3 | Luis Fernando | Guzmán | Rojas | 174 | 01/01/2001 | 2 | . | 4 | Juan | López | Gutiérrez | 191 | 28/02/1997 | 7 | . | 5 | Esteban | López | López | 166 | 07/09/2001 | 1 | . | 6 | Ana Lucía | Smith | López | 185 | 19/01/2000 | 7 | . | 7 | Fernando José | Delgado | Aguas | 157 | 17/08/1969 | 1 | . | etc | etc | etc | etc | etc | etc | etc | . TABLA PAISES . | id | nombre | id_continente | . | 1 | México | 2 | . | 2 | Colombia | 2 | . | 3 | España | 4 | . | 4 | Australia | 5 | . | 5 | China | 3 | . | 6 | Egipto | 1 | . | 7 | Argentina | 2 | . | etc | etc | etc | . TABLA CONTINENTES . | id | nombre | . | 1 | África | . | 2 | América | . | 3 | Asia | . | 4 | Europa | . | 5 | Oceanía | . Ahora el nombre del país no está almacenado directamente en la tabla personas, sino en la tabla paises. Ambas tablas se relacionan gracias al campo id_pais. Lo mismo ocurre entre paises y continentes. Por lo tanto, si necesitamos recuperar, por ejemplo, los nombres y apellidos de todas las personas junto con su país de nacimiento, será necesario mezclar los datos de las tablas personas y paises. Esto se hace así: . SELECT personas.nombre, apellido1, apellido2, paises.nombre FROM personas JOIN paises ON personas.id_pais = paises.id . El resultado será: . Antonia López Zapata España Micaela Cruz Ortega México Luis Fernando Guzmán Rojas Colombia Juan López Gutiérrez Argentina Esteban López López México Ana Lucía Smith López Argentina Fernando José Delgado Aguas México . Observa algunas cosas importantes en esta sentencia: . | En la clásula FROM indicamos la tabla principal de nuestra consulta (personas). | En la clásula JOIN indicamos la segunda tabla de nuestra consulta (paises) y le indicamos a SQL cuál es el campo que relaciona personas con paises (personas.id_pais = paises.id). | En la lista de campos, tenemos dos campos llamados nombre, uno perteneciente a la tabla personas (el nombre de la persona) y otro perteneciente a la tabla paises (el nombre del país). Por eso es necesario distinguirlos poniendo delante el identificador de la tabla (personas.nombre y paises.nombre). Con apellido1 y apellido2 no hace falta, puesto que esos campos solo existen en la tabla personas. | . Y poco más hay que decir sobre los JOIN. Son así de sencillos. SQL se encargará de mostrar a cada persona con su país correspondiente, cruzando los datos de las dos tablas. Se puede hacer JOIN de más de dos tablas. En esos casos, basta con cruzar las tablas por parejas. Por ejemplo, para mostrar la lista de personas junto con su país y su continente de nacimiento, primero cruzaremos personas con paises y después paises con continentes. No se puede cruzar directamente personas con continentes porque no tienen ningún campo en común, es decir, no están directamente relacionadas entre sí. SELECT personas.nombre, apellido1, apellido2, paises.nombre, continentes.nombre FROM personas JOIN paises ON personas.id_pais = paises.id JOIN continentes ON paises.id_continente = continentes.id . El resultado de esta consulta será: . Antonia López Zapata España Europa Micaela Cruz Ortega México América Luis Fernando Guzmán Rojas Colombia América Juan López Gutiérrez Argentina América Esteban López López México América Ana Lucía Smith López Argentina América Fernando José Delgado Aguas México América . Por último, las consultas con JOIN también pueden llevar cláusulas WHERE, ORDER BY, GROUP BY o HAVING, como cualquier otra consulta. Por ejemplo, vamos a buscar los nombres, apellidos, país de nacimiento y continente de todas las personas nacidas a partir de 1 de enero del año 2000 y vamos a ordenar los resultados por apellidos: . SELECT personas.nombre, apellido1, apellido2, paises.nombre, continentes.nombre FROM personas JOIN paises ON personas.id_pais = paises.id JOIN continentes ON paises.id_continente = continentes.id WHERE fecha_nacimiento &gt;= '01/01/2000' ORDER BY apellido1, apellido2; . El resultado será: . Luis Fernando Guzmán Rojas Colombia América Esteban López López México América Antonia López Zapata España Europa Ana Lucía Smith López Argentina América . 2.3.8. SQL avanzado: introducción a las subconsultas . Hay ciertas situaciones en las que nos encontramos con una consulta tan compleja que no se puede resolver con las herramientas que hemos visto hasta ahora. En esos casos, utilizar una subconsulta en una cláusula WHERE o HAVING suele obrar milagros. Sin embargo, no conviene abusar de este recurso: las consultas con subconsultas siempre consumen más recursos y son más lentas de ejecutar que las consultas convencionales. La subconsulta se inserta en cualquier cláusula WHERE o HAVING con alguno de estos operadores: . | ANY, ALL o SOME. | IN o NOT IN. | EXISTS o NOT EXISTS. | =, &gt;, &gt;=, &lt;, &lt;=. | . El significado de los operadores es bastante obvio. Como siempre, se comprende mejor con algunos ejemplos. Ejemplo 1: buscar a todas las personas que hayan nacido en algún país del continente americano: . SELECT nombre, apellido1, apellido2 FROM personas WHERE personas.id_pais IN (SELECT id_pais FROM paises WHERE id_continente = 2); . Observa bien el código de esta consulta: le estamos pidiendo a la base de datos que, en primer lugar, ejecute la consulta que hay entre paréntesis (es decir, la subconsulta). Esta consulta nos devolverá una lista de IDs de paises del contienente americano. Y luego, gracias a la clásula WHERE de la consulta principal, seleccionaremos solo a las personas que hayan nacido en alguno de esos países. (Esta consulta, por cierto, puede resolverse sin subconsultas de forma más eficiente. Puedes pensar en ello si lo deseas: es un interesante ejercicio). Ejemplo 2: buscar todos los países de los cuales hay al menos una persona en la base de datos: . También puede hacerse sin subconsultas, pero la solución con subconsulta es así de simple: . SELECT nombre FROM paises WHERE id = ANY (SELECT id_pais FROM personas); . Ejemplo 3: buscar a las personas más altas de la base de datos: . Es decir, buscar a las personas que compartan el valor máximo de estatura, sea este el que sea. Este es un ejemplo de consulta que difícilmente podrías resolver sin subconsultas, pero que con subconsultas queda en algo tan simple como: . SELECT nombre, apellido1, apellido2 FROM personas WHERE estatura = (SELECT MAX(estatura) FROM personas); . Las subconsultas se pueden considerar SQL avanzado, por lo que no es necesario que las domines en este momento, pero sí que conozcas su existencia por si más adelante en tu carrera como programador/a tienes que profundizar en ellas. 2.3.9. Otras cuestiones avanzadas: alias y combinaciones de consultas . Como dijimos al principio, SQL en general y la instrucción SELECT en particular son muy amplios y se pueden aplicar en muchísimos casos diferentes, desde consultas sencillísimas hasta casos complejos donde tu cerebro puede tener un amago de explosión mientras trata de buscar una solución. Te menciono aquí algunos aspectos avanzados de los SELECT para que los conozcas, haciéndote saber que, si no aprendes a controlarlos ahora, no es ninguna tragedia: más adelante, si te especializas en esto, sin duda aprenderás a dominarlos. Por ahora basta con que los conozcas y los comprendas. En algunos de los ejercicios del tema usaremos estos aspectos avanzados para buscar soluciones a supuestos prácticos particularmente enrevesados. ALIAS . Los alias son nombres alternativos que se asignan a las tablas o a las columnas en una consulta. El objetivo del alias puede ser doble: . | Usar un nombre más corto para facilitar la escritura de una expresión que, de otro modo, sería muy larga. | Poder referirse a la misma tabla en dos conextos diferentes. | . El primer uso es muy fácil de entender. El segundo, no tanto. De momento, vamos a ver el uso más fácil. No te preocupes demasiado por el otro: veremos algún ejemplo en los ejercicios de este capítulo. El alias se indica con la palabra AS. Por ejemplo, en la siguiente consulta, se usan alias para acortar los identificadores de los campos persona.nombre, paises.nombre y continentes.nombre, que pasan a ser nom_pers, nom_pais y nom_cont, respectivamente. Observa como podemos referirnos a cualquiera de esos campos por su nombre o su alias, como hacemos en la cláusula WHERE de este ejemplo. SELECT personas.nombre AS nom_pers, apellido1, apellido2, paises.nombre AS nom_pais, continentes.nombre AS nom_cont FROM personas JOIN paises ON personas.id_pais = paises.id JOIN continentes ON paises.id_continente = continentes.id WHERE nom_pers LIKE 'A%' ORDER BY apellido1, apellido2; . COMBINACIONES DE CONSULTAS . Es posible combinar los resultados de dos consultas para obtener un resultado más amplio. Si tenemos dos consultas, que llamaremos C1 y C2, sus resultados pueden combinarse de tres modos diferentes: . | Con UNION: los registros de C1 y de C2 se sumarán, es decir, el resultado de C1 UNION C2 serán todas las filas que estén en C1 más las que estén en C2. | Con INSERSECT: el resultado de C1 INSERSECT C2 serán todas las filas que están a la vez en C1 y en C2, es decir, la insersección de los dos conjuntos de resultados. | Con EXCEPT: el resultado de C1 EXCEPT C2 serán todas las filas que estén en C1, quitando las que estén en C2. | . Para poder hacer UNION, INSERSECT o EXCEPT de dos consultas, ambas tienen que haber producido exactamente el mismo conjunto de campos. Si no, estas operaciones no son posibles. Por ejemplo, observa el siguiente código. Fíjate en que las dos consultas producen el mismo conjunto de campos (nombre, apellido1, apellido2). Si no, no sería posible combinarlas. Observa también el uso de los paréntesis: . (SELECT nombre, apellido1, apellido2 FROM personas WHERE pais_nacimiento = '1') UNION (SELECT nombre, apellido1, apellido2 FROM personas) WHERE estatura &gt; '180'); . (por supuesto, esto mismo puede resolverse sin usar UNION) . | La combinación de estas dos consultas con UNION nos devuelve la lista de personas que han nacido en Argentina O que miden más de 180 cm. Cualquier persona que cumpla una de las dos condiciones estará en el resultado final. | Si combinásemos las mismas consultas con INSERSECT en lugar de con UNION, lo que obtendríamos sería la lista de personas que nacieron en Argentina Y que miden más de 180 cm. Es decir, las personas que formen parte de los dos resultados y, por lo tanto, cumplan a la vez las dos condiciones. Fíjate en que en el enunciado solo hemos cambiado una “O” por una “Y”, pero es que esa es precisamente la diferencia entre UNION e INTERSECT. | Por último, si combinamos las mismas consultas con EXCEPT, obtendremos la lista de personas que nacieron en Argentina, excepto las que miden más de 180 cm. Habremos eliminado del primer SELECT los resultados que estén en el segundo SELECT. Esto es, obtendremos la lista de personas nacidas en argentina que miden 180 cm o menos. | . Es un lío desde el punto de vista lógico, ¿verdad? Y es que no se te habrán escapado las semejanzas de UNION, INTERSECT y EXCEPT con los operadores lógicos Y, O y NO. En efecto, UNION, INSERSECT y EXCEPT son los equivalentes a Y, O y NO a nivel de consultas completas. Aplicaremos UNION, INSERSECT y EXCEPT a algunas de las consultas más complejas de nuestros ejercicios propuestos. ",
    "url": "https://iescelia.org//docs/tico/_site/lenguaje-sql/#23-buscando-informaci%C3%B3n-con-sql-la-instrucci%C3%B3n-select",
    "relUrl": "/lenguaje-sql/#23-buscando-información-con-sql-la-instrucción-select"
  },"79": {
    "doc": "2. El lenguaje SQL",
    "title": "2.4. ¿Y cómo puedo probar todo esto?",
    "content": "Seguro que te has hecho esta pregunta mientras leías los ejemplos de este capítulo y tal vez incluso intentabas resolverlos por tu cuenta. Es una excelente pregunta. Para ejecutar SQL necesitas un gestor de bases de datos relacionales. Puede instalar un gestor de escritorio, para bases de datos domésticas, como Microsoft Access o Libreoffice Base, o puedes decantarte por un gestor profesional en red, como MySQL, MariaDB, Oracle, SQLite o SQL Server. En realidad, da igual, porque el SQL es más o menos igual en todos. (Digo “más o menos” porque cada base de datos hace su propia interpretación del estándar SQL y puede haber pequeñas diferencias entre uno y otro). Si nunca has usado una base de datos profesional como MySQL, Oracle u SQL Server, probablemente lo más sencillo es que empieces por Microsoft Access o Libreoffice Base. Si, en cambio, ya conoces las bases de datos profesionales, no necesitas leer este apartado. Puedes pasar directamente a los ejercicios, aunque probablemente tampoco los necesites. Ten en cuenta que tanto Microsoft Access como Libreoffice Base usan versiones de SQL bastante alejadas del estándar (más aún en el caso de Base). Son la manera más sencilla de ejecutar SQL, pero probablemente no la mejor. Si aún así es lo único que tienes a mano, te cuento brevemente cómo ponerlas en marcha: . | Instala Microsoft Access (forma parte del paquete Microsoft Office) o Libreoffice Base (forma parte del paquete Libreoffice) en tu ordenador. Microsoft ofrece una versión online de su Office. Recuerda que Microsoft Office es un paquete de software propietario y que copiar y usar programas de forma fraudulenta es un delito penal. Libreoffice, en cambio, es software libre y puedes usarlo y distribuirlo libremente. Eso sí: ¡descárgalo solo de la web oficial, por favor! . | Arranca el programa (claro). | En Microsoft Access, crea una base de datos (o abre una existente). Ahora puedes ejecutar tus sentencias SQL pulsando el botón “Create” de la parte superior de la pantalla, y luego seleccionando “Query design” -&gt; “Show table” -&gt; “SQL view”. Escribe tu sentencia SQL y pulsa “Run” para probarla. | En Libreoffice Base, crea una base de datos (o abre una existente). Selecciona “Tool - SQL” y luego “Create Query in SQL view”. En la pantalla siguiente, haz clic en “View” -&gt; “Switch Design View On/Off”. Escribe tu sentencia SQL y pulsa “Run” para probarla. | . Existe otra posibilidad para ejecutar SQL sin complicarte la vida: las soluciones online. Hay páginas son sqliteonline.com o sqlfiddle.com que te permiten lanzar sentencias SQL contra bases de datos virtuales de forma gratuita y sin necesidad de registrarte en ningún sitio. En realidad, todo esto no tiene nada que ver con aprender SQL, sino con aprender a manejar un determinado programa. Elige el tuyo y bichea un poco hasta que averigües cómo se ejecuta el SQL. Se presupone de ti que eres un usuario/a de ordenadores de nivel medio-avanzado, y por eso quieres aprender a programar. No tiene mucho sentido explicar aquí cómo ejecutar SQL en cada gestor de bases de datos porque puede haber importantes diferencias entre un gestor de bases de datos y otro o, incluso, entre versiones del mismo programa. Y, en última instancia, es algo tan simple como trastear un rato con el programa. ",
    "url": "https://iescelia.org//docs/tico/_site/lenguaje-sql/#24-y-c%C3%B3mo-puedo-probar-todo-esto",
    "relUrl": "/lenguaje-sql/#24-y-cómo-puedo-probar-todo-esto"
  },"80": {
    "doc": "2. El lenguaje SQL",
    "title": "2.5. Ejercicios",
    "content": "Como de costumbre, vamos a proponer una batería de ejercicios de SQL para que practiques todo lo que hemos visto a lo largo de este capítulo. Muchos de ellos los encontrarás resueltos en la siguiente sección. Ya sabes lo que digo siempre: es una pésima idea mirar las soluciones antes de haber intentado resolverlos por tu cuenta. Ejercicio 1: compañía de seguros . Una compañía de seguros dispone de una base de datos con las siguientes tablas: . | Personas (dni#, nombre, apellidos, dirección, ciudad, país) | Coches (matrícula#, marca, modelo, potencia, conductor, seguro) | Seguros (núm-póliza#, compañía, tipo, franquicia, dni-tomador, fecha) | . Las claves ajenas, es decir, las claves de unas tablas que se han copiado en otras para implementar las relaciones, son estas: . | Coches.conductor → Personas.dni (es decir, el campo coches.conductor es una clave ajena de personas.dni) | Coches.seguro → Seguros.núm-póliza (el campo coches.seguro es una clave ajena de seguros.num-numpoliza) | Seguros.dni-tomador → Personas.dni (el campo seguros.dni-tomador es una clave ajena de personas.dni) | . Se pide escribir el código SQL necesario para: . a) Crear las tablas (CREATE TABLE), suponiendo las siguientes restricciones: . | Todas las claves primarias y ajenas son campos obligatorios (no pueden ser nulos). Además, las claves primarias no pueden tomar valores repetidos. | Personas.país tendrá, por defecto, el valor “España”. Personas.ciudad tendrá, por defecto, el valor “Almería”. | Hay que activar el borrado y actualización en cascada en todas las relaciones. | Es conveniente definir todas las claves como restricciones (constraints), con el objeto de poder modificarlas más adelante. | Todos los datos son cadenas de caracteres (la longitud puedes elegirla tú, siempre que sea razonable), excepto los siguientes: . | Coches.potencia es un número real con tres cifras enteras y dos cifras decimales. | Seguros.núm-póliza es un número entero largo. | Seguros.franquicia es un número real con seis cifras enteras y dos decimales. | Seguros.fecha es de tipo fecha (claro) | . | . b) Realizar los siguientes cambios en las tablas (ALTER TABLE, INSERT, UPDATE, DELETE): . | Agregar a la tabla Personas el campo sexo, con un sólo carácter y obligatorio. | Desactivar el borrado en cascada (no la actualización) de la clave ajena en la tabla Seguros. | Insertar estos registros: . | En Personas, DNI = 1111A, Juan Martín, C/ Barco, Roquetas de Mar, España | En Seguros, Nº Póliza = 1, Compañía = Mapfre, Franquicia = 299,95 €, Tomador = Juan Martín | . | Modificar todos los seguros de tipo “Todo riesgo” para que la franquicia sea de 120 € | Borrar todas las personas que no vivan ni en España ni en Portugal. | . c) Realizar las siguientes consultas (SELECT): . | Nombre y apellidos, ordenados alfabéticamente, de todas las personas cuyo nombre sea “Laura” | Nombre y apellidos, ordenados alfabéticamente, de todas las personas que viven en ciudades que empiezan por “A”. | Compañías de seguros que aseguran coches de la marca Seat y cuyas pólizas fueron contratadas después del año 2005. | Precio medio de las franquicias de los coches asegurados por la compañía Mapfre y cuya potencia es mayor de 100 caballos. | . EJERCICIO 1 RESUELTO: . a) Crear las tablas con las restricciones detalladas en el enunciado del ejercicio: . CREATE TABLE Personas ( dni VARCHAR(12) UNIQUE NOT NULL, nombre VARCHAR(50) NOT NULL, apellidos VARCHAR(50) NOT NULL, ciudad VARCHAR(50) DEFAULT \"Almería\", país VARCHAR(50) DEFAULT \"España\", CONSTRAINT pk_personas PRIMARY KEY (dni) ); CREATE TABLE Seguros ( num_póliza BIGINT UNIQUE NOT NULL, compañía VARCHAR(50) NOT NULL, tipo VARCHAR(20), franquicia DECIMAL(8,2) DEFAULT 0, dni_tomador VARCHAR(12) NOT NULL, fecha DATE, CONSTRAINT pk_seguros PRIMARY KEY (num_póliza), CONSTRAINT fk_seguros_personas FOREIGN KEY (dni_tomador) REFERENCES Personas(dni) ON DELETE CASCADE ON UPDATE CASCADE ); CREATE TABLE Coches ( matrícula VARCHAR(7) UNIQUE NOT NULL, marca VARCHAR(30) NOT NULL, modelo VARCHAR(30), potencia DECIMAL(5,2), conductor VARCHAR(12) NOT NULL, seguro BIGINT NOT NULL, CONSTRAINT pk_coches PRIMARY KEY (matricula), CONSTRAINT fk_coches_personas FOREIGN KEY (conductor) REFERENCES Personas(dni) ON DELETE CASCADE ON UPDATE CASCADE, CONSTRAINT fk_coches_seguros FOREIGN KEY (seguro) REFERENCES Seguros(num_póliza) ON DELETE CASCADE ON UPDATE CASCADE ); . b) Realizar los siguientes cambios en las tablas . Agregar a la tabla Personas el campo sexo, con un sólo carácter y obligatorio. ALTER TABLE Personas ADD Sexo VARCHAR(1) NOT NULL; . Desactivar el borrado en cascada (no la actualización) de la clave ajena en la tabla Seguros. (No puede eliminarse solamente el borrado en cascada, así que hay que quitar por completo la restricción “fk_seguros_personas”, y luego volver a crearla sin borrado en cascada. Observa que esto no afectará a los datos de la tabla.) . ALTER TABLE Seguros DROP CONSTRAINT fk_seguros_personas; ALTER TABLE Seguros ADD CONSTRAINT fk_seguros_personas FOREIGN KEY (dni_tomador) REFERENCES Personas(dni) ON UPDATE CASCADE; . Insertar estos registros: . | En Personas, DNI = 1111A, Juan Martín, C/ Barco, Roquetas de Mar, España | En Seguros, Nº Póliza = 1, Compañía = Mapfre, Franquicia = 299,95 €, Tomador = Juan Martín | . INSERT INTO Personas VALUES ('1111A', 'Juan', 'Martín', 'C/ Barco', 'Roquetas de Mar', 'España'); INSERT INTO Seguros (num_póliza, compañía, franquicia, dni_tomador) VALUES (1, 'Mapfre', 299.95, '1111A'); . Modificar todos los seguros de tipo “Todo riesgo” para que la franquicia sea de 120 € . UPDATE Pacientes SET pais = 'Desconocido' WHERE tipo = 'Todo riesgo'; . Borrar todas las personas que no vivan ni en España ni en Portugal. DELETE FROM Personas WHERE país &lt;&gt; 'España' AND país &lt;&gt; 'Portugal'; . c) Realizar las siguientes consultas (SELECT): . Nombre y apellidos, ordenados alfabéticamente, de todas las personas cuyo nombre sea “Laura” . SELECT nombre, apellidos FROM Personas WHERE nombre = 'Laura' ORDER BY apellidos, nombre; . Nombre y apellidos, ordenados alfabéticamente, de todas las personas que viven en ciudades que empiezan por “A” (consideraremos también la “A” con tilde): . SELECT nombre, apellidos FROM Personas WHERE ciudad LIKE 'A*' OR ciudad LIKE 'Á*' ORDER BY apellidos, nombre; . Compañías de seguros que aseguran coches de la marca Seat y cuyas pólizas fueron contratadas después del año 2005. SELECT DISTINCT compañía FROM Seguros INNER JOIN Coches ON Seguros.num_póliza = Coches.seguro WHERE marca = 'Seat' AND fecha &gt; '31/12/2005'; . Precio medio de las franquicias de los coches asegurados por la compañía Mapfre y cuya potencia es mayor de 100 caballos. SELECT AVG(franquicia) FROM Seguros INNER JOIN Coches ON Seguros.num_póliza = Coches.seguro WHERE compañía = 'Mapfre' AND potencia &gt; 100; . Ejercicio 2: academia de idiomas . (Advertencia: las consultas de este ejercicio son más complicadas. Solo las ponemos aquí a modo de ejemplo, pero no os vamos a pedir que sepáis hacerlas). La base de datos de una academia de idiomas está formada por las siguientes tablas: . | PROFESORES(#dni-prof, nombre, apellidos, idioma) | ALUMNOS(#dni-alum, nombre, apellidos) | GRUPOS(#cod-grupo, denominación) | HORARIOS(#cod-grupo, #día-semana, #dni-prof, hora-inicio, hora-fin, aula) | . Se pide escribir las sentencias SQL necesarias para: . 1) Consultar los nombres y apellidos de los profesores que dan clase de francés de lunes a jueves a partir de las 16:00 horas, junto con la denominación de los grupos a los que dan clase y el horario de cada día. 2) Consultar los nombres y apellidos de los alumnos que reciben clases de al menos dos idiomas diferentes. 3) Consultar los nombres y apellidos de los alumnos que reciben clases de INGLÉS y de FRANCÉS. 4) Consultar los nombres y apellidos de los alumnos que reciben clases de INGLÉS o de FRANCÉS. 5) Consultar los nombres y apellidos de los alumnos que reciben clases de INGLÉS pero no reciben clases de ALEMÁN. Solución del ejercicio 2: . 1) Consultar los nombres y apellidos de los profesores que dan clase de francés de lunes a jueves a partir de las 16:00 horas, junto con la denominación de los grupos a los que dan clase y el horario de cada día. SELECT nombre, apellidos, denominación, día_semana, hora_inicio, hora_fin FROM Profesores INNER JOIN Horarios ON Profesores.dni_prof = Horarios.dni_prof INNER JOIN Grupos ON Horarios.cod_grupo = Grupos.cod_grupo WHERE (día_semana = 'L' OR día_semana = 'M' OR día_semana = 'X' OR día_semana = 'J') AND hora_inicio &gt;= '16:00' AND idioma = 'Francés'; . 2) Consultar los nombres y apellidos de los alumnos que reciben clases de al menos dos idiomas diferentes. SELECT DISTINCT Alumnos.nombre, Alumnos.apellidos FROM Alumnos INNER JOIN Horarios ON Alumnos.cod_grupo = Horarios.cod_grupo INNER JOIN Profesores AS Profes1 ON Horarios.dni_prof = Profes1.dni_prof WHERE Alumnos.dni IN (SELECT Alumnos.dni FROM Alumnos INNER JOIN Horarios ON Alumnos.cod_grupo = Horarios.cod_grupo INNER JOIN Profesores AS Profes2 ON Horarios.dni_prof = Profes2.dni_prof WHERE Profes1.idioma &lt;&gt; Profes2.idioma); . 3) Consultar los nombres y apellidos de los alumnos que reciben clases de INGLÉS y de FRANCÉS. SELECT Alumnos.nombre, Alumnos.apellidos FROM Alumnos INNER JOIN Horarios ON Alumnos.cod_grupo = Horarios.cod_grupo INNER JOIN Profesores ON Horarios.dni_prof = Profesores.dni_prof WHERE Profesores.idioma = \"Inglés\" INTERSECT SELECT Alumnos.nombre, Alumnos.apellidos FROM Alumnos INNER JOIN Horarios ON Alumnos.cod_grupo = Horarios.cod_grupo INNER JOIN Profesores ON Horarios.dni_prof = Profesores.dni_prof WHERE Profesores.idioma = \"Francés\" . 4) Consultar los nombres y apellidos de los alumnos que reciben clases de INGLÉS o de FRANCÉS. SELECT Alumnos.nombre, Alumnos.apellidos FROM Alumnos INNER JOIN Horarios ON Alumnos.cod_grupo = Horarios.cod_grupo INNER JOIN Profesores ON Horarios.dni_prof = Profesores.dni_prof WHERE (Profesores.idioma = \"Inglés\" OR Profesores.idioma = \"Francés\"); . 5) Consultar los nombres y apellidos de los alumnos que reciben clases de INGLÉS pero no reciben clases de ALEMÁN. SELECT Alumnos.nombre, Alumnos.apellidos FROM Alumnos INNER JOIN Horarios ON Alumnos.cod_grupo = Horarios.cod_grupo INNER JOIN Profesores ON Horarios.dni_prof = Profesores.dni_prof WHERE Profesores.idioma = \"Inglés\" EXCEPT SELECT Alumnos.nombre, Alumnos.apellidos FROM Alumnos INNER JOIN Horarios ON Alumnos.cod_grupo = Horarios.cod_grupo INNER JOIN Profesores ON Horarios.dni_prof = Profesores.dni_prof WHERE Profesores.idioma = \"Alemán\"; . Ejercicio obligatorio: Series de TV . La base de datos para nuestras series de TV favoritas incluye estas tablas: . | SERIES (id#, titulo, canal, puntuacion) | TEMPORADAS (id#, anyo, num_capitulos, id_serie) | PERSONAS (id#, nombre, apellido) | DIRIGEN (id_persona#, id_serie#) | ACTUAN (id_persona#, id_serie#) | . | Crea las tablas con las instrucciones CREATE TABLE necesarias, asignando los tipos de datos que te parezcan más adecuados. | Inserta unos cuantos datos de ejemplo en cada una de las tablas con INSERT INTO. | Escribe las siguientes consultas: . | Obtener los títulos y canales de todas las series, ordenadas por puntuación (de mayor a menor) y, en caso de empate, por orden alfabético. | Obtener los títulos de todas las series donde actúe… (pon aquí el nombre de tu actor o actriz favorito). | Obtener todos los datos disponibles (reparto, directores, temporadas, etc.) de la serie… (pon aquí el título de tu serie preferida). | Obtener el número de personas que hay en el reparto de tu serie preferida. Es decir, si esa serie tiene 5 actores y actrices en el reparto, el resultado de esta consulta debe ser “5”, no la lista de nombres de esas personas. | . | . Para hacer este ejercicio, hemos creado una base de datos online a la que puedes acceder con un programa llamado PHPMyAdmin desde la dirección https://acceso.donhosting.es/pma/. Usa estas credenciales: . | Usuario: la primera letra de tu nombre + tu apellido | Contraseña: la primera letra de tu nombre + tu apellido + 2022! | . Por ejemplo, si te llamas “Ana López”, podrás entrar con el usuario “alopez” y la contraseña “alopez2022!”. Si tu nombre es compuesto, como en “Jose Luis Rubio”, tu cuenta será “jlrubio” y tu contraseña “jlrubio2022!”. Una vez conectado a MySQL, tendrás que seleccionar la base de datos que vas a usar (en el panel de la izquierda). Solo tienes una disponible, así que no tiene pérdida: . Ahora escribe tus instrucciones SQL desde la pestaña “SQL” (pulsa “Continuar” para ejecutar la instrucción): . Para comprobar si tus instrucciones SQL están funcionando: . | Asegúrate de que no dan ningún error al ejecutarlas. | Selecciona una tabla en la lista de tablas y mira en la pestaña “Estructura” a ver si se han creado las tablas como deberían. | Selecciona una tabla en la lista de tablas y mira en la pestaña “Examinar” a ver si contiene los datos que debería. | . No olvides ir copiando tu código SQL en algún editor de texto para poder luego subirme a Moodle el ejercicio completo. ",
    "url": "https://iescelia.org//docs/tico/_site/lenguaje-sql/#25-ejercicios",
    "relUrl": "/lenguaje-sql/#25-ejercicios"
  },"81": {
    "doc": "6. Los lenguajes de programación",
    "title": "6. Los lenguajes de programación",
    "content": ". | 6.1. Tipos de lenguaje según el nivel de abstracción: alto y bajo nivel | 6.2. Tipos de lenguaje según su generación | 6.3. Tipos de lenguaje según su forma de traducción | 6.4. Tipos de lenguaje según su tipado | 6.5. El top ten de los lenguajes de programación | . Los lenguajes de programación constituyen un ecosistema muy extenso y en constante evolución. Para orientarse un poco en esa jungla, nada mejor que clasificar los lenguajes igual que los biólogos clasifican a las criaturas vivas. ",
    "url": "https://iescelia.org//docs/tico/_site/lenguajes-de-programacion/",
    "relUrl": "/lenguajes-de-programacion/"
  },"82": {
    "doc": "6. Los lenguajes de programación",
    "title": "6.1. Tipos de lenguaje según el nivel de abstracción: alto y bajo nivel",
    "content": "Hay lenguajes de programación muy próximos al lenguaje binario: a éstos los llamamos lenguajes de bajo nivel de abstracción. Y los hay más próximos al lenguaje natural: son los lenguajes de alto nivel de abstracción. Lenguajes de bajo nivel . Son los lenguajes más cercanos a la máquina. Los programas directamente escritos en código binario se dice que están en lenguaje máquina que, por lo tanto, es el lenguaje de más bajo nivel que existe. Las instrucciones del lenguaje máquina realizan tareas muy sencillas, como, por ejemplo, sumar dos números, detectar qué tecla se ha pulsado en el teclado o escribir algo en la pantalla del ordenador. Cuando se combinan adecuadamente muchas de estas instrucciones sencillas se obtiene un programa de ordenador que puede realizar tareas muy complejas. Por ejemplo, este puede ser el aspecto de una instrucción en lenguaje máquina para sumar dos números: . 0001 000100000101 110100110101 . Incomprensible, ¿verdad? . A pesar de la simplicidad de las instrucciones del lenguaje máquina, la forma de escribirlas es muy complicada, ya que hay que hacerlo en binario. En los primeros años de la informática los ordenadores se programaban directamente en lenguaje máquina, lo cual convertía la tarea de programar en una verdadera pesadilla. Hoy en día nadie lo hace. Cuando los ordenadores fueron haciéndose más potentes, surgió la idea de utilizar el propio ordenador como traductor: ¿por qué no escribir instrucciones en un lenguaje más parecido al natural y que un programa de ordenador se encargue de traducir esa instrucción a su correspondiente instrucción en lenguaje máquina? . Así apareció el lenguaje ensamblador, cuyas instrucciones son equivalentes a las del lenguaje máquina, pero se escriben con palabras similares a las del lenguaje humano. Por ejemplo, para sumar dos números, la instrucción en ensamblador puede tener un aspecto como este: . ADD D1 D2 . Lenguajes de alto nivel . Siguiendo el razonamiento anterior (utilizar el propio ordenador como traductor), en la década de 1960 y, sobre todo, de 1970, se empezaron a desarrollar lenguajes cada vez más complejos, en los que cada instrucción ya no se correspondía exactamente con una instrucción del lenguaje máquina, sino con varias. Estos son los lenguajes de alto nivel. Lógicamente, la traducción desde un lenguaje de alto nivel a lenguaje máquina es mucho más compleja que desde lenguaje ensamblador, por lo que los traductores se han hecho cada vez más complicados. Una característica muy importante de los lenguajes de alto nivel es que son independientes del hardware, lo que implica que los programas desarrollados con estos lenguajes pueden ser ejecutados en ordenadores con hardware totalmente distinto. A esto se le llama portabilidad. Los programas encargados de traducir el código de alto nivel a código máquina se llaman compiladores e intérpretes. Son programas muy complejos que generan el código binario equivalente al código de alto nivel para una máquina concreta. Por lo tanto, el programa de alto nivel, que es portable de un hardware a otro, debe ser traducido a código máquina en cada tipo de máquina en la que se pretenda ejecutar. Los ejemplos de lenguajes de alto nivel son innumerables, y la lista incluye casi todos de los que has oído hablar alguna vez: Basic, Cobol, Fortran, Ada, C/C++, PHP, Python, Java, Perl, Ruby, Javascript, etc. Ventajas e inconvenientes de los lenguajes de alto y bajo nivel . | LENGUAJES DE BAJO NIVEL | LENGUAJES DE ALTO NIVEL | . | Ventajas | Inconvenientes | . | Son comprensibles directamente por la máquina (aunque el ensamblador necesita una pequeña traducción) | Necesitan ser traducidos por medio de complicados programas (compiladores e intérpretes) | . | Los programas se ejecutan muy rápidamente (si están bien escritos, claro) | La traducción automática del código de alto nivel al código máquina siempre genera programas menos eficientes que si se escribieran directamente en binario | . | Ocupan menos espacio en memoria | Ocupan más espacio en memoria | . | Permiten controlar directamente el hardware, por lo que son apropiados para la programación de sistemas | En general, solo pueden acceder al hardware utilizando al sistema operativo como intermediario. Pero, entonces, ¿cómo programar el sistema operativo, que necesita controlar directamente el hardware? | . | Inconvenientes | Ventajas | . | Son completamente dependientes del hardware. Un programa escrito para determinado tipo de máquina no funcionará en un ordenador con diferente arquitectura. | Son portables, es decir, independientes del hardware. Un programa escrito en una máquina puede funcionar en otra con hardware distinto, siempre que se vuelva a traducir a binario en la máquina nueva. | . | Incluso los programas más sencillos son largos y farragosos | Los programas son más sencillos, ya que una sola instrucción puede equivaler a varias instrucciones binarias. | . | Los programas son difíciles de escribir, depurar y mantener | Los programas son más fáciles de escribir, depurar y mantener | . | Es imposible resolver problemas muy complejos | Es posible, aunque difícil, enfrentarse a problemas muy complejos | . Si echas un vistazo a la tabla anterior comprenderás que, en general, es preferible usar lenguajes de alto nivel la gran mayoría de las veces, reservando los de bajo nivel para casos muy concretos, como el desarrollo de ciertas partes de los sistemas operativos. También hay que destacar que no todos los lenguajes de alto nivel son iguales. Los hay de más alto nivel que otros. El lenguaje C, por ejemplo, tiene menor nivel de abstracción que, por ejemplo, Java. Esto hace que los programas escritos en C sean más rápidos y eficientes que los escritos en Java, aunque también pueden llegar a ser más difíciles de escribir y depurar. ",
    "url": "https://iescelia.org//docs/tico/_site/lenguajes-de-programacion/#61-tipos-de-lenguaje-seg%C3%BAn-el-nivel-de-abstracci%C3%B3n-alto-y-bajo-nivel",
    "relUrl": "/lenguajes-de-programacion/#61-tipos-de-lenguaje-según-el-nivel-de-abstracción-alto-y-bajo-nivel"
  },"83": {
    "doc": "6. Los lenguajes de programación",
    "title": "6.2. Tipos de lenguaje según su generación",
    "content": "Los lenguajes de programación también se clasifican según la generación a la que pertenecen. El lenguaje máquina fue el lenguaje de primera generación. Los ensambladores fueron los lenguajes de segunda generación. A partir de ahí, surgió una explosión de lenguajes diferentes que podemos clasificar como: . | Lenguajes de tercera generación (o imperativos), en los que el programador escribe una secuencia de instrucciones que el ordenador debe ejecutar en un orden preestablecido. Son los lenguajes más “clásicos”: C, Basic, Cobol, Fortran, Pascal, etc. | Lenguajes de cuarta generación (o 4GL), dirigidos a facilitar la creación de interfaces con el usuario y con otras aplicaciones, como las bases de datos. Un ejemplo de estos lenguajes es SQL, universalmente utilizado para manipular bases de datos y omnipresente en muchas aplicaciones web actuales. | Lenguajes orientados a objetos, que son una evolucuión de los lenguajes de tercera generación y que permiten construir con mayor facilidad y robustez programas modulares complejos. Ejemplos de lenguajes orientados a objetos son C++, C#, Java, Javascript, Python, PHP o Ruby. Algunos de ellos son multiparadigma, es decir, permiten programar con orientación a objetos pero también permiten hacer programación estructurada clásica, sin objetos. | Lenguajes declarativos y lenguajes funcionales, propios de la inteligencia artificial, como Prolog o Lisp. | Otros tipos aún más específicos: lenguajes concurrentes, paralelos, distribuidos, etc. | . En general, podemos decir que un programador acostumbrado a trabajar con un lenguaje de tercera generación puede aprender con poco esfuerzo cualquier otro lenguaje de tercera generación y, con algo más de trabajo, un lenguaje orientado a objetos. Sin embargo, el “salto” a otros tipos de lenguajes, como los declarativos, cuesta más porque las fundamentos de estos lenguajes son muy diferentes. ",
    "url": "https://iescelia.org//docs/tico/_site/lenguajes-de-programacion/#62-tipos-de-lenguaje-seg%C3%BAn-su-generaci%C3%B3n",
    "relUrl": "/lenguajes-de-programacion/#62-tipos-de-lenguaje-según-su-generación"
  },"84": {
    "doc": "6. Los lenguajes de programación",
    "title": "6.3. Tipos de lenguaje según su forma de traducción",
    "content": "Cuando programamos en un lenguaje distinto del lenguaje máquina, nuestro código debe ser traducido a binario para que el ordenador pueda entenderlo y ejecutarlo. Existe un programa específico encargado de hacer esa traducción y que, dependiendo del lenguaje en el que hayamos escrito nuestro programa, puede ser un ensamblador, un compilador o un intérprete. Ensambladores . Se llaman ensambladores los programas encargados de traducir los programas escritos en ensamblador a código binario. Sí, ya lo sé: se usa el mismo nombre para referirse al lenguaje de programación y al traductor de ese lenguaje a código máquina. Es un lío. Como el lenguaje ensamblador es muy próximo al binario, estos traductores son programas relativamente sencillos. Compiladores . El compilador es un programa que traduce el código de alto nivel a código binario. Es, por tanto, parecido al ensamblador, pero mucho más complejo, ya que las diferencias entre los lenguajes de alto nivel y el código binario son muy grandes. El programa escrito en lenguaje de alto nivel se denomina programa fuente o código fuente. El programa traducido a código binario se llama programa objeto o código objeto. Por lo tanto, el compilador se encarga de convertir el programa fuente en un programa objeto. Una vez que se ha obtenido el código objeto ya no es necesario volver a realizar la traducción (o compilación), a menos que se haga alguna modificación en el programa fuente, en cuyo caso habría que volver a compilarlo. El código objeto, una vez generado, puede ejecutarse en la máquina en la que fue compilado, o en otra de similares características (procesador, sistema operativo, etc.). Cuando se usa programación modular, puede ser necesario un proceso previo de enlace de los diferentes módulos antes de poder construir el programa ejecutable. Intérpretes . El intérprete es un programa que traduce el código de alto nivel a código binario pero, a diferencia del compilador, lo hace en tiempo de ejecución. Es decir, no existe un proceso previo de traducción de todo el código fuente a código binario, sino que se va traduciendo y ejecutando instrucción por instrucción. Compiladores frente a intérpretes . El intérprete es notablemente más lento que el compilador, ya que realiza la traducción al mismo tiempo que la ejecución. Además, esa traducción se lleva a cabo siempre que se ejecuta el programa, mientras que el compilador sólo la hace una vez. Hay un evidente malgasto de recursos. Sin embargo, los intérpretes tienen una gran ventaja sobre los compiladores, y es que logran que los programas sean más portables, es decir, que puedan ejecutarse en diferentes máquinas con diferentes sistemas operativos sin apenas cambios. Así, un programa compilado en una máquina PC bajo Windows no funcionará en un Mac o en un PC bajo Linux, a menos que se vuelva a compilar el programa fuente en el nuevo sistema. En cambio, un programa interpretado funcionará en todas las plataformas, siempre que dispongamos del intérprete en cada una de ellas. C/C++ es un ejemplo de lenguaje compilado. Python es un ejemplo de lenguaje interpretado. Eso significa que un programa escrito, por ejemplo, con Python, puede funcionar en cualquier máquina que disponga de un intérperte Python, que, hoy en día, es casi cualquiera. Por eso, cualquier programa escrito en Python puede ejecutarse prácticamente en cualquier ordenador del mundo sin tocarle ni una coma. En cambio, los programas desarrollados con C/C++ se ejecuten más rápido (¡pero mucho más rápido!) que sus equivalentes en Python. Sin embargo, tendrás que volver a compilarlos si deseas ejecutarlos en una máquina con diferente hardware o diferente sistema operativo. ",
    "url": "https://iescelia.org//docs/tico/_site/lenguajes-de-programacion/#63-tipos-de-lenguaje-seg%C3%BAn-su-forma-de-traducci%C3%B3n",
    "relUrl": "/lenguajes-de-programacion/#63-tipos-de-lenguaje-según-su-forma-de-traducción"
  },"85": {
    "doc": "6. Los lenguajes de programación",
    "title": "6.4. Tipos de lenguaje según su tipado",
    "content": "Por tipado nos referimos a la forma en la que los lenguajes de programación usan los tipos de datos. Ya sabes: entero, carácter, lógico, etc. Es decir, las categorías a las que puede pertenecer una variable. Pues bien, según su tipado, los lenguajes pueden ser: . | De tipado fuerte: los tipos de datos no pueden mezclarse. Por ejemplo, no puedes sumar un entero y un real, porque son números de distinto tipo. Y mucho menos sumar un entero con un carácter. | De tipado débil: los tipos de datos pueden mezclarse y el lenguaje hace las conversiones de tipos implícitas que le parezca oportunas. Así, en estos lenguajes podrías sumar un entero con un real, o incluso un entero con un carácter. ¿Que cuál sería el resultado? Buena pregunta. Tendrás que probarlo, porque eso depende de las conversiones de tipo que haga el lenguaje. | De tipado estático: los tipos de datos se asignan al escribir el código y no pueden cambiarse durante la ejecución. Esto es típico de los compiladores (aunque no de todos). | De tipado dinámico: los tipos de datos pueden cambiarse alegremente durante la ejecución. Esto es típico de los intérpretes. | . Las dos primeras categorías y las dos segundas no son excluyentes. Por ejemplo, pueden existir lenguajes de tipado débil y dinámico, o bien fuerte y estático. Las otras combinaciones (fuerte y dinámico, débil y estático) pueden darse pero son menos habituales. ",
    "url": "https://iescelia.org//docs/tico/_site/lenguajes-de-programacion/#64-tipos-de-lenguaje-seg%C3%BAn-su-tipado",
    "relUrl": "/lenguajes-de-programacion/#64-tipos-de-lenguaje-según-su-tipado"
  },"86": {
    "doc": "6. Los lenguajes de programación",
    "title": "6.5. El top ten de los lenguajes de programación",
    "content": "Es difícil saber cuales son los lenguajes más populares en un determinado momento porque no existen estadísticas fiables a nivel mundial. Además, las cosas pueden cambiar mucho de un territorio a otro. Sin embargo, ciertos sitios de internet, como GitHub, almacenan enormes cantidades de proyectos de software. GitHub, de hecho, es el mayor almacén de código fuente conocido, de modo que sus estadísticas nos pueden dar una idea bastante exacta de cuál es el grado de uso de cada lenguaje. Según Madnight, un proyecto que recopila y publica estadísticas de uso de lenguajes en GitHub, el top ten de lenguajes de programación más usados en GitHub es: . | Puesto | Lenguaje | Porcentaje de uso | Variación de uso en 12 meses | . | 1 | JavaScript | 17.955% | -2.192% | . | 2 | Python | 15.943% | +0.071% | . | 3 | Java | 12.977% | +1.573% | . | 4 | Go | 8.203% | -0.612% | . | 5 | TypeScript | 7.212% | -0.276% | . | 6 | C++ | 6.683% | -0.251% | . | 7 | Ruby | 6.488% | +0.303% | . | 8 | PHP | 4.937% | -0.093% | . | 9 | C# | 3.366% | -0.350% | . | 10 | C | 2.958% | +0.068% | . El porcentaje de uso indica la proporción de proyectos en GitHub que usan ese lenguaje de programación sobre el total de proyectos. La última cifra señala la variación interanual del porcentaje de uso. Estos datos son de tercer cuatrimestre de 2021. Para obtener datos de otras fechas, puedes visitar la web https://madnight.github.io/ . Ten en cuenta de nuevo que esto no son cifras de uso absoluto de los lenguajes a nivel mundial. Solo se trata de una pista de cuál es la situación. De hecho, si consultas otras estadísticas como el TIOBE index, encontrarás datos diferentes. Según estas cifras, el conjunto de proyectos que usan lenguaje C o cualquiera de sus variantes (C++ o C#) es muy significativo, sobre todo teniendo en cuenta que C es un lenguaje de la década de 1970, lo cual constituye una eternidad en informática. Que un lenguaje mantenga su vigencia durante tanto tiempo indica lo robusto y confiable que es. Seguramente seguirá con nosotros dentro de muchos años, cuando otros competidores de esta lista ya hayan caído en el olvido. ",
    "url": "https://iescelia.org//docs/tico/_site/lenguajes-de-programacion/#65-el-top-ten-de-los-lenguajes-de-programaci%C3%B3n",
    "relUrl": "/lenguajes-de-programacion/#65-el-top-ten-de-los-lenguajes-de-programación"
  },"87": {
    "doc": "4. Modelado e impresión 3D",
    "title": "4. Modelado e impresión 3D",
    "content": ". | 4.1. Software para diseño 3D: TinkerCAD . | 4.1.1. Qué es TinkerCAD y cómo funciona | 4.1.2. Moviéndose por TinkerCAD | 4.1.3. El panel de control | 4.1.4. Cómo modelar objetos 3D con TinkerCAD | 4.1.5. Edición de objetos externos a TinkerCAD | 4.1.6. El generador de formas | 4.1.7. Algunos aspectos avanzados de TinkerCAD | 4.1.8. Exportando nuestros modelos para impresión 3D | . | 4.2. Formatos de archivo para impresión 3D | 4.2. Software para slicing (corte o laminado) | 4.4. Pruebas de impresión . | 4.4.1. Diez pasos para calibrar una impresora 3D | 4.4.2. Modelos de prueba | . | 4.5. Imprimir el modelo . | 4.5.1. Consejos antes de imprimir | 4.5.2. Consejos durante la impresión | 4.5.3. Consejos para después de imprimir | 4.5.4. Algunos tips para usar la impresora de CR10-mini con éxito | . | 4.6. Ejercicios | . En este capítulo vamos a aprender a usar una herramienta de modelado 3D llamada TinkerCAD. Se trata de una aplicación online muy sencilla (para tratarse de modelado 3D) e intuitiva que puede usarse desde cualquier navegador web, independientemente de tu sistema operativo. Y, encima, es gratuita. También veremos cómo los modelos 3D creados con TinkerCAD pueden laminarse en capas (slicing) para su tratamiento con una impresora 3D y qué tenemos que hacer para obtener ese modelo finalmente impreso. ",
    "url": "https://iescelia.org//docs/tico/_site/modelado-e-impresion-3d/",
    "relUrl": "/modelado-e-impresion-3d/"
  },"88": {
    "doc": "4. Modelado e impresión 3D",
    "title": "4.1. Software para diseño 3D: TinkerCAD",
    "content": "(Este apartado está adaptado del artículo “Mega Tutorial TinkerCAD, cómo utilizarlo Paso a Paso”, publicado por Jorge Lorenzo en https://of3lia.com/tinkercad-tutorial-completo/) . Aunque existen programas de modelado 3D tan alucinantes como Blender, Maya o 3DSmax (el primero de ellos, encima, gratuito), para aprender los fundamentos de estas técnicas sin complicarse mucho la vida, sin duda lo más apropiado es TinkerCAD. TinkerCAD es versátil, no hace falta instalarlo, es muy potente, es muy estable y, además, es online. Es verdad que resulta algo más limitado que sus hermanos mayores, ya que no tiene tantas opciones como otros programa de modelado 3D, pero, para la gran mayoría de nosotros, lo que ofrece TinkerCAD es más que suficiente. 4.1.1. Qué es TinkerCAD y cómo funciona . TinkerCAD es un programa de modelado 3D que crea las piezas con el método lowpoly, que consiste en la unión de polígonos en un número relativamente bajo (comparado con otros programas) para crear los modelos. TinkerCAD trae un montón de figuras geométricas predefinidas para que las puedas usar en tus diseños. Para crear un perro, por ejemplo, tendrías que pensar qué conjunto de figuras es más adecuado unir: cilindros para las patas, una esfera para la cabeza, dos conos para las orejas… Cada una de estas figuras está constituida por un montón de polígonos que TinkerCAD maneja por nosotros. Un perro salchicha modelado con TinkerCAD de forma muy cutre y empleando solo formas geométricas simples Además, como TinkerCAD es online, no hay que descargarlo, instalarlo ni configurarlo: basta con crearse una cuenta en su web www.tinkercad.com. Existen cuentas de tres tipos: . | Educadores: pensada para profesores/as que quieren usar TinkerCAD en sus clases. | Estudiantes: para alumnos/as de los profesores anteriores. Los profesores pueden crear clases y los estudiantes pueden unirse a esas clases. Los miembros de una clase pueden interactuar entre ellos, ver sus diferentes trabajos o colaborar en grupos. | Cuentas personales: para el público en general. | . Homepage de TinkerCAD &nbsp; . Al registrarte, puedes indicar qué tipo de usuario eres 4.1.2. Moviéndose por TinkerCAD . Los controles de TinkerCAD son muy sencillos. Eso sí, necesitarás un ratón con ruleta central. Estos son los principales: . | Click izquierdo: Selección. | Click derecho: Rotación. | Ruleta del ratón: Zoom. | Click en ruleta ratón: Traslación. | . Cuando seleccionas un objeto, aparecen unos controles muy intuitivos a su alrededor para moverlo, rotarlo y escalarlo. Además, también puedes mover el cubo que hay en la parte superior izquierda para mover todo el objeto y si das doble click en sus caras posicionas tu vista de forma perpendicular a ese plano. 4.1.3. El panel de control . En esta imagen puedes ver el aspecto del panel de control de TinkerCAD con sus áreas principales numeradas: . Las áreas del panel de control son estas: . | Espacio de trabajo. El cuadrado grande es la superficie de trabajo y el pequeño son las opciones de dicha superficie: tamaño total, tamaño de la rejilla y unidades de medición. | Modos de visualización. El primero es el cubo de visualización, que nos permite rotar el objeto. Después tenemos la vista inicial, para volver a la visualización estándar, los controles de zoom (para acercarnos o alejarnos del objeto) y el cambio de vista (para activar o desactivar la perspectiva isométrica). | Zona de edición de objetos. Aquí podremos ocultar objetos si nos molestan, hacer simetrías, agrupar, desagrupar y alinear. Es una de las herramientas que más usaremos. | Zona de usuario: importar y exportar archivos y acceder funcionalidades adicionales. | Banco de piezas. Aquí está toda la (enorme) biblioteca de pieza prediseñadas de TinkerCAD. Esta es una de las principales características que diferencian a TinkerCAD de otros programas de modelado 3D: la enorme cantidad de figuras predefinidas que existen. Otros programas tienen solo cubos, conos, cilindros y poco más. Encima de la biblioteca encontrarás las herramientas del plano de trabajo y la regla. Más adelante veremos para qué sirven. | Herramientas de edición del documento: copiar, pegar, duplicar, eliminar, rehacer, deshacer… Si hacemos click justo al lado del nombre del documento, podremos cambiar su visibilidad y su tipo de licencia. | . 4.1.4. Cómo modelar objetos 3D con TinkerCAD . Modelar objetos 3D con TinkerCAD es muy fácil, al menos en comparación con otros programas de diseño 3D. Vamos a hacer recorrido por el proceso mediante unos ejemplos, revisando con ellos las cuatro cosas fundamentales que se usan en todos los modelados. Una vez que hayas asimilado esas cuatro cosas, podrás aplicarlas por tu cuenta para diseñar cualquier otro objeto, simplemente dejando volar tu imaginación. Hacer uniones y vaciados entre formas . Una de las cosas más habituales que se han en los programas de diseño 3D es unir dos objetos entre sí. Para entender cómo funciona, sigue estos pasos: . | Arrastra un cubo al espacio de trabajo. | Arrastra un cilindro al espacio de trabajo. | Agranda el cilindro. | Mete el cubo en el cilindro y vuelve a pulsar el cubo. | Ahora te toca decidir: déjalo como está o selecciona la opción “hueco”. Cuando te decidas, pulsa “Agrupar”. | . Si has escogido la primera opción, se habrá formado un sólido a partir de la unión de las dos piezas. La pieza resultante es ahora una sola, y cuando la escales o la muevas se moverá como tal. Si has escogido la segunda opción 2, se habrá formado un sólido a partir de la diferencia de una pieza con la otra. Es decir, has escogido que el cubo sea un hueco. Y si juntas un sólido con un hueco, ¿qué tienes? Muy fácil: un sólido con un agujero. Acabas de practicar tu primer vaciado de piezas. La unión y el vaciado son dos de las operaciones más comunes durante el modelado. Si controlas bien estas dos operaciones, puedes hacer casi cualquier cosa. Cambiar el plano de trabajo . Sigamos trabajando con nuestro sólido con agujero, al que vamos a llamar “cabaña”. Ahora queremos ponerle un bonito tejado cónico. Para ello, podemos crear un cono, agrandarlo y subirlo hasta la parte superior de nuestro objeto, ¿verdad? . Pero hay una solución más fácil. Seleccionar la herramienta Plano de trabajo y sitúa el nuevo plano sobre el tejado de nuestra pieza. Verás que también puedes ponerlo en las paredes, en la puerta o donde te dé la gana. Ahora crea un cono sobre el plano y listo. Como ves, el nuevo plano de trabajo tiene otro color para distinguirlo del original. Esta es herramienta es muy útil para no tener que mover objetos continuamente hasta colocarlos en su lugar. Además, no necesitas tener una cara plana para crear un nuevo plano de trabajo: incluso puedes hacerlo tangente a una esfera. Para volver al plano de trabajo original, pulsa sobre la herramienta y selecciónalo otra vez. Así de sencillo. Transformar, alinear y medir . El siguiente ejemplo lo vamos a hacer con cuatro esferas coloreadas como las fichas del parchís: . Lo primero que haremos será transformarlas. Para ello, selecciona una de ellas (la azul, por ejemplo), y verás que salen varios iconos: . | Los puntos blancos transforman la pieza en dos dimensiones a la vez (X e Y) o solo el eje Z. | Los puntos negros transforman la pieza en una sola dimensión (X o Y). | La flecha negra superior mueve el objeto hacia arriba y hacia abajo. | Las flechas curvas rotan la pieza en cualquiera de los 3 ejes (X, Y o Z). | . Si, además, pulsas la tecla Mayúsculas y mueves uno de los puntos blancos, la figura se escala uniformemente. Otra cuestión fundamental es alinear objetos. Cuando tienes varios objetos, a menudo necesitarás dejarlos perfectamente alineados. Hacerlo a mano es tedioso e inexacto. TinkerCAD lo hace por ti. Simplemente, selecciona la esfera roja y la esfera verde y pulsa “Alinear”. Vamos a alinearlas en la línea media del eje longitudinal. Y ahora intena alinear todas las esferas entre sí, en disposición de rectángulo. Finalmente, vamos a ver para que sirve la regla. Al posicionar la regla te darás cuenta de dos cosas: . | Puedes cambiar todas las medidas de la pelota (ya que las ves). | Puedes cambiar la posición relativa de los objetos con respecto a la regla. | . Esto te ayudará a saber la posición relativa entre los objetos, por si necesitas medidas exactas. Vamos a probarlo poniendo las esferas en forma de cuadrado de 40 mm de lado. Si interiorizas todo esto bien (a base de practicar un buen rato), ya puedes considerarte un usuario/a avanzado/a en TinkerCAD. Pero aún vamos a aprender un par de cosas más… . 4.1.5. Edición de objetos externos a TinkerCAD . TinkerCAD también puede manipular modelos 3D hechos por otras personas, aunque hayan usado otros programas. Por ejemplo, vamos a diseñar una taza con la cabeza de Ironman capaz de contener en su interior una lata de refresco convencional. Ve a la web de Thingiverse, un portal donde los usuarios suben sus diseños 3D para que otros usuarios puedan descargarlos libremente, y descárgarte el busto de Ironman (simplemente, busca “Ironman Bust”): . (Si tienes problemas para descargarlo, inténtalo desde aquí) . Ahora sigue estos pasos: . | Escala el busto para que mida 140 mm de ancho. | Crea 3 cubos huecos para quitarle toda la parte del cuerpo (hombros incluidos). El cubo central hasta la barbilla mide 63mm de alto. Ahora se los restamos. | Inserta un cilindro de 67mm de diámetro y 115mm de alto. Esto es debido a que las latas convencionales de refresco miden 66mm de diámetro, y tenemos que dejar al menos 1mm de holgura. | Inserta un toroide (o “donut”) como mango. | Haz la unión de todos los elementos. | . Más o menos así debería quedarte el resultado: ¡una taza de Ironman para latas diseñada en cinco minutos! . 4.1.6. El generador de formas . Si has usado las formas básicas un tiempo, te habrás dado cuenta de que cada objeto tiene sus propiedades: longitud, altura, anchura. Pero ¿y si hubiera objetos con otras propiedades diferentes? ¿Y si los pudiéramos crear nosotros y asignarles las propiedades que queramos? . Para eso sirve el generador de formas. Lo encontrarás en el mismo lugar que las formas básicas, pero en otra pestaña diferente. Ten en cuenta que todos estos objetos tienen diferentes propiedades modificables: lapared de ladrillos, por ejemplo, además del grosor, el ancho o el alto, te permite manipular el número de filas de ladrillos o el grosor de los ladrillos, propiedades que no tendrían sentido en otros objetos. Entre los objetos que puedes encontrar en el generador de formas encontrarás cosas tan locas como: . | Mapas de muchos lugares del mundo, incluyendo Europa y países europeos. | Una casa completa con jardín. | Importar archivos .svg (imágenes vectoriales) | Generador de código QR. | Diagramas circulares y de barras. | Figuras del Carcassonne (un popular juego de mesa). | Engranajes diversos. | Un generador de funciones 3D y otro de superficies. | Un taladro (la boquilla) | Un mandala. | Una caja ventilada para meter placas electrónicas. | Un reflector parabólico paramétrico. | Perfiles aerodinámicos de avión. | Una matriz circular de perfil personalizable. | Una matriz 3D con cubos y nomenclatura matriz. | La curva de Moebius. | Un árbol con fractales. | El mosaico de Penrose. | Simuladores de terreno (rocoso y de hierba). | . ¡Y así hasta 17 páginas completas! . 4.1.7. Algunos aspectos avanzados de TinkerCAD . Aunque es un software mucho más sencillo que otros como Blender o Maya, TinkerCAD también esconde sus características avanzadas. Aquí te resumo algunas que pueden resultarte útiles. Atajos de teclado . Si te aprendes los siguientes atajos de teclado, te convertirás en un diseñador (o diseñadora) mucho más rápido y eficaz: . | Ctrl + C, Ctrl + V: copiar y pegar. | Ctrl + Z, Ctrl + Y: deshacer y rehacer. | Ctrl + D: duplicar el objeto seleccionado. | Ctrl + H: ocultar el objeto seleccionado. | Ctrl + Shift + H: mostrar todos los objetos ocultos. | Ctrl + G: agrupar los objetos seleccionados. | Ctrl + Shift + G: desagrupar el objeto seleccionado. | L: abrir la herramienta para alinear. | M: abrir la herramienta “espejo”. | . Diferencia entre “copy-paste” y “duplicar” . Si te has fijado, hay dos formas de crear copias de un objeto: por un lado, el clásico “copiar y pegar” y, por otro, “duplicar”. La principal diferencia entre estos dos procedimientos es cómo manejan las transformaciones: . | Si haces “copiar y pegar”, las transformaciones que hayas aplicado al objeto copiado no se aplican al nuevo objeto. Por ejemplo, si el objeto copiado está rotado 20 grados a la derecha, la copia no lo estará. | Si haces “duplicar”, todas las transformaciones del objeto original se aplicarán también al objeto duplicado. | . Cambiar la rejilla . El plano de trabajo tiene una rejilla cuadriculada que nos ayuda a conseguir la sensación de perspectiva. Esa rejilla puede cambiarse haciendo clic en la esquina inferior derecha del área de trabajo, donde está el botón “Edit Grid”. En la ventana que aparece entonces puedes elegir la configuración de la rejilla que más te convenga. Por ejemplo, puedes cambiar el tamaño del plano de trabajo. Puede ser muy útil para hacerlo coincidir con el tamaño de la cama de tu impresora 3D. Bloques de código . Tinkercad Codeblocks permite generar objetos mediante programación visual (no confundir con “Code Blocks”, una herramienta open source de programación visual semejante a Scratch). Para iniciar Codeblocks en TinkerCAD, solo tienes que ir a la página principal de la web, iniciar tu sesión y hacer click en la opción “Bloques de código” -&gt; “Crear nuevo bloque de código”. La edición de objetos por bloques de código te proporciona un montón de objetos predefinidos para empezar a trabajar con ellos. Es buena idea que pruebes alguno sencillito para ver qué aspecto tienen los bloques de código. Si has trabajado con Scratch, te resultará muy familiar. En general, cualquiera que haya programado alguna vez, se acostumbrará rápidamente a los bloques de código. Por ejemplo, este es el aspecto de los bloques de código que generan una sencilla mesa con cuatro patas: . A la izquierda tienes los tipos de bloque disponibles, en el centro los bloques que estás usando y a la derecha el resultado. Los bloques de la zona centras se “ejecutan” de arriba a abajo para obtener la figura final. Para “ejecutar” el programa y ver cómo se va construyendo la figura al seguir los pasos, pulsa el botón “Play” que hay arriba a la derecha. Por ejemplo, en el programa de la imagen anterior, la secuencia de pasos es esta: . | Se definen algunas variables, como el alto, el ancho y la profundidad de la mesa, o la longitud de las patas. | Se crea un cubo de color rojo | Se mueve el cubo a la posición 0,0 del plano de trabajo. | Se crean otros dos cubos, que se usarán para hacer el “vaciado” de la parte inferior de la mesa. | Se agrupan los tres cubos, haciendo la operación de vaciado (como haríamos con el editor 3D). | Se reposiciona el grupo resultante para que la mesa quede justo sobre el plano de trabajo | . Puedes encajar y desencajar bloques de la secuencia para cambiar la manera en la que se genera el objeto. De este modo, y con un poco de práctica, lograrás crear objetos muy complejos en menos tiempo que si los hicieras con el editor 3D. 4.1.8. Exportando nuestros modelos para impresión 3D . Desde TinkerCAD, es muy sencillo exportar un modelo para imprimirlo con una impresora 3D. Simplemente, haz clic en el botón “Exportar” que encontrarás tanto en la pantalla de edición del modelo como en la pantalla principal de TinkerCAD. También podemos abrir la pantalla de edición de un modelo y seleccionar un solo objeto de nuestra escena (si es que tenemos varios) y, a continuación, hacer clic en “Exportar” para guardar en un archivo solo ese objeto, no la escena completa. Al exportar un modelo 3D, la aplicación te preguntará qué formato de archivo quieres utilizar. Para impresión 3D, TinkerCAD soporta archivos STL y OBJ, así que ha llegado el momento de que conozcas qué tipos de archivos para modelos 3D existen. ",
    "url": "https://iescelia.org//docs/tico/_site/modelado-e-impresion-3d/#41-software-para-dise%C3%B1o-3d-tinkercad",
    "relUrl": "/modelado-e-impresion-3d/#41-software-para-diseño-3d-tinkercad"
  },"89": {
    "doc": "4. Modelado e impresión 3D",
    "title": "4.2. Formatos de archivo para impresión 3D",
    "content": "Como ocurre con las imágenes planas o los archivos de vídeo, hay un montón de formatos diferentes para los modelos 3D. En este apartado vamos a conocer los principales y qué características tienen. Todos los archivos de modelos 3D contienen, como mínimo, una definición de la geometría de la pieza. Algunos, además, pueden contener información sobre las texturas, la escala, etc. A la hora de elegir un formato u otro, tienes que fijarte en la precisión con la que son capaces de reproducir el modelo original y, además, consultar la documentación de tu impresora para saber qué formatos soporta. Formato STL . El formato STL es el formato de modelos 3D más popular en el ámbito de la impresión 3D. Y también uno de los más antiguos y menos precisos. Fue creado en los años 90 por la empresa 3D Systems para la impresión 3D usando esterolitografía. Los archivos STL contienen las coordenadas de los polígonos que conforman la geometría tridimensional del objeto, excluyendo otras propiedades como el color, la escala, o la estructura del modelo. Una peculiaridad de los archivos STL es que el único polígono que soporta es el triángulo, por lo que, si nuestro modelo está hecho con otro tipo de polígonos, al exportarlo a STL estos polígonos se descomponen en triángulos. Existen varios tipos de archivo STL, pero los más comunes son el ASCII y el binario. Hay varios matices en el funcionamiento de cada uno, pero quédate con la idea de que los STL binarios son algo más pequeños y aparecieron como respuesta al tamaño creciente de los STL ASCII. A pesar de ser más ligeros, los STL binarios siguen ocupando demasiado tamaño si queremos dar mucha resolución a un objeto, ya que necesitaremos incluir muchos triángulos. Este formato es, actualmente, el más utilizado para compartir modelos para impresión 3D, aunque no es ni de lejos el mejor, ya que existen formatos más modernos que ocupan menos espacio y añaden más información. Formato OBJ . El formato OBJ, pese a ser menos conocido que el STL, es también muy popular y casi cualquier software relacionado con el diseño o la impresión 3D acepta este formato. Este formato es mucho más complejo y dispone de dos modos de funcionamiento: . | Modo preciso. Un archivo OBJ que utilice codificación precisa no hara descripción del modelo en polígonos, como sí hace un STL. En su lugar, conservará la geometría original del modelo utilizando unas líneas tridimensionales conocidas como NURBS (Non-uniform Rational B-spline). Esto significa que, usando un OBJ podemos capturar la geometría «original» del modelo, no una aproximación construída a partir de triángulos. | Modo aproximado. Un archivo OBJ que utilice una codificación aproximada genera una versión simplificada de la superficie del modelo a través de polígonos, como ocurre con un STL. En este caso, no estamos limitados a triángulos, sino que se pueden usar otros polígonos, por lo que, pese a ser solo una aproximación de la geometría original, podemos conseguir acabados más suaves. | . En ambos casos, además de la propia geometría del modelo 3D, un archivo OBJ incluye información adicional como: . | Un mapa de textura: básicamente, una imagen 2D que representa la «piel» del modelo. Este mapa de texturas es entendido por otros programas y así podemos recuperar la textura y colores originales del modelo. | Iluminación: fuentes de luz para iluminar adecuadamente el modelo en un programa de edición 3D. | Metadatos: quién creó el modelo, cuándo, con qué programa, etc. | . En resumen, el formato OBJ es una excelente alternativa a STL si queremos mayor precisión en los modelos. Formato 3MF . Otro de los problemas de los archivos STL es que son totalmente desestructurados, ya que contienen únicamente una lista de coordenadas de los bordes de los triángulos que componen la superficie del objeto. Nada en un archivo STL impide que un objeto tenga errores en su definición como, por ejemplo, agujeros, triángulos que se intersectan entre sí, triángulos volteados o invertidos, vértices no compartidos (es decir, que quedan “sueltos”), etc. Estos problemas, derivados de un mal modelado o de una mala exportación, pueden prevenirse usando el formato 3MF. Los modelos que exportemos como 3MF serán validados para evitar todos estos errores, por lo que podemos estar seguro de que nuestro archivo podrá ser impreso en 3D sin errores. Además de prevenir los errores, un archivo 3MF incluye mucha más información, ya que puede comprimir otros archivos y encapsularlos en un solo paquete, como hacemos al usar un archivo ZIP. Esa información adicional incluye: . | Escala: Los modelos tienen escala y unidades por lo que siempre tendremos el mismo tamaño al margen de la impresora o del laminador que usemos. | Escenas: Un archivo 3MF puede contener varios modelos separados y guardarlos como modelos diferentes que pertenecen a una misma escena. | Colores y texturas, como los OBJ. | Ajustes de impresión: junto a los modelos se pueden incluir los ajustes de impresión. De esta manera nos aseguramos de que compartimos no sólo el modelo, sino también cómo queremos que se imprima. | . Además, un archivo 3MF está comprimido y ocupa mucho menos que un STL. Por todo esto, 3MF es uno de los formatos más recomendables para la impresión 3D. Otros formatos . Existen varios formatos más que también son interesantes: . | Formato STP. Es el formato estándar para compartir modelos 3D según la norma ISO 10303. Este formato es muy interesante para intercambiar los modelos entre programas de CAD, ya que un archivo en este formato se podrá editar fácilmente en softwares de CAD convencionales. | Formato Collada. Este formato está en desuso, pero antes se utilizaba mucho para el intercambio de archivos entre programas como Maya o 3DSmax. Puede incluír geometría, color, textura y también información sobre las cinemáticas de los modelos. | Formato FBX. Muy usado en la industria del cine, incluye información sobre el «esqueleto» de las figuras, lo cual es importante para su animación. | . ",
    "url": "https://iescelia.org//docs/tico/_site/modelado-e-impresion-3d/#42-formatos-de-archivo-para-impresi%C3%B3n-3d",
    "relUrl": "/modelado-e-impresion-3d/#42-formatos-de-archivo-para-impresión-3d"
  },"90": {
    "doc": "4. Modelado e impresión 3D",
    "title": "4.2. Software para slicing (corte o laminado)",
    "content": "Para la impresión 3D, no solo necesitamos disponer de un modelo 3D convenientemente diseñado con una herramienta como TinkerCAD, Maya o Blender, sino que debemos preparar nuestro modelo para la impresión en capas. El software para corte o laminado (slicing, en inglés) se encarga de eso: se trata de un programa que convierte el modelo 3D en una serie de finas capas y produce un fichero que contiene el código G, que no es otra cosa que el conjunto de instrucciones adecuadas para un determinado tipo de impresora 3D. (El lenguaje G, por cierto, es un lenguaje de programación de control numérico muy extendido, pero no es necesario aprenderlo para imprimir en 3D, porque el slicer se encarga de todo) . Existen numerosos programas de laminado en el mercado, y muchos de ellos son gratuitos, pero sin duda el número uno es uno con el peculiar nombre de Cura. Ultimaker Cura es un programa gratuito, multiplataforma (Windows, Linux, Mac) y de código abierto mantenido por Ultimaker (un fabricante de impresoras 3D) y una ferviente comunidad de usuarios. Admite archivos STL, 3MF y OBJ, que el slicer 3D puede reparar en caso necesario. Además, crea rutas de herramientas, así como estimaciones del material y el tiempo de impresión. Dispone de ajustes para novatos y para expertos, por lo que es muy apropiado para cualquier tipo de usuario. Los resultados de impresión son generalmente muy buenos. El software Cura se actualiza continuamente y dispone de montones de plugins externos. Existe una versión enterprise que no es gratuita y que dispone de plugins especialmente diseñados para profesionales. Aspecto de Ultimaker Cura en su versión para Windows Para preparar un modelo 3D con Cura y dejarlo listo para imprimir, simplemente sigue estos pasos: . | Instala Cura en tu ordenador y ejecútalo. | Abre tu modelo 3D. Cura admite los formatos STL, OBJ y 3MF, así que puedes abrir los modelos hechos con TinkerCAD sin problemas. | En la parte superior del área de trabajo verás dos botones, etiquetados como “1” y “2” (ver captura de pantalla más abajo). Pulsa el botón “1” para seleccionar tu tipo de impresora. Si no está en la lista, selecciona la que más se parezca. | Después, pulsa el botón “2” para seleccionar los ajustes de impresión. Si has seleccionado bien la impresora, estos ajustes ya vendrán preestablecidos y no tendrás que tocarlos. En caso contrario, tendrás que juguetear un poco con ellos hasta conseguir una impresión adecuada. | Inicia el laminador pulsando en el botón que encontrarás abajo y a la derecha. | Una vez terminado el laminado, se habilitará el botón “Preview” (en la parte superior de la ventana) para previsualizar el resultado. Es muy útil para comprobar si el modelo es apto para su impresión o si contiene errores. | Guarda el trabajo en una memoria USB o disco extraíble para poder transferirlo a tu impresora. Algunas impresoras más avanzadas soportan la impresión por red o a través de servicios cloud, por lo que puedes imprimir tu modelo directamente desde Cura. | . Aspecto de Cura justo después de preparar un modelo 3D para su impresión. Arriba puedes observar los botones para seleccionar la impresora (etiquetado como \"1\") y para los ajustes de impresión (etiquetado como \"2\"). El botón \"Preview\" ya está disponible porque el slicing ya ha finalizado. ",
    "url": "https://iescelia.org//docs/tico/_site/modelado-e-impresion-3d/#42-software-para-slicing-corte-o-laminado",
    "relUrl": "/modelado-e-impresion-3d/#42-software-para-slicing-corte-o-laminado"
  },"91": {
    "doc": "4. Modelado e impresión 3D",
    "title": "4.4. Pruebas de impresión",
    "content": "La impresión 3D ha avanzado mucho en los últimos años, pero aún se encuentra dando sus primeros pasos. Te digo esto para que comprendas por qué imprimir en 3D no es tan sencillo como hacerlo en 2D. En tu vieja impresora de inyección de tinta o láser, simplemente cargas una hoja de papel, envías un archivo para imprimir, y en unos segundos tienes una copia perfectamente impresa. Sin embargo, si alguna vez has cambiado los cartuchos de tinta o el tóner de tu impresora, quizá te hayas fijado en que la impresora hace un calibrado automático inmediatamente después. Esto es necesario para que la impresión se haga correctamente, esto es, para que cada punto de tinta se imprima en el lugar correcto de la página. Por desgracia, las impresoras 3D necesitan un calibrado manual porque, como te digo, esta tecnología aún está dando sus primeros pasos. Y ese calibrado puede llegar a ser una tortura. Aprender a calibrar bien una impresora 3D es importante para: . | Que los componentes no se rompan. | Que tus piezas salgan perfectas. | Evitar dolores de cabeza y filamento malgastado. | . 4.4.1. Diez pasos para calibrar una impresora 3D . 1. Limpia bien la impresora 3D: Muchas veces no nos damos cuenta la cantidad de roña que hay en nuestras impresoras y de lo que afecta a su funcionamiento. Límpiala a conciencia antes de imprimir nada. 2. Tensa bien las correas: Las correas de la impresora siempre tienen que estar bien tensas para que no haya problemas de pérdida de pasos. Es la parte más importante de la mecánica. 3. Cambia piezas desgastadas: Nada de “ya lo cambiaré cuando se rompa”. Los fallos por rotura en las impresoras hacen efecto dominó, y un simple rodamiento en mal estado puede acabar estropeando otras piezas. 4. Lubrica todo bien: Una máquina lubricada es una máquina con años de vida. Lubrica bien los componentes necesarios: aceite de silicona para rodamientos y grasa de litio para husillos y varillas. 5. Instala Marlin: Marlin es un firmware abierto y gratuito que funciona en muchas impresoras 3D. El firmware es un pequeño programa que controla la propia impresora. Si puedes instalar Marlin en tu impresora 3D, conseguirás configurarla y afinarla con mucha más facilidad. 6. Mira los pasos de los motores: Es decir, cuando “avanza” cada motor en cada giro. Con Marlin se puede ajustar al milímetro el paso de motor. Si no es posible, tienes que mirar si el software que trae tu impresora te permite ajustarlo. 7. Calibra el flujo de plástico: Hay veces que nuestro extrusor se desajusta y no extruye lo que debería extruir, sacando más cantidad o menos cantidad de plástico de la necesaria. 8. Afina la distancia del Eje Z: Esta distancia es vital para la impresión: si lo dejas muy lejos, el plástico 3D no se pegará; si lo haces muy cerca, habrá una sobrepresión que acabará deformando la figura. Una distancia de 0,15mm suele funcionar bien. 9. Testéalo todo con un cubo: Una vez hecho todo hay que comprobar si va bien. Para ello, lo mejor es imprimir un cubo u otra figura muy simple. 10. Imprímete algo bonito: Así comprobarás si realmente todo se ha calibrado correctaemente. 4.4.2. Modelos de prueba . Hablando de imprimir “algo bonito”, existen modelos de prueba usados para probar específicamente ciertas capacidades de tu impresora 3D y ayudarte a calibrarla. Por ejemplo, unos modelos pueden probar la habilidad de tu impresora para imprimir puentes o voladizos; otros pueden probar la precisión o el acabado de la superficie, y otros ponen a prueba determinados ajustes del programa de corte o slicer, como la velocidad, la temperatura o la extrusión de las capas. Estos son algunos modelos de prueba muy populares: . 3D Benchy . 3DBenchy es el buque insignia, nunca mejor dicho, de las pruebas de impresión más populares. Con este modelo, puedes experimentar con todo tipo de elementos, desde voladizos hasta extrusiones. Si quieres poner a punto tu impresora, Benchy te ayudará a determinar los ajustes necesarios para obtener las impresiones perfectas. La presencia de unos cuantos barquitos Benchy alrededor de una impresora es un signo inequívoco de un fabricante experimentado. All in one 3D printer test . Como su nombre indica, este test «todo en uno» para impresoras 3D contempla todo tipo de elementos: voladizos, puentes, encordado, extrusión, temperatura, tensión de la correa… . Una vez realizada la impresión, podrás encontrar una solución para los problemas que hayan surgido en la guía de resolución de problemas que suele acompañar al modelo y en muchos sitios de internet. Dado de calibración XYZ de 20 mm . Este dado de calibración es un modelo sencillo, rápido y fácil para poner a tu impresora contra las cuerdas. Su objetivo principal es ayudarte a ajustar la precisión de tu impresora modificando los pasos por mm, pero también permite probar la temperatura, la extrusión y la vibración. Cali Cat, el gato para calibración . Cali Cat es un modelo sencillo y adorable que te permitirá probar la precisión, los voladizos, los detalles, los puentes, las extrusiones y la vibración en tu impresora, todo ello en menos de una hora. Diseñado para realizar la calibración inicial, este lindo gatito te permitirá calibrar tu impresora en muy poco tiempo. Curiosidad: si imprimes un gato el doble de grande que el otro, el gato pequeño encajará perfectamente sobre el grande. Modelo paramétrico para la calibración de la cama . La nivelación de la cama suele ser el paso más complejo de la calibración de una impresora 3D. Este modelo te permitirá detectar cómo mejorar las primeras capas de tus impresiones. ",
    "url": "https://iescelia.org//docs/tico/_site/modelado-e-impresion-3d/#44-pruebas-de-impresi%C3%B3n",
    "relUrl": "/modelado-e-impresion-3d/#44-pruebas-de-impresión"
  },"92": {
    "doc": "4. Modelado e impresión 3D",
    "title": "4.5. Imprimir el modelo",
    "content": "Hemos diseñado nuestro modelo 3D, lo hemos exportado a un archivo STL, OBJ o 3MF, lo hemos laminado y tenemos nuestra impresora razonablemente bien calibrada. ¡Por fin llega el momento de ponernos a imprimir! . ¿Cómo se hace eso? . Lógicamente, el procedimiento exacto depende del modelo de impresora 3D que tengamos, pues incluso entre impresoras FDM puede haber muchas diferencias. La mayoría de las impresoras FDM domésticas tienen un panel de control con botones o diales, un puerto USB y una pantalla para comunicarse con el usuario. En estos modelos, tienes que guardar tu código G (el que genera el software de slicing) en una memoria USB (o disco duro externo) y conectarla al puerto USB del panel de control. Para asegurarte de que no hay problemas con la lectura, formatea la memoria USB como FAT32. Si eso no es posible, consulta el manual de usuario de tu impresora para ver qué sistemas de ficheros soporta. Panel de control típico de una impresora FDM doméstica. El puerto USB suele estar en un lateral. La electrónica del panel de control revisará el contenido de la memoria USB y te permitirá elegir el archivo que quieres imprimir. La forma de hacer esto también puede ser diferente en unas impresoras que en otras: algunas cuentan con una rueda que se gira a un lado y a otro para cambiar la selección y que se pulsa para aceptar la selección. Otras tienen botones o pantallas táctiles para lograr el mismo efecto. Por último, la impresora te preguntará por algunos parámetros de configuración (como la temperatura) y te pedirá confirmación para iniciar la impresión. Además, cuando el proceso de impresión comience, te irá informando en la pantalla de cómo se está desarrollando o de posibles errores. 4.5.1. Consejos antes de imprimir . Además de hacer un adecuado mantenimiento de la impresora (limpieza, calibración, etc), antes de imprimir cualquier modelo es necesario preparar la cama y cargar el filamento. La preparación de la cama suele consistir en aplicar un material antideslizante a su superficie, sobre todo si es de cristal. Hay quien usa cintas especiales, como Kapton Tape, que se vende en distintos anchos, para crear una capa antideslizante muy fina y resistente. También existen láminas de plástico como BuildTak. Puedes encontrar todos estos productos en cualquier tienda especializada física u online. Si no tienes a mano nada de esto, la cinta de pintor (Blue tape, o incluso cinta de carrocero de toda la vida) es una solución barata y aceptable. Otras personas prefieren imprimir directamente sobre el cristal, que debe estar en buen estado, sin arañazos profundos. En tal caso, es necesario rociarlo con un spray antideslizante como 3DLac o DimaFix. También se puede usar laca para el pelo, que por su naturaleza crea una capa invisible levemente pegajosa que puede limpiarse después con un trapo humedecido con agua. Pieza despegada por falta de adherencia a la cama . Kapton tape (cinta específica para camas de impresoras 3D) y blue painter tape (cinta de pintor azul) La carga de filamento solo es necesaria si este no está ya cargado de una impresión anterior. Cambiar el filamento es sencillo: se calienta el cabezal, se saca el material, se coloca la nueva bobina y se introduce el filamento. Si el material del nuevo filamento fuera diferente del viejo, hay que limpiar el cabezal antes de volver a introducir el nuevo. Por supuesto, debes asegurarte de que queda filamento suficiente en la bobina para imprimir la pieza. Algunos programas como Cura te hacen una estimación del peso de la pieza que vas a imprimir, para que puedas estimar si tu bobina es suficiente. Cómo sustituir una bobina y cargar el filamento en el extrusor La limpieza del extrusor es imprescindible para evitar atascos en el cabezal de impresión. Debe hacerse depués de cada impresión y comprobarse antes de imprimir. Esta limpieza puede hacerse de varias maneras. Muchos usuarios utilizan un hilo de nylon del grosor adecuado, que puede conseguirse en cualquier ferretería. Se calienta el cabezal y se hace pasar el nylon por él hasta que salga limpio. El nylon tiene una temperatura de fusión superior a los filamentos FDM, por lo que limpiará los restos sin derretirse él mismo. Luego se enfría el cabezal hasta los 90º y se retira el filamento de nylon. Veremos que sale sucio. Se tiene que repetir esta operación hasta que salga limpio. También existen filamentos hechos adrede para este propósito. En casos extremos, puede ser necesario desmontar el extrusor para hacer la limpieza desde el interior. Cómo limpiar el extrusor con un filamento de nylon Cómo desmontar el extrusor en caso de atasco persistente 4.5.2. Consejos durante la impresión . Mientras la impresora trabaja podemos hacer una inspección visual periódica de cómo se está imprimiendo nuestra pieza. Esto es particularmente importante en las primeras capas, que es donde suelen darse la mayor parte de los problemas. Por ejemplo, porque la pieza se deslice sobre la cama. Todos los paneles de control permiten suspender la impresión en cualquier momento si obervamos que algo está saliendo mal. El proceso de impresión puede durar bastante tiempo: desde unos minutos hasta varias horas. Todo depende de la complejidad de la pieza y de los ajustes de la impresora (velocidad, grosor de cada capa, etc), así que tampoco es necesario que te pases las horas muertas observando trabajar al cabezal de impresión, pero sí es buena idea que te pases de vez en cuando para ver cómo va el trabajo. Asegúrate de que en el entorno de la impresora no se producen corrientes de aire durante la impresión. El filamento es muy ligero y la corriente de aire puede desviarlo, dando lugar a un inoportuno error de impresión. Para el correcto enfriamento del filamento, la temperatura ambiente debe ser moderada (menos de 30º C). El exceso de polvo en el ambiente y la luz solar directa también pueden afectar a la calidad de la impresión. 4.5.3. Consejos para después de imprimir . Corta el filamento sobrante. Para ello, necesitarás disponer de unos alicates apropiados. Retira la pieza de la cama con cuidado, en particular si aplicaste alguna sustancia antideslizante, porque entonces la pieza estará ligeramente pegada a la cama. Antes de retirarla, espera al menos 5 minutos para que toda la pieza se endurezca. Limpia la cama, sobre todo si la rociaste con spray. Retira cualquier resto de plástico con una espátula suave. Si has aplicado laca para el pelo, límpiala con un trapo humedecido con agua u otro disolvente. Los sprays específicos para impresoras 3D también se limpian con agua, pero estos últimos pueden durarte varias impresiones antes de tener que volver a aplicarlos. En cualquier caso, antes de poner una nueva capa de spray, limpia bien la anterior. Por último, si has utilizado una cinta antideslizante, retírala si está en mal estado y limpia los restos de adhesivo, si los hubiera, con el disolvente apropiado (alcohol o acetona suelen dar buen resultado). Limpia el extrusor. Te explicamos como hacerlo en el apartado “Antes de imprimir” que encontrarás un poco más arriba. Comprueba la pieza, no solo sus acabados, sino también sus dimensiones. Esto te permitirá descubrir errores de calibrado de tu impresora antes de que se hagan muy grandes. En algunas piezas, y dependiendo del material utilizado para la impresión, puede aplicarse una capa protectora de acetona (solo para plástico ABS) o una resina de recubrimiento llamada XTC, que permite lijar y pintar la pieza, dándole un aspecto mucho más liso. Una pieza antes y después de la aplicación de una resina XTC. 4.5.4. Algunos tips para usar la impresora de CR10-mini con éxito . En el momento de escribir esto, en el IES Celia Viñas contamos con una impresora Crealty CR10-mini. Se trata de una impresora de filamento capaz de imprimir en plástico ABS y PLA. Después de varios meses de experiencia trabajando con ella, podemos proporcionarte algunos consejos adicionales referidos a este modelo concreto: . | Calienta el filamento un poco por encima de la temperatura indicada por el fabricante del mismo, sobre todo en invierno. Alrededor de 210 o 215º van bien para el PLA. El ABS necesitará que pongas la máquina a tope de temperatura. Ojo, porque cada vez que inicies una nueva impresión, la impresora hará bajar su temperatura hasta los valores establecidos de fábrica y tendrás que volver a subirlos. | Calienta también la cama un poco por encima de lo normal: unos 60º para el PLA y 70-80º para el ABS. | La calibración de la altura de la cama es fundamental para obtener un buen resultado. Si no, las piezas se despegarán hagas lo que hagas. Recuerda que el ABS se despega con más facilidad que el PLA. | Limpia y calibra la cama antes de cada impresión. Los laminados de Cura hacen varias pasadas de calibración previas antes de empezar a imprimir. Úsalas para darle un último toque a la calibración mirando de perfil cómo se mueve el extrusor y a qué distancia de la cama está. Recuerda que debe estar muy, muy cerca del cristal pero sin llegar a tocarlo. | Usa laca del pelo extrafuerte o, mejor aún, algún spray específico para mejorar el agarre de la pieza a la cama. Debes reponerlo antes de cada impresión y extender una capa generosa cuando la cama aún no esté demasiado caliente. | Usa un poco de cinta de carrocero para asegurarte de que el cristal no se mueve de su posición en la cama. | Las piezas con una base muy grande se imprimen mejor. Cuanto menor es la base con la que apoyan en la cama, más posibilidades hay de que se muevan y la impresión se estropee. Si la pieza es pequeña y siempre se te despega, platéate alguna de estas alternativas: . | Aumentar su tamaño. | Reducir la velocidad de impresión. | Añadir a la pieza una base de apoyo de tamaño generoso. | . | . ",
    "url": "https://iescelia.org//docs/tico/_site/modelado-e-impresion-3d/#45-imprimir-el-modelo",
    "relUrl": "/modelado-e-impresion-3d/#45-imprimir-el-modelo"
  },"93": {
    "doc": "4. Modelado e impresión 3D",
    "title": "4.6. Ejercicios",
    "content": "Ejercicio 1. Regístrate en TinkerCAD y familiarízate con el entorno de trabajo. Tienes que aprender, como mínimo, a rotar, trasladar y hacer zoom de la vista, así como a insertar objetos, escalarlos y moverlos. Ejercicio 2. Trata de crear con TinkerCAD este sencillo perro salchicha. Ejercicio 3. Sigue los pasos de los apuntes para crear con TinkerCAD la cabaña que aparece aquí . Ejercicio 4. Sigue los pasos de los apuntes para crear con TinkerCAD la estructura con cuatro esferas alineadas que aparece aquí . Ejercicio 5. Intenta crear con TinkerCAD la taza con el busto de Ironman que se describe aquí. Puedes usar otro busto que localices en Thingverse (o en algún otro sitio de modelos 3D de libre uso) si lo tuyo no son Los Vengadores. Ejercicio 6. Instala el programa Ultimaker Cura en tu ordenador. Exporta la taza de Ironman (o del busto que hayas empleado) a formato STL y ábrela con Cura. Haz el slicing (laminado) para dejarla lista para su impresión. Guarda el archivo con el resultado. Ejercicio 7. Utiliza los bloques de código para crear con TinkerCAD 10 mesas de cuatro patas, siguiendo las pistas que se dan en este apartado. Las mesas deben estar lo bastante separadas unas de otras como para que se puedan ver con facilidad. A ver si consigues que cada una tenga un color diferente. Ejercicio 8. Modifica el ejercicio anterior para generar 28 mesas en lugar de 10. Colócalas como si fueran las mesas de un aula para 28 personas (por ejemplo, haciendo 4 filas de 7 mesas). Crea 28 sillas y colócalas junto a las mesas. Por último, crea una mesa (un poco más grande) junto con su silla para el profesor y colócala en un extremo de la clase. Ejercicio OBLIGATORIO. Ya conoces los fundamentos del modelado e impresión 3D. Ahora, para evaluar este bloque de la asignatura, te voy a pedir que prepares dos modelos distintos: . | Un modelo para imprimir. Debe ser algo sencillito (un llavero con tu nombre, por ejemplo). Expórtalo a STL, lamínalo con Cura e imprímelo. Haremos turnos de impresión para que todos/as tengáis ocasión de usar la impresora 3D. | Un modelo para lucirte. Este puede (y debe) ser todo lo complejo que quieras. Deja volar tu imaginación o, mejor todavía, deja que se te vaya un poco la olla para crear algo que solo tú puedas hacer. Este modelo tendrás que subirlo a Moodle Centros. | . Importante: los dos modelos deben ser tuyos, no descargados de Internet (aunque puedes descargar alguna parte para reutilizarla, como hicimos con la taza de Ironman) . ",
    "url": "https://iescelia.org//docs/tico/_site/modelado-e-impresion-3d/#46-ejercicios",
    "relUrl": "/modelado-e-impresion-3d/#46-ejercicios"
  },"94": {
    "doc": "10. Orientación a objetos con C++",
    "title": "10. Orientación a objetos con C++",
    "content": ". | 10.1. Conceptos básicos de programación orientada a objetos . | 10.1.1. Un ejemplo sencillo para entender el concepto de “objeto” | 10.1.2. Métodos | 10.1.3. Atributos | 10.1.4. Herencia | . | 10.2. Los objetos en Javascript . | 10.2.1. Creación de objetos con Javascript | 10.2.2. El objeto “this” | 10.2.3. Las clases en Javascript | 10.2.4. Herencia en Javascript | 10.2.5. El objeto “super” | 10.2.6. Algunos aspectos avanzados | 10.2.7. Objetos predefinidos de Javascript | . | 10.3. Un ejemplo completo | . ATENCIÓN: este capítulo está en fase de revisión, así que su contenido va a cambiar en las próximas semanas. En este capítulo vamos a introducir las técnicas de programación orientada a objetos y su implementación en Javascript. La programación orientada a objetos es una forma de programar (un paradigma, dicen los teóricos) que implica organizar el código fuente de una determinada manera. Desde que este paradigma se impuso con fuerza en la década de 1990, se ha comprobado que las aplicaciones orientadas a objetos son más fáciles de diseñar y de mantener que las aplicaciones que usan técnicas de programación más anticuadas (lo que se llama programación estructurada clásica). Javascript es un lenguaje orientado a objetos, aunque hace una interpretación un poco peculiar de lo que significa este concepto. En este capítulo, veremos primero qué es la programación orientada a objetos y luego nos centraremos en cómo aplicar esas ideas a Javascript. ",
    "url": "https://iescelia.org//docs/tico/_site/orientacion-a-objetos-c++/",
    "relUrl": "/orientacion-a-objetos-c++/"
  },"95": {
    "doc": "10. Orientación a objetos con C++",
    "title": "10.1. Conceptos básicos de programación orientada a objetos",
    "content": "Los párrafos que vienen a continuación se basan en un texto Yukihiro Matsumoto, el creador del lenguaje Ruby. La razón es sencilla: me parece una explicación insuperable (gracias a Matsumoto, claro, no a mí). Para entender qué significa exactamente programación orientada a objetos, primero tenemos que comprender en qué consiste la programación tradicional o no orientada a objetos. En programación tradicional, cualquier problema informático se resuelve codificando un conjunto de algoritmos que trabajan sobre un conjunto de datos. Es decir, los datos son elementos pasivos: es el código el que se encarga de hacer todo el trabajo por ellos. A medida que los proyectos crecen, el código también lo hace, y llega un momento en el que es imposible saber cómo funciona todo el sistema. Surgen interacciones imprevistas e impredecibles entre distintas partes del programa. El fallo más tonto, como un error tipográfico, puede convertirse en una pesadilla cuya localización puede suponer muchas horas de trabajo (y, en consecuencia, mucho dinero). Como dice Matsumoto, el mantenimiento de estos programas se convierte en algo parecido a transportar un calamar gigante intentado que ninguno de sus tentáculos te alcance la cara. Lo que hace la programación orientada a objetos es cambiar esta forma de trabajar. No supone una revolución con los métodos anteriores, sino un cambio en la forma en la que se hacen las mismas cosas de siempre. La mayoría del trabajo se delega a los propios datos, de modo que los datos ya no son estáticos, sino que se encargan de mantenerse en forma a sí mismos. De nuevo en palabras de Matsumoto: dejamos de tratar cada pieza de dato como una caja en la que se puede abrir su tapa y arrojar cosas en ella y empezamos a tratarlos como máquinas funcionales cerradas con unos pocos interruptores y diales bien definidos. Un dato en programación orientada a objetos (es decir, una caja con interruptores, botoncitos y diales) puede tener, en sus tripas, algo muy simple o muy complejo. No se puede saber desde el exterior y no se nos permite abrir la máquina (excepto cuando estamos completamente seguros de que algo está mal en su diseño), por lo que se nos obliga a utilizar los interruptores y leer los diales para interactuar con los datos. Una vez construida una de esas máquinas, no queremos tener que volver a pensar en cómo funciona internamente. 10.1.1. Un ejemplo sencillo para entender el concepto de “objeto” . Seguimos con Matsumoto para ilustrar con un ejemplo sencillo qué es eso de una “máquina con unos pocos interruptores y diales”. Seguramente en tu cocina tienes un horno microondas (aunque, en realidad, para este ejemplo podrías elegir cualquier electrodoméstico). El horno consta, entre otros muchos subsistemas, de un temporizador. Su trabajo consiste en mantener el horno encendido durante un tiempo determinado por el usuario. ¿Cómo podríamos representar esto en un lenguaje de programación? En Javascript, por ejemplo, el temporizador podría ser, simplemente, una variable de tipo number. El programa manipularía esa variable disminuyendo el valor una vez por segundo, y permitiría al usuario establecer el tiempo inicial del temporizador antes de poner el horno en marcha. Con este enfoque tradicional, un error en cualquier parte del programa podría terminar asignando un valor falso a la variable, como un número negativo o un tiempo de varias horas. Hay un número infinito de razones inesperadas por las que podría llegar a suceder esto. Cualquiera con cierta experiencia programando sabe que se pueden perder horas o días tratando de encontrar ese error. Pero si programamos con un lenguaje orientado a objetos, no pensaremos en el tipo de datos que mejor se ajusta a un temporizador de microondas, sino en el modo en el que un temporizador de microondas funciona en el mundo real. No parece una gran diferencia, pero lo es. El programador, o el diseñador, necesitará dedicar cierto tiempo a decidir qué es exactamente un temporizador de microondas y cómo se espera que el mundo exterior interactúe con el. Por fin, construirá una pequeña máquina (una pieza de software) con controles que permitan establecer, consultar y disminuir su valor. Por ejemplo, podemos decidir crear el temporizador impidiendo asignarle un valor arbitrario, por la sencilla razón de que los temporizadores de microondas no trabajan de esa forma en el mundo real: solo permiten asignar múltiplos de 10 segundos, por lo general. Es decir: existen sólo unas cuantas cosas que un temporizador de microondas puede hacer, y sólo permitiremos esas cosas. Así, si alguien desde otra parte del programa trata de asignar algún valor no permitido al temporizador, como un número negativo, le resultará imposible hacerlo por la sencilla razón de que el propio temporizador no lo permitirá. Ya no es un dato “tonto” y estático, que permite que cualquiera lo manipule. Es un dato “listo”, con control y autonomía sobre su propio comportamiento. Lo hemos convertido en un objeto. De ese modo, estaremos protegiendo una parte del programa de errores cometidos en otras partes y que, en programación tradicional, se propagan como el fuego en un tanque de gasolina. Por si fuera poco, los lenguajes orientados a objetos nos permiten que, una vez que hayamos diseñado un temporizador de microondas (o el objeto que sea), podamos fabricar tantos como sea necesario. Habremos creado un patrón o molde de temporizador y, a partir de ese molde, se pueden construir objetos diferentes (pero similares) indefinidamente. Pues bien, el molde se conoce como clase, y cada temporizador concreto que fabriquemos a partir de ese molde se conoce como objeto. Aclaremos, sin embargo, que la programación orientada a objetos no es una solución milagrosa: nada impide, en cualquier lenguaje, escribir código poco claro, descuidado, inestable o directamente erróneo. A continuación hablaremos de los “interruptores y diales” del temporizador del microondas (métodos) y, un poco después, veremos como se construyen los moldes (clases). 10.1.2. Métodos . En la programación orientada a objetos, como acabamos de ver, no se piensa en manipular los datos directamente desde el exterior de un objeto, sino que son los propios objetos los que deciden cómo se debe operar sobre ellos. Se pasa un mensaje al objeto y este mensaje provoca algún tipo de acción o respuesta significativa por parte del objeto. Esto ocurre sin que nos importe cómo realiza el objeto, interiormente, el trabajo. Las tareas que podemos pedir que un objeto realice (o lo que es lo mismo, los mensajes que el objeto comprende) son los métodos. En Javascript, se llama a un método con la notación punto (como en Java, C++, Python, Ruby o muchos otros lenguajes). El objeto con el que nos comunicamos se nombra a la izquierda del punto. Por ejemplo: . mi_cadena = \"Hoy es viernes\"; alert(\"Cadena convertida a mayúsculas: \" + mi_cadena.toUpperCase()); . Hemos enviado a un objeto llamado mi_cadena (que es, evidentemente, una cadena de caracteres) el menaje toUpperCase(). La salida por pantalla será: . Cadena convertida a mayúsculas: HOY ES VIERNES . Intuitivamente es fácil comprender lo que ha ocurrido aquí: al objeto mi_cadena se le ha pedido que nos calcule una versión de sí mismo con todos los caracteres convertidos en mayúscula. Técnicamente, lo que hemos hecho se llama invocar el método toUpperCase() del objeto mi_cadena. Otros objetos pueden hacer una interpretación un poco diferente de toUpperCase(), o no comprenderlo en absoluto. Cuando un objeto recibe un mensaje que no conoce, se produce un error. Por lo tanto, hay que conocer qué métodos son aceptables para un objeto, aunque no se necesita saber como están programados por dentro. Los métodos, recuerda, son como los diales del horno microondas: como usuario, tienes que saber qué diales existen y cómo usarlos, pero no cómo están construidos. 10.1.3. Atributos . Los atributos de un objeto definen las características del mismo. Por ejemplo, un atributo del temporizador del microondas debería ser el número de segundos que éste debe permanecer activo, y un atributo de un objeto de tipo String debe de ser el número de caracteres de que consta la cadena. Al programador que usa un objeto deberían importarle un bledo los atributos del mismo. Él (o ella) se encargará de usar el objeto a través de sus métodos, y éstos operarán con los atributos, si ello es necesario, de forma totalmente transparente al programador. Es decir, los atributos raramente son accesibles desde el exterior del objeto, salvo que, por razones de diseño, el programador del objeto haya decidido lo contrario. 10.1.4. Herencia . En programación orientada a objetos, unas clases pueden heredar de otras. El concepto de herencia, en este contexto, se parece a la herencia genética entre seres vivos. Un ser vivo hereda por vía genética ciertas características de sus progenitores. Del mismo modo, una clase puede heredear ciertas características de sus clases-madre. Esto es extraordinariamente útil para reutilizar código y, por lo tanto, facilitar y abaratar el desarrollo y el mantenimiento de las aplicaciones informáticas. Por ejemplo, si en una aplicación tenemos una clase llamada Vehículo con ciertos atributos (matrícula, marca, modelo, etc), podemos crear varias subclases o clases-hijas llamadas Turismo, Camión o Bicicleta. Todas ellas heredarán los atributos y métodos de la clase-madre. Es decir, todas tendrán matrícula, marca y modelo, por ejemplo. Pero algunas de las subclases pueden necesitar atributos o métodos adicionales (¿qué tal un atributo número_plazas para Turismo?), mientras que otras pueden prescindir de algunos atributos o métodos (las bicicletas no suelen tener matrícula). Sin embargo, todas las subclases siguen siendo vehículos, y el código fuente que hayamos escrito para la clase Vehículo sigue siendo válido en cada una de ellas, sin necesidad de reescribirlo. ",
    "url": "https://iescelia.org//docs/tico/_site/orientacion-a-objetos-c++/#101-conceptos-b%C3%A1sicos-de-programaci%C3%B3n-orientada-a-objetos",
    "relUrl": "/orientacion-a-objetos-c++/#101-conceptos-básicos-de-programación-orientada-a-objetos"
  },"96": {
    "doc": "10. Orientación a objetos con C++",
    "title": "10.2. Los objetos en Javascript",
    "content": "Una vez comprendidos los conceptos básicos de programación orientada a objetos, vamos a ver cómo se utilizan en Javascript. Javascript ha hecho, históricamente, una interpretación un poco peculiar del paradigma de orientación a objetos. De hecho, se decía de él que no era un lenguaje orientado a objetos, sino orientado a prototipos. No importa demasiado lo que esto significa, al menos de momento. Afortunadamente, desde la versión EC6 del año 2015, Javascript admite definiciones de clases y objetos mucho más convencionales y respetuosas con el paradigma. 10.2.1. Creación de objetos con Javascript . En JavaScript, crear un objeto individual es tan sencillo como declarar una variable con esta sintaxis: . var book = {}; . Por supuesto, esto creará un objeto llamado book que estará vacío. Para que el objeto tenga atributos y métodos, hay que rellenarlo con código. Observa el siguiente ejemplo: . var book = { title: 'The Lord of the Rings', year: 1954, genre: ['epic', 'fantasy'], getTitle: function() { alert(this.title); } getGenres: function () { alert(this.genre[0] + ' ' + this.genre[1]); }, }; . Este objeto se compone de tres atributos (title, year, genre) y dos métodos (getGenres() y getTitle()). A los atributos les hemos asignado algunos valores. De este modo, podemos invocar a los métodos y comprobar que el objeto responde correctamente. Así: . book.getTitle(); book.getGenres(); . El resultado serán dos pantallas de tipo alert() donde se nos mostrarán los textos “The Lord of the Rings” y “epic fantasy”, respectivamente. En el objeto anterior, también podemos acceder y modificar los atributos del objeto. Observa este código: . alert(book.title); book.title = \"Harry Potter and the Philosopher's Stone\"; alert(book.title); . El primer alert() mostrará “The Lord of the Rings” (exactamente igual que el método getTitle()), mientras que el segundo alert() mostrará “Harry Potter and the Philosopher’s Stone”, porque hemos accedido y modificado el atributo title del objeto book. 10.2.2. El objeto “this” . Es posible que te haya llamado la atención la presencia de la palabra this en el objeto book. Esa palabra se refiere al objeto actual sobre el que se está ejecutando el código. En el ejemplo, this es equivalente a book. Si, por ejemplo, le cambiásemos el nombre a la variable book, no será necesario cambiar el código fuente de sus métodos porque esos métodos se refieren a this, no a book. Puedes verlo mejor en este ejemplo: . var book1 = { title: 'The Lord of the Rings', getTitle: function() { alert(this.title); } } var book2 = { title: 'The Hunger Games', getTitle: function() { alert(this.title); } } . En el objeto book1 podíamos haber utilizado el identificador book1 en lugar de this, y funcionaría exactamente igual. Lo mismo suceden con book2. ¿Cuál es la ventaja, entonces, de usar this? Muy pronto aprenderemos a crear múltiples objetos a partir del mismo código fuente. En ese caso, ¿qué tendríamos que poner en el código fuente? Si escribimos book1, el código ya no funcionaría para book2, y si escribimos book2, no funcionaría para book1. En cambio, escribiendo this, el método getTitle() funciona con book1, con book2 y con cualquier otro objeto que creemos a partir del mismo molde. 10.2.3. Las clases en Javascript . (Nota importante: como hemos dicho al principio, vamos a utilizar la sintaxis de Javascript EC6 y posterior. Si no sabes de qué estamos hablando, no te preocupes: solo tienes que mantener tu navegador web actualizado para asegurarte que entiende el Javascript moderno). Como vimos antes, una clase en un molde a partir del cual podemos crear objetos idénticos (aunque luego cada uno pueda evolucionar de forma independiente del resto). Por ejemplo, podemos definir una clase Book que tenga en su interior los atributos (title, genre, etc) y los métodos (como getTitle()), y a partir de ella podemos crear todos los objetos de tipo Book que necesitemos. Así, solo habremos escrito el código fuente una vez, y lo podemos reutilizar tantas veces como sea necesario, no cada vez que vayamos a crear un libro. En Javascript, la clase Book se declara así: . class Book { title; // Atributo constructor(title) { // Método constructor this.title = title; } getTitle() { // Otro método alert(this.title); } } . Esta clase contiene: . | Un atributo (title). | El método constructor(), que se ejecutará automáticamente al crear cada nuevo objeto del tipo Book. Es importante que se llame exactamente así. Observa que tiene un parámetro, title. | El método getTitle() , que nos mostrará el título del libro mediante un alert(). Este método puede tener el nombre que queramos y podría hacer cualquier otra cosa con el libro. Nos limitamos al mostrar el título como ejemplo de algo que tiene sentido hacer con un libro. | . Ahora podemos crear todos los Books que queramos, y todos utilizarán el mismo código y tendrán los mismos atributos. Por ejemplo: . var book1 = new Book('The Lord of the Rings'); var book2 = new Book('The Hunger Games'); var book3 = new Book('The Neverending Story'); . Acabamos de crear tres objetos de tipo Book diferentes. Observa cómo se usa la palabra new delante del nombre de la clase y como, al crear cada libro, debemos pasar su título como parámetro. Esto es así porque el constructor de la clase tenía un parámetro, el título del libro. Ahora podemos usar los métodos de esos objetos, y cada uno actuará sobre su propio conjunto de atributos. Por ejemplo: . book1.getTitle(); book2.getTitle(); book3.getTitle(); . Este código provocará la ejecución de tres alerts consecutivos, que nos mostrarán, uno tras otro, los títulos de nuestros tres libros. (Nota: por convenio, el nombre de la clase suele escribirse con mayúscula inicial, mientras que el nombre de los atributos, métodos y objetos individuales se escribe empezando en minúsculas). 10.2.4. Herencia en Javascript . (Nuevamente, nos referiremos a cómo se maneja la herencia en las versiones recientes de Javascript (EC6 o posterior). ¡Asegúrate de tener tu navegador web actualizado!) . Cuando se crea una clase, se puede hacer desde cero o bien se puede basar en otra clase preexistente. En este segundo caso, la nueva clase hereda los atributos y los métodos de la clase-madre o superclase, a los que puede añadir sus propios atributos y métodos. Esto permite reutilizar grandes cantidades de código de forma bien organizada y sin necesidad de volver a escribirlo. Lo vamos a entender mejor con otro ejemplo. Vamos a crear una clase nueva, en esta ocasión llamada Person. Tendrá dos atributos (name y age) y un método (getName()), además del constructor: . class Person { // Atributos name; age; // Método constructor constructor(firstname, lastname, age) { this.name = {firstname, lastname}; this.age = age; } // Otros métodos getName() { alert(\"Esta persona se llama: \" + this.name.firstname + \" \" + this.name.lastname); } } . En este caso, pasamos tres parámetros a la función constructora. Dos de ellos (firstname y lastname) los agrupamos dentro de un solo atributo (name). Por ese motivo, en el método getName() tenemos que acceder a cada uno de los elementos de name por separado. Podríamos haber utilizado dos atributos diferenciados, pero hemos preferido hacerlo así para darle un poco de variedad a los ejemplos y para que veas que el número de parámetros del constructor no tiene por qué coincidir con el número de atributos. Ahora, por supuesto, podemos crear todos los objetos que queramos a partir de la clase Person. Por ejemplo: . var person1 = new Person('Juan', 'Pérez', 25); var person2 = new Person('Ana', 'López', 37); . A continuación, podemos crear nuestras clases-hija o clases derivadas que hereden de Person. Observa detenidamente este código y enseguida entenderás cómo funciona la herencia: . class Student extends Person { // Atributos adicionales course; // Método constructor constructor(firstname, lastname, age, course) { super(firstname, lastname, age); this.course = course; } // Otros métodos getCourse() { alert(\"Este estudiante está matriculado en el curso: \" + this.course); } } class Teacher extends Person { // Atributos adcicionales speciality; // Método constructor constructor(firstname, lastname, age, speciality) { super(firstname, lastname, age); this.speciality = speciality; } // Otros métodos getSpeciality() { alert(\"La especialidad de este profesor/a es: \" + this.speciality); } } . ¿No es cierto que los estudiantes y los profesores suelen ser personas (en la mayoría de los casos, al menos)? Pues bien, aquí hemos definido dos nuevas clases llamadas Student y Teacher. Pero no las hemos definido completamente, sino que hemos reutilizado la clase Person. Y lo hemos hecho indicando que tanto Student como Teacher heredan de la clase Person. Esto se indica con la palabra extends en la declaración de la clase. Es decir, que las dos nuevas clases heredan todo el contenido de su clase-madre. Luego, simplemente, hemos añadido los nuevos atributos y nuevos métodos que existen en esas clases pero no tienen sentido en la clase-madre. Observa bien los constructores de Student y Teacher. Ahí encontrarás la palabra super. En el siguiente apartado veremos lo que significa. El resto del código es bastante trivial. Ahora podemos hacer algo como esto y funcionará: . var person1 = new Person('Juan', 'Pérez', 25); var person2 = new Student('Ana', 'López', 16, '1º bachillerato A'); var person3 = new Teacher('Laura', 'Sánchez', 42, 'Matemáticas'); . Acabamos de crear tres personas diferentes. La primera es una persona genérica, la segunda es una estudiante (y tiene un atributo y un método extra del que carecen las personas genéricas) y la tercera es una profesora (con su propio atributo y método extra). (Por supuesto, los estudiantes y los profesores podrían tener más atributos y métodos adicionales, no solo uno). Por lo tanto, los tres objetos tendrán un método getName(), pero solo el Student tendrá un método getCourse() y solo el Teacher tendrá un método getSpeciality(): . person1.getName(); // Funciona person2.getName(); // Funciona person3.getName(); // Funciona person1.getCourse(); // NO FUNCIONA. person1 no es un Student person2.getCourse(); // Funciona person3.getCourse(); // NO FUNCIONA. person3 no es un Student person1.getSpeciality(); // NO FUNCIONA. person1 no es un Teacher person2.getSpeciality(); // NO FUNCIONA. person2 no es un Teacher person3.getSpeciality(); // Funciona . 10.2.5. El objeto “super” . En los constructores de las clases Student y Teacher del apartado anterior hemos usado la palabra super. ¿Qué significa exactamente? . super es una referencia a la superclase. Por lo tanto, al escribir super(firstname, lastname, age), estamos invocando al constructor de la superclase Person. Esto es obligatorio hacerlo en todos los constructores de las clases derivadas. Del mismo modo, si escribiéramos algo como super.getName(), estaríamos invocando al método getName() de la clase madre, no de la clase actual. Esto, por supuesto, no es obligatorio, y solo lo haremos si realmente nuestro código lo necesita. 10.2.6. Algunos aspectos avanzados . Como ves, la programación orientada a objetos no es más que una manera particular de organizar el código fuente en clases que se ha revelado muy útil a la hora de minimizar el tiempo y el esfuerzo para construir y mantener proyectos grandes. La programación orientada a objetos tiene otras características más avanzadas que vamos a describir muy brevemente, no porque sean complicadas de entender o de usar, sino porque solo tienen sentido cuando trabajas en proyectos muy grandes y con un conjunto de clases muy elaborado. Como de momento solo estamos aprendiendo, aún no necesitamos profundizar en ello. Ya lo harás cuando llegue tu momento y te lo pida el cuerpo. Lo que sí es importante es que estos conceptos te suenen para que puedas buscar información cuando lo necesites. | Clases abstractas: son clases de las que no se pueden crear objetos. ¿Entonces para qué sirven?, te preguntarás. Muy sencillo: para hacer herencia a partir de ellas. Normalmente, las clases abstractas son clases muy genéricas de las que no tiene sentido crear un objeto, porque ese objeto apenas sería funcional. La clase abstracta se limita a proporcionar un conjunto de atributos y métodos que heredan todas las clases-hija. | Herencia múltiple: ocurre cuando una clase hereda de varias clases-madre a la vez. Proporciona una enorme flexibilidad a la hora de diseñar nuestra arquitectura de clases, pero también provoca no pocos problemas. Muchos lenguajes, entre ellos Javascript, no la permiten. Otros, como C++ o Python, sí. | Visibilidad: los métodos y atributos de los objetos se pueden hacer públicos o privados. Si son públicos, quiere decir que pueden usarse desde cualquier lugar del código fuente. Si son privados, quiere decir que solo pueden usarse desde el código escrito dentro de la propia clase. Esto se hace para que el objeto funcione como una caja negra, cuyas “tripas” sean invisibles al exterior. Generalmente, los atributos de una clase suelen hacerse privados, mientras que la mayor parte de los métodos suelen ser públicos, pero puede haber tantas excepciones a esta regla que sería imposible enumerarlas. | Sobrecarga. Sobrecargar un método consiste en crear varias versiones del mismo que se diferencian por el número de parámetros. Puede llegar a ser muy útil en programas muy grandes con jerarquías de clases muy complejas. | Polimorfismo. Se llama polimorfismo a la capacidad de los lenguajes orientados a objetos de que existan varias versiones diferentes de un mismo elemento (métodos, generalmente) que se nombran del mismo modo pero se comportan de modo diferente. Probablemente sigues sin entender qué narices significa la frase anterior aunque la hayas leído varias veces, ¿verdad? . Tranquilidad, porque a todo el mundo le ocurre la primera vez que le mencionan el término polimorfismo. Te lo explico con un ejemplo, pero tampoco te preocupes demasiado: no es algo que vayas a usar hasta dentro de muuucho tiempo. Imagina que tenemos una superclase llamada Person con sus clases derivadas como Student o Teacher. Es decir, como en los ejemplos anteriores. Hasta aquí, bien. Ahora sigue imaginando que tienes un método, el que sea, en la clase Person. Por ejemplo, getProfession(). Todos los objetos de tipo Student o Teacher heredarán el método getProfession(). Ahora bien, ¿tiene sentido que ese método sea el mismo para Student que para Teacher? Probablemente no. ¡Para empezar, el estudiante ni siquiera tiene profesión (aún)! . Una cosa muy interesante que pueden hacer las clases-hija es sobreescribir los métodos, es decir, coger un método heredado y cambiar su código fuente. Así, puedes tener diferentes versiones del método getProfession(), una para cada clase de la jerarquía. Y ya lo tienes. Eso es una manifestación del polimorfismo: tener un método (getProfession()) con diferentes formas o implementaciones. Según cuál sea el objeto con el que lo llames, se ejecutará una versión u otra del método. Esto puede parecer una chorrada, pero con jerarquías de clases muy complejas ayuda a resolver situaciones muy chungas. Por ejemplo: ¿qué pasa si un profesor es, a su vez, estudiante en algún curso? Según el papel de esa persona en cada momento, habrá que ejecutar una versión diferente de getProfession(). Si has llegado hasta aquí en esta explicación, puedes volver a leer la definición de polimorfismo y seguramente sí la entenderás. | . 10.2.7. Objetos predefinidos de Javascript . Ahora que ya conoces un poco sobre la programación orientada a objetos y cómo trabajar con ella en Javascript, puedo confesarte un secreto: has estado utilizando objetos desde el primer momento en el que empezaste a trabajar con Javascript. Así es. Como Javascript es un lenguaje orientado a objetos, hay un montón de objetos predefinidos que existen en todos los programas Javascript para que los uses si los necesitas. Por ejemplo, cuando hacías Math.rand(), estabas invocando al método rand() del objeto Math. Este objeto es un poco especial, porque no necesitas crear una instancia. Es decir, no necesitas hacer var math = new Math() para usarlo. Con algunas clases ocurre esto, y se llaman clases estáticas. Otro objeto predefinido que seguro que has utilizado sin saber que lo era es el objeto window. En este caso, es un objeto normal, no estático, pero no tenemos que crearlo con var window = new Window() porque Javascript lo crea automáticamente para nosotros cada vez que abrimos una ventana del navegador web. De hecho, los métodos alert() o confirm() son, en realidad, métodos del objeto window. Es decir, podemos escribir window.alert() o window.confirm(), y funcionarían exactamente igual. Lo que ocurre es que, si no indicamos un objeto delante del nombre del método, Javascript interpretará que se trata de un método del objeto window. Y así hay otro buen puñado de objetos predefinidos cuya existencia te conviene conocer. Algunos de ellos son: . | Math: contiene un montón de métodos para operaciones matemáticas. | window: métodos y atributos para manejar la ventana del navegador donde se ejecuta la aplicación. | Date: para trabajar con fechas y horas. | Number: operaciones relacionadas con números. | String: para trabajar con cadenas de caracteres. | Array: para trabajar con arrays. | JSON: para trabajar con datos complejos codificados como JSON, un formato de intercambio de información muy utilizado con Javascript y otros lenguajes. | Error: para manipular los errores de ejecución y obtener información sobre ellos. | . ",
    "url": "https://iescelia.org//docs/tico/_site/orientacion-a-objetos-c++/#102-los-objetos-en-javascript",
    "relUrl": "/orientacion-a-objetos-c++/#102-los-objetos-en-javascript"
  },"97": {
    "doc": "10. Orientación a objetos con C++",
    "title": "10.3. Un ejemplo completo",
    "content": "Vamos a terminar esta pequeña introducción a la programación orientada a objetos mostrando un ejemplo completo desarrollado con Javascript. Puedes considerarlo un ejercicio resuelto. Es decir: primero puedes intentar hacerlo tú, y luego comparar tu intento con mi solución. No es necesario que tu solución y la mía sean idénticas, desde luego, puesto que siempre hay varias formas correctas de hacer lo mismo. Lo que queremos hacer . Este es un ejemplo clásico para practicar la herencia entre clases, porque resulta fácil de entender y de programar. Se trata de escribir un programa que sea capaz de calcular ciertas magnitudes, como el área y el perímetro, de muchos tipos diferentes de figuras geométricas. Empezaremos por círculos, cuadrados y rectángulos, pero podríamos extender el programa con facilidad para abarcar otras figuras. Observa el diagrama de aquí abajo. Se trata de un diagrama de clases, una representación gráfica de las clases que existen en un programa y cómo heredan unas de otras. No te asustes: es sencillo leer un diagrama de clases. Más abajo te doy algunas pistas. Cada “caja” de este diatrama es una clase, y en cada clase se indica su nombre, sus atributos y sus métodos. Delante de cada atributo y método verás un símbolo: + significa que ese atributo o método es público, es decir, accesible desde otras clases, y - significa que es privado, accesible solo desde la propia clase. Si no se indica lo contrario, Javascript considerará que los atributos y métodos son públicos. Es decir, todos los atributos y métodos que hemos usado hasta ahora son públicos. En sistemas complejos, es importante distinguir los atributos y métodos públicos de los privados. Además, el diagrama expresa cómo heredan las clases unas de otras. La clase Figura es la madre de toda la jerarquía, también llamada superclase. Las clases Círculo y Rectángulo son hijas de Figura, es decir, subclases o clases derivadas. Por último, la clase Cuadrado es subclase de Rectángulo. Por supuesto, podíamos haber añadido más figuras, pero con estas ya tienes entretenimiento para un rato. Observa, por cierto, como Cuadrado hereda de Rectángulo, y no directamente de Figura. El programa que vamos a escribir tiene que incluir lo siguiente: . | La superclase Figura (figura geométrica), que contendrá: . | Dos atributos: color (String) y relleno (boolean). | Un constructor que recibirá dos argumentos para inicializar los atributos. | Getters y setters, es decir, métodos para consultar el valor de los atributos (getColor() y getRelleno()) y para establecer el valor de los atributos (setColor() y setRelleno()). Entiendes por qué se llaman getters y setters, ¿verdad? | Un método toString() que devolverá la cadena: “Soy una figura de color xxx y rellena/no rellena”, según lo que valgan los atributos en ese momento. | . | Una subclase de Figura llamada Círculo. La clase Círculo contendrá: . | Un atributo llamado radio (un número real). | Un constructor, como se ve en el diagrama de clases. | Getter y setter para el radio. | Los métodos getArea() y getPerimetro(). Si no recuerdas como calcular el área y el perímetro (o circunferencia) de un círculo… bueno, ¿para qué está la wikipedia? | El método toString() heredado de Figura se debe sobreescribir. Ahora, el método devolverá: “Soy un círculo con radio = x, esta es mi superclase: yyy”, donde yyy es la salida del método toString() de la superclase de Figura. | . | Una subclase de Figura llamada Rectángulo. La clase Rectángulo se comportará igual que Círculo, con las lógicas diferencias en atributos y métodos getters y setters. Mira el diagrama de clases si tienes alguna duda. | Una subclase de Rectángulo llamada Cuadrado. Esta clase podía haberse modelado como subclase de Figura, pero es más cómodo hacerlo como subclase de Rectángulo, porque podemos aprovechar casi todo el código de su superclase. Basta con crear el siguiente constructor: . class Cuadrado { constructor(side) { super(side, side); // Llama al constructor de la superclase Rectangulo } } . | Además de crear el constructor, sobreescribiremos, como en los otros casos, el método toString(). | Atención, pregunta: ¿necesitarás sobreescribir getArea() y getPerimetro(), o funcionarán tal y como han sido heredados de Rectángulo? Haz la prueba a ver qué pasa… | También sobreescribiremos los métodos setAlto() y setAncho() para evitar que el largo y el ancho del cuadrado puedan tener dimensiones diferentes. | . | Finalmente, tendremos que escribir un fragmento de código para testear que todo lo anterior funcione, creando unas cuantas figuras de cada tipo y llamando a algunos métodos. | . Nuestra implementación . En la implementación de la clase Figura vamos a usar comentarios en formato javadoc. Es una manera de escribir los comentarios que te vas a encontrar a menudo por ahí, puesto que se trata de un estándar de la industria. El resto de clases son tan sencillas que nos hemos ahorrado los comentarios para no complicar innecesariamente el código fuente. Como en otras ocasiones, tu trabajo aquí es intentar resolver el ejercicio antes de ver la solución. Y, una vez que empieces a leer la solución, hacerlo poco a poco y sin prisas. &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Jerarquía de figuras geométricas&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; /** * Clase Figura (figura geométrica genérica) */ class Figura { color; // Atributos relleno; /** * Constructor con parámetros. * * @param c El color de la figura. * @param r Indica si la figura está rellena o no. */ constructor(c, r) { this.color = c; this.relleno = r; } /** * Determina el color de la figura. * * @return El color de la figura. */ getColor() { return this.color; } /** * Establece el color de la figura. * * @param c El color de la figura. */ setColor(c) { this.color = c; } /** * Determina si la figura está o no rellena. * * @return True si la figura está rellena, false si no está. */ estaRelleno() { return this.relleno; } /** * Cambia el valor del relleno de la figura. * * @param r True para que la figura pase a estar rellena, * false para que no lo esté. */ setRelleno(r) { this.relleno = r; } /** * Devuelve una cadena descriptiva del objeto actual. * @return La cadena con la descripción del objeto. */ toString() { var s = \"Soy una figura de color \" + this.color + \" y \"; if (this.relleno) s = s + \"estoy rellena\"; else s = s + \"no estoy rellena\"; return s; } } class Circulo extends Figura { radio; // Atributo constructor(color, relleno, r) { super(color, relleno); this.radio = r; } getRadio() { return this.radio; } setRadio(r) { this.radio = r; } getArea() { return Math.PI * this.radio * this.radio; } getPerimetro() { return 2 * Math.PI * this.radio; } toString() { return \"Soy un círculo de radio \" + this.radio + \" y esta es mi superclase: \" + super.toString(); } } class Rectangulo extends Figura { ancho; // Atributos alto; constructor(color, relleno, an, al) { super(color, relleno); this.ancho = an; this.alto = al; } getAncho() { return this.ancho; } setAncho(an) { this.ancho = an; } getAlto() { return this.alto; } setAlto(al) { this.alto = al; } getArea() { return this.ancho * this.alto; } getPerimetro() { return 2 * this.ancho + 2 * this.alto; } toString() { return \"Soy un rectángulo de base \" + this.ancho + \" y altura \" + this.alto + \" y esta es mi superclase: \" + super.toString(); } } class Cuadrado extends Rectangulo { constructor(color, relleno, lado) { super(lado, lado, color, relleno); } setAncho(a) { super.setAncho(a); super.setAlto(a); } setAlto(a) { super.setAncho(a); super.setAlto(a); } toString() { return \"Soy un cuadrado de lado \" + super.getAncho() + \" y esta es mi superclase: \" + super.toString(); } } // -------------------------------------------------------------------------------- // El siguiente código sirve para TESTEAR la jerarquía de clases // -------------------------------------------------------------------------------- // Primero, vamos a crear una figura con cada constructor y a llamar a toString() var fig1 = new Figura(\"rojo\", true); alert(fig1.toString()); var circulo1 = new Circulo(\"azul\", true, 1.5); alert(circulo1.toString()); var rect1 = new Rectangulo(\"amarillo\", false, 8.3, 2.4); alert(rect1.toString()); var cuadrado1 = new Cuadrado(\"verde\", true, 3.1); alert(cuadrado1.toString()); // Probamos ahora algunos métodos sobre los objetos anteriores // y volvemos a llamar a toString() para comprobar que // los atributos han cambiado como se esperaba. fig1.setColor(\"blanco\"); alert(fig1.toString()); circulo1.setRadio(2.5); alert(\"El área del círculo es \" + circulo1.getArea()); alert(circulo1.toString()); rect1.setAlto(3.0); alert(\"El perímetro del rectángulo es \" + rect1.getPerimetro()); alert(rect1.toString()); cuadrado1.setAncho(5.1); alert(\"La base del cuadrado es \" + cuadrado1.getAlto() + \" y su altura es \" + cuadrado1.getAncho()); alert(\"El área del cuadrado es \" + cuadrado1.getArea()); alert(cuadrado1.toString()); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; . ",
    "url": "https://iescelia.org//docs/tico/_site/orientacion-a-objetos-c++/#103-un-ejemplo-completo",
    "relUrl": "/orientacion-a-objetos-c++/#103-un-ejemplo-completo"
  },"98": {
    "doc": "X. Seguridad y privacidad",
    "title": "9. Seguridad y privacidad",
    "content": "Seguridad y privacidad. Acceso a la información de las bases de datos. ",
    "url": "https://iescelia.org//docs/tico/_site/seguridad-y-privacidad/#9-seguridad-y-privacidad",
    "relUrl": "/seguridad-y-privacidad/#9-seguridad-y-privacidad"
  },"99": {
    "doc": "X. Seguridad y privacidad",
    "title": "X. Seguridad y privacidad",
    "content": " ",
    "url": "https://iescelia.org//docs/tico/_site/seguridad-y-privacidad/",
    "relUrl": "/seguridad-y-privacidad/"
  },"100": {
    "doc": "3. Tecnologías de impresión 3D",
    "title": "3. Tecnologías de impresión 3D",
    "content": ". | 3.1. Tecnologías de impresión 3D . | 3.1.1. Un poco de historia | 3.1.2. Cómo funciona la impresión 3D | 3.1.3. Métodos de impresión 3D | 3.1.4. Materiales | 3.1.5. Aplicaciones de la impresión en 3D | 3.1.6. El futuro de la impresión 3D | . | 3.2. Modelado y diseño diseño 3D . | 3.2.1. En qué consiste el diseño 3D | 3.2.2. Breve historia del diseño 3D | 3.2.3. Programas de diseño 3D | 3.2.4. Formatos de archivo | . | 3.3. Impresión 3D por FDM | 3.4. Actividades propuestas | . Estamos acostumbrados a la impresión 2D, ¿verdad? Desde hace décadas las impresoras 2D imprimen en papel a un precio asequible y con multitud de técnicas: láser, inyección de tinta, matricial, térmica, etc. En la segunda década del siglo XXI, la impresión 3D asequible también se convirtió en una realidad. Sin embargo, todavía es un mundo bastante desconocido para muchas personas. En este capítulo vamos a recorrer la historia de las impresoras 3D, en qué consiste este tipo de impresión y cómo funciona, los tipos de impresoras que existen y cómo podemos iniciarnos en este mundillo. ",
    "url": "https://iescelia.org//docs/tico/_site/tecnologias-de-impresion-3d/",
    "relUrl": "/tecnologias-de-impresion-3d/"
  },"101": {
    "doc": "3. Tecnologías de impresión 3D",
    "title": "3.1. Tecnologías de impresión 3D",
    "content": "La impresión 3D se refiere a un un grupo de tecnologías de fabricación capaces de crear objeto tridimensionales mediante la superposición de capas sucesivas de un determinado material. Por lo tanto, con estas técnicas se pueden crear objetos físicos a partir de un modelo digital. 3.1.1. Un poco de historia . Aunque nos puede parecer una tecnología moderna, en el año 1976 ya se desarrollaron los primeros equipos y materiales de construcción para la impresión en 3D. Unos años después, en 1981, Hideo Kodama, uno de los precursores de la impresión 3D, inventó dos métodos de fabricación de un modelo tridimensional con un polímero plástico que se endurecía al darle la luz. Hideo Kodama y sus primeros diseños de impresora 3D de los años 70. En 1984 se patentaron varias tecnologías basadas en un proceso llamado estereolitografía, que se basa en ir añadiendo capas mediante polímeros plásticos que se endurecían al aplicarles radiación ultravioleta. Además, se definió un sistema para generar objetos tridimensionales mediante la creación de un patrón del objeto que dio lugar al formato de archivo STL, que es ampliamente aceptado hoy en día para la impresión 3D. En el año 1992 se desarrolló la primera máquina de impresión 3D de tipo SLA (tecnología estereolotigráfica), obra de la compañía 3D Systems. Un láser ultravioleta iba solidificando un polímero capa por capa para crear objetos tridimensionales. A pesar de que no eran piezas muy perfectas, hacía pensar en el gran potencial que podía ofrecer este tipo de máquinas. Aspecto de la primera impresora 3D por SLA, del año 1992. Siete años después, en 1999, hubo bastante revuelo cuando el equipo de investigación del Instituto de Wake Forest de Medicina Regenerativa (Carolina del Norte, EEUU) presentó la primera impresora 3D capaz de crear tejido orgánico. Esto abrió otro campo de aplicación de la tecnología de impresión 3D del que se esperan grandes resultados en los próximos años. En 2006 se construyó la primera impresora de tipo SLS o de sintetización de láser selectivo. Esta tecnología utiliza un láser para fundir materiales durante el proceso de impresión 3D. Representó una gran esperanza en la fabricación de piezas industriales, prótesis, etc. Un par de años más tarde, a través de un proyecto llamado RepRap, vió la luz la primera impresora capaz de replicar sus propios componentes, lo que permitía construir impresoras idénticas, piezas de repuesto o impresoras autorreparables. En el año 2011, los ingenieros de la Universidad de Shouthampton diseñaron un avión no tripulado impreso en 3D y fabricado en tan solo una semana. En ese mismo año, se pudo ver también el primer prototipo de un coche cuya carrocería había sido creada a través de la impresión 3D. En los últimos años hemos visto aplicaciones múltiples de la impresión 3D: implantes dentales, prótesis de huesos, material sanitario, piezas industriales, joyas… Y también hemos asistido a un abataramiento progresivo de las impresoras y sus consumibles. 3.1.2. Cómo funciona la impresión 3D . El proceso de impresión 3D consiste en crear objetos en tres dimensiones a partir de la superposición de capas de abajo hacia arriba. La impresión 3D requiere de la cooperación de 3 elementos: . | Un software adecuado para crear los modelos 3D y controlar el proceso de impresión. | La propia impresora 3D. | Los consumibles o materiales utilizados durante el proceso de impresión. | . Antes de comenzar la impresión, el software de impresión divide el modelo 3D en capas tan finas como el diámetro del material que se vaya a emplear para imprimir. Para cada capa, la impresora se va desplazando sobre el plano para ir liberando material sobre las coordenadas correspondientes y así ir formando la figura en tres dimensiones. El material de impresión, una vez depositado, se endurece y adquiere su forma definitiva. Por lo tanto, lo primero que necesitamos para imprimir un objeto en tres dimensiones es un archivo creado con algún software de modelado 3D. Lo siguiente es utilizar el material más adecuado para su fabricación. Las impresoras más habituales en la actualidad utilizan materiales termoplásticos, es decir, filamentos de plástico que se ablandan con el calor para poder darle forma, y que vuelve a endurecerse al enfriarse. Sin embargo, también existen impresoras capaces de utilizar otros materiales como metal, resinas sintéticas u otros polímeros. Estas impresoras tienen un coste mayor puesto que deben ser capaces de fundir los materiales a mayor temperatura. Y, por último, está la propia impresora. Casi todas se parecen entre sí y la mayor diferencia se da en su tamaño, su velocidad y el tipo de material que pueden utilizar para imprimir los modelos 3D. Ejemplo de impresión 3D por SLA o estereolitografía 3.1.3. Métodos de impresión 3D . Aunque la mayoría de las impresoras actuales actúan fundiendo un material para ir creando las capas, hay algunas que depositan materiales líquidos que son solidificados con diferentes tecnologías, como la luz ultravioleta. Entre los métodos más utilizados en la impresión 3D tenemos: . | Modelado por deposición fundida (FDM): el material fundido, generalmente un termoplástico, se deposita en capas que se solidifican a temperatura ambiente. Son las impresoras más habituales en la actualidad. | Estereolitografía (SLA): se utilizan resinas líquidas que se solidifican con luz ultravioleta. Una luz láser va creando capas de resina sólida hasta formar el objeto. Los objetos así obtenidos suelen ser mucho más perfectos y duraderos que los que se obtienen con la tecnología FDM, aunque el coste de estas impresoras es considerablemente mayor. Por eso se usan más en la industria que en la impresión doméstica, aunque ya existen los primeros modelos de sobremesa. | Impresión por inyección: En este método, la impresora crea los objetos inyectando un líquido dentro de un molde, lo que permite crear objetos con gran precisión y rapidez y, además, mezclar materiales y colores. El molde se retira cuando el líquido se ha solidificado. Los propios moldes pueden fabricarse previamente con impresoras 3D de tipo SLA. | Fotopolimerización por luz ultravioleta: se utiliza un recipiente de polímero líquido que es expuesto a la luz de un proyector bajo determinadas condiciones. El polímero se endurece a medida que la placa de montaje se va moviendo hacia abajo muy poco a poco para ir creando las distintas capas. | Fotopolimerización por absorción de fotones (SLS): el objeto 3D es creado a partir de un bloque de gel que un láser va endureciendo selectivamente. Posteriormente, se retiran las partes de gel no endurecidas por el láser, y el resultado es el objeto 3D. | . Algunos tipos de impresora 3D 3.1.4. Materiales . Como hemos visto, se utilizan diferentes materiales según la tecnología de impresión. Cada material satisface una serie de propiedades (resistencia, precisión, conductividad, etc) y las piezas que se crean a partir de ellos tendrán diferentes usos. Los materiales más utilizados en la actualidad son: . | Ácido poliláctico (PLA): Se trata de un termoplástico con propiedades similares a las del tereftalato de polietileno (PET) que se utiliza habitualmente para hacer envases, solo que más fácil de colorear. | Tereftalato de polietileno (PET): el mismo plástico utilizado para envases de bebidas. Se trata de un plástico ligero, resistente y reutilizable indefinidamente. Su problema es que no admite muchas coloraciones. | Laywood: es similar al PLA, pero mezclado con madera en polvo en diferentes porcentajes para ofrecer un resultado con un aspecto similar a la madera y que se puede pintar y lijar fácilmente. | Acrilonitrilo butadieno estireno (ABS): un plástico muy resistente y que aguanta altas temperaturas. Ofrece cierta flexibilidad y es fácil de pintar. | Poliestireno de alto impacto (HIPS): es una variedad de los poliestireno (el clásico “corcho blanco”), muy ligero aunque bastante frágil. Se modifica mediante diversos aditivos para mejorar su resistencia o su elasticidad. | Elastómero termoplástico (TPE): otro termoplástico, en este caso dotado de una enorme elasticidad. | Laybrick: Se trata de un material que resulta de la mezcla de ciertos plásticos y yeso. Los objetos adquieren así un aspecto semejante a la piedra y se puedan pintar y lijar fácilmente. | Nylon: fibra textil sintética, muy elástica y resistente, utilizada para la fabricación y confección de tejidos y telas. | Metales amorfos (BGM): aleaciones metálicas cuya estructura atómica (denominada “amorfa” o desordenada) permite que sean fácilmente maleables antes de su solidificación. | . Algunos de los materiales disponibles en la actualidad para impresión 3D 3.1.5. Aplicaciones de la impresión en 3D . Las aplicaciones de la impresión 3D son múltiples y muy variadas gracias a las diferentes técnicas y materiales que se pueden utilizar en función del tipo de objeto, precisión de detalles y resistencia. Algunos de los ámbitos de aplicación de la impresión de objetos en tres dimensiones son: . | Medicina y salud: Ya se pueden crear ciertas prótesis con impresoras 3D (por ejemplo, en odontología). Muy pronto se fabricarán tejidos tolerables por el organismo. En el momento de escribir estas líneas, por ejemplo, la fabricación de piel sintética biocompatible está en fase de experimentación con animales. En un futuro no muy lejano se podrán recrear órganos humanos totalmente funcionales. También se puede fabricar material de uso médico con gran rapidez y facilidad. | Educación: se pueden crear modelos tridimensionales de conceptos abstractos o difícilmente disponibles para facilitar su estudio y comprensión: figuras geométricas, órganos, animales, piezas encajables, etc. | Industria: en el sector industrial, poder crear piezas para repuestos o para maquinaria nueva supone un gran ahorro de tiempo y de costes. | Arqueología: se pueden replicar objetos reales sin el complejo y laborioso proceso de modelado, reconstrucción, etc. | Moda: la industria de la moda también está aprovechando las ventajas de la impresión 3D para fabricar de forma rápida y sin apenas costes accesorios, calzado, complementos, bolsos, joyas o incluso prendas de ropa impresas en piezas que posteriormente se ensamblan entre sí. | Comida y alimentación: una de las aplicaciones más increíbles de la impresión 3D es la posibilidad de crear alimentos a partir de materiales comestibles y moldeables. Otro uso muy habitual es la fabricación de moldes en repostería. | Otros: la impresión 3D se puede aplicar en muchos otros ámbitos: fabricación de juguetes, réplica de antigüedades, jardinería, realización de maquetas para arquitectura, cine o televisión, creación de armamento (sí, sí: lo has leído bien; las armas creadas con impresoras 3D ya son un problema de seguridad pública)… Muchas de sus aplicaciones ni siquiera las hemos imaginado todavía. | . La realización rápida, barata y precisa de maquetas es un ejemplo de aplicación práctica de de las impresoras 3D 3.1.6. El futuro de la impresión 3D . La impresión 3D ha evolucionado mucho en los últimos años y ya ha quedado clara la infinidad de posibilidades que ofrece. Se espera que en el futuro cercano cobre aún mayor protagonismo. Las aplicaciones futuras de las impresoras 3D que probablemente más van a revolucionar el mundo son: . | La creación de órganos humanos artificiales: corazones y riñones impresos serán casi con total seguridad los primeros en trasplantarse con éxito a seres humanos. | Fabricación de viviendas a medida, impresas en piezas que luego se ensamblarán, con propiedades térmicas y acústicas nunca vistas hasta ahora, y con unos tiempo de construcción de días en lugar de meses o años. | Creación de alimentos nuevos, nutricionalmente equilibrados, económicos y sostenibles desde el punto de vista ambiental. | . Objetos 3D comestibles creados con una impresora ",
    "url": "https://iescelia.org//docs/tico/_site/tecnologias-de-impresion-3d/#31-tecnolog%C3%ADas-de-impresi%C3%B3n-3d",
    "relUrl": "/tecnologias-de-impresion-3d/#31-tecnologías-de-impresión-3d"
  },"102": {
    "doc": "3. Tecnologías de impresión 3D",
    "title": "3.2. Modelado y diseño diseño 3D",
    "content": "Para imprimir cualquier cosa en 3D, primero hay que diseñarla y modelarla con el software adecuado. El modelado y diseño 3D se ha convertido en unas de las tendencias con más fuerza en el campo del diseño en las últimas décadas, no solo por las impresoras 3D. Se trata de un ámbito el diseño que cuenta con gran versatilidad y posibilidades infinitas en muchísimos campos, como la arquitectura, la ingeniería o la industria del entretenimiento. En este apartado vamos a conocer algo más sobre el diseño y modelado 3D. 3.2.1. En qué consiste el diseño 3D . El diseño y modelado 3D es una manera de recrear objetos trimensionales en la pantalla plana del ordenador. Estos objetos se crean, generalmente, mediante la unión de muchos polígonos de pequeño tamaño entre sí, constituyendo lo que se denomina una malla tridimensional. Los polígonos son lo suficientemente pequeños como para que no se aprecie su existencia y, además, el software 3D es capaz de suavizar la conexión entre ellos. Ejemplo de modelo de malla creado con Blender A los polígonos se les aplica una textura para simular materiales, y los modelos pueden ser mejorados mediante la iluminación y otros efectos específicos, como el movimiento del agua o la simulación de fenómenos atmosféricos. El modelo anterior, texturizado Los modelos se pueden rotar, escalar y, en general, manipular muy fácilmente con el software adecuado. También se pueden animar (para la industria del cine, de la publicidad o de los videojuegos), renderizar (para crear imágenes fotorrealistas) o exportar a diferentes formatos (para, por ejemplo, imprimirlos en una impresora 3D). 3.2.2. Breve historia del diseño 3D . Ya en la década de 1960 se crearon los primeros sistemas de Diseño Asistido por Computadora (CAD). Patrick Hanratty, conocido mundialmente conocido como “el Padre del CAD”, ideó el primer sistema CAD, llamado PRONTO, ni más ni menos que en 1957. PRONTO, el primer sistema CAD de la historia En los años 70 aparecieron varios sistemas de diseño y dibujo automatizado, sobre todo orientado al 2D, pero no fue hasta los años 80, con la popularización del ordenador personal, que se popularizaron los programas de diseño 2D entre el público en general. El más popular de todos fue, sin duda, AutoCAD, cuya primera versión salió al mercado en 1982. AutoCAD sigue siendo hoy la aplicación de referencia en arquitectura y delineación. AutoCAD en su versión 1 (año 1982) y en una versión reciente Ya en los años 90 se generalizaron los programas de diseño 3D, como 3D Studio o Maya. La industria del cine, a partir de la aparición del estudio Pixar y su gran éxito de 1995, Toy Story, los hizo mejorar rápidamente, y esas mejoras llegaron muy pronto al mercado de la informática personal. En la actualidad, existe una enorme variedad de herramientas de diseño 2D y 3D, tanto libres como propietarias, algunas online y otras instalables en nuestros ordenadores o smartphones, algunas muy simples y otras tremendamente complejas y orientadas al mercado profesional. Blender es el software libre para modelado y animación 3D más popular y más completo del mercado 3.2.3. Programas de diseño 3D . Aunque, como hemos dicho, hay muchos programas de modelado y diseño 3D, estos son algunos de los más importantes: . | Maya. Creado por Autodesk (los creadores de AutoCAD), es un programa animación, renderizado y simulación. También puede hacer modelado 3D, aunque no es su fuerte. Se utiliza en el desarrollo de videojuegos, películas de animación y efectos visuales para cine, televisión y publicidad. | 3DS MAX. También conocido como 3D Studio Max, es la apuesta de Autodesk para hacer modelado 3D. | Blender. Un software libre nacido para competir con Maya y 3DS. Aunque al principio resultaba más limitado, en la actualidad sus prestaciones no tienen nada que envidiar a sus hermanos propietarios. Es una herramienta todo-en-uno: permite hacer modelado 2D y 3D, animación, renderizado y simulación. Es altamente configurable y se puede programar en Python. Funciona en cualquier plataforma (Windows, MAC o Linux). | Sketchup. Es otro programa de modelado 2D y 3D muy popular, utilizado sobre todo en el ámbito de diseño de interiores, diseño industrial y arquitectura. | Solidworks. Es un software de diseño 3D bastante popular, sobre todo en el ámbito educativo, aunque también tiene aplicaciones profesionales. Es propietario y solo corre bajo sistemas Windows. | TinkerCAD. Un herramienta online de Autodesk para hacer modelos 3D y descargarlos. Su uso es gratuito y, aunque es más limitada que los otros programas, el hecho de que esté disponible online, sin necesidad de instalar ningún programa adicional en nuestro ordenador, la hace muy interesante. | . Pero modelo creado con estos programas no puede imprimirse directamente: antes hay que dividirlo en capas (slices) con un software específico, como Makerware, Cura o Repetier. Estos programas nos dejarán especificar ciertos parámetros de la impresión, como la altura de cada capa. A menor altura, más precisa (aunque más lenta) resultará la impresión. 3.2.4. Formatos de archivo . Los modelos 3D creados con cualquiera de estos programas (o muchos otros que existen en el mercado) pueden manejar muchos formatos, pero en impresión 3D suele usarse el formato STL. La mayoría de las impresoras admitirán modelos 3D almacenados con este formato. Cuando el modelo 3D está fragmentado en capas, ya lo tenemos listo para pasarlo a nuestra impresora. La mayoría de ellas cuentan con un puerto USB para poder insertar una memoria Flash o un disco duro externo donde debemos llevar guardado el modelo que queremos imprimir. Algunos modelos más avanzados también disponen de una conexión de red. ",
    "url": "https://iescelia.org//docs/tico/_site/tecnologias-de-impresion-3d/#32-modelado-y-dise%C3%B1o-dise%C3%B1o-3d",
    "relUrl": "/tecnologias-de-impresion-3d/#32-modelado-y-diseño-diseño-3d"
  },"103": {
    "doc": "3. Tecnologías de impresión 3D",
    "title": "3.3. Impresión 3D por FDM",
    "content": "Las impresoras 3D por FDM son sin duda las impresoras de 3D más extendidas en la actualidad, ya que son relativamente sencillas de construir y baratas de adquirir. FDM, por cierto, significa modelado por deposición fundida (o fused deposition modeling en inglés). Las impresoras FDM basan en 4 elementos principales: . | Una placa (también llamada cama) de impresión en la que se imprime la pieza. | Una bobina de filamento termoplástico que sirve como material de impresión | Una cabeza de extrusión también llamada extrusor. | Un bastidor donde descansa el extrusor y que le permite moverse en los 3 ejes del espacio (X, Y, Z). | . Partes de una impresora 3D por FDM El filamento es succionado lentamente por el extrusor, que lo calienta, lo derrite y lo deposita de forma precisa sobre la cama de impresión. El extrusor se puede mover sobre la cama en cualquiera de los 3 ejes del espacio, y va ascendiendo poco a poco conforme avanza la impresión, para depositar así cada capa del modelo. La velocidad de impresión puede ajustarse en la mayoría de las impresoras. Si el modelo 3D es muy complejo, tendremos que usar una velocidad baja para que se imprima correctamente, con lo que la impresión puede demorarse varias horas. En cambio, un modelo 3D sencillo puede imprimirse a alta velocidad y estar listo en minutos. La impresión 3D comienza cuando la máquina alcanza una temperatura alrededor de los 200°C, necesaria para la fusión del material termoplástico. Entre los materiales de impresión 3D más populares en las impresoras FDM se encuentran el PLA (ácido poliacético) y el ABS (Acrilonitrilo butadieno estireno). Son plásticos baratos y resistentes, que funden a temperaturas relativamente bajas (unos 200º C) y que se pueden encontrar en bobinas de muchos colores en el mercado. El modelo no debe moverse ni un milímetro durante la impresión, o acabará saliendo un monstruo deforme. Para lograrlo, es habitual impregnar la cama con alguna sustancia levemente pegajosa (un poco de laca para el pelo suele dar buen resultado). Algunos modelos, por su forma, pueden necesitar soportes específicos para no caerse o desplazarse mientras se imprimen. Estos soportes pueden estar hechos del mismo material que el objeto impreso, con lo cual quedarán adheridos a él, o de un material que sea soluble en agua para poder retirarlos posteriormente sumergiendo la pieza en agua. Obviamente, el tamaño máximo del objeto que se puede imprimir con una de estas impresoras depende del tamaño de la cama y del tamaño del bastidor donde va colocado el extrusor. A mayor tamaño, mayor es el precio de la impresora. Algunas impresoras 3D domésticas de gama alta están equipadas con varios extrusores para combinar varios colores o materiales. Una impresora 3D por FDM trabajando ",
    "url": "https://iescelia.org//docs/tico/_site/tecnologias-de-impresion-3d/#33-impresi%C3%B3n-3d-por-fdm",
    "relUrl": "/tecnologias-de-impresion-3d/#33-impresión-3d-por-fdm"
  },"104": {
    "doc": "3. Tecnologías de impresión 3D",
    "title": "3.4. Actividades propuestas",
    "content": "Ejercicio 1. Busca tres aplicaciones de las impresoras 3D (presentes o futuras) que te parezcan sorprendentes y que no se hayan mencionado en este tema. Ejercicio 2. Busca los precios actuales de los tipos principales de impresora 3D. Para cada tipo de impresora, busca al menos tres modelos: uno de gama baja, otro de gama media y otro de gama alta. Elabora una tabla comparativa. ¿Qué tipo de impresora es, en promedio, más asequible? ¿Y cuáles son las más caras? . Ejercicio 3. No todo lo que rodea a las impresoras 3D son buenas noticias. Cada vez que los seres humanos inventamos una nueva tecnología, a alguien se le ocurre utilizarla de manera poco recomendable. Lee este artículo y trata de imaginar otros peligros que pueden suponer, en el presente y en el futuro, las impresoras 3D. Ejercicio 4. En el tema hemos mencionado los paquetes de software de modelado 3D más importantes, como Maya, Blender o 3DS Max. Busca en internet información acerca de qué software utiliza la industria del entretenimiento (cine, televisión, publicidad, videojuegos…) para hacer los modelos y animaciones 3D que vemos a diario. Ejercicio OBLIGATORIO. En Moodle encontrarás un Wiki colaborativo sobre los distintos tipos de impresora que existen. Agrupados en parejas, tenéis que investigar uno de los tipos de impresora siguiendo las pautas que se indican en el propio Wiki. ",
    "url": "https://iescelia.org//docs/tico/_site/tecnologias-de-impresion-3d/#34-actividades-propuestas",
    "relUrl": "/tecnologias-de-impresion-3d/#34-actividades-propuestas"
  },"105": {
    "doc": "About",
    "title": "About",
    "content": "Estos apuntes han sido elaborados por Antonio Zapata Sierra y Alfredo Moreno Vozmediano, del Departamento de Informática del IES Celia Viñas de Almería, y se publican aquí con licencia CC BY 4.0, lo que quiere decir que eres libre de usar este material, copiarlo, distribuirlo y modificarlo siempre que el resultado de todo eso mantenga la misma licencia y cites la autoría original. Algunos fragmentos (pocos) están tomados y adaptados de otras fuentes. Cuando eso ocurre, lo indicamos claramente en el texto. Debes atenerte a la licencia de los sitios web de origen para esos fragmentos. ",
    "url": "https://iescelia.org//docs/tico/_site/about/",
    "relUrl": "/about/"
  },"106": {
    "doc": "Tecnologías de la Información y la Comunicación 2º BACHILLERATO",
    "title": "Tecnologías de la Información y la Comunicación 2º BACHILLERATO",
    "content": "Esta es la documentación (apuntes) de Tecnologías de la Información y la Comunicación II, optativa de 2º de Bachillerato impartida en el IES Celia Viñas de Almería (España). ",
    "url": "https://iescelia.org//docs/tico/_site/",
    "relUrl": "/"
  }
}
