I"÷<h2 class="no_toc" id="92-introducci√≥n-a-c">9.2. Introducci√≥n a C</h2>

<ul id="markdown-toc">
  <li><a href="#921--caracter√≠sticas-b√°sicas-de-c" id="markdown-toc-921--caracter√≠sticas-b√°sicas-de-c">9.2.1.  Caracter√≠sticas b√°sicas de C</a></li>
  <li><a href="#922-breve-historia-de-c" id="markdown-toc-922-breve-historia-de-c">9.2.2. Breve historia de C</a></li>
  <li><a href="#923-sintaxis-b√°sica-de-c" id="markdown-toc-923-sintaxis-b√°sica-de-c">9.2.3. Sintaxis b√°sica de C</a></li>
  <li><a href="#924-conversiones-de-tipo" id="markdown-toc-924-conversiones-de-tipo">9.2.4. Conversiones de tipo</a></li>
  <li><a href="#925-asignaci√≥n" id="markdown-toc-925-asignaci√≥n">9.2.5. Asignaci√≥n</a></li>
  <li><a href="#926-operadores-y-expresiones" id="markdown-toc-926-operadores-y-expresiones">9.2.6. Operadores y expresiones</a></li>
  <li><a href="#927-estructuras-de-control" id="markdown-toc-927-estructuras-de-control">9.2.7. Estructuras de control</a></li>
  <li><a href="#928-algoritmo-principal-y-subalgoritmos" id="markdown-toc-928-algoritmo-principal-y-subalgoritmos">9.2.8. Algoritmo principal y Subalgoritmos</a></li>
  <li><a href="#929-entrada-y-salida-en-c" id="markdown-toc-929-entrada-y-salida-en-c">9.2.9. Entrada y salida en C</a></li>
  <li><a href="#9210-cadenas-de-caracteres" id="markdown-toc-9210-cadenas-de-caracteres">9.2.10. Cadenas de caracteres</a></li>
  <li><a href="#9211-arrays" id="markdown-toc-9211-arrays">9.2.11. Arrays</a></li>
  <li><a href="#9212-funciones-de-la-librer√≠a-est√°ndar" id="markdown-toc-9212-funciones-de-la-librer√≠a-est√°ndar">9.2.12. Funciones de la librer√≠a est√°ndar</a></li>
</ul>

<p>C es un lenguaje muy antiguo pero plenamente vigente en muchos √°mbitos de la <strong>inform√°tica y diversas ingenier√≠as</strong>.</p>

<p>¬°C tiene m√°s de 50 a√±os, lo que es una aut√©ntica burrada en inform√°tica!</p>

<p>Sin embargo, sigue us√°ndose en la actualidad. <strong>Por algo ser√°.</strong></p>

<p>Por un lado, C genera c√≥digo m√°quina tan eficiente que ning√∫n otro lenguaje puede igualarlo. Y puedes acceder directamente al hardware de tu m√°quina desde C, o incluso incrustar c√≥digo ensamblador.</p>

<p>Por si esto fuera poco, C (o su hermano mayor, C++, que veremos en el siguiente tema) se utiliza mucho en la actualidad en diversos √°mbitos donde se necesita acceder al hardware o que los programas se ejecuten muy, muy r√°pido:</p>

<ul>
  <li>Desarrollo de sistemas. Gran parte de Windows, Linux, iOS o Android est√°n programados en C.</li>
  <li>Desarrollo de drivers para los sistemas operativos.</li>
  <li>Rob√≥tica y autom√°tica.</li>
  <li>Sistemas integrados en electrodom√©sticos: televisores, microondas, frigor√≠ficos, routers, etc.</li>
  <li>Sistemas integrados en los autom√≥viles: ABS, ESP, climatizaci√≥n, visualizaci√≥n de informaci√≥n en tiempo real, control de los sensores‚Ä¶</li>
  <li>Aprendizaje. Con C aprender√°s a programar de verdad, sin que librer√≠as enormes o <em>frameworks</em> te oculten lo que pasa en las entra√±as de la m√°quina.</li>
</ul>

<p>Por todas estas razones, C es un lenguaje estupendo para iniciarse en la programaci√≥n, as√≠ que ¬°vamos a ello!</p>

<h3 id="921--caracter√≠sticas-b√°sicas-de-c">9.2.1.  Caracter√≠sticas b√°sicas de C</h3>

<ul>
  <li>C es un lenguaje de <strong>nivel intermedio</strong>. Tiene caracter√≠sticas de los lenguajes de alto nivel pero, al mismo tiempo, permite manipular detalles del hardware que para otros lenguajes resultan innacesibles y genera c√≥digo m√°quina ultrarr√°pido.</li>
  <li>Es <strong>imperativo y estructurado</strong>. Admite <strong>orientaci√≥n a objetos</strong> (aunque entonces se llama C++).</li>
  <li>Su <strong>tipado es est√°tico y d√©bil</strong>. Eso significa que hay que indicar el tipo de datos de las variables antes de usarlas y que se pueden hacer mezclas de tipos.</li>
  <li>La <strong>sintaxis</strong> de sus estructuras de control se parece a las de Java, Javascript, PHP o Python, porque todos estos lenguajes son herederos naturales de C.</li>
  <li>Es un <strong>lenguaje compilado</strong>, pensado para producir c√≥digo m√°quina r√°pido y eficiente. Si quieres velocidad de ejecuci√≥n, C es tu lenguaje.</li>
  <li>Es <strong>altamente portable</strong> (para ser un lenguaje compilado). Existen compiladores de C para todos los sistemas y arquitecturas. Si respetas el est√°ndar de C, no tendr√°s dificultad para migrar las aplicaciones a cualquier sistema.</li>
  <li>Es un lenguaje de programaci√≥n <strong>muy  popular</strong> y <strong>muy veterano</strong>. Aunque se ha intentado reemplazar muchas veces, ning√∫n lenguaje lo ha conseguido y tiene una base de programadores muy fieles.</li>
</ul>

<h3 id="922-breve-historia-de-c">9.2.2. Breve historia de C</h3>

<p>A principios de la d√©cada de 1970, los laboratorios Bell necesitaban un nuevo sistema operativo. Hasta ese momento, la mayor√≠a de los sistemas operativos estaban escritos en lenguaje ensamblador (muy parecido al lenguaje m√°quina) para que el resultado fuera un programa lo suficientemente r√°pido.</p>

<p>Pero los programas escritos en ensamblador son dif√≠ciles de mantener y Bell quer√≠a que su nuevo sistema operativo se pudiera mantener y modificar con facilidad. Por lo tanto, se decidieron a inventar un lenguaje nuevo con el que programar su sistema operativo.</p>

<p>Tras varios intentos, Brian Kerningham y Dennis Ritchie, dos ingenieros de laboratorios Bell, terminaron de dise√±ar el lenguaje C en un ordenador DEC PDP-11 y, con √©l, desarrollaron el sistema operativo Unix.</p>

<p>El t√°ndem C - Unix ha sido una referencia fundamental en el mundo de la programaci√≥n en el √∫ltimo medio siglo, y C se ha convertido en uno de los lenguajes de programaci√≥n m√°s populares y longevos de la historia de la inform√°tica. C creci√≥ en popularidad muy r√°pidamente y sigue siendo uno de los lenguajes fundamentales tanto en el mundo educativo como en el mundo profesional.</p>

<p>El primer est√°ndar de C (ANSI C) no apareci√≥ hasta 1990, por lo que es posible encontrar diferentes dialectos de C ligeramente incompatibles entre s√≠.</p>

<p>Una evoluci√≥n de C fue el lenguaje C++ que, a parte de todas las caracter√≠sticas del ANSI C, incluye la posibilidad de orientaci√≥n a objetos, una t√©cnica de programaci√≥n ligeramente diferente de la programaci√≥n estructurada. Algo m√°s tarde, en el a√±o 2000, Microsoft patent√≥ el lenguaje C#, otra evoluci√≥n de C++ orientada al desarrollo de aplicaciones en red para la plataforma .NET de esta compa√±√≠a.</p>

<p>Otros lenguajes han sido dise√±ados para permitir que los no programadores puedan leer y comprender los programas y, presumiblemente, aprender a escribir los suyos propios para resolver problemas sencillos. Por el contrario, C fue creado, influenciado y probado en vivo por programadores profesionales. El resultado es que C da al programador lo que muchos programadores piden: unas pocas y bien escogidas palabras clave, una biblioteca poderosa y estandarizada, unas m√≠nimas restricciones y un m√°ximo control sobre lo que sucede en el interior de la m√°quina.</p>

<p>Si a esto unimos que el c√≥digo objeto generado por C es casi tan eficiente como el ensamblador, se entender√° por qu√© lleva medio siglo siendo uno de los lenguajes m√°s populares entre los programadores profesionales.</p>

<p>C tambi√©n tiene sus detractores que lo acusan de ser confuso, cr√≠ptico y demasiado flexible. En efecto, con C se pueden desarrollar las t√©cnicas de programaci√≥n estructurada, pero tambi√©n se puede programar ‚Äúc√≥digo espagueti‚Äù. Esto, sin embargo, ocurre con todos los lenguajes: incluso los que tienen una sintaxis m√°s estilizada y elegante, como Python o Ruby, pueden generar c√≥digo absolutamente ininteligible en manos de un programador manazas.</p>

<h3 id="923-sintaxis-b√°sica-de-c">9.2.3. Sintaxis b√°sica de C</h3>

<p>En este apartado vamos a aprender c√≥mo se escriben en C las estructuras de control y el resto de instrucciones b√°sicas.</p>

<h4 id="generalidades-sint√°cticas">Generalidades sint√°cticas</h4>

<p>Hay algunas normas b√°sicas de la sintaxis de C que tienes que conocer:</p>

<ul>
  <li><strong>Los bloques de c√≥digo se marcan con las llaves</strong> ( <strong>{</strong> y <strong>}</strong> ). Por ejemplo, despu√©s de una sentencia <em>while</em> (equivalente al <em>mientras</em> de pseudoc√≥digo) hay que abrir una llave. El cuerpo de bucle comprender√° desde esa llave de apertura hasta la siguiente llave de cierre, as√≠:</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="k">while</span> <span class="p">(</span><span class="n">condicion</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Instrucci</span><span class="err">√≥</span><span class="n">n</span> <span class="mi">1</span> <span class="n">del</span> <span class="n">bucle</span>
      <span class="n">Instrucci</span><span class="err">√≥</span><span class="n">n</span> <span class="mi">2</span> <span class="n">del</span> <span class="n">bulce</span>
      <span class="p">...</span>
      <span class="n">Instrucci</span><span class="err">√≥</span><span class="n">n</span> <span class="n">N</span> <span class="n">del</span> <span class="n">bucle</span>
   <span class="p">}</span>
</code></pre></div></div>

<p>La llave de cierre, por tanto, ser√≠a el equivalente al <em>FinMientras</em> de pseudoc√≥digo.</p>

<ul>
  <li>
    <p>Todas las instrucciones <strong>terminan con un punto y coma</strong> ( <strong>;</strong> ). Excepci√≥n: si una instrucci√≥n contiene un bloque marcado con llaves ( { ‚Ä¶ } ), se considera que esa instrucci√≥n termina al cerrar el bloque, y en ese caso no hace falta poner punto y coma.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>                     <span class="cm">/* La instrucci√≥n de asignaci√≥n termina con ; */</span>
 <span class="k">while</span> <span class="p">(</span><span class="n">condicion</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Cuerpo del bucle */</span>
 <span class="p">}</span>                           <span class="cm">/* El bucle termina con }, as√≠ que no necesita ; */</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Los <strong>identificadores</strong> de variables, funciones, etc., no pueden empezar con un n√∫mero ni contener espacios o s√≠mbolos especiales, salvo el de subrayado ( _ )</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">a5</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>     <span class="cm">/* Identificador de variable v√°lido */</span>
 <span class="mi">5</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>     <span class="cm">/* Identificador de variable NO v√°lido */</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Las <strong>cadenas de caracteres</strong> deben encerrarse entre <strong>comillas dobles</strong> ( ‚Äú‚Ä¶‚Äù ). Los <strong>caracteres</strong> individuales se encierran entre <strong>comillas simples</strong>.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="s">"Soy una cadena"</span><span class="p">;</span>   <span class="cm">/* Cadena de caracteres */</span>
 <span class="sc">'C'</span><span class="p">;</span>                <span class="cm">/* Car√°cter individual */</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>El lenguaje es <strong>sensitivo a las may√∫sculas</strong>. Es decir, no es lo mismo que una variable se llame <em>edad</em> que <em>Edad</em> o <em>EDAD</em>.</p>
  </li>
</ul>

<h4 id="tipos-de-datos-simples">Tipos de datos simples</h4>

<p>C utiliza varios tipos de datos <strong>simples</strong> porque solo pueden contener un valor en cada momento (como en pseudoc√≥digo). Los m√°s importantes son:</p>

<ul>
  <li><strong>int</strong>: n√∫meros enteros. Admite modificadores como <strong>long</strong> (para enteros largos) o <strong>short</strong> (para enteros cortos). Por ejemplo, el tipo <em>int</em> permite usar n√∫meros entre ‚Äì32768 a 32767, mientras que el tipo <em>long int</em> admite n√∫meros entre ‚Äì2147483648 a 2147483647.</li>
  <li><strong>float</strong>: n√∫mero reales. El tipo <strong>double</strong> se usa para lo mismo, pero tiene m√°s precisi√≥n y admite n√∫meros mayores.</li>
  <li><strong>char</strong>: caracteres.</li>
  <li><strong>void</strong>: vac√≠o. Se usa en funciones que no devuelven nada o que tienen una lista de par√°metros vac√≠a.</li>
</ul>

<p>Observa que en C no existe el tipo de dato <strong>l√≥gico o booleano</strong>. Se utiliza en su lugar el tipo <em>int</em>, representando el 0 el valor falso y cualquier otra cantidad (normalmente 1) el valor verdadero.</p>

<h4 id="declaraci√≥n-de-variables">Declaraci√≥n de variables</h4>

<p>Todas las variables tienen que <strong>declararse</strong> antes de su primer uso. Esto se hace as√≠:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>   <span class="cm">/* Declaraci√≥n de la variable a, de tipo entero */</span>
<span class="kt">char</span> <span class="n">b</span><span class="p">;</span>  <span class="cm">/* Declaraci√≥n de la variable b, de tipo car√°cter */</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>  <span class="cm">/* Uso de la variable a */</span>
<span class="n">b</span> <span class="o">=</span> <span class="sc">'z'</span><span class="p">;</span> <span class="cm">/* Uso de la variable b */</span>
</code></pre></div></div>

<p>Observa que, al declarar una variable, hay que especificar su tipo.</p>

<p>Todas las variables son <strong>locales</strong> a la funci√≥n o bloque de c√≥digo donde est√©n definidas, salvo que se indique otra cosa, dejando de existir al finalizar el bloque actual. Aunque pueden crearse variables globales, su uso est√° tan desaconsejado que ni siquiera te voy a explicar c√≥mo se hace.</p>

<h3 id="924-conversiones-de-tipo">9.2.4. Conversiones de tipo</h3>

<p>C es un lenguaje <strong>d√©bilmente tipado</strong>, es decir, no hace comprobaciones estrictas de tipos a la hora de asignar un valor a una variable o de comparar dos expresiones.</p>

<p>Por ejemplo, estas instrucciones son correctas:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">a</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
</code></pre></div></div>

<p>¬°Hemos asignado un valor entero a la variable <em>a</em>, que es de tipo <em>float</em>!</p>

<p>En otros lenguajes esto no est√° permitido, pero en C se realizan conversiones autom√°ticas de tipo cuando en una misma expresi√≥n aparecen datos de tipos diferentes. Esto, que en principio es una ventaja, pues elimina algunas limitaciones engorrosas, otras veces es peligroso porque algunos datos pueden cambiar extra√±amente de valor al hacerse esa conversi√≥n autom√°tica.</p>

<p>La conversi√≥n puede ser de dos clases:</p>

<ul>
  <li>
    <p><strong>Asignaci√≥n de un valor a una variable que permita m√°s precisi√≥n</strong>. Por ejemplo, asignar un n√∫mero entero a una variable <em>float</em>. En este caso, el n√∫mero se convierte a real a√±adiendo ‚Äú.0‚Äù a la parte decimal. No hay p√©rdida de informaci√≥n.</p>
  </li>
  <li>
    <p><strong>Asignaci√≥n de un valor a una variable que permita menos precisi√≥n</strong>. Por ejemplo, asignar un n√∫mero <em>long int</em> a una variable de tipo <em>int</em>. En este caso, el n√∫mero se recorta, perdiendo sus bits m√°s significativos, es decir, los d√≠gitos binarios que est√©n m√°s a la izquierda. Por lo tanto, hay p√©rdida de informaci√≥n. Hay que tener mucho cuidado con este tipo de conversiones.</p>
  </li>
</ul>

<p>Adem√°s de las conversiones autom√°ticas de tipo, el programador puede <strong>forzar la conversi√≥n de tipos</strong> a voluntad utilizando <strong>moldes</strong>.</p>

<p>Un molde es una expresi√≥n de un tipo de datos entre par√©ntesis que aparece delante de un dato. Entonces, antes de evaluar la expresi√≥n, el dato es convertido al tipo especificado en el molde. Por ejemplo:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">a</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</code></pre></div></div>

<p>Sin el molde <code class="language-plaintext highlighter-rouge">(float)</code>, la divisi√≥n <code class="language-plaintext highlighter-rouge">a/2</code> ser√≠a entera, ya que a es una variable de tipo <em>int</em>, y se perder√≠a la parte decimal. Al aplicar el molde, se convierte moment√°neamente el valor entero 5 al valor real 5.0 y se eval√∫a la expresi√≥n, que ahora s√≠ se realiza como divisi√≥n real, conservando sus decimales.</p>

<h3 id="925-asignaci√≥n">9.2.5. Asignaci√≥n</h3>

<p>La <strong>asignaci√≥n</strong> de valores a variables en C es f√°cil de explicar: se hace con el <strong>s√≠mbolo igual (=)</strong>, no con el s√≠mbolo &lt;= que us√°bamos en pseudoc√≥digo:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>      <span class="cm">/* Declaraci√≥n de la variable a */</span>
<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Declaraci√≥n y asignaci√≥n de valor a la variable b */</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>  <span class="cm">/* Asignaci√≥n de valor a la variable a */</span>
</code></pre></div></div>

<p>Observa c√≥mo, en la segunda instrucci√≥n, hemos declarado y asignado valor a una variable en la misma l√≠nea.</p>

<h3 id="926-operadores-y-expresiones">9.2.6. Operadores y expresiones</h3>

<p>Los <strong>operadores y expresiones en C</strong> son iguales que los que hemos empleado en pseudoc√≥digo:</p>

<ul>
  <li>Operadores <strong>aritm√©ticos</strong>: +, -, *, /, % (este √∫ltimo significa <em>m√≥dulo de la divisi√≥n</em>).</li>
  <li>Operadores <strong>relacionales</strong>: &gt;, &lt;, &gt;=, &lt;=‚Ä¶</li>
</ul>

<p>Sin embargo, hay algunas <strong>diferencias</strong> importantes entre el pseudoc√≥digo de PseInt y C. Son estas:</p>

<ul>
  <li>
    <p>La <strong>asignaci√≥n</strong>, como ya hemos visto m√°s arriba, se hace con el <strong>s√≠mbolo igual (=)</strong>, no con &lt;=.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>        <span class="cm">/* A la variable a se le asigna el valor 5 */</span>
 <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>    <span class="cm">/* A la variable b se le asigna el valor a + 1 */</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>La <strong>comparaci√≥n de igualdad</strong> se hace con un <strong>doble igual (==)</strong>, no con un solo igual (=). Esto es as√≠ para distinguir la comparaci√≥n de la asignaci√≥n.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>    <span class="cm">/* Comparaci√≥n: ¬øes a igual a 5? */</span>
     <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>   <span class="cm">/* Asignaci√≥n: b toma el valor a + 1 */</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Existe el <strong>operador incremento (++)</strong>. Se utiliza para sumar una unidad a una variable.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">i</span><span class="o">++</span><span class="p">;</span>         <span class="cm">/* Esto es equivalente a: i = i + 1 */</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Tambi√©n existe el <strong>operador decremento (- -)</strong>, para restar una unidad a una variable.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">i</span><span class="o">--</span><span class="p">;</span>     <span class="cm">/* Equivalente a: i = i - 1 */</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Los <strong>operadores l√≥gicos</strong> (Y, O, NO) se escriben de forma distinta:</p>
    <ul>
      <li><strong>Y</strong> se escribe <strong>&amp;&amp;</strong>.</li>
      <li><strong>O</strong> se escribe <strong>||</strong>.</li>
      <li><strong>NO</strong> se escribe <strong>!</strong> (s√≠, s√≠, es una admiraci√≥n).</li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>   <span class="cm">/* Operador Y: tienen que darse las dos condiciones a la vez */</span>
     <span class="p">...</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>Hay algunas otras diferencias, desde luego, pero con esto ya tienes para hacer un buen mont√≥n de programas.</p>

<h3 id="927-estructuras-de-control">9.2.7. Estructuras de control</h3>

<p>Las <strong>estructuras de control</strong> en C son muy similares a las que hemos utilizado en pseudoc√≥digo, cambiando ligeramente la notaci√≥n empleada.</p>

<p>A continuaci√≥n te muestro una tabla con las m√°s habituales y su equivalente en pseudoc√≥digo, sin entrar en explicaciones, porque supondremos que ya sabes manejarlas. Si no recuerdas para qu√© serv√≠a alguna de ellas, quiz√° ser√≠a buena idea que le dieras un repaso al cap√≠tulo dedicado al pseudoc√≥digo.</p>

<table>
    <tr>
      <th>Instrucci√≥n</th>
      <th>Pseudoc√≥digo</th>
      <th>Lenguaje C</th>
    </tr>
    <tr>
      <td>Condicional simple</td>
      <td>
         <code>
         Si condici√≥n entonces<br />
         &nbsp;&nbsp;&nbsp;acciones<br />
         FinSi
         </code>
      </td>
      <td>
         <code>
         if (condicion) {<br />
         &nbsp;&nbsp;&nbsp;acciones<br />
         }
         </code>
      </td>
    </tr>
    <tr>
      <td>Condicional doble</td>
      <td>
         <code>
         Si condicion entonces<br />
         &nbsp;&nbsp;&nbsp;acciones<br />
         SiNo<br />
         &nbsp;&nbsp;&nbsp;acciones<br />
         FinSi
         </code>
      </td>
      <td>
         <code>
         if (condicion) {<br />
         &nbsp;&nbsp;&nbsp;acciones<br />
         }<br />
         else {<br />
         &nbsp;&nbsp;&nbsp;acciones<br />
         }
         </code>
      </td>
    </tr>
    <tr>
      <td>Bucle tipo mientras</td>
      <td>
         <code>
         Mientras condicion hacer<br />
         &nbsp;&nbsp;&nbsp;acciones<br />
         FinMientras
         </code>
      </td>
      <td>
         <code>
         while (condicion) {<br />
         &nbsp;&nbsp;&nbsp;acciones<br />
         }
         </code>
      </td>
    </tr>
    <tr>
      <td>Bucle tipo repetir</td>
      <td>
         <code>
         Repetir<br />
         &nbsp;&nbsp;&nbsp;acciones<br />
         Hasta Que condicion
         </code>
      </td>
      <td>
         <code>
         do {<br />
         &nbsp;&nbsp;&nbsp;acciones<br />
         } while (condicion)
         </code>
      </td>
    </tr>
    <tr>
      <td>Bucle tipo para</td>
      <td>
         <code>
         Para variable &lt;- valor_inicial hasta valor_final con paso incremento hacer<br />
         &nbsp;&nbsp;&nbsp;acciones<br />
         FinPara
         </code>
      </td>
      <td>
         <code>
         for (variable = valor_inicial; variable != valor_final; variable = variable + incremento) {<br />
         &nbsp;&nbsp;&nbsp;acciones<br />
         }
         </code>
      </td>
    </tr>
</table>

<p>F√≠jate en que casi todo se escribe del mismo modo que en pseudoc√≥digo con un par de diferencias notables:</p>

<ul>
  <li>
    <p><strong>DIFERENCIA 1: En el bucle tipo <em>repetir</em></strong>, la condici√≥n de salida se expresa al rev√©s (‚Äúrepetir mientras..‚Äù en lugar de ‚Äúrepetir hasta que‚Ä¶‚Äù. Lo ver√°s mejor en este ejemplo que muestra los n√∫meros del 1 al 100. Observa la condici√≥n del final del bucle:</p>

    <p>En pseudoc√≥digo:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> i &lt;- 1
 Repetir
    Escribir i
    i &lt;- i + 1
 Hasta que i &gt;= 100
</code></pre></div>    </div>

    <p>En C:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
 <span class="k">do</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">i</span><span class="o">++</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>DIFERENCIA 2: En el bucle tipo <em>para</em></strong> hay que indicar la asignaci√≥n a la variable que controla el bucle, la condici√≥n de salida y la forma en la que esa variable cambiar√° en cada iteraci√≥n. Observa este ejemplo:</p>

    <p>En pseudoc√≥digo:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Para i &lt;- 1 hasta 10 hacer
    Escribir i
 FinPara
</code></pre></div>    </div>

    <p>En C:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
 <span class="p">}</span>
</code></pre></div>    </div>

    <p>Si el <strong>paso</strong> del bucle no es +1 (es decir, si la variable que controla el bucle no incrementa su valor de 1 en 1 en cada iteraci√≥n), hay que indicarlo de este modo:</p>

    <p>En pseudoc√≥digo:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Para i &lt;- 1 hasta 10 con paso 2 hacer
    Escribir i
 FinPara
</code></pre></div>    </div>

    <p>En C:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
 <span class="p">}</span>
</code></pre></div>    </div>

    <p>Por √∫ltimo, recuerda que en C existe una abreviatura para <code class="language-plaintext highlighter-rouge">i = i + 1</code>, que se escribe <code class="language-plaintext highlighter-rouge">i++</code>, por lo que lo m√°s habitual es encontrar los bucles de tipo <em>para</em> escritos as√≠:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span><span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="928-algoritmo-principal-y-subalgoritmos">9.2.8. Algoritmo principal y Subalgoritmos</h3>

<p>C es un <strong>lenguaje modular</strong> hasta el extremo de que todas las l√≠neas de c√≥digo deben pertenecer a alguna funci√≥n, incluyendo las instrucciones del algoritmo principal, que se escriben en una funci√≥n llamada <em>principal</em> (<strong><em>main</em></strong> en ingl√©s)</p>

<h4 id="la-funci√≥n-main">La funci√≥n <em>main()</em></h4>

<p>La <strong>funci√≥n <em>main()</em></strong> contiene el algoritmo o m√≥dulo principal del programa. La ejecuci√≥n de un programa siempre empieza por la primera l√≠nea de la funci√≥n <em>main()</em>.</p>

<p>Esta funci√≥n, como todas las funciones de C, puede devolver un valor. El valor devuelto por <em>main()</em> debe ser de tipo entero (<em>int</em>). Esto se utiliza para pasar alg√∫n valor al programa que haya llamado al nuestro, que suele ser el sistema operativo. Si <em>main()</em> no devuelve un n√∫mero entero al sistema operativo mediante una sentencia return, entonces nuestro programa devolver√° un n√∫mero desconocido.</p>

<p>(Moraleja: es una buena idea incluir un <em>return</em> al final de la funci√≥n <em>main()</em>. Generalmente, la devoluci√≥n de un 0 indica al sistema operativo que el programa a finalizado sin problemas, mientras que cualquier otro valor se√±ala que se ha producido alg√∫n error).</p>

<p>Por lo tanto, la forma habitual de la funci√≥n <em>main()</em> ser√°:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
   <span class="p">...</span><span class="n">instrucciones</span> <span class="n">del</span> <span class="n">algoritmo</span> <span class="n">principal</span><span class="p">...</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Observa que <em>main()</em> no tiene argumentos, por lo que aparece el identificador <em>void</em> entre par√©ntesis en la declaraci√≥n. Tambi√©n se pueden utilizar argumentos en <em>main()</em>, pero eso es algo que no trataremos de momento.</p>

<h4 id="las-funciones-en-c">Las funciones en C</h4>

<p>La declaraci√≥n de funciones se hace de forma similar a la empleada en pseudoc√≥digo:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tipo_devuelto</span> <span class="n">nombre_funci</span><span class="err">√≥</span><span class="n">n</span> <span class="p">(</span><span class="n">par</span><span class="err">√°</span><span class="n">metros_formales</span><span class="p">)</span>
<span class="p">{</span>
   <span class="p">...</span><span class="n">instrucciones</span><span class="p">...</span>
   <span class="k">return</span> <span class="n">expresi</span><span class="err">√≥</span><span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Observa que las √∫nicas diferencias con el pseudoc√≥digo son que no se usa la palabra ‚Äúfunci√≥n‚Äù, que las llaves { y } sustituyen a <em>inicio</em> y <em>fin</em>, y que se emplea la palabra <em>return</em> en lugar de devolver.</p>

<p>Si el tipo_devuelto es <em>void</em>, se considera que la funci√≥n no devuelve ning√∫n valor y que, por lo tanto, es un procedimiento. Entonces, un procedimiento en C se declara as√≠:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">nombre_procedimiento</span> <span class="p">(</span><span class="n">par</span><span class="err">√°</span><span class="n">metros_formales</span><span class="p">)</span>
<span class="p">{</span>
   <span class="p">...</span><span class="n">instrucciones</span><span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="paso-de-par√°metros">Paso de par√°metros</h4>

<p>Los par√°metros formales son, como en pseudoc√≥digo, una lista de tipos e identificadores que se sustituir√°n por los par√°metros actuales y se usar√°n como variables dentro de la funci√≥n.</p>

<p>Los par√°metros se pasan normalmente <strong>por valor</strong>, pero tambi√©n se pueden pasar por referencia. El paso de par√°metros por referencia admite dos sitaxis ligeramente diferentes en C: anteponiendo el <strong>operador *</strong> (asterisco) al nombre del par√°metro (equivalente a usar la expresi√≥n <em>por referencia</em> en pseudoc√≥digo) o anteponiendo el <strong>operador &amp;</strong>.</p>

<p><strong>Paso de par√°metros por valor</strong></p>

<p>Por ejemplo, en esta funci√≥n el paso de par√°metros es por valor:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">funcion1</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
   <span class="p">...</span><span class="n">c</span><span class="err">√≥</span><span class="n">digo</span> <span class="n">de</span> <span class="n">la</span> <span class="n">funci</span><span class="err">√≥</span><span class="n">n</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Esto quiere decir que <em>funcion1()</em> recibir√° √∫nicamente el valor de los dos par√°metros, x e y. Podr√° utilizar esos valores a lo largo de su c√≥digo, e incluso podr√° cambiarlos. Pero cualquier cambio en x e y no afectar√° a los par√°metros actuales, es decir, a los par√°metros del programa que llam√≥ a <em>funcion1()</em>.</p>

<p><strong>Paso de par√°metros por referencia con el operador *</strong></p>

<p>En la siguiente funci√≥n, el paso del par√°metro ‚Äúx‚Äù es por valor y el del par√°metro ‚Äúy‚Äù, por referencia:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">funcion2</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
   <span class="p">...</span><span class="n">c</span><span class="err">√≥</span><span class="n">digo</span> <span class="n">de</span> <span class="n">la</span> <span class="n">funci</span><span class="err">√≥</span><span class="n">n</span>
<span class="p">}</span>
</code></pre></div></div>

<p>En este caso, cada vez que se vaya a usar el par√°metro ‚Äúy‚Äù dentro del c√≥digo de la funci√≥n, ser√° necesario acompa√±arlo del asterisco. Por ejemplo:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">17</span> <span class="o">+</span> <span class="o">*</span><span class="n">y</span><span class="p">;</span>
</code></pre></div></div>

<p>(Hay algunas excepciones a esta regla, pero ahora no vienen a cuento).</p>

<p>En la llamada a la funci√≥n hay que indicar expl√≠citamente qu√© par√°metro se est√° pasando por referencia utilizando el operador &amp;. Por lo tanto, para llamar a <em>funcion2()</em> con los par√°metros a y b habr√° que escribir:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">resultado</span> <span class="o">=</span> <span class="n">funcion2</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</code></pre></div></div>

<p>Observa que el segundo par√°metro (el que se pasa por referencia), lleva delante el operador &amp;.</p>

<p>Si dentro de la funci√≥n se cambia el valor de y, tambi√©n cambiar√° el valor de b fuera de la funci√≥n, ya que ambas variables han quedado ligadas por el paso por referencia. En cambio, las variables x y a son independientes. (Si todo esto te suena a chino, rep√°sate el apartado dedicado al paso de par√°metros en el tema de introducci√≥n a la programaci√≥n en pseudoc√≥digo, donde se explicaba con m√°s detalle).</p>

<p><strong>Paso de par√°metros por referencia con el operador &amp;</strong></p>

<p>Otra forma de pasar un par√°metro por referencia es usar el operador &amp; en los par√°metros formales, as√≠:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">funcion3</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
   <span class="p">...</span><span class="n">c</span><span class="err">√≥</span><span class="n">digo</span> <span class="n">de</span> <span class="n">la</span> <span class="n">funci</span><span class="err">√≥</span><span class="n">n</span>
<span class="p">}</span>
</code></pre></div></div>

<p>En esta funci√≥n, el par√°metro x se pasa por valor y el par√°metro y se pasa por referencia. Utilizando esta sintaxis no es necesario a√±adir asteriscos cada vez que se usa la y en el cuerpo de la funci√≥n, ni tampoco usar ‚Äú&amp;‚Äù en la llamada a la funci√≥n.</p>

<p>Esta tercera forma de paso por referencia no es est√°ndar en C, sino que es propia de C++, por lo que evitaremos utilizarla de momento.</p>

<h4 id="junt√°ndolo-todo-en-un-ejemplo">Junt√°ndolo todo en un ejemplo</h4>

<p>En el siguiente ejemplo se ilustran los dos tipos de paso de par√°metros y, en el paso por referencia, las dos sintaxis alternativas de que dispone C.</p>

<p>El ejemplo muestra tres funciones muy similares que reciben dos par√°metros, a y b. Las tres intentan intercambiar el valor de a y b mediante una tercera variable llamada tmp. Sin embargo, en la primera de ellas el intercambio no tiene ning√∫n efecto en el programa <em>main()</em>, ya que los par√°metros est√°n pasados por valor. En las otras dos funciones s√≠ que se consigue el intercambio, ya que los par√°metros est√° pasados por referencia.</p>

<p>No te preocupes si no entiendes toda la sintaxis de este ejemplo. Lo interesante ahora es que veas cu√°l es la forma correcta de escribir cada tipo de paso de par√°metros.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="c1">// Paso de par√°metros por valor.</span>
<span class="c1">// En este ejemplo, esta funci√≥n no tendr√° el efecto deseado, porque las variables</span>
<span class="c1">// del programa principal no se ver√°n afectadas.</span>
<span class="kt">void</span> <span class="nf">intercambiar1</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
     <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
     <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
     <span class="n">b</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Paso de par√°metros por referencia, sintaxis 1.</span>
<span class="c1">// Esta funci√≥n s√≠ que consigue intercambiar los valores de las variables</span>
<span class="c1">// del programa principal.</span>
<span class="kt">void</span> <span class="nf">intercambiar2</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
     <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
     <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
     <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Paso de par√°metros por referencia, sintaxis 2.</span>
<span class="c1">// Esta funci√≥n tambi√©n consigue su objetivo. A todos los efectos,</span>
<span class="c1">// es id√©ntica a la funci√≥n anterior.</span>
<span class="kt">void</span> <span class="nf">intercambiar3</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
     <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
     <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
     <span class="n">b</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// Programa principal</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">dato1</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span> <span class="n">dato2</span> <span class="o">=</span> <span class="mi">90</span><span class="p">;</span>
    
    <span class="n">printf</span><span class="p">(</span><span class="s">"Antes de la llamada a las funcioens: dato1 = %i, dato2 = %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dato1</span><span class="p">,</span> <span class="n">dato2</span><span class="p">);</span>
    <span class="n">intercambiar1</span><span class="p">(</span><span class="n">dato1</span><span class="p">,</span> <span class="n">dato2</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Despu√©s de intercambiar1: dato1 = %i, dato2 = %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dato1</span><span class="p">,</span> <span class="n">dato2</span><span class="p">);</span>
    <span class="n">intercambiar2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dato1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dato2</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Despu√©s de intercambiar2: dato1 = %i, dato2 = %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dato1</span><span class="p">,</span> <span class="n">dato2</span><span class="p">);</span>
    <span class="n">intercambiar3</span><span class="p">(</span><span class="n">dato1</span><span class="p">,</span> <span class="n">dato2</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Despu√©s de intercambiar3: dato1 = %i, dato2 = %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dato1</span><span class="p">,</span> <span class="n">dato2</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="prototipos-de-funciones">Prototipos de funciones</h4>

<p>En C no es necesario escribir las funciones (subalgoritmos) antes de su primera invocaci√≥n. El mecanismo de compilaci√≥n y enlace de C permite, de hecho, que las funciones puedan estar f√≠sicamente en un archivo distinto del lugar desde el que se invocan.</p>

<p>En la pr√°ctica, esto plantea un problema: C no tiene forma de saber si la llamada a una funci√≥n se hace correctamente, es decir, si se le pasan los argumentos debidos y con el tipo correcto, ni si el resutado devuelto es asignado a una variable del tipo adecuado.</p>

<p>Para conseguir que C realice esas comprobaciones durante la compilaci√≥n se utilizan los <strong>prototipos de funci√≥n</strong>. Un prototipo de funci√≥n es, simplemente, <em>la declaraci√≥n de una funci√≥n</em>. Es decir, la primera l√≠nea del c√≥digo la funci√≥n.</p>

<p>El prototipo debe aparecer antes de que la funci√≥n se invoque por primera vez, aunque el c√≥digo completo de la funci√≥n est√© en otra parte. Los prototipos permiten al compilador comprobar que los argumentos de la funci√≥n coinciden en tipo y n√∫mero con los de la invocaci√≥n de la misma, y que el tipo devuelto es el correcto.</p>

<p>Los prototipos suelen aparecer al principio del programa, antes de la funci√≥n <em>main()</em>. Observa, en el siguiente ejemplo, que el prototipo de la funci√≥n <em>calcular_area()</em> se coloca delante de <em>main()</em>. Sin embargo, el c√≥digo concreto de esta funci√≥n no aparece hasta despu√©s (incluso podr√≠a estar situado en otro archivo diferente):</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">calcular_area</span> <span class="p">(</span><span class="kt">float</span> <span class="n">base</span><span class="p">,</span> <span class="kt">float</span> <span class="n">altura</span><span class="p">);</span>	<span class="c1">// Prototipo de la funci√≥n</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>				<span class="c1">// Algoritmo principal</span>
<span class="p">{</span>
   <span class="p">...</span><span class="n">instrucciones</span><span class="p">...</span>
   <span class="n">area</span> <span class="o">=</span> <span class="n">calcular_area</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">);</span>
   <span class="p">...</span><span class="n">m</span><span class="err">√°</span><span class="n">s</span> <span class="n">instrucciones</span><span class="p">...</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">calcular_area</span><span class="p">(</span><span class="kt">float</span> <span class="n">base</span><span class="p">,</span> <span class="kt">float</span> <span class="n">altura</span><span class="p">)</span>	<span class="c1">// C√≥digo de la funci√≥n (podr√≠a estar incluso en otro archivo)</span>
<span class="p">{</span>
   <span class="p">...</span> <span class="n">instrucciones</span><span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Cuando se vayan a usar funciones de librer√≠a, como <em>fabs()</em> (valor absoluto), <em>sqrt()</em> (ra√≠z cuadrada) o cualquier otra, hay que escribir sus prototipos antes de la funci√≥n <em>main()</em>. Sin embargo, como estas funciones no las hemos escrito nosotros, desconocemos cuales son sus prototipos.</p>

<p>En C se soluciona este problema con los <strong>archivos de cabecera</strong>, que son archivos que incluyen en su interior los prototipos de las funciones, entre otras cosas.</p>

<p>Hay muchos archivos de cabecera en la librer√≠a est√°ndar de C. Por ejemplo, el archivo <strong>math.h</strong> tiene los prototipos de todas las funciones matem√°ticas. Todos los archivos de cabecera tienen la <strong>extensi√≥n .h</strong> en su nombre (h de ‚Äúheader‚Äù).</p>

<p>Para incluir un archivo de cabecera en nuestro programa se utiliza <strong>#include</strong>, que no es exactamente una instrucci√≥n de C, sino una <strong>directiva de compilaci√≥n</strong>. Ya hemos visto otra directiva de compilaci√≥n: #define, que us√°bamos para definir constantes. Las directivas de compilaci√≥n indican al compilador c√≥mo se debe comportar y, aunque estrictamente hablando no son instrucciones de C, para nosotros es como si lo fueran.</p>

<p>Por ejemplo, esta l√≠nea de c√≥digo sirve para incluir todos los prototipos de las funciones de librer√≠a matem√°tica en nuestro programa:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;math.h&gt;</span><span class="cp">
</span></code></pre></div></div>

<h3 id="929-entrada-y-salida-en-c">9.2.9. Entrada y salida en C</h3>

<p>La entrada y salida de datos en C, es decir, la traducci√≥n de las instrucciones leer() y escribir() de pseudoc√≥digo, es uno de los aspectos m√°s dif√≠ciles de C para los principiantes.</p>

<p>El est√°ndar ANSI C dispone de muchas funciones para hacer las entradas y salidas de datos. En concreto, dispone de un subconjunto de ellas para hacer la entrada y salida por consola, es decir, por teclado y pantalla.</p>

<p>Podemos clasificar estas funciones de E/S en dos grupos:</p>

<ul>
  <li><strong>Funciones de E/S simples</strong>: <em>getchar(), putchar(), gets(), puts()</em></li>
  <li><strong>Funciones de E/S con formato</strong>: <em>printf(), scanf()</em></li>
</ul>

<p>Las m√°s utilizadas y vers√°tiles son sin duda las segundas, as√≠ que nos detendremos en ellas.</p>

<h4 id="salida-de-datos-con-printf">Salida de datos con <em>printf()</em></h4>

<p>La funci√≥n <em>printf()</em> (de ‚Äúprint‚Äù = imprimir y ‚Äúf‚Äù = formato) sirve para escribir datos en el dispositivo de salida est√°ndar (generalmente la pantalla) con un formato determinado por el programador. La forma general de utilizarla es la siguiente:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">printf</span><span class="p">(</span><span class="n">cadena_de_formato</span><span class="p">,</span> <span class="n">datos</span><span class="p">);</span>
</code></pre></div></div>

<p>El prototipo de <em>printf()</em> se encuentra en el archivo de cabecera <strong>&lt;stdio.h&gt;</strong> (de ‚Äústd‚Äù = standard e ‚Äúio‚Äù = input/output, es decir, ‚Äústdio‚Äù es un acr√≥nimo de ‚Äúentrada/salida est√°ndar‚Äù).</p>

<p>El primer argumento, la <em>cadena_de_formato</em>, especifica el modo en el que se deben mostrar los datos que aparecen a continuaci√≥n. Esta cadena se compone de una serie de c√≥digos de formato que indican a C qu√© tipo de datos son los que se desean imprimir.</p>

<p>Todos los c√≥digos est√°n precedidos del s√≠mbolo de porcentaje (‚Äú%‚Äù). Por ejemplo, el c√≥digo ‚Äú%i‚Äù indica a la funci√≥n que se desea escribir un n√∫mero de tipo <em>int</em>, y el c√≥digo ‚Äú%f‚Äù, que se desea escribir un n√∫mero real de tipo <em>float</em>.</p>

<p>La forma m√°s simple de utilizar <em>printf()</em> es:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div></div>

<p>Esto escribir√° el valor de la variable entera a en la pantalla, es decir, 5. F√≠jate que el primer argumento de printf() es una cadena (y, por lo tanto, se escribe entre comillas) cuyo contenido es el c√≥digo del tipo de dato que se pretende escribir. El segundo argumento es el dato mismo.</p>

<p>En una sola instrucci√≥n <em>printf()</em> pueden escribirse varios datos. Por ejemplo:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">x</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">.</span><span class="mi">33</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%i%f"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</code></pre></div></div>

<p>Observa detenidamente la cadena de formato: primero aparece ‚Äú%i‚Äù y luego ‚Äú%f‚Äù. Esto indica que el primer dato que debe imprimirse es un entero, y el segundo, un real. Despu√©s, aparecen esos datos separados por comas y exactamente en el mismo orden que en la cadena de formato: primero la variable entera y luego la variable real. El resultado ser√° que en la pantalla se escribir√°n los n√∫meros 5 y 10.33.</p>

<p>Algunos de los c√≥digos de formato que se pueden utilizar en <em>printf()</em> son:</p>

<ul>
  <li><strong>%c</strong>: para imprimir caracteres individuales.</li>
  <li><strong>%i</strong> o <strong>%d</strong>: para imprimir n√∫meros enteros.</li>
  <li><strong>%u</strong>: para imprimir n√∫meros enteros sin signo.</li>
  <li><strong>%f</strong>: para imprimir n√∫meros reales.</li>
  <li><strong>%e</strong>: para imprimir n√∫meros reales en notaci√≥n cient√≠fica.</li>
  <li><strong>%s</strong>: para imprimir cadenas de caracteres (strings).</li>
  <li><strong>%o</strong> y <strong>%x</strong>: para imprimir n√∫meros en octal y en hexadecimal, respectivamente.</li>
</ul>

<p>Algunos de estos c√≥digo admiten modificadores. Los m√°s habituales son:</p>

<ul>
  <li><strong>Los c√≥digos num√©ricos como ‚Äú%i‚Äù o ‚Äú%f‚Äù</strong> permiten insertar modificadores de longitud como ‚Äúl‚Äù (longitud doble) o ‚Äúh‚Äù (longitud corta). As√≠, por ejemplo, ‚Äú%ld‚Äù indica que se va a imprimir un entero de longitud doble (long int); ‚Äú%hu‚Äù sirve para enteros cortos sin signo (unsigned short int); ‚Äú%lf‚Äù indica que se imprimir√° un n√∫mero real de longitud doble (double), etc.</li>
  <li><strong>El c√≥digo ‚Äú%f‚Äù</strong> (n√∫meros reales) se pueden usar con un modificador de posiciones decimales que se desean mostrar. Por ejemplo, con ‚Äú%3.4f‚Äù obligamos a que se impriman tres d√≠gitos a la izquierda de la coma decimal y cuatro a la derecha. La escritura se justifica a la derecha. Para justificarla a la izquierda se utiliza el modificador ‚Äú-‚Äú, de esta forma: ‚Äú%-10.4f‚Äù.</li>
  <li><strong>El c√≥digo ‚Äú%s‚Äù</strong> (cadenas de caracteres) se puede combinar con un especificador de longitud m√°xima y m√≠nima de la cadena. Por ejemplo, ‚Äú%4.8s‚Äù escribe una cadena de al menos cuatro caracteres y no m√°s de ocho. Si la cadena tiene m√°s, se pierden los que excedan de ocho. Tambi√©n se puede utilizar el modificador ‚Äú-‚Äú para alinear el texto a la izquierda.</li>
</ul>

<p>Adem√°s de los c√≥digos de formato, en la cadena de formato puede aparecer cualquier texto entremezclado con los c√≥digos. A la hora de escribir en la pantalla, los c√≥digos ser√°n sustituidos por los datos correspondientes. Por ejemplo:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">x</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">.</span><span class="mi">33</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"El n√∫mero entero es %i y el real es %f"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</code></pre></div></div>

<p>Lo que aparecer√° en la pantalla al ejecutar este fragmento de c√≥digo ser√°:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>El n√∫mero entero es 5 y el real es 10.33
</code></pre></div></div>

<p>Una √∫ltima observaci√≥n sobre <em>printf()</em>: hay ciertos caracteres que no son directamente imprimibles desde el teclado. Uno de ellos es el <strong>salto de l√≠nea</strong>. Para poder ordenar a <em>printf()</em> que escriba un salto de l√≠nea (o cualquier otro car√°cter no imprimible) se utilizan los c√≥digos de barra invertida, que con c√≥digos especiales precedidos del car√°cter ‚Äú".</p>

<p>En concreto, el car√°cter ‚Äúsalto de l√≠nea‚Äù se indica con el c√≥digo ‚Äú\n‚Äù. Observa las diferencias entre estos dos bloques de instrucciones para intentar comprender la importancia del salto de l√≠nea:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"La variable a vale %i"</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"La variable a vale %i"</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div></div>

<p>El resultado en la pantalla de la ejecuci√≥n de estas instrucciones es:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>La variable a vale 5La variable a vale 14
</code></pre></div></div>

<p>Veamos el mismo ejemplo usando el c√≥digo del salto de l√≠nea (\n):</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"La variable a vale %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"La variable a vale %i"</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div></div>

<p>El resultado en la pantalla ser√°:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>La variable a vale 5
La variable a vale 14

</code></pre></div></div>

<h4 id="entrada-de-datos-con-scanf">Entrada de datos con scanf()</h4>

<p>La funci√≥n <em>scanf()</em> es, en muchos sentidos, la inversa de <em>printf()</em>. Puede leer desde el dispositivo de entrada est√°ndar (normalmente el teclado) datos de cualquier tipo de los manejados por el compilador, convirti√©ndolos al formato interno apropiado. Funciona de manera an√°loga a <em>printf()</em>, por lo que su sintaxis es:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scanf</span><span class="p">(</span><span class="n">cadena_de_formato</span><span class="p">,</span> <span class="n">datos</span><span class="p">);</span>
</code></pre></div></div>

<p>El prototipo de <em>scanf()</em> se encuentra en el archivo de cabecera <strong>&lt;stdio.h&gt;</strong>, como <em>printf()</em>.</p>

<p>La <em>cadena_de_formato</em> tiene la misma composici√≥n que la de printf(). Los datos son las variables donde se desea almacenar el dato o datos leidos desde el teclado. <strong>¬°Cuidado!</strong> Con los tipos simples, es necesario utilizar el operador &amp; delante del nombre de la variable, porque esa variable se pasa por referencia a <em>scanf()</em> para que √©sta pueda modificarla.</p>

<p>Por ejemplo:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">x</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Escribe un n√∫mero entero:"</span><span class="p">);</span>
<span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Ahora escribe un n√∫mero entero y un n√∫mero real:"</span><span class="p">);</span>
<span class="n">scanf</span><span class="p">(</span><span class="s">"%d%f"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Escribe una cadena:"</span><span class="p">);</span>
<span class="n">scanf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
</code></pre></div></div>

<p>La funci√≥n <em>scanf()</em> tiene alguna otra funcionalidad a√±adida para el manejo de cadenas de caracteres que ya veremos en su momento.</p>

<h4 id="ejemplo-de-uso-de-scanf-y-printf">Ejemplo de uso de scanf() y printf()</h4>

<p>Debido a la relativa complejidad de estas funciones de entrada y salida, vamos a presentar un peque√±o ejemplo de traducci√≥n de pseudoc√≥digo a C. Se trata de un algoritmo que lee dos n√∫meros enteros, A y B. Si A es mayor que B los resta, y en otro caso los suma.</p>

<p>Observa detenidamente la correspondencia entre cada pareja de instrucciones, especialmente las de entrada y salida.</p>

<p><strong>Pseudoc√≥digo:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>algoritmo suma_y_resta
   definir a, b como entero
   escribir "Introduzca dos n√∫meros enteros";
   leer a
   leer b
   si a &lt; b entonces
       escribir "La suma de a y b es:", a+b
   sino
       escribir "La resta de a menos b es:", a‚Äìb
finAlgoritmo
</code></pre></div></div>

<p><strong>Lenguaje C:</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Programa suma y resta */</span>
<span class="cp">#include stdio.h
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>   
  <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">"Introduzca dos n√∫meros enteros</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">"%d%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)</span> 
     <span class="n">printf</span><span class="p">(</span><span class="s">"La suma de %d y %d es: %d"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">);</span>
  <span class="k">else</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">"La resta de %d menos %d es: %d"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="err">‚Äì</span><span class="n">b</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="funciones-para-es-simple-por-consola">Funciones para E/S simple por consola</h4>

<p>T√©cnicamente, con <em>printf()</em> y <em>scanf()</em> es posible escribir y leer cualquier tipo de datos desde cualquier dispositivo de salida o entrada, no solo la pantalla y el teclado.</p>

<p>En la pr√°ctica, aunque <em>printf()</em> resulta bastante efectiva y vers√°til, <em>scanf()</em> puede darte muchos dolores de cabeza. Para hacerte una idea, s√≥lo tienes que probar a hacer un <em>scanf()</em> de un n√∫mero entero e inmediatamente despu√©s otro <em>scanf()</em> de una cadena de caracteres. El segundo <em>scanf()</em> fallar√°. La raz√≥n es bastante rocambolesca: el flujo de entrada no consumir√° el car√°cter de retorno de carro al leer el n√∫mero entero, por lo que dicho car√°cter se adjudicar√° al segundo <em>scanf()</em> autom√°ticamente.</p>

<p>Por suerte, <strong>existe otro grupo de funciones en ANSI C espec√≠ficamente dise√±adas para hacer la E/S por consola</strong>, es decir, por teclado y pantalla, de manera m√°s simple. Las resumimos en el siguiente cuadro.</p>

<p>Los prototipos de estas funciones, como el de <em>scanf()</em>, se encuentran en el archivo de cabecera <strong><em>stdio.h</em></strong>, as√≠ que tendr√°s que incluirlo en tu c√≥digo para poder usarlas.</p>

<ul>
  <li>
    <p><strong><em>getchar()</em></strong>: Espera a que se pulse una tecla seguida de INTRO y devuelve su valor. Muestra el eco en la pantalla, es decir, la tecla pulsada aparece en la pantalla.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">char</span> <span class="n">car</span><span class="p">;</span>
 <span class="n">car</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">();</span>
 <span class="n">printf</span><span class="p">(</span><span class="s">"Tecla pulsada:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li><strong><em>putchar(c)</em></strong>: Escribe el car√°cter <em>c</em> en la pantalla.</li>
  <li>
    <p><strong><em>gets(cadena)</em></strong>: Lee del teclado una cadena de caracteres seguida de INTRO.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">char</span> <span class="n">cadena</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
 <span class="n">gets</span><span class="p">(</span><span class="n">cadena</span><span class="p">);</span>
 <span class="n">printf</span><span class="p">(</span><span class="s">"Cadena tecleada:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
 <span class="n">puts</span><span class="p">(</span><span class="n">cadena</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li><strong><em>puts(cadena)</em></strong>: Escribe una cadena de caracteres en la pantalla (ver ejemplo anterior).</li>
</ul>

<p>Por lo tanto, <strong>para evitar los problemas que a menudo causa <em>scanf()</em>, podemos recurrir a <em>gets()</em></strong> para leer las cadenas de caracteres. Si necesitamos leer un n√∫mero, podemos usar <em>gets()</em> y luego <strong>convertir la cadena</strong> a un tipo de dato num√©rico con las funciones de conversi√≥n <em>atoi()</em> y <em>atof()</em>, como se muestra en el siguiente ejemplo:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">cadena</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">x</span><span class="p">;</span>

<span class="n">gets</span><span class="p">(</span><span class="n">cadena</span><span class="p">);</span>      <span class="c1">// Leemos una cadena de caracteres</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">cadena</span><span class="p">);</span>  <span class="c1">// Convertimos la cadena en un n√∫mero entero</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">atof</span><span class="p">(</span><span class="n">cadena</span><span class="p">);</span>  <span class="c1">// Convertimos la cadena en un n√∫mero real</span>
</code></pre></div></div>

<p>Las funciones de conversi√≥n <em>atoi()</em> y <em>atof()</em> tratar√°n de convertir la cadena en un n√∫mero, si ello es posible (es decir, si la cadena realmente contiene n√∫meros).</p>

<p>Pero cuidado: si se teclean m√°s caracteres de los que caben en la cadena, el resultado es imprevisible (a menudo el programa fallar√° durante la ejecuci√≥n). Esto puede solucionarse utilizando <em>fgets()</em> en lugar de <em>gets()</em>, que es una funci√≥n m√°s compleja y no vamos a explicar aqu√≠. Puedes buscar informaci√≥n en internet si te interesa el tema.</p>

<p>Tal vez pienses que resulta demasiado complicado hacer algo muy simple como una entrada de datos por teclado. Tienes raz√≥n. Pero ten en cuenta dos cosas: las entradas de datos nunca son simples (son el punto donde el usuario interacciona con m√°s libertad con el programa, y los usuarios humanos tendemos a hacer cosas impredecibles y complicadas), y C es un lenguaje de nivel intermedio m√°s que de alto nivel, por lo que muchas tareas de alto nivel, simplemente, no las resolver√° por nosotros. En ese sentido, C requiere del programador prestar atenci√≥n a ciertos detalles que podr√≠a obviar en otros lenguajes.</p>

<h3 id="9210-cadenas-de-caracteres">9.2.10. Cadenas de caracteres</h3>

<p>Las <strong>cadenas</strong> de caracteres en C son, en realidad, <strong>arrays de caracteres</strong>.</p>

<p>Aunque veremos los arrays en el pr√≥ximo apartado, si ya sabes pseudoc√≥digo quiz√° no te sorprenda saber que una cadena se declara as√≠:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">cadena</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>		<span class="cm">/* Declaraci√≥n de una cadena de 50 caracteres */</span>
</code></pre></div></div>

<p>La cadenas tienen ciertas peculiaridades que comentaremos en este apartado, pero todo lo que digamos en el siguiente sobre arrays tambi√©n ser√° aplicable a las cadenas.</p>

<h4 id="declaraci√≥n-y-manipulaci√≥n-de-cadenas">Declaraci√≥n y manipulaci√≥n de cadenas</h4>

<p>Las cadenas pueden manipularse elemento por elemento, como cualquier array. Por ejemplo:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">cadena</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
<span class="n">cadena</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'H'</span><span class="p">;</span>
<span class="n">cadena</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'o'</span><span class="p">;</span>
<span class="n">cadena</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'l'</span><span class="p">;</span>
<span class="n">cadena</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'a'</span><span class="p">;</span>
</code></pre></div></div>

<p>Las cadenas deben tener, despu√©s de su √∫ltimo car√°cter v√°lido, un car√°cter especial llamado <strong>nulo</strong>. Este car√°cter marca el final de la cadena. El car√°cter nulo se simboliza con <strong>el c√≥digo \0</strong>. Por lo tanto, en el ejemplo anterior habr√≠a que agregar la siguiente l√≠nea para que la cadena estuviera completa:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cadena</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
</code></pre></div></div>

<p><strong>Todas las cadenas deben terminar en un car√°cter nulo</strong>. De lo contrario, podemos tener problemas al imprimirlas en la pantalla o al realizar con ellas cualquier otro proceso. En consecuencia, en una cadena definida como la anterior, de 50 caracteres, en realidad s√≥lo tienen cabida 49, ya que siempre hay que reservar una posici√≥n para el car√°cter nulo.</p>

<p>La declaraci√≥n de una cadena puede ir acompa√±ada de una inicializaci√≥n mediante una constante. En este caso, la constante debe ir encerrada entre comillas dobles, al tratarse de una cadena y no de caracteres sueltos. Por ejemplo:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">cadena</span><span class="p">[</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Hola"</span><span class="p">;</span>
</code></pre></div></div>

<p>En inicializaciones de este tipo, el compilador se encarga de a√±adir el car√°cter nulo.
Por √∫ltimo, se√±alemos que no es necesario indicar el tama√±o de la cadena si se inicializa al mismo tiempo que se declara. Por ejemplo, la declaraci√≥n anterior puede sustituirse por esta otra:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">cadena</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"Hola"</span><span class="p">;</span>
</code></pre></div></div>

<p>Esto se denomina array de longitud indeterminada. El compilador, al encontrar una declaraci√≥n as√≠, crea una cadena del tama√±o suficiente para contener todos los caracteres. Esto vale no s√≥lo para las cadenas, sino que tambi√©n es aplicable a cualquier otro tipo de array que se inicialice al mismo tiempo que se declare.</p>

<h4 id="funciones-para-manejo-de-cadenas">Funciones para manejo de cadenas</h4>

<p>La mayor parte de las veces las cadenas son manipuladas mediante el uso de funciones de librer√≠a espec√≠ficas. En este apartado comentaremos las m√°s comunes.</p>

<p><strong>Funciones de lectura y escritura</strong></p>

<p>Para leer por teclado una cadena de caracteres se puede utilizar tambi√©n la funci√≥n <em>scanf()</em> con la cadena de formato ‚Äú%s‚Äù. Como las cadenas son arrays, no es preciso anteponer el s√≠mbolo &amp; al nombre de la variable. Sin embargo, es preferible emplear la funci√≥n <strong><em>gets()</em></strong> por estar espec√≠ficamente dise√±ada para la lectura de cadenas. Por ejemplo:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">cadena</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Introduzca su nombre "</span><span class="p">);</span>
<span class="n">gets</span><span class="p">(</span><span class="n">cadena</span><span class="p">);</span>
</code></pre></div></div>

<p>Tanto <em>scanf()</em> como <strong>gets()</strong> insertan autom√°ticamente el car√°cter ‚Äú\0‚Äù al final de la cadena.</p>

<p>De manera an√°loga podemos emplear la funci√≥n <em>printf()</em> para escribir el contenido de una cadena en la pantalla, pero preferiremos la funci√≥n <strong><em>puts()</em></strong>, espec√≠fica de las cadenas. Por ejemplo:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">cadena</span><span class="p">[</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Hola, mundo"</span><span class="p">;</span>
<span class="n">puts</span><span class="p">(</span><span class="n">cadena</span><span class="p">);</span>
</code></pre></div></div>

<h4 id="funciones-de-tratamiento-de-cadenas">Funciones de tratamiento de cadenas</h4>

<p>Las funciones de librer√≠a ANSI C para manejar cadenas suelen empezar por las letras ‚Äústr‚Äù (de ‚Äústring‚Äù, que significa ‚Äúcadena‚Äù en ingl√©s) y utilizan el archivo de cabecera <strong><em>string.h</em></strong>.</p>

<p>Entre las funciones m√°s habituales encontramos las siguientes:</p>

<ul>
  <li>
    <p><strong><em>strcpy()</em></strong>: Copia el contenido de una cadena en otra, incluyendo el car√°cter nulo. Su sintaxis es:</p>

    <p>El siguiente ejemplo es otra versi√≥n (artificialmente enrevesada) del ‚Äúhola, mundo‚Äù:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">char</span> <span class="n">cad1</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
 <span class="kt">char</span> <span class="n">cad2</span><span class="p">[</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Hola"</span><span class="p">;</span>
 <span class="n">strcpy</span><span class="p">(</span><span class="n">cad1</span><span class="p">,</span> <span class="n">cad2</span><span class="p">);</span>
 <span class="n">strcpy</span><span class="p">(</span><span class="n">cad2</span><span class="p">,</span> <span class="s">"mundo"</span><span class="p">);</span>
 <span class="n">printf</span><span class="p">(</span><span class="s">"%s, %s"</span><span class="p">,</span> <span class="n">cad1</span><span class="p">,</span> <span class="n">cad2</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong><em>strlen()</em></strong>: Devuelve la longitud de una cadena, es decir, el n√∫mero de caracteres de que consta, sin contar el car√°cter nulo.
Por ejemplo, en este fragmento de c√≥digo el resultado debe ser 11. F√≠jate que la variable cadena tiene una longitud total de 50 caracteres, pero <em>strlen()</em> s√≥lo cuenta los que efectivamente se est√°n usando, es decir, los que hay hasta el car√°cter nulo:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">char</span> <span class="n">cadena</span><span class="p">[</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Hola, mundo"</span><span class="p">;</span>
 <span class="kt">int</span> <span class="n">longitud</span><span class="p">;</span>
 <span class="n">longitud</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">cadena</span><span class="p">);</span>
 <span class="n">printf</span><span class="p">(</span><span class="s">"La longitud es %i"</span><span class="p">,</span> <span class="n">longitud</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong><em>strcmp()</em></strong>: Compara dos cadenas. Devuelve el valor 0 si son iguales, un valor mayor que 0 si la primera es alfab√©ticamente mayor que la segunda, o un valor menor que 0 en caso contrario. Por ejemplo:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">char</span> <span class="n">cad1</span><span class="p">[</span><span class="mi">50</span><span class="p">],</span> <span class="n">cad2</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
 <span class="kt">int</span> <span class="n">comparacion</span><span class="p">;</span>
 <span class="n">printf</span><span class="p">(</span><span class="s">"Introduzca dos cadenas"</span><span class="p">);</span>
 <span class="n">scanf</span><span class="p">(</span><span class="s">"%s %s"</span><span class="p">,</span> <span class="n">cad1</span><span class="p">,</span> <span class="n">cad2</span><span class="p">);</span>
 <span class="n">comparacion</span> <span class="o">=</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">cad1</span><span class="p">,</span> <span class="n">cad2</span><span class="p">);</span>
 <span class="k">if</span> <span class="p">(</span><span class="n">comparacion</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Las dos cadenas son iguales"</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong><em>strcat()</em></strong>: Concatena dos cadenas. Esta funci√≥n a√±ade la <em>cadena2</em> al final de la <em>cadena1</em>, incluyendo el car√°cter nulo. El resultado del siguiente ejemplo debe ser, otra vez, ‚Äúhola, mundo‚Äù:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">char</span> <span class="n">cad1</span><span class="p">[</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Hola, "</span><span class="p">;</span>
 <span class="kt">char</span> <span class="n">cad2</span><span class="p">[</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="s">"mundo"</span><span class="p">;</span>
 <span class="n">strcat</span><span class="p">(</span><span class="n">cad1</span><span class="p">,</span> <span class="n">cad2</span><span class="p">);</span>
 <span class="n">prinft</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">cad1</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="las-cadenas-y-la-validaci√≥n-de-los-datos-de-entrada">Las cadenas y la validaci√≥n de los datos de entrada</h4>

<p>Una de las principales fuentes de error de los programas son los datos de entrada incorrectos. Por ejemplo, si un programa est√° preparado para leer un n√∫mero entero pero el usuario, por error o por mala fe, introduce un car√°cter, la funci√≥n <em>scanf()</em> fallar√° y el programa se detendr√°.</p>

<p>En otros lenguajes de m√°s alto nivel, el propio lenguaje tiene mecanismos para prevenir estos errores. Pero recuerda que C es un lenguaje de nivel intermedio, pensado para producir c√≥digo m√°quina supereficiente y r√°pido. El precio a pagar por ello es que el lenguaje no har√° ninguna comprobaci√≥n de este tipo de errores: es responsabilidad del programador preverlos.</p>

<p>Hay un modo bastante sencillo de hacer esto: <strong>leer todos los datos de entrada como cadenas y, luego, convertirlos al tipo de dato adecuado</strong>.</p>

<p>Observa el siguiente ejemplo. Sirve para leer un n√∫mero entero por teclado, pero previniendo los errores provocados por el usuario que antes mencion√°bamos. Se utiliza la funci√≥n <em>atoi()</em>, que convierte una cadena a un n√∫mero entero:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">n</span><span class="p">;</span>		<span class="c1">// El n√∫mero entero que se pretende leer por teclado</span>
<span class="kt">char</span> <span class="n">cad</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>	<span class="c1">// La cadena que se usar√° para prevenir errores de lectura</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Introduzca un n√∫mero entero"</span><span class="p">);</span>
<span class="n">gets</span><span class="p">(</span><span class="n">cad</span><span class="p">);</span>		<span class="c1">// No se lee un n√∫mero entero, sino una cadena</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">cad</span><span class="p">);</span>	<span class="c1">// Se convierte la cadena a entero</span>
</code></pre></div></div>

<h3 id="9211-arrays">9.2.11. Arrays</h3>

<p>Un <strong>array</strong>, como ya vimos en pseudoc√≥digo, es una agrupaci√≥n de muchos datos individuales del mismo tipo bajo el mismo nombre. Cada dato individual de un array es accesible mediante un <strong>√≠ndice</strong>.</p>

<p>El caso m√°s simple de array es el <strong>array unidimensional</strong>. Por ejemplo, un array unidimensional de n√∫meros enteros es una colecci√≥n de muchos n√∫meros enteros a los que les adjudicamos un √∫nico identificador.</p>

<h4 id="declaraci√≥n-de-arrays">Declaraci√≥n de arrays</h4>

<p>La declaraci√≥n de un array en C se hace as√≠:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tipo_de_datos</span> <span class="n">nombre_array</span><span class="p">[</span><span class="n">n</span><span class="err">√∫</span><span class="n">mero_de_elementos</span><span class="p">];</span>
</code></pre></div></div>

<p>Por ejemplo:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">serie</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</code></pre></div></div>

<p>La variable <em>serie</em> ser√° un array que contendr√° 10 n√∫meros enteros. Los 10 n√∫meros reciben el mismo nombre, es decir, <em>serie</em>. 
Se puede acceder a cada uno de los n√∫meros que forman el array escribiendo a continuaci√≥n del nombre un n√∫mero entre corchetes. Ese n√∫mero se denomina √≠ndice. Lo puedes ver en el siguiente ejemplo:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">serie</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="n">serie</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="n">serie</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
<span class="n">serie</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">serie</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">serie</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="n">serie</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
</code></pre></div></div>

<p>El array <em>serie</em> puede almacenar hasta 10 n√∫meros enteros. Las posiciones empiezan a numerarse en el 0, as√≠ que <em>serie[2]</em> se refiere, en realidad, a la tercera posici√≥n. En ella se almacena el n√∫mero 20. En la cuarta posici√≥n (<em>serie[3]</em>) se almacena el n√∫mero 15. Luego se suman ambos valores, y el resultado se almacena en la quinta posici√≥n (<em>serie[4]</em>). Finalmente, se imprime en la pantalla el resultado de la suma, es decir, 35.</p>

<pre>
            +------------+----+----+----+----+----+
            | Posiciones |  0 |  1 |  2 |  3 |  4 |
    serie = +------------+----+----+----+----+----+
            | Valores    |  ? |  ? | 20 | 15 | 35 |
            +------------+----+----+----+----+----+
</pre>

<p>C no realiza comprobaci√≥n de los √≠ndices de los arrays, por lo que es perfectamente posible utilizar un √≠ndice fuera del rango v√°lido (por ejemplo, <em>serie[17]</em>). Es responsabilidad del programador evitar que esto ocurra, porque los efectos ser√°n desastrosos para el programa.</p>

<p>Como es l√≥gico, se pueden construir arrays cuyos elementos sean de cualquier otro tipo simple, como <em>float</em> o <em>double</em>, con la √∫nica restricci√≥n de que todos los elementos sean del mismo tipo. Los arrays de caracteres se denominan <strong>cadenas de caracteres</strong>, y ya hablamos de ellos en el apartado anterior.</p>

<p>Tambi√©n es posible construir arrays cuyos elementos sean de un tipo complejo. As√≠, podemos tener arrays de arrays o de otros tipos que no vamos a estudiar en este curso de introducci√≥n.</p>

<h4 id="manipulaci√≥n-de-los-elementos-individuales-de-un-array">Manipulaci√≥n de los elementos individuales de un array</h4>

<p>Los arrays en C deben manipularse elemento a elemento. No se pueden modificar todos los elementos a la vez.</p>

<p>Para asignar valores a los elementos de un array, por lo tanto, el mecanismo es este:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">serie</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="n">serie</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">serie</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">serie</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="p">...</span><span class="n">etc</span><span class="p">...</span>
</code></pre></div></div>

<p>La inicializaci√≥n de los valores de un array tambi√©n puede hacerse conjuntamente en el momento de declararlo, as√≠:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">serie</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">14</span><span class="p">};</span>
</code></pre></div></div>

<p>El resultado de esta declaraci√≥n ser√° un array de 5 elementos de tipo entero a los que se les asigna los valores 5, 3, 7, 9 y 14.</p>

<p>Cada elemento del array es, a todos los efectos, una variable que puede usarse independientemente de los dem√°s elementos. As√≠, por ejemplo, un elemento del array serie puede usarse en una instrucci√≥n de salida igual que cualquier variable simple de tipo <em>int</em>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">serie</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="n">serie</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="n">serie</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</code></pre></div></div>

<p>Del mismo modo, pueden usarse elementos de array en una instrucci√≥n de entrada. Por ejemplo:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">serie</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="n">scanf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">serie</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">serie</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">serie</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">15</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="n">serie</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</code></pre></div></div>

<h4 id="recorrido-de-un-array">Recorrido de un array</h4>

<p>Una forma habitual de manipular un array es <strong>acceder secuencialmente</strong> a todos sus elementos, uno tras otro.</p>

<p>Para ello, <strong>se utiliza un bucle con contador</strong>, de modo que la variable contador nos sirve como √≠ndice para acceder a cada uno de los elementos del array.</p>

<p>Supongamos, por ejemplo, que tenemos un array de 10 n√∫meros enteros declarado como <code class="language-plaintext highlighter-rouge">int v[10]</code> y una variable entera declarada como  <code class="language-plaintext highlighter-rouge">int i</code>. Por medio de un bucle, con ligeras modificaciones, podemos realizar todas estas operaciones:</p>

<p><strong>1) Inicializar todos los elementos a un valor cualquiera</strong> (por ejemplo, 0):</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>2) Inicializar todos los elementos con valores introducidos por teclado</strong>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">"Escribe el valor del elemento n¬∫ %i: "</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
   <span class="n">scanf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>3) Mostrar todos los elementos en la pantalla</strong>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">"El elemento n¬∫ %i vale %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>4) Realizar alguna operaci√≥n que implique a todos los elementos</strong>. Por ejemplo, sumarlos:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">suma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">suma</span> <span class="o">=</span> <span class="n">suma</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="arrays-y-funciones">Arrays y funciones</h4>

<p>Para <strong>pasar un array como argumento</strong> a una funci√≥n, en la llamada a la funci√≥n se escribe simplemente el nombre del array, sin √≠ndices.</p>

<p>Los arrays en C <strong>siempre se pasan por referencia</strong>, nunca por valor. Por lo tanto, si alg√∫n elemento del array se modifica en una funci√≥n, tambi√©n ser√° modificado en la funci√≥n desde la que fue invocada.</p>

<p>Como siempre se pasan por referencia, no es necesario utilizar el s√≠mbolo &amp; delante del par√°metro.</p>

<p>Por ejemplo, supongamos que <em>serie</em> es un array de 15 n√∫meros enteros. Para pasarlo como par√°metro a una funci√≥n llamada <em>funcion1()</em> escribir√≠amos simplemente esto:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">serie</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span>
<span class="n">funcion1</span><span class="p">(</span><span class="n">serie</span><span class="p">);</span>
</code></pre></div></div>

<p>En cuanto a la declaraci√≥n de la funci√≥n, el par√°metro de tipo array se especifica esta maneras:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">funcion1</span> <span class="p">(</span><span class="kt">int</span> <span class="n">serie</span><span class="p">[</span><span class="mi">15</span><span class="p">])</span> <span class="p">{</span>
   <span class="p">...</span><span class="n">c</span><span class="err">√≥</span><span class="n">digo</span> <span class="n">de</span> <span class="n">la</span> <span class="n">funci</span><span class="err">√≥</span><span class="n">n</span><span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Dentro de la funci√≥n, el array <em>serie</em> puede usarse del mismo modo que en el programa que la llama, es decir, no es preciso utilizar el operador asterisco ni nada por el estilo.</p>

<h4 id="un-programa-de-ejemplo-que-usa-arrays-y-funciones">Un programa de ejemplo que usa arrays y funciones</h4>

<p>Para ilustrar todo esto, te muestro  programa que sirve para leer 50 n√∫meros por teclado y calcular la suma, la media y la desviaci√≥n t√≠pica de todos los valores.</p>

<p>Lee el c√≥digo detenidamente, prestando sobre todo atenci√≥n al uso de los arrays y a c√≥mo se pasan como par√°metros.</p>

<p>Los n√∫meros de la serie se almacenar√°n en un array de tipo <em>float</em> de 50 posiciones llamado <em>valores</em>. La introducci√≥n de datos en el array se hace en la funci√≥n <em>introducir_valores()</em>. Como los arrays siempre se pasan por referencia, al modificar el array <em>valores</em> dentro de la funci√≥n, tambi√©n se modificar√° en el algoritmo principal.</p>

<p>Despu√©s, se llama a 3 funciones que calculan las tres magnitudes (suma, media y desviaci√≥n). El array tambi√©n se pasa por referencia a estas funciones, ya que en C no hay modo de pasar un array por valor.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;math.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">float</span> <span class="n">valores</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
	<span class="kt">float</span> <span class="n">suma</span><span class="p">,</span> <span class="n">media</span><span class="p">,</span> <span class="n">desviacion</span><span class="p">;</span>
	
	<span class="n">introducir_valores</span><span class="p">(</span><span class="n">valores</span><span class="p">);</span>
	<span class="n">suma</span> <span class="o">=</span> <span class="n">calcular_suma</span><span class="p">(</span><span class="n">valores</span><span class="p">);</span>	
	<span class="n">media</span> <span class="o">=</span> <span class="n">calcular_media</span><span class="p">(</span><span class="n">valores</span><span class="p">,</span> <span class="n">suma</span><span class="p">);</span>
	<span class="n">desviacion</span> <span class="o">=</span> <span class="n">calcular_desviacion</span><span class="p">(</span><span class="n">valores</span><span class="p">,</span> <span class="n">media</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"La suma es %f, la media es %f y la desviaci√≥n es %f"</span><span class="p">,</span> <span class="n">suma</span><span class="p">,</span> <span class="n">media</span><span class="p">,</span> <span class="n">desviacion</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Lee 50 n√∫meros y los almacena en el array N pasado por referencia */</span>
<span class="kt">void</span> <span class="nf">introducir_valores</span><span class="p">(</span><span class="kt">float</span> <span class="n">n</span><span class="p">[</span><span class="mi">50</span><span class="p">])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">49</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Introduzca el valor n¬∫ %d: "</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">"%f"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Devuelve la suma todos los elementos del array n */</span>
<span class="kt">float</span> <span class="nf">calcular_suma</span><span class="p">(</span><span class="kt">float</span> <span class="n">n</span><span class="p">[</span><span class="mi">50</span><span class="p">])</span>	
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">suma</span><span class="p">;</span>
	<span class="n">suma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">49</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">suma</span> <span class="o">=</span> <span class="n">suma</span> <span class="o">+</span> <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">suma</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Devuelve el valor medio de los elementos del array n. Necesita conocer la suma de los elementos para calcular la media */</span>
<span class="kt">float</span> <span class="nf">calcular_media</span><span class="p">(</span><span class="kt">float</span> <span class="n">n</span><span class="p">[</span><span class="mi">50</span><span class="p">],</span> <span class="kt">float</span> <span class="n">suma</span><span class="p">)</span>	
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">media</span><span class="p">;</span>
	<span class="n">media</span> <span class="o">=</span> <span class="n">suma</span> <span class="o">/</span> <span class="mi">50</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">media</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Calcula la desviaci√≥n t√≠pica de los elementos del array n. Necesita conocer la media para hacer los c√°lculos */</span>
<span class="kt">float</span> <span class="nf">calcular_desviacion</span><span class="p">(</span><span class="kt">float</span> <span class="n">n</span><span class="p">[</span><span class="mi">50</span><span class="p">],</span> <span class="kt">float</span> <span class="n">media</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">diferencias</span><span class="p">;</span>
	<span class="n">diferencias</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">49</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">diferencias</span> <span class="o">=</span> <span class="n">diferencias</span> <span class="o">+</span> <span class="n">abs</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="err">‚Äì</span> <span class="n">media</span><span class="p">)</span> <span class="p">;</span>
	<span class="n">diferencias</span> <span class="o">=</span> <span class="n">diferencias</span> <span class="o">/</span> <span class="mi">50</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">diferencias</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="9212-funciones-de-la-librer√≠a-est√°ndar">9.2.12. Funciones de la librer√≠a est√°ndar</h3>

<p>La siguiente lista resume algunas funciones de uso frecuente de ANSI C. Para cada funci√≥n se muestra su prototipo y se explica brevemente cu√°l es su cometido y cu√°les sus datos de entrada y salida. Tambi√©n se indica el archivo de cabecera donde se encuentra el prototipo.</p>

<p>Debes tener en cuenta que ANSI C dispone de muchas otras funciones. Si en alg√∫n momento las necesitas, una b√∫squeda r√°pida por internet te proporcionar√° informaci√≥n de sobra. Eso s√≠, aseg√∫rate que la funci√≥n que vayas a usar pertenezca al est√°ndar ANSI C. Solo as√≠ tendr√°s la garant√≠a de que tu compilador la reconocer√° y de que tu programa ser√° portable a otros sistemas.</p>

<p><strong>Funciones de entrada/salida</strong></p>

<table>
  <thead>
    <tr>
      <th>Funci√≥n</th>
      <th>Prototipo</th>
      <th>Utilidad</th>
      <th>Archivo de cabecera</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong><em>getchar()</em></strong></td>
      <td><code class="language-plaintext highlighter-rouge">int getchar(void)</code></td>
      <td>Devuelve un car√°cter leido por teclado mostrando el eco. Es necesario pulsar INTRO</td>
      <td>stdio.h</td>
    </tr>
    <tr>
      <td><strong><em>gets()</em></strong></td>
      <td><code class="language-plaintext highlighter-rouge">char* gets(char* cadena)</code></td>
      <td>Lee una cadena de caracteres del dispositivo est√°ndar de entrada y la sit√∫a en la posici√≥n apuntada por cadena</td>
      <td>stdio.h</td>
    </tr>
    <tr>
      <td><strong><em>printf()</em></strong></td>
      <td><code class="language-plaintext highlighter-rouge">int printf(const char* formato, lista_argumentos)</code></td>
      <td>Salida est√°ndar con formato. V√©ase el texto del cap√≠tulo para m√°s detalles</td>
      <td>stdio.h</td>
    </tr>
    <tr>
      <td><strong><em>putchar()</em></strong></td>
      <td><code class="language-plaintext highlighter-rouge">int putchar(int car√°cter)</code></td>
      <td>Escribe car√°cter en la pantalla</td>
      <td>stdio.h</td>
    </tr>
    <tr>
      <td><strong><em>puts()</em></strong></td>
      <td><code class="language-plaintext highlighter-rouge">int puts(const char* cadena)</code></td>
      <td>Escribe cadena en el dispositivo est√°ndar de salidastdio.h</td>
      <td>¬†</td>
    </tr>
    <tr>
      <td><strong><em>scanf()</em></strong></td>
      <td><code class="language-plaintext highlighter-rouge">int scanf(const char* formato, lista_argumentos)</code></td>
      <td>Entrada est√°ndar con formato. V√©ase el texto del cap√≠tulo para m√°s detalles</td>
      <td>stdio.h</td>
    </tr>
  </tbody>
</table>

<p><strong>Funciones de caracteres</strong></p>

<table>
  <thead>
    <tr>
      <th>Funci√≥n</th>
      <th>Prototipo</th>
      <th>Utilidad</th>
      <th>Archivo de cabecera</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong><em>isalnum()</em></strong></td>
      <td><code class="language-plaintext highlighter-rouge">int isalnum(int car√°cter)</code></td>
      <td>Devuelve 1 si el car√°cter es alfanum√©rico (letra o n√∫mero), o 0 si no lo es</td>
      <td>ctype.h</td>
    </tr>
    <tr>
      <td><strong><em>isalpha()</em></strong></td>
      <td><code class="language-plaintext highlighter-rouge">int isalpha(int car√°cter)</code></td>
      <td>Devuelve 1 si el car√°cter es alfab√©tico (una letra may√∫scula o min√∫scula), o 0 si no lo es</td>
      <td>ctype.h</td>
    </tr>
    <tr>
      <td><strong><em>isdigit()</em></strong></td>
      <td><code class="language-plaintext highlighter-rouge">int isdigit(int car√°cter)</code></td>
      <td>Devuelve 1 si el car√°cter es num√©rico, o 0 si no lo es</td>
      <td>ctype.h</td>
    </tr>
    <tr>
      <td><strong><em>isupper()</em></strong> e <strong><em>islower()</em></strong></td>
      <td><code class="language-plaintext highlighter-rouge">int isupper(int car√°cter);  int islower(int car√°cter);</code></td>
      <td>La primera devuelve 1 si el car√°cter es una letra may√∫scula y 0 en otro caso. La segunda, al rev√©s</td>
      <td>ctype.h</td>
    </tr>
  </tbody>
</table>

<p><strong>Funciones matem√°ticas</strong></p>

<table>
  <thead>
    <tr>
      <th>Funci√≥n</th>
      <th>Prototipo</th>
      <th>Utilidad</th>
      <th>Archivo de cabecera</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong><em>abs()</em></strong></td>
      <td><code class="language-plaintext highlighter-rouge">int abs(int n√∫mero)</code></td>
      <td>Devuelve el valor absoluto de n√∫mero</td>
      <td>stdlib.h</td>
    </tr>
    <tr>
      <td><strong><em>cos()</em></strong><br /><strong><em>sin()</em></strong><br /><strong><em>tan()</em></strong><br /><strong><em>acos()</em></strong><br /><strong><em>asin()</em></strong><br /><strong><em>atan()</em></strong></td>
      <td><code class="language-plaintext highlighter-rouge">double acos(double argumento)</code></td>
      <td>Todas tienen un prototipo similar. Calculan y devuelven, respectivamente, el arcocoseno, el arcoseno, el arcotangente, el coseno, el seno y la tangente de argumento. Los √°ngulos se expresan en radianes</td>
      <td>math.h</td>
    </tr>
    <tr>
      <td><strong><em>ceil()</em></strong></td>
      <td><code class="language-plaintext highlighter-rouge">double ceil(double n√∫mero)</code></td>
      <td>Redondea n√∫mero por exceso. P. ej: ceil(3.2) devuelve 4</td>
      <td>math.h</td>
    </tr>
    <tr>
      <td><strong><em>exp()</em></strong></td>
      <td><code class="language-plaintext highlighter-rouge">double exp(double potencia)</code></td>
      <td>Calcula el exponencial epotencia</td>
      <td>math.h</td>
    </tr>
    <tr>
      <td><strong><em>fabs()</em></strong></td>
      <td><code class="language-plaintext highlighter-rouge">double fabs(double n√∫mero)</code></td>
      <td>Devuelve el valor absoluto de n√∫mero</td>
      <td>math.h</td>
    </tr>
    <tr>
      <td><strong><em>floor()</em></strong></td>
      <td><code class="language-plaintext highlighter-rouge">double floor(double n√∫mero)</code></td>
      <td>Redondea n√∫mero por defecto. P. ej: floor(3.8) devuelve 3</td>
      <td>math.h</td>
    </tr>
    <tr>
      <td><strong><em>log()</em></strong></td>
      <td><code class="language-plaintext highlighter-rouge">double log(double n√∫mero)</code></td>
      <td>Devuelve el logaritmo natural de n√∫mero</td>
      <td>math.h</td>
    </tr>
    <tr>
      <td><strong><em>log10()</em></strong></td>
      <td><code class="language-plaintext highlighter-rouge">double log10(double n√∫mero)</code></td>
      <td>Devuelve el logaritmo decimal de n√∫mero</td>
      <td>math.h</td>
    </tr>
    <tr>
      <td><strong><em>pow()</em></strong></td>
      <td><code class="language-plaintext highlighter-rouge">double log(double base, double exp)</code></td>
      <td>Devuelve la potencia de base elevado a exp</td>
      <td>math.h</td>
    </tr>
    <tr>
      <td><strong><em>sqrt()</em></strong></td>
      <td><code class="language-plaintext highlighter-rouge">double sqrt(double n√∫mero)</code></td>
      <td>Devuelve la raiz cuadrada de n√∫mero</td>
      <td>math.h</td>
    </tr>
  </tbody>
</table>

<p><strong>Funciones variadas</strong></p>

<table>
  <thead>
    <tr>
      <th>Funci√≥n</th>
      <th>Prototipo</th>
      <th>Utilidad</th>
      <th>Archivo de cabecera</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong><em>atof()</em></strong></td>
      <td><code class="language-plaintext highlighter-rouge">double atof(char* cadena)</code></td>
      <td>Convierte la cadena en un n√∫mero real. Si la cadena no contiene un n√∫mero real v√°lido, devuelve 0</td>
      <td>stdlib.h</td>
    </tr>
    <tr>
      <td><strong><em>atoi()</em></strong></td>
      <td><code class="language-plaintext highlighter-rouge">int atoi(char* cadena)</code></td>
      <td>Convierte la cadena en un n√∫mero entero. Si la cadena no contiene un n√∫mero entero v√°lido, devuelve 0</td>
      <td>stdlib.h</td>
    </tr>
    <tr>
      <td><strong><em>atof()</em></strong></td>
      <td><code class="language-plaintext highlighter-rouge">double atof(char* cadena)</code></td>
      <td>Convierte la cadena en un n√∫mero real. Si la cadena no contiene un n√∫mero real v√°lido, devuelve 0</td>
      <td>stdlib.h</td>
    </tr>
    <tr>
      <td><strong><em>itoa()</em></strong></td>
      <td><code class="language-plaintext highlighter-rouge">char* itoa(int n√∫mero, int base)</code></td>
      <td>Convierte el n√∫mero en una cadena. La base de la cadena resultante se determina en base</td>
      <td>stdlib.h</td>
    </tr>
    <tr>
      <td><strong><em>rand()</em></strong></td>
      <td><code class="language-plaintext highlighter-rouge">int rand(void)</code></td>
      <td>Devuelve un n√∫mero entero al azar entre 0 y RAND_MAX (RAND_MAX es una constante definida en stdlib.h)</td>
      <td>stdlib.h</td>
    </tr>
    <tr>
      <td><strong><em>randomize()</em></strong></td>
      <td><code class="language-plaintext highlighter-rouge">void randomize(void)</code></td>
      <td>Inicializa el generador de n√∫meros aleatorio. Es necesario invocar esta funci√≥n si despu√©s se va a usar random()</td>
      <td>stdlib.h</td>
    </tr>
    <tr>
      <td><strong><em>random()</em></strong></td>
      <td><code class="language-plaintext highlighter-rouge">int random(int m√°ximo)</code></td>
      <td>Devuelve un n√∫mero al azar entre 0 y m√°ximo ‚Äì 1</td>
      <td>stdlib.h</td>
    </tr>
  </tbody>
</table>
:ET