I"√\<h1 class="no_toc" id="3-introducci√≥n-a-la-programaci√≥n">3. Introducci√≥n a la programaci√≥n</h1>

<ul id="markdown-toc">
  <li><a href="#31-qu√©-es-exactamente-eso-de-programar-un-ordenador" id="markdown-toc-31-qu√©-es-exactamente-eso-de-programar-un-ordenador">3.1. ¬øQu√© es exactamente eso de ‚Äúprogramar un ordenador‚Äù?</a></li>
  <li><a href="#32-programas-y-algoritmos" id="markdown-toc-32-programas-y-algoritmos">3.2. Programas y algoritmos</a>    <ul>
      <li><a href="#33-datos-y-tipos-de-datos" id="markdown-toc-33-datos-y-tipos-de-datos">3.3. Datos y tipos de datos</a></li>
      <li><a href="#34-variables-y-constantes" id="markdown-toc-34-variables-y-constantes">3.4. Variables y constantes</a></li>
      <li><a href="#35-subalgoritmos" id="markdown-toc-35-subalgoritmos">3.5. Subalgoritmos</a></li>
      <li><a href="#36-expresiones-y-operadores" id="markdown-toc-36-expresiones-y-operadores">3.6. Expresiones y operadores</a></li>
      <li><a href="#37-tipos-de-instrucciones" id="markdown-toc-37-tipos-de-instrucciones">3.7. Tipos de instrucciones</a></li>
      <li><a href="#38-dos-maneras-formales-de-escribir-los-algoritmos-pseudoc√≥digo-y-diagramas-de-flujo" id="markdown-toc-38-dos-maneras-formales-de-escribir-los-algoritmos-pseudoc√≥digo-y-diagramas-de-flujo">3.8. Dos maneras formales de escribir los algoritmos: pseudoc√≥digo y diagramas de flujo</a></li>
    </ul>
  </li>
</ul>

<h2 id="31-qu√©-es-exactamente-eso-de-programar-un-ordenador">3.1. ¬øQu√© es exactamente eso de ‚Äúprogramar un ordenador‚Äù?</h2>

<p><strong>Programar un ordenador</strong> no es m√°s que proporcionarle a la m√°quina un conjunto de instrucciones y datos para que realice una tarea. Esa tarea, generalmente, resuelve un problema concreto, que puede ir desde realizar complicados c√°lculos matem√°ticos hasta entretenernos con un videojuego en nuestros ratos de ocio.</p>

<p>El conjunto de las instrucciones que conforma el programa se denomina <strong>c√≥digo fuente</strong>, y tiene que estar escrito en un lenguaje comprensible por la m√°quina, es decir, un <strong>lenguaje de programaci√≥n</strong>.</p>

<p>Esas instrucciones se traducen a <strong>c√≥digo binario</strong> (que, recuerda, es lo √∫nico que puede comprender el ordenador). La CPU de un ordenador est√° construida de manera que puede entender y ejecutar ciertas instrucciones binarias, gracias a lo cual nuestro programa acaba ejecut√°ndose en las entra√±as de la m√°quina.</p>

<p>Este es un fragmento de un programa inform√°tico real escrito en lenguaje PHP. Implementa un algoritmo de ordenaci√≥n de elementos llamado <em>Bubble Sort</em> o, en espa√±ol, <em>m√©todo de la burbuja</em>. No es necesario, ni mucho menos, que lo entiendas de momento. Solo quiero que le eches un vistazo para que veas el aspecto que tiene un programa real (o un fragmento) escrito en un lenguaje real.</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">bubble_Sort</span><span class="p">(</span><span class="nv">$my_array</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="k">do</span>
	<span class="p">{</span>
		<span class="nv">$swapped</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span> <span class="nv">$i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">$c</span> <span class="o">=</span> <span class="nb">count</span><span class="p">(</span> <span class="nv">$my_array</span> <span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nv">$i</span> <span class="o">&lt;</span> <span class="nv">$c</span><span class="p">;</span> <span class="nv">$i</span><span class="o">++</span> <span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span><span class="p">(</span> <span class="nv">$my_array</span><span class="p">[</span><span class="nv">$i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nv">$my_array</span><span class="p">[</span><span class="nv">$i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
			<span class="p">{</span>
				<span class="k">list</span><span class="p">(</span> <span class="nv">$my_array</span><span class="p">[</span><span class="nv">$i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="nv">$my_array</span><span class="p">[</span><span class="nv">$i</span><span class="p">]</span> <span class="p">)</span> <span class="o">=</span>
						<span class="k">array</span><span class="p">(</span> <span class="nv">$my_array</span><span class="p">[</span><span class="nv">$i</span><span class="p">],</span> <span class="nv">$my_array</span><span class="p">[</span><span class="nv">$i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="p">);</span>
				<span class="nv">$swapped</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">while</span><span class="p">(</span> <span class="nv">$swapped</span> <span class="p">);</span>
<span class="k">return</span> <span class="nv">$my_array</span><span class="p">;</span>
<span class="p">}</span>

<span class="nv">$test_array</span> <span class="o">=</span> <span class="k">array</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">echo</span> <span class="s2">"Original Array :"</span><span class="p">;</span>
<span class="k">echo</span> <span class="nb">implode</span><span class="p">(</span><span class="s1">', '</span><span class="p">,</span><span class="nv">$test_array</span> <span class="p">);</span>
<span class="k">echo</span> <span class="s2">"Sorted Array:"</span><span class="p">;</span>
<span class="k">echo</span> <span class="nb">implode</span><span class="p">(</span><span class="s1">', '</span><span class="p">,</span><span class="nf">bubble_Sort</span><span class="p">(</span><span class="nv">$test_array</span><span class="p">))</span><span class="mf">.</span> <span class="kc">PHP_EOL</span><span class="p">;</span>
</code></pre></div></div>

<p>(Fuente: php.net)</p>

<h2 id="32-programas-y-algoritmos">3.2. Programas y algoritmos</h2>

<p>Para realizar un programa es necesario idear previamente un algoritmo. Esto es importante hasta el extremo de que, sin algoritmo, no existir√≠a el programa.</p>

<p>Un algoritmo, como hemos visto, es una <strong>secuencia ordenada de acciones que conducen a la soluci√≥n de un problema en un n√∫mero finito de pasos simples</strong>.</p>

<p>Por ejemplo, vamos a escribir un algoritmo para determinar si un n√∫mero entero cualquiera (que llamaremos N) es par o impar:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- Inicio del algoritmo
- Paso 1. Preguntar qu√© n√∫mero concreto es N.
- Paso 2. Si N es divisible entre 2, entonces la soluci√≥n es "PAR".
- Paso 3. Si N no es divisible entre 2, entonces la soluci√≥n es "IMPAR".
- Paso 4. Imprimir la soluci√≥n.
- Fin del algoritmo
</code></pre></div></div>

<p>Recuerda que este algoritmo est√° <strong>escrito para que lo ejecute un ordenador</strong>, no para que lo ejecute una persona. Por eso el Paso 1 es ‚ÄúPreguntar qu√© n√∫mero es N‚Äù: porque el ordenador tendr√° que preguntarnos a nosotros, los humanos, el n√∫mero. Y por eso el Paso 4 es ‚ÄúImprimir la soluci√≥n‚Äù: porque el ordenador nos ofrecer√° el resultado imprimi√©ndolo en la pantalla o en un papel.</p>

<p>Este algoritmo resuelve el problema planteado en un n√∫mero finito de pasos simples. L√≥gicamente, al ordenador no le podemos dar estas instrucciones tal y como las hemos escrito, sino que habr√° que expresarlo en un lenguaje de programaci√≥n, pero esto es algo que trataremos m√°s adelante.</p>

<h3 id="33-datos-y-tipos-de-datos">3.3. Datos y tipos de datos</h3>

<p>Los algoritmos, como hemos dicho, son colecciones de instrucciones que resuelven un problema.</p>

<p>Pero esas instrucciones <strong>siempre trabajan con datos</strong>, es decir, con informaci√≥n formalizada para su uso en un ordenador:</p>

<ul>
  <li><strong>Los datos de entrada</strong> son datos que el algoritmo necesita para trabajar. En el ejemplo anterior, el n√∫mero ‚ÄúN‚Äù es un dato de entrada.</li>
  <li><strong>Los datos de salida</strong> son datos que el algoritmo produce como resultado de sus c√°lculos. En el ejemplo anterior, ‚Äúsoluci√≥n‚Äù es un dato de salida.</li>
</ul>

<p>Los datos siempre pertenecen a un <strong>tipo de datos</strong>, que es el rango de valores que ese dato puede tomar. Existen multitud de tipos de datos posibles, pero empezaremos trabajando solo con estos:</p>

<ul>
  <li><strong>Enteros</strong>. Los datos de este tipo solo pueden tomar como valores n√∫meros enteros (positivos o negativos). Ejemplos: 3, 28, -15, 0, 4982‚Ä¶</li>
  <li><strong>Reales</strong>. N√∫meros con decimales. Ejemplos: 18.25, -3.198887</li>
  <li><strong>Caracteres</strong>. Letras, n√∫meros, signos de puntuaci√≥n‚Ä¶ Ojo, si un dato es de tipo ‚Äúcar√°cter‚Äù, solo puede contener en cada momento un √∫nico car√°cter. Ejemplos: ‚Äòa‚Äô, ‚ÄòZ‚Äô, ‚Äò&amp;‚Äô, ‚Äò?‚Äô</li>
  <li><strong>Cadenas de caracteres</strong>. O, simplemente, <em>cadenas</em>. Son colecciones de letras, n√∫meros, signos de puntuaci√≥n‚Ä¶ Es decir, palabras y cualquier cosa que se le parezca. Ejemplos: ‚ÄúHoy es lunes‚Äù, ‚Äúsgcv08 e98 ie7f83 ?so9&amp;/‚Äù. Suelen distinguirse de los caracteres individuales por la doble comilla, aunque esto depende del lenguaje de programaci√≥n.</li>
  <li><strong>L√≥gicos o booleanos</strong>. Estos datos solo pueden tener dos valores: <em>verdadero</em> o <em>falso</em>.</li>
</ul>

<h3 id="34-variables-y-constantes">3.4. Variables y constantes</h3>

<p>Las <strong>variables</strong> de un algoritmo son como las variables en una ecuaci√≥n matem√°tica: representaciones de un dato a las que asignamos un nombre o identificador.</p>

<p>En el algoritmo para averiguar si un n√∫mero es par o impar, <em>N</em> es una variable y <em>soluci√≥n</em> es otra variable.</p>

<p>Las variables pueden tomar un valor perteneciente a un tipo de datos. Ese valor puede cambiar a lo largo del algoritmo (por eso se denominan <em>variables</em>). Lo que no puede cambiar es el tipo de datos al que pertenecen. Es decir: si una variable es entera, no puede cambiar y pasar a ser real durante la ejecuci√≥n del programa.</p>

<p>(Bueno, hay lenguajes que s√≠ permiten hacer esto, pero esa es otra historia).</p>

<p>Por eso, la mayor√≠a de los lenguajes de programaci√≥n exigen que les indiquemos a qu√© tipo de datos pertenece cada variable antes de usarlas por primera vez. Es algo que tambi√©n haremos en pseudoc√≥digo. Eso se denomina <strong>declarar una variable</strong>.</p>

<p>As√≠ pues, podemos mejorar el algoritmo anterior con la declaraci√≥n de las variables ‚ÄúN‚Äù y ‚Äúsoluci√≥n‚Äù:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- Inicio del algoritmo
- Declaraci√≥n de variables:
   - N es un n√∫mero entero.
   - soluci√≥n es una cadena de caracteres.
- Paso 1. Averiguar qu√© n√∫mero es N.
- Paso 2. Si N es divisible entre 2, entonces la soluci√≥n es "PAR".
- Paso 3. Si N no es divisible entre 2, entonces la soluci√≥n es "IMPAR".
- Paso 4. Imprimir la soluci√≥n.
- Fin del algoritmo
</code></pre></div></div>

<p>Las <strong>constantes</strong> se parecen a las variables: tienen un nombre y un tipo, y se les asigna un valor. La √∫nica diferencia es que una constante <em>no puede cambiar de valor durante la ejecuci√≥n del algoritmo</em> y una variable s√≠.</p>

<h3 id="35-subalgoritmos">3.5. Subalgoritmos</h3>

<p>Cuando un algoritmo es muy complejo, lo dividimos en trozos m√°s simples que denominamos <strong>subalgoritmos</strong>. En programaci√≥n, esos subalgoritmos se denominan <strong>procedimientos</strong> o <strong>funciones</strong>. Son casi la misma cosa, con una sutil diferencia que ya veremos cuando llegue el momento.</p>

<p>Los lenguajes de programaci√≥n reales, adem√°s de las instrucciones b√°sicas que enseguida vamos a ver, tienen unas colecciones de funciones predefinidas llamadas <strong>bibliotecas</strong>. Esas funciones se encargan de realizar tareas habituales y repetitivas, de modo que nos ahorran un mont√≥n de trabajo.</p>

<p>Por ejemplo, es posible escribir algoritmos para hacer c√°lculos matem√°ticos complejos, tales como logaritmos o ra√≠ces cuadradas. Para evitarnos ese trabajo, todos los lenguajes de programaci√≥n disponen de una biblioteca de funciones matem√°ticas que incluye, entre otras muchas cosas, el c√°lculo de logaritmos y de ra√≠ces cuadradas para cuando los necesitemos. As√≠ que vamos a suponer, cuando escribamos pseudoc√≥digo, que tambi√©n tenemos a nuestra disposici√≥n de esas bibliotecas de funciones.</p>

<p>Algunos subalgoritmos o funciones que existen en todos los lenguajes de programaci√≥n y que podemos considerar que tambi√©n existen en pseudoc√≥digo son las siguientes:</p>

<ul>
  <li>abs(x). Calcula el valor absoluto de x. Funciona con n√∫meros reales y con enteros.</li>
  <li>sen(x). Calcula el seno de x. Devuelve valores reales.</li>
  <li>cos(x). Calcula el coseno de x. Devuelve valores reales.</li>
  <li>exp(x). Calcula e<sup>x</sup>. Devuelve un real.</li>
  <li>ln(x). Calcula el logaritmo neperiano de x. Devuelve un valor real.</li>
  <li>redon(x). Redondea el n√∫mero x al valor entero m√°s pr√≥ximo. El valor x ser√° real, y la funci√≥n devolver√° un entero.</li>
  <li>trunc(x). Trunca el n√∫mero x, es decir, le elimina la parte decimal. El valor x ser√° real, y la funci√≥n devolver√° un entero.</li>
  <li>rc(x). Calcula la ra√≠z cuadrada de x. Devuelve un valor real</li>
  <li>azar(x). Genera un n√∫mero al azar entre 0 y x. Supondremos que solo funciona con n√∫meros enteros.</li>
</ul>

<h3 id="36-expresiones-y-operadores">3.6. Expresiones y operadores</h3>

<p>Una <strong>expresi√≥n</strong> es una combinaci√≥n de constantes, variables, operadores y funciones.</p>

<p>Por ejemplo, esto es una expresi√≥n:</p>

<p align="center">rc((5 + x) / 2)</p>

<p>En esta expresi√≥n, aparecen dos constantes literales (5 y 2), una variable (x), dos operadores aritm√©ticos (+ y /) y una funci√≥n (rc, para calcular la ra√≠z cuadrada), adem√°s de los par√©ntesis, que sirven para manipular la prioridad de las operaciones.</p>

<p>L√≥gicamente, para resolver la expresi√≥n, es decir, para evaluar su resultado, debemos conocer cu√°l es el valor de la variable x.</p>

<p>Si suponemos que la variable x tiene el valor 7, el resultado de la expresi√≥n ser√° 2,449.</p>

<p>La forma m√°s habitual de encontrar una expresi√≥n es combinada con una <strong>sentencia de asignaci√≥n a una variable</strong>. Por ejemplo:</p>

<p align="center">y &lt;- raiz((5 + x) / 2)</p>

<p>En estos casos, la expresi√≥n (lo que hay a la derecha del signo ‚Äú&lt;-‚Äú) se eval√∫a y <em>su resultado es asignado a la variable</em> situada a la izquierda del ‚Äú&lt;-‚Äú.</p>

<p>En el ejemplo anterior, suponiendo que la variable x valiera 7, la expresi√≥n se evaluar√≠a como 2,449, y, por lo tanto, ese es el valor que se asignar√≠a a la variable y.</p>

<p>En las expresiones anteriores se han realizado algunas operaciones matem√°ticas (como sumas o divisiones). Los s√≠mbolos que se usan para ello se denominan <strong>operadores</strong>. En programaci√≥n, existen distintos tipos de operadores:</p>

<ul>
  <li><strong>Operadores aritm√©ticos</strong>: para hacer operaciones matem√°ticas convencionales. Los m√°s habituales son + (suma), - (resta), * (producto), / (divisi√≥n) y MOD (resto de la divisi√≥n entera).</li>
  <li><strong>Operadores relacionales</strong>: se utilizan para comparar n√∫meros, aunque tambi√©n pueden comparar caracteres o cadenas alfab√©ticamente. Los m√°s habituales son &lt; (menor que), &gt; (mayor que), = (igual que), != (distinto de), &lt;= (menor o igual que) y &gt; (mayor o igual que). El resultado de estas comparaciones siempre es un valor l√≥gico, es decir, verdadero o falso.</li>
  <li><strong>Operadoresl l√≥gicos</strong>: se utilizan para comparar otros datos l√≥gicos y relacionarlos entre s√≠. Los m√°s habituales son Y, O y NO. Estas palabras tienen el mismo significado que en la lengua natural.</li>
</ul>

<p>Observa, por ejemplo, este fragmento de pseudoc√≥digo muy f√°cil de entender:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>puntos_carnet = &lt;poner-aqu√≠-un-n√∫mero-entero&gt;
edad = &lt;poner-aqu√≠-otro-n√∫mero-entero&gt;
Si edad &gt;= 18 y puntos_carnet &gt; 0 Entonces
   escribir "Puedes conducir"
FinSi
Si edad &lt; 18 o puntos_carnet = 0 Entonces
   escribir "No puedes conducir"
FinSi
</code></pre></div></div>

<p>Aqu√≠ se usan dos variables, <em>puntos_carnet</em> y <em>edad</em> (que pueden tomar el valor que quieras ponerle) y luego se hacen dos comparaciones que implican operadores relacionales y l√≥gicos.</p>

<ul>
  <li>En la primera comparaci√≥n, se tienen que cumplir a la vez las dos condiciones (que la edad sea mayor o igual que 18 a√±os y que los puntos del carnet sean superiores a cero) para que el programa nos diga <em>‚ÄúPuedes conducir‚Äù</em>.</li>
  <li>En la segunda comparaci√≥n, basta con que una de las dos condiciones se cumpla para que el programa diga <em>‚ÄúNo puedes conducir‚Äù</em>.</li>
</ul>

<p>Es habitual encontrar varias operaciones juntas en una misma l√≠nea. En estos casos es imprescindible conocer la <strong>prioridad de los operadores</strong>, porque las operaciones se calcular√°n en el orden de prioridad y el resultado puede ser muy distinto del esperado.</p>

<p>En general, los operadores aritm√©ticos tienen la m√°xima prioridad y, entre ellos, la multiplicaci√≥n y la divisi√≥n son m√°s prioritarias que la suma o la resta. Los siguientes operadores por prioridad son los relacionales y, por √∫ltimo, los l√≥gicos. Sin embargo, esto puede variar seg√∫n el lenguaje de programaci√≥n concreto.</p>

<p>Lo m√°s apropiado, si tenemos dudas sobre el orden en el que se van a ejecutar las operaciones, es usar par√©ntesis, exactamente igual que hacemos en matem√°ticas.</p>

<h3 id="37-tipos-de-instrucciones">3.7. Tipos de instrucciones</h3>

<p>Hemos dicho varias veces que los algoritmos constan de dos elementos: un conjunto de datos (representados por constantes y variables) y un conjunto de instrucciones.</p>

<p>Son muy pocas, en realidad, las instrucciones que necesitamos para construir algoritmos que funcionen. Incre√≠blemente pocas:</p>

<ul>
  <li><strong>Instrucciones de entrada de datos</strong>. Sirven para indicar que, en ese punto, hay que proporcionar un dato al algoritmo. En el <em>Paso 1</em> del algoritmo para determinar si un n√∫mero es par o impar hay una instrucci√≥n de entrada.</li>
  <li><strong>Instrucciones de salida de datos</strong>. Sirven para que el algoritmo nos facilite el resultado de sus c√°lculos. En el <em>Paso 4</em> del algoritmo par-impar hay una instrucci√≥n de salida.</li>
  <li><strong>Instrucciones de asignaci√≥n</strong>. Sirven para asignar un valor a una variable.</li>
  <li><strong>Instrucciones para crear subalgoritmos</strong>. Sirven para declarar subalgoritmos y darles un nombre.</li>
  <li><strong>Instrucciones condicionales</strong>. Sirven para bifurcar el posible flujo de ejecuci√≥n del algoritmo. Las instrucciones condicionales contienen siempre una condici√≥n que puede ser verdadera o falsa. Si es verdadera, el algoritmo contin√∫a por un camino. Si es falsa, contin√∫a por otro. Antes o despu√©s, esa bifurcaci√≥n finaliza y el flujo del algoritmo vuelve a reunirse.</li>
  <li><strong>Instrucciones iterativas</strong>. Sirven para repetir una o varias instrucciones un n√∫mero finito de veces. Son la estructura m√°s dif√≠cil de manejar para los programadores principiantes.</li>
</ul>

<h3 id="38-dos-maneras-formales-de-escribir-los-algoritmos-pseudoc√≥digo-y-diagramas-de-flujo">3.8. Dos maneras formales de escribir los algoritmos: pseudoc√≥digo y diagramas de flujo</h3>

<p>Necesitamos un m√©todo de escritura de algoritmos que sea independiente del lenguaje de programaci√≥n que luego se vaya a utilizar. As√≠ se podr√°n traducir m√°s tarde a cualquier lenguaje.</p>

<p>Tres posibles maneras de escribir un algoritmo son:</p>

<ul>
  <li><strong>Lenguaje natural</strong> (como hicimos con el algoritmo para decidir si un n√∫mero es o no par).</li>
  <li><strong>Diagramas de flujo</strong></li>
  <li><strong>Pseudoc√≥digo</strong></li>
</ul>

<p>Por supuesto, tambi√©n podr√≠amos escribir los algoritmos directamente con un lenguaje de programaci√≥n real, pero, si eres principiante, es m√°s f√°cil aprender a programar usando pseudoc√≥digo o diagramas de flujo que hacerlo con un lenguaje de programaci√≥n. No tengas prisa: el lenguaje de programaci√≥n llegar√° muy pronto.</p>

<p>El lenguaje natural (castellano, en nuestro caso) no es apropiado porque, como todos los lenguajes naturales humanos, tiene muchas ambig√ºedades que provocar√≠an que, a veces, no quedara claro lo que queremos decir.</p>

<p>El <strong>pseudoc√≥digo</strong> es un lenguaje de codificaci√≥n de algoritmos basado en la lengua castellana, pero donde solo se permite un conjunto reducido de palabras con un significado muy concreto. El pseudoc√≥digo tiene dos propiedades que nos interesar√°n mucho: facilita considerablemente el aprendizaje de las t√©cnicas de programaci√≥n y logra que la traducci√≥n a un lenguaje de programaci√≥n real sea casi instant√°nea.</p>

<p>Los <strong>diagramas de flujo</strong> son representaciones gr√°ficas de los algoritmos que ayudan a comprender de forma visual su funcionamiento. Tienen una correspondencia directa con los diagramas de flujo.</p>

<p>Son dos t√©cnicas complementarias que vamos a trabajar indistintamente. Usar uno u otro es una cuesti√≥n de gustos y preferencias personales.</p>

<p>A continuaci√≥n, vamos a mostrar el algoritmo que determina si un n√∫mero es par escrito de los dos modos. Solo es un ejemplo, pero deber√≠as echarle un vistazo con detenimiento para comprobar si lo entiendes o no.</p>

<p><em>‚ÄúCon detenimiento‚Äù</em> significa que no lo leas deprisa y corriendo para marcharte a hacer otra cosa en dos minutos. Respira hondo y t√≥mate tu tiempo.</p>

<p>Si no lo entiendes todo, no te agobies todav√≠a. Aprender√°s a escribir pseudoc√≥digo y diagramas de flujo muy pronto.</p>

<p><strong>1. El algoritmo ‚ÄúPar-Impar‚Äù escrito como pseudoc√≥digo:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Algoritmo par_impar
	Definir N como Entero
	Definir solucion como Cadena

	Escribir "Dime un n√∫mero:"
	Leer N
	Si N MOD 2 = 0 Entonces
		solucion &lt;- "PAR"
	SiNo
		solucion &lt;- "IMPAR"
	FinSi
	Escribir "El n√∫mero ", N, " es ", solucion
FinAlgoritmo
</code></pre></div></div>

<p><strong>2. El algoritmo ‚ÄúPar-Impar‚Äù escrito como diagrama de flujo:</strong></p>

<p><img src="/docs/prog-y-3d/_site/assets/images/03-par-impar.png" alt="Diagrama de flujo par-impar" /></p>

:ET