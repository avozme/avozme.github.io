I"ËO<h1 class="no_toc" id="6-los-lenguajes-de-programaci√≥n">6. Los lenguajes de programaci√≥n</h1>

<ul id="markdown-toc">
  <li><a href="#61-tipos-de-lenguaje-seg√∫n-el-nivel-de-abstracci√≥n-alto-y-bajo-nivel" id="markdown-toc-61-tipos-de-lenguaje-seg√∫n-el-nivel-de-abstracci√≥n-alto-y-bajo-nivel">6.1. Tipos de lenguaje seg√∫n el nivel de abstracci√≥n: alto y bajo nivel</a></li>
  <li><a href="#62-tipos-de-lenguaje-seg√∫n-su-generaci√≥n" id="markdown-toc-62-tipos-de-lenguaje-seg√∫n-su-generaci√≥n">6.2. Tipos de lenguaje seg√∫n su generaci√≥n</a></li>
  <li><a href="#63-tipos-de-lenguaje-seg√∫n-su-forma-de-traducci√≥n" id="markdown-toc-63-tipos-de-lenguaje-seg√∫n-su-forma-de-traducci√≥n">6.3. Tipos de lenguaje seg√∫n su forma de traducci√≥n</a></li>
  <li><a href="#64-tipos-de-lenguaje-seg√∫n-su-tipado" id="markdown-toc-64-tipos-de-lenguaje-seg√∫n-su-tipado">6.4. Tipos de lenguaje seg√∫n su tipado</a></li>
  <li><a href="#65-el-top-ten-de-los-lenguajes-de-programaci√≥n" id="markdown-toc-65-el-top-ten-de-los-lenguajes-de-programaci√≥n">6.5. El <em>top ten</em> de los lenguajes de programaci√≥n</a></li>
</ul>

<p>Los lenguajes de programaci√≥n constituyen un ecosistema muy extenso y en constante evoluci√≥n. Para orientarse un poco en esa jungla, nada mejor que clasificar los lenguajes igual que los bi√≥logos clasifican a las criaturas vivas.</p>

<h2 id="61-tipos-de-lenguaje-seg√∫n-el-nivel-de-abstracci√≥n-alto-y-bajo-nivel">6.1. Tipos de lenguaje seg√∫n el nivel de abstracci√≥n: alto y bajo nivel</h2>

<p>Hay lenguajes de programaci√≥n muy pr√≥ximos al lenguaje binario: a √©stos los llamamos <strong>lenguajes de bajo nivel</strong> de abstracci√≥n. Y los hay m√°s pr√≥ximos al lenguaje natural: son los <strong>lenguajes de alto nivel</strong> de abstracci√≥n.</p>

<h4 id="lenguajes-de-bajo-nivel">Lenguajes de bajo nivel</h4>

<p>Son los lenguajes m√°s cercanos a la m√°quina. Los programas directamente escritos en c√≥digo binario se dice que est√°n en <strong>lenguaje m√°quina</strong> que, por lo tanto, es el lenguaje de m√°s bajo nivel que existe.</p>

<p>Las instrucciones del lenguaje m√°quina realizan tareas muy sencillas, como, por ejemplo, sumar dos n√∫meros, detectar qu√© tecla se ha pulsado en el teclado o escribir algo en la pantalla del ordenador. Cuando se combinan adecuadamente muchas de estas instrucciones sencillas se obtiene un programa de ordenador que puede realizar tareas muy complejas.</p>

<p>Por ejemplo, este puede ser el aspecto de una instrucci√≥n en lenguaje m√°quina para sumar dos n√∫meros:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0001 000100000101 110100110101
</code></pre></div></div>

<p>Incomprensible, ¬øverdad?</p>

<p>A pesar de la simplicidad de las instrucciones del lenguaje m√°quina, la forma de escribirlas es muy complicada, ya que hay que hacerlo en binario. En los primeros a√±os de la inform√°tica los ordenadores se programaban directamente en lenguaje m√°quina, lo cual convert√≠a la tarea de programar en una verdadera pesadilla. Hoy en d√≠a nadie lo hace.</p>

<p>Cuando los ordenadores fueron haci√©ndose m√°s potentes, surgi√≥ la idea de utilizar el propio ordenador como <strong>traductor</strong>: ¬øpor qu√© no escribir instrucciones en un lenguaje m√°s parecido al natural y que un programa de ordenador se encargue de traducir esa instrucci√≥n a su correspondiente instrucci√≥n en lenguaje m√°quina?</p>

<p>As√≠ apareci√≥ el <strong>lenguaje ensamblador</strong>, cuyas instrucciones son equivalentes a las del lenguaje m√°quina, pero se escriben con palabras similares a las del lenguaje humano. Por ejemplo, para sumar dos n√∫meros, la instrucci√≥n en ensamblador puede tener un aspecto como este:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ADD D1 D2
</code></pre></div></div>

<h4 id="lenguajes-de-alto-nivel">Lenguajes de alto nivel</h4>

<p>Siguiendo el razonamiento anterior (utilizar el propio ordenador como traductor), en la d√©cada de 1960 y, sobre todo, de 1970, se empezaron a desarrollar lenguajes cada vez m√°s complejos, en los que cada instrucci√≥n ya no se correspond√≠a exactamente con una instrucci√≥n del lenguaje m√°quina, sino con varias. Estos son los <strong>lenguajes de alto nivel</strong>.</p>

<p>L√≥gicamente, la traducci√≥n desde un lenguaje de alto nivel a lenguaje m√°quina es mucho m√°s compleja que desde lenguaje ensamblador, por lo que <em>los traductores se han hecho cada vez m√°s complicados</em>.</p>

<p>Una caracter√≠stica muy importante de los lenguajes de alto nivel es que <strong>son independientes del hardware</strong>, lo que implica que los programas desarrollados con estos lenguajes pueden ser ejecutados en ordenadores con hardware totalmente distinto. A esto se le llama <strong>portabilidad</strong>.</p>

<p>Los programas encargados de traducir el c√≥digo de alto nivel a c√≥digo m√°quina se llaman <strong>compiladores</strong> e <strong>int√©rpretes</strong>. Son programas muy complejos que generan el c√≥digo binario equivalente al c√≥digo de alto nivel para una m√°quina concreta. Por lo tanto, el programa de alto nivel, que es portable de un hardware a otro, debe ser traducido a c√≥digo m√°quina en cada tipo de m√°quina en la que se pretenda ejecutar.</p>

<p>Los ejemplos de lenguajes de alto nivel son innumerables, y la lista incluye casi todos de los que has o√≠do hablar alguna vez: Basic, Cobol, Fortran, Ada, C/C++, PHP, Python, Java, Perl, Ruby, Javascript, etc.</p>

<h4 id="ventajas-e-inconvenientes-de-los-lenguajes-de-alto-y-bajo-nivel">Ventajas e inconvenientes de los lenguajes de alto y bajo nivel</h4>

<table>
  <thead>
    <tr>
      <th><strong>LENGUAJES DE BAJO NIVEL</strong></th>
      <th><strong>LENGUAJES DE ALTO NIVEL</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Ventajas</strong></td>
      <td><strong>Inconvenientes</strong></td>
    </tr>
    <tr>
      <td>Son comprensibles directamente por la m√°quina (aunque el ensamblador necesita una peque√±a traducci√≥n)</td>
      <td>Necesitan ser traducidos por medio de complicados programas (compiladores e int√©rpretes)</td>
    </tr>
    <tr>
      <td>Los programas se ejecutan muy r√°pidamente (si est√°n bien escritos, claro)</td>
      <td>La traducci√≥n autom√°tica del c√≥digo de alto nivel al c√≥digo m√°quina siempre genera programas menos eficientes que si se escribieran directamente en binario</td>
    </tr>
    <tr>
      <td>Ocupan menos espacio en memoria</td>
      <td>Ocupan m√°s espacio en memoria</td>
    </tr>
    <tr>
      <td>Permiten controlar directamente el hardware, por lo que son apropiados para la programaci√≥n de sistemas</td>
      <td>En general, solo pueden acceder al hardware utilizando al sistema operativo como intermediario. Pero, entonces, ¬øc√≥mo programar el sistema operativo, que necesita controlar directamente el hardware?</td>
    </tr>
    <tr>
      <td><strong>Inconvenientes</strong></td>
      <td><strong>Ventajas</strong></td>
    </tr>
    <tr>
      <td>Son completamente dependientes del hardware. Un programa escrito para determinado tipo de m√°quina no funcionar√° en un ordenador con diferente arquitectura.</td>
      <td>Son portables, es decir, independientes del hardware. Un programa escrito en una m√°quina puede funcionar en otra con hardware distinto, siempre que se vuelva a traducir a binario en la m√°quina nueva.</td>
    </tr>
    <tr>
      <td>Incluso los programas m√°s sencillos son largos y farragosos</td>
      <td>Los programas son m√°s sencillos, ya que una sola instrucci√≥n puede equivaler a varias instrucciones binarias.</td>
    </tr>
    <tr>
      <td>Los programas son dif√≠ciles de escribir, depurar y mantener</td>
      <td>Los programas son m√°s f√°ciles de escribir, depurar y mantener</td>
    </tr>
    <tr>
      <td>Es imposible resolver problemas muy complejos</td>
      <td>Es posible, aunque dif√≠cil, enfrentarse a problemas muy complejos</td>
    </tr>
  </tbody>
</table>

<p>Si echas un vistazo a la tabla anterior comprender√°s que, en general, <strong>es preferible usar lenguajes de alto nivel</strong> la gran mayor√≠a de las veces, reservando los de bajo nivel para casos muy concretos, como el desarrollo de ciertas partes de los sistemas operativos.</p>

<p>Tambi√©n hay que destacar que no todos los lenguajes de alto nivel son iguales. Los hay de m√°s alto nivel que otros. El lenguaje C, por ejemplo, tiene menor nivel de abstracci√≥n que, por ejemplo, Java. Esto hace que los programas escritos en C sean m√°s r√°pidos y eficientes que los escritos en Java, aunque tambi√©n pueden llegar a ser m√°s dif√≠ciles de escribir y depurar.</p>

<h2 id="62-tipos-de-lenguaje-seg√∫n-su-generaci√≥n">6.2. Tipos de lenguaje seg√∫n su generaci√≥n</h2>

<p>Los lenguajes de programaci√≥n tambi√©n se clasifican seg√∫n la generaci√≥n a la que pertenecen.</p>

<p>El lenguaje m√°quina fue el lenguaje de primera generaci√≥n. Los ensambladores fueron los lenguajes de segunda generaci√≥n. A partir de ah√≠, surgi√≥ una explosi√≥n de lenguajes diferentes que podemos clasificar como:</p>

<ul>
  <li><strong>Lenguajes de tercera generaci√≥n</strong> (o <strong>imperativos</strong>), en los que el programador escribe una secuencia de instrucciones que el ordenador debe ejecutar en un orden preestablecido. Son los lenguajes m√°s ‚Äúcl√°sicos‚Äù: C, Basic, Cobol, Fortran, Pascal, etc.</li>
  <li><strong>Lenguajes de cuarta generaci√≥n</strong> (o <strong>4GL</strong>), dirigidos a facilitar la creaci√≥n de interfaces con el usuario y con otras aplicaciones, como las bases de datos. Un ejemplo de estos lenguajes es SQL, universalmente utilizado para manipular bases de datos y omnipresente en muchas aplicaciones web actuales.</li>
  <li><strong>Lenguajes orientados a objetos</strong>, que son una evolucui√≥n de los lenguajes de tercera generaci√≥n y que permiten construir con mayor facilidad y robustez programas modulares complejos. Ejemplos de lenguajes orientados a objetos son C++, C#, Java, Javascript, Python, PHP o Ruby. Algunos de ellos son multiparadigma, es decir, permiten programar con orientaci√≥n a objetos pero tambi√©n permiten hacer programaci√≥n estructurada cl√°sica, sin objetos.</li>
  <li><strong>Lenguajes declarativos</strong> y <strong>lenguajes funcionales</strong>, propios de la inteligencia artificial, como Prolog o Lisp.</li>
  <li><strong>Otros</strong> tipos a√∫n m√°s espec√≠ficos: lenguajes concurrentes, paralelos, distribuidos, etc.</li>
</ul>

<p>En general, podemos decir que un programador acostumbrado a trabajar con un lenguaje de tercera generaci√≥n puede aprender con poco esfuerzo cualquier otro lenguaje de tercera generaci√≥n y, con algo m√°s de trabajo, un lenguaje orientado a objetos. Sin embargo, el ‚Äúsalto‚Äù a otros tipos de lenguajes, como los declarativos, cuesta m√°s porque las fundamentos de estos lenguajes son muy diferentes.</p>

<h2 id="63-tipos-de-lenguaje-seg√∫n-su-forma-de-traducci√≥n">6.3. Tipos de lenguaje seg√∫n su forma de traducci√≥n</h2>

<p>Cuando programamos en un lenguaje distinto del lenguaje m√°quina, <strong>nuestro c√≥digo debe ser traducido a binario</strong> para que el ordenador pueda entenderlo y ejecutarlo. Existe un programa espec√≠fico encargado de hacer esa traducci√≥n y que, dependiendo del lenguaje en el que hayamos escrito nuestro programa, puede ser un <em>ensamblador</em>, un <em>compilador</em> o un <em>int√©rprete</em>.</p>

<h4 id="ensambladores">Ensambladores</h4>

<p>Se llaman <strong>ensambladores</strong> los programas encargados de <strong>traducir los programas escritos en ensamblador a c√≥digo binario</strong>.</p>

<p>S√≠, ya lo s√©: se usa el mismo nombre para referirse al <em>lenguaje</em> de programaci√≥n y al <em>traductor</em> de ese lenguaje a c√≥digo m√°quina. Es un l√≠o.</p>

<p>Como el lenguaje ensamblador es muy pr√≥ximo al binario, estos traductores son programas relativamente sencillos.</p>

<h4 id="compiladores">Compiladores</h4>

<p>El <strong>compilador</strong> es un programa que traduce el <strong>c√≥digo de alto nivel a c√≥digo binario</strong>.</p>

<p>Es, por tanto, parecido al ensamblador, pero mucho m√°s complejo, ya que las diferencias entre los lenguajes de alto nivel y el c√≥digo binario son muy grandes.</p>

<p>El programa escrito en lenguaje de alto nivel se denomina programa fuente o <strong>c√≥digo fuente</strong>. El programa traducido a c√≥digo binario se llama programa objeto o <strong>c√≥digo objeto</strong>. Por lo tanto, el compilador se encarga de convertir el programa fuente en un programa objeto.</p>

<p>Una vez que se ha obtenido el c√≥digo objeto ya no es necesario volver a realizar la traducci√≥n (o compilaci√≥n), a menos que se haga alguna modificaci√≥n en el programa fuente, en cuyo caso habr√≠a que volver a compilarlo.</p>

<p>El c√≥digo objeto, una vez generado, puede ejecutarse en la m√°quina en la que fue compilado, o en otra de similares caracter√≠sticas (procesador, sistema operativo, etc.). Cuando se usa programaci√≥n modular, puede ser necesario un proceso previo de enlace de los diferentes m√≥dulos antes de poder construir el programa ejecutable.</p>

<h4 id="int√©rpretes">Int√©rpretes</h4>

<p>El <strong>int√©rprete</strong> es un programa que <strong>traduce el c√≥digo de alto nivel a c√≥digo binario</strong> pero, a diferencia del compilador, lo hace <strong>en tiempo de ejecuci√≥n</strong>.</p>

<p>Es decir, no existe un proceso previo de traducci√≥n de todo el c√≥digo fuente a c√≥digo binario, sino que se va traduciendo y ejecutando instrucci√≥n por instrucci√≥n.</p>

<h4 id="compiladores-frente-a-int√©rpretes">Compiladores frente a int√©rpretes</h4>

<p>El <strong>int√©rprete</strong> es notablemente <strong>m√°s lento</strong> que el compilador, ya que realiza la traducci√≥n al mismo tiempo que la ejecuci√≥n. Adem√°s, esa traducci√≥n se lleva a cabo siempre que se ejecuta el programa, mientras que el compilador s√≥lo la hace una vez. Hay un evidente malgasto de recursos.</p>

<p>Sin embargo, los int√©rpretes tienen una gran ventaja sobre los compiladores, y es que logran que <strong>los programas sean m√°s portables</strong>, es decir, que puedan ejecutarse en diferentes m√°quinas con diferentes sistemas operativos sin apenas cambios.</p>

<p>As√≠, un programa <em>compilado</em> en una m√°quina PC bajo Windows no funcionar√° en un Mac o en un PC bajo Linux, a menos que se vuelva a compilar el programa fuente en el nuevo sistema. En cambio, un programa <em>interpretado</em> funcionar√° en todas las plataformas, siempre que dispongamos del int√©rprete en cada una de ellas.</p>

<p><strong>C/C++ es un ejemplo de lenguaje compilado. Python es un ejemplo de lenguaje interpretado.</strong></p>

<p>Eso significa que un programa escrito, por ejemplo, con <strong>Python</strong>, puede funcionar en cualquier m√°quina que disponga de un int√©rperte Python, que, hoy en d√≠a, es casi cualquiera. Por eso, <strong>cualquier programa escrito en Python puede ejecutarse pr√°cticamente en cualquier ordenador del mundo</strong> sin tocarle ni una coma.</p>

<p>En cambio, los programas desarrollados con C/C++ se ejecuten <strong>m√°s r√°pido</strong> (¬°pero mucho m√°s r√°pido!) que sus equivalentes en Python. Sin embargo, <strong>tendr√°s que volver a compilarlos</strong> si deseas ejecutarlos en una m√°quina con diferente hardware o diferente sistema operativo.</p>

<h2 id="64-tipos-de-lenguaje-seg√∫n-su-tipado">6.4. Tipos de lenguaje seg√∫n su tipado</h2>

<p>Por <em>tipado</em> nos referimos a la forma en la que los lenguajes de programaci√≥n usan los tipos de datos. Ya sabes: entero, car√°cter, l√≥gico, etc. Es decir, las categor√≠as a las que puede pertenecer una variable.</p>

<p>Pues bien, seg√∫n su tipado, los lenguajes pueden ser:</p>

<ul>
  <li><strong>De tipado fuerte</strong>: los tipos de datos no pueden mezclarse. Por ejemplo, no puedes sumar un entero y un real, porque son n√∫meros de distinto tipo. Y mucho menos sumar un entero con un car√°cter.</li>
  <li><strong>De tipado d√©bil</strong>: los tipos de datos pueden mezclarse y el lenguaje hace las conversiones de tipos impl√≠citas que le parezca oportunas. As√≠, en estos lenguajes podr√≠as sumar un entero con un real, o incluso un entero con un car√°cter. ¬øQue cu√°l ser√≠a el resultado? Buena pregunta. Tendr√°s que probarlo, porque eso depende de las conversiones de tipo que haga el lenguaje.</li>
  <li><strong>De tipado est√°tico</strong>: los tipos de datos se asignan al escribir el c√≥digo y no pueden cambiarse durante la ejecuci√≥n. Esto es t√≠pico de los compiladores (aunque no de todos).</li>
  <li><strong>De tipado din√°mico</strong>: los tipos de datos pueden cambiarse alegremente durante la ejecuci√≥n. Esto es t√≠pico de los int√©rpretes.</li>
</ul>

<p>Las dos primeras categor√≠as y las dos segundas no son excluyentes. Por ejemplo, pueden existir lenguajes de tipado d√©bil y din√°mico, o bien fuerte y est√°tico. Las otras combinaciones (fuerte y din√°mico, d√©bil y est√°tico) pueden darse pero son menos habituales.</p>

<h2 id="65-el-top-ten-de-los-lenguajes-de-programaci√≥n">6.5. El <em>top ten</em> de los lenguajes de programaci√≥n</h2>

<p>Es dif√≠cil saber cuales son los lenguajes m√°s populares en un determinado momento porque no existen estad√≠sticas fiables a nivel mundial. Adem√°s, las cosas pueden cambiar mucho de un territorio a otro.</p>

<p>Sin embargo, ciertos sitios de internet, como <strong>GitHub</strong>, almacenan enormes cantidades de proyectos de software. GitHub, de hecho, es el mayor almac√©n de c√≥digo fuente conocido, de modo que sus estad√≠sticas nos pueden dar una idea bastante exacta de cu√°l es el grado de uso de cada lenguaje.</p>

<p>Seg√∫n <a href="https://madnight.github.io/githut">Madnight</a>, un proyecto que recopila y publica estad√≠sticas de uso de lenguajes en GitHub, el <em>top ten</em> de lenguajes de programaci√≥n m√°s usados en GitHub es:</p>

<table>
  <thead>
    <tr>
      <th>Puesto</th>
      <th>Lenguaje</th>
      <th>Porcentaje de uso</th>
      <th>Variaci√≥n de uso en 12 meses</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>JavaScript</td>
      <td>17.955%</td>
      <td>-2.192%</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Python</td>
      <td>15.943%</td>
      <td>+0.071%</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Java</td>
      <td>12.977%</td>
      <td>+1.573%</td>
    </tr>
    <tr>
      <td>4</td>
      <td>Go</td>
      <td>8.203%</td>
      <td>-0.612%</td>
    </tr>
    <tr>
      <td>5</td>
      <td>TypeScript</td>
      <td>7.212%</td>
      <td>-0.276%</td>
    </tr>
    <tr>
      <td>6</td>
      <td>C++</td>
      <td>6.683%</td>
      <td>-0.251%</td>
    </tr>
    <tr>
      <td>7</td>
      <td>Ruby</td>
      <td>6.488%</td>
      <td>+0.303%</td>
    </tr>
    <tr>
      <td>8</td>
      <td>PHP</td>
      <td>4.937%</td>
      <td>-0.093%</td>
    </tr>
    <tr>
      <td>9</td>
      <td>C#</td>
      <td>3.366%</td>
      <td>-0.350%</td>
    </tr>
    <tr>
      <td>10</td>
      <td>C</td>
      <td>2.958%</td>
      <td>+0.068%</td>
    </tr>
  </tbody>
</table>

<p>El porcentaje de uso indica la proporci√≥n de proyectos en GitHub que usan ese lenguaje de programaci√≥n sobre el total de proyectos. La √∫ltima cifra se√±ala la variaci√≥n interanual del porcentaje de uso.</p>

<p>Estos datos son de tercer cuatrimestre de 2021. Para obtener datos de otras fechas, puedes visitar la web <a href="https://madnight.github.io/">https://madnight.github.io/</a></p>

<p>Ten en cuenta de nuevo que esto no son cifras de uso absoluto de los lenguajes a nivel mundial. Solo se trata de una pista de cu√°l es la situaci√≥n. De hecho, si consultas otras estad√≠sticas como el <a href="https://tiobe.com/tiobe-index/">TIOBE index</a>, encontrar√°s datos diferentes.</p>

<p>Seg√∫n estas cifras, el conjunto de proyectos que usan lenguaje C o cualquiera de sus variantes (C++ o C#) es muy significativo, sobre todo teniendo en cuenta que C es un lenguaje de la d√©cada de 1970, lo cual constituye una eternidad en inform√°tica. Que un lenguaje mantenga su vigencia durante tanto tiempo indica lo robusto y confiable que es. Seguramente seguir√° con nosotros dentro de muchos a√±os, cuando otros competidores de esta lista ya hayan ca√≠do en el olvido.</p>
:ET