I"Ü<h2 class="no_toc" id="94-un-poco-de-c-avanzado">9.4. Un poco de C avanzado</h2>

<ul id="markdown-toc">
  <li><a href="#941-punteros" id="markdown-toc-941-punteros">9.4.1. Punteros</a></li>
  <li><a href="#942-comprendiendo-los-punteros" id="markdown-toc-942-comprendiendo-los-punteros">9.4.2. Comprendiendo los punteros</a></li>
  <li><a href="#943-declaraci√≥n-e-inicializaci√≥n-de-punteros" id="markdown-toc-943-declaraci√≥n-e-inicializaci√≥n-de-punteros">9.4.3. Declaraci√≥n e inicializaci√≥n de punteros</a></li>
  <li><a href="#944-asignaci√≥n-de-punteros" id="markdown-toc-944-asignaci√≥n-de-punteros">9.4.4. Asignaci√≥n de punteros</a></li>
  <li><a href="#945-punteros-y-arrays" id="markdown-toc-945-punteros-y-arrays">9.4.5. Punteros y arrays</a></li>
  <li><a href="#946-paso-de-punteros-como-par√°metros" id="markdown-toc-946-paso-de-punteros-como-par√°metros">9.4.6. Paso de punteros como par√°metros</a></li>
  <li><a href="#947-devoluci√≥n-de-punteros" id="markdown-toc-947-devoluci√≥n-de-punteros">9.4.7. Devoluci√≥n de punteros</a></li>
  <li><a href="#948-punteros-a-punteros" id="markdown-toc-948-punteros-a-punteros">9.4.8. Punteros a punteros</a></li>
  <li><a href="#949-gesti√≥n-din√°mica-de-la-memoria-arrays-din√°micos" id="markdown-toc-949-gesti√≥n-din√°mica-de-la-memoria-arrays-din√°micos">9.4.9. Gesti√≥n din√°mica de la memoria: arrays din√°micos</a></li>
  <li><a href="#9410-librer√≠as-no-est√°ndar-que-molan-ncurses" id="markdown-toc-9410-librer√≠as-no-est√°ndar-que-molan-ncurses">9.4.10. Librer√≠as no est√°ndar que molan: ncurses</a></li>
  <li><a href="#9411-librer√≠as-no-est√°ndar-que-molan-sdl" id="markdown-toc-9411-librer√≠as-no-est√°ndar-que-molan-sdl">9.4.11. Librer√≠as no est√°ndar que molan: SDL</a></li>
</ul>

<p>En esta secci√≥n vamos a ver algunas cosas (¬°no todas!) sobre C avanzado: una introducci√≥n a los punteros, algo sobre gesti√≥n din√°mica de memoria, un poco acerca de los arrays din√°micos y c√≥mo usar librer√≠as no est√°ndar importantes tales como Ncurses (para a√±adir color y otros efectos a nuestros programas de texto) o SDL (para a√±adir gr√°ficos y sonidos).</p>

<h3 id="941-punteros">9.4.1. Punteros</h3>

<p>Comprender y usar correctamente los punteros es con seguridad <strong>lo m√°s complicado del lenguaje C</strong>, pero tambi√©n se trata de un mecanismo muy poderoso. Tan poderoso que un simple puntero descontrolado (hay quien los llama <em>punteros locos</em>) puede provocar que el programa se cuelgue o se comporte de forma extra√±a e impredecible.</p>

<p>Todos los programadores con cierta experiencia en C reconocer√°n que, a veces, programar con punteros es como quedarse atrapado en un ascensor con un mont√≥n de serpientes pit√≥n enloquecidas. Pero, cuando se les coge el tranquillo y se les ata en corto, permiten hacer aut√©nticas virguer√≠as.</p>

<h3 id="942-comprendiendo-los-punteros">9.4.2. Comprendiendo los punteros</h3>

<p>Dentro de la memoria del ordenador, cada <strong>dato</strong> almacenado ocupa <strong>una o m√°s celdas contiguas de memoria</strong>. El n√∫mero de celdas de memoria requeridas para almacenar un dato depende de su tipo. Por ejemplo, un dato de tipo entero puede ocupar 32 bits (es decir, 4 bytes), mientras que un dato de tipo car√°cter ocupa 8 bits (es decir, 1 byte).</p>

<div style="padding: 10px; background-color: #ddd"><strong>Un puntero no es m√°s que una variable cuyo contenido no es un dato, sino la direcci√≥n de memoria donde est√° almacenado un dato.</strong></div>

<p>Ve√°moslo a trav√©s de un ejemplo. Imaginemos que v es una variable de tipo car√°cter y que, por tanto, necesita 1 byte para ser almacenada. La declaraci√≥n e inicializaci√≥n de la variable ser√° como la siguiente:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">v</span><span class="p">;</span>
<span class="n">v</span> <span class="o">=</span> <span class="sc">'A'</span><span class="p">;</span>
</code></pre></div></div>

<p>Al ejecutar este c√≥digo, el sistema operativo asigna autom√°ticamente una celda de memoria para el dato. Supongamos que la celda asignada tiene la direcci√≥n 1200. Al hacer la asignaci√≥n v = ‚ÄòA‚Äô, el sistema almacena en la celda 1200 el valor 65, que es el c√≥digo ASCII de la letra ‚ÄòA‚Äô:</p>

<table>
  <thead>
    <tr>
      <th>Direcci√≥n de memoria</th>
      <th>Contenido</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1198</td>
      <td>¬†</td>
    </tr>
    <tr>
      <td>1199</td>
      <td>¬†</td>
    </tr>
    <tr>
      <td>1200</td>
      <td>65</td>
    </tr>
    <tr>
      <td>1201</td>
      <td>¬†</td>
    </tr>
    <tr>
      <td>‚Ä¶</td>
      <td>‚Ä¶</td>
    </tr>
  </tbody>
</table>

<p>Cuando usamos la variable v a lo largo del programa, el sistema consulta el dato contenido en la celda de memoria asignada a la variable. Esa celda ser√° siempre la misma a lo largo de la ejecuci√≥n: la 1200.</p>

<p>Por ejemplo, al encontrar esta instrucci√≥n:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">printf</span><span class="p">(</span><span class="s">"%c"</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div></div>

<p>.. el compilador acude a la celda 1200 de la memoria, consulta el dato almacenado en ella en ese momento y sustituye la variable v por ese dato.</p>

<p>El programador no tiene modo de saber en qu√© posici√≥n de memoria se almacena cada dato, a menos que utilice punteros. Los punteros sirven, entonces, para conocer la direcci√≥n de memoria donde se almacena el dato, y no el dato en s√≠.</p>

<p>La direcci√≥n ocupada por una variable v se determina escribiendo <strong>&amp;v</strong>. Por lo tanto, el <strong>operador &amp;</strong> es un operador unario, llamado <strong>operador direcci√≥n</strong>, que proporciona la direcci√≥n de memoria de una variable.</p>

<p>La direcci√≥n de v se le puede asignar a otra variable mediante esta instrucci√≥n:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">;</span> 
</code></pre></div></div>

<p>Resultar√° que esta nueva variable es un puntero a v, es decir, una variable cuyo contenido es la direcci√≥n de memoria ocupada por la variable v. <em>Representa la direcci√≥n de v y no su valor</em>. Por lo tanto, el contenido de p ser√° 1200, mientras que el contenido de v ser√° 65.</p>

<p>El dato almacenado en la celda apuntada por la variable puntero puede ser accedido mediante el operador asterisco aplicado al puntero. As√≠ pues, la expresi√≥n *p devuelve el valor 65, que es el contenido de la celda apuntada por p. El <strong>operador *</strong> es un operador unario, llamado <strong>operador indirecci√≥n</strong>, que opera s√≥lo sobre una variable puntero.</p>

<p>Resumiendo: podemos tener <em>variables ‚Äúnormales‚Äù</em> y utilizar el operador &amp; para conocer su direcci√≥n de memoria. O podemos tener <em>variables puntero</em>, que ya son en s√≠ mismas direcciones de memoria, y utilizar el operador * para acceder al dato que contienen:</p>

<ul>
  <li><strong>El operador direcci√≥n (&amp;)</strong> s√≥lo puede actuar sobre variables que <strong>no</strong> sean punteros. En el ejemplo anterior, la variable v vale 65 y la expresi√≥n &amp;v vale 1200.</li>
  <li><strong>El operador indirecci√≥n (*)</strong> s√≥lo puede actuar sobre variables que sean punteros. En el ejemplo anterior, la expresi√≥n *p vale 65 y la variable p vale 1200.</li>
</ul>

<p>Las variables puntero pueden apuntar a direcciones donde se almacene cualquier tipo de dato: enteros, flotantes, caracteres, cadenas, arrays, estructuras, etc. Esto es tremendamente √∫til y proporciona una enorme potencia al lenguaje C, pero tambi√©n es una fuente inagotable de errores de programaci√≥n dif√≠ciles de detectar y corregir, como iremos viendo en los siguientes temas</p>

<h3 id="943-declaraci√≥n-e-inicializaci√≥n-de-punteros">9.4.3. Declaraci√≥n e inicializaci√≥n de punteros</h3>

<p>Las variables de tipo puntero, como cualquier otra variable, deben <strong>declararse</strong> antes de ser usadas.</p>

<p>Cuando una variable puntero es definida, <em>el nombre de la variable debe ir precedido por un *</em>.</p>

<p>El tipo de dato que aparece en la declaraci√≥n se refiere al tipo de dato que se almacena en la direcci√≥n representada por el puntero, en vez del puntero mismo. As√≠, una declaraci√≥n de puntero general es:</p>

<p>Por ejemplo:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">numero</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">letra</span><span class="p">;</span>
</code></pre></div></div>

<p>La variable <em>numero</em> no contiene un n√∫mero entero, sino <em>la direcci√≥n de memoria donde se almacenar√° un n√∫mero entero</em>. La variable letra tampoco contiene un car√°cter, sino <em>la direcci√≥n de memoria donde se almacenar√° un car√°cter</em>.</p>

<p>Cuando un puntero ha sido declarado pero no inicializado, apunta a una direcci√≥n de memoria indeterminada. Si tratamos de usarlo en esas condiciones obtendremos resultados impredecibles (y casi siempre desagradables).</p>

<p>Antes de usar cualquier puntero hay que <strong>asegurarse de que est√° apuntando a una direcci√≥n v√°lida</strong>, es decir, a la direcci√≥n de alguna variable del tipo adecuado. Por ejemplo, as√≠:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">numero</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="n">numero</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
</code></pre></div></div>

<p>El puntero <em>numero</em> ahora s√≠ est√° en condiciones de ser usado, porque est√° apuntado a la direcci√≥n de la variable <em>a</em>, que es de tipo <em>int</em>, como el puntero.</p>

<p>Otra posibilidad es hacer que un puntero apunte a NULL. El identificador NULL es una constante definida en el lenguaje que indica que un puntero no est√° apuntando a ninguna direcci√≥n v√°lida y que, por lo tanto, no se debe utilizar:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">numero</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="944-asignaci√≥n-de-punteros">9.4.4. Asignaci√≥n de punteros</h3>

<p>Se puede asignar una variable puntero a otra siempre que ambas apunten al mismo tipo de dato. Al realizar la asignaci√≥n, ambos punteros quedar√°n apuntando a la misma direcci√≥n de memoria.</p>

<p>Observa este ejemplo y trata de determinar qu√© resultado se obtiene en la pantalla (antes de leer la soluci√≥n que aparece m√°s abajo):</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="o">*</span><span class="n">p2</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">p1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>	<span class="cm">/* p1 apunta a la direcci√≥n de memoria de la variable a */</span>
<span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>	<span class="cm">/* a p2 se le asigna la misma direcci√≥n que tenga p1 */</span>
<span class="n">b</span> <span class="o">=</span> <span class="o">*</span><span class="n">p1</span><span class="p">;</span>
<span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="n">p1</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>	<span class="cm">/* Suma 5 a lo que contenga la direcci√≥n apuntada por p1 */</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%i %i %i %p %p"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span>
</code></pre></div></div>

<p>En la pantalla se imprimir√° ‚Äú5 5 10‚Äù, que es el contenido de las variables a, b y c al terminar la ejecuci√≥n de este bloque de instrucciones, y la direcci√≥n a la que apuntan p1 y p2, que debe ser la misma. Observa que con <em>printf</em> y la cadena de formato ‚Äú%p‚Äù se puede mostrar la direcci√≥n de memoria de cualquier variable.</p>

<h3 id="945-punteros-y-arrays">9.4.5. Punteros y arrays</h3>

<h4 id="punteros-y-arrays-de-una-dimensi√≥n">Punteros y arrays de una dimensi√≥n</h4>

<p>Los punteros y los arrays tienen una relaci√≥n muy estrecha en C, ya que <strong>el nombre de un array es en realidad un puntero al primer elemento</strong> de ese array.</p>

<p>Es decir, si <em>x</em> es un array undimensional, la direcci√≥n del primer elemento puede ser expresada como <em>&amp;x[0]</em> o simplemente como <em>x</em>.</p>

<p>Y, del mismo modo, la direcci√≥n del elemento i-√©simo se puede expresar como <em>&amp;x[i]</em> o como <em>(x+i)</em>. En este caso, la expresi√≥n <em>(x+i)</em> no es una operaci√≥n aritm√©tica convencional, sino una operaci√≥n con punteros.</p>

<p>Si &amp;x[i] y (x+i) representan la direcci√≥n del i-√©simo elemento de x, podemos decir que x[i] y *(x+i) representan el <strong>contenido</strong> de esa direcci√≥n, es decir, el valor del i-√©simo elemento de x. Observa que la forma x[i] es la que hemos estado utilizando hasta ahora para acceder a los elementos de un vector.</p>

<p>Los arrays, por lo tanto, pueden utilizarse con √≠ndices o con punteros. Al programador suele resultarle mucho m√°s c√≥modo utilizar la forma x[i] para acceder al elemento i-√©simo de un array. Sin embargo, hay que tener en cuenta que la forma *(x+i) es mucho m√°s eficiente que x[i], por lo que suele preferirse cuando la velocidad del ejecuci√≥n es un factor determinante.</p>

<h4 id="punteros-y-arrays-multidimensionales">Punteros y arrays multidimensionales</h4>

<p>Un array multidimensional es en realidad una colecci√≥n de varios arrays unidimensionales (vectores). Por tanto, se puede definir un array multidimensional como un puntero a un grupo contiguo de arrays unidimensionales.</p>

<p>El caso m√°s simple de array de varias dimensiones es el bidimiensional. Supongamos que <em>x</em> es un array bidimensional de enteros con 10 filas y 20 columnas. Podemos declarar <em>x</em> de dos formas:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="mi">20</span><span class="p">];</span>   <span class="cm">/* Declaraci√≥n convencional */</span>
<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">)[</span><span class="mi">20</span><span class="p">];</span>    <span class="cm">/* Declaraci√≥n como puntero */</span>
</code></pre></div></div>
<p>En la segunda declaraci√≥n, <em>x</em> se define como un puntero a un grupo de array unidimensionales de 20 elementos enteros. As√≠ <em>x</em> apunta al primero de los arrays de 20 elementos, que es en realidad la primera fila (fila 0) del array bidimensional original. Del mismo modo (x+1) apunta al segundo array de 20 elementos, y as√≠ sucesivamente.</p>

<p>Por ejemplo, el elemento de la columna 2 y la fila 5 puede ser accedido de estas dos maneras:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">5</span><span class="p">];</span>      <span class="cm">/* Acceso convencional */</span>
<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">5</span><span class="p">);</span>  <span class="cm">/* Acceso mediante punteros */</span>
</code></pre></div></div>

<p>Esta instrucci√≥n parece muy complicada pero es f√°cil de desentra√±ar:</p>

<ul>
  <li>(x+2) es un puntero a la columna 2</li>
  <li>*(x+2) es el objeto de ese puntero y refiere a toda la columna. Como la columna 2 es un array unidimensional,  *(x+2) es realmente un puntero al primer elemento de la columna 2.</li>
  <li>(*(x+2)+5) es un puntero al elemento 5 de la columna 2.</li>
  <li>El objeto de este puntero <em>(</em>(x+2)+5) refiere al elemento 5 de la columna 2.</li>
</ul>

<h3 id="946-paso-de-punteros-como-par√°metros">9.4.6. Paso de punteros como par√°metros</h3>

<p>A menudo los punteros son <strong>pasados a las funciones como argumentos</strong>. Esto permite que datos de la porci√≥n de programa desde el que se llama a la funci√≥n sean accedidos por la funci√≥n, alterados dentro de ella y devueltos de forma alterada.</p>

<p>Este uso de los punteros se conoce como <strong>paso de par√°metros por variable o referencia</strong> y lo hemos estado utilizando hasta ahora sin saber muy bien lo que hac√≠amos.</p>

<p>Cuando los punteros son usados como argumento de una funci√≥n, es necesario tener cuidado con la declaraci√≥n y uso de los par√°metros dentro de la funci√≥n. Los argumentos formales que sean punteros deben ir precedidos por un asterisco. Observa detenidamente el siguiente ejemplo:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="kt">void</span> <span class="nf">funcion1</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">funcion2</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span>
  <span class="n">u</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">v</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="n">funcion1</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Despu√©s de la llamada a funcion1:  u=%d v=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
  <span class="n">funcion2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="p">,</span><span class="o">&amp;</span><span class="n">v</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Despu√©s de la llamada a funcion2:  u=%d v=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">funcion1</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span>	
<span class="p">{</span>
   <span class="n">u</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
   <span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">funcion2</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">pu</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pv</span><span class="p">)</span>
<span class="p">{</span>
   <span class="o">*</span><span class="n">pu</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
   <span class="o">*</span><span class="n">pv</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>La funci√≥n de <em>funcion1()</em> utiliza <strong>paso de par√°metros por valor</strong>. Cuando es invocada, los valores de las variables <em>u</em> y <em>v</em> del programa principal son <em>copiados</em> en los par√°metros <em>u</em> y <em>v</em> de la funci√≥n. Al modificar estos par√°metros dentro de la funci√≥n, el valor de u y v en el programa principal no cambia.</p>

<p>En cambio, <em>funcion2()</em> utiliza paso de par√°metros por por referencia. Lo que se pasa a la funci√≥n no es el <em>valor</em> de las variables sino su <em>direcci√≥n</em> de memoria, es decir, un puntero a las celdas de memoria donde <em>u</em> y <em>v</em> est√°n almacenadas. Dentro de la funci√≥n, se utiliza el operador asterisco para acceder al <em>contenido</em> de <em>pu</em> y <em>pv</em> y, en consecuencia, se altera el contenido de las posiciones de memoria apuntadas por <em>pu</em> y <em>pv</em>. El resultado es que las variables <em>u</em> y <em>v</em> del programa principal quedan modificadas.</p>

<p>Por lo tanto, la salida del programa debe ser:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Despu√©s de la llamada a funcion1:  u=1 v=3
Despu√©s de la llamada a funcion2:  u=0 v=0
</code></pre></div></div>

<p>¬øRecuerdas que la funci√≥n <em>scanf()</em> requiere que sus argumentos vayan precedidos por &amp;, mientras que <em>printf()</em> no lo necesita? Hasta ahora no pod√≠amos comprender por qu√©, pero ahora podemos dar una raz√≥n: <em>scanf()</em> necesita que sus argumentos vayan precedidos del s√≠mbolo &amp; porque necesita las direcciones de los datos que van a ser le√≠dos, para poder colocar en esas posiciones de memoria los datos introducidos por teclado. En cambio, printf() no necesita las direcciones, sino √∫nicamente los valores de los datos para poder mostrarlos en la pantalla.</p>

<p>Al estudiar los arrays y las estructuras ya vimos en detalle c√≥mo se deben pasar como par√°metros a las funciones. Recuerda que los arrays siempre se pasan por variable y no es necesario usar el s√≠mbolo &amp; en la llamada, ya que el propio nombre del array se refiere, en realidad, a la direcci√≥n del primer elemento.</p>

<h3 id="947-devoluci√≥n-de-punteros">9.4.7. Devoluci√≥n de punteros</h3>

<p>Una funci√≥n tambi√©n puede devolver un puntero. Para hacer esto, la declaraci√≥n de la funci√≥n debe indicar que devolver√° un puntero. Esto se realiza precediendo el nombre de la funci√≥n con un asterisco. Por ejemplo:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="o">*</span><span class="n">pf</span><span class="p">;</span>
<span class="n">pf</span> <span class="o">=</span> <span class="n">funcion</span><span class="p">(</span><span class="n">argumentos</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%lf"</span><span class="p">,</span> <span class="o">*</span><span class="n">pf</span><span class="p">);</span>
</code></pre></div></div>

<p>Cuando esta funci√≥n sea invocada, devolver√° un puntero a un dato de tipo double, y por lo tanto debe ser asignada a una variable de ese tipo. Por ejemplo, as√≠:</p>

<h3 id="948-punteros-a-punteros">9.4.8. Punteros a punteros</h3>

<p>Un √∫ltimo aspecto (a la vez confuso y potente) de los punteros es la posibilidad de definir punteros que, a su vez, apunten a otros punteros. Esto no es un trabalenguas, sino que, t√©cnicamente, se denomina <strong>indirecci√≥n m√∫ltiple</strong>.</p>

<p>Por ejemplo, el resultado del siguiente fragmento de c√≥digo en C debe ser que se imprima el n√∫mero 15 en la pantalla:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">p1</span><span class="p">;</span>      <span class="cm">/* puntero a un n√∫mero entero */</span>
<span class="kt">int</span><span class="o">**</span> <span class="n">p2</span><span class="p">;</span>     <span class="cm">/* puntero a un puntero de n√∫meros enteros */</span>
<span class="n">p1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">;</span>	     <span class="cm">/* p1 contiene la direcci√≥n de n */</span>
<span class="n">p2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p1</span><span class="p">;</span>	  <span class="cm">/* p2 contiene la direcci√≥n de p1 */</span>
<span class="o">**</span><span class="n">p2</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>    
<span class="n">printf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="949-gesti√≥n-din√°mica-de-la-memoria-arrays-din√°micos">9.4.9. Gesti√≥n din√°mica de la memoria: arrays din√°micos</h3>

<p>Seg√∫n hemos visto hasta ahora, la memoria reservada para cada variable se define en el momento de escribir el c√≥digo del programa.</p>

<p>Por ejemplo, si declaramos una variable de tipo <em>int</em>, √©sta tendr√° asignados 2 o 4 bytes de memoria (esa cantidad puede variar dependiendo del compilador y del sistema operativo). Entonces, si declaramos un array de 100 n√∫meros enteros, el array tendr√° reservados 200 o 400 bytes de memoria.</p>

<p><em>¬øPero qu√© ocurre si no sabemos de antemano cu√°ntos elementos puede llegar a tener el array?</em></p>

<p>Por ejemplo, imaginemos un problema consistente en leer por teclado (u otro dispositivo de entrada) una cantidad indefinida de n√∫meros para almacenarlos en un array y luego hacer ciertas operaciones con ellos. ¬øDe qu√© tama√±o podemos definir el array? ¬øDe 100 elementos? ¬øY si el usuario introduce 101 elementos?</p>

<p>Para estas situaciones, que son muy frecuentes, existe la <strong>asignaci√≥n din√°mica de memoria</strong>, que consiste en reservar memoria para las variables en tiempo de ejecuci√≥n, es decir, mientras el programa est√° funcionando. As√≠, es posible ‚Äúestirar‚Äù o ‚Äúencoger‚Äù sobre la marcha el espacio reservado para el array, dependiendo de las necesidades de cada momento.</p>

<p>Veremos enseguida que, para manejar la memoria din√°micamente, es imprescindible <strong>el uso de punteros</strong>. De hecho, este es uno de los grandes frutos que vamos a obtener de ellos.</p>

<p>Como los arrays son la estructura de datos m√°s simple y f√°cil de entender, vamos a centrarnos en crear y manipular <strong>arrays din√°micos</strong>, pero los principios que veamos aqu√≠ son aplicables a cualquier otra estructura din√°mica simple, como pilas, listas o colas, o complejas, como √°rboles o grafos.</p>

<h4 id="reserva-de-memoria-con-malloc">Reserva de memoria con <em>malloc()</em></h4>

<p>Ya que un nombre de array es en realidad un puntero a su primer elemento, es posible definir un array como una variable puntero en vez de como un array convencional. As√≠, estas dos definiciones sirven para un vector de n√∫meros enteros:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">vector1</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">vector2</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>El <em>vector1</em> se define del modo convencional de un array. Esto produce la reserva de un bloque fijo de memoria al empezar la ejecuci√≥n del programa lo suficientemente grande como para almacenar 100 n√∫meros enteros.</li>
  <li>El <em>vector2</em> se define como puntero a entero. En este caso, no se reserva ninguna cantidad de memoria para almacenar los n√∫meros enteros.</li>
</ul>

<p>Si intentamos acceder a los elementos de los vectores obtendremos resultados diferentes:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector1</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">83</span><span class="p">;</span>
<span class="n">vector2</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>	<span class="cm">/* Esto es un error */</span>
</code></pre></div></div>

<p>La primera asignaci√≥n funcionar√° correctamente, ya que el quinto elemento del <em>vector1</em> tiene un espacio de memoria asignado. La segunda asignaci√≥n producir√° un efecto impredecible, ya que <em>vector2</em> no tiene ning√∫n espacio de memoria asignado y, por lo tanto, el dato 27 se escribir√° en una posici√≥n de memoria correspondiente a otro dato u otro programa. La consecuencia puede llegar a ser bastante desagradable.</p>

<p>Se necesita, pues, reservar un fragmento de memoria antes de que los elementos del array sean procesados. Tales tipos de reserva se realizan mediante la <strong>funci√≥n <em>malloc()</em></strong> o alguna de sus variedades. Observa bien su uso en este ejemplo:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span> <span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</code></pre></div></div>

<p>La funci√≥n <em>malloc()</em> reserva un especio de memoria consistente en 100 veces el tama√±o de un n√∫mero entero. F√≠jate bien en el uso del <em>sizeof(int)</em>: se trata de un operador unario que devuelve el tama√±o de un tipo de dato cualquiera, tanto simple como complejo.</p>

<p>Suponiendo que <em>sizeof(int)</em> fuera 2 (es decir, que cada n√∫mero de tipo int ocupase 2 bytes), lo que se le est√° pidiendo a <em>malloc()</em> es que reserve 100 * 2 bytes, es decir, 200 bytes de memoria.</p>

<p>Adem√°s, es necesario usar el <strong>molde (int *)</strong>, ya que malloc() devuelve un puntero sin tipo (es decir, un puntero a <em>void</em>), as√≠ que hay que convertirlo a puntero a entero antes de asignarlo a la variable x, que efectivamente es un puntero a entero.</p>

<p>De esta manera, la variable <em>vector2</em> pasa a ser un <strong>array din√°mico</strong>: se comporta como un array y puede usarse como tal, pero su tama√±o ha sido definido durante la ejecuci√≥n del programa. Y m√°s adelante, en el mismo programa, podemos redefinir el tama√±o del array para acortarlo o alargarlo.</p>

<p>Si la funci√≥n <em>malloc()</em> falla devolver√° un puntero a NULL. Utilizar un puntero a NULL es la forma m√°s segura de hacer explotar tu programa, as√≠ que siempre debemos comprobar que el puntero devuelto es correcto. Una vez hecho esto, podemos utilizar x con toda tranquilidad como si fuera un array de 100 n√∫meros enteros. Por ejemplo:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span> <span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Error en la asignaci√≥n de memoria"</span><span class="p">);</span>
<span class="k">else</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Se ha reservado con √©xito espacio para 100 n√∫meros"</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"Introduzca un n√∫mero:"</span><span class="p">);</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="liberaci√≥n-de-memoria-con-free">Liberaci√≥n de memoria con <em>free()</em></h4>

<p>El programador debe tener dos precauciones b√°sicas a la hora de manejar la memoria din√°micamente:</p>

<ul>
  <li><strong>Asignar memoria</strong> a un puntero antes de usarlo con <em>malloc()</em> u otra funci√≥n similar</li>
  <li><strong>Liberar la memoria asignada</strong>, cuando ya no va a usarse m√°s, con <em>free()</em> u otra funci√≥n similar.</li>
</ul>

<p>Si no se libera la memoria asignada a un puntero, te√≥ricamente no ocurre nada grave, salvo que podemos terminar por agotar la memoria disponible si reservamos continuamente y nunca liberamos.</p>

<p>Es, en cualquier caso, una costumbre muy saludable.</p>

<p>Para liberar la memoria reservada previamente con <em>malloc()</em> u otra funci√≥n de su misma familia, se utiliza la funci√≥n <em>free()</em>. Observa su uso en este ejemplo:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span> <span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="p">...</span> <span class="n">instrucciones</span> <span class="n">de</span> <span class="n">manipulaci</span><span class="err">√≥</span><span class="n">n</span> <span class="n">de</span> <span class="n">x</span> <span class="p">...</span>
<span class="n">free</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</code></pre></div></div>

<p>Toda la memoria reservada con <em>malloc()</em> quedar√° liberada despu√©s de hacer <em>free()</em> y se podr√° utilizar para guardar otros datos o programas. El puntero <em>x</em> quedar√° apuntado a NULL y no debe ser utilizado hasta que se le asigne alguna otra direcci√≥n v√°lida.</p>

<h4 id="funciones-b√°sicas-para-la-gesti√≥n-din√°mica-de-la-memoria">Funciones b√°sicas para la gesti√≥n din√°mica de la memoria</h4>

<p>Adem√°s de <em>malloc()</em> y <em>free()</em> existen otras funciones similares pero con peque√±as diferencias. A continuaci√≥n resumimos las m√°s usuales y mostramos un ejemplo de su uso.</p>

<p>Pero antes haremos una advertencia: todas las funciones de reserva de memoria devuelven un puntero a NULL si no tienen √©xito. Por lo tanto, deben ir seguidas de un condicional que compruebe si el puntero apunta a NULL antes de utilizarlo.</p>

<ul>
  <li>
    <p><strong>calloc()</strong>: Reserva un bloque de memoria para almacenar num elementos de tam bytes y devuelve un puntero void al comienzo del bloque.</p>

    <p>El siguiente ejemplo reserva espacio para 35 n√∫meros enteros:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
 <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">35</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>free()</strong>: Libera el bloque de memoria apuntado por un puntero y que previamente hab√≠a sido reservado.</p>
  </li>
  <li>
    <p><strong>malloc()</strong>: Reserva un bloque de memoria de tam bytes y devuelve un puntero void al comienzo del mismo. Por ejemplo, para reservar espacio para una cadena de 100 caracteres:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">char</span><span class="o">*</span> <span class="n">texto</span><span class="p">;</span>
 <span class="n">texto</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>realloc()</strong>: Cambia el tama√±o de un bloque de memoria apuntado por puntero. Dicho bloque ha debido ser previamente asignado con malloc() u otra funci√≥n similar. El nuevo tama√±o ser√° de tam bytes. Devuelve un puntero void al comienzo del bloque.</p>

    <p>En el siguiente ejemplo, se reserva espacio para 100 caracteres, pero luego se modifica el tama√±o del bloque para dar cabida hasta 500 caracteres:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">char</span><span class="o">*</span> <span class="n">texto</span><span class="p">;</span>
 <span class="n">texto</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
 <span class="cm">/* Aqu√≠ ir√≠an las instrucciones que utilicen el puntero texto
    con un tama√±o de 100 caracteres */</span>
 <span class="n">texto</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">realloc</span><span class="p">(</span><span class="n">texto</span><span class="p">,</span> <span class="mi">500</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
 <span class="cm">/* A partir de aqu√≠, el mismo puntero texto puede usarse para
    manejar hasta 500 caracteres */</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="9410-librer√≠as-no-est√°ndar-que-molan-ncurses">9.4.10. Librer√≠as no est√°ndar que molan: ncurses</h3>

<p>Adem√°s de las librer√≠as est√°ndar ANSI, existen muchas (¬°much√≠simas!) librer√≠as de terceros que se pueden usar en nuestros programas. Las que vamos a ver a continuaci√≥n nos permitir√°n introducir colores, sonidos y movimientos en nuestros programas, pero debes tener presente una cosa: al no ser librer√≠as est√°ndar, los programas creados con estas librer√≠as ser√°n m√°s dif√≠cilmente portables a otros sistemas.</p>

<h4 id="qu√©-es-ncurses">Qu√© es Ncurses</h4>

<p><strong>Ncurses</strong> es una <strong>librer√≠a para el manejo de interfaces basadas en texto</strong>.</p>

<p>Es decir, se trata de un conjunto de funciones ya programadas que podemos utilizar en nuestros programas de texto para mejorar su aspecto. Con Ncurses podemos a√±adir colores, escribir en cualquier parte de la pantalla o borrar caracteres concretos. Por ejemplo, este programa para generar y resolver sudokus est√° escrito con Ncurses:</p>

<p><img src="/docs/prog-y-3d/_site/assets/images/05-ncurses.png" alt="Ejemplo de programa escrito con Ncurses" /></p>

<p>Desde luego, la pantalla anterior ser√≠a imposible de obtener con las librer√≠as est√°ndar de C.</p>

<h4 id="compilaci√≥n-y-enlace">Compilaci√≥n y enlace</h4>

<p>Como Ncurses no es una librer√≠a est√°ndar, es necesario ordenar al compilador que la enlace con nuestro programa.</p>

<p>Si compilas desde la consola, esto se hace a√±adiendo la opci√≥n ‚Äìlncurses al comando <em>gcc</em>. Por ejemplo:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">gcc holamundo.c</code>: compila holamundo.c sin enlazarlo con la librer√≠a Ncurses</li>
  <li><code class="language-plaintext highlighter-rouge">gcc -lncurses holamundo.c</code>: compila holamundo.c enlaz√°ndolo con Ncurses</li>
</ul>

<p>Si trabajas desde desde Visual Studio Code y tienes la librer√≠a Ncurses instalada en tu sistema, no es necesario que hagas nada en especial. Un simple <code class="language-plaintext highlighter-rouge">#include &lt;ncurses.h&gt;</code> bastar√° para poder usar la librer√≠a.</p>

<p>Ncurses tiene much√≠simas funciones, pero nosotros s√≥lo nos referiremos aqu√≠ a las m√°s b√°sicas, que nos permitir√°n a√±adir color a nuestros textos y controlar libremente la posici√≥n del cursor de escritura. Pero Ncurses va mucho m√°s all√°, permitiendo la creaci√≥n de capas de texto superpuestas, men√∫s desplegables y muchas otras cosas en la consola de texto.</p>

<h4 id="inicializaci√≥n-de-ncurses">Inicializaci√≥n de Ncurses</h4>

<p>Para utilizar las funciones de Ncurses en nuestro programa, basta con que incluyamos la siguiente llamada:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">initscr</span><span class="p">();</span>
</code></pre></div></div>

<p>Esta funci√≥n crea una ventana de texto. La ventana se llama <em>stdscr</em> (que significa ‚Äústandard screen‚Äù, es decir, ‚Äúpantalla est√°ndar‚Äù). A partir de aqu√≠ podremos utilizar cualquier funci√≥n de Ncurses, pues todas act√∫an sobre esa ventana (se pueden crear varias ventanas sobre stdscr, pero nosotros no profundizaremos en esa posibilidad). Por ejemplo, una funci√≥n que suele ir justo despu√©s es:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">keypad</span> <span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>Esto sirve para activar la recepci√≥n de teclas especiales (como F1, F2, ESC, etc). Si no llamamos a keypad(), no podremos utilizar ese tipo de teclas en nuestro programa. El segundo par√°metro sirve para activar (1) o desactivar (0) la recepci√≥n de teclas especiales.</p>

<p>A continuaci√≥n te dejo una lista con las principales funciones de inicializaci√≥n de Ncurses:</p>

<ul>
  <li><strong>initscr()</strong>. Inicializa Ncurses y crea la pantalla est√°ndar. Debe ser invocada antes que cualquier otra funci√≥n de la librer√≠a.</li>
  <li><strong>keypad()</strong>. Activa / desactiva la recepci√≥n de teclas especiales, como F1, ESC, Intro, etc. Si activar = 1, se activa la recepci√≥n. Si activar = 0, se desactiva.</li>
  <li><strong>echo()</strong> y <strong>noecho()</strong>. Activa / desactiva el eco de caracteres. Si el eco est√° activo, lo que se escriba en el teclado aparece en la pantalla. Si est√° inactivo, no.</li>
  <li><strong>cbreak()</strong> y <strong>nocbreak()</strong>. Activa / desactiva el env√≠o inmediato de teclas. Normalmente, cuando se teclea algo no es enviado al programa hasta que no se pulsa ‚Äúintro‚Äù. La funci√≥n cbreak() hace que todo cuanto se teclee sea enviado al programa sin necesidad de ‚Äúintro‚Äù. La funci√≥n nocbreak() desactiva este comportamiento</li>
  <li>
    <p><strong>nodelay(stdscr)</strong>. Activa / desactiva la espera para lectura de teclado. Las funciones para leer un solo car√°cter, como getch(), detienen la ejecuci√≥n del programa hasta que se pulsa alguna tecla. Llamando a esta funci√≥n con el par√°metro activar = 1, conseguiremos que el programa no se detenga en getch() aunque no se pulse tecla alguna. Para desactivarlo, llamaremos a la funci√≥n con activar = 0.</p>
  </li>
  <li><strong>endwin()</strong>. Finaliza Ncurses. Hay que llamar a esta funci√≥n antes de terminar el programa para liberar la memoria ocupada y restaurar la consola al estado inicial.</li>
</ul>

<h4 id="escribir-y-leer-con-ncurses">Escribir y leer con ncurses</h4>

<p>Cuando utilicemos Ncurses debemos olvidarnos de las funciones de entrada/salida est√°ndar, como <em>scanf()</em>, <em>printf()</em>, <em>gets()</em> o <em>puts()</em>. En su lugar usaremos estas otras funciones:</p>

<ul>
  <li><strong>printw()</strong> y <strong>putstr()</strong>. Para escribir usaremos la funci√≥n <em>printw()</em>, que funciona igual que <em>printf()</em> pero sobre una ventana de Ncurses. Tambi√©n podemos usar <em>putstr()</em>, que es como <em>puts()</em>, es decir, sirve para imprimir cadenas</li>
  <li><strong>getstr()</strong> y <strong>getch()</strong>. Para leer disponemos de <em>getstr()</em>, que es como <em>gets()</em>, es decir, sirve para leer cadenas por teclado. De modo que, si queremos leer un n√∫mero, debemos leerlo como cadena y luego convertirlo a n√∫mero (con las funciones est√°ndar <em>atoi()</em>, <em>atof()</em>, etc). Tambi√©n podemos usar <em>getch()</em>, que lee un √∫nico car√°cter.</li>
  <li><strong>move()</strong>. Posiciona el cursor de texto en la columna x y la fila y de la pantalla. ¬°Atenci√≥n! Se indica primero la fila y luego la columna.</li>
  <li><strong>refresh()</strong>. Actualiza la pantalla. Es el √∫nico modo de asegurarnos de que los cambios realizados se muestren instant√°neamente. Si no, Ncurses decidir√° cu√°ndo actualizar la pantalla por su cuenta, y te aseguro que no lo hace continuamente.</li>
</ul>

<h4 id="dar-color-a-nuestro-texto">Dar color a nuestro texto</h4>

<p>Antes de utilizar los colores en la terminal de texto hay que inicializarlos llamando a la funci√≥n <em>start_color()</em> sin argumentos, as√≠:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">has_colors</span><span class="p">())</span>
  <span class="n">start_color</span><span class="p">();</span>
</code></pre></div></div>

<p>La llamada previa a <em>has_colors()</em> se realiza para asegurarnos de que nuestra consola soporta el uso de colores. Es raro encontrar una consola que no permita colores, pero existen, as√≠ que no est√° de m√°s hacer la comprobaci√≥n.</p>

<p>Una vez hecho esto, podemos utilizar los colores b√°sicos definidos en <em>ncurses.h</em>, cuyas constantes son COLOR_BLACK, COLOR_WHITE, COLOR_YELLOW, etc.</p>

<p>Para utilizar esos colores se deben agrupar en parejas: un color para el texto junto con un color para el fondo. A cada pareja se le asigna un n√∫mero a trav√©s de la funci√≥n <em>init_pair()</em>. Por ejemplo:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">init_pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">COLOR_YELLOW</span><span class="p">,</span> <span class="n">COLOR_BLUE</span><span class="p">);</span>
</code></pre></div></div>

<p>Esto define a la <em>pareja de colores n¬∫ 1</em> como <em>texto amarillo sobre fondo azul</em>. De este modo podemos definir, por lo general, hasta 64 parejas.</p>

<p>Despu√©s, para <strong>activar una pareja de color</strong>, haremos esta llamada:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">attron</span><span class="p">(</span><span class="n">COLOR_PAIR</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</code></pre></div></div>

<p>Esto activa la pareja de colores n¬∫ 1, de manera que todo el texto que aparezca en la pantalla a partir de este momento se ver√° amarillo con el fondo azul.</p>

<p>La funci√≥n <em>attron()</em>, adem√°s de para activar parejas de colores, sirve para cambiar otros atributos del texto. Por ejemplo, lo siguiente se utiliza para escribir en <strong>negrita</strong>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">attron</span><span class="p">(</span><span class="n">A_BOLD</span><span class="p">);</span>
</code></pre></div></div>

<p>Puedes obtener m√°s informaci√≥n sobre attron() en las p√°ginas de manual (escribiendo <code class="language-plaintext highlighter-rouge">$ man attron</code> en la consola) o en internet (por ejemplo, <a href="https://linux.die.net/man/3/attron">aqu√≠</a>).</p>

<h4 id="ejemplo-de-uso-de-ncurses">Ejemplo de uso de Ncurses</h4>

<p>Para terminar esta breve introducci√≥n a la librer√≠a Ncurses mostraremos un ejemplo ilustrativo del uso de algunas de las funciones que aqu√≠ se han visto.</p>

<p>El siguiente programa utiliza Ncurses para escribir el texto HOLA en color rojo sobre fondo azul y el texto MUNDO en color amarillo sobre fondo verde. El texto HOLA aparece en la l√≠nea 11, y MUNDO en la 12. Luego, el programa espera hasta que se pulsa la tecla ‚Äúflecha arriba‚Äù, y entonces termina.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;ncurses.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">car</span><span class="err">√°</span><span class="n">cter</span><span class="p">;</span>
  <span class="n">initscr</span><span class="p">();</span>         <span class="c1">// Inicializa Ncurses</span>
  <span class="n">keypad</span><span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// Activa teclas especiales (como las flechas)</span>
  <span class="n">cbreak</span><span class="p">();</span>          <span class="c1">// Para no tener que pulsar Intro tras cada car√°cter </span>
  <span class="k">if</span> <span class="p">(</span><span class="n">has_colors</span><span class="p">())</span> <span class="n">start_color</span><span class="p">();</span>         <span class="c1">// Inicializa colores</span>
  <span class="n">init_pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">COLOR_RED</span><span class="p">,</span> <span class="n">COLOR_BLUE</span><span class="p">);</span>     <span class="c1">// Pareja 1 = Texto rojo, fondo azul</span>
  <span class="n">init_pair</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">COLOR_YELLOW</span><span class="p">,</span> <span class="n">COLOR_GREEN</span><span class="p">);</span> <span class="c1">// Pareja 2 = Texto amarillo, fondo verde</span>
  <span class="n">attron</span><span class="p">(</span><span class="n">COLOR_PAIR</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>    <span class="c1">// Activa pareja 1</span>
  <span class="n">move</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">printw</span><span class="p">(</span><span class="s">"HOLA"</span><span class="p">);</span>
  <span class="n">attron</span><span class="p">(</span><span class="n">COLOR_PAIR</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>    <span class="c1">// Activa pareja 2</span>
  <span class="n">move</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">printw</span><span class="p">(</span><span class="s">"MUNDO"</span><span class="p">);</span>
  <span class="k">do</span>
  <span class="p">{</span>  
       <span class="n">car</span><span class="err">√°</span><span class="n">cter</span> <span class="o">=</span> <span class="n">getch</span><span class="p">();</span>  <span class="c1">// Lee un car√°cter desde el teclado</span>
  <span class="p">}</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">car</span><span class="err">√°</span><span class="n">cter</span> <span class="o">!=</span> <span class="n">KEY_UP</span><span class="p">);</span>
  <span class="n">endwin</span><span class="p">();</span>  <span class="c1">// Finaliza Ncurses</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="9411-librer√≠as-no-est√°ndar-que-molan-sdl">9.4.11. Librer√≠as no est√°ndar que molan: SDL</h3>

<p><strong>SDL</strong> (iniciales de <em>Single DirectMedia Layer</em>) es una biblioteca de C libre y disponible para m√∫ltiples plataformas (entre ellas, Linux y Windows). Puedes bajarte la √∫ltima versi√≥n de <a href="http://www.libsdl.org">http://www.libsdl.org</a>.</p>

<p>Esta biblioteca contiene un conjunto muy completo de funciones para manejar gr√°ficos, adem√°s de sonidos y distintos dispositivos multimedia (rat√≥n, CD-ROM, etc). Muchos programas escritos en C (en particular, videojuegos) se han desarrollado con SDL. Adem√°s, la librer√≠a es razonablemente sencilla de usar.</p>

<p>La siguiente captura pertenece a un juego llamado <em>Unknown Horizons</em>, desarrollado en 2008 con la librer√≠a SDL y cuya √∫ltima versi√≥n es del a√±o 2019. Puedes encontrar en internet muchos otros ejemplos de programas escritos con SDL, tanto antiguos como recientes:</p>

<p><img src="/docs/prog-y-3d/_site/assets/images/05-sdl-example.png" alt="Ejemplo de juego desarrollado con SDL" /></p>

<p>Nosotros s√≥lo nos vamos a centrar en la parte de SDL dedicada a los gr√°ficos. Si quieres m√°s informaci√≥n, en la p√°gina web rese√±ada antes encontrar√°s una completa documentaci√≥n.</p>

<p><em>NOTA IMPORTANTE: todo lo que sigue se refiere a la versi√≥n 1.2 de la librer√≠a SDL. La versi√≥n m√°s reciente podr√≠a tener algunas peque√±as diferencias que debes consultar en la documentaci√≥n.</em></p>

<h4 id="instalaci√≥n-de-sdl">Instalaci√≥n de SDL</h4>

<p>SDL no es una librer√≠a C est√°ndar, es decir, no viene ‚Äúde serie‚Äù con el compilador de C. En realidad, tampoco <em>ncurses</em> lo es, pero su uso est√° tan extendido en entornos Unix que viene incorporada a las librer√≠as del compilador gcc.</p>

<p>En cambio, la librer√≠a SDL debe ser instalada antes de poder utilizarla. A continuaci√≥n describimos el proceso de instalaci√≥n en Linux y en Windows</p>

<p>Existen dos paquetes de SDL: el <em>runtime</em>, necesario para ejecutar aplicaciones que usen SDL, y el <em>development</em>, necesario para escribir y compilar programas que usen SDL. Nosotros necesitaremos los dos, claro.</p>

<p><strong>Instalaci√≥n de SDL en Linux</strong></p>

<ul>
  <li>
    <p>Instala el paquete <strong>libSDLX.X-dev</strong> (X.X es el n√∫mero de la versi√≥n; por ejemplo, puede ser 1.2) desde la tienda de aplicaciones de tu distribuci√≥n Linux. Eso ser√° suficiente para que se instalen los paquetes de desarrollo y de <em>runtime</em>.</p>
  </li>
  <li>
    <p>Si estos paquetes no estuvieran en tu repositorio (algo muy raro), puedes baj√°rtelos de <a href="https://libsdl.org">libsdl.org</a> e instalarlos manualmente. Consulta el manual de tu Linux para aprender a hacer esto √∫ltimo.</p>
  </li>
  <li>
    <p>Adem√°s, puedes necesitar paquetes adicionales. Los m√°s habituales son <strong>libSDL-imageX.X-dev</strong> (para manipular im√°genes), <strong>libSDL-ttfX-X-dev</strong> (para manejar fuentes y renderizar textos) y <strong>libSDL-mixerX.X-dev</strong> (para utilizar sonidos). Ten en cuenta que los nombres de los paquetes pueden variar ligeramente dependiendo de tu distribuci√≥n de Linux.</p>
  </li>
  <li>
    <p>Para instalar todos estos paquetes de SDL 1.2 en una distribuci√≥n como Ubuntu, puedes usar este comando:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ sudo apt update
$ sudo apt install libsdl1.2-dev libsdl-image1.2-dev libsdl-ttf1.2-dev libsdl-mixer1.2-dev
</code></pre></div>    </div>

    <p>Si tu distribuci√≥n no usa apt como gestor de paquetes, tendr√°s que buscar en la documentaci√≥n de la misma c√≥mo instalar paquetes de los respositorios.</p>
  </li>
</ul>

<p><strong>Instalaci√≥n de SDL en Windows</strong></p>

<ul>
  <li>
    <p>B√°jate la √∫ltima versi√≥n de la librer√≠a de la web de SDL. Necesitar√°s la librer√≠a de v√≠nculos din√°micos (denominada dll), que es el <em>runtime</em> para Windows, y el paquete de desarrollo.</p>
  </li>
  <li>
    <p>La librer√≠a de v√≠nculos din√°micos suele venir comprimida en un archivo cuyo nombre es similar a: SDL-x.x.x.zip, donde ‚Äúx.x.x‚Äù es la versi√≥n de la liber√≠a. Existir√°n varios paquetes de desarrollo para varios compiladores. Mi consejo es que bajes el que est√° preparado para el compilador de GNU, cuyo nombre es SDL-devel-x.x.x-mingw32.tar o algo similar.</p>
  </li>
  <li>
    <p>Descomprime la librer√≠a de v√≠nculos din√°micos. Debes obtener un archivo llamado sdl.dll. Copia este archivo al directorio /windows/system32, o bien ub√≠calo en la misma carpeta en la que se encuentre el programa que est√°s escribiendo.</p>
  </li>
  <li>
    <p>Descomprime el paquete de desarrollo. Encontrar√°s varios directorios y, dentro de ellos, multitud de archivos. Copia los archivos en los directorios del mismo nombre de tu compilador. Por ejemplo, el copia el directorio ‚Äúinclude‚Äù del paquete de desarrollo al directorio ‚Äúinclude‚Äù de la carpeta donde est√© instalado tu compilador. Repite la operaci√≥n para todos los directorios cuyo nombre coincida.</p>
  </li>
  <li>
    <p>Si vas a usar otras librer√≠as auxiliares, como <em>image</em>, <em>ttf</em> o <em>mixer</em> (para manipular im√°genes, fuentes y sonidos con SDL), repite el proceso con cada una de ellas.</p>
  </li>
</ul>

<h4 id="compilaci√≥n-y-enlace-de-sdl">Compilaci√≥n y enlace de SDL</h4>

<p>Al no ser SDL una librer√≠a est√°ndar, el enlace entre nuestro programa y las funciones de SDL no se produce autom√°ticamente. Hay que indicarle al enlazador (o linker) lo que debe hacer.</p>

<p>Para empezar, como con cualquier librer√≠a, tienes que incluirla en tu c√≥digo fuente, as√≠:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;SDL/SDL.h&gt;</span><span class="cp">
</span></code></pre></div></div>

<p>Si usas otras librer√≠as auxiliares de SDL, como SDL-mixer, tambi√©n tendr√°s que incluir el archivo de cabecera. Por ejemplo:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;SDL/SDL_mixer.h&gt;</span><span class="cp">
</span></code></pre></div></div>

<p>Luego, durante la compilaci√≥n, tienes que indicar al compilador que enlace tu programa con la librer√≠a SDL. Si est√°s compilando desde la l√≠nea de comandos esto se hace as√≠:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ gcc mi_programa.c -o mi_ejecutable -lSDL
</code></pre></div></div>

<p>Si est√°s usando otras librer√≠as, como SDL_mixer, tendr√°s que a√±adirlas tambi√©n:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ gcc mi_programa.c -o mi_ejecutable -lSDL -lSDL_mixer
</code></pre></div></div>

<p>En cambio, si para compilar utilizas <strong>Visual Studio Code</strong> con la extensi√≥n <strong>Code Runner</strong>, tendr√°s que agregar ‚Äú-lSDL‚Äù a la lista de argumentos de la tarea de compilaci√≥n. Para eso, abre el archivo <strong><em>.json</em></strong> que encontrar√°s en el directorio <strong><em>.vscode</em></strong> de tu proyecto. Encontrar√°s algo como esto:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"configurations"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="p">{</span><span class="w">
            </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Linux"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"includePath"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
                </span><span class="s2">"${workspaceFolder}/**"</span><span class="w">
            </span><span class="p">],</span><span class="w">
            </span><span class="nl">"defines"</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span><span class="w">
            </span><span class="nl">"compilerPath"</span><span class="p">:</span><span class="w"> </span><span class="s2">"/usr/bin/gcc"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"cStandard"</span><span class="p">:</span><span class="w"> </span><span class="s2">"gnu17"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"cppStandard"</span><span class="p">:</span><span class="w"> </span><span class="s2">"gnu++17"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"intelliSenseMode"</span><span class="p">:</span><span class="w"> </span><span class="s2">"linux-gcc-x64"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"compilerArgs"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
                </span><span class="s2">"-lSDL"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"-lSDL_mixer"</span><span class="w">
            </span><span class="p">]</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">],</span><span class="w">
    </span><span class="nl">"version"</span><span class="p">:</span><span class="w"> </span><span class="mi">4</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Mira en la secci√≥n ‚ÄúcompilerArgs‚Äù. Si esa secci√≥n no existe o existe pero no contiene la l√≠nea ‚Äú-lSDL‚Äù, a√±√°dela. Si necesitas otras librer√≠as, como SDL-mixer, a√±√°dela tambi√©n. Guarda el archivo y reinicia Visual Studio Code.</p>

<p>Si utilizas otro entorno de desarrollo distinto de Visual Studio Code, u otra extensi√≥n distinta de Code Runner dentro de Visual Studio Code, el proceso debe ser muy parecido, pero tendr√°s que mirar la documentaci√≥n de ese entorno o de esa extensi√≥n para ver los detalles.</p>

<h4 id="inicializaci√≥n-y-terminaci√≥n-de-la-pantalla-gr√°fica">Inicializaci√≥n y terminaci√≥n de la pantalla gr√°fica</h4>

<p>Una vez instalada la liber√≠a y preparado el compilador, podemos usar las funciones de SDL como cualquier otra funci√≥n est√°ndar de C. Su uso es exactamente igual en Windows y en Linux, por lo que el programa que obtendremos deber√≠a compilar sin necesidad de hacerle ning√∫n cambio en ambos sistemas.</p>

<p>Para usar los gr√°ficos, hay que hacer un <code class="language-plaintext highlighter-rouge">#include &lt;SDL/SDL.h&gt;</code> en el archivo fuente, como es natural. Aparece dos veces el nombre ‚ÄúSDL‚Äù porque el archivo SDL.h est√° dentro de una carpeta llamada SDL.</p>

<p>Lo siguiente que hay que hacer es <strong>inicializar la pantalla gr√°fica</strong>. Para eso disponemos de dos funciones: <em>SDL_Init()</em> y <em>SDL_SetVideoMode()</em>:</p>

<ul>
  <li>
    <p><strong><em>SDL_Init()</em></strong>. Debe ser la primera funci√≥n en invocarse. No se puede usar ninguna otra funci√≥n de SDL si antes no se ha llamado a esta. Hay que pasarle un par√°metro que indica qu√© tipo de sistema multimedia queremos manejar (la tarjeta de v√≠deo, la de sonido, el CD-ROM, etc). En nuestro caso ser√° la tarjeta de v√≠deo, ya que s√≥lo nos interesa manipular gr√°ficos. La constante para ello es SDL_INIT_VIDEO:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">SDL_Init</span><span class="p">(</span><span class="n">SDL_INIT_VIDEO</span><span class="p">);</span>
</code></pre></div>    </div>

    <p>La fuci√≥n SDL_Init() devuelve ‚Äì1 si ocurre alg√∫n error al iniciar el sistema de gr√°ficos. En ese caso, el programa no podr√° continuar, de modo que debemos comprobar el valor devuelto por SDL_Init().</p>
  </li>
  <li>
    <p><strong><em>SDL_SetVideoMode()</em></strong>. Esta debe ser la segunda funci√≥n en invocarse, justo a continuaci√≥n de SDL_Init(). Sirve para establecer el tipo de pantalla gr√°fica que queremos. Hay que indicarle el tama√±o en p√≠xels, el n√∫mero de bits de color y los atributos de la pantalla. Por ejemplo:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">SDL_SetVideoMode</span><span class="p">(</span><span class="mi">1200</span><span class="p">,</span> <span class="mi">960</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="n">SDL_ANYFORMAT</span> <span class="o">|</span> <span class="n">SDL_DOUBLEBUFFER</span><span class="p">);</span>
</code></pre></div>    </div>

    <p>Esto crea una ventana gr√°fica de 1200x960 p√≠xeles, con 24 bits de profundidad de color. El √∫ltimo par√°metro, <em>SDL_ANYFORMAT</em>, es una constante que indica a SDL que puede seleccionar otra profundidad de color si la elegida no est√° disponible. Este cuarto par√°metro puede tomar otros muchos valores que no vamos a ver, pero s√≠ se√±alaremos que es conveniente a√±adir la constante <em>SDL_DOUBLEBUFFER</em> por motivos de rendimiento (ver ejemplo m√°s abajo).</p>

    <p><em>SDL_SetVideoMode()</em> devuelve un puntero a una estructura llamada <em>SDL_Surface</em>, definida en <em>SDL.h</em>, o NULL si ocurre alg√∫n error. Este puntero nos ser√° imprescidible para manejar la pantalla gr√°fica, as√≠ que <strong>debes guardarlo en una variable</strong>.</p>

    <p>Esta variable, adem√°s, debe ser <strong>global</strong> si se va a usar en otras partes del programa, contraviniendo una de las buenas pr√°cticas de programaci√≥n m√°s universales que existen. Sin embargo, si no lo haces as√≠, la variable no funcionar√° correctamente.</p>

    <p>Aqu√≠ tienes un ejemplo de inicializaci√≥n de la pantalla gr√°fica:</p>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cp">#include</span> <span class="cpf">&lt;SDL/SDL.h&gt;</span><span class="c1">  </span><span class="cp">
</span>  <span class="p">...</span>
  <span class="n">SDL_Surface</span> <span class="o">*</span><span class="n">pantalla</span><span class="p">;</span>	<span class="c1">// Esta variable debe ser GLOBAL</span>
  <span class="p">...</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">SDL_Init</span><span class="p">(</span><span class="n">SDL_INIT_VIDEO</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"Error en la inicializaci√≥n del sistema de v√≠deo</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">SDL_Quit</span><span class="p">();</span>
    <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">pantalla</span> <span class="o">=</span> <span class="n">SDL_SetVideoMode</span><span class="p">(</span><span class="mi">1280</span><span class="p">,</span> <span class="mi">960</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">SDL_ANYFORMAT</span><span class="o">|</span><span class="n">SDL_DOUBLEBUF</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pantalla</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"Fallo al establecer el modo de v√≠deo</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">SDL_Quit</span><span class="p">();</span>
    <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="p">...</span>
  <span class="n">SDL_Quit</span><span class="p">();</span>		<span class="c1">// Esto se hace al final del programa</span>
</code></pre></div></div>

<p>Tan importante como inicializar la pantalla gr√°fica es <strong>finalizarla</strong>. Ten en cuenta que la pantalla gr√°fica consume muchos recursos, y √©stos deben ser liberados antes de que el programa termine su ejecuci√≥n. Para eso tenemos la funci√≥n <em>SDL_Quit()</em>, que se invoca sin argumentos (observa el ejemplo)</p>

<h4 id="dibujar-gr√°ficos-en-la-pantalla">Dibujar gr√°ficos en la pantalla</h4>

<p>Ya tenemos nuestra pantalla gr√°fica inicializada y lista para empezar a dibujar en ella. Pero, ¬øqu√© tipo de objetos se pueden dibujar?</p>

<p>Aunque las librer√≠as gr√°ficas permiten al programador <strong>pintar p√≠xels individuales</strong> en cualquier punto de la pantalla, lo habitual es <strong>trabajar con im√°genes</strong> previamente existentes llamadas <strong><em>sprites</em></strong>.</p>

<p>Un <em>sprite</em> es una imagen guardada en un archivo que puede ser cargada por el programa y mostrada en cualquier parte de la pantalla gr√°fica y tantas veces como sea necesario.</p>

<p>Por lo tanto, lo primero que necesitas es hacerte con una colecci√≥n de sprites para tu programa. Si, por ejemplo, suponemos que estamos desarrollando un de ajedrez, necesitar√≠amos los siguientes:</p>

<ul>
  <li>Una imagen del tablero.</li>
  <li>Una imagen de cada una de las piezas.</li>
  <li>Opcionalmente, una imagen de fondo para decorar la pantalla.</li>
</ul>

<p>Los archivos con las im√°genes deben estar en formato BMP. SDL admite otros formatos, pero el BMP es f√°cil de manipular, as√≠ que es buena idea empezar por las im√°genes BMP y luego, cuando ya las manejes bien, dar el salto a otros formatos con compresi√≥n, como JPG o PNG. Cualquier editor de im√°genes te permitir√° convertir tus <em>sprites</em> a BMP.</p>

<p>Para dibujar una imagen en cualquier punto de la pantalla, hay que hacer dos cosas que pasamos a describir con detalle:</p>

<ul>
  <li>Cargar la imagen en la memoria (procedente de un archivo BMP)</li>
  <li>Mostrar la imagen en la pantalla</li>
</ul>

<p><strong>1. Cargar im√°genes en la memoria</strong></p>

<p>S√≥lo es necesario cargar las im√°genes <strong>una vez</strong>. Normalmente, se har√° <strong>al principio del programa</strong>, justo despu√©s de la inicializaci√≥n de SDL.</p>

<p>Una vez cargadas en la memoria, podremos utilizarlas tantas veces como las necesitemos, a menos que liberemos el espacio de memoria que ocupan. La liberaci√≥n de espacio, por tanto, deber√≠a hacerse al final del programa, justo antes de terminar.</p>

<p>Para cargar una imagen BMP se usa la funci√≥n <em>SDL_LoadBMP()</em>, de esta forma:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">SDL_Surface</span> <span class="o">*</span><span class="n">tablero</span><span class="p">;</span>

  <span class="n">tablero</span> <span class="o">=</span> <span class="n">SDL_LoadBMP</span><span class="p">(</span><span class="s">"tablero.bmp"</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">tablero</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">"Error al cargar el archivo tablero.bmp"</span><span class="p">);</span>
     <span class="n">SDL_Quit</span><span class="p">();</span>
     <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>Observa que <em>SDL_LoadBMP()</em> devuelve un puntero a <em>SDL_Surface</em>. Este puntero ser√° necesario para luego mostrar la imagen en cualquier lugar de la pantalla. La variable ‚Äútablero‚Äù debe ser global si se va a usar en m√°s de una funci√≥n (si es local y la pasamos como par√°metro a otra funci√≥n, SDL fallar√°).</p>

<p>Las im√°genes son rectangulares. En muchas ocasiones, necesitamos mostrar una imagen encima de otra. Es el caso de las piezas, que se mostrar√°n encima del tablero. Cuando esto ocurre, el color de fondo de la pieza (que decidimos que fuera negro) aparecer√° encima del tablero como un desagradable recuadro de color negro. En estas situaciones, hay que avisar a SDL de que, para este <em>sprite</em> en concreto, el color negro (o el que decidamos) va a ser transparente, es decir, no debe ser mostrado. Esto se hace as√≠:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">SDL_Surface</span> <span class="o">*</span><span class="n">peon_blanco</span><span class="p">;</span>
  <span class="n">Uint32</span> <span class="n">color</span><span class="p">;</span>	<span class="c1">// Para definir el color de transparencia (donde proceda)</span>

  <span class="c1">// Cargamos la imagen del pe√≥n blanco</span>
  <span class="n">peon_blanco</span> <span class="o">=</span> <span class="n">SDL_LoadBMP</span><span class="p">(</span><span class="s">"peon_blanco.bmp"</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">peon_blanco</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">"Error al cargar el archivo peon_blanco.bmp"</span><span class="p">);</span>
     <span class="n">SDL_Quit</span><span class="p">();</span>
     <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
 
  <span class="c1">// Definimos la transparencia (color negro = (0,0,0) )</span>
  <span class="n">color</span> <span class="o">=</span> <span class="n">SDL_MapRGB</span><span class="p">(</span><span class="n">peon_blanco</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">SDL_SetColorKey</span><span class="p">(</span><span class="n">cuadro1</span><span class="p">,</span> <span class="n">SDL_SRCCOLORKEY</span> <span class="o">|</span> <span class="n">SDL_RLEACCEL</span><span class="p">,</span> <span class="n">color</span><span class="p">);</span>
</code></pre></div></div>

<p>Las im√°genes cargadas en memoria deben ser liberadas antes de finalizar el programa con una llamada a SDL_FreeSurface(). Por ejemplo, para liberar la memoria ocupada por la imagen ‚Äútablero.bmp‚Äù que hemos cargado antes usaremos el puntero que obtuvimos al cargarla, as√≠:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SDL_FreeSurface</span><span class="p">(</span><span class="n">tablero</span><span class="p">);</span>
</code></pre></div></div>

<p><strong>2. Mostrar im√°genes en la pantalla</strong></p>

<p>Una vez cargada una imagen BMP en la memoria, podemos mostrarla en la pantalla a trav√©s del puntero <em>SDL_Surface</em> que obtuvimos al cargarla. Una imagen cargada puede ser mostrada todas las veces que queramos en cualquier posici√≥n de la pantalla.</p>

<p>Por ejemplo, para mostrar la imagen del tablero (que cargamos en un ejemplo del apartado anterior) har√≠amos lo siguiente (luego comentamos el c√≥digo):</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">SDL_Rect</span> <span class="n">rect</span><span class="p">;</span>
  <span class="n">rect</span> <span class="o">=</span> <span class="p">(</span><span class="n">SDL_Rect</span><span class="p">)</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">400</span><span class="p">};</span>
  <span class="n">SDL_BlitSurface</span><span class="p">(</span><span class="n">tablero</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">pantalla</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rect</span><span class="p">);</span>
  <span class="n">SDL_Flip</span><span class="p">(</span><span class="n">pantalla</span><span class="p">);</span>
</code></pre></div></div>

<p>La variable <em>rect</em> es de tipo <em>SDL_Rect</em>, y define un √°rea rectangular de la pantalla. El √°rea rectangular empieza en las coordenadas (10, 10) (esquina superior izquierda de la pantalla) y mide 400 p√≠xels de ancho y 400 de alto, es decir, termina en (410, 410).</p>

<p><em>SDL_BlitSurface()</em> es la funci√≥n que se encarga de mostrar en la pantalla un <em>sprite</em>. La variable <em>tablero</em> es de tipo <em>SDL_Surface</em>, y debe ser la que nos devolvi√≥ <em>SDL_LoadBMP()</em> al cargar la imagen del tablero. La variable <em>pantalla</em> tambi√©n es una <em>SDL_Surface</em>, y debe ser la que nos devolvi√≥ <em>SDL_SetVideoMode()</em> al inicializar la pantalla gr√°fica. Ya dijimos que los punteros que nos devuelven estas funciones son imprescidibles y que deb√≠amos definirlos como variables globales. La variable <em>rect</em> es el √°rea rectangular que acabamos de definir.</p>

<p>F√≠jate que <em>rect</em> es la que indica en qu√© lugar de la pantalla va a aparecer el <em>sprite</em>. En este ejemplo, aparecer√° en (10,10). Se le han reservado 400x400 p√≠xels para dibujarse, es decir, hasta la posici√≥n (410, 410). Si el <em>sprite</em> es m√°s peque√±o, no pasar√° nada (ocupar√° lo que mida realmente). Si es m√°s grande, se truncar√°.</p>

<p>Por √∫ltimo, <em>SDL_Flip()</em> hace que lo que acabamos de dibujar se muestre realmente en la pantalla. Su efecto es parecido al de la funci√≥n refresh() de ncurses. En realidad, todo lo que dibujamos se escribe en una zona de memoria espec√≠fica y, al hacer <em>SDL_Flip()</em>, esa zona de memoria se vuelca sobre la memoria de v√≠deo, apareciendo todo en la pantalla. Esto representa el movimiento de gran cantidad de informaci√≥n entre distintas zonas de memoria, lo cual es un proceso relativamente lento. Por eso, si vamos a dibujar varios sprites consecutivos, es mejor hacer una sola vez <em>SDL_Flip()</em>, al final, cuando los hayamos dibujado todos. Llamar a <em>SDL_Flip()</em> despu√©s de dibujar cada sprite ralentizar√° notablemente el funcionamiento de nuestro programa.</p>

<h4 id="control-del-teclado">Control del teclado</h4>

<p>Para leer el teclado en una ventana gr√°fica creada con SDL <em>no</em> se pueden usar las funciones est√°ndar (como <em>getchar()</em> o <em>gets()</em>), ni mucho menos las de <em>ncurses</em> (como <em>getstr()</em>).</p>

<p>SDL solo permite <strong>leer los caracteres de uno en uno</strong>, y <strong>no muestra eco</strong> por la pantalla (si queremos eco, tenemos que mostrar los caracteres nosotros mismos despu√©s de leerlos).</p>

<p>Por lo dem√°s, la forma de capturar un car√°cter tecleado es similar a la de <em>ncurses</em>, solo que un poco m√°s complicada. A continuaci√≥n se muestra un c√≥digo de ejemplo:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SDL_Event</span> <span class="n">evento</span><span class="p">;</span>	  	      <span class="c1">// Para leer el teclado</span>

<span class="c1">// Leer teclado</span>
<span class="k">if</span> <span class="p">(</span><span class="n">SDL_PollEvent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">evento</span><span class="p">))</span>            <span class="c1">// Comprobar si se ha pulsado una tecla</span>
<span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">evento</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">SDL_KEYDOWN</span><span class="p">)</span>     <span class="c1">// Efectivamente, se ha pulsado una tecla</span>
   <span class="p">{</span>
       <span class="k">switch</span> <span class="p">(</span><span class="n">evento</span><span class="p">.</span><span class="n">key</span><span class="p">.</span><span class="n">keysym</span><span class="p">.</span><span class="n">sym</span><span class="p">)</span>  <span class="c1">// Vamos a mirar qu√© ecla es</span>
       <span class="p">{</span>
           <span class="k">case</span> <span class="n">SDLK_UP</span><span class="p">:</span>     <span class="p">...</span><span class="n">acciones</span><span class="p">...;</span> <span class="k">break</span><span class="p">;</span>	<span class="c1">// Flecha arriba</span>
           <span class="k">case</span> <span class="n">SDLK_DOWN</span><span class="p">:</span>   <span class="p">...</span><span class="n">acciones</span><span class="p">...;</span> <span class="k">break</span><span class="p">;</span>	<span class="c1">// Flecha abajo</span>
           <span class="k">case</span> <span class="n">SDLK_LEFT</span><span class="p">:</span>   <span class="p">...</span><span class="n">acciones</span><span class="p">...;</span> <span class="k">break</span><span class="p">;</span>	<span class="c1">// Felcha izquierda</span>
           <span class="k">case</span> <span class="n">SDLK_RIGHT</span><span class="p">:</span>  <span class="p">...</span><span class="n">acciones</span><span class="p">...;</span> <span class="k">break</span><span class="p">;</span>	<span class="c1">// Flecha derecha</span>
           <span class="k">case</span> <span class="n">SDLK_RETURN</span><span class="p">:</span> <span class="p">...</span><span class="n">acciones</span><span class="p">...;</span> <span class="k">break</span><span class="p">;</span>	<span class="c1">// Intro </span>
           <span class="k">case</span> <span class="n">SDLK_ESCAPE</span><span class="p">:</span> <span class="p">...</span><span class="n">acciones</span><span class="p">...;</span> <span class="k">break</span><span class="p">;</span>	<span class="c1">// ESC</span>
           <span class="k">case</span> <span class="n">SDLK_m</span><span class="p">:</span>      <span class="p">...</span><span class="n">acciones</span><span class="p">...;</span> <span class="k">break</span><span class="p">;</span>	<span class="c1">// Tecla "m" (men√∫)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Existen constantes para cualquiera de las otras teclas del teclado. Todas empiezan por <em>SDLK_</em>. Por ejemplo, la tecla ‚Äúa‚Äù tendr√° el c√≥digo <em>SDLK_a</em>.</p>

<h4 id="definici√≥n-de-colores">Definici√≥n de colores</h4>

<p>Aunque a menudo trabajes con <em>sprites</em> basados en im√°genes preexistentes, es posible que tambi√©n necesites definir alg√∫n color para usarlo directamente sobre la pantalla gr√°fica (por ejemplo, para usar transparencias o para escribir un texto).</p>

<p>En SDL no hay colores predefinidos, como en <em>ncurses</em>. Los colores debemos definirlos nosotros mezclando los colores b√°sicos RGB (rojo, verde y azul).</p>

<p>Hay dos formas de definir un color: con una variable de tipo <em>SDL_Color</em> o con una variable de tipo <em>Uint32</em>. El uso de una u otra depender√° de para qu√© queramos usar ese color:</p>

<p><strong>a) Con una variable de tipo SDL_Color</strong>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="n">SDL_Color</span> <span class="n">color</span><span class="p">;</span>
   <span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="n">SDL_Color</span><span class="p">)</span> <span class="p">{</span><span class="mi">50</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">255</span><span class="p">};</span>
</code></pre></div></div>

<p>Los cuatro n√∫meros definen el color. Deben ser n√∫meros comprendidos entre 0 y 255. El primero es el nivel de rojo (R), el segundo el nivel de verde (G) y el tercero, el nivel de azul (B). El cuarto n√∫mero es el brillo. El color definido en este ejemplo tiene mucho azul, bastante verde y poco rojo. El resultado debe ser un azul amarillento.</p>

<p><strong>b) Con una variable de tipo Uint32</strong>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="n">Uint32</span> <span class="n">color</span><span class="p">;</span>
   <span class="n">color</span> <span class="o">=</span> <span class="n">SDL_MapRGB</span><span class="p">(</span><span class="n">pantalla</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">200</span><span class="p">);</span>  
</code></pre></div></div>

<p>En esta ocasi√≥n, <em>pantalla</em> debe ser un puntero a una imagen <em>SDL_Surface</em> que hayamos cargado previamente. Los tres valores siguientes son los niveles RGB. No hay nivel de brillo, porque √©ste se toma de la imagen apuntada por <em>pantalla</em>.</p>

<p>De las dos maneras se pueden definir colores para usarlos posteriormente. Si el color lo necesitamos para una transparencia, recurriremos al segundo m√©todo (de hecho, ya vimos un ejemplo de ello al estudiar c√≥mo se cargaban y mostaban las im√°genes en SDL; all√≠ usamos el color negro como transparencia). Si el color lo necesitamos para escribir un texto en la pantalla gr√°fica, usaremos el primer m√©todo (como se podr√° ver en el siguiente apartado)</p>

<h4 id="mostrar-texto-en-la-pantalla-gr√°fica-instalaci√≥n-y-uso-de-la-librer√≠a-sdl_ttf">Mostrar texto en la pantalla gr√°fica: instalaci√≥n y uso de la librer√≠a SDL_TTF</h4>

<p>La librer√≠a SDL no permite directamente la escritura de texto en la pantalla gr√°fica. Esto se debe a que la pantalla gr√°fica, por definici√≥n, no admite caracteres, sino √∫nicamente im√°genes.</p>

<p>Por fortuna, a la sombra de SDL se han creado multitud de librer√≠as adicionales que, partiendo de SDL, complementan y mejoran sus prestaciones. Una de ellas es SDL_TTF.</p>

<p>La liber√≠a SDL_TTF permite cargar fuentes <em>true type</em> que est√©n guardadas en archivos .ttf y manejarlas como si fueran im√°genes BMP en la pantalla gr√°fica generada por SDL. Necesitamos SDL_TTF, por lo tanto, para escribir los mensajes de usuario y las opciones del men√∫.</p>

<p>La <strong>instalaci√≥n</strong> de la librer√≠a SDL_TTF es similar a la de SDL, tanto en Linux como en Windows, de modo que puedes remitirte al apartado correspondiente para recordar c√≥mo se hac√≠a. Lo mismo puede decirse en cuanto a la compilaci√≥n y el enlace.</p>

<p>Igual que SDL, la librer√≠a SDL_TTF necesita ser <strong>inicializada</strong> antes de usarla, y <strong>finalizada</strong> antes de terminar el programa para liberar los recursos adquiridos.</p>

<p>Como SDL_TTF corre por debajo de SDL, debe ser inicializada despu√©s de SDL, y debe ser terminada antes que SDL. Observa c√≥mo se hace en este ejemplo:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span><span class="p">(</span><span class="n">TTF_Init</span><span class="p">()</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Fallo al inicializar SDL_TTF"</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>  
</code></pre></div></div>

<p>Inmediatamente despu√©s, ya podemos cargar una fuente true type de un archivo TTF, as√≠:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">TTF_Font</span><span class="o">*</span> <span class="n">fuente</span><span class="p">;</span>
  <span class="p">....</span>
  <span class="n">fuente</span> <span class="o">=</span> <span class="n">TTF_OpenFont</span><span class="p">(</span><span class="s">"arial.ttf"</span><span class="p">,</span> <span class="mi">14</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">fuente</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Fallo al abrir la fuente"</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">TTF_SetFontStyle</span><span class="p">(</span><span class="n">fuente</span><span class="p">,</span> <span class="n">TTF_STYLE_BOLD</span><span class="p">);</span>
</code></pre></div></div>

<p>La variable <em>fuente</em> es un puntero a <em>TTF_Font</em>. Debe ser una variable global por el mismo motivo que las variables <em>SDL_Surface</em>. La funci√≥n <em>TTF_OpenFont()</em> abre el archivo ‚Äúarial.ttf‚Äù y carga el tipo de letra Arial en tama√±o 14 para su uso en el programa. Despu√©s es conveniente comprobar que el puntero <em>fuente</em> contenga un valor v√°lido y no NULL.</p>

<table>
  <tbody>
    <tr>
      <td>Por √∫ltimo, la funci√≥n <em>TTF_SetFontStyle()</em> puede usarse para determinar el estilo de la fuente. Tenemos varias posibilidades: <em>TTF_STYLE_BOLD</em> (negrita), <em>TTF_STYLE_ITALIC</em> (cursiva), <em>TTF_STYLE_UNDERLINE</em> (subrayado) y <em>TTF_STYLE_NORMAL</em>. Si queremos combinar varios estilos, podemos separarlos por el operador ‚Äú</td>
      <td>‚Äù. Por ejemplo, para poner la fuente en negrita y cursiva escribir√≠amos esto:</td>
    </tr>
  </tbody>
</table>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">TTF_SetFontStyle</span><span class="p">(</span><span class="n">fuente</span><span class="p">,</span> <span class="n">TTF_STYLE_BOLD</span> <span class="o">|</span> <span class="n">TTF_STYLE_ITALIC</span><span class="p">);</span>
</code></pre></div></div>

<p>El proceso de <strong>finalizaci√≥n</strong> del SDL_TTF es inverso y complementario al de inicializaci√≥n. Primero habr√° que liberar todas las fuentes cargadas durante la inicializaci√≥n, y luego hay que terminar el subsistema SDL_TTF:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">TTF_CloseFont</span><span class="p">(</span><span class="n">fuente</span><span class="p">);</span> 
  <span class="n">TTF_Quit</span><span class="p">();</span>
</code></pre></div></div>

<p>La variable <em>fuente</em> ser√° de tipo <em>TTF_Font</em>, y debe coincidir con la que nos devolvi√≥ la funci√≥n <em>TTF_OpenFont()</em>. Esta operaci√≥n la repetiremos con cada una de las fuentes que hayamos cargado.</p>

<p>Recuerda que todo esto debe hacerse ANTES de <em>SDL_Quit()</em>, ya que SDL_TTF depende de SDL.</p>

<h4 id="escribir-texto-con-sdl_ttf">Escribir texto con SDL_TTF</h4>

<p>Todo esto lo hacemos con un objetivo: poder escribir texto en la pantalla gr√°fica y sustituir as√≠ todas las funciones <em>printw()</em> y similares.</p>

<p>Para escribir un texto hay que hacer dos cosas: <strong>primero, convertirlo en una imagen; segundo, mostrar la imagen en la pantalla</strong>.</p>

<p>La conversi√≥n de un texto en una imagen se hace con la funci√≥n <em>TTF_Render()</em>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">SDL_Color</span> <span class="n">color</span><span class="p">;</span>
  <span class="n">SDL_Surface</span><span class="o">*</span> <span class="n">txt_img</span><span class="p">;</span>

  <span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="n">SDL_Color</span><span class="p">)</span> <span class="p">{</span><span class="mi">255</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">255</span><span class="p">};</span>
  <span class="n">txt_img</span> <span class="o">=</span> <span class="n">TTF_RenderText_Blended</span><span class="p">(</span><span class="n">fuente</span><span class="p">,</span> <span class="s">"Hola mundo"</span><span class="p">,</span> <span class="n">color</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">txt_img</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"Fallo al renderizar el texto"</span><span class="p">);</span>
	<span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>Como ves, hay que hacer bastantes cosas para mostrar un texto en la pantalla gr√°fica, pero todo es acostumbrarse. Primero, hay que definir un color para el texto (c√≥mo se definen los colores es algo que vimos en el ep√≠grafe anterior). En este caso, hemos escogido un rojo brillante.</p>

<p>Despu√©s se invoca a <em>TTF_RenderText()</em>, pas√°ndole como par√°metros el puntero a la fuente que obtuvimos con <em>TTF_OpenFont()</em>, el texto que queremos mostrar y el color. La funci√≥n nos devuelve un puntero de tipo <em>SDL_Surface</em> que, si recuerdas, es exactamente el mismo que us√°bamos con las im√°genes cargadas desde un archivo BMP.</p>

<p>En realidad, la funci√≥n <em>TTF_RenderText()</em> tiene tres formas:</p>

<ul>
  <li><em>TTF_RenderText_Solid()</em> - realiza una conversi√≥n del texto en imagen r√°pida pero de poca calidad.</li>
  <li><em>TTF_RenderText_Shaded()</em> - la imagen resultante es de gran calidad pero tiene un recuadro negro alrededor</li>
  <li><em>TTF_RenderText_Blended()</em> - la imagen resultante es de gran calidad y sin recuadro negro</li>
</ul>

<p>En general preferiremos el modo <em>Blended</em>, que es el que proporciona mejores resultados. El modo <em>Shaded</em> se puede usar en determinados lugares (si no hay otra imagen debajo del texto). El modo <em>Solid</em> s√≥lo debe usarse si hay que mostrar mucho texto y el modo <em>Blended</em> se revela demasiado lento.</p>

<p>Hasta aqu√≠, s√≥lo hemos convertido el texto ‚ÄúHola mundo‚Äù en una imagen, pero a√∫n no la hemos mostrado en la pantalla. Para hacerlo procederemos como con cualquier otra imagen:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// Mostramos el texto como si fuera una imagen</span>
  <span class="n">rect</span> <span class="o">=</span> <span class="p">(</span><span class="n">SDL_Rect</span><span class="p">)</span> <span class="p">{</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">280</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">30</span> <span class="p">};</span>
  <span class="n">SDL_BlitSurface</span><span class="p">(</span><span class="n">txt_img</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">pantalla</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rect</span><span class="p">);</span>	
  <span class="n">SDL_Flip</span><span class="p">(</span><span class="n">scr</span><span class="p">);</span>
</code></pre></div></div>

<p>Se supone que <em>rect</em> es de tipo <em>SDL_Rect</em> y que pantalla es el puntero a <em>SDL_Surface</em> que nos devolvi√≥ <em>SDL_SetVideoMode()</em> al inicializar SDL. As√≠, el texto ‚ÄúHola mundo‚Äù se mostrar√° en la posici√≥n (500, 280) de la pantalla gr√°fica, reserv√°ndose para √©l 100 p√≠xels de ancho y 30 de alto.</p>

:ET