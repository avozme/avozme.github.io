{"0": {
    "doc": "0. Presentación de la asignatura",
    "title": "0. Presentación de la asignatura",
    "content": "# 0. Presentación de la asignatura {: .no_toc } - TOC {:toc} ## 0.1. Contextualización y horario La asignatura **Introducción a la programación y al diseño 3D** se imparte como optativa en segundo curso de Bachillerato en el IES Celia Viñas de Almería y tiene una duración de 72 horas (2 horas semanales). El profesor encargado de impartirla durante el curso 2021-2022 es **Alfredo Moreno Vozmediano**, miembro del Departamento de Informática. Salvo cambio de criterio de la dirección del centro, durante el curso actual, el **horario** de clases será el siguiente: * Miércoles de 9:05 a 10:05 horas (aula 19). * Jueves de 12:35 a 13:35 horas (aula ?). ## 0.2. Objetivos Los objetivos de esta asignatura son los siguientes: 1. Comprender el impacto del pensamiento computacional en la sociedad actual. 2. Producir programas informáticos plenamente funcionales. 3. Integrarse en un equipo de desarrollo de software que sea capaz de afrontar proyectos de cierta envergadura. 4. Desarrollar la capacidad de abstracción. 5. Emplear la creatividad en el desarrollo de aplicaciones informáticas para resolver problemas y fomentar la capacidad de expresión personal. 6. Recopilar, almacenar y procesar datos con el objetivo de encontrar patrones, descubrir conexiones y resolver problemas. 7. Analizar cómo la representación, el almacenamiento, la seguridad y la transmisión de datos requiere de manipulación computacional, y comprender los riesgos de seguridad y privacidad existentes cuando se trata de información personal. 8. Conocer los fundamentos y aplicaciones del Diseño Asistido por Ordenador y capacitar para el diseño de objetos bidimensionales y tridimensionales sencillos. 9. Fomentar el trabajo en equipo y la comunicación interpersonal. ## 0.3. Contenido Los contenidos de la asignatura se dividen en **cuatro bloques y 12 unidades didácticas**. Los resumimos a continuación. **Bloque 1. Representación digital y pensamiento computacional** * UD1. Características, ejemplos e importancia del pensamiento computacional. * UD2. Representación de la información. Bits, bytes, múltiplos y submúltiplos. Almacenamiento, transmisión y tratamiento de la información binaria. Representaciones octal y hexadecimal. ASCII y Unicode. **Bloque 2. Introducción a la programación** * UD3. Lenguajes de programación. Tipos de lenguajes. Estructura de un programa informático. Tipos básicos de datos. Constantes y variables. Operadores y expresiones. Comentarios. Pseudocódigo y diagramas de flujo. Estructuras de control: secuencial, condicional e iterativa. * UD4. Estructuras de datos. Funciones y bibliotecas de funciones. Reutilización de código. Facilidades para la entrada y salida de datos de usuario. Manipulación de archivos. * UD5. Orientación a objetos. Clases, objetos y constructores. Herencia. Subclases y superclases. Polimorfismo y sobrecarga. Encapsulamiento y ocultación. * UD6. Entornos integrados de desarrollo. Depuración. Ciclo de vida del software. Trabajo en equipo y mejora continua. Control de versiones. Metodologías ágiles: Scrum. * UD7. Lenguajes de programación reales. Java, Python o PHP. **Bloque 3. Datos e Información** * UD8. Almacenamiento de la información. Ficheros. Bases de datos relacionales. Sistemas gestores de bases de datos. Diseño conceptual. Diagramas entidad-relación. Normalización hasta 3FN y FNBC. Definición y manipulación. * UD9. Comandos básicos de SQL: DDL, DML y DCL. * UD10. Seguridad y privacidad. Acceso a los información de las bases de datos. **Bloque 4. Diseño 3D** * UD11. Tecnologías de impresión 3D. Utilidad y posibilidades del diseño 3D. Impresión 3D por FDM. Impresoras 3D por FDM. Partes, funcionamiento y mantenimiento básico. * UD12. Modelado e impresión 3D. Software para diseño 3D y software para slicing (laminado). Creación e impresión de figuras básicas. Transformación, rotación y unión de figuras básicas. Formatos para impresión 3D. Pruebas de impresión. ## 0.4. Evaluación y calificación A lo largo de curso se evaluarán los siguientes elementos: * **Observación del trabajo diario** en el aula (calificación de 1 a 10). * **Actividades, prácticas y proyectos** (calificación de 1 a 10). * **Test de conocimientos** (exámenes) (calificación de 1 a 10). Para aprobar cada **evaluación trimestral**, es necesario **obtener al menos un 5** en cada uno de los apartados anteriores. La nota trimestral se calculará así: * Observación directa y trabajo diario: 30% * Prácticas y proyectos: 40% * Tests de conocimientos: 30% La **nota final del curso** se obtendrá mediante una media aritmética de las calificaciones obtenidas en cada trimestre. Se hará un examen teórico-práctico final, con actividades de un nivel similar a las propuestas en las prácticas y proyectos, para las personas que no hayan superado alguna de las evaluaciones trimestrales. Asimismo, habrá una recuperación en septiembre con la misma naturaleza y que abarcará toda la materia impartida durante el curso. ",
    "url": "/docs/prog-y-3d/_site/presentacion/",
    "relUrl": "/presentacion/"
  },"1": {
    "doc": "1. Pensamiento computacional",
    "title": "1. Pensamiento computacional",
    "content": "# 1. Pensamiento computacional {: .no_toc } - TOC {:toc} ## 1.1. ¿Qué es eso del pensamiento computacional? El pensamiento computacional es un proceso de **formulación y resolución de problemas que utiliza los conceptos de la ingeniería informática**. Es decir, consiste en pensar como lo haría un científico-informático cuando está frente un problema y tener la habilidad y la actitud para que nos sea útil tanto en nuestra vida personal como profesional. Hemos dicho \"vida personal\", sí. Uno de los errores más frecuentes cuando se habla de *pensamiento computacional* es considerar que solo se aplica a la Informática. El pensamiento computacional **sirve para resolver problemas cotidianos haciendo uso de las técnicas y habilidades de los programadores/as informáticos** y obtener así soluciones que pueden ser representadas mediante una serie de pasos o instrucciones. Aquí tienes un vídeo que desarrolla esta interesante idea en tres minutos: ## 1.2. Características del pensamiento computacional Según las definiciones que hemos visto en el apartado anterior, el pensamiento computacional es un proceso de resolución de problemas que incluye las siguientes características: * Reformular problemas de forma que se permita el uso de un ordenador y otras herramientas para ayudar a resolverlos. * Organizar y analizar lógicamente la información. * Representar la información a través de abstracciones como los modelos y las simulaciones. * Automatizar soluciones haciendo uso del pensamiento algorítmico (estableciendo una serie de pasos ordenados para llegar a la solución). * Identificar, analizar e implementar posibles soluciones con el objetivo de lograr la combinación más efectiva y eficiente de pasos y recursos. * Generalizar y transferir este proceso de resolución de problemas para ser capaz de resolver una gran variedad de familias de problemas. #### Ejemplo de pensamiento computacional Escribir **una receta de cocina** siguiendo unos pasos o instrucciones sería un buen primer ejemplo de aplicación para el pensamiento computacional. Por ejemplo, supongamos que queremos cocinar un *risotto* utilizando un sobre de comida preparada (para que sea más rápido). No te preocupes si no tienes ni idea de lo que es un *risotto*. En realidad, y gracias al pensamiento computacional, no necesitas saber lo que es para prepararlo, puesto que el pensamiento computacional te permite disponer de una receta. En este caso, los pasos de la receta serían más o menos estos: 1. Abrir el sobre 2. Poner a calentar el agua 3. Esperar a que el agua hierva 4. Si hierve, verter el sobre 5. Remover el contenido de la olla 6. Apagar el fuego y dejar reposar 7. Servir en el plato para \"x\" personas Si sigues esos pasos, seguro que puedes obtener algo comestible aunque no tengas ni idea de qué estás cocinando en realidad, ¿verdad? El pensamiento computacional consiste en enfrentarse a un problema (como \"cocinar un *risotto*\") y obtener una solución (como una \"receta\") que permita solucionarlo todas las veces que sean necesarias. Si la \"receta\" anterior la escribiéramos usando un lenguaje de programación, tendríamos en nuestras manos un programa de ordenador. De hecho, podemos \"escribirla\" en un lenguaje de programación por bloques gráficos, como el popular *Scratch*, y nos quedaría algo así: ![Ejemplo de receta escrita con Scratch](/docs/prog-y-3d/_site/assets/images/01-scratch.jpg) ## 1.3. El pensamiento computacional vs la programación Los términos \"pensamiento computacional\" y \"programación\" no son sinónimos. Esta es una confusión muy habitual. La programación solo es una de las posibles herramientas con la que se pone en práctica el pensamiento computacional. Por eso la programación y el pensamiento computacional comparten los mismos procesos cognitivos. La programación limita sus procesos de resolución de problemas al ámbito de la informática. Para ello, hace uso de diferentes lenguajes de programación. Puedes pedir a un ordenador que haga muchas cosas, pero no que prepare un *risotto*. Así que el pensamiento computacional puede aplicarse a problemas más allá de la informática. > ***Curiosidad**: ¿sabías que las peronas que aprenden a utilizar un lenguaje de programación muestran mayor capacidad de atención y autonomía, y obtienen en promedio mejores resultados en pruebas matemáticas, que las que no saben programar?* [Diversos estudios](https://www.redalyc.org/pdf/547/54741184011.pdf) han demostrado que, mediante los lenguajes de programación, se desarrollan ciertas habilidades cognitivas como: * El pensamiento lógico. * La creatividad. * El razonamiento abstracto. * La capacidad de resolución de problemas. Así que, si quieres orientar tu vida académica hacia las ciencias o la ingeniería, aprender a programar puede ser una herramienta muy útil para ti. Pero incluso si tus preferencias académicas van por otro camino, las rutinas de pensamiento computacional que adquirirás programando te reportarán muchos beneficios que quizá no sospechabas. ## 1.4. Algoritmos y descomposición de problemas Tanto el pensamiento computacional como la programación utilizan procesos cognitivos idénticos, como hemos dicho. Y el principal de ellos se denomina **\"Divide y vencerás\"** (*\"Divide and Conquer\"* en inglés). Es decir: descompón tu problema en problemas más pequeños, hasta que sean lo suficientente pequeños para afrontarlos. Y luego reúnelos todos como un puzle para componer la solución final. Fácil de explicar, difícil de hacer. ![Divide y vencerás](/docs/prog-y-3d/_site/assets/images/01-divide-y-venceras.jpg) El pensamiento computacional busca encontrar una \"receta\" para resolver cualquier problema computable. Esas recetas se denominan **algoritmos**. Un algoritmo, por tanto, es *un conjunto de pasos que, aplicados sistemáticamente a unos datos de entrada apropiados, resuelven un problema en un numero finito de pasos.* Nuestra receta de cocina para el *risotto* era un algoritmo. Las instrucciones para fabricar un avión de papel a partir de un folio también lo son. El motor de búsqueda de Google es otro algoritmo. Obviamente, el grado de complejidad de esos algoritmos no es comparable entre sí. Pero todos son algoritmos. Los algoritmos tienen una **entrada** (input) y una **salida** (output), y entre ambas están los pasos o instrucciones. La entrada de un algoritmo pueden ser los ingredientes para cocinar un *risotto*, y la salida es el plato comestible. Este es un algoritmo computable pero no programable, porque ningún ordenador podría ejecutarlo. La entrada del algoritmo de Google es el texto que escribimos en la caja de búsqueda, y la salida es la lista de resultados. Este es un algoritmo computable y programable (de hecho, la gente de Google lo ha programado, ¿no?) En realidad, los algoritmos recogen operaciones tan sencillas que pueden ser realizadas con éxito por cualquiera. *Incluso por las máquinas*. **La unión de máquinas y algoritmos es lo que está cambiando el mundo**. El matemático británico [Alan Turing](https://es.wikipedia.org/wiki/Alan_Turing), famoso por haber *hackeado* la máquina Enigma de mensajes cifrados de los nazis muchos años antes de que se inventara el término \"*hackear*\", y por haberse suicidado tras sufrir una dura persecución debido a su condición homosexual, fue de los primeros que relacionó algoritmos y ordenadores. De hecho, fue de los primeros que imaginó un ordenador tal y como lo conocemos hoy. Así es: los ordenadores actuales son, en esencia, *Máquinas de Turing* mucho más potentes de lo que Turing pudo soñar. ![Alan Turing](/docs/prog-y-3d/_site/assets/images/01-alan-turing.jpg) **El trabajo de los programadores/as informáticos** consiste en traducir los problemas del mundo a un lenguaje que una máquina pueda entender. Así, **un programa de ordenador** es un algoritmo escrito en un lenguaje de programación. Es decir, un conjunto de miles (¡o millones!) de operaciones sencillas que, como las piezas de un puzle, encajan para dar lugar a la solución final. Los algoritmos se usan para cualquier cosa: predecir resultados electorales, calcular trayectorias de satélites, conocer nuestros gustos y preferencias... El mundo del trabajo se va *algoritmizando* poco a poco: las diferentes tareas se convierten en algoritmos y se automatiza el trabajo. **Las únicas tareas no computables, por el momento, son las relacionadas con la creatividad y las emociones**. ¡Así que ya sabes dónde seguirá existiendo trabajo en las próximas décadas! ## 1.5. Algunos algoritmos famosos en tiempos de internet La palabra algoritmo se ha puesto de moda en los últimos años. Los ordenadores pueden hacer cálculo mucho más deprisa, y con mucha más fiabilidad, que un cerebro humano. Desde la aparición de Internet, se ha producido un salto cualitativo y estamos llegando a computar cosas que antes parecían imposibles. Por eso han surgido disciplinas en plena ebullición como el *big data* o la inteligencia artificial. #### El Algoritmo de Facebook ![Edgerank, el algoritmo de Facebook](/docs/prog-y-3d/_site/assets/images/01-edgerank.jpg) En el *big data*, los algoritmos analizan millones de datos de los clientes. Hay algoritmos ejecutándose en los ordenadores de a bordo de los automóviles, en los satélites de control de tráfico o en las redes sociales. El algoritmo que decide qué ve cada usuario en su muro de Facebook fue uno de los primeros en utilizar *big data*. Es un algoritmo tan famoso que hasta tiene nombre propio: **EdgeRank**. Cada vez que Facebook realiza cambios importantes en *EdgeRank*, se produce un revuelo en Facebook. A principios de 2018, por ejemplo, Facebook decidió dar más importancia a los usuarios particulares que a las empresas, marcas y medios de comunicación, en un intento de que la red social volviera a ser más \"social\" y paliar un poco la invasión de las *fake news*. El cambio dio bastantes quebraderos de cabeza a empresas y medios y, en algunos casos, provocó pérdidas millonarias. #### Algoritmo de Google ![Pagerank, el algoritmo de Google](/docs/prog-y-3d/_site/assets/images/01-pagerank.jpg) Tal vez el algoritmo más famoso del mundo, después del de la multiplicación, sea el de Google. Creado en 1998 y llamado **PageRank**, su éxito revolucionario consistió en que rastreaba la web y daba resultados de búsqueda ordenados por su importancia. ¿Y cómo mide *PageRank* la importancia de cada web? Es un secreto mejor guardado que la fórmula de la Coca-cola. El *PageRank* original medía la importancia de una web por la cantidad de webs que estaban enlazadas a ella. Esa fue la clave de su éxito inicial. En la actualidad, sospecho que ni siquiera los ingenieros de Google están muy seguros de qué cosas mide *PageRank* y en qué medida influyen en sus resultados. Actualmente, *PageRank* es capaz de adaptar sus resultados al usuario (no es lo mismo ser un adulto que un niño, o lanzar una búsqueda desde Almería que hacerlo desde Silicon Valley), ofrecer mapas, imágenes, corregir la ortografía de la búsqueda o entender cuándo en la caja de búsqueda se escribe una pregunta. Y darle respuesta. #### El algoritmo de Amazon ![A9, el algoritmo de Amazon](/docs/prog-y-3d/_site/assets/images/01-amazon.jpg) ¿Despedido por un algoritmo? No es ciencia ficción. De hecho, es algo que ocurre desde hace años. Las máquinas toman decisiones en lugar de los humanos pero que afectan directamente los humanos. Entre 2017 y 2018, más de 300 empleados de Amazon fueron despedidos por falta de productividad en una de sus sedes en Baltimore. Lo llamativo es que detrás esta decisión no hubo una inteligencia humana, sino artificial. Amazon mide individual y automáticamente la productividad de cada trabajador en base al número de paquetes que confeccionan cada hora. El programa, en caso de detectar empleados de baja productividad, genera automáticamente advertencias e incluso procesa automáticamente despidos, sin la intervención de los supervisores. De esta forma, los empleados son supervisados por algoritmos que llegan hasta el punto de conocer el tiempo que emplean fuera de sus tareças. Por ejemplo, si los empleados dejan de escanear paquetes durante demasiado tiempo, el sistema genera automáticamente alertas y el empleado puede ser despedido. Por otro lado, Amazon ha sido acusado en repetidas ocasiones de manipular sus algoritmos de búsqueda de productos dentro de su web, para priorizar los productos que les son más rentables. Cosa que no es de extrañar, por otra parte, ¿no te parece? La cuestión es esta: *un pequeño cambio en un algoritmo puede afectar a una gran parte del comercio electrónico mundial y a miles de fabricantes y vendedores*. ## 1.6. Actividades #### Ejercicio 1 Vamos a escribir nuestro primer algoritmo. Así, sin miedo. Imagina que tienes que explicarle a un extraterrestre recién llegado a la Tierra cómo debe cruzar un semáforo para evitar ser arrollado por los coches. (Si la metáfora del extraterrestre te parece excesiva, imagina que se lo tienes que explicar a un niño o niña muy pequeño) El extraterrestre (o el niño) solo comprende órdenes muy sencillas: camina, no camines, mira la luz, ¿es verde?, ¿es roja?, y cosas así. Tienes que exponer las instrucciones en una lista de pasos o \"receta de cocina\" expresada con acciones sencillas como las anteriores. Venga, a ver qué te sale. (Nota: no te desesperes si no sabes ni cómo empezar. Eso le pasa a todo el mundo la primera vez) #### Ejercicio 2 Ahora lo vamos a complicar un poco más, enfrentándonos a un algoritmo clásico en las ciencias de la computación. Se trata de encontrar el camino más corto entre dos puntos. En nuestro caso, queremos llegar desde A (Salida) hasta F (Meta). Cada camino tiene un peso (el numerito indicado en él). Puedes considerar que ese peso es el tiempo o la distancia, da lo mismo. Constrúyete una tabla con todos los diferentes caminos o recorridos posibles y el valor total de tiempo (o distancia) que acaba sumando cada uno de ellos. ![Grafo de Dijkstra](/docs/prog-y-3d/_site/assets/images/01-grafo.jpg) ¿Cómo se podría construir un algoritmo genérico que encontrase el camino más corto entre dos puntos cualesquiera, en un mapa con cualquier número de puntos y cualquier número de contexiones? Trata de pensarlo unos minutos. Después, cuando notes que la cabeza va a explotarte, bichea un poco por Internet en busca del **algoritmo de Dijkstra**. Brevemente y con tus propias palabras, comenta en qué consiste y trata de aplicarlo al problema anterior. #### Ejercicio 3 Investiga en internet quién fue **Ada Lovelace** y explica en pocas frases qué relación tiene con el mundo de los algoritmos y la programación de ordenadores. #### Ejercicio 4 Investiga en Internet sobre el escándalo de **Cambridge Analytica** y responde con tus palabras (¡y brevemente!) a las siguientes cuestiones: 1. Detalla qué es Cambridge Analytica y a qué se dedicaba. 2. ¿Con qué fin recababa Cambridge Analytica datos y perfiles de usuarios? 3. ¿Cuándo y por qué se produjo un escándalo mundial relacionado directamente con ella? 4. Describe el funcionamiento del algoritmo de Cambridge Analytica y explica como pudo influenciar mediante el mismo en las victorias de Donald Trump en Estados Unidos y del Brexit en Inglaterra? 5. ¿Cuál fue el número de usuarios de Facebook afectados? ¿Cuantos miles de millones de dólaresperdió Facebook tras el escándalo? 6. Busca y encuentra un video corto en youtube donde aparezca Mark Zuckerberg declarando en el congreso de Estados Unidos, dando explicaciones sobre el escándalo de Cambridge Analytica. (No olvides activar los subtítulos si tienes problemas con el inglés). ¿Con qué argumentos se defendió Zuckerberg de las acusaciones? #### Ejercicio 5 Vamos investigar entre todos sobre algunos algoritmos famosos en la historia de la computación: 1. Algoritmo del viajante de comercio. 2. Algoritmo de los filósofos comensales. 3. Algoritmo quicksort 4. Algoritmo mergesort 5. Algoritmo bubblesort o algoritmo de la burbuja 6. Algoritmo auto-tune 7. Algoritmo de la transformada rápida de Fourier 8. Algoritmo OkCupid Date Matching 9. Algoritmo de las ocho reinas 10. Algoritmo de la criba de Eratóstenes 11. Algoritmo MD5 12. Algoritmo SHA1 Una vez que se te asigne uno de estos algoritmos, lo que tienes que investigar es muy sencillo: * ¿Qué problema pretende resolver ese algoritmo? * ¿Cómo lo resuelve? (Expresado en términos sencillos y de andar por casa) ",
    "url": "/docs/prog-y-3d/_site/pensamiento-computacional/",
    "relUrl": "/pensamiento-computacional/"
  },"2": {
    "doc": "2. Representación de la información",
    "title": "2. Representación de la información",
    "content": "# 2. Representación de la información {: .no_toc } ATENCIÓN: este capítulo aún está en construcción El ordenador es una máquina digital, es decir, binaria. Cualquier aprendiz de programador/a debe conocer esa forma de codificación, y otras primas suyas (como la octal y la hexadecimal) antes de aventurarse en los vericuetos de la programación. Dedicaremos todo este tema a hacerlo. - TOC {:toc} ## 2.1. Los códigos Un **código** es un *método de representación de la información*. Se compone de un conjunto de símbolos, llamado **alfabeto**, y de un conjunto de **reglas** para combinar esos símbolos de forma correcta. Estos son algunos ejemplos de códigos que utilizas todos los días o que, al menos, conoces: * Ejemplo 1: la lengua castellana es un código. Su alfabeto es el abecedario (a, b, c, d, e ... z), pero los símbolos del alfabeto no se pueden combinar a lo loco, sino que existen unas reglas, y sólo siguiendo esas reglas se codifica correctamente la información, dando lugar a mensajes con sentido. Esas reglas las habéis estudiado en la asignatura de lengua castellana desde la enseñanza primaria. * Ejemplo 2: el código morse también es un código. Su alfabeto es muy reducido: sólo el punto (.) y la raya (–), pero combinando los dos símbolos correctamente, se puede transmitir cualquier información. * Ejemplo 3: el sistema de numeración decimal es un código. Tiene un alfabeto de 10 símbolos (0, 1, 2, 3, 4, 5, 6, 7, 8 y 9). Combinándolos según ciertas reglas, puede usarse para transmitir información. Pero ojo, no cualquier información, solamente información numérica. Hemos dicho que los códigos sirven para representar información, pero no que tengan que servir para representar toda la información posible. Aunque sólo sirva para los números, el sistema de numeración también es un código. ### 2.1.1. El código binario Pues bien, el sistema de numeración binario también es un código. Es muy parecido al sistema de numeración decimal, con la única diferencia de la cantidad de símbolos del alfabeto. Si el decimal tiene diez, el binario sólo tiene dos: el 0 y el 1. En todo lo demás son iguales, así que el sistema binario también sirve para representar información numérica. Pero, ¿puede representarse cualquier número con sólo dos símbolos? La respuesta es sí. El modo de hacerlo consiste en combinar los símbolos 0 y 1 adecuadamente, igual que hacemos con los números decimales. En el sistema decimal contamos así: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9. Cuando queremos pasar a la siguiente cantidad, empezamos a agrupar los dígitos de dos en dos: 10, 11, 12, 13, 14, 15, 16, 17, 18, 19. Al volver a terminar las unidades, vamos incrementando las decenas: 20, 21, 22, etc. (Esto se debe a que, en los sistemas de numeración, cada dígito tiene un valor posicional, es decir, tiene un valor diferente dependiendo del lugar que ocupe en el número general. Por ejemplo, en el número 283, el 3 tiene valor de tres, pero el 8 no tiene valor de ocho, sino de ochenta, y el 2 no tiene valor de dos, sino de doscientos) En binario, el razonamiento es el mismo. Empezamos a contar por 0 y 1, pero entonces ya hemos agotado los símbolos, así que empezamos a agruparlos: 10, 11. Como hemos vuelto a agotarlos, seguimos combinándolos: 100, 101, 110, 111, 1000, 1001, 1010, y así sucesivamente. Así, los 16 primeros números binarios comparados con sus equivalentes decimales son: Decimal|Binario -|- 0|0000 1|0001 2|0010 3|0011 4|0100 5|0101 6|0110 7|0111 8|1000 9|1001 10|1010 11|1011 12|1100 13|1101 14|1110 15|1111 Los números escritos en código binario tienen el mismo valor que en decimal, y sólo cambia la representación. Es decir, “15” en decimal y “1111” en binario representan exactamente a la misma idea: quince. #### Convertir números binarios a decimales Para obtener la representación decimal de un número binario hay que proceder según el Teorema Fundamental de la Normalización, del siguiente modo: 1. Numeramos la posición que ocupa cada dígito binario de derecha a izquierda, empezando por 0. Por ejemplo, en el número binario 1010011, numeraremos las posiciones así: XXX insertar imagen 2. Multiplicamos cada dígito binario por 2 elevado a la posición del dígito y sumamos todos los resultados. Con el número del ejemplo anterior: XXX insertar imagen Ahora sólo nos quedaría sumar los resultados de todas las multiplicaciones: 64 + 0 + 16 + 0 + 0 + 2 + 1 = 83 Por lo tanto, el número binario 1010011 es equivalente al número decimal 83. Es habitual indicar con un subíndice el sistema de numeración al que pertenece cada número, así: XXX insertar imagen o código HTML para: 10100112 = 8310 #### Convertir números decimales a binarios XXX revisar desde aquí --- El proceso contrario se realiza dividiendo sucesivamente el número decimal entre dos, y cogiendo el último cociente y todos los restos en el orden inverso al que los obtuvimos. Por ejemplo, vamos hallar la representación binaria del número 8310 : XXX insertar imagen Tomando el último cociente (que siempre es 1) y todos los restos desde el último hacia el primero (es decir, 010011, siguiendo la dirección de la flecha), obtenemos el número binario 1010011. Por lo tanto, podemos decir que: XXX insertar imagen o HTML: 8310 = 10100112 #### Operaciones aritméticas binarias La operaciones aritméticas binarias se realizan exactamente igual que las decimales, aunque teniendo la precaución de usar sólo los dos símbolos permitidos (0 y 1), lo que puede parecernos un poco extraño al principio. Por ejemplo, para realizar una suma de dos números binarios, escribiremos ambos números uno encima de otro, alineados a la derecha, como hacíamos cuando éramos tiernos infantes y estábamos aprendiendo a sumar. Luego, iremos sumando los dígitos de derecha a izquierda, como haríamos con dos números decimales, con la precaución de sumar también el acarreo cuando se produzca. Vamos a sumar los números 110012 y 10112 : 1 1 1 acarreos 1 1 0 0 1 + 1 0 1 1 1 0 0 1 0 0 Del mismo modo, pueden realizarse otras operaciones aritméticas como restas, productos o divisiones. ### 2.1.2. El código ASCII Hasta ahora hemos visto que mediante el código binario se pueden representar números, pero no sabemos cómo se las apaña un ordenador para representar las letras, o, dicho en terminilogía informática, los caracteres alfanuméricos (que incluyen números, letras y otros símbolos habituales, como los signos de puntuación). El código ASCII consiste en una correspondencia entre números binarios de 8 dígitos y caracteres alfanuméricos2. Así, por ejemplo, al número 6510 (en binario, 010000012) se le hace corresponder la letra A, al 6610 la B, al 6710 la C, etc. De este modo, el ordenador puede también manejar letras, y lo hace del mismo modo en que maneja números: mediante combinaciones de ceros y unos. Es importante resaltar que los códigos ASCII siempre tienen 8 dígitos binarios, rellenándose con ceros a la izquierda si fuera necesario. Así ocurre en el caso de la letra A, que, como hemos dicho, se representa con el código 01000001. El código ASCII no es el único que existe para representar letras en binario, pero sí el más extendido. ### 2.1.3. El código Unicode XXX redactar ### 2.1.4. El código hexadecimal Es importante conocer y saber manejar el código binario al ser el método de codificación que emplean los ordenadores digitales, pero este código tiene dos serios inconvenientes: • Primero, resulta difícil de manipular para cerebros que, como los nuestros, están habituados a pensar en decimal (o habituados a no pensar en absoluto, que también se da el caso). • Segundo, los números binarios pueden llegar a tener cantidades enormes de dígitos (es habitual trabajar con números de 16, 32 ó 64 dígitos binarios), lo cual los convierte en inmanejables. Por este motivo, suelen usarse, en programación, otros dos sistemas de numeración llamados octal y hexadecimal. El octal maneja 8 símbolos distintos y, el hexadecimal, 16. Sin duda, el más utilizado es el hexadecimal y por este motivo nos vamos a detener en él, aunque haciendo notar que el octal funciona de la misma manera, sólo que empleando los dígitos del 0 al 7. Si el sistema binario utiliza dos símbolos (0 y 1) y el decimal utiliza 10 (0, 1, 2, 3, 4, 5, 6, 7, 8 y 9), el hexadecimal emplea 16 símbolos, que son: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E y F. En hexadecimal, por tanto, es normal ver números cuyos dígitos son letras del alfabeto. Por ejemplo: 2AF5 es un número válido escrito en hexadecimal (exactamente, el 10997 en decimal). La forma de contar, por supuesto, es la misma: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, y después empezamos a agrupar los símbolos: 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 1A, 1B, 1C, 1D, 1E, 1F. Seguiríamos con 20, 21, 22, etc. Podemos construir una tabla para comparar los primeros números en los tres sistemas de numeración que conocemos. Hemos rellenado los primeros números binarios con ceros a la izquierda por razones que pronto se verán, pero en realidad los números no cambian (recuerda que un cero a la izquierda no tiene ningún valor, ni en binario ni en el resto de sistemas) XXX insertar tabla Si te fijas, cada dígito hexadecimal se corresponde exactamente con una combinación de 4 dígitos binarios. Así, por ejemplo, el número binario 1001 1101 se puede escribir más resumidamente como 9D en hexadecimal. Y esa es la gran utilidad del sistema hexadecimal: permite manipular números binarios de forma más escueta y resumida, de manera que nos sean más fáciles de manejar a nosotros, los humanos, que somos muy propensos a cometer errores. Convertir números hexadecimales a decimales El mecanismo es el mismo que ya utilizamos para convertir números binarios, sólo que cambiando la base del sistema de numeración de 2 a 16, ya que ahora vamos a manejar números hexadecimales. Por lo tanto, los pasos a seguir son: 1) Numeramos las posiciones que ocupa cada dígito hexadecimal de derecha a izquierda, empezando por 0. Por ejemplo, en el número hexadecimal 2AF, numeraremos las posiciones así: XXX insertar imagen 2) Multiplicamos cada dígito hexadecimal por 16 elevado a la posición del dígito y sumamos todos los resultados. Con el número 2AF lo haríamos así: 2 x 162 + A x 161 + F x 160 Según la tabla de anterior, tenemos que el dígito hexadecimal A equivale a 10 en decimal, y que F equivale a 15. Por lo tanto la operación quedaría así: 2 x 162 + 10 x 161 + 15 x 160 Ahora sólo nos falta resolver la operaciones y sumar: 2 x 256 + 10 x 16 + 15 x 1 = 687 Por lo tanto, el número hexadecimal 2AF16 es equivalente al número decimal 68710. Indicándolo con subíndices, lo expresaríamos así: 2AF16 = 68710 #### Convertir números decimales a hexadecimales El proceso también es idéntico al realizado con números binarios, pero sustituyendo la división entre 2 por divisiones entre 16, que es la base del sistema hexadecimal. #### Relación entre números hexadecimales y binarios La verdadera utilidad del sistema hexadecimal es que se puede utilizar en lugar del binario, siendo más fácil de manejar. Para que ello sea posible, el paso de hexadecimal a binario y viceversa debe poder hacerse con mucha rapidez. Para convertir un número hexadecimal a binario, basta con sustituir cada dígito hexadecimal por sus cuatro cifras binarias correspondientes, según la tabla de la página anterior. Por ejemplo: 2AF16 = 0010 1010 11112 Del mismo modo, para convertir un número binario a hexadecimal, lo agruparemos en bloques de 4 cifras binarias (empezando por la derecha) y buscaremos la correspondencia en la tabla. Por ejemplo, el número binario 100100 se convierte así: 0010 01002 = 2416 Observa que hemos rellenado con ceros a la izquierda para obtener bloques de 4 dígitos binarios sin alterar la esencia del número. Por supuesto, no es obligatorio hacerlo, pero las primeras veces puede facilitar las cosas. Con un poco de práctica conseguirás convertir binarios a hexadecimales y viceversa de un sólo vistazo y sin necesidad de consultar la tabla. ### 2.1.5. El código octal XXX redactar ## 2.2. Unidades de medida de información Como hemos visto, el código binario es el fundamento del funcionamiento de los ordenadores: toda la información que el ordenador maneja, ya sea numérica o alfanumérica, se encuentra codificada en binario. Del mismo modo que para medir distancias se utiliza el metro, o para medir masas se utiliza el gramo, para medir la cantidad de información almacenada o procesada en un ordenador existe otra unidad de medida. Como el ordenador representa toda la información en binario, la unidad fudamental es el dígito binario (es decir, 0 ó 1), también llamado BIT (de BInary digiT) Un bit es realmente muy poca cantidad de información. Recuerda que, por ejemplo, para almacenar un sólo carácter en código ASCII son necesarios 7 u 8 bits. ¡Para un único carácter! Del mismo modo que el metro dispone de múltiplos (el decámetro, el hectómetro, el kilómetro, etc), también los tiene el bit, y son los siguientes: • Byte: 1 byte equivale a 8 bits (un carácter). Esto no siempre ha sido así, pero, en la actualidad, se acepta la cifra de 8 como estándar. Cuidado con el nombre, porque se parecen y es un error común confundir el bit con el byte. • Kibibyte (KiB3 ): 1 kilobyte son 1024 bytes. Fïjate que es parecido al kilómetro (1000 metros), pero no exactamente igual. • Mebibyte (MiB): 1 megabyte equivale a 1024 kilobytes. • Gibibyte (GiB): 1 gigabyte equivale a 1024 megabytes. • Tebibyte (TiB): 1 terabyte equivale a 1024 gigabytes • Pebibyte (PiB): 1 pebibyte equivale a 1024 tebibytes. • Exbibyte (EiB): 1 exbibyte equivale a 1024 pebibytes. Podemos resumir las unidades de medida de información en la siguiente tabla: 1 Byte = 8 bits 1 KiB = 1024 Bytes 1 MiB = 1024 KiB 1 GiB = 1024 MiB 1 TiB = 1024 GiB 1 PiB = 1024 TiB 1 EiB = 1024 PiB Existe otra colección de múltiplos del Byte que se incrementan en potencias de 10, como sucede con los múltiplos de otras magnitudes físicas (tales como el kilómetro, el kilogramo, etc). Se introdujeron hace unos años para acabar con la confusión que provocaba el hecho de que algunos fabricantes consideraban que 1 KB eran 1024 Bytes, mientras que otros decían que eran 1000 Bytes. Estas otras unidades son: • Kilobyte (KB): 1 kilobyte son 1000 bytes. • Megabyte (MB): 1 megabyte equivale a 1000 kilobytes. • Gigabyte (GB): 1 gigabyte equivale a 1000 megabytes. • Terabyte (TB): 1 terabyte equivale a 1000 gigabytes • Petabyte (PB): 1 petabyte equivale a 1000 terabytes. • Exabyte (EB): 1 exabyte equivale a 1000 petabytes. Podemos resumir las unidades de medida de información en la siguiente tabla: 1 Byte = 8 bits 1 KB = 1000 Bytes 1 MB = 1000 KB 1 GB = 1000 MB 1 TB = 1000 GB 1 PB = 1000 TB 1 EB = 1000 EB Las unidades decimales son más pequeñas que las correspondientes binarias. Es decir, 1 GB, por ejemplo, son menos Bytes que 1 GiB. La diferencia es tanto mayor cuanto más grande es la unidad. Por ejemplo, 1 KB es un 2,35% más pequeño que 1 KiB, pero 1 EB es un 13,3% más pequeño que 1 EiB. ¡Entre 1 EB y 1 EiB hay 150 millones de GB de diferencia! Por lo tanto, no es de extrañar que las compañías de telefonía o los fabricantes de dispositivos de almacenamiento publiciten sus capacidades en las unidades más pequeñas posible. Por último, hacemos notar que, en ocasiones, también se usan los mismos múltiplos para el bit, no para el Byte. Así, puedes encontrarte con megabits (Mb) o mebibits (Mib), que son, respectivamente, un millón (1.000.000) de bits y 220 bits (1.048.576). O con gigabits (Gb) o gigibits (Gib). La conversión entre los múltiplos del bit los del Byte se realiza multiplicando o dividiendo entre 8, como es lógico. Observa como se usa la \"b\"minúscula para distinguir los bits de los Bytes. ",
    "url": "/docs/prog-y-3d/_site/representacion-de-la-informacion/",
    "relUrl": "/representacion-de-la-informacion/"
  },"3": {
    "doc": "3. Introducción a la programación",
    "title": "3. Introducción a la programación",
    "content": "# 3. Introducción a la programación {: .no_toc } - TOC {:toc} Lenguajes de programación. Tipos de lenguajes. Estructura de un programa informático. Tipos básicos de datos. Constantes y variables. Operadores y expresiones. Comentarios. Pseudocódigo y diagramas de flujo. Estructuras de control: secuencial, condicional e iterativa. ",
    "url": "/docs/prog-y-3d/_site/introduccion-a-la-programacion/",
    "relUrl": "/introduccion-a-la-programacion/"
  },"4": {
    "doc": "4. Estructuras de datos",
    "title": "4. Estructuras de datos",
    "content": "# 4. Estructuras de datos {: .no_toc } - TOC {:toc} Estructuras de datos. Funciones y bibliotecas de funciones. Reutilización de código. Facilidades para la entrada y salida de datos de usuario. Manipulación de archivos. ",
    "url": "/docs/prog-y-3d/_site/estructuras-de-datos/",
    "relUrl": "/estructuras-de-datos/"
  },"5": {
    "doc": "5. Orientación a objetos",
    "title": "5. Orientación a objetos",
    "content": "# 5. Orientación a objetos {: .no_toc } - TOC {:toc} Orientación a objetos. Clases, objetos y constructores. Herencia. Subclases y superclases. Polimorfismo y sobrecarga. Encapsulamiento y ocultación. ",
    "url": "/docs/prog-y-3d/_site/orientacion-a-objetos/",
    "relUrl": "/orientacion-a-objetos/"
  },"6": {
    "doc": "6. Entornos integrados de desarrollo",
    "title": "6. Entornos integrados de desarrollo",
    "content": "# 6. Entornos integrados de desarrollo {: .no_toc } - TOC {:toc} Entornos integrados de desarrollo. Depuración. Ciclo de vida del software. Trabajo en equipo y mejora continua. Control de versiones. Metodologías ágiles: Scrum. ",
    "url": "/docs/prog-y-3d/_site/entornos-integrados-de-desarrollo/",
    "relUrl": "/entornos-integrados-de-desarrollo/"
  },"7": {
    "doc": "7. Lenguaje PHP",
    "title": "7. Lenguaje PHP",
    "content": "# 7. Lenguaje PHP {: .no_toc } - TOC {:toc} Lenguajes de programación reales. El lenguaje PHP ",
    "url": "/docs/prog-y-3d/_site/lenguaje-php/",
    "relUrl": "/lenguaje-php/"
  },"8": {
    "doc": "8. Bases de datos",
    "title": "8. Bases de datos",
    "content": "# 8. Bases de datos {: .no_toc } - TOC {:toc} Almacenamiento de la información. Ficheros. Bases de datos relacionales. Sistemas gestores de bases de datos. Diseño conceptual. Diagramas entidad-relación. Normalización hasta 3FN y FNBC. Definición y manipulación. ",
    "url": "/docs/prog-y-3d/_site/bases-de-datos/",
    "relUrl": "/bases-de-datos/"
  },"9": {
    "doc": "9. El lenguaje SQL",
    "title": "9. El lenguaje SQL",
    "content": "# 9. El lenguaje SQL {: .no_toc } - TOC {:toc} Comandos básicos de SQL: DDL, DML y DCL. ",
    "url": "/docs/prog-y-3d/_site/lenguaje-sql/",
    "relUrl": "/lenguaje-sql/"
  },"10": {
    "doc": "10. Seguridad y privacidad",
    "title": "10. Seguridad y privacidad",
    "content": "# 10. Seguridad y privacidad {: .no_toc } - TOC {:toc} Seguridad y privacidad. Acceso a la información de las bases de datos. ",
    "url": "/docs/prog-y-3d/_site/seguridad-y-privacidad/",
    "relUrl": "/seguridad-y-privacidad/"
  },"11": {
    "doc": "11. Tecnologías de impresión 3D",
    "title": "11. Tecnologías de impresión 3D",
    "content": "# 11. Tecnologías de impresión 3D {: .no_toc } - TOC {:toc} Tecnologías de impresión 3D. Utilidad y posibilidades del diseño 3D. Impresión 3D por FDM. Impresoras 3D por FDM. Partes, funcionamiento y mantenimiento básico. ",
    "url": "/docs/prog-y-3d/_site/tecnologias-de-impresion-3d/",
    "relUrl": "/tecnologias-de-impresion-3d/"
  },"12": {
    "doc": "12. Modelado e impresión 3D",
    "title": "12. Modelado e impresión 3D",
    "content": "# 12. Modelado e impresión 3D {: .no_toc } - TOC {:toc} Modelado e impresión 3D. Software para diseño 3D y software para slicing (laminado). Creación e impresión de figuras básicas. Transformación, rotación y unión de figuras básicas. Formatos para impresión 3D. Pruebas de impresión. ",
    "url": "/docs/prog-y-3d/_site/modelado-e-impresion-3d/",
    "relUrl": "/modelado-e-impresion-3d/"
  },"13": {
    "doc": "About",
    "title": "About",
    "content": "Estos apuntes han sido elaborados por Antonio Zapata Sierra y Alfredo Moreno Vozmediano, del Departamento de Informática del IES Celia Viñas de Almería, y se publican aquí con licencia [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/), lo que quiere decir que eres libre de usar este material, copiarlo, distribuirlo y modificarlo siempre que el resultado de todo eso mantenga la misma licencia y cites la autoría original. Algunos fragmentos (pocos) están tomados y adaptados de otras fuentes. Cuando eso ocurre, lo indicamos claramente en el texto. Debes atenerte a la licencia de los sitios web de origen para esos fragmentos. ",
    "url": "/docs/prog-y-3d/_site/about/",
    "relUrl": "/about/"
  },"14": {
    "doc": "Introd. a la prog. y al diseño 3D",
    "title": "Introd. a la prog. y al diseño 3D",
    "content": "Esta es la documentación (apuntes) de ***Introducción a la programación y al diseño 3D***, optativa de 2º de Bachillerato ofertada por el IES Celia Viñas de Almería (España). 1. TOC {:toc} ",
    "url": "/docs/prog-y-3d/_site/",
    "relUrl": "/"
  }
}
