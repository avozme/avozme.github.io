{"0": {
    "doc": "0. Presentación de la asignatura",
    "title": "0. Presentación de la asignatura",
    "content": "# 0. Presentación de la asignatura {: .no_toc } - TOC {:toc} ## 0.1. Contextualización y horario La asignatura **Introducción a la programación y al diseño 3D** se imparte como optativa en segundo curso de Bachillerato en el IES Celia Viñas de Almería y tiene una duración de 72 horas (2 horas semanales). El profesor encargado de impartirla durante el curso 2021-2022 es **Alfredo Moreno Vozmediano**, miembro del Departamento de Informática. Salvo cambio de criterio de la dirección del centro, durante el curso actual, el **horario** de clases será el siguiente: * Miércoles de 9:05 a 10:05 horas (aula 19). * Jueves de 12:35 a 13:35 horas (aula ?). ## 0.2. Objetivos Los objetivos de esta asignatura son los siguientes: 1. Comprender el impacto del pensamiento computacional en la sociedad actual. 2. Producir programas informáticos plenamente funcionales. 3. Integrarse en un equipo de desarrollo de software que sea capaz de afrontar proyectos de cierta envergadura. 4. Desarrollar la capacidad de abstracción. 5. Emplear la creatividad en el desarrollo de aplicaciones informáticas para resolver problemas y fomentar la capacidad de expresión personal. 6. Recopilar, almacenar y procesar datos con el objetivo de encontrar patrones, descubrir conexiones y resolver problemas. 7. Analizar cómo la representación, el almacenamiento, la seguridad y la transmisión de datos requiere de manipulación computacional, y comprender los riesgos de seguridad y privacidad existentes cuando se trata de información personal. 8. Conocer los fundamentos y aplicaciones del Diseño Asistido por Ordenador y capacitar para el diseño de objetos bidimensionales y tridimensionales sencillos. 9. Fomentar el trabajo en equipo y la comunicación interpersonal. ## 0.3. Contenido Los contenidos de la asignatura se dividen en **cuatro bloques y 12 unidades didácticas**. Los resumimos a continuación. **Bloque 1. Representación digital y pensamiento computacional** * UD1. Características, ejemplos e importancia del pensamiento computacional. * UD2. Representación de la información. Bits, bytes, múltiplos y submúltiplos. Almacenamiento, transmisión y tratamiento de la información binaria. Representaciones octal y hexadecimal. ASCII y Unicode. **Bloque 2. Introducción a la programación** * UD3. Lenguajes de programación. Tipos de lenguajes. Estructura de un programa informático. Tipos básicos de datos. Constantes y variables. Operadores y expresiones. Comentarios. Pseudocódigo y diagramas de flujo. Estructuras de control: secuencial, condicional e iterativa. * UD4. Estructuras de datos. Funciones y bibliotecas de funciones. Reutilización de código. Facilidades para la entrada y salida de datos de usuario. Manipulación de archivos. * UD5. Orientación a objetos. Clases, objetos y constructores. Herencia. Subclases y superclases. Polimorfismo y sobrecarga. Encapsulamiento y ocultación. * UD6. Entornos integrados de desarrollo. Depuración. Ciclo de vida del software. Trabajo en equipo y mejora continua. Control de versiones. Metodologías ágiles: Scrum. * UD7. Lenguajes de programación reales. Java, Python o PHP. **Bloque 3. Datos e Información** * UD8. Almacenamiento de la información. Ficheros. Bases de datos relacionales. Sistemas gestores de bases de datos. Diseño conceptual. Diagramas entidad-relación. Normalización hasta 3FN y FNBC. Definición y manipulación. * UD9. Comandos básicos de SQL: DDL, DML y DCL. * UD10. Seguridad y privacidad. Acceso a los información de las bases de datos. **Bloque 4. Diseño 3D** * UD11. Tecnologías de impresión 3D. Utilidad y posibilidades del diseño 3D. Impresión 3D por FDM. Impresoras 3D por FDM. Partes, funcionamiento y mantenimiento básico. * UD12. Modelado e impresión 3D. Software para diseño 3D y software para slicing (laminado). Creación e impresión de figuras básicas. Transformación, rotación y unión de figuras básicas. Formatos para impresión 3D. Pruebas de impresión. ## 0.4. Evaluación y calificación A lo largo de curso se evaluarán los siguientes elementos: * **Observación del trabajo diario** en el aula (calificación de 1 a 10). * **Actividades, prácticas y proyectos** (calificación de 1 a 10). * **Test de conocimientos** (exámenes) (calificación de 1 a 10). Para aprobar cada **evaluación trimestral**, es necesario **obtener al menos un 5** en cada uno de los apartados anteriores. La nota trimestral se calculará así: * Observación directa y trabajo diario: 30% * Prácticas y proyectos: 40% * Tests de conocimientos: 30% La **nota final del curso** se obtendrá mediante una media aritmética de las calificaciones obtenidas en cada trimestre. Se hará un examen teórico-práctico final, con actividades de un nivel similar a las propuestas en las prácticas y proyectos, para las personas que no hayan superado alguna de las evaluaciones trimestrales. Asimismo, habrá una recuperación en septiembre con la misma naturaleza y que abarcará toda la materia impartida durante el curso. ",
    "url": "/docs/prog-y-3d/_site/presentacion/",
    "relUrl": "/presentacion/"
  },"1": {
    "doc": "1. Pensamiento computacional",
    "title": "1. Pensamiento computacional",
    "content": "# 1. Pensamiento computacional {: .no_toc } - TOC {:toc} ## 1.1. ¿Qué es eso del pensamiento computacional? El pensamiento computacional es un proceso de **formulación y resolución de problemas que utiliza los conceptos de la ingeniería informática**. Es decir, consiste en pensar como lo haría un científico-informático cuando está frente un problema y tener la habilidad y la actitud para que nos sea útil tanto en nuestra vida personal como profesional. Hemos dicho \"vida personal\", sí. Uno de los errores más frecuentes cuando se habla de *pensamiento computacional* es considerar que solo se aplica a la Informática. El pensamiento computacional **sirve para resolver problemas cotidianos haciendo uso de las técnicas y habilidades de los programadores/as informáticos** y obtener así soluciones que pueden ser representadas mediante una serie de pasos o instrucciones. Aquí tienes un vídeo que desarrolla esta interesante idea en tres minutos: ## 1.2. Características del pensamiento computacional Según las definiciones que hemos visto en el apartado anterior, el pensamiento computacional es un proceso de resolución de problemas que incluye las siguientes características: * Reformular problemas de forma que se permita el uso de un ordenador y otras herramientas para ayudar a resolverlos. * Organizar y analizar lógicamente la información. * Representar la información a través de abstracciones como los modelos y las simulaciones. * Automatizar soluciones haciendo uso del pensamiento algorítmico (estableciendo una serie de pasos ordenados para llegar a la solución). * Identificar, analizar e implementar posibles soluciones con el objetivo de lograr la combinación más efectiva y eficiente de pasos y recursos. * Generalizar y transferir este proceso de resolución de problemas para ser capaz de resolver una gran variedad de familias de problemas. #### Ejemplo de pensamiento computacional Escribir **una receta de cocina** siguiendo unos pasos o instrucciones sería un buen primer ejemplo de aplicación para el pensamiento computacional. Por ejemplo, supongamos que queremos cocinar un *risotto* utilizando un sobre de comida preparada (para que sea más rápido). No te preocupes si no tienes ni idea de lo que es un *risotto*. En realidad, y gracias al pensamiento computacional, no necesitas saber lo que es para prepararlo, puesto que el pensamiento computacional te permite disponer de una receta. En este caso, los pasos de la receta serían más o menos estos: 1. Abrir el sobre 2. Poner a calentar el agua 3. Esperar a que el agua hierva 4. Si hierve, verter el sobre 5. Remover el contenido de la olla 6. Apagar el fuego y dejar reposar 7. Servir en el plato para \"x\" personas Si sigues esos pasos, seguro que puedes obtener algo comestible aunque no tengas ni idea de qué estás cocinando en realidad, ¿verdad? El pensamiento computacional consiste en enfrentarse a un problema (como \"cocinar un *risotto*\") y obtener una solución (como una \"receta\") que permita solucionarlo todas las veces que sean necesarias. Si la \"receta\" anterior la escribiéramos usando un lenguaje de programación, tendríamos en nuestras manos un programa de ordenador. De hecho, podemos \"escribirla\" en un lenguaje de programación por bloques gráficos, como el popular *Scratch*, y nos quedaría algo así: ![Ejemplo de receta escrita con Scratch](/docs/prog-y-3d/_site/assets/images/01-scratch.jpg) ## 1.3. El pensamiento computacional vs la programación Los términos \"pensamiento computacional\" y \"programación\" no son sinónimos. Esta es una confusión muy habitual. La programación solo es una de las posibles herramientas con la que se pone en práctica el pensamiento computacional. Por eso la programación y el pensamiento computacional comparten los mismos procesos cognitivos. La programación limita sus procesos de resolución de problemas al ámbito de la informática. Para ello, hace uso de diferentes lenguajes de programación. Puedes pedir a un ordenador que haga muchas cosas, pero no que prepare un *risotto*. Así que el pensamiento computacional puede aplicarse a problemas más allá de la informática. > ***Curiosidad**: ¿sabías que las peronas que aprenden a utilizar un lenguaje de programación muestran mayor capacidad de atención y autonomía, y obtienen en promedio mejores resultados en pruebas matemáticas, que las que no saben programar?* [Diversos estudios](https://www.redalyc.org/pdf/547/54741184011.pdf) han demostrado que, mediante los lenguajes de programación, se desarrollan ciertas habilidades cognitivas como: * El pensamiento lógico. * La creatividad. * El razonamiento abstracto. * La capacidad de resolución de problemas. Así que, si quieres orientar tu vida académica hacia las ciencias o la ingeniería, aprender a programar puede ser una herramienta muy útil para ti. Pero incluso si tus preferencias académicas van por otro camino, las rutinas de pensamiento computacional que adquirirás programando te reportarán muchos beneficios que quizá no sospechabas. ## 1.4. Algoritmos y descomposición de problemas Tanto el pensamiento computacional como la programación utilizan procesos cognitivos idénticos, como hemos dicho. Y el principal de ellos se denomina **\"Divide y vencerás\"** (*\"Divide and Conquer\"* en inglés). Es decir: descompón tu problema en problemas más pequeños, hasta que sean lo suficientente pequeños para afrontarlos. Y luego reúnelos todos como un puzle para componer la solución final. Fácil de explicar, difícil de hacer. ![Divide y vencerás](/docs/prog-y-3d/_site/assets/images/01-divide-y-venceras.jpg) El pensamiento computacional busca encontrar una \"receta\" para resolver cualquier problema computable. Esas recetas se denominan **algoritmos**. Un algoritmo, por tanto, es *un conjunto de pasos que, aplicados sistemáticamente a unos datos de entrada apropiados, resuelven un problema en un numero finito de pasos.* Nuestra receta de cocina para el *risotto* era un algoritmo. Las instrucciones para fabricar un avión de papel a partir de un folio también lo son. El motor de búsqueda de Google es otro algoritmo. Obviamente, el grado de complejidad de esos algoritmos no es comparable entre sí. Pero todos son algoritmos. Los algoritmos tienen una **entrada** (input) y una **salida** (output), y entre ambas están los pasos o instrucciones. La entrada de un algoritmo pueden ser los ingredientes para cocinar un *risotto*, y la salida es el plato comestible. Este es un algoritmo computable pero no programable, porque ningún ordenador podría ejecutarlo. La entrada del algoritmo de Google es el texto que escribimos en la caja de búsqueda, y la salida es la lista de resultados. Este es un algoritmo computable y programable (de hecho, la gente de Google lo ha programado, ¿no?) En realidad, los algoritmos recogen operaciones tan sencillas que pueden ser realizadas con éxito por cualquiera. *Incluso por las máquinas*. **La unión de máquinas y algoritmos es lo que está cambiando el mundo**. El matemático británico [Alan Turing](https://es.wikipedia.org/wiki/Alan_Turing), famoso por haber *hackeado* la máquina Enigma de mensajes cifrados de los nazis muchos años antes de que se inventara el término \"*hackear*\", y por haberse suicidado tras sufrir una dura persecución debido a su condición homosexual, fue de los primeros que relacionó algoritmos y ordenadores. De hecho, fue de los primeros que imaginó un ordenador tal y como lo conocemos hoy. Así es: los ordenadores actuales son, en esencia, *Máquinas de Turing* mucho más potentes de lo que Turing pudo soñar. ![Alan Turing](/docs/prog-y-3d/_site/assets/images/01-alan-turing.jpg) **El trabajo de los programadores/as informáticos** consiste en traducir los problemas del mundo a un lenguaje que una máquina pueda entender. Así, **un programa de ordenador** es un algoritmo escrito en un lenguaje de programación. Es decir, un conjunto de miles (¡o millones!) de operaciones sencillas que, como las piezas de un puzle, encajan para dar lugar a la solución final. Los algoritmos se usan para cualquier cosa: predecir resultados electorales, calcular trayectorias de satélites, conocer nuestros gustos y preferencias... El mundo del trabajo se va *algoritmizando* poco a poco: las diferentes tareas se convierten en algoritmos y se automatiza el trabajo. **Las únicas tareas no computables, por el momento, son las relacionadas con la creatividad y las emociones**. ¡Así que ya sabes dónde seguirá existiendo trabajo en las próximas décadas! ## 1.5. Algunos algoritmos famosos en tiempos de internet La palabra algoritmo se ha puesto de moda en los últimos años. Los ordenadores pueden hacer cálculo mucho más deprisa, y con mucha más fiabilidad, que un cerebro humano. Desde la aparición de Internet, se ha producido un salto cualitativo y estamos llegando a computar cosas que antes parecían imposibles. Por eso han surgido disciplinas en plena ebullición como el *big data* o la inteligencia artificial. #### El Algoritmo de Facebook ![Edgerank, el algoritmo de Facebook](/docs/prog-y-3d/_site/assets/images/01-edgerank.jpg) En el *big data*, los algoritmos analizan millones de datos de los clientes. Hay algoritmos ejecutándose en los ordenadores de a bordo de los automóviles, en los satélites de control de tráfico o en las redes sociales. El algoritmo que decide qué ve cada usuario en su muro de Facebook fue uno de los primeros en utilizar *big data*. Es un algoritmo tan famoso que hasta tiene nombre propio: **EdgeRank**. Cada vez que Facebook realiza cambios importantes en *EdgeRank*, se produce un revuelo en Facebook. A principios de 2018, por ejemplo, Facebook decidió dar más importancia a los usuarios particulares que a las empresas, marcas y medios de comunicación, en un intento de que la red social volviera a ser más \"social\" y paliar un poco la invasión de las *fake news*. El cambio dio bastantes quebraderos de cabeza a empresas y medios y, en algunos casos, provocó pérdidas millonarias. #### Algoritmo de Google ![Pagerank, el algoritmo de Google](/docs/prog-y-3d/_site/assets/images/01-pagerank.jpg) Tal vez el algoritmo más famoso del mundo, después del de la multiplicación, sea el de Google. Creado en 1998 y llamado **PageRank**, su éxito revolucionario consistió en que rastreaba la web y daba resultados de búsqueda ordenados por su importancia. ¿Y cómo mide *PageRank* la importancia de cada web? Es un secreto mejor guardado que la fórmula de la Coca-cola. El *PageRank* original medía la importancia de una web por la cantidad de webs que estaban enlazadas a ella. Esa fue la clave de su éxito inicial. En la actualidad, sospecho que ni siquiera los ingenieros de Google están muy seguros de qué cosas mide *PageRank* y en qué medida influyen en sus resultados. Actualmente, *PageRank* es capaz de adaptar sus resultados al usuario (no es lo mismo ser un adulto que un niño, o lanzar una búsqueda desde Almería que hacerlo desde Silicon Valley), ofrecer mapas, imágenes, corregir la ortografía de la búsqueda o entender cuándo en la caja de búsqueda se escribe una pregunta. Y darle respuesta. #### El algoritmo de Amazon ![A9, el algoritmo de Amazon](/docs/prog-y-3d/_site/assets/images/01-amazon.jpg) ¿Despedido por un algoritmo? No es ciencia ficción. De hecho, es algo que ocurre desde hace años. Las máquinas toman decisiones en lugar de los humanos pero que afectan directamente los humanos. Entre 2017 y 2018, más de 300 empleados de Amazon fueron despedidos por falta de productividad en una de sus sedes en Baltimore. Lo llamativo es que detrás esta decisión no hubo una inteligencia humana, sino artificial. Amazon mide individual y automáticamente la productividad de cada trabajador en base al número de paquetes que confeccionan cada hora. El programa, en caso de detectar empleados de baja productividad, genera automáticamente advertencias e incluso procesa automáticamente despidos, sin la intervención de los supervisores. De esta forma, los empleados son supervisados por algoritmos que llegan hasta el punto de conocer el tiempo que emplean fuera de sus tareças. Por ejemplo, si los empleados dejan de escanear paquetes durante demasiado tiempo, el sistema genera automáticamente alertas y el empleado puede ser despedido. Por otro lado, Amazon ha sido acusado en repetidas ocasiones de manipular sus algoritmos de búsqueda de productos dentro de su web, para priorizar los productos que les son más rentables. Cosa que no es de extrañar, por otra parte, ¿no te parece? La cuestión es esta: *un pequeño cambio en un algoritmo puede afectar a una gran parte del comercio electrónico mundial y a miles de fabricantes y vendedores*. ## 1.6. Actividades #### Ejercicio 1 Vamos a escribir nuestro primer algoritmo. Así, sin miedo. Imagina que tienes que explicarle a un extraterrestre recién llegado a la Tierra cómo debe cruzar un semáforo para evitar ser arrollado por los coches. (Si la metáfora del extraterrestre te parece excesiva, imagina que se lo tienes que explicar a un niño o niña muy pequeño) El extraterrestre (o el niño) solo comprende órdenes muy sencillas: camina, no camines, mira la luz, ¿es verde?, ¿es roja?, y cosas así. Tienes que exponer las instrucciones en una lista de pasos o \"receta de cocina\" expresada con acciones sencillas como las anteriores. Venga, a ver qué te sale. (Nota: no te desesperes si no sabes ni cómo empezar. Eso le pasa a todo el mundo la primera vez) #### Ejercicio 2 Ahora lo vamos a complicar un poco más, enfrentándonos a un algoritmo clásico en las ciencias de la computación. Se trata de encontrar el camino más corto entre dos puntos. En nuestro caso, queremos llegar desde A (Salida) hasta F (Meta). Cada camino tiene un peso (el numerito indicado en él). Puedes considerar que ese peso es el tiempo o la distancia, da lo mismo. Constrúyete una tabla con todos los diferentes caminos o recorridos posibles y el valor total de tiempo (o distancia) que acaba sumando cada uno de ellos. ![Grafo de Dijkstra](/docs/prog-y-3d/_site/assets/images/01-grafo.jpg) ¿Cómo se podría construir un algoritmo genérico que encontrase el camino más corto entre dos puntos cualesquiera, en un mapa con cualquier número de puntos y cualquier número de contexiones? Trata de pensarlo unos minutos. Después, cuando notes que la cabeza va a explotarte, bichea un poco por Internet en busca del **algoritmo de Dijkstra**. Brevemente y con tus propias palabras, comenta en qué consiste y trata de aplicarlo al problema anterior. #### Ejercicio 3 Investiga en internet quién fue **Ada Lovelace** y explica en pocas frases qué relación tiene con el mundo de los algoritmos y la programación de ordenadores. #### Ejercicio 4 Investiga en Internet sobre el escándalo de **Cambridge Analytica** y responde con tus palabras (¡y brevemente!) a las siguientes cuestiones: 1. Detalla qué es Cambridge Analytica y a qué se dedicaba. 2. ¿Con qué fin recababa Cambridge Analytica datos y perfiles de usuarios? 3. ¿Cuándo y por qué se produjo un escándalo mundial relacionado directamente con ella? 4. Describe el funcionamiento del algoritmo de Cambridge Analytica y explica como pudo influenciar mediante el mismo en las victorias de Donald Trump en Estados Unidos y del Brexit en Inglaterra? 5. ¿Cuál fue el número de usuarios de Facebook afectados? ¿Cuantos miles de millones de dólaresperdió Facebook tras el escándalo? 6. Busca y encuentra un video corto en youtube donde aparezca Mark Zuckerberg declarando en el congreso de Estados Unidos, dando explicaciones sobre el escándalo de Cambridge Analytica. (No olvides activar los subtítulos si tienes problemas con el inglés). ¿Con qué argumentos se defendió Zuckerberg de las acusaciones? #### Ejercicio 5 Vamos investigar entre todos sobre algunos algoritmos famosos en la historia de la computación: 1. Algoritmo del viajante de comercio. 2. Algoritmo de los filósofos comensales. 3. Algoritmo quicksort 4. Algoritmo mergesort 5. Algoritmo bubblesort o algoritmo de la burbuja 6. Algoritmo auto-tune 7. Algoritmo de la transformada rápida de Fourier 8. Algoritmo OkCupid Date Matching 9. Algoritmo de las ocho reinas 10. Algoritmo de la criba de Eratóstenes 11. Algoritmo MD5 12. Algoritmo SHA1 Una vez que se te asigne uno de estos algoritmos, lo que tienes que investigar es muy sencillo: * ¿Qué problema pretende resolver ese algoritmo? * ¿Cómo lo resuelve? (Expresado en términos sencillos y de andar por casa) ",
    "url": "/docs/prog-y-3d/_site/pensamiento-computacional/",
    "relUrl": "/pensamiento-computacional/"
  },"2": {
    "doc": "2. Representación de la información",
    "title": "2. Representación de la información",
    "content": "# 2. Representación de la información {: .no_toc } El ordenador es una máquina digital, es decir, binaria. Cualquier aprendiz de programador/a debe conocer esa forma de codificación, y otras primas suyas (como la octal y la hexadecimal) antes de aventurarse en los vericuetos de la programación. Dedicaremos todo este tema a hacerlo. - TOC {:toc} ## 2.1. Los códigos Un **código** es un *método de representación de la información*. Se compone de un conjunto de símbolos, llamado **alfabeto**, y de un conjunto de **reglas** para combinar esos símbolos de forma correcta. Estos son algunos ejemplos de códigos que utilizas todos los días o que, al menos, conoces: * **Ejemplo 1**: la lengua castellana es un código. Su alfabeto es el abecedario (a, b, c, d, e ... z), pero los símbolos del alfabeto no se pueden combinar a lo loco, sino que existen unas reglas, y sólo siguiendo esas reglas se codifica correctamente la información, dando lugar a mensajes con sentido. Esas reglas las habéis estudiado en la asignatura de lengua castellana desde la enseñanza primaria. * **Ejemplo 2**: el código morse también es un código. Su alfabeto es muy reducido: sólo el punto (.) y la raya (–), pero combinando los dos símbolos correctamente, se puede transmitir cualquier información. * **Ejemplo 3**: el sistema de numeración decimal es un código. Tiene un alfabeto de 10 símbolos (0, 1, 2, 3, 4, 5, 6, 7, 8 y 9). Combinándolos según ciertas reglas, puede usarse para transmitir información. Pero ojo, no cualquier información, solamente información numérica. Hemos dicho que los códigos sirven para representar información, pero no que tengan que servir para representar toda la información posible. Aunque sólo sirva para los números, el sistema de numeración también es un código. ### 2.1.1. El código binario Pues bien, **el sistema de numeración binario también es un código**. Es muy parecido al sistema de numeración decimal, con la única diferencia de la cantidad de símbolos del alfabeto. Si el decimal tiene diez, el binario sólo tiene dos: el 0 y el 1. En todo lo demás son iguales, así que el sistema binario también sirve para representar información numérica. Pero, ¿puede representarse cualquier número con sólo dos símbolos? La respuesta es sí. El modo de hacerlo consiste en combinar los símbolos 0 y 1 adecuadamente, igual que hacemos con los números decimales. En el sistema decimal contamos así: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9. Cuando queremos pasar a la siguiente cantidad, empezamos a agrupar los dígitos de dos en dos: 10, 11, 12, 13, 14, 15, 16, 17, 18, 19. Al volver a terminar las unidades, vamos incrementando las decenas: 20, 21, 22, etc. (Esto se debe a que, en los sistemas de numeración, cada dígito tiene un valor posicional, es decir, tiene un valor diferente dependiendo del lugar que ocupe en el número general. Por ejemplo, en el número 283, el 3 tiene valor de tres, pero el 8 no tiene valor de ocho, sino de ochenta, y el 2 no tiene valor de dos, sino de doscientos) En binario, el razonamiento es el mismo. Empezamos a contar por 0 y 1, pero entonces ya hemos agotado los símbolos, así que empezamos a agruparlos: 10, 11. Como hemos vuelto a agotarlos, seguimos combinándolos: 100, 101, 110, 111, 1000, 1001, 1010, y así sucesivamente. Así, los 16 primeros números binarios comparados con sus equivalentes decimales son: Decimal|Binario -|- 0|0000 1|0001 2|0010 3|0011 4|0100 5|0101 6|0110 7|0111 8|1000 9|1001 10|1010 11|1011 12|1100 13|1101 14|1110 15|1111 Los números escritos en código binario tienen el mismo valor que en decimal, y sólo cambia la representación. Es decir, “15” en decimal y “1111” en binario representan exactamente a la misma idea: quince. #### Convertir números binarios a decimales Para obtener la representación decimal de un número binario hay que proceder según el Teorema Fundamental de la Normalización, del siguiente modo: 1. Numeramos la posición que ocupa cada dígito binario de derecha a izquierda, empezando por 0. Por ejemplo, en el número binario 1010011, numeraremos las posiciones así: ``` Posiciones --> 6 5 4 3 2 1 0 Dígitos --> 1 0 1 0 0 1 1 ``` 2. Multiplicamos cada dígito binario por 2 elevado a la posición del dígito y sumamos todos los resultados. Con el número del ejemplo anterior: 1 x 26 + 0 x 25 + 1 x 24 + 0 x 23 + 0 x 22 + 1 x 21 + 1 x 20 . 3. Ahora sólo nos quedaría sumar los resultados de todas las multiplicaciones: 64 + 0 + 16 + 0 + 0 + 2 + 1 = 83 . Por lo tanto, el número binario 1010011 es equivalente al número decimal 83. Es habitual indicar con un subíndice el sistema de numeración al que pertenece cada número, así: 10100112 = 8310 . #### Convertir números decimales a binarios El proceso contrario se realiza dividiendo sucesivamente el número decimal entre dos, y cogiendo el último cociente y todos los restos en el orden inverso al que los obtuvimos. Por ejemplo, vamos hallar la representación binaria del número 8310: . Tomando el último cociente (que siempre es 1) y todos los restos desde el último hacia el primero (es decir, 010011, siguiendo la dirección de la flecha), obtenemos el número binario 1010011. Por lo tanto, podemos decir que: 8310 = 10100112 . #### Operaciones aritméticas binarias La operaciones aritméticas binarias se realizan exactamente igual que las decimales, aunque teniendo la precaución de usar sólo los dos símbolos permitidos (0 y 1), lo que puede parecernos un poco extraño al principio. Por ejemplo, para realizar una suma de dos números binarios, escribiremos ambos números uno encima de otro, alineados a la derecha, como hacíamos cuando estábamos aprendiendo a sumar. Luego, iremos sumando los dígitos de derecha a izquierda, como haríamos con dos números decimales, con la precaución de sumar también el acarreo cuando se produzca. Vamos a sumar los números 110012 y 10112: ``` 1 1 1 10 (expresado en binario, 010000012) se le hace corresponder la letra \"A\", al 6610 la \"B\", al 6710 la \"C\", etc. De este modo, el ordenador puede también manejar letras, y lo hace del mismo modo en que maneja números: mediante combinaciones de ceros y unos. La siguiente tabla muestra los 127 primeros caracteres del código ASCII junto con el número al que corresponden en decimal, binario, octal y hexadecimal (estos dos últimos son sistemas de numeración que veremos enseguida): ![Tabla ASCII simplificada](/docs/prog-y-3d/_site/assets/images/02-tabla-ascii.png) (Fuente: Wikimedia Commons - Dominio público) Es importante resaltar que los códigos ASCII siempre tienen 8 dígitos binarios, rellenándose con ceros a la izquierda si fuera necesario. Así ocurre en el caso de la letra A, que, como hemos dicho, se representa con el código 01000001. Si te tomas la molestia de calcular cuántos caracteres diferentes pueden representarse con el código ASCII, verás que son exactamente 256. Suficientes para todos los caracteres habituales, ¿verdad? Aunque, un momento... ¿Y qué hay de los caracteres griegos? ¿O los caracteres cirílicos del ruso? Eso por no hablar del chino y o el japonés. Si queremos dar cabida a cualquier idioma del mundo, el código ASCII se nos queda rápidamente pequeño. Por eso se ideó otra forma de codificación de caracteres que es la que más se usa en la actualidad: Unicode. ### 2.1.3. El código UTF-8 de Unicode El código ASCII no es, desde luego, el único que existe para representar letras en binario, pero sí el más popular por motivos históricos. A finales de la década de 1980, se empezó a desarrollar un proyecto para codificar de forma unívoca todos los caracteres de todas las lenguas del mundo (¡incluidas lenguas muertas!). A ese proyecto se lo denominó **Unicode**. Unicode se ha impuesto con fuerza en la actualidad. Por ejemplo, este documento que estás leyendo ahora mismo está codificado con Unicode, en su versión UTF-8. Y es que Unicode tiene varias implementaciones: * **UTF-8**: los caracteres se codifican en grupos de 8 bits. Algunos solo necesitan 8 bits, pero otros necesitan 16, 24 o incluso 32 bits. Por ejemplo, la \"N\" se codifica con 8 bits (los mismos que en el viejo ASCII), pero la \"Ñ\" se codifica con 16: los 8 correspondientes a la \"N\" más los 8 correspondientes al símbolo \"~\" * **UTF-16**: los caracteres se codifican en grupos de 16 bits. Algunos solo necesitan 16 bits, pero otros necesitan el doble, es decir, 32. * **UTF-32**: los caracteres se codifican en grupos de 32 bits. Eso da un total de 232 caracteres posibles, más que suficientes para codificar todas las lenguas existentes en el mundo. Es la forma de Unicode más simple que existe. La codificación más popular es la **UTF-8 de Unicode**. Aunque es algo más compleja que la UTF-32, los textos codificados de este modo ocupan mucho menos espacio. Los primeros 127 caracteres del UTF-8 se corresponden con el viejo código ASCII. Por eso mismo, y para propósitos prácticos, las tablas clásicas de código ASCII siguen siendo vigentes, al menos hasta el carácter número 127. ### 2.1.4. El código hexadecimal Es importante conocer y saber manejar el código binario al ser el método de codificación que emplean los ordenadores digitales, pero este código tiene dos serios inconvenientes: 1. **Resulta difícil de manipular para nuestros cerebros**, que destán habituados a pensar en decimal (o habituados a no pensar en absoluto, que también se da el caso). 2. **Los números binarios pueden llegar a tener cantidades enormes de dígitos**. Es habitual trabajar con números de 16, 32 o 64 dígitos binarios, lo cual los convierte en inmanejables. Por este motivo, suelen usarse, en programación, otros dos sistemas de numeración llamados **octal** y **hexadecimal**. * El **sistema octal** maneja 8 símbolos distintos: 0, 1, 2, 3, 4, 5, 6 y 7. * El **sistema hexadecimal**, por su parte, tiene 16 símbolos: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E y F. Sin duda, el más utilizado de los dos es el hexadecimal y por este motivo nos vamos a detener en él, aunque haciendo notar que el octal funciona de la misma manera. En hexadecimal, por tanto, es normal ver números cuyos dígitos son letras del alfabeto. Por ejemplo: 2AF5 es un número válido escrito en hexadecimal (exactamente, 10997 en decimal). La forma de contar, por supuesto, es la misma: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, y después empezamos a agrupar los símbolos: 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 1A, 1B, 1C, 1D, 1E, 1F. Seguiríamos con 20, 21, 22, etc. Podemos construir una tabla para comparar los primeros números en los tres sistemas de numeración que conocemos. Hemos rellenado los primeros números binarios con ceros a la izquierda por razones que pronto se verán, pero en realidad los números no cambian (recuerda que un cero a la izquierda no tiene ningún valor, ni en binario ni en el resto de sistemas) Decimal|Binario|Hexadecimal -|-|- 0|0000|0 1|0001|1 2|0010|2 3|0011|3 4|0100|4 5|0101|5 6|0110|6 7|0111|7 8|1000|8 9|1001|9 10|1010|A 11|1011|B 12|1100|C 13|1101|D 14|1110|E 15|1111|F Si te fijas, cada dígito hexadecimal se corresponde exactamente con una combinación de 4 dígitos binarios. Así, por ejemplo, el número binario 1001 1101 se puede escribir más resumidamente como 9D en hexadecimal (porque 10012 equivale a 916 y 11012 equivale a D16). Y **esa es la gran utilidad del sistema hexadecimal**: permite manipular números binarios de forma más escueta y resumida, de manera que nos sean más fáciles de manejar a nosotros, los humanos, que somos muy propensos a cometer errores. #### Convertir números hexadecimales a decimales El mecanismo es el mismo que ya utilizamos para convertir números binarios, sólo que cambiando la base del sistema de numeración de 2 a 16, ya que ahora vamos a manejar números hexadecimales. Por lo tanto, los pasos a seguir son: 1. Numeramos las posiciones que ocupa cada dígito hexadecimal de derecha a izquierda, empezando por 0. Por ejemplo, en el número hexadecimal 2AF, numeraremos las posiciones así: ``` Posiciones --> 2 1 0 2 A F ``` 2. Multiplicamos cada dígito hexadecimal por 16 elevado a la posición del dígito y sumamos todos los resultados. Con el número 2AF lo haríamos así: 2 x 162 + A x 161 + F x 160 . Según la tabla de anterior, tenemos que el dígito hexadecimal A equivale a 10 en decimal, y que F equivale a 15. Por lo tanto la operación quedaría así: 2 x 162 + 10 x 161 + 15 x 160 . Ahora sólo nos falta resolver la operaciones y sumar: 2 x 256 + 10 x 16 + 15 x 1 = 687 . Por lo tanto, el número hexadecimal 2AF es equivalente al número decimal 687. Indicándolo con subíndices, lo expresaríamos así: 2AF16 = 68710 . #### Convertir números decimales a hexadecimales El proceso también es idéntico al realizado con números binarios, pero sustituyendo la división entre 2 por divisiones entre 16, que es la base del sistema hexadecimal. #### Relación entre números hexadecimales y binarios La verdadera utilidad del sistema hexadecimal es que **se puede utilizar en lugar del binario**, siendo más fácil de manejar. Para que ello sea posible, el paso de hexadecimal a binario y viceversa debe poder hacerse con mucha rapidez. Para convertir un número hexadecimal a binario, basta con **sustituir cada dígito hexadecimal por sus cuatro cifras binarias** correspondientes, según la tabla de correspondencias que hemos visto más arriba. Por ejemplo: 2AF16 = 0010 1010 11112 . Del mismo modo, para convertir un número binario a hexadecimal, lo agruparemos en bloques de 4 cifras binarias (empezando por la derecha) y buscaremos la correspondencia en la tabla. Por ejemplo, el número binario 100100 se convierte así: 0010 01002 = 2416 . Observa que hemos rellenado con ceros a la izquierda para obtener bloques de 4 dígitos binarios sin alterar la esencia del número. Por supuesto, no es obligatorio usar este truco de rellenar con ceros a la izquierda, pero las primeras veces puede facilitar las cosas. Con un poco de práctica conseguirás convertir binarios a hexadecimales y viceversa de un sólo vistazo y sin necesidad de consultar la tabla. ## 2.2. Unidades de medida de información Como hemos visto, el código binario es el fundamento del funcionamiento de los ordenadores: toda la información que el ordenador maneja, ya sea numérica o alfanumérica, se encuentra codificada en binario. Del mismo modo que para medir distancias se utiliza el metro, o para medir masas se utiliza el gramo, **para medir la cantidad de información almacenada o procesada en un ordenador existe una unidad de medida**. Como el ordenador representa toda la información en binario, **la unidad fudamental de medida de la cantidad de información es el dígito binario** (es decir, 0 ó 1), también llamado **BIT** (de BInary digiT) Un bit es realmente muy poca cantidad de información. Recuerda que, por ejemplo, para almacenar un sólo carácter en código ASCII son necesarios 7 u 8 bits. ¡Para un único carácter! Del mismo modo que el metro dispone de **múltiplos** (el decámetro, el hectómetro, el kilómetro, etc), también los tiene el bit, y son los siguientes: * **Bit**: Unidad fundamental de medida de la cantidad de información. * **Byte**: 1 byte equivale a 8 bits (un carácter). Esto no siempre ha sido así, pero, en la actualidad, se acepta la cifra de 8 como estándar. Cuidado con el nombre, porque se parecen y es un error común confundir el bit con el byte. * **Kibibyte (KiB)**: 1 kilobyte son 1024 bytes. Fïjate que es parecido al kilómetro (1000 metros), pero no exactamente igual. * **Mebibyte (MiB)**: 1 megabyte equivale a 1024 kilobytes. * **Gibibyte (GiB)**: 1 gigabyte equivale a 1024 megabytes. * **Tebibyte (TiB)**: 1 terabyte equivale a 1024 gigabytes * **Pebibyte (PiB)**: 1 pebibyte equivale a 1024 tebibytes. * **Exbibyte (EiB)**: 1 exbibyte equivale a 1024 pebibytes. Podemos resumir las unidades de medida de información en la siguiente tabla: ``` 1 Byte = 8 bits 1 KiB = 1024 Bytes 1 MiB = 1024 KiB 1 GiB = 1024 MiB 1 TiB = 1024 GiB 1 PiB = 1024 TiB 1 EiB = 1024 PiB ``` Existe otra colección de múltiplos del Byte que se incrementan en potencias de 10, como sucede con los múltiplos de otras magnitudes físicas (tales como el kilómetro, el kilogramo, etc). Se introdujeron hace unos años para acabar con la confusión que provocaba el hecho de que algunos fabricantes consideraban que 1 KB eran 1024 Bytes, mientras que otros decían que eran 1000 Bytes. Estas otras unidades son: * **Kilobyte (KB)**: 1 kilobyte son 1000 bytes. * **Megabyte (MB)**: 1 megabyte equivale a 1000 kilobytes. * **Gigabyte (GB)**: 1 gigabyte equivale a 1000 megabytes. * **Terabyte (TB)**: 1 terabyte equivale a 1000 gigabytes * **Petabyte (PB)**: 1 petabyte equivale a 1000 terabytes. * **Exabyte (EB)**: 1 exabyte equivale a 1000 petabytes. Podemos resumir las unidades de medida de información en la siguiente tabla: ``` 1 Byte = 8 bits 1 KB = 1000 Bytes 1 MB = 1000 KB 1 GB = 1000 MB 1 TB = 1000 GB 1 PB = 1000 TB 1 EB = 1000 EB ``` **Las unidades decimales son más pequeñas que las correspondientes binarias**. Es decir, 1 GB, por ejemplo, son menos Bytes que 1 GiB. La diferencia es tanto mayor cuanto más grande es la unidad. Por ejemplo, 1 KB es un 2,35% más pequeño que 1 KiB, pero 1 EB es un 13,3% más pequeño que 1 EiB. ¡Entre 1 EB y 1 EiB hay 150 millones de GB de diferencia! Por lo tanto, no es de extrañar que las compañías de telefonía o los fabricantes de dispositivos de almacenamiento publiciten sus capacidades en las unidades más pequeñas posible, para que lo que te ofertan parezca más de lo que es. Por último, hacemos notar que, en ocasiones, también se usan los mismos múltiplos para el bit, no para el Byte. Así, puedes encontrarte con megabits (Mb) o mebibits (Mib), que son, respectivamente, un millón (1.000.000) de bits y 220 bits (1.048.576). O con gigabits (Gb) o gigibits (Gib). La conversión entre los múltiplos del bit los del Byte se realiza multiplicando o dividiendo entre 8, como es lógico. Observa como **se usa la \"b\" minúscula para distinguir los bits de los Bytes**. ## 2.3. Ejercicios propuestos **Ejercicio 1**. Investiga y responde a las siguientes cuestiones: > a) ¿Por qué los ordenadores digitales sólo utilizan ceros y unos, es decir, códigos binarios, en lugar de manejar internamente códigos decimales, como hacemos los humanos? > b) ¿Por qué los humanos estamos habituados a un sistema de numeración basado en 10 símbolos y no a cualquier otro, por ejemplo, uno con 8 símbolos, o con 5, o con 12? **Ejercicio 2**. Tenemos un viejo ordenador con una capacidad de almacenamiento en la memoria principal de 2 GB. Suponiendo que un nombre ocupe 30 caracteres y un apellido ocupe 25, ¿cuántos nombres y apellidos puede almacenar este ordenador? **Ejercicio 3**. Convierte las siguientes cantidades de información: > a) 30 GB a MB > b) 128 KB a bits > c) 2 MB a bits > d) 64512 KiB a MiB **Ejercicio 4**. Convierte los siguientes números al sistema de numeración indicado: > a) 1001012 a decimal > b) 25410 a binario > c) 11111112 a decimal > d) 19110 a binario **Ejercicio 5**. Convierte los siguientes números entre los sistemas hexadecimal y binario, utilizando la tabla de conversión que hemos visto en este tema. Si puedes hacerlo sin mirar la tabla, mucho mejor. > a) 100111012 a hexadecimal > b) 1101001110110011012 a hexadecimal > c) 38C16 a binario > d) FDCA16 a binario **Ejercicio 6**. Escribe las palabras \"CELIA VIÑAS\" en código ASCII (en decimal y en hexadecimal). **Ejercicio 7**. La cantidad de memoria RAM de un ordenador personal medio ha ido creciendo imparablemente desde que los ordenadores personales se popularizaron en los años 80. Estas son algunas de esas cantidades: * Año 1982: 256 KiB * Año 1992: 4 MiB * Año 2002: 512 MiB * Año 2012: 4 GiB * Año 2022: 8 GiB Dibuja en un gráfico la evolución de estas cantidades y haz una proyección aproximada hasta el año 2032. ¿Cuánta memoria RAM usarán los ordenadores dentro de 10 años? Puedes usar un programa de hoja de cálculo para ayudarte. **Ejercicio 8**. El tamaño de los discos duros promedios de los ordenadores también ha ido creciendo desde hace cuarenta años. Haz una proyección parecida a la anterior para averiguar qué capacidad de almacenamiento en disco tendrán los ordenadores personales, previsiblemente, dentro de 10 años. * Año 1982: 10 MiB (los pocos ordenadores que tenían disco duro) * Año 1992: 1 GiB * Año 2002: 40 GiB * Año 2012: 240 GiB * Año 2022: 2 TiB ",
    "url": "/docs/prog-y-3d/_site/representacion-de-la-informacion/",
    "relUrl": "/representacion-de-la-informacion/"
  },"3": {
    "doc": "3. Introducción a la programación",
    "title": "3. Introducción a la programación",
    "content": "# 3. Introducción a la programación {: .no_toc } - TOC {:toc} ## 3.1. ¿Qué es exactamente eso de \"programar un ordenador\"? **Programar un ordenador** no es más que proporcionarle a la máquina un conjunto de instrucciones y datos para que realice una tarea. Esa tarea, generalmente, resuelve un problema concreto, que puede ir desde realizar complicados cálculos matemáticos hasta entretenernos con un videojuego en nuestros ratos de ocio. El conjunto de las instrucciones que conforma el programa se denomina **código fuente**, y tiene que estar escrito en un lenguaje comprensible por la máquina, es decir, un **lenguaje de programación**. Esas instrucciones se traducen a **código binario** (que, recuerda, es lo único que puede comprender el ordenador). La CPU de un ordenador está construida de manera que puede entender y ejecutar ciertas instrucciones binarias, gracias a lo cual nuestro programa acaba ejecutándose en las entrañas de la máquina. Este es un fragmento de un programa informático real escrito en lenguaje PHP. Implementa un algoritmo de ordenación de elementos llamado *Bubble Sort* o, en español, *método de la burbuja*. No es necesario, ni mucho menos, que lo entiendas de momento. Solo quiero que le eches un vistazo para que veas el aspecto que tiene un programa real (o un fragmento) escrito en un lenguaje real. ```php function bubble_Sort($my_array ) { do { $swapped = false; for( $i = 0, $c = count( $my_array ) - 1; $i $my_array[$i + 1] ) { list( $my_array[$i + 1], $my_array[$i] ) = array( $my_array[$i], $my_array[$i + 1] ); $swapped = true; } } } while( $swapped ); return $my_array; } $test_array = array(3, 0, 2, 5, -1, 4, 1); echo \"Original Array :\"; echo implode(', ',$test_array ); echo \"Sorted Array:\"; echo implode(', ',bubble_Sort($test_array)). PHP_EOL; ``` (Fuente: php.net) ### 3.1.2. Programas y algoritmos Para realizar un programa es necesario idear previamente un algoritmo. Esto es importante hasta el extremo de que, sin algoritmo, no existiría el programa. Un algoritmo, como hemos visto, es una **secuencia ordenada de acciones que conducen a la solución de un problema en un número finito de pasos simples**. Por ejemplo, vamos a escribir un algoritmo para determinar si un número entero cualquiera (que llamaremos N) es par o impar: ``` - Inicio del algoritmo - Paso 1. Preguntar qué número concreto es N. - Paso 2. Si N es divisible entre 2, entonces la solución es \"PAR\". - Paso 3. Si N no es divisible entre 2, entonces la solución es \"IMPAR\". - Paso 4. Imprimir la solución. - Fin del algoritmo ``` Recuerda que este algoritmo está **escrito para que lo ejecute un ordenador**, no para que lo ejecute una persona. Por eso el Paso 1 es \"Preguntar qué número es N\": porque el ordenador tendrá que preguntarnos a nosotros, los humanos, el número. Y por eso el Paso 4 es \"Imprimir la solución\": porque el ordenador nos ofrecerá el resultado imprimiéndolo en la pantalla o en un papel. Este algoritmo resuelve el problema planteado en un número finito de pasos simples. Lógicamente, al ordenador no le podemos dar estas instrucciones tal y como las hemos escrito, sino que habrá que expresarlo en un lenguaje de programación, pero esto es algo que trataremos más adelante. ### 3.1.3. Datos y tipos de datos Los algoritmos, como hemos dicho, son colecciones de instrucciones que resuelven un problema. Pero esas instrucciones **siempre trabajan con datos**, es decir, con información formalizada para su uso en un ordenador: * **Los datos de entrada** son datos que el algoritmo necesita para trabajar. En el ejemplo anterior, el número \"N\" es un dato de entrada. * **Los datos de salida** son datos que el algoritmo produce como resultado de sus cálculos. En el ejemplo anterior, \"solución\" es un dato de salida. Los datos siempre pertenecen a un **tipo de datos**, que es el rango de valores que ese dato puede tomar. Existen multitud de tipos de datos posibles, pero empezaremos trabajando solo con estos: * **Enteros**. Los datos de este tipo solo pueden tomar como valores números enteros (positivos o negativos). Ejemplos: 3, 28, -15, 0, 4982... * **Reales**. Números con decimales. Ejemplos: 18.25, -3.198887 * **Caracteres**. Letras, números, signos de puntuación... Ojo, si un dato es de tipo \"carácter\", solo puede contener en cada momento un único carácter. Ejemplos: 'a', 'Z', '&', '?' * **Cadenas de caracteres**. O, simplemente, *cadenas*. Son colecciones de letras, números, signos de puntuación... Es decir, palabras y cualquier cosa que se le parezca. Ejemplos: \"Hoy es lunes\", \"sgcv08 e98 ie7f83 ?so9&/\". Suelen distinguirse de los caracteres individuales por la doble comilla, aunque esto depende del lenguaje de programación. * **Lógicos o booleanos**. Estos datos solo pueden tener dos valores: *verdadero* o *falso*. ### 3.1.4. Variables y constantes Las **variables** de un algoritmo son como las variables en una ecuación matemática: representaciones de un dato a las que asignamos un nombre o identificador. En el algoritmo para averiguar si un número es par o impar, *N* es una variable y *solución* es otra variable. Las variables pueden tomar un valor perteneciente a un tipo de datos. Ese valor puede cambiar a lo largo del algoritmo (por eso se denominan *variables*). Lo que no puede cambiar es el tipo de datos al que pertenecen. Es decir: si una variable es entera, no puede cambiar y pasar a ser real durante la ejecución del programa. (Bueno, hay lenguajes que sí permiten hacer esto, pero esa es otra historia). Por eso, la mayoría de los lenguajes de programación exigen que les indiquemos a qué tipo de datos pertenece cada variable antes de usarlas por primera vez. Es algo que también haremos en pseudocódigo. Eso se denomina **declarar una variable**. Así pues, podemos mejorar el algoritmo anterior con la declaración de las variables \"N\" y \"solución\": ``` - Inicio del algoritmo - Declaración de variables: - N es un número entero. - solución es una cadena de caracteres. - Paso 1. Averiguar qué número es N. - Paso 2. Si N es divisible entre 2, entonces la solución es \"PAR\". - Paso 3. Si N no es divisible entre 2, entonces la solución es \"IMPAR\". - Paso 4. Imprimir la solución. - Fin del algoritmo ``` Las **constantes** se parecen a las variables: tienen un nombre y un tipo, y se les asigna un valor. La única diferencia es que una constante *no puede cambiar de valor durante la ejecución del algoritmo* y una variable sí. ### 3.1.5. Subalgoritmos Cuando un algoritmo es muy complejo, lo dividimos en trozos más simples que denominamos **subalgoritmos**. En programación, esos subalgoritmos se denominan **procedimientos** o **funciones**. Son casi la misma cosa, con una sutil diferencia que ya veremos cuando llegue el momento. Los lenguajes de programación reales, además de las instrucciones básicas que enseguida vamos a ver, tienen unas colecciones de funciones predefinidas llamadas **bibliotecas**. Esas funciones se encargan de realizar tareas habituales y repetitivas, de modo que nos ahorran un montón de trabajo. Por ejemplo, es posible escribir algoritmos para hacer cálculos matemáticos complejos, tales como logaritmos o raíces cuadradas. Para evitarnos ese trabajo, todos los lenguajes de programación disponen de una biblioteca de funciones matemáticas que incluye, entre otras muchas cosas, el cálculo de logaritmos y de raíces cuadradas para cuando los necesitemos. Así que vamos a suponer, cuando escribamos pseudocódigo, que también tenemos a nuestra disposición de esas bibliotecas de funciones. Algunos subalgoritmos o funciones que existen en todos los lenguajes de programación y que podemos considerar que también existen en pseudocódigo son las siguientes: * abs(x). Calcula el valor absoluto de x. Funciona con números reales y con enteros. * sen(x). Calcula el seno de x. Devuelve valores reales. * cos(x). Calcula el coseno de x. Devuelve valores reales. * exp(x). Calcula ex. Devuelve un real. * ln(x). Calcula el logaritmo neperiano de x. Devuelve un valor real. * redon(x). Redondea el número x al valor entero más próximo. El valor x será real, y la función devolverá un entero. * trunc(x). Trunca el número x, es decir, le elimina la parte decimal. El valor x será real, y la función devolverá un entero. * rc(x). Calcula la raíz cuadrada de x. Devuelve un valor real * azar(x). Genera un número al azar entre 0 y x. Supondremos que solo funciona con números enteros. ### 3.1.6. Expresiones y operadores Una **expresión** es una combinación de constantes, variables, operadores y funciones. Por ejemplo, esto es una expresión: rc((5 + x) / 2) . En esta expresión, aparecen dos constantes literales (5 y 2), una variable (x), dos operadores aritméticos (+ y /) y una función (rc, para calcular la raíz cuadrada), además de los paréntesis, que sirven para manipular la prioridad de las operaciones. Lógicamente, para resolver la expresión, es decir, para evaluar su resultado, debemos conocer cuál es el valor de la variable x. Si suponemos que la variable x tiene el valor 7, el resultado de la expresión será 2,449. La forma más habitual de encontrar una expresión es combinada con una **sentencia de asignación a una variable**. Por ejemplo: y En estos casos, la expresión (lo que hay a la derecha del signo \" (mayor que), = (igual que), != (distinto de), (mayor o igual que). El resultado de estas comparaciones siempre es un valor lógico, es decir, verdadero o falso. * **Operadoresl lógicos**: se utilizan para comparar otros datos lógicos y relacionarlos entre sí. Los más habituales son Y, O y NO. Estas palabras tienen el mismo significado que en la lengua natural. Observa, por ejemplo, este fragmento de pseudocódigo muy fácil de entender: ``` puntos_carnet = edad = Si edad >= 18 y puntos_carnet > 0 Entonces escribir \"Puedes conducir\" FinSi Si edad | Instrucción | Significado | . | Algoritmo nombre | Marca el comienzo de un algoritmo y le adjudica un nombre | . | FinAlgoritmo | Marca el final del algoritmo | . | Definir variable Como tipo | Declara una variable y le asigna un tipo. Los tipos válidos son Entero, Real, Carácter, Lógico y Cadena. | . | Leer variable | Entrada de datos. El programa lee un dato desde un dispositivo de entrada (si no se indica otra cosa, el teclado), asignando ese dato a la variable. | . | Escribir expresión | Salida de datos. La expresión se calcula y su resultado se muestra en la pantalla. | . | variable | Asignación. Se evalúa la expresión y el resultado se guarda en la variable. | . | Si condición Entonces &nbsp;&nbsp;&nbsp;&nbsp;acciones-1 SiNo &nbsp;&nbsp;&nbsp;&nbsp;acciones-2 FinSi | Estructura condicional. Se evalúa la condición. Si es verdadera, se ejecutan las \"acciones-1\". Si es falsa, se ejecutan las \"acciones-2\". | . | Segun expresión hacer &nbsp;&nbsp;&nbsp;&nbsp;valor-1: acciones-1; &nbsp;&nbsp;&nbsp;&nbsp;valor-2: acciones-2; &nbsp;&nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;&nbsp;&nbsp;valor-n: acciones-N; &nbsp;&nbsp;&nbsp;&nbsp;De otro modo: acciones-por-defecto; FinSegun | Condicional múltiple. Si la expresión se evaúa como\"valor-1\", se ejecutan las acciones-1. Si vale \"valor-2\", se ejecutan las acciones-2, y así sucesivamente. Si la expresión no coincide con ningún valor, se ejecutan las acciones-por-defecto. | . | Mientras condición &nbsp;&nbsp;&nbsp;&nbsp;acciones FinMientras | Bucle con condición al princio. Se realizan las acciones repetidamente mientras la condición siga siendo verdadera. | . | Repetir &nbsp;&nbsp;&nbsp;&nbsp;acciones Hasta Que condición | Bucle con condición al final. Se realizan las acciones repetidamente mientras la condición siga siendo verdadera. Observa que el cuerpo de este bucle se ejecuta al menos una vez, mientras que el del bucle anterior podría no ejecutarse nunca (si la condición es falsa desde el principio). | . | Para variable valor_inicial Hasta valor_final Hacer &nbsp;&nbsp;&nbsp;&nbsp;acciones FinPara | Bucle con iterador. Se asigna el valor_inicial a la variable. El bucle se repite hasta que la variable llega al valor_final. En cada iteración, la variable se incrementa en una unidad (se puede indicar otro incremento, pero, de momento, nos quedamos con ese). | . También existen instrucciones para crear y manejar subalgoritmos. Como nuestros programas, de momento, van a ser muy simples, aún no vamos a verlas. Nos dedicaremos a ellas cuando llegue el momento. ### 3.2.3. Un ejemplo sencillo de algoritmo escrito en pseudocódigo Vamos a terminar esta sección mostrando un ejemplo sencillo pero muy completo de algoritmo escrito en pseudocódigo. Se trata de escribir un algoritmo tal que, dados dos números enteros (que llamaremos A y B), nos dirá cuáles son los números enteros que existen entre A y B ordenados de menor a mayor. Lo primero que el algoritmo tendrá que hacer será pedirnos los valores de A y B. Después, tendrá que averiguar cuál de los dos es el menor (A o B), para poder luego meterse en un bucle que vaya desde el número menor hasta el número mayor, pasando por todos los valores intermedios e imprimiéndolos. Las instrucciones de ese algoritmo serían estas: ``` Algoritmo contar_numeros Definir A,B,inicio,final,i Como Entero Escribir 'Dime un número' Leer A Escribir 'Dime otro número' Leer B Si (A | Símbolo | Equivalencia en pseudocódigo | Significado | . | | Algoritmo nombre | Marca el comienzo de un algoritmo y le adjudica un nombre | . | | FinAlgoritmo | Marca el final del algoritmo | . | | Definir variable Como tipo | Declara una variable y le asigna un tipo. | . | | Leer variable | Entrada de datos. | . | | Escribir expresión | Salida de datos. | . | | variable | Asignación. | . | | Si condición Entonces &nbsp;&nbsp;&nbsp;&nbsp;acciones-1 SiNo &nbsp;&nbsp;&nbsp;&nbsp;acciones-2 FinSi | Estructura condicional. | . | | Segun expresion hacer &nbsp;&nbsp;&nbsp;&nbsp;valor-1: acciones-1; &nbsp;&nbsp;&nbsp;&nbsp;valor-2: acciones-2; &nbsp;&nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;&nbsp;&nbsp;valor-n: acciones-N; &nbsp;&nbsp;&nbsp;&nbsp;De otro modo: acciones-por-defecto; FinSegun | Condicional múltiple. | . | | Mientras Condición &nbsp;&nbsp;&nbsp;&nbsp;acciones FinMientras | Bucle con condición al princio. | . | | Repetir &nbsp;&nbsp;&nbsp;&nbsp;acciones Hasta Que Condición | Bucle con condición al final. | . | | Para variable valor_inicial Hasta valor_final Hacer &nbsp;&nbsp;&nbsp;&nbsp;acciones FinPara | Bucle con iterador. | . Recuerda que también existen símbolos para definir y utilizar **subalgoritmos**, destinados a dividir el algoritmo en trozos cuando resolvemos problemas complejos. Por ahora, nuestros problemas serán simples y no usaremos subalgoritmos. Cuando llegue el momento, explicaremos cómo se utilizan. Para terminar, te muestro el algoritmo para contar números enteros entre dos números cualesquiera, A y B, escrito como un diagrama de flujo. No dejes de comparar esta solución con la que planteamos en pseudocódigo un poco más arriba. Ambas son exactamente iguales, pero están descritas con una herramienta diferente. Es como si hubiéramos escrito la misma frase en dos idiomas distintos. ![Diagrama de flujo contar-numeros](/docs/prog-y-3d/_site/assets/images/03-contar-numeros.png) ## 3.4. Errores frecuentes entre principiantes En esta sección recopilo para ti algunas de las dudas, errores y pifias más frecuentes que, según mi experiencia como profesor de programación, suelen asaltar a los principantes. #### No es lo mismo 20 que \"20\" Así es. Cuando estás programando, no es lo mismo la instrucción ```Escribir 20``` (o cualquier otro número) que la instrucción ```Escribir \"20\"```, con el número entre comillas. Las cadenas de caracteres siempre se ponen entre comillas. Los números NO. Por eso, ```Escribir 20``` significa literalmente *mostrar en pantalla el número 20*, mientras que ```Escribir \"20\"``` significa *mostrar en pantalla la cadena de caracteres \"20\"*. Puede parecer lo mismo, pero no lo es. En una, 20 es un texto y, en otra, un número, y para el ordenador son cosas muy distintas (por ejemplo, no puedes sumar dos textos, pero sí dos números). #### Escribir \"a\" no es lo mismo que Escribir a Un caso particular de la confusión anterior, y muy frecuente cuando se empieza a programar, es confundir ```Escribir \"a\"``` (o cualquier otro carácter) con ```Escribir a```. La primera instrucción pide al ordenador que escriba un texto (en este ejemplo, una letra \"a\"). La segunda instrucción pide al ordenador que escriba *el contenido* de una variable. Es decir, en ```Escribir a```, la a debe ser una variable preexistente. Y, como todas las variables, debe tener un valor. La instrucción ```Escribir a``` pide al ordenador que escriba ese valor, no una letra \"a\". #### ¡Me hago un lío entre Escribir y Leer! A menudo me he encontrado con que las personas que se inician en la programación de ordenadores confunden *escribir* y *leer*: ¡no tienen claro cuándo utilizar una y cuándo la otra! Esta confusión se debe a un problema de punto de vista. El programador/a novato piensa los algoritmos *desde su punto de vista*, es decir, como si fuera él o ella quien debe ejecutar el algoritmo. La solución pasa por cambiar el punto de vista. **El algoritmo lo ejecutará un ordenador**, no nosotros. Los algoritmos son colecciones de órdenes para el ordenador, no para nosotros. Podemos pensar en el ordenador como en un esclavo obediente que hará todo lo que le pidamos (siempre que se lo pidamos en un lenguaje que pueda entender). Así, cuando le pedimos que ejecute una instrucción *escribir 'Hola'*, no somos nosotros los que vamos a escribir \"Hola\", sino que será la máquina la que lo hará. Y lo escribirá en su pantalla, que es la manera estandarizada en la que un ordenador escribe cosas. Y cuando le pidamos que ejecute *leer n*, será el ordenador el que leerá el valor de la variable n. ¿Y cómo se las apaña un ordenador para leer cosas? A través de un dispositivo de entrada. Es decir, a través del teclado. La instrucción *leer n* hará que el programa se detenga hasta que tecleemos algo, y ese algo se almacenará en la variable n. #### Errores lógicos: confundir Y con O Este también es un problema frecuente, incluso entre programadores experimentados. Recuerda que los operadores lógicos Y y O tienen exactamente el mismo significado que en español. A partir de ahí, solo te queda utilizar el sentido común. Si, aún así, te enfrentas con una expresión que no acabas de comprender, trata de descomponerla en expresiones más simples para asimilar mejor la lógica del problema. #### Confundir condición con iteración Otro error recurrente entre principiantes consiste en confundir la estructura condicional con la iterativa. En concreto, confudir *Si... Entonces* con *Mientras... Hacer*. Creo que se debe a que ambas instrucciones comparten la misma estructura: tienen una condición al principio y ejecutan una serie de acciones o no en función de esa condición. Pero hay una diferencia fundamental: las acciones de un *Si... Entonces* solo se ejecutarán **una o ninguna vez**, y luego el programa continuará. Las acciones de un *Mientras... Hacer* se ejecutarán **cero, una o muchas veces**, dependiendo de la condición. Por lo tanto, para saber si debes usar una u otra, pregúntate esto: \"¿tiene sentido que estas acciones se ejecuten muchas veces o, como máximo, se ejecutarán una vez?\". Si la respuesta es \"muchas veces\", necesitas un *Mientras... Hacer*. Si la respuesta es \"una vez\", necesitas un *Si... Entonces*. Pongamos un ejemplo. Imagina que estás escribiendo un programa que pida un número y determine si es negativo. Puedes tener la tentación de escribir esto: ``` leer N Mientras N ¡¡¡CUIDADO, ESTO ES UN ERROR!!! escribir \"El número es negativo\" FinMientras ``` Si haces eso, habrás provocado involuntariamente un bucle infinito, ya que, cuando el programa entre en el bucle, no logrará salir jamás de él porque la condición siempre será verdadera. Para no caer en este error, trata de responder a la pregunta que planteábamos antes. La única accion que hay dentro de este bucle es *Escribir \"El número es negativo\"*, así que debes preguntarte: \"¿mi programa tiene que escribir *El número es negativo* muchas veces, o solo una (en caso de que el número, en efecto, sea negativo)?\" La respuesta, obviamente, es que basta con una. Así que la solución correcta a este problema es: ``` leer N Si N Calcular el área y la circunferencia de un círculo cuyo radio será proporcionado a través del teclado. Recuerda que área = 3.14 x r x r y circunferencia = 2 x 3.14 x r **Ejercicio 2**. Pedir las cuatro notas de los exámenes del primer trimestre de un alumno y mostrar la nota media obtenida. **Ejercicio 3**. Calcular el precio de llenar una piscina de agua. Para ello se tienen que pedir al usuario las medidas de la piscina (largo, ancho y alto) y el precio del m​3​ del agua. Se mostrará el precio total. Supondremos que la piscina es de forma regular. #### Ejercicios con estructuras condicionales **Ejercicio 4**. Determinar si un número leído del teclado es positivo, negativo o cero. **Ejercicio 5**. Calcular la raíz cuadrada de un número introducido por teclado. Hay que tener la precaución de comprobar que el número sea positivo. **Ejercicio 6**. Leídos dos números por teclado, A y B, calcular la resta del mayor menos el menor. Por ejemplo, si A = 8 y B = 3, el resultado debe ser A – B, es decir, 5. Pero si A = 4 y B = 7, el resultado debe ser B – A, es decir, 3. **Ejercicio 7**. Averiguar si un número real introducido por teclado tiene o no parte fraccionaria (utilícese la función trunc() que aparece descrita en los apuntes) **Ejercicio 8**. Leer un número real y un tipo de moneda, que puede ser \"euro\" o \"peseta\". Convertir la cantidad al tipo de moneda indicado, suponiendo que está expresada en la otra. Por ejemplo, si la cantidad es 15 y la moneda es \"peseta\", se supondrá que se trata de 15 € y que hay que convertirlos a pesetas y, por lo tanto, el resultado debe ser 2495. **Ejercicio 9**. Leer tres números por teclado, X, Y y Z, y decidir si están ordenados de menor a mayor. **Ejercicio 10**. Como el anterior, pero para averiguar si los números son consecutivos. **Ejercicio 11**. Determinar si un año es bisiesto o no (los años bisiestos son múltiplos de 4; utilícese el operador módulo) **Ejercicio 12**. Determinar el número de cifras de un número entero. El algoritmo debe funcionar para números de hasta 5 cifras, considerando los negativos. Por ejemplo, si se introduce el número 5342, la respuesta del programa debe ser 4. Si se introduce –250, la respuesta debe ser 3. **Ejercicio 13**. Calcular las dos soluciones de una ecuación de segundo grado, del tipo ax2 + bx + c = 0. Los coeficientes a, b y c deberá introducirlos el usuario a través del teclado. #### Ejercicios con estructuras condicionales e iterativas **Ejercicio 14**. Escribir todos los números entre 1 y n, siendo n un entero introducido por teclado. **Ejercicio 15**. Escribir todos los números pares entre 1 y n. **Ejercicio 16**. Escribir todos los números impares entre dos números a y b introducidos por teclado. Antes habrá que comprobar cuál de los dos números (a o b) es mayor. **Ejercicio 17**. Calcular la suma de todos los números pares entre 1 y n, siendo n un entero introducido por teclado. Es decir, hay que calcular 2 + 4 + 6 + ... hasta n (o n-1, si n es un número impar). **Ejercicio 18**. Realiza un programa que calcule la suma de los n primeros números, donde n es un número introducido por teclado. Al terminar, el programa nos mostrará el mensaje \"¿Desea terminar? (S/N)\". Si el usuario escribe \"S\", el programa terminará, pero, si escribe \"N\", volverá a comenzar. **Ejercicio 19**. Calcular la nota media de un alumno a partir de las notas de todos sus exámenes a lo largo del curso. El programa nos irá pidiendo notas, pero no sabemos cuántas son. Para terminar de introducir valores, el usuario debe teclear un número negativo. Entonces, el programa calculará el promedio de todas las notas introducidas. **Ejercicio 20**. El usuario de este programa será un profesor, que introducirá las notas de sus 30 alumnos de una en una. El algoritmo debe decirle cuántos suspensos y cuántos aprobados hay. **Ejercicio 21**. Calcular el valor máximo de una serie de 10 números introducidos por teclado. **Ejercicio 22**. Generalizar el ejercicio anterior para que también se averigüe el valor mínimo y el medio. **Ejercicio 23**. Calcular el factorial de un número entero N. Recuerda que el factorial de un número es el producto de ese número por todos los enteros menores que él. Por ejemplo, el factorial de 5 (simbolizado 5!) se calcula como: 5! = 5 x 4 x 3 x 2 x 1. **Ejercicio 24**. Generar combinaciones al azar para la lotería primitiva (6 números entre 1 y 49). Debes utilizar la función azar(x) que vimos en los apuntes. Por ahora, no te preocupes porque los números puedan repetirse. **Ejercicio 25**. Generar combinaciones al azar para la quiniela (14 valores dentro del conjunto 1, X o 2). #### Ejercicios más avanzados **Ejercicio 26**. Determinar si un número N introducido por teclado es o no primo. Recuerda que un número primo es aquél que sólo es divisible por sí mismo y por la unidad. **Ejercicio 27**. Generalizar el algoritmo anterior para averiguar todos los números primos que existen entre 2 y N, siendo N un número introducido por teclado. **Ejercicio 28**. Introducida una hora por teclado (horas, minutos y segundos), se pretende sumar un segundo a ese tiempo e imprimir en la pantalla la hora que resulta (también en forma de horas, minutos y segundos). **Ejercicio 29**. La calculadora. Diseñar un algoritmo que lea dos números, A y B, y un operador (mediante una variable de tipo carácter), y calcule el resultado de operar A y B con esa operación. Por ejemplo, si A = 5 y B = 2, y operación = \"+\", el resultado debe ser 7. El algoritmo debe seguir pidiendo números y operaciones indefinidamente, hasta que el usuario decida terminar (utilizar un valor centinela para ello) #### Algunos juegos sencillos **Ejercicio 30. Juego del número secreto**. El ordenador elegirá un número al azar entre 1 y 100. El usuario irá introduciendo números por teclado, y el ordenador le irá dando pistas: \"mi número es mayor\" o \"mi número es menor\", hasta que el usuario acierte. Entonces el ordenador le felicitará y le comunicará el número de intentos que necesitó para acertar el número secreto**. **Ejercicio 31. Número de la suerte** El número de la suerte o *lucky number* es una tontuna que se han inventado los numerólogos y que se obtiene sumando todas las cifras de la fecha de nacimiento de un modo azaroso. Por ejemplo, como yo nací el 15 de octubre de 1974 (15-10-1974), se supone que mi número de la suerte es 15+10+1974 = 1999. Ahora sumo todas las cifras de 1999 así: 1+9+9+9 = 28. Como aún tengo dos dígitos, vuelvo a sumarlos. 2 + 8 = 10. Y, por último, 1 + 0 = 1. Por lo tanto, 1 es mi número de la suerte. Si alguna vez me toca la lotería y llevo un número acabado en 1, os aviso. Por ahora, nos conformamos con escribir un programa que, dada una fecha de nacimiento (día, mes y año), calcule el número de la suerte de esa persona. **Ejercicio 32. El juego de la ruleta** Escribe un programa que permita jugar a la ruleta con el ordenador. Supondremos que la ruleta tiene 20 números rojos y 20 negros. El jugador, que tendrá una suma de dinero inicial, apostará una cantidad (siempre menor que el dinero que le quede) a un número y un color. La ruleta, que puedes simular con el método azar(), la manejará el ordenador y comunicará al jugador el resultado. Si el jugador acierta, multiplicará por 10 el dinero apostado. Si falla, perderá el dinero apostado. El proceso se repetirá hasta que el jugador decida abandonar el juego, o bien se quede sin dinero. Por favor, abstenerse ludópatas. **Ejercicio 33. Juego de dados** Escribe un programa para jugar a los dados con el ordenador. Las reglas del juego son las siguientes: * El jugador humano dispondrá de una cantidad inicial de dinero que se introducirá por teclado. * El jugador apostará una cantidad de dinero (siempre igual o menor del que le queda) * Después, se tirarán tres dados (lo cual se puede simular con el método azar()) * Si en los tres dados sale la misma cantidad, el dinero apostado por el jugador: * Se multiplica por 5 si en los dados ha salido un 6 * Se multiplica por 3 si sale cualquier otra cantidad * Si en dos dados de los tres sale la misma cantidad, el dinero apostado se multiplica por 2 * En cualquier otro caso, el dinero apostado se pierde * El proceso se repite hasta que el jugador se queda sin dinero o hasta que decide dejar de jugar. **Ejercicio 34. Juego de las Tres en Raya** Vamos a hacer una versión del popular juego de las Tres en Raya para jugar contra el ordenador. No será un juego con inteligencia artificial como el de la WOPR (si no sabes qué es la WOPR, bueno, ¿para qué sirve wikipedia?), pero te permitirá pasar un buen rato programando, que es de lo que se trata. El juego se desarrolla en un tablero de 3 x 3 casillas en el que los jugadores van disponiendo sus fichas tratando de formar una línea vertical, horizontal o diagonal. Las fichas del jugador humano tendrán forma de aspa (X) y, las del ordenador, forma de círculo (O) . Al principio, el tablero está en blanco. Comenzará jugando el jugador humano, que colocará una ficha en el tablero. Después, será el turno del ordenador. El proceso se repite hasta que uno de los dos consigue colocar tres fichas formando una línea, o hasta que ya no es posible colocar más fichas (situación de “tablas”) *Aviso: este juego es más difícil de programar que los anteriores.* **Ejercicio 35**. Dibujar con asteriscos. Se trata de escribir un programa que sea capaz de dibujar en la pantalla, *mediante bucles*, estos bonitos diseños. Añade alguno de tu propia cosecha, por favor. (Por si queda alguna duda: el último se supone que es un árbol de navidad) ``` * *** ***** ******* * *** ***** ******* ***** *** * * * * * * * * * * * * * * *** * *** ***** ******* * *** ***** ******* ********* *********** ************* *** *** *** *** ``` **Ejercicio 36. Máquina tragaperras** Vamos a escribir ahora un programa que simule el funcionamiento de una máquina tragaperras. No es que yo tenga ningún problema con los juegos de azar, ¿eh?, es solo que son simples y adecuados para simular con un ordenador en el momento del curso en el que nos encontramos. Además, puedo dejarlos cuando quiera. El programa debe tener el siguiente comportamiento: a) Preguntará al usuario con cuánto dinero inicial desea jugar (en euros). Esta cantidad no puede ser menor que 1 euro ni mayor que 50. b) Cada jugada costará 0,50 euros, que se descontarán automáticamente del saldo que el jugador tenga en cada momento. c) Cada jugada consiste en una combinación de tres frutas elegidas al azar entre estas seis: * Manzana * Naranja * Fresa * Cereza * Limón * Sandía d) El jugador no gana nada si las tres frutas que salen son distintas. e) En cambio, si varias frutas coinciden, el jugador gana un premio, que pasa a incrementar su saldo. El premio será: * Si dos frutas cualesquiera son iguales: * 1) Si son dos cerezas, 3 euros * 2) Si son dos sandías, 2 euros * 3) Si no son ni sandías ni cerezas, 1 euro * Si las tres frutas son iguales: * 1) Si son tres cerezas, 30 euros * 2) Si son tres sandías, 20 euros * 3) Si son tres fresas, 10 euros * 4) Si no son ni cerezas, ni sandías, ni fresas, 5 euros f) Después de cada jugada, la máquina comunicará al jugador la combinación que ha salido y le dirá si ha ganado algún premio. g) Después de eso, la máquina le dirá al jugador cuál es su saldo actual y le preguntará si desea seguir jugando. Si el jugador se queda sin dinero, el juego terminará automáticamente sin preguntar nada. Este es un ejemplo de ejecución del programa: ``` *** BIENVENIDO AL JUEGO DE LA TRAGAPERRAS *** ¿Con cuánto dinero desea empezar (de 1 a 50 euros) ? 60 Cantidad incorrecta ¿Con cuánto dinero desea empezar (de 1 a 50 euros) ? 20 COMIENZA EL JUEGO... La combinación de esta jugada es: NARANJA – CEREZA – SANDÍA Lo siento, no ha obtenido ningún premio Su saldo actual es de 19,5 euros. ¿Desea jugar otra vez (S/N) ? S La combinación de esta jugada es: SANDÍA – SANDÍA - LIMÓN ¡Enhorabuena! Ha ganado 20 euros. Su saldo actual es de 39,5 euros. ¿Desea jugar otra vez (S/N) ? N ¡Hasta la próxima! ``` #### Desafíos matemáticos para personas valientes **Ejercicio 37**. Mínimo común múltiplo. El programa nos pedirá dos números y calculará el mínimo común múltiplo de ambos. *Atención: este ejercicio es de dificultad elevada*. **Ejercicio 38**. Máximo común divisor. Como el anterior, pero calculando el máximo común divisor. *Atención: este ejercicio es de dificultad elevada*. **Ejercicio 39**. Escribe un programa que pregunte al usuario su fecha de nacimiento y la fecha del día de hoy, y calcule la edad del usuario en años. (Aviso: no es tan fácil como parece) Este programa se puede mejorar haciendo que calcule la edad en años, meses y días (¡incluso en horas, minutos y segundos!), pero es una labor por ahora solo apta para los más atrevidos/as. ### 3.6. Ejercicios resueltos A continuación, vamos a mostrar la solución de algunos de los ejercicios anteriores. No de todos, porque entonces este texto sería interminable, pero si de bastantes de ellos. Ten en cuenta que, **en muchas ocasiones, hay más de una solución posible** igualmente válida. Si tú has logrado resolver el ejercicio por otra vía, puede que hayas dado con una de esas otras soluciones. Sin embargo, también hay soluciones inaceptables por su poca eficiencia aunque, en apariencia, parezcan funcionar bien. Ten en cuenta que, para ir de Almería a Granada, se puede ir por la autovía A-92 o se puede dar un rodeo por Barcelona. O por Júpiter y Saturno. De todos esos modos conseguiremos llegar a Granada, pero las últimas soluciones son tan ineficientes que no resultan aceptables. Lo mismo ocurre con los programas informáticos. Cuando tu solución sea muy diferente de la mía, pregúntate si la tuya da un rodeo mucho mayor que la mía para llegar al mismo sitio, o si, por el contrario, es igual de eficiente (¡o incluso más!). En este caso, enhorabuena: has dado con una de esas soluciones alternativas de las que hablaba. Por último, permíteme un consejo: **intenta resistir la tentación de mirar la solución a los ejercicios antes de hacerlos**. Es muy conveniente que pases un rato tratando de resolver los problemas por ti mismo/a antes de mirar la solución. Al menos, es muy conveniente si tu intención es aprender a programar. #### Ejercicios con estructura secuencial **Ejercicio 1**. Calcular el área y la circunferencia de un círculo cuyo radio será proporcionado a través del teclado. Recuerda que área = 3.14 x r x r y circunferencia = 2 x 3.14 x r *Solución en pseudocódigo:* ``` Algoritmo area_circulo Definir radio, area, circunferencia Como Real Escribir \"Dime el radio\" Leer radio area = 5 Entonces escribir \"Has aprobado, enhorabuena\" SiNo escribir \"Has suspendido, sigue jugando\" FinSi FinAlgoritmo ``` *Solución en diagrama de flujo:* ![Diagrama de flujo media_examenes](/docs/prog-y-3d/_site/assets/ejercicios-resueltos-pseint/03_02_media_examenes.png) **Ejercicio 3**. Calcular el precio de llenar una piscina de agua. Para ello se tienen que pedir al usuario las medidas de la piscina (largo, ancho y alto) y el precio del m​3​ del agua. Se mostrará el precio total. Supondremos que la piscina es de forma regular. *Solución en pseudocódigo:* ``` Algoritmo piscina Definir largo, ancho, alto como real Definir preciom3 como real Definir costeTotal Como Real Escribir \"¿Cuál es el largo de la piscina (en cm)?\" Leer largo Escribir \"¿Cuál es el ancho de la piscina (en cm)?\" Leer ancho Escribir \"¿Cuál es el alto de la piscina (en cm)?\" Leer alto Escribir \"¿Cuál es el precio del metro cúbico de agua (en euros)?\" Leer preciom3 coste 0 Entonces escribir \"El número es POSITIVO\" FinSi si n -10 y n -100) o (n >= 10 y n -1000) o (n >= 100 y n -10000) o (n >= 1000 y n -100000) o (n >= 10000 y n = 100000 Entonces Escribir \"Error, ese número tiene más de 5 cifras\" SiNo Escribir \"El número de cifras del número \", n, \" es \", numCifras FinSi FinAlgoritmo ``` *Solución en diagrama de flujo:* ![Diagrama de flujo contar-cifras](/docs/prog-y-3d/_site/assets/ejercicios-resueltos-pseint/03_12_contar_cifras.png) **Ejercicio 14**. Escribir todos los números entre 1 y n, siendo n un entero introducido por teclado. *Solución en pseudocódigo:* ``` Algoritmo contar_de_uno_a_n Definir n,i Como Entero Escribir 'Dime un número' Leer n i maximo) Entonces maximo = 1 y numero_apuesta 0 y cantidad_apuesta \"Ninguno\" o tablas = Verdadero mostrar(tablero) Si ganador = \"Ninguno\" Entonces Escribir \"El juego ha terminado en tablas\" SiNo Escribir \"El juego ha terminado. El ganador es: \", ganador FinSi FinAlgoritmo // -------------------------------------------- // Inicializa el tablero con espacios en blanco // -------------------------------------------- SubAlgoritmo inicializar(tablero por referencia) Definir i como entero Para i \" \") Entonces contador <- contador + 1 FinSi FinPara // Si todas las casillas están ya ocupadas y no hay ganador, // entonces estamos en tablas. Si contador = 9 Entonces tablas <- Verdadero SiNo tablas <- Falso FinSi FinSubAlgoritmo ``` (No mostramos la solución en diagrama de flujo porque ocupa demasiado espacio. No obstante, si te interesa verla, solo tienes que escribir el programa en PSeInt y pedirle que te muestre el diagrama de flujo equivalente) ",
    "url": "/docs/prog-y-3d/_site/introduccion-a-la-programacion/",
    "relUrl": "/introduccion-a-la-programacion/"
  },"4": {
    "doc": "4. Estructuras de datos. Subalgoritmos",
    "title": "4. Estructuras de datos. Subalgoritmos",
    "content": "# 4. Estructuras de datos. Subalgoritmos {: .no_toc } - TOC {:toc} Hasta ahora, hemos conocido las estructuras de control básicas de cualquier programa estructurado: secuencia, condición e iteración. Pero los programas no se componen solo de *instrucciones*, sino también de ***datos***. Todos los datos que hemos manejado hasta ahora eran simples, es decir, se almacenaban en variables en las que solo podíamos guardar un valor en cada momento. Las variables simples se nos quedan cortas en muchas ocasiones (repasa el programa de las 3 en raya, sin ir más lejos, para comprobarlo). En esos casos necesitamos una variable de tipo complejo o **estructura de datos**. En este capítulo hablaremos de las estructuras de datos y nos centraremos en la más utilizada con diferencia: el **array**. Después, introduciremos los conceptos de **subalgoritmo, función y biblioteca de funciones**, para terminar hablando de uno de los principios básicos de la ingeniería del software: la **reutilización del código**. ## 4.1. Estructuras de almacenamiento de datos Hemos trabajado, por el momento, con los tipos de datos básicos: enteros, reales, caracteres, lógicos... Es el momento de dar el salto a los **tipos de datos complejos**, también llamados **estructuras de datos**. Las estructuras de datos pueden ser de dos tipos: * **Estáticas**: son aquellas que ocupan un espacio determinado en la memoria del ordenador. Este espacio es invariable y se especifica durante la escritura del código fuente. * **Dinámicas**: son aquellas cuyo espacio ocupado en la memoria puede modificarse durante la ejecución del programa. Existe todo un universo de estructuras de datos: desde los arrays, presentes en casi cualquier programa, hasta estructuras mucho más exóticas como pilas, colas, listas enlazadas, árboles, grafos, etc. Nosotros no pretendemos verlas todas, ni mucho menos, pero sí que conozcas la más importante de todas: el array. ## 4.2. Arrays unidimensionales (vectores) Un **array** (también llamado **arreglo**, sobre todo en América latina) es una *agrupación de muchos datos individuales del mismo tipo bajo el mismo nombre*. Cada dato individual de un array es accesible mediante un índice. Por ejemplo, un array de números enteros es una colección de muchos números enteros a los que les adjudicamos un único identificador. El caso más simple de array es el **array unidimensional**, también llamado **vector**. Se trata, sin duda, del rey de las estructuras de almacenamiento. ### 4.2.1. Declaración de vectores La **declaración de un vector** en pseudocódigo (seguiremos usando la sintaxis de PSeInt) se hace así: ``` Definir nombre_variable Como tipo Dimension nombre_variable[tamaño] ``` Por ejemplo: ``` Definir serie como Entero Dimension serie[10] ``` La variable *serie* será un vector que contendrá 10 números enteros. Todos los números recibirán el mismo nombre, es decir, *serie*. Se puede acceder a cada uno de los números que forman el vector escribiendo a continuación del nombre un número entre corchetes. Ese número se denomina **índice**. Observa el siguiente ejemplo: ``` Definir serie como Entero Dimension serie[5] serie[2] +------------+----+----+----+----+----+ | Posiciones | 0 | 1 | 2 | 3 | 4 | serie = +------------+----+----+----+----+----+ | Valores | ? | ? | 20 | 15 | 35 | +------------+----+----+----+----+----+ . Observa algo muy importante: **el primer elemento del vector tiene el índice 0**, es decir, el primer elemento es **serie[0]**. Como este vector tiene 5 elementos, el último será serie[4], no serie[5]. Observa también que los elementos 0 y 1 no han sido utilizados y, por lo tanto, tienen un valor desconocido, exactamente lo mismo que ocurre con cualquier variable de tipo simple que no se inicialice. *(Nota: PSeInt se puede configurar para que el primer elemento del vector tenga índice 1, no 0, pero, como la mayor parte de los lenguajes de programación reales usan el 0, supondremos que PSeInt también lo está haciendo)* Como es lógico, se pueden construir vectores cuyos elementos sean de cualquier otro tipo simple, como números reales o caracteres, con la única restricción de que todos los elementos sean del mismo tipo. Y, por supuesto, pueden construirse vectores cuyos elementos sean otros vectores. Obtendremos así un array bidimensional, del que hablaremos un poco más adelante. ### 4.2.2. Manipulación de elementos de un vector Los vectores deben manipularse **elemento a elemento**. *No se pueden modificar todos los elementos a la vez.* Por ejemplo, **para asignar valores a los elementos de un vector**, esta sería la manera: ``` Definir serie como Entero Dimension serie[5] serie[0] +----+----+----+----+----+----+----+----+----+----+ | 0 | 1 | 2 | 3 | 4 | 5 | 3 | 14 | 9 | 8 | +----+----+----+----+----+----+----+----+----+----+ . Después de la ordenación, nos quedará este otro vector: +----+----+----+----+----+----+----+----+----+----+ | 0 | 1 | 2 | 3 | 3 | 4 | 5 | 8 | 9 | 14 | +----+----+----+----+----+----+----+----+----+----+ . Del mismo modo, se pueden ordenar los elementos con cualquier otro criterio: de mayor a menor, primero los pares y luego los impares, o cualquier otro que nos resulte útil para resolver un problema. Métodos de ordenación de vectores hay muchos, algunos muy simples (e ineficientes) y otros muy elaborados, y constituyen un área de estudio muy interesante dentro de la algorítmica. Aquí vamos a presentar uno de los métodos más sencillos que existen para ordenar un vector, de modo que te resulte fácil entenderlo. Para aprender los métodos más complejos y rápidos ya tendrás tiempo en el futuro, ¿no te parece? #### Ordenación mediante selección directa La **selección directa** es probablemente el método de ordenación más fácil de entender porque es lo que la mayoría de nosotros haríamos si tuviéramos que ordenar un conjunto de elementos a mano. Esto no quiere decir que sea fácil de programar para un principiante, pero vamos a intentarlo. Vamos a suponer que tratamos de ordenar un vector de números enteros de menor a mayor pero, como hemos dicho, la misma idea podría emplearse para ordenar cualquier otra cosa y mediante cualquier otro criterio. El método de selección directa recorre el vector desde el principio hasta localizar el elemento más pequeño, guardando su posición y su valor en dos variables que llamaremos *posicion_minimo* y *valor_minimo*. Al terminar, coloca ese elemento mínimo en la primera posición del vector y lo intercambia con el elemento que antes ocupaba esa primera posición. (Para hacer ese intercambio de valores, es necesario usar una variable auxiliar que llamaremos *aux*). El proceso se repite, pero ahora desde la *segunda* posición del vector original. De nuevo volvemos a buscar el elemento más pequeño mirándolos todos de uno en uno. Al terminar, colocamos ese elemento mínimo en la *segunda* posición del vector, intercambiándola por el número que antes estaba en la segunda posición. Volvemos a hacerlo, ahora desde la *tercera* posición del vector original, y así sucesivamente hasta terminar de recorrer el vector completo. **Observa con detenimiento el código fuente de esta implementación**. No pases por él de puntillas para dedicarte a otra cosa. Dedica unos minutos para tratar de ejecutarlo *a mano*, es decir, con papel y lápiz, apuntando el valor de las variables para ver cómo actúa el algoritmo y cómo construye, pasada tras pasada, el vector ordenado. ``` Algoritmo seleccion_directa Definir i, j, aux Como Entero Definir valor_minimo, posicion_minimo Como Entero Definir vector Como Entero Dimensión vector[100] // Primero, vamos a llenar el vector_original con valores al azar entre 1 y 500, por ejemplo Para i desde 0 hasta 99 Hacer vector[i] = 0 Entonces Escribir \"El dato \", dato, \" estaba en la posición \", posicion SiNo Escribir \"No he encontrado el dato \", dato, \" en el vector\" FinSi ``` #### Búsqueda binaria Para que esta búsqueda funcione, como hemos dicho, **el vector debe estar previamente ordenado**. El **método de búsqueda binaria** consiste en lo siguiente: * **Paso 1**. Supongamos que v es el vector y que contiene N elementos. Llamaremos *izq* a la posición del elemento izquierdo del array (inicialmente, izq = 0). Llamaremos *der* a la posición del elemento derecho del array (inicialmente, der = N-1) * **Paso 2**. Tomamos un x igual al punto medio entre izq y der, es decir, x busc Entonces // Seguiremos buscando por la mitad izquierda der 2N pasos. ¿No te parece una diferencia muy impresionante? Fíjate en estos datos: * Si el vector es pequeño (por ejemplo, N = 10): * a. La búsqueda secuencial necesita una media de 5 pasos. * b. La búsqueda binaria necesita una media de 3 pasos. * Si el vector es mediano (por ejemplo, N = 100): * a. La búsqueda secuencial necesita una media de 50 pasos. * b. La búsqueda binaria necesita una media de 6 ó 7 pasos. * Si el vector es grande (por ejemplo, N = 1000), la mejora de tiempo empieza a ser notable: * a. La búsqueda secuencial necesita una media de 500 pasos. * b. La búsqueda binaria necesita una media de… ¡10 pasos! * Si el vector es muy grande (por ejemplo, N = 100.000), la mejora de tiempo es aún mayor: * a. La búsqueda secuencial necesita una media de 50.000 pasos. * b. La búsqueda binaria necesita una media de sólo 16 pasos. La mejora en el tiempo de búsqueda es, por lo tanto, mayor cuanto mayor es el vector. Por eso dijimos que la búsqueda binaria se emplea cuando los vectores son muy grandes. ## 4.3. Arrays bidimiensionales (matrices) Una **matriz**, **tabla** o **array bidimiensional**, igual que un vector, es una colección de elementos individuales, todos del mismo tipo, agrupados bajo el mismo identificador. La diferencia con el vector es que, en el momento de declararlo y de acceder a cada elemento individual, debemos utilizar **dos índices** en lugar de uno. Una matriz de, por ejemplo, 4x4 elementos, se declara así: ``` Definir matriz como Entero Dimension matriz[4][4] ``` La variable *matriz* no consta de 4 elementos enteros, sino de 16, organizados en 4 filas y 4 columnas. Podemos representar gráficamente la matriz como una tabla: Filas | V +----+----+----+----+----+ | 0 | 1 | 2 | 3 | **Cada casilla de la matriz es identificable mediante una pareja de índices**. Normalmente, el primero de los índices se refiere a la fila y, el segundo, a la columna. Por ejemplo, si hacemos estas asignaciones: ``` matriz[0][0] Filas | V +----+----+----+----+----+ | 0 | 1 | 2 | 3 | Por descontado, los dos tamaños de la matriz pueden ser diferentes, obteniéndose tablas que son más anchas que altas o más altas que anchas. Por lo demás, **las matrices se utilizan exactamente igual que los vectores**. A modo de ejemplo, este sería el código para inicializar una matriz de 5x10 enteros con todos sus elementos a 0. Observa cómo se usan los dos bucles anidados para acceder a todos los elementos: ``` Definir i, j como Entero Definir m como Entero Dimension m[5][10] Para i 0 Entonces i b) y (c > d * raiz(k) ) entonces a b)y(c>d*raiz(k))entonces a b)``` o ```(a>b)```, pero a cualquier programador que deba leer nuestro código le resultará mucho más cómoda la primera forma. Por la misma razón, también es conveniente dejar líneas en blanco entre determinadas instrucciones del algoritmo cuando se considere que mejora la legibilidad. #### Identificadores A la hora de elegir identificadores de variables (o de algoritmos y subalgoritmos) es muy importante utilizar **nombres que sean significativos**, es decir, que den una idea de la información que almacena esa variable. Por ejemplo, si en un programa de nóminas vamos a guardar en una variable la edad de los empleados, es una buena ocurrencia llamar a esa variable \"edad\", pero no llamarla \"x\", \"a\" o \"cosa\". Ahora bien, dentro de esta política de elegir identificadores significativos, es conveniente optar por aquellos que sean lo más cortos posible, siempre que sean descifrables. Un identificador llamado \"edad_de_los_empleados\" es engorroso de escribir y leer, sobre todo si aparece muchas veces en el algoritmo, cuando probablemente \"edad_empl\" proporciona la misma información. Sin embargo, si lo acortamos demasiado (por ejemplo \"ed_em\") llegará un momento en el no quede claro lo que significa. Toda esta idea de significación de los identificadores es extensible a los nombres de los algoritmos, de las funciones, de los procedimientos, de los archivos y, en general, de todos los objetos relacionados con un programa. Por último, señalar que muchos lenguajes de programación distinguen entre mayúsculas y minúsculas, es decir, que para ellos no es lo mismo el identificador \"edad\" que \"Edad\" o \"EDAD\". Por convenio, los algoritmos suelen nombrarse con la primera letra en mayúscula y el resto en minúsculas, mientras que las variables y funciones suelen nombrarse con la todas las letras en minúscula. Excepción: si el identificador consta de más de una palabra. En ese caso, ¿cómo es conveniente escribirlo? Existen dos convenciones para eso: * **CamelCase**: si el identificador consta de más de una palabra, se escriben todas juntas y la primera letra de cada palabra se escribe en mayúsculas. Por ejemplo: ```edadEmpleado```. * **snake_case**: si el identificador consta de más de una palabra, se escriben separadas por el signo de subrayado (_). Por ejemplo: ```edad_empleado```. Elegir CamelCase o snake_case es una cuestión de gustos personales. Lo importante es que, optes por el estilo que optes, lo utilices siempre y no mezcles identificadores de un tipo con identificadores de otro. ## 4.6. Ejercicios propuestos Resuelve los siguientes ejercicios utilizando subalgoritmos cuando la complejidad del problema así lo requiera. Puedes hacerlo con todos, excepto los números 1, 2, 7 y 8, que son tan simples que difícilmente podrás sacar un subalgoritmo de ellos. #### Ejercicios de vectores (arrays unidimensionales) **Ejercicio 1: Inicializar un vector**. Escribe un programa en pseudocódigo en el que se defina un vector de 100 números enteros, se inicialicen todos los elementos al valor –1 y se impriman por pantalla. **Ejercicio 2: Inicializar un vector (más complejo)**. Define dos vectores de 100 números enteros, uno llamado *pares* y otro *impares*. Inicializa el primero con los 100 primeros números pares positivos (es decir, pares[0] contendrá el valor 2, pares[1] contendrá el valor 4, pares[2] contendrá el valor 6, y así sucesivamente). Inicializa el segundo con los 100 primeros números impares positivos. Imprímelo por pantalla para comprobar que lo has hecho correctamente. **Ejercicio 3: Lotería primitiva**. Escribe un programa que genere al azar una combinación para jugar a la lotería primitiva asegurándote de que ningún número se repite. Pista: puedes utilizar un array de 6 números enteros, asignando a cada posición un número entero aleatorio entre 1 y 49, y comprobando que el número asignado no es igual a ninguno de los asignados anteriormente. **Ejercicio 4. Estadística básica**. Escribe un programa que pida al usuario N números enteros (siendo N un valor introducido por teclado) y calcule el valor medio de todos ellos, mostrando luego en la pantalla los números que están por encima de la media y los que están por debajo de ella. **Ejercicio 5. Ordenar vector gigante**. Escribe un programa que defina un vector de 1000 elementos y lo inicialice con valores aleatorios entre 0 y 2.000.000. Posteriormente, el programa debe ordenar los elementos del array de menor a mayor. Prueba luego a cambiar el tamaño del vector hasta los 10.000, 100.000 y 1.000.000 de elementos. ¿El tiempo de respuesta del programa crece linealmente con el tamaño del vector? **Ejercicio 6. Vector creciente**. Escribe un programa que defina un vector de 10 enteros y lo rellene con números CRECIENTES al azar entre 1 y 100. Es decir, los números serán elegidos aleatoriamente pero siempre tienen que ser mayores que los anteriores: el número que ocupe la posición 1 debe ser mayor que el de la posición 0, el de la posición 2 mayor que el de la 1, y así sucesivamente. Después de eso, se pedirá al usuario un número entre 1 y el número mayor que exista en el vector. El número introducido por el usuario se insertará en la posición del vector adecuada para conservar el orden, desplazando los demás elementos hacia la derecha, de manera que se pierda el último elemento. Después de insertar el número introducido por el usuario, el contenido del vector debe mostrarse por la pantalla. El proceso se repetirá hasta que el usuario introduzca un número negativo. Por ejemplo, supongamos que el array generado al azar por el ordenador, después de ordenarlo, es este: 4 – 18 – 23 – 25 – 44 - 45 – 51 – 72 – 78 - 85 . Como el número más alto es 85, el programa debe pedir al usuario: Introduzca un número entre 1 y 85: _ . Si el usuario teclea, por ejemplo, el número 67, éste debe ser insertado en la posición adecuada para conservar el orden, es decir, entre los números 51 y 72, desplazando a los demás números hacia la derecha, con lo cual se pierde el mayor de todos ellos (85). El vector quedaría así: 4 – 18 – 23 – 25 – 44 - 45 – 51 – 67 - 72 – 78 . #### Ejercicios de matrices (arrays bidimensionales) **Ejercicio 7. Inicializar matriz simple**. Escribe un programa en el que se defina una matriz de 10x10 números enteros. Inicializa todos los elementos al valor –1. **Ejercicio 8. Inicializar matriz complejo**. Repite el ejercicio anterior, inicializando ahora todas las filas pares al valor 0 y todas las filas impares al valor –1. **Ejercicio 9. Sumar filas**. Escribe un programa que defina una matriz de 6x3 números enteros y luego pida al usuario que introduzca los valores de cada elemento. Después, el programa debe sumar los tres números de cada fila, mostrando los resultados. **Ejercicio 10. Permutar filas**. Escribe un programa que defina una matriz de 3x5 números enteros y luego pida al usuario que introduzca los valores de cada elemento. Después, debe permutar el contenido de la fila 3 por el de la fila 1, y mostrar por último el contenido de la matriz. **Ejercicio 11. Sumar matrices**. Escribe un programa que defina dos matrices de 10x5 números enteros y las inicialice con números aleatorios entre 0 y 255. Posteriormente, cada elemento de la primera matriz debe ser sumado con el mismo elemento de la segunda matriz, guardando el resultado en una tercera matriz. Se deben sumar todas las parejas de elementos y mostrar el resultado en la pantalla. **Ejercicio 12. Jugueteando con matrices**. Escribe un programa que genere al azar una matriz cuadrada de NxN números enteros (siendo N un valor introducido por el usuario) y que luego haga lo siguiente: * *Mostrar*. Mostrará la matriz tal y como ha sido generada. * *Perímetro*. Mostrará los elementos que ocupan el borde de la matriz, partiendo de la esquina superior izquierda y recorriéndola hacia la derecha y luego hacia abajo. * *Centro*. Mostrará los elementos que ocupan el centro geométrico de la matriz. Puede ser 1 (si N es impar) o 4 (si N es par). * *Espiral*. Hará un recorrido en espiral por la matriz partiendo de la esquina superior izquierda. Por ejemplo, si la matriz fuera de 4x4 y tuviera este contenido: 4 6 7 8 2 4 3 9 0 1 3 4 7 3 3 5 ...las distintas operaciones deben obtener este resultado: * Perímetro: 4 6 7 8 9 4 5 3 3 7 0 2 * Centro: 4 3 1 3 * Espiral: 4 6 7 8 9 4 5 3 3 7 0 2 4 3 3 1 ## 4.7. Ejercicios resueltos **Ejercicio 1: Inicializar un vector**. Escribe un programa en pseudocódigo en el que se defina un vector de 100 números enteros, se inicialicen todos los elementos al valor –1 y se impriman por pantalla. ``` Algoritmo InicializarVectorSimple Definir i, vector Como Entero Dimension vector[100] // Inicializamos el array Para i media Entonces Escribir vector[i] FinSi FinPara FinAlgoritmo ``` **Ejercicio 5. Ordenar vector gigante**. Escribe un programa que defina un vector de 1000 elementos y lo inicialice con valores aleatorios entre 0 y 2.000.000. Posteriormente, el programa debe ordenar los elementos del array de menor a mayor. Prueba luego a cambiar el tamaño del vector hasta los 10.000, 100.000 y 1.000.000 de elementos. ¿El tiempo de respuesta del programa crece linealmente con el tamaño del vector? ``` Algoritmo ordenar_array Definir n, i como Entero Definir vector Como Entero // Dimensionamos el array Escribir \"¿De qué tamaño quieres el array?\" Leer n Dimension vector[n] // Inicializamos el array con valores aleatorios Para i vector[j+1] Entonces aux <- vector[j] vector[j] <- vector[j+1] vector[j+1] <- aux FinSi FinPara Borrar Pantalla Escribir \"Ordenando el array... \", redon(i*100/(n-2)), \"%\" FinPara FinSubAlgoritmo ``` **Ejercicio 7. Inicializar matriz simple**. Escribe un programa en el que se defina una matriz de 10x10 números enteros. Inicializa todos los elementos al valor –1. ``` Algoritmo inicializar_matriz_simple Definir fila, columna como entero Definir matriz como entero Dimension matriz(10,10) // Primero inicializamos la matriz Para fila <- 0 hasta 9 Hacer Para columna <- 0 hasta 9 Hacer matriz[fila, columna] <- -1 FinPara FinPara // Después mostramos la matriz por pantalla Para fila <- 0 hasta 9 Hacer Para columna <- 0 hasta 9 Hacer Escribir sin saltar matriz[fila, columna], \" \" FinPara Escribir \" \" // Hace el salto de línea al final de cada columna FinPara FinAlgoritmo ``` **Ejercicio 8. Inicializar matriz complejo**. Repite el ejercicio anterior, inicializando ahora todas las filas pares al valor 0 y todas las filas impares al valor –1. ``` Algoritmo inicializar_matriz_complejo Definir fila, columna como entero Definir matriz como entero Dimension matriz(10,10) // Primero inicializamos la matriz Para fila <- 0 hasta 9 Hacer Para columna <- 0 hasta 9 Hacer Si fila MOD 2 = 0 Entonces matriz[fila, columna] <- 0 SiNo matriz[fila, columna] <- -1 FinSi FinPara FinPara // Después mostramos la matriz por pantalla Para fila <- 0 hasta 9 Hacer Para columna <- 0 hasta 9 Hacer Si fila MOD 2 = 0 Entonces Escribir sin saltar \" \", matriz[fila, columna], \" \" SiNo Escribir sin saltar matriz[fila, columna], \" \" FinSi FinPara Escribir \" \" // Hace el salto de línea al final de cada columna FinPara FinAlgoritmo ``` ",
    "url": "/docs/prog-y-3d/_site/estructuras-de-datos/",
    "relUrl": "/estructuras-de-datos/"
  },"5": {
    "doc": "5. Lenguaje Javascript",
    "title": "Ventana nerviosa",
    "content": "Saltar Temblar Ocultar Mostrar ``` Lo siguiente es programar el código de cada una de las cuatro funciones Javascript, que se ejecutarán al pulsar cada botón. No te voy a decir lo que tienes que escribir en ellas, pero sí te voy a dar un par de pistas: * **Pista nº 1**. Hay un objeto en Javascript llamado ***window***, que nos permite alterar las propiedades de la ventana del navegador. Por ejemplo, nos permite cambiar su posición y su tamaño. En el apartado 5.2.11, sobre *Objetos predefinidos de Javascript*, hablamos de qué modo se puede cambiar eso. Observa que, en el fragmento de código anterior, hemos creado un objeto *window* llamado ***myWindow***. Es sobre ese objeto sobre el que tienes que actuar. * **Pista nº 2**. En el ejercicio anterior cambiábamos las propiedades *top* y *left* de un botón, pero los botones (y cualquier cosa que haya en una página web) tienen muchas otras propiedades (¡pero MUCHAS!). Una de ellas se llama ***visibility***, y puede tomar dos valores: *visible* o *hidden*. #### Ejercicio 5. Colorines Vamos a juguetear más con las propiedades de la página web cargada desde Javascript. En esta ocasión, construiremos una página con un cuadro de texto, un botón y un recuadro de color negro. Si escribimos en la caja de texto otro color (por ejemplo, \"orange\") y hacemos click en el botón, **el recuadro negro tiene que cambiar de color** y volverse naranja. El código HTML que puedes usar como base es este: ```html Colorines . ",
    "url": "/docs/prog-y-3d/_site/javascript/",
    "relUrl": "/javascript/"
  },"6": {
    "doc": "5. Lenguaje Javascript",
    "title": "Colorines",
    "content": "Cambiar color ``` Observa que, además de preparar los tres elementos que necesitamos (el recuadro de color negro, la caja de texto y el botón), hemos añadido más elementos HTML como *head* o *title*. Esos elementos son necesarios para que la página web se considere bien formada. Si no sabes lo que significan (aunque es bastante evidente), puedes repasarlos en el capítulo dedicado a HTML. (El navegador se tragará la página web aunque no esté bien formada, pero lo correcto es hacerla bien dentro de lo posible). Ahora solo te falta escribir el código de la función Javascript para cambiar el color del recuadro. #### Ejercicio 6. Pelota de goma Busca en internet una imagen de una pelota que te guste y descárgala. En esa imagen no debe aparecer nada más, excepto la pelota. Luego insértala en una página web, así: ```html ``` En *'nombre-del-archivo-de-la-imagen'*, como es lógico, tendrás que escribir el nombre del archivo que contiene tu pelota. Le hemos asignado 100 píxeles de ancho y 100 de alto, pero si es demasiado pequeña o demasiado grande, siéntete libre de cambiar esas cantidades. **Ahora escribe en Javascript un programa para que la pelota rebote por la pantalla como si fuera una pelota de verdad.** Para conseguirlo, tendrás que: * Alterar de nuevo las propiedades *top* y *left* de la pelota * Usar las propiedades el objeto ***window*** para evitar que la pelota se salga de los márgenes de la pantalla. * Utilizar un **temporizador** para mover la pelota cada x milisegundos. Según el valor de x, la pelota se moverá más deprisa o más despacio. **Mejora para los más valientes**: trata de añadir un botón a este programa. Al pulsarlo, la pelota se detendrá. Al volver a pulsarlo, la pelota se pondrá en marcha de nuevo. #### Ejercicio 7. Tres en raya improved **Modifica el juego de las tres en raya para que sea más atractivo al usuario y más cómodo de jugar.** Tienes que eliminar todas las entradas de datos mediante *prompt()* y sustituirlas por cajas de texto HTML, como esta: ```html ¿En qué casilla quieres poner tu pieza? (1-9) Aceptar ``` Al hacer clic en el botón, se ejecutará la función *colocar_pieza()*. Observa cómo se extrae el texto escrito en el cuadro de texto para llevárnoslo a una variable de Javascript (llamada *casilla*). También puedes mejorar la apariencia del juego alterando sus colores, tipografías, etc. Tendrás que investigar un poco en internet sobre cómo puede hacerse eso. #### Ejercicio 8. Tenis (Aviso: este ejercicio es de dificultad elevada) Ya sabes hacer que una pelota rebote (ejercicio 5). **Vamos a mejorar ese programa haciendo una versión del clásico juego de tenis *\"Pong\"***, el primer videojuego comercial de la historia. Si no conoces el *Pong*, bichea un poco por Internet para averiguar cómo es. ¡Y ahora trata de programar una versión actualizada en Javascript! #### Ejercicio 9. Carretera al infierno (Aviso: este ejercicio es de dificultad elevada) En esta ocasión, vamos a programar **un juego que llamaremos \"Carretera al infierno\"**. En el juego, manejaremos un coche (busca en internet la imagen de un coche visto desde arriba). El coche aparecerá en la parte inferior de la pantalla, centrado y mirando hacia arriba. Una carretera irá desplazándose de arriba a abajo. La carretera no será recta, sino que tendrá irregularidades aleatorias hacia la izquierda y hacia la derecha. Nuestro objetivo es mover el coche hacia la izquierda y hacia la derecha para evitar que se salga de la carretera. La carreterá se moverá cada vez más deprisa. **El objetivo del juego es aguantar la mayor cantidad posible de tiempo sin salirnos.** ## 5.7. Ejercicios resueltos Aquí iremos poniendo los ejercicios que resolvamos en clase. ",
    "url": "/docs/prog-y-3d/_site/javascript/",
    "relUrl": "/javascript/"
  },"7": {
    "doc": "5. Lenguaje Javascript",
    "title": "5. Lenguaje Javascript",
    "content": "# 5. El lenguaje Javascript {: .no_toc } - TOC {:toc} El ordenador, como ya sabes, solo puede manejar ceros y unos, es decir, código o **lenguaje binario**. Los seres humanos, por el contrario, utilizamos un lenguaje mucho más complejo, con montones de símbolos y reglas sintácticas y semánticas, que denominamos **lenguaje natural** (aunque de \"natural\" tiene poco). Entre estos dos extremos (lenguaje binario y lenguaje natural) se encuentran los **lenguajes de programación**. Tienen cierto parecido con el lenguaje natural, pero son mucho más reducidos y estrictos en su sintaxis y semántica, para acercarse a las limitaciones del lenguaje binario. En este capítulo vamos a aprender a escribir algoritmos con un lenguaje de alto nivel llamado **Javascript**. Se trata de un lenguaje que ha alcanzado una popularidad enorme gracias a que se encuentra incrustado en todas las páginas web que visitas a diario. Javascript es la piedra angular de cualquier web, pero también puede usarse como un lenguaje de programación convencional para escribir algoritmos de forma rápida, que es lo que vamos a hacer en este tema. Lenguajes de programación hay muchos, así que también hablaremos de otros lenguajes y conoceremos los tipos y características de algunos de ellos. ## 5.1. Orientándose en la jungla de los lenguajes de programación Los lenguajes de programación constituyen un ecosistema muy extenso y en constante evolución. Para orientarse un poco en esa jungla, nada mejor que clasificar los lenguajes igual que los biólogos clasifican a las criaturas vivas. ### 5.1.1. Tipos de lenguaje según el nivel de abstracción: alto y bajo nivel Hay lenguajes de programación muy próximos al lenguaje binario: a éstos los llamamos **lenguajes de bajo nivel** de abstracción. Y los hay más próximos al lenguaje natural: son los **lenguajes de alto nivel** de abstracción. #### Lenguajes de bajo nivel Son los lenguajes más cercanos a la máquina. Los programas directamente escritos en código binario se dice que están en **lenguaje máquina** que, por lo tanto, es el lenguaje de más bajo nivel que existe. Las instrucciones del lenguaje máquina realizan tareas muy sencillas, como, por ejemplo, sumar dos números, detectar qué tecla se ha pulsado en el teclado o escribir algo en la pantalla del ordenador. Cuando se combinan adecuadamente muchas de estas instrucciones sencillas se obtiene un programa de ordenador que puede realizar tareas muy complejas. Por ejemplo, este puede ser el aspecto de una instrucción en lenguaje máquina para sumar dos números: ``` 0001 000100000101 110100110101 ``` Incomprensible, ¿verdad? A pesar de la simplicidad de las instrucciones del lenguaje máquina, la forma de escribirlas es muy complicada, ya que hay que hacerlo en binario. En los primeros años de la informática los ordenadores se programaban directamente en lenguaje máquina, lo cual convertía la tarea de programar en una verdadera pesadilla. Hoy en día nadie lo hace. Cuando los ordenadores fueron haciéndose más potentes, surgió la idea de utilizar el propio ordenador como **traductor**: ¿por qué no escribir instrucciones en un lenguaje más parecido al natural y que un programa de ordenador se encargue de traducir esa instrucción a su correspondiente instrucción en lenguaje máquina? Así apareció el **lenguaje ensamblador**, cuyas instrucciones son equivalentes a las del lenguaje máquina, pero se escriben con palabras similares a las del lenguaje humano. Por ejemplo, para sumar dos números, la instrucción en ensamblador puede tener un aspecto como este: ``` ADD D1 D2 ``` #### Lenguajes de alto nivel Siguiendo el razonamiento anterior (utilizar el propio ordenador como traductor), en la década de 1960 y, sobre todo, de 1970, se empezaron a desarrollar lenguajes cada vez más complejos, en los que cada instrucción ya no se correspondía exactamente con una instrucción del lenguaje máquina, sino con varias. Estos son los **lenguajes de alto nivel**. Lógicamente, la traducción desde un lenguaje de alto nivel a lenguaje máquina es mucho más compleja que desde lenguaje ensamblador, por lo que *los traductores se han hecho cada vez más complicados*. Una característica muy importante de los lenguajes de alto nivel es que **son independientes del hardware**, lo que implica que los programas desarrollados con estos lenguajes pueden ser ejecutados en ordenadores con hardware totalmente distinto. A esto se le llama **portabilidad**. Los programas encargados de traducir el código de alto nivel a código máquina se llaman **compiladores** e **intérpretes**. Son programas muy complejos que generan el código binario equivalente al código de alto nivel para una máquina concreta. Por lo tanto, el programa de alto nivel, que es portable de un hardware a otro, debe ser traducido a código máquina en cada tipo de máquina en la que se pretenda ejecutar. Los ejemplos de lenguajes de alto nivel son innumerables, y la lista incluye casi todos de los que has oído hablar alguna vez: Basic, Cobol, Fortran, Ada, C/C++, PHP, Python, Java, Perl, Ruby, Javascript, etc. #### Ventajas e inconvenientes de los lenguajes de alto y bajo nivel **LENGUAJES DE BAJO NIVEL**|**LENGUAJES DE ALTO NIVEL** -|- **Ventajas**|**Inconvenientes** Son comprensibles directamente por la máquina (aunque el ensamblador necesita una pequeña traducción)|Necesitan ser traducidos por medio de complicados programas (compiladores e intérpretes) Los programas se ejecutan muy rápidamente (si están bien escritos, claro)|La traducción automática del código de alto nivel al código máquina siempre genera programas menos eficientes que si se escribieran directamente en binario Ocupan menos espacio en memoria|Ocupan más espacio en memoria Permiten controlar directamente el hardware, por lo que son apropiados para la programación de sistemas|En general, solo pueden acceder al hardware utilizando al sistema operativo como intermediario. Pero, entonces, ¿cómo programar el sistema operativo, que necesita controlar directamente el hardware? **Inconvenientes**|**Ventajas** Son completamente dependientes del hardware. Un programa escrito para determinado tipo de máquina no funcionará en un ordenador con diferente arquitectura.|Son portables, es decir, independientes del hardware. Un programa escrito en una máquina puede funcionar en otra con hardware distinto, siempre que se vuelva a traducir a binario en la máquina nueva. Incluso los programas más sencillos son largos y farragosos|Los programas son más sencillos, ya que una sola instrucción puede equivaler a varias instrucciones binarias. Los programas son difíciles de escribir, depurar y mantener|Los programas son más fáciles de escribir, depurar y mantener Es imposible resolver problemas muy complejos|Es posible, aunque difícil, enfrentarse a problemas muy complejos Si echas un vistazo a la tabla anterior comprenderás que, en general, **es preferible usar lenguajes de alto nivel** la gran mayoría de las veces, reservando los de bajo nivel para casos muy concretos, como el desarrollo de ciertas partes de los sistemas operativos. También hay que destacar que no todos los lenguajes de alto nivel son iguales. Los hay de más alto nivel que otros. El lenguaje C, por ejemplo, tiene menor nivel de abstracción que, por ejemplo, Java. Esto hace que los programas escritos en C sean más rápidos y eficientes que los escritos en Java, aunque también pueden llegar a ser más difíciles de escribir y depurar. ### 5.1.2. Tipos de lenguaje según su generación Los lenguajes de programación también se clasifican según la generación a la que pertenecen. El lenguaje máquina fue el lenguaje de primera generación. Los ensambladores fueron los lenguajes de segunda generación. A partir de ahí, surgió una explosión de lenguajes diferentes que podemos clasificar como: * **Lenguajes de tercera generación** (o **imperativos**), en los que el programador escribe una secuencia de instrucciones que el ordenador debe ejecutar en un orden preestablecido. Son los lenguajes más \"clásicos\": C, Basic, Cobol, Fortran, Pascal, etc. * **Lenguajes de cuarta generación** (o **4GL**), dirigidos a facilitar la creación de interfaces con el usuario y con otras aplicaciones, como las bases de datos. Un ejemplo de estos lenguajes es SQL, universalmente utilizado para manipular bases de datos y omnipresente en muchas aplicaciones web actuales. * **Lenguajes orientados a objetos**, que son una evolucuión de los lenguajes de tercera generación y que permiten construir con mayor facilidad y robustez programas modulares complejos. Ejemplos de lenguajes orientados a objetos son C++, C#, Java, Javascript, Python, PHP o Ruby. Algunos de ellos son multiparadigma, es decir, permiten programar con orientación a objetos pero también permiten hacer programación estructurada clásica, sin objetos. * **Lenguajes declarativos** y **lenguajes funcionales**, propios de la inteligencia artificial, como Prolog o Lisp. * **Otros** tipos aún más específicos: lenguajes concurrentes, paralelos, distribuidos, etc. En general, podemos decir que un programador acostumbrado a trabajar con un lenguaje de tercera generación puede aprender con poco esfuerzo cualquier otro lenguaje de tercera generación y, con algo más de trabajo, un lenguaje orientado a objetos. Sin embargo, el \"salto\" a otros tipos de lenguajes, como los declarativos, cuesta más porque las fundamentos de estos lenguajes son muy diferentes. ### 5.1.3. Tipos de lenguaje según su forma de traducción Cuando programamos en un lenguaje distinto del lenguaje máquina, **nuestro código debe ser traducido a binario** para que el ordenador pueda entenderlo y ejecutarlo. Existe un programa específico encargado de hacer esa traducción y que, dependiendo del lenguaje en el que hayamos escrito nuestro programa, puede ser un *ensamblador*, un *compilador* o un *intérprete*. #### Ensambladores Se llaman **ensambladores** los programas encargados de **traducir los programas escritos en ensamblador a código binario**. Sí, ya lo sé: se usa el mismo nombre para referirse al *lenguaje* de programación y al *traductor* de ese lenguaje a código máquina. Es un lío. Como el lenguaje ensamblador es muy próximo al binario, estos traductores son programas relativamente sencillos. #### Compiladores El **compilador** es un programa que traduce el **código de alto nivel a código binario**. Es, por tanto, parecido al ensamblador, pero mucho más complejo, ya que las diferencias entre los lenguajes de alto nivel y el código binario son muy grandes. El programa escrito en lenguaje de alto nivel se denomina programa fuente o **código fuente**. El programa traducido a código binario se llama programa objeto o **código objeto**. Por lo tanto, el compilador se encarga de convertir el programa fuente en un programa objeto. Una vez que se ha obtenido el código objeto ya no es necesario volver a realizar la traducción (o compilación), a menos que se haga alguna modificación en el programa fuente, en cuyo caso habría que volver a compilarlo. El código objeto, una vez generado, puede ejecutarse en la máquina en la que fue compilado, o en otra de similares características (procesador, sistema operativo, etc.). Cuando se usa programación modular, puede ser necesario un proceso previo de enlace de los diferentes módulos antes de poder construir el programa ejecutable. #### Intérpretes El **intérprete** es un programa que **traduce el código de alto nivel a código binario** pero, a diferencia del compilador, lo hace **en tiempo de ejecución**. Es decir, no existe un proceso previo de traducción de todo el código fuente a código binario, sino que se va traduciendo y ejecutando instrucción por instrucción. #### Compiladores frente a intérpretes El **intérprete** es notablemente **más lento** que el compilador, ya que realiza la traducción al mismo tiempo que la ejecución. Además, esa traducción se lleva a cabo siempre que se ejecuta el programa, mientras que el compilador sólo la hace una vez. Hay un evidente malgasto de recursos. Sin embargo, muchos lenguajes muy populares en la actualidad, como Javascript, PHP o Python, suelen ser interpretados y no compilados. Alguna ventaja tendrá la interpretación frente a la compilación, ¿no crees? Pues sí: la **gran ventaja de los intérpretes** es que hacen que **los programas sean más portables**. Así, un programa compilado en una máquina PC bajo Windows no funcionará en un Mac o en un PC bajo Linux, a menos que se vuelva a compilar el programa fuente en el nuevo sistema. En cambio, un programa interpretado funcionará en todas las plataformas, siempre que dispongamos del intérprete en cada una de ellas. **JavaScript** es un ejemplo de lenguaje interpretado tremendamente popular gracias al crecimiento de Internet. Los programas escritos con JavaScript (llamados comúnmente *scripts*) pueden funcionar en cualquier máquina que disponga de un intérperte Javascript, y resulta que todos los navegadores web tienen uno. Por eso, **cualquier programa escrito en Javascript puede ejecutarse prácticamente en cualquier ordenador del mundo** sin tocarle ni una coma. En cambio, **C++**, por ejemplo, es un lenguaje compilado, lo que hace que los programas desarrollados con estos lenguajes se ejecuten más rápido (¡pero mucho más rápido!) que sus equivalentes en JavaScript. Sin embargo, tendrás que volver a compilarlos si deseas ejecutarlos en una máquina con diferente hardware o diferente sistema operativo. ### 5.1.4. Tipos de lenguaje según su tipado Por *tipado* nos referimos a la forma en la que los lenguajes de programación usan los tipos de datos. Ya sabes: entero, carácter, lógico, etc. Es decir, las categorías a las que puede pertenecer una variable. Pues bien, según su tipado, los lenguajes pueden ser: * **De tipado fuerte**: los tipos de datos no pueden mezclarse. Por ejemplo, no puedes sumar un entero y un real, porque son números de distinto tipo. Y mucho menos sumar un entero con un carácter. * **De tipado débil**: los tipos de datos pueden mezclarse y el lenguaje hace las conversiones de tipos implícitas que le parezca oportunas. Así, en estos lenguajes podrías sumar un entero con un real, o incluso un entero con un carácter. ¿Que cuál sería el resultado? Buena pregunta. Tendrás que probarlo, porque eso depende de las conversiones de tipo que haga el lenguaje. * **De tipado estático**: los tipos de datos se asignan al escribir el código y no pueden cambiarse durante la ejecución. Esto es típico de los compiladores (aunque no de todos). * **De tipado dinámico**: los tipos de datos pueden cambiarse alegremente durante la ejecución. Esto es típico de los intérpretes. Las dos primeras categorías y las dos segundas no son excluyentes. Por ejemplo, pueden existir lenguajes de tipado débil y dinámico, o bien fuerte y estático. Las otras combinaciones (fuerte y dinámico, débil y estático) pueden darse pero son menos habituales. ### 5.1.5. El *top ten* de los lenguajes de programación Es difícil saber cuales son los lenguajes más populares en un determinado momento porque no existen estadísticas fiables a nivel mundial. Además, las cosas pueden cambiar mucho de un territorio a otro. Sin embargo, ciertos sitios de internet, como **GitHub**, almacenan enormes cantidades de proyectos de software. GitHub, de hecho, es el mayor almacén de código fuente conocido, de modo que sus estadísticas nos pueden dar una idea bastante exacta de cuál es el grado de uso de cada lenguaje. Según [Madnight](https://madnight.github.io/githut), un proyecto que recopila y publica estadísticas de uso de lenguajes en GitHub, el *top ten* de lenguajes de programación más usados en GitHub es: Puesto|Lenguaje|Porcentaje de uso|Variación de uso en 12 meses -|-|-|- 1|JavaScript|17.955%|-2.192% 2|Python|15.943%|+0.071% 3|Java|12.977%|+1.573% 4|Go|8.203%|-0.612% 5|TypeScript|7.212%|-0.276% 6|C++|6.683%|-0.251% 7|Ruby|6.488%|+0.303% 8|PHP|4.937%|-0.093% 9|C#|3.366%|-0.350% 10|C|2.958%|+0.068% El porcentaje de uso indica la proporción de proyectos en GitHub que usan ese lenguaje de programación sobre el total de proyectos. La última cifra señala la variación interanual del porcentaje de uso. Estos datos son de tercer cuatrimestre de 2021. Para obtener datos de otras fechas, puedes visitar la web [https://madnight.github.io/](https://madnight.github.io/) Ten en cuenta de nuevo que esto no son cifras de uso absoluto de los lenguajes a nivel mundial. Solo se trata de una pista de cuál es la situación. De hecho, si consultas otras estadísticas como el [TIOBE index](https://tiobe.com/tiobe-index/), encontrarás datos diferentes. Según las cifras de Madnight, Javascript continúa siendo el lenguaje preferido por la mayoría de los programadores (aunque está lejos de sus tiempos memorables, donde llegó a utilizarse en casi el 30% de los proyectos activos en Github). Viejas glorias como Java, C++, PHP y C aguantan muy bien el tipo, con unos números muy estables, porque tienen una base de programadores muy fieles a sus espaldas, mientras que algunos lenguajes recientes como Go y Typescript se han hecho un hueco en el ránking de los 10 más usados. ## 5.2. ¡Bienvenidos a Javascript! ### 5.2.1. Características básicas de Javascript * Javascript es un lenguaje de **alto nivel**. * Es **imperativo y estructurado**. Admite **orientación a objetos basada en prototipos**, no en clases (puede que no entiendas lo que significa esto, pero de momento no importa). * Su **tipado es débil y dinámico**. * La **sintaxis** de sus estructuras de control está **heredada del lenguaje C**, como la de Java, PHP o Python, por lo que guarda bastantes semejanzas con estos otros lenguajes. * Es un **lenguaje interpretado**, pensado para ser ejecutado dentro de un navegador web. Por lo tanto, no es particularmente eficiente, pero sí muy portable. Sin embargo, también existen **compiladores y precompiladores** que permiten construir con Javascript cualquier tipo de programa, no solo aplicaciones web. * Es **altamente portable**. Cualquier programa en Javascript debería poder ejecutarse sin ninguna adaptación particular en cualquier navegador web reciente. * Su integración con los navegadores web hace que pueda manipular cualquier página web, incluso después de estar cargada en el navegador. * Es uno de los lenguajes de programación **más populares** del mundo en la actualidad. Aunque se ha intentado reemplazar muchas veces, ningún otro lenguaje lo ha conseguido (de momento). ### 5.2.2. Breve historia de Javascript Javascript fue un lenguaje creado en la década de 1990 para el ya desaparecido navegador web **Netscape Navigator**. En aquellos primeros tiempos de internet, las páginas web eran sitios muy poco vistosos, con mucho texto y unas pocas imágenes, y Javascript pretendía introducir un poco de movimiento y dinamismo en esas páginas tan aburridas. **Internet Explorer**, el principal competidor de Netscape, respondió creando el **VB Script** y, posteriormente, un lenguaje muy similar a Javascript (pero no igual) llamado **JScript**. Esos lenguajes no tuvieron éxito e Internet Explorer terminó por aceptar la existencia de Javascript. Aquella competición entre Netscape e Internet Explorer se llamó *guerra de los navegadores* y, aunque Netscape la perdió y acabó desapareciendo, Javascript ha permanecido hasta hoy como el heredero directo aquella época convulsa. Desde entonces, Javascript ha tenido una evolución enorme, y ha pasado de ser apenas un lenguaje de juguete con el que se podían conseguir un puñado de efectos dinámicos en los sitios web a ser un lenguaje muy potente y bien definido, capaz de sustentar la estructura de aplicaciones web complejas. Hoy en día, Javascript suele utilizarse con librerías y *frameworks* que mejoran su estructura y aumentan su potencia. El estándar del lenguaje está publicado por la **ECMA** (European Computer Manufacturers Association) y se denomina **ECMAScript**. Todos los navegadores web respetan ese estándar en gran medida. ### 5.2.3. Sintaxis básica de Javascript #### Generalidades sintácticas Hay algunas normas básicas de la sintaxis de Javascript que tienes que conocer: * **Los bloques de código se marcan con las llaves** ( **{** y **}** ). Por ejemplo, después de una sentencia *while* (equivalente al *mientras* de pseudocódigo) hay que abrir una llave. El cuerpo de bucle comprenderá desde esa llave de apertura hasta la siguiente llave de cierre, así: ```javascript while (condicion) { Instrucción 1 del bucle Instrucción 2 del bulce ... Instrucción N del bucle } ``` La llave de cierre, por tanto, sería el equivalente al *FinMientras* de pseudocódigo. * Todas las instrucciones **terminan con un punto y coma** ( **;** ). Excepción: si una instrucción contiene un bloque marcado con llaves ( { ... } ), se considera que esa instrucción termina al cerrar el bloque, y en ese caso no hace falta poner punto y coma. ```javascript a = 10; // La instrucción de asignación termina con ; while (condicion) { // Cuerpo del bucle } // El bucle termina con }, así que no necesita ; ``` * Los **identificadores** de variables, funciones, etc., no pueden empezar con un número ni contener espacios o símbolos especiales, salvo el de subrayado ( _ ) ```javascript a5 = 1; // Identificador de variable válido 5a = 1; // Identificador de variable NO válido ``` * Las **cadenas de caracteres** pueden encerrarse entre **comillas simples** ( '...' ) o **comillas dobles** ( \"...\" ) ```javascript a = \"Soy una cadena\"; b = 'Yo también soy una cadena'; ``` * El lenguaje es **sensitivo a las mayúsculas**. Es decir, no es lo mismo que una variable se llame *edad* que *Edad* o *EDAD*. #### Tipos de datos primitivos Javascript utiliza varios tipos de datos simples llamados **primitivos**. Los más importantes son: * **number**: números enteros y reales, indistintamente. * **string**: cadenas de caracteres. * **boolean**: datos de tipo lógico, es decir, de los que solo pueden valer *true* (verdadero) o *false* (falso). Como es un lenguaje de tipado dinámico, esos tipos **pueden variar durante la ejecución**, dependiendo de lo que hagas con las variables. De hecho, Javascript es tan flexible que **ni siquiera es necesario declarar las variables** (aunque es aconsejable). Es decir, que puedes usar una variable cuando la necesites sin tener que declararla antes. Las variables en Javascript se declaran con las palabras clave **var** o **let**. Las diferencias entre una y otra tienen que ver con el ámbito de la variable y las veremos enseguida. Por ejemplo: ```javascript var a = \"Hola\"; let b = 1; var c; d = 3; ``` En el código anterior hemos declarado tres variables, a, b y c. Observa que, **al declarar una variable, no se especifica el tipo**: Javascript decidirá su tipo en función del valor que se le asigne. Así pues, el tipo de la variable a será *string*, y el de la variable b será *number*. ¿Qué pasará con el tipo de la variable c? Hasta que no se le asigne algún valor, permanecerá *undefined*. Fíjate, por último, en que no hemos declarado la variable d, sino que la hemos usado directamente. Esto también es válido en Javascript, aunque, en general, poco recomendable por razones que comentaremos luego. El tipo de esta variable también será *number*. ### 5.2.4. Conversiones de tipo Javascript, como hemos dicho, es un lenguaje de **tipado dinámico**. Es decir, que las variables pueden variar de tipo a lo largo del programa: ```javascript var a = 1; // Variable tipo number // Aquí pueden ir varias instrucciones más a = \"Hola\"; // Ahora la variable es de tipo string ``` Además, Javascript también es un lenguaje **débilmente tipado**, lo que significa que no hace comprobaciones estrictas de tipos a la hora de asignar un valor a una variable o de comparar dos expresiones. Por ejemplo, estas instrucciones son correctas: ```javascript a = 5; // La variable a es de tipo number b = \"A\"; // La variable b es de tipo string c = a + b; // ¿Qué ocurre si las mezclamos en una expresión? ``` ¿Qué resultado crees que obtendrás con una mezcla de tipos como esta? ¿Por qué no haces la prueba? Cuando mezclas tipos, estás dejando que el lenguaje de programación decida cuál será el resultado, por lo que puedes obtener resultados imprevisibles. Es mejor que tú controles qué conversiones de tipo se hacen. Para eso, Javacript dispone de varias herramientas: * **typeof**: Nos dice de qué tipo es una variable. ```javascript a = 5; document.write(typeof a); // En la pantalla, aparecerá escrito \"number\" ``` * **String**: Convierte la variable a un *string* (cadena de caracteres). ```javascript a = 5; // a es el número entero 5 b = String(a); // b es la cadena \"5\" ``` * **parseInt** y **parseFloat**: Convierte la variable a un *number* entero o real (es decir, a sin decimales o con decimales). ```javascript a = \"5 pollos\"; // a es una cadena b = parseInt(a); // Javascript tratará de convertir la cadena a un número entero document.write(b); // ¿Qué crees que aparecerá en la pantalla? ``` ### 5.2.5. Asignación y ámbito de las variables La **asignación** de valores a variables en Javascript es fácil de explicar: se hace con el **símbolo igual (=)**, no con el símbolo 0) { let c = 3; // Variable local al bloque if document.write(\"La variable a vale \", a, \", la variable b vale \", b, \" y la variable c vale \", c); } } ``` En este ejemplo tenemos 3 variables: * La variable a vuelve a ser **global**, lo que significa que será accesible desde cualquier parte de este programa. * La variable b es **local a la función**. Está disponible desde su declaración hasta la llave de cierre de la función. * La variable c es **local a su bloque**. Es decir, está disponible desde su declaración hasta la llave de cierre del *if*. #### No declarar las variables Con Javascript, como ya hemos visto, es perfectamente posible **no declarar las variables** y usarlas sin más. Sin embargo, cuando haces este tipo de cosas, dejas que sea el lenguaje de programación el que tome decisiones por ti. En este caso, que decida sobre el ámbito de la variable. Por eso mi consejo es que *siempre* declares las variables, aunque no les asignes ningún valor inicial. Si decides usar las variables sin declarar, tienes que saber que Javascript las considerará a todas **globales**, independientemente del punto del programa donde hayas usado la variable por primera vez. ```javascript a = 1; // Variable global function mostrarMensaje() { b = 2; // Variable global if (b > 0) { c = 3; // Variable global document.write(\"La variable a vale \", a, \", la variable b vale \", b, \" y la variable c vale \", c); } } ``` ### 5.2.6. Operadores y expresiones Los **operadores y expresiones en Javascript** son iguales que los que hemos empleado en pseudocódigo: * Operadores **aritméticos**: +, -, \\*, /, % (este último significa *módulo de la división*). * Operadores **relacionales**: >, =, 0) { i--; // Equivalente a: i = i - 1 } ``` * Los **operadores lógicos** (Y, O, NO) se escriben de forma distinta: * **Y** se escribe **&&**. * **O** se escribe **\\|\\|**. * **NO** se escribe **!** (sí, sí, es una admiración). ```javascript if (a > 0) && (b > 0) { // Operador Y: tienen que darse las dos condiciones a la vez ... } ``` Hay algunas otras diferencias, desde luego, pero con esto ya tienes para hacer un buen montón de programas. ### 5.2.7. Estructuras de control Las **estructuras de control** en Javascript son muy similares a las que hemos utilizado en pseudocódigo, cambiando ligeramente la notación empleada. A continuación te muestro una tabla con las más habituales y su equivalente en pseudocódigo, sin entrar en explicaciones, porque supondremos que ya sabes manejarlas. Si no recuerdas para qué servía alguna de ellas, quizá sería buena idea que le dieras un repaso al capítulo dedicado al pseudocódigo. | Instrucción | Pseudocódigo | Javascript | . | Condicional simple | Si condición entonces &nbsp;&nbsp;&nbsp;acciones FinSi | if (condicion) { &nbsp;&nbsp;&nbsp;acciones } | . | Condicional doble | Si condicion entonces &nbsp;&nbsp;&nbsp;acciones SiNo &nbsp;&nbsp;&nbsp;acciones FinSi | if (condicion) { &nbsp;&nbsp;&nbsp;acciones } else { &nbsp;&nbsp;&nbsp;acciones } | . | Bucle tipo mientras | Mientras condicion hacer &nbsp;&nbsp;&nbsp;acciones FinMientras | while (condicion) { &nbsp;&nbsp;&nbsp;acciones } | . | Bucle tipo repetir | Repetir &nbsp;&nbsp;&nbsp;acciones Hasta Que condicion | do { &nbsp;&nbsp;&nbsp;acciones } while (condicion) | . | Bucle tipo para | Para variable &nbsp;&nbsp;&nbsp;acciones FinPara | for (variable = valor_inicial; variable != valor_final; variable = variable + incremento) { &nbsp;&nbsp;&nbsp;acciones } | . Fíjate en que casi todo se escribe del mismo modo que en pseudocódigo con un par de diferencias notables: * **DIFERENCIA 1: En el bucle tipo *repetir***, la condición de salida se expresa al revés (\"repetir mientras..\" en lugar de \"repetir hasta que...\". Lo verás mejor en este ejemplo que muestra los números del 1 al 100. Observa la condición del final del bucle: En pseudocódigo: ``` i = 100 ``` En Javascript: ```javascript i = 1; do { document.write(i); i++; } while (i | Instrucción | Pseudocódigo | Javascript | . | Entrada | Leer variable | variable = prompt(); | . | Salida | Escribir expresión | document.getElementById('selector').innerHTML = expresión; O bien: document.write(expresión); O bien: alert(expresión); | . Vamos a ver un poco más despacio cómo se usa cada una de estas funciones: #### Entrada de datos con prompt() La **entrada de datos** en Javascript puede hacerse de diversas maneras. En particular, usando **formularios HTML**, pero de momento no vamos a pelearnos con eso. En esta primera toma de contacto con el lenguaje, vamos a conformarnos con la función **prompt()**. Esta función muestra un mensaje en forma de ventana emergente y permite escribir un texto, asignándolo a una variable. Observa cómo se usa *prompt()* con este ejemplo escrito primero en pseudocódigo y luego en Javascript: Pseudocódigo: ``` Escribir(\"Dime un número\") Leer n ``` Javascript: ```javascript document.write(\"Dime un número\"); n = prompt(); ``` Si pruebas este código, verás que sucede algo raro: el mensaje \"Dime un número\" sale escrito en la ventana del navegador web, pero el número nos lo pide en una ventana emergente que se sitúa *por encima* del mensaje. ¡Y, en algunos navegadores, el mensaje \"Dime un número\" ni siquiera llega a verse! ![Prompt sin texto](/docs/prog-y-3d/_site/assets/images/05-prompt-sin-texto.png) Esto hace un efecto muy raro. ¿verdad? Para evitarlo, puedes **unir las dos instrucciones** en una sola, puesto que *prompt()* te permite incluir un mensaje en la caja de texto. Así: ```javascript n = prompt(\"Dime un número\"); ``` Al ejecutar este código, verás que el resultado es mucho más natural: ![Prompt con texto](/docs/prog-y-3d/_site/assets/images/05-prompt-con-texto.png) (Nota: la forma exacta en la que veas estas pantallas dependerá de tu navegador web, puesto que cada uno hace el *prompt* de manera ligeramente distinta) #### Salida de datos con innerHTML, document.write() y alert() La forma más sencilla de hacer la salida de datos con Javascript es usar **document.write()** o su hermana melliza, **document.writeln()**. Mira cómo se usa en este ejemplo y el resultado que produce en la ventana del navegador: Código: ```javascript ``` Resultado: ![Salida de datos con document.write()](/docs/prog-y-3d/_site/assets/images/05-salida-de-datos-con-document-write.png) La diferencia entre *write()* y *writeln()* es que la segunda insertará automáticamente un salto de línea tras la salida, y la primera no. Sin embargo, estas funciones tiene un grave problema: puede que el texto de salida *no se muestre inmediatamente*. La decisión de cuándo se muestra la salida la toma el navegador y hay poco que puedas hacer al respecto. Por eso, la usaremos en contadas ocasiones. Otra manera muy sencilla de hacer salida de datos es con **alert()**. Esta función muestra un texto en forma de ventana emergente. Parecido a *prompt()*, pero sin caja de texto para escribir. Observa a *alert()* en acción en el siguiente ejemplo: Código: ```javascript ``` Resultado: ![Salida de datos con alert()](/docs/prog-y-3d/_site/assets/images/05-salida-de-datos-con-alert.png) La salida con *alert()* es simple y efectiva, pero resulta muy invasiva. Si haces todo tu programa con *alert()*, el usuario se sentirá enseguida apabullado por esa cantidad de ventanas emergentes que le saltan a la cara. De modo que nos queda la tercera vía. Es la más enrevesada, pero también la mejor. Y, en fin, tampoco es tan complicado. Consiste en preparar una zona de la pantalla del navegador para hacer en ella la salida de datos, y luego acceder a la misma con **document.getElementById().innerHTML**. Si sabes un poco de **HTML**, el lenguaje de marcado con el que se codifican las páginas web, enseguida comprenderás lo que estamos haciendo. Si no tienes ni idea de HTML, no te preocupes. Basta con que sigas los pasos que proponemos aquí para que puedas ejecutar tus programas Javascript. Ya tendrás tiempo de aprender HTML más adelante. **Paso 1. Prepara la caja donde se hará la salida**. La caja se crea un la etiqueta **** de HTML, a la que puedes asignar un estilo de visualización. La primeras veces, puedes limitarte copiar y pegar este código en todos los programas Javascript que vayas a hacer: ```html ``` **Paso 2. Dentro de tu programa Javascript, utiliza *document.getElementById('salida').innerHTML = expresión* para hacer la salida**. Sí, lo sé, es un poco largo, pero Javascript es así. Por ejemplo, este código: ```html ``` ...producirá este resultado: ![Salida de datos con innerHTML](/docs/prog-y-3d/_site/assets/images/05-salida-de-datos-con-innerhtml.png) **Paso 3. Utiliza *document.getElementById('salida').innerHTML += expresión* si no quieres perder la salida anterior**. Es decir, si usas un **igual** (=), cada salida de datos borrará la pantalla. Si usas **más igual** (+=), la salida de datos se añadirá a la anterior, sin borrarla: ```html ``` **Paso 4 (OPTATIVO). Cambia las propiedades de tu caja de salida**. Intenta juguetear con las propiedades ***text-align***, ***border-style*** o ***border-color*** del *div* de salida. Además, hay muchas otras propiedades que puedes asignarle a esa caja. Si te atreves, investiga un poco cómo cambiar el color del texto o la tipografía. ### 5.2.10. Arrays Los **arrays en Javascript** son mucho más que simples arrays: se trata de elementos muy complejos y flexibles que se adaptan a multitud de soluciones. Aquí solo vamos a ver una introducción a los mismos. Conforme vayas profundizando en tu conocimiento de Javascript, descubrirás cosas nuevas sobre estas asombrosas estructuras y les sacarás más y más partido. #### Declaración de arrays Los arrays en Javascript se pueden **declarar** de diversas formas: ```javascript // Una forma de declarar un array: var ciudades = ['Almería', 'Granada', 'Málaga']; // Otra forma de declarar un array: var ciudades = new Array('Almería', 'Granada', 'Málaga'); // Esta es otra forma: var ciudades = new Array(3); ciudades[0] = 'Almería'; ciudades[1] = 'Granada'; ciudades[2] = 'Málaga'; // Y otra forma más: var ciudades = []; ciudades[0] = 'Almería'; ciudades[1] = 'Granada'; ciudades[2] = 'Málaga'; ``` Realmente, no todas estas formas son equivalentes, porque Javascript a veces tratará a la variable *ciudades* como un **Array** y a veces como un **objeto**. La diferencia entre una y otra cosa es tan sutil que, de momento, puedes desentenderte de ello. Si algún día te vuelves un experto en Javascript, ya entenderás esa diferencia. Por ahora, quédate con la idea de que todas estas formas son válidas para declarar un array. #### Características de los arrays en Javascript Como puedes observar por los ejemplos anteriores, los arrays de Javascript tienen dos características importantes: * **No es necesario indicar su tamaño al declararlos**, aunque se puede hacer. Esto se debe a que los arrays en Javascript son dinámicos: pueden crecer o decrecer durante la ejecución del programa. * **El índice empieza en 0**. Es decir, el primer elemento es el 0, el segundo es el 1, etc. * El **acceso a los elementos** del array se hace como en pseudocódigo: indicando el índice del elemento entre corchetes. Los arrays NO son variables primitivas (simples). Recuerda que esto significa que **siempre se pasan por referencia** a las funciones, mientras que las variables primitivas se pasan por valor. Repasa el paso de parámetros a funciones del que hablamos un poco más arriba si no recuerdas bien todo esto. Una cosa muy peculiar de los arrays de Javascript es que **sus elementos pueden ser de diferente tipo**. Por ejemplo: ```javascript // Este array tiene elementos del mismo tipo (strings): var ciudades = ['Almería', 'Granada', 'Málaga']; // Este array tiene elementos de diferente tipo: var miArray = ['Lunes', 5, ciudades]; ``` En el ejemplo anterior, el array *ciudades* solo contiene elementos de tipo *string*, mientras que el array *miArray* contiene elementos de tipo dispares: un *string*, un *number* y un *array*. Como ves, nada impide que un elemento de un array sea otro array. De hecho, un elemento de un array puede ser cualquier cosa. #### Propiedades y métodos Los arrays de Javascript, como cualquier objeto, tienen una serie de **propiedades y métodos**. Ya veremos exactamente qué son las propiedades y los métodos, pero de momento te basta saber que se trata de funciones y variables que *están dentro* del objeto de tipo array y que permiten usarlo. Algunas propiedades y métodos útiles de los arrays son: * **nombreArray.length**: devuelve el número de elementos del array. * **nombreArray.sort()**: ordena el array. * **nombreArray.push(valor)**: añade un elemento al array (a continuación de la última posición usada). Como consecuencia, el tamaño del array crecerá. * **nombreArray.pop()**: elimina el último elemento del array. Como consecuencia, el tamaño del array decrecerá. * **nombreArray.indexOf(valor)**: busca el elemento *valor* en el array y devuelve su posición (si lo encuentra) o -1 (si no lo encuentra). Hay muchas otras propiedades y métodos que puedes consultar en la [referencia oficial del lenguaje](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/Arrays). #### Recorrido de un array El **recorrido** de un array puede hacerse igual que en pseudocódigo, con la salvedad de que tendremos que averiguar la longitud del array antes de recorrerlo, puesto que el tamaño del array puede variar a lo largo del programa: ```javascript var ciudades = ['Almería', 'Granada', 'Málaga']; var longArray = ciudades.length; for (i = 0; i Púlsame ``` ¿Te imaginas lo que se verá en el navegador si cargas esa página? Pues sí: un botón cuyo texto será \"Púlsame\". Ahora mira el mismo código, ligeramente modificado: ```html Púlsame ``` Ese \"onclick\" a continuación del botón significa que **vamos a capturar el evento clic de ratón** asociado al botón. Al hacer clic sobre él, se ejecutará la función *procesar_boton()* de Javascript. Usaremos algún evento *onclick()* como este en los ejercicios para conseguir resultados curiosos. Sobre los eventos, se podría hablar muchísimo más, pero como introducción a Javascript es suficiente por ahora... ### 5.4.2. Temporizadores de Javascript Lo que te voy a contar ahora puede considerarse Javascript avanzado (o, al menos, no es Javascript básico). Pero lo vas a necesitar para hacer juegos y otras diversiones con Javascript y, en fin, tampoco es tan complicado... Se trata de los **temporizadores**. Un temporizador es como el cronómetro de una bomba de relojería de las que salen en las películas. Ya sabes, esas bombas que siempre tienen una pantalla LCD donde se ve una cuenta atrás que indica cuánto falta para que explote. (El temporizador es el cronómetro, no la bomba, que conste...) Un temporizador se pone en marcha así: ```javascript var timer = setTimeout('nombre-de-función', intervalo); ``` El *nombre-de-función* es exactamente eso: el nombre de alguna función Javascript que ya exista. El *intervalo* es un número entero. Lo que hace el temporizador es **iniciar una cuenta atrás de *intervalo* milisegundos y, cuando el cronómetro llega a cero, se ejecuta la función indicada**. Por ejemplo: ```javascript var timer = setTimeout('saludar', 1000); function saludar() { alert(\"Hola, mundo\"); } ``` Si ejecutas este código, verás que el saludo (¡Hola, mundo!) tarda exactamente un segundo en aparecer. El temporizador se ha encargado de ello. Nada más ejecutar el código, se ha puesto en marcha un temporizador cuyo encargo es ejecutar la función *saludar()* al cabo de 1000 milisegundos (es decir, un segundo). Programar acciones para que se realicen en el futuro abre muchísimas posibilidades. En particular, piensa en qué ocurriría si hacemos que la propia función *saludar()* vuelva a reestablecer el temporizador: ```javascript var timer = setTimeout('saludar', 1000); function saludar() { alert(\"Hola, mundo\"); setTimeout('saludar', 1000); } ``` Detente un momento a tratar de averiguar qué ocurriría al ejecutar este programa y por qué podríamos decir sin dudarlo que se trata de uno de los programas más plastas que hemos escrito hasta ahora. Si no te lo crees, pruébalo y lo comprobarás. Por último, si, por lo que sea, necesitas **detener un temporizador** que ya está en marcha, solo tienes que usar la función ***clearTimeout()***: ```javascript clearTimeout(timer); ``` Lógicamente, la variable *timer* debe ser la misma que usaste al crear el temporizador. ## 5.5. Un ejemplo completo Llegó la hora de poner manos a la obra. Si hay una sección de este capítulo que tienes que leer con atención, es esta. Así que es un mal momento para tener prisa. Vamos a escribir un **programa completo en Javascript**. Te puede servir de plantilla para desarrollar tus propios programas a partir de aquí. El programa en cuestión será una versión del juego de **las tres en raya** que resolvimos en el tema de introducción a la programación. No dudes en repasar aquel ejercicio resuelto para ver el pseudocódigo, puesto que nuestro programa será una traducción literal de ese pseudocódigo a Javascript. Aquí tienes el código fuente completo. Estúdialo con atención y asegúrate de entenderlo todo (o un gran porcentaje) antes de continuar. Ah, y no dejes de compararlo línea a línea con el mismo código en pseudocódigo. ### 5.5.1. El código fuente ```html ``` ### 5.5.2. ¿Cómo ejecutar y depurar este programa? Guarda el programa anterior en un archivo de texto con extensión .html (por ejemplo, *3-en-raya.html*). Luego, sencillamente, haz doble clic sobre él para abrirlo. El sistema operativo usará el navegador web predeterminado de tu sistema para abrir el archivo y la ejecución comenzará. #### ¡Socorro! El programa no funciona ¿El resultado no es el esperado? Es lo habitual. Habrá algún error en el código y te tocará depurarlo. Las páginas web (con Javascript incluido) son extraordinariamente resistentes a los errores. No te mostrarán mensajes de error cada vez que haya algo mal escrito. Al contrario, permanecerán en silencio para no asustar al usuario de la web y provocar que salga corriendo de allí. Por ese motivo, los errores de Javascript solo se dejan ver en la \"sala de máquinas\" del navegador. Por supuesto, los programadores/as tienen una manera de acceder a esa \"sala de máquinas\". Pulsa **F12** en tu navegador para abrir la **consola de errores** de Javascript. Asegúrate de seleccionar la pestaña etiquetada como ***Console***. Verás algo como esto: ![Consola de errores de Javascript](/docs/prog-y-3d/_site/assets/images/05-consola-errores-javascript.png) En la consola de errores aparecen, en rojo, los mensajes de error que haya lanzado el intérprete de Javascript, indicándote el tipo de error y la línea en la que se ha detectado. Los mensajes estarán en inglés, por supuesto, pero ¿qué esperabas? Si quieres aprender a programar, tienes que acostumbrarte a manejar el inglés técnico. ¡Atención! Dependiendo del navegador que uses, puede que esa consola de errores se abra con otra combinación de teclas. Tendrás que bichear un poco por internet para averiguarlo. Lo habitual, sin embargo, es F12. Cuando hayas localizado el error, **regresa a tu editor de texto, haz los cambios necesarios, guarda las modificaciones y recarga la página** (pulsando **F5** en la mayoría de los navegadores). Si el navegador se había quedado colgado, tendrás que cerrarlo, esperar unos segundos y volver a abrirlo. Y así hasta que funcione. ¡Mucha paciencia y sangre fría! Recuerda siempre que la mayor parte del tiempo de programación se va en depurar programas, no en escribirlos. ## 5.6. Ejercicios propuestos #### Ejercicio 1. Tabla de multiplicar Vamos a empezar por algo sencillito. Escribe un programa en Javascript que pida un número y muestre la tabla de multiplicar de ese número. Puedes utilizar esta plantilla para tu primer programa: ```html ``` Recuerda que la salida la puedes enviar al 'salida' con la expresión: *document.getElementById('salida').innerHTML* #### Ejercicio 2. Juego del número secreto Ahora algo solo un poquito más complicado: una versión en Javascript del juego del número secreto. (Puedes encontrarlo resuelto en el capítulo \"Introducción a la programación\") #### Ejercicio 3. Botón saltarín Aquí empezamos a divertirnos. **Vamos a hacer una página web con un botón. Al pulsar ese botón, Javascript hará que ¡el botón cambie de sitio!** Para eso, capturaremos el **evento *click*** del botón. El botón lo tienes que crear antes mediante HTML. No importa que no sepas HTML. Solo echa un vistazo a este código: ```html Púlsame ``` Ahora solo te queda programar la función *mover_boton()*. Para lograr que el botón se mueva, tendrás que fijarte primero en cómo está el botón creado: tiene un **id**, un evento **onclick** y un **style**. Dentro del este último se definen dos propiedades: * **top** es la distancia desde la parte superior de la ventana del navegador hasta el botón. Lo hemos establecido en 100 píxeles (100px). * **left** es la distancia desde la parte izquierda de la ventana del navegador hasta el botón. Le hemos dado 200 píxeles. Pues bien, debes hacer que Javascript modifique esas dos propiedades. Por ejemplo, así: ```javascript function mover_boton() { document.getElementById('boton').style.top = '150px'; document.getElementById('boton').style.left = '250px'; } ``` Con eso, el botón se moverá al hacer clic sobre él, pero solo la primera vez. Quedará emplazado en la posición top = 150px y left = 250px y ya no se desplazará más. **¿Y si quisiéramos que se moviera *siempre* que hagamos clic sobre él?** Es es lo que tienes que conseguir en este ejercicio. #### Ejercicio 4. Ventana nerviosa y botones evanescentes **Ahora vamos a conseguir que una ventana entera del navegador se mueva al pulsar un botón. Y a hacer aparecer y desaparecer botones.** De hecho, vamos a crear cuatro botones: * **Botón \"Saltar\"**: al pulsarlo, la ventana dará un salto. Es decir, cambiará de posición.. * **Botón \"Temblar\"**: al pulsarlo, la ventana se pondrá a \"temblar\", como si tuviera frío o se hubiera puesto nerviosa, durante un rato. * **Botón \"Ocultar\"**: al pulsarlo, los dos botones anteriores desaparecerán de la vista. * **Botón \"Mostrar\"**: al pulsarlo, los botones desaparecidos volverán a aparecer. Esos cuatro botones puedes crearlos con este código HTML. También crearemos una segunda ventana del navegador, que será la que cambiará de posición: ```html ",
    "url": "/docs/prog-y-3d/_site/javascript/",
    "relUrl": "/javascript/"
  },"8": {
    "doc": "6. Orientación a objetos",
    "title": "6. Orientación a objetos",
    "content": "# 6. Orientación a objetos {: .no_toc } - TOC {:toc} Orientación a objetos. Clases, objetos y constructores. Herencia. Subclases y superclases. Polimorfismo y sobrecarga. Encapsulamiento y ocultación. -------- ### 3.3 Variables: asignación y ámbito La **asignación** de valores a variables en Javascript es fácil de explicar: se hace con el **símbolo igual (=)**, no con el símbolo 0) { let c = 3; // Variable local al bloque if document.write(\"La variable a vale \", a, \", la variable b vale \", b, \" y la variable c vale \", c); } } ``` En este ejemplo tenemos 3 variables: * La variable a vuelve a ser **global**, lo que significa que será accesible desde cualquier parte de este programa. * La variable b es **local a la función**. Está disponible desde su declaración hasta la llave de cierre de la función. * La variable c es **local a su bloque**. Es decir, está disponible desde su declaración hasta la llave de cierre del *if*. #### No declarar las variables Con Javascript, como ya hemos dicho, es perfectamente posible no declarar las variables y usarlas sin más. Sin embargo, cuando haces este tipo de cosas, dejas que sea el lenguaje de programación el que tome decisiones por ti. En este caso, que decida sobre el ámbito de la variable. Por eso mi consejo es que *siempre* declares las variables, aunque no les asignes ningún valor inicial. Si decides usar las variables sin declarar, tienes que saber que Javascript las considerará a todas **globales**, independientemente del punto del programa donde hayas usado la variable por primera vez. ```javascript a = 1; // Variable global function mostrarMensaje() { b = 2; // Variable global if (b > 0) { c = 3; // Variable global document.write(\"La variable a vale \", a, \", la variable b vale \", b, \" y la variable c vale \", c); } } ``` ### 3.5 Conversiones de tipo Javascript es un lenguaje **débilmente tipado**, es decir, no hace comprobaciones estrictas de tipos a la hora de asignar un valor a una variable o de comparar dos expresiones. Por ejemplo, estas instrucciones son correctas: ```javascript a = 5; b = 3.8; c = a + b; ``` La variable a es de tipo entero (recuerda que el tipo lo asigna automáticamente Javascript) y la variable b es de tipo real (también llamado *float* o *double*, dependiendo del número de decimales que sea capaz de almacenar). Por lo tanto, en la expresión ```c = a + b``` se están mezclando los tipos entero y real, algo que solo es posible en los lenguajes débilmente tipados. La mezcla de tipos puede ser más rocambolesca. Por ejemplo, puedes mezclar enteros y cadenas. ¿Qué resultado obtendrás de una mezcla así? Buena pregunta. ¿Por qué no haces la prueba? Cuando mezclas tipos, estás dejando que el lenguaje de programación decida cuál será el resultado, por lo que puedes obtener resultados imprevisibles. Es mejor que tú controles qué conversiones de tipo se hacen: * **typeof**: Nos dice de qué tipo es una variable. ```javascript a = 5; document.write(typeof a); ``` * **String**: Convierte la variable a un string (cadena de caracteres). ```javascript a = 5; // a es el número entero 5 b = String(a); // b es la cadena \"5\" ``` * **Number**: Convierte la variable a un string (cadena de caracteres). ```javascript a = \"5 pollos\"; // a es una cadena b = Number(a); // Javascript tratará de convertir la cadena a un número document.write(b); // ¿Qué crees que aparecerá en la pantalla? ### 3.6 Operadores y expresiones Los **operadores y expresiones en Javascript** son iguales que los que hemos empleado en pseudocódigo, con unas pocas excepciones que mencionamos a continuación: * La **asignación**, como ya hemos dicho, se hace con el **símbolo igual (=)**, no con 0) { i--; // Equivalente a: i = i - 1 } ``` * El **operador lógico Y** se escribe **&&**. El **operador lógico O** se escribe **||**. El **operador lógico NO** se escribe *!* ```javascript if (a > 0) && (b > 0) { // Operador Y: tienen que darse las dos condiciones a la vez ... } ``` Hay algunas otras diferencias, desde luego, pero con esto ya tienes para hacer la mayoría de las cosas. ## 4. Estructuras de control en Javascript Las **estructuras de control** en Javascript son muy similares a las que hemos utilizado en pseudocódigo, cambiando ligeramente la notación empleada. A continuación te muestro una tabla con las más habituales y su equivalente en pseudocódigo, sin entrar en explicaciones, porque supondremos que ya sabes manejarlas. Si no recuerdas para qué servía alguna de ellas, quizá sería buena idea que le dieras un repaso al capítulo dedicado al pseudocódigo. | Instrucción | Pseudocódigo | Javascript | | Condicional simple | Si condición entonces acciones FinSi | if (condicion) { acciones } | . | Instrucción | Pseudocódigo | Javascript | . | Instrucción | Pseudocódigo | Javascript | . | Instrucción | Pseudocódigo | Javascript | . | Instrucción | Pseudocódigo | Javascript | . Si condición entonces inicio acciones fin| if (condición) { acciones } #### Condicional doble Pseudocódigo Lenguaje C si condición entonces inicio acciones-1 fin si_no inicio acciones-2 fin if (condición) { acciones-1 } else { acciones-2 } 4.3 Condicional múltiple Pseudocódigo Lenguaje C según expresión hacer inicio valor1: acciones-1 valor2: acciones-2 valor3: acciones-3 ... valorN: acciones-N si_no: acciones-si_no fin switch (expresión) { case valor1: acciones-1; break; case valor2: acciones-2; break; case valor3: acciones-3; break; ... case valorN: acciones-N; break; default: acciones-si_no; } Esta estructura presenta algunas peculiaridades, a saber: • La expresión discriminante debe escribirse entre paréntesis y ser de un tipo ordinal (int, char o similar). No pueden usarse cadenas ni números reales. • Los valores no pueden ser expresiones, sino constantes, es decir, números o caracteres fijos. • ¡Cuidado! Las acciones no son bloques de instrucciones, es decir, no van encerradas entre { y }. Eso quiere decir que, si se ejecutan las acciones-2, después se ejecutarán automáticamente las acciones-3, luego las acciones-4, etc. La forma de evitar esto es insertar la instrucción break al final de cada bloque de instrucciones. 4.4 Bucle mientras Pseudocódigo Lenguaje C mientras condición hacer inicio acciones fin while (condición) { acciones } 4.5 Bucle repetir Pseudocódigo Lenguaje C repetir inicio acciones fin mientras que condición do { acciones } while (condición) 4.6 Bucle para Pseudocódigo Lenguaje C para cont desde valor_inicial hasta valor_final inicio acciones fin for (inicialización; condición; incremento) { acciones } Cuidado con este tipo de bucle porque es algo diferente a como lo hemos visto en pseudocódigo. Ya se ha dicho en varias ocasiones que C es a veces un poco críptico. El bucle para (o bucle for) es un ejemplo típico de ello ya que: • La variable contador debe ser inicializada con una asignación dentro de la instrucción for. • El valor final debe ser expresado en forma de condición, como haríamos en un bucle mientras. • El incremento del contador hay que indicarlo explícitamente. Por ejemplo, el siguiente bucle en pseudocódigo: para cont desde 1 hasta 100 inc 2 hacer inicio acciones fin Tendría esta traducción en C: for (cont = 1; cont // Paso de parámetros por valor. // En este ejemplo, esta función no tendrá el efecto deseado, porque las variables // del programa principal no se verán afectadas. void intercambiar1(int a, int b) { int tmp = a; a = b; b = tmp; } // Paso de parámetros por referencia, sintaxis 1. // Esta función sí que consigue intercambiar los valores de las variables // del programa principal. void intercambiar2(int *a, int *b) { int tmp = *a; *a = *b; *b = tmp; } // Paso de parámetros por referencia, sintaxis 2. // Esta función también consigue su objetivo. A todos los efectos, // es idéntica a la función anterior. void intercambiar3(int &a, int &b) { int tmp = a; a = b; b = tmp; } // Programa principal int main() { int dato1 = 30, dato2 = 90; printf(\"Antes de la llamada a las funcioens: dato1 = %i, dato2 = %i\\n\", dato1, dato2); intercambiar1(dato1, dato2); printf(\"Después de intercambiar1: dato1 = %i, dato2 = %i\\n\", dato1, dato2); intercambiar2(&dato1, &dato2); printf(\"Después de intercambiar2: dato1 = %i, dato2 = %i\\n\", dato1, dato2); intercambiar3(dato1, dato2); printf(\"Después de intercambiar3: dato1 = %i, dato2 = %i\\n\", dato1, dato2); return 0; } 5.4 La función main() La función main() contiene el algoritmo o módulo principal del programa. La ejecución de un programa siempre empieza por la primera línea de la función main() La función main(), como todas las funciones de C, puede devolver un valor. El valor devuelto por main() debe ser de tipo entero. Esto se utiliza para pasar algún valor al programa que haya llamado al nuestro, que suele ser el sistema operativo. Si main() no devuelve un número entero al sistema operativo mediante una sentencia return, entonces nuestro programa devolverá un número desconocido. Moraleja: es una buena idea incluir un return al final de la función main(). Generalmente, la devolución de un 0 indica al sistema operativo que el programa a finalizado sin problemas, mientras que cualquier otro valor señala que se ha producido algún error. Por lo tanto, la forma habitual de la función main() será: int main(void) { ...instrucciones del algoritmo principal... return 0; } Observa que main() no tiene argumentos, por lo que aparece el identificador void entre paréntesis en la declaración. También se pueden utilizar argumentos en main(), pero eso es algo que trataremos en otro momento. 5.5 Prototipos de funciones En C no es necesario escribir las funciones (subalgoritmos) antes de su primera invocación. El mecanismo de compilación y enlace de C permite, de hecho, que las funciones puedan estar físicamente en un archivo distinto del lugar desde el que se invocan. En la práctica, esto plantea un problema: C no tiene forma de saber si la llamada a una función se hace correctamente, es decir, si se le pasan los argumentos debidos y con el tipo correcto, ni si el resutado devuelto es asignado a una variable del tipo adecuado. Para conseguir que C realice esas comprobaciones se utilizan los prototipos de función. Un prototipo de función es la declaración de una función. Consiste, simplemente, en la primera línea del código la función. El prototipo debe aparecer antes de que la función se invoque por primera vez, aunque el código completo de la función esté en otra parte. Los prototipos permiten al compilador comprobar que los argumentos de la función coinciden en tipo y número con los de la invocación de la misma, y que el tipo devuelto es el correcto. Los prototipos suelen aparecer al principio del programa, antes de la función main(). Observa, en el siguiente ejemplo, que el prototipo de la función calcular_area() se coloca delante de main(). Sin embargo, el código concreto de esta función no aparece hasta después (incluso podría estar situado en otro archivo diferente): float calcular_area (float base, float altura); // Prototipo de la función int main() // Algoritmo principal { ...instrucciones... area = calcular_area (x,y); ...más instrucciones... return 0; } float calcular_area(float base, float altura) // Código de la función { ... instrucciones... } Cuando se vayan a usar funciones de librería, como fabs() (valor absoluto), sqrt() (raíz cuadrada) o cualquier otra, hay que escribir sus prototipos antes de la función main(). Sin embargo, como estas funciones no las hemos escrito nosotros, desconocemos cuales son sus prototipos. En C se soluciona este problema con los archivos de cabecera, que son archivos proporcionados con el compilador de C que incluyen en su interior los prototipos de las funciones de librería, entre otras cosas. Como funciones de librería hay muchas, también hay muchos archivos de cabecera. Por ejemplo, el archivo math.h tiene los prototipos de todas las funciones matemáticas. Todos los archivos de cabecera tienen la extensión .h en su nombre (h de \"header\"). Para incluir un archivo de cabecera en nuestro programa se utiliza #include, que no es exactamente una instrucción de C, sino una directiva de compilación. Más adelante veremos qué significa eso. Ya hemos visto otra directiva de compilación: #define, que usábamos para definir constantes. Las directivas de compilación se detallan en uno de los apéndices de este libro, y puedes ir ahora allí si quieres ampliar esta información. Por ejemplo, esta línea de código sirve para incluir todos los prototipos de las funciones de librería matemática en nuestro programa: #include Al final del tema, en el apéndice dedicada a las funciones ANSI, encontrarás una lista con las funciones utilizadas más habitualmente y sus correspondientes archivos de cabecera. Cada vez que necesites usar una de esas funciones en un programa, debes escribir al principio del mismo el #include del archivo de cabecera para disponer así del prototipo. 5.6 Estructura general de un programa en C Visto todo esto, ya estamos en condiciones de echar un vistazo a cual será el aspecto de (casi) todos los programas que escribamos en C. Todo programa C, desde el más pequeño hasta el más complejo, tiene un programa principal ubicado en la función main(). Además, por encima de main() deben aparecer los prototipos de funciones (y esto implica a los archivos de cabecera, si se utilizan funciones de librería) y las variables y constantes globales. Por debajo de main() encontraremos el código de las funciones de usuario. Por lo tanto, la estructura habitual de nuestros programas en C debería ser esta: /* Comentario inicial: nombre del programa, del programador, fecha, etc */ /* Archivos de cabecera (prototipos de funciones de librería) */ #include #include /* Prototipos de funciones escritas por nosotros */ float función1 (argumentos); float función2 (argumentos); /* Variables globales */ int variable_global1; char variable_global2; /* Algoritmo principal */ int main(void) { /* Variables locales del algoritmo principal */ int a, b; float x, y; ..... /* Instrucciones del algoritmo principal */ ... función1(argumentos); ... función2(argumentos); ... return 0; } /* Código completo de las funciones escritas por nosotros */ float función1 (argumentos) { /* Variables locales e instrucciones de este subalgoritmo */ } float función2 (argumentos) { /* Variables locales e instrucciones de este subalgoritmo */ } 6 Entrada y salida estándar La entrada y salida de datos en C, es decir, la traducción de las instrucciones leer() y escribir() de pseudocódigo, es uno de los aspectos más difíciles (y criticables) de C. El estándar ANSI C dispone de muchas funciones para hacer las entradas y salidas de datos. En concreto, dispone de un subconjunto de ellas para hacer la entrada y salida por consola, es decir, por teclado y pantalla. Podemos clasificar estas funciones de E/S en dos grupos: • Funciones de E/S simples: getchar(), putchar(), gets(), puts() • Funciones de E/S con formato: printf(), scanf() Las más utilizadas y versátiles son sin duda las segundas, así que nos detendremos más en ellas. 6.1 E/S con formato Salida de datos: printf() La función printf() (de \"print\" = imprimir y \"f\" = formato) sirve para escribir datos en el dispositivo de salida estándar (generalmente la pantalla) con un formato determinado por el programador. La forma general de utilizarla es la siguiente: printf(cadena_de_formato, datos); El prototipo de printf() se encuentra en el archivo de cabecera stdio.h (de \"std\" = standard e \"io\" = input/output, es decir, entrada/salida; por lo tanto, \"stdio\" es un acrónimo de \"entrada/salida estándar\") El primer argumento, la cadena_de_formato, especifica el modo en el que se deben mostrar los datos que aparecen a continuación. Esta cadena se compone de una serie de códigos de formato que indican a C qué tipo de datos son los que se desean imprimir. Todos los códigos están precedidos del símbolo de porcentaje (\"%\"). Por ejemplo, el código \"%i\" indica a la función que se desea escribir un número de tipo int, y el código \"%f\", que se desea escribir un número real de tipo float. La forma más simple de utilizar printf() es: int a; a = 5; printf(\"%i\", a); Esto escribirá el valor de la variable entera a en la pantalla, es decir, 5. Fíjate que el primer argumento de printf() es una cadena (y, por lo tanto, se escribe entre comillas) cuyo contenido es el código del tipo de dato que se pretende escribir. El segundo argumento es el dato mismo. En una sola instrucción printf() pueden escribirse varios datos. Por ejemplo: int a; float x; a = 5; x = 10.33; printf(\"%i%f\", a, x); Observa detenidamente la cadena de formato: primero aparece \"%i\" y luego \"%f\". Esto indica que el primer dato que debe imprimirse es un entero, y el segundo, un real. Después, aparecen esos datos separados por comas y exactamente en el mismo orden que en la cadena de formato: primero a (la variable entera) y luego x (la variable real). El resultado será que en la pantalla se escribirán los números 5 y 10.33. Los códigos de formato que se pueden utilizar en printf() son: Código Tipo del dato que se escribe %c Carácter %d Número entero %i Número entero %e Número real con notación científica %f Número real %g Usar %e o %f, el más corto %o Número octal %s Cadena de caracteres %u Entero sin signo %x Número hexadecimal %p Puntero Algunos de estos códigos sirven para imprimir tipos de datos que aún no conocemos, pero que iremos viendo en las siguientes páginas. Hay códigos que admiten modificadores. Por ejemplo: • Los códigos numéricos \"%i\", \"%d\", \"%u\" (para números enteros) y \"%f\", \"%e\" y \"%g\" (para números reales), permiten insertar modificadores de longitud \"l\" (longitud doble) y \"h\" (longitud corta). Así, por ejemplo, \"%ld\" indica que se va a imprimir un entero de longitud doble (long int); \"%hu\" sirve para enteros cortos sin signo (unsigned short int); \"%lf\" indica que se imprimirá un número real de longitud doble (double), etc. • El código \"%f\" (números reales) se pueden usar con un modificador de posiciones decimales que se desean mostrar. Por ejemplo, con \"%10.4f\" obligamos a que se impriman diez dígitos a la izquierda de la coma decimal y cuatro a la derecha. La escritura se ajusta a la derecha. Para ajustarla a la izquierda se utiliza el modificador \"-\", de esta forma: \"%-10.4f\" • El código \"%s\" (cadenas de caracteres) se puede combinar con un especificador de longitud máxima y mínima de la cadena. Por ejemplo, \"%4.8s\" escribe una cadena de al menos cuatro caracteres y no más de ocho. Si la cadena tiene más, se pierden los que excedan de ocho. También se puede utilizar el modificador \"-\" para alinear el texto a la izquierda. Además de los códigos de formato, en la cadena de formato puede aparecer cualquier texto entremezclado con los códigos. A la hora de escribir en la pantalla, los códigos serán sustituidos por los datos correspondientes. Por ejemplo: int a; float x; a = 5; x = 10.33; printf(\"El número entero es %i y el real es %f\", a, x); Lo que aparecerá en la pantalla al ejecutar este fragmento de código será: El número entero es 5 y el real es 10.33 Una última observación sobre printf(). Hay ciertos caracteres que no son directamente imprimibles desde el teclado. Uno de ellos es el salto de línea. Para poder ordenar a printf() que escriba un salto de línea (o cualquier otro carácter no imprimible) se utilizan los códigos de barra invertida, que con códigos especiales precedidos del carácter \"\\\". En concreto, el carácter \"salto de línea\" se indica con el código \"\\n\". Observa las diferencias entre estos dos bloques de instrucciones para intentar comprender la importancia del salto de línea: int a; a = 5; printf(\"La variable a vale %i\", a); a = 14; printf(\"La variable a vale %i\", a); El resultado en la pantalla de la ejecución de estas instrucciones es: La variable a vale 5La variable a vale 14 Veamos el mismo ejemplo usando el código del salto de línea (\\n): int a; a = 5; printf(\"La variable a vale %i\\n\", a); a = 14; printf(\"La variable a vale %i\", a); El resultado en la pantalla será: La variable a vale 5 La variable a vale 14 Entrada de datos: scanf() La función scanf() es, en muchos sentidos, la inversa de printf(). Puede leer desde el dispositivo de entrada estándar (normalmente el teclado) datos de cualquier tipo de los manejados por el compilador, convirtiéndolos al formato interno apropiado. Funciona de manera análoga a printf(), por lo que su sintaxis es: scanf(cadena_de_formato, datos); El prototipo de scanf() se encuentra en el archivo de cabecera stdio.h (de \"std\" = standard e \"io\" = input/output, es decir, entrada/salida) La cadena_de_formato tiene la misma composición que la de printf(). Los datos son las variables donde se desea almacenar el dato o datos leidos desde el teclado. ¡Cuidado! Con los tipos simples, es necesario utilizar el operador & delante del nombre de la variable, porque esa variable se pasa por referencia a scanf() para que ésta pueda modificarla. Por ejemplo: int a, b; float x; scanf(\"%d\", &a); scanf(\"%d%f\", &b, &x); La primera llamada a scanf() sirve para leer un número entero desde teclado y almacenarlo en la variable a. La segunda llamada lee dos números: el primero, entero, que se almacena en b; y, el segundo, real, que se almacena en x. La función scanf() tiene alguna otra funcionalidad añadida para el manejo de cadenas de caracteres que ya veremos en su momento. Ejemplo de uso de scanf() y printf() Debido a la relativa complejidad de estas funciones de entrada y salida, vamos a presentar un pequeño ejemplo de traducción de pseudocódigo a C. Se trata de un algoritmo que lee dos números enteros, A y B. Si A es mayor que B los resta, y en otro caso los suma. Observa detenidamente la correspondencia entre cada pareja de instrucciones, especialmente las de entrada y salida. Pseudocódigo Traducción a C algoritmo suma_y_resta variables a y b son enteros inicio escribir (\"Introduzca dos números enteros\") leer(a, b) si (a int main() { int a, b; printf (\"Introduzca dos números enteros\\n\"); scanf(\"%d%d\", &a, &b); if (a < b) printf(\"La suma de %d y %d es: %d\", a, b, a+b); else printf(\"La resta de %d menos %d es: %d\", a, b, a–b); return 0; } 6.2 E/S simple por consola Técnicamente, con printf() y scanf() es posible escribir y leer cualquier tipo de datos desde cualquier dispositivo de salida o entrada, no solo la pantalla y el teclado, como de hecho comprobaremos cuando estudiemos los ficheros. En la práctica, aunque printf() resulta bastante efectiva y versátil, scanf() puede darte muchos dolores de cabeza. Para hacerte una idea, sólo tienes que probar a hacer un scanf() de un número entero e inmediatamente después otro scanf() de una cadena de caracteres. El segundo scanf() fallará. La razón es bastante rocambolesca: el flujo de entrada no consumirá el carácter de retorno de carro al leer el número entero, por lo que dicho carácter se adjudicará al segundo scanf() automáticamente. Por suerte, existe otro grupo de funciones en ANSI C específicamente diseñadas para hacer la E/S por consola, es decir, por teclado y pantalla, de manera más simple. Las resumimos en el siguiente cuadro. Los prototipos de estas funciones se encuentran en el archivo de cabecera stdio.h (de \"std\" = standard e \"io\" = input/output, es decir, \"entrada/salida\") Función Utilidad Ejemplo getchar() Espera a que se pulse una tecla seguida de INTRO y devuelve su valor. Muestra el eco en la pantalla, es decir, la tecla pulsada aparece en la pantalla. putchar(carácter) Escribe un carácter en la pantalla char car; car = getchar(); printf(\"Tecla pulsada:\\n\"); putchar(car); gets(cadena) Lee del teclado una cadena de caracteres seguida de INTRO. puts(cadena) Escribe una cadena de caracteres en la pantalla char cadena[50]; gets(cadena); printf(\"Cadena tecleada:\\n\"); puts(cadena); Para evitar los problemas que a menudo causa scanf(), podemos recurrir a gets() para leer las cadenas de caracteres. Si necesitamos leer un número, podemos usar gets() y luego convertir la cadena a un tipo de dato numérico con las funciones de conversión atoi() y atof(), como se muestra en el siguiente ejemplo: char cadena[50]; int a; float x; gets(cadena); // Leemos una cadena de caracteres a = atoi(cadena); // Convertimos la cadena en un número entero x = atof(cadena); // Convertimos la cadena en un número real Las funciones de conversión atoi() y atof() tratarán de convertir la cadena en un número, si ello es posible (es decir, si la cadena realmente contiene números). Estas funciones, junto con muchas otras, se describen en el apéndice I de este capítulo. Usar la combinación de gets() con atoi() o atof() es más costoso que utilizar scanf(). Primero, porque necesitamos una variable auxiliar de tipo cadena. Y, segundo, porque gets() es una función peligrosa: si se teclean más caracteres de los que caben en la cadena, el resultado es imprevisible (a menudo el programa se cuelga). Esto también tiene solución utilizando en su lugar la función fgets(). Tal vez pienses que resulta demasiado complicado hacer algo muy simple como una entrada de datos por teclado. Tienes razón. Pero ten en cuenta dos cosas: las entradas de datos nunca son simples (son el punto donde el usuario interacciona con más libertad con el programa, y los usuarios humanos tendemos a hacer cosas impredecibles y complicadas), y C es un lenguaje de nivel intermedio, por lo que muchas tareas de alto nivel, simplemente, no las resolverá por nosotros. En ese sentido, C requiere del programador prestar atención a ciertos detalles que podría obviar en otros lenguajes. Es por esto, entre otras cosas, por las que C tiene exaltados detractores pero también incondicionales entusiastas. Por último, mencionaremos que los compiladores de Borland tienen dos variaciones muy útiles de la función getchar() llamadas getche() y getch(). Estas funciones, no definidas en el estándar ANSI de C, son como getchar() pero sin necesidad de pulsar INTRO detrás del carácter. La primera muestra el eco, es decir, escribe en la pantalla la tecla pulsada, y la segunda no. Los prototipos de estas funciones se encuentran en conio.h (de \"con\" = consola e \"io\" = input/output) 7 Flujo de trabajo programando con lenguaje C Como vimos más arriba, el ciclo de vida de desarrollo del software consta de una serie de etapas. En esta parte del libro nos estamos centrando a la etapa de implementación o codificación del software, ya que estamos aprendiendo un lenguaje de programación concreto. Antes de continuar profundizando en el lenguaje, vamos a hacer un pequeño paréntesis para especificar cuál suele ser el flujo de trabajo en el desarrollo de programas con lenguaje C. Cuando se trabaja con C, la implementación de un programa suele dividirse en varias subfases: edición, compilación, enlace y depuración. Pasamos a describirlas brevemente a continuación. 7.1 Edición del código fuente Editar consiste en escribir el código fuente del programa en el lenguaje seleccionado, en nuestro caso C. Para escribir el código nos puede servir cualquier procesador de textos que permita guardar el documento en forma de texto ASCII plano (sin códigos de control y formato propios de los procesadores avanzados, como MS Word). Existen multitud de procesadores de texto plano para programar en lenguaje C. Solo tienes que hacer una pequeña búsqueda en internet para encontrar una pléyade de candidatos. La ventaja de estos procesadores es que resaltan, en diferentes colores y tipografías, las palabras clave, las funciones, las cadenas, los comentarios, etc, haciendo de este modo mucho más legible el código fuente. Necesitarás probar unos cuantos antes de decidir cuál es el que más te gusta. Además, es habitual que los compiladores de C incluyan también un editor. Por ejemplo, los compiladores de Borland (como Turbo C/C++, Borland C/C++ o C++ Builder) poseen un entorno integrado de desarrollo, que es un programa que une al editor de texto, al compilador y al depurador en una sola aplicación controlada por un único interfaz, lo cual facilita mucho el trabajo. Estos editores con funcionalidades añadidas suelen denominarse IDEs (Integrated Development Environment, entorno integrado de desarrollo), y nos referiremos a ellos con más detalle en los apéndices de este libro. Mi recomendación es que, al menos al principio, intentes usar un editor simple, que no incluya el compilador. Esto te obligará a hacer un trabajo adicional al tener que compilar y enlazar manualmente tu programa, pero es la mejor forma de comprender realmente en qué consiste la compilación y el enlace. En el futuro, esta comprensión te puede ayudar a resolver muchos errores de compilación y enlace. En cualquier caso, las recomendaciones que hemos de seguir durante la edición del código fuente son: • No empezar a teclear código sin haber entendido bien el problema que se nos plantea. Si éste es complejo, es imprescindible plantear antes su descomposición modular en papel, resolviendo los módulos con pseudocódigo. • Recuerda: comenzar a teclear a lo loco y sin pensar antes la solución detenidamente es la manera más segura de tardar el mayor tiempo posible en desarrollar un programa que, además, no funcione bien. • Realizar un diseño modular previo del programa. Recuerda que un módulo de más de 30 ó 40 líneas (aproximadamente) empieza a ser demasiado largo. • Evitar las variables globales. • Elegir bien el nombre de los identificadores (variables, constantes, funciones...). Que sean significativos y no excesivamente largos. • Identar el texto, es decir, dejar las sangrías necesarias para facilitar su comprensión. • Usar espacios y líneas en blanco siempre que se considere que facilita la lectura. • Ser generosos documentando el código fuente. Mejor que sobren comentarios que no que falten. • Guardar el código fuente en archivos de texto cuya extensión sea \".c\" (por ejemplo: \"ejercicio.c\") 7.2 Compilación El proceso de compilación, como sabes, consiste en que un programa, llamado compilador, traduzca el código fuente en lenguaje C a código binario. La compilación, por lo tanto, no es más que una traducción. El resultado de la compilación es el mismo programa traducido a código binario. Como el programa fuente estaba almacenado en un archivo con extensión .C, el compilador suele guardar el programa objeto en otro archivo con el mismo nombre y extensión .OBJ. Los programas cortos se guardan en un único archivo fuente que se traducirá a un único archivo objeto. Pero cuando los programas crecen, es habitual distribuir el código fuente en varios archivos con el objetivo de manipularlo mejor. Los compiladores de C usan compilación separada. Esto significa que, si un programa largo está escrito en varios archivos fuente, no es necesario compilarlos todos cada vez que se modifica algo. Basta con volver a compilar el archivo modificado. Por eso, dividir un programa fuente largo en varios archivos más cortos también sirve para mejorar los tiempos de compilación. Cuando tenemos varios archivos fuente es normal que existan dependencias entre ellos. Por ejemplo, cuando en un archivo A1 se utiliza (con la directiva #include) un archivo de cabecera A2. Si modificamos el archivo A2 es necesario volver a compilar el archivo A1, aunque A1 no haya sido modificado en absoluto. Se dice entonces que existe una dependencia entre los archivos A1 y A2. Controlar las dependencias es un trabajo tedioso y propenso a errores. Por fortuna, los compiladores se encargan de controlarlas por sí mismos. Así que no te extrañes si, al volver a compilar un archivo fuente después de modificarlo, se compilan automáticamente algunos otros archivos, aunque no los hayas tocado. El control de las dependencias lo puede realizar el compilador de manera automática o semiautomática (mediante archivos de dependencias o makefiles escritos por el programador), como veremos en los apéndices. Los compiladores, en fin, son programas muy complejos que, además, tienen multitud de opciones de compilación. Algunas de esas opciones también las veremos en los apéndices del libro. Allí encontrarás información sobre cómo compilar tus programas con Mingw, un compilador de C/C++ para Windows, y con gcc, el compilador nativo de Linux. 7.3 Enlace (link) Cuando existen varios programas objeto es necesario combinarlos todos para dar lugar al programa ejecutable definitivo. Este proceso se denomina enlace. El código objeto de las funciones de librería de C se encuentra almacenado en varios archivos (cuya extensión es .LIB) situados en ubicaciones conocidas por el enlazador. De este modo, el código objeto de las funciones de librería que hayamos utilizado en nuestro programa puede unirse con el código objeto del programa durante en enlace, generándose el programa ejecutable. Por lo tanto, es necesario hacer el enlace cuando el programa se encuentra distribuido en varios archivos, o cuando dentro del programa se utilizan funciones de librería. Esto quiere decir que, en la práctica, el enlace hay que hacerlo siempre. El enlazador o linker, es decir, el programa encargado de hacer el enlace, es en realidad diferente del compilador, que sólo hace la traducción. Sin embargo, la mayoría de los compiladores de C lanzan automáticamente el enlazador al finalizar la compilación para que el programador no tenga que hacerlo. El enlace de nuestro código objeto con las funciones de librería puede hacerse de dos maneras: • Enlace estático. Consiste en unir durante el enlace el código objeto de las librerías con el código del programa, generando así el ejecutable. El programa ejecutable crece notablemente de tamaño respecto de los archivos objeto, ya que incorpora el código de todas las funciones de las librerías. El enlace estático es el que normalmente se utiliza a menos que indiquemos otra cosa. • Enlace dinámico. El código de las librerías no se une al del programa, sino que se busca durante la ejecución, únicamente cuando es requerido. El enlace dinámico produce, por lo tanto, ejecuciones más lentas, ya que cada vez que se use una función de librería dinámica es necesario buscar el archivo en el que se encuentra y ejecutar su código. Además, pueden producirse errores de enlace durante la ejecución del programa. Sin embargo, el enlace dinámico tiene las ventajas de reducir el tamaño del archivo ejecutable y permitir la compartición de librerías entre diferentes aplicaciones. 7.4 Depuración La depuración del programa consiste en localizar y corregir los errores que se hayan podido producir durante el desarrollo. El objetivo es conseguir un programa que funcione lo más correctamente posible, aunque hay que tener presente que ningún programa complejo está libre de errores al 100% Los errores pueden ser de tres tipos: • Errores en tiempo de compilación. Se producen al traducir el código fuente a código objeto. El compilador los detecta y marca en qué línea se han producido, y de qué tipo son, por lo que son relativamente fáciles de corregir. Los errores de compilación más frecuentes son: • Errores sintácticos: escribir mal alguna instrucción o algún identificador, u olvidarnos del punto y coma que debe terminar cada instrucción. • Errores de tipos: intentar asignar a una variable de cierto tipo un valor de otro tipo incompatible, o invocar a una función con argumentos de tipo equivocado. Recuerda que C puede hacer conversiones de tipo automáticas, por lo que estos errores pueden quedar enmascarados. • Errores de identificadores no reconocidos: ocurren cuando se intenta utilizar una variable o una constante que no ha sido declarada, o cuyo ámbito no llega al lugar donde se intenta utilizar. • Avisos. Además de los errores, el compilador puede dar avisos (warnings) en lugares donde potencialmente puede existir un error de compilación. Es conveniente revisar todos los avisos y tratar de corregirlos antes de continuar con la ejecución. • Errores en tiempo de enlace. Cuando el compilador termina la traducción se produce el enlace de todos los archivos objeto. En este momento se resuelven todas las llamadas a funciones, de modo que si alguna función no está presente en el conjunto de archivos objeto, el enlazador fallará y explicará la causa del error. • Errores en tiempo de ejecución. Si la compilación y el enlace terminan sin novedad, se genera un archivo ejecutable (con extensión .EXE en sistemas Windows). Es el momento de comprobar que el programa realmente hace lo que se espera que haga. Para ello hay que probarlo con diversos conjuntos de datos de entrada; la elaboración de estos juegos de pruebas es una técnica que excede nuestras pretensiones. Los errores que surgen en tiempo de ejecución son los más complicados de corregir, ya que muchas veces no está clara la causa del error. En el peor de los casos, puede ser necesario rediseñar la aplicación por completo. Simplificando mucho, podemos encontrarnos con estos errores en tiempo de ejecución: • Errores lógicos. Se producen cuando alguna condición lógica está mal planteada. Entonces, el flujo del programa puede ir por la rama \"si_no\" cuando debería ir por la rama \"si\", o puede salirse de un bucle cuando debería repetir una vez más, o entrar en un bucle infinito, etc. • Errores aritméticos. Ocurren cuando una variable se desborda (overflow), o se intenta una operación de división entre cero, o alguna operación aritmética está mal planteada. • Errores de punteros. Los punteros son herramientas muy potentes que permiten la manipulación dinámica de la memoria, pero también conllevan grandes riesgos porque un puntero \"descontrolado\" puede hacer auténticas locuras en la memoria del ordenador, hasta el punto de colgar sistemas poco fiables (Windows 9x) • Errores de conversión automática de tipos. Se producen cuando C realiza una conversión automática que no teníamos prevista. Entonces el dato puede cambiar y dar al traste con la lógica del programa. • Errores de diseño. Ocurren cuando el programa no está bien diseñado y realiza tareas diferentes de las que se pretendían. Son los peores errores, porque obligarán a modificar una parte (o la totalidad) del trabajo realizado, debiendo, en ocasiones, volver a las primeras fases del ciclo de vida para repetir todo el proceso. Estos y otros errores en tiempo de ejecución pueden manifestarse con distintas frecuencias: • Siempre que se ejecuta el programa: son los más fáciles de localizar y corregir. • Solo cuando se introducen determinados datos de entrada: puede ser complicado dar con la secuencia de datos de entrada que provocan el error, pero una vez que la encontramos, puede localizarse con facilidad. • Al azar: algunas veces, los programas fallan sin motivo aparente, cuando han estado funcionando en el pasado con el mismo conjunto de datos. Son los errores más difíciles de localizar, porque ni siquiera se sabe bajo qué circunstancias ocurren. El depurador El depurador es un programa independiente del editor, el compilador y el enlazador. La mayoría de los compiladores disponen de uno y, además, suele estar integrado con los otros tres, de modo que desde el editor se puede lanzar cualquiera de los otros. El depurador es una herramienta fundamental para localizar y corregir errores en tiempo de ejecución. Para que la depuración sea cómoda, hay que activar una opción específica del compilador que permita hacer la depuración sobre el código fuente. Si no se activa, la depuración se hará sobre el código binario o, como mínimo, será imposible acceder a los identificadores de variables, lo cual complica mucho la depuración. Muchos compiladores tienen esta opción activada por defecto. Cada depurador tiene sus propias opciones y características, pero todos suelen coincidir en varios aspectos: • Permiten ejecutar paso a paso cada instrucción del programa, deteniéndose antes de ejecutar la siguiente para permitirnos ver el estado de las variables o de los dispositivos de E/S. • Permiten ver y manipular el contenido de las variables en cualquier punto del programa. • Permiten ver y manipular la estructura de la memoria asignada al programa y de los registros del microprocesador. • Permiten insertar puntos de ruptura (breakpoints), es decir, puntos donde la ejecución se detendrá momentáneamente para que hagamos alguna comprobación de las anteriormente expuestas. Haciendo correcto uso de estas posibilidades, podemos localizar rápidamente cualquier error en tiempo de ejecución y afrontar la tarea de corregirlo. Si quieres ver ejemplos concretos de depuradores para Windows y para Linux, puedes consultar los apéndices del libro en este momento. ",
    "url": "/docs/prog-y-3d/_site/orientacion-a-objetos/",
    "relUrl": "/orientacion-a-objetos/"
  },"9": {
    "doc": "7. Entornos integrados de desarrollo",
    "title": "7. Entornos integrados de desarrollo",
    "content": "# 7. Entornos integrados de desarrollo {: .no_toc } - TOC {:toc} Entornos integrados de desarrollo. Depuración. Ciclo de vida del software. Trabajo en equipo y mejora continua. Control de versiones. Metodologías ágiles: Scrum. ",
    "url": "/docs/prog-y-3d/_site/entornos-integrados-de-desarrollo/",
    "relUrl": "/entornos-integrados-de-desarrollo/"
  },"10": {
    "doc": "8. Bases de datos",
    "title": "8. Bases de datos",
    "content": "# 8. Bases de datos {: .no_toc } - TOC {:toc} Almacenamiento de la información. Ficheros. Bases de datos relacionales. Sistemas gestores de bases de datos. Diseño conceptual. Diagramas entidad-relación. Normalización hasta 3FN y FNBC. Definición y manipulación. ",
    "url": "/docs/prog-y-3d/_site/bases-de-datos/",
    "relUrl": "/bases-de-datos/"
  },"11": {
    "doc": "9. El lenguaje SQL",
    "title": "9. El lenguaje SQL",
    "content": "# 9. El lenguaje SQL {: .no_toc } - TOC {:toc} Comandos básicos de SQL: DDL, DML y DCL. ",
    "url": "/docs/prog-y-3d/_site/lenguaje-sql/",
    "relUrl": "/lenguaje-sql/"
  },"12": {
    "doc": "10. Seguridad y privacidad",
    "title": "10. Seguridad y privacidad",
    "content": "# 10. Seguridad y privacidad {: .no_toc } - TOC {:toc} Seguridad y privacidad. Acceso a la información de las bases de datos. ",
    "url": "/docs/prog-y-3d/_site/seguridad-y-privacidad/",
    "relUrl": "/seguridad-y-privacidad/"
  },"13": {
    "doc": "11. Tecnologías de impresión 3D",
    "title": "11. Tecnologías de impresión 3D",
    "content": "# 11. Tecnologías de impresión 3D {: .no_toc } - TOC {:toc} Tecnologías de impresión 3D. Utilidad y posibilidades del diseño 3D. Impresión 3D por FDM. Impresoras 3D por FDM. Partes, funcionamiento y mantenimiento básico. ",
    "url": "/docs/prog-y-3d/_site/tecnologias-de-impresion-3d/",
    "relUrl": "/tecnologias-de-impresion-3d/"
  },"14": {
    "doc": "12. Modelado e impresión 3D",
    "title": "12. Modelado e impresión 3D",
    "content": "# 12. Modelado e impresión 3D {: .no_toc } - TOC {:toc} Modelado e impresión 3D. Software para diseño 3D y software para slicing (laminado). Creación e impresión de figuras básicas. Transformación, rotación y unión de figuras básicas. Formatos para impresión 3D. Pruebas de impresión. ",
    "url": "/docs/prog-y-3d/_site/modelado-e-impresion-3d/",
    "relUrl": "/modelado-e-impresion-3d/"
  },"15": {
    "doc": "About",
    "title": "About",
    "content": "Estos apuntes han sido elaborados por Antonio Zapata Sierra y Alfredo Moreno Vozmediano, del Departamento de Informática del IES Celia Viñas de Almería, y se publican aquí con licencia [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/), lo que quiere decir que eres libre de usar este material, copiarlo, distribuirlo y modificarlo siempre que el resultado de todo eso mantenga la misma licencia y cites la autoría original. Algunos fragmentos (pocos) están tomados y adaptados de otras fuentes. Cuando eso ocurre, lo indicamos claramente en el texto. Debes atenerte a la licencia de los sitios web de origen para esos fragmentos. ",
    "url": "/docs/prog-y-3d/_site/about/",
    "relUrl": "/about/"
  },"16": {
    "doc": "Introd. a la prog. y al diseño 3D",
    "title": "Introd. a la prog. y al diseño 3D",
    "content": "Esta es la documentación (apuntes) de ***Introducción a la programación y al diseño 3D***, optativa de 2º de Bachillerato ofertada por el IES Celia Viñas de Almería (España). 1. TOC {:toc} ",
    "url": "/docs/prog-y-3d/_site/",
    "relUrl": "/"
  }
}
