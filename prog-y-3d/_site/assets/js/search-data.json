{"0": {
    "doc": "0. Presentación de la asignatura",
    "title": "0. Presentación de la asignatura",
    "content": "# 0. Presentación de la asignatura {: .no_toc } - TOC {:toc} ## 0.1. Contextualización y horario La asignatura **Introducción a la programación y al diseño 3D** se imparte como optativa en segundo curso de Bachillerato en el IES Celia Viñas de Almería y tiene una duración de 72 horas (2 horas semanales). El profesor encargado de impartirla durante el curso 2021-2022 es **Alfredo Moreno Vozmediano**, miembro del Departamento de Informática. Salvo cambio de criterio de la dirección del centro, durante el curso actual, el **horario** de clases será el siguiente: * Miércoles de 9:05 a 10:05 horas (aula 19). * Jueves de 12:35 a 13:35 horas (aula ?). ## 0.2. Objetivos Los objetivos de esta asignatura son los siguientes: 1. Comprender el impacto del pensamiento computacional en la sociedad actual. 2. Producir programas informáticos plenamente funcionales. 3. Integrarse en un equipo de desarrollo de software que sea capaz de afrontar proyectos de cierta envergadura. 4. Desarrollar la capacidad de abstracción. 5. Emplear la creatividad en el desarrollo de aplicaciones informáticas para resolver problemas y fomentar la capacidad de expresión personal. 6. Recopilar, almacenar y procesar datos con el objetivo de encontrar patrones, descubrir conexiones y resolver problemas. 7. Analizar cómo la representación, el almacenamiento, la seguridad y la transmisión de datos requiere de manipulación computacional, y comprender los riesgos de seguridad y privacidad existentes cuando se trata de información personal. 8. Conocer los fundamentos y aplicaciones del Diseño Asistido por Ordenador y capacitar para el diseño de objetos bidimensionales y tridimensionales sencillos. 9. Fomentar el trabajo en equipo y la comunicación interpersonal. ## 0.3. Contenido Los contenidos de la asignatura se dividen en **cuatro bloques y 12 unidades didácticas**. Los resumimos a continuación. **Bloque 1. Representación digital y pensamiento computacional** * UD1. Características, ejemplos e importancia del pensamiento computacional. * UD2. Representación de la información. Bits, bytes, múltiplos y submúltiplos. Almacenamiento, transmisión y tratamiento de la información binaria. Representaciones octal y hexadecimal. ASCII y Unicode. **Bloque 2. Introducción a la programación** * UD3. Lenguajes de programación. Tipos de lenguajes. Estructura de un programa informático. Tipos básicos de datos. Constantes y variables. Operadores y expresiones. Comentarios. Pseudocódigo y diagramas de flujo. Estructuras de control: secuencial, condicional e iterativa. * UD4. Estructuras de datos. Funciones y bibliotecas de funciones. Reutilización de código. Facilidades para la entrada y salida de datos de usuario. Manipulación de archivos. * UD5. Orientación a objetos. Clases, objetos y constructores. Herencia. Subclases y superclases. Polimorfismo y sobrecarga. Encapsulamiento y ocultación. * UD6. Entornos integrados de desarrollo. Depuración. Ciclo de vida del software. Trabajo en equipo y mejora continua. Control de versiones. Metodologías ágiles: Scrum. * UD7. Lenguajes de programación reales. Java, Python o PHP. **Bloque 3. Datos e Información** * UD8. Almacenamiento de la información. Ficheros. Bases de datos relacionales. Sistemas gestores de bases de datos. Diseño conceptual. Diagramas entidad-relación. Normalización hasta 3FN y FNBC. Definición y manipulación. * UD9. Comandos básicos de SQL: DDL, DML y DCL. * UD10. Seguridad y privacidad. Acceso a los información de las bases de datos. **Bloque 4. Diseño 3D** * UD11. Tecnologías de impresión 3D. Utilidad y posibilidades del diseño 3D. Impresión 3D por FDM. Impresoras 3D por FDM. Partes, funcionamiento y mantenimiento básico. * UD12. Modelado e impresión 3D. Software para diseño 3D y software para slicing (laminado). Creación e impresión de figuras básicas. Transformación, rotación y unión de figuras básicas. Formatos para impresión 3D. Pruebas de impresión. ## 0.4. Evaluación y calificación A lo largo de curso se evaluarán los siguientes elementos: * **Observación del trabajo diario** en el aula (calificación de 1 a 10). * **Actividades, prácticas y proyectos** (calificación de 1 a 10). * **Test de conocimientos** (exámenes) (calificación de 1 a 10). Para aprobar cada **evaluación trimestral**, es necesario **obtener al menos un 5** en cada uno de los apartados anteriores. La nota trimestral se calculará así: * Observación directa y trabajo diario: 30% * Prácticas y proyectos: 40% * Tests de conocimientos: 30% La **nota final del curso** se obtendrá mediante una media aritmética de las calificaciones obtenidas en cada trimestre. Se hará un examen teórico-práctico final, con actividades de un nivel similar a las propuestas en las prácticas y proyectos, para las personas que no hayan superado alguna de las evaluaciones trimestrales. Asimismo, habrá una recuperación en septiembre con la misma naturaleza y que abarcará toda la materia impartida durante el curso. ",
    "url": "/docs/prog-y-3d/_site/presentacion/",
    "relUrl": "/presentacion/"
  },"1": {
    "doc": "1. Pensamiento computacional",
    "title": "1. Pensamiento computacional",
    "content": "# 1. Pensamiento computacional {: .no_toc } - TOC {:toc} ## 1.1. ¿Qué es eso del pensamiento computacional? El pensamiento computacional es un proceso de **formulación y resolución de problemas que utiliza los conceptos de la ingeniería informática**. Es decir, consiste en pensar como lo haría un científico-informático cuando está frente un problema y tener la habilidad y la actitud para que nos sea útil tanto en nuestra vida personal como profesional. Hemos dicho \"vida personal\", sí. Uno de los errores más frecuentes cuando se habla de *pensamiento computacional* es considerar que solo se aplica a la Informática. El pensamiento computacional **sirve para resolver problemas cotidianos haciendo uso de las técnicas y habilidades de los programadores/as informáticos** y obtener así soluciones que pueden ser representadas mediante una serie de pasos o instrucciones. Aquí tienes un vídeo que desarrolla esta interesante idea en tres minutos: ## 1.2. Características del pensamiento computacional Según las definiciones que hemos visto en el apartado anterior, el pensamiento computacional es un proceso de resolución de problemas que incluye las siguientes características: * Reformular problemas de forma que se permita el uso de un ordenador y otras herramientas para ayudar a resolverlos. * Organizar y analizar lógicamente la información. * Representar la información a través de abstracciones como los modelos y las simulaciones. * Automatizar soluciones haciendo uso del pensamiento algorítmico (estableciendo una serie de pasos ordenados para llegar a la solución). * Identificar, analizar e implementar posibles soluciones con el objetivo de lograr la combinación más efectiva y eficiente de pasos y recursos. * Generalizar y transferir este proceso de resolución de problemas para ser capaz de resolver una gran variedad de familias de problemas. #### Ejemplo de pensamiento computacional Escribir **una receta de cocina** siguiendo unos pasos o instrucciones sería un buen primer ejemplo de aplicación para el pensamiento computacional. Por ejemplo, supongamos que queremos cocinar un *risotto* utilizando un sobre de comida preparada (para que sea más rápido). No te preocupes si no tienes ni idea de lo que es un *risotto*. En realidad, y gracias al pensamiento computacional, no necesitas saber lo que es para prepararlo, puesto que el pensamiento computacional te permite disponer de una receta. En este caso, los pasos de la receta serían más o menos estos: 1. Abrir el sobre 2. Poner a calentar el agua 3. Esperar a que el agua hierva 4. Si hierve, verter el sobre 5. Remover el contenido de la olla 6. Apagar el fuego y dejar reposar 7. Servir en el plato para \"x\" personas Si sigues esos pasos, seguro que puedes obtener algo comestible aunque no tengas ni idea de qué estás cocinando en realidad, ¿verdad? El pensamiento computacional consiste en enfrentarse a un problema (como \"cocinar un *risotto*\") y obtener una solución (como una \"receta\") que permita solucionarlo todas las veces que sean necesarias. Si la \"receta\" anterior la escribiéramos usando un lenguaje de programación, tendríamos en nuestras manos un programa de ordenador. De hecho, podemos \"escribirla\" en un lenguaje de programación por bloques gráficos, como el popular *Scratch*, y nos quedaría algo así: ![Ejemplo de receta escrita con Scratch](/docs/prog-y-3d/_site/assets/images/01-scratch.jpg) ## 1.3. El pensamiento computacional vs la programación Los términos \"pensamiento computacional\" y \"programación\" no son sinónimos. Esta es una confusión muy habitual. La programación solo es una de las posibles herramientas con la que se pone en práctica el pensamiento computacional. Por eso la programación y el pensamiento computacional comparten los mismos procesos cognitivos. La programación limita sus procesos de resolución de problemas al ámbito de la informática. Para ello, hace uso de diferentes lenguajes de programación. Puedes pedir a un ordenador que haga muchas cosas, pero no que prepare un *risotto*. Así que el pensamiento computacional puede aplicarse a problemas más allá de la informática. > ***Curiosidad**: ¿sabías que las peronas que aprenden a utilizar un lenguaje de programación muestran mayor capacidad de atención y autonomía, y obtienen en promedio mejores resultados en pruebas matemáticas, que las que no saben programar?* [Diversos estudios](https://www.redalyc.org/pdf/547/54741184011.pdf) han demostrado que, mediante los lenguajes de programación, se desarrollan ciertas habilidades cognitivas como: * El pensamiento lógico. * La creatividad. * El razonamiento abstracto. * La capacidad de resolución de problemas. Así que, si quieres orientar tu vida académica hacia las ciencias o la ingeniería, aprender a programar puede ser una herramienta muy útil para ti. Pero incluso si tus preferencias académicas van por otro camino, las rutinas de pensamiento computacional que adquirirás programando te reportarán muchos beneficios que quizá no sospechabas. ## 1.4. Algoritmos y descomposición de problemas Tanto el pensamiento computacional como la programación utilizan procesos cognitivos idénticos, como hemos dicho. Y el principal de ellos se denomina **\"Divide y vencerás\"** (*\"Divide and Conquer\"* en inglés). Es decir: descompón tu problema en problemas más pequeños, hasta que sean lo suficientente pequeños para afrontarlos. Y luego reúnelos todos como un puzle para componer la solución final. Fácil de explicar, difícil de hacer. ![Divide y vencerás](/docs/prog-y-3d/_site/assets/images/01-divide-y-venceras.jpg) El pensamiento computacional busca encontrar una \"receta\" para resolver cualquier problema computable. Esas recetas se denominan **algoritmos**. Un algoritmo, por tanto, es *un conjunto de pasos que, aplicados sistemáticamente a unos datos de entrada apropiados, resuelven un problema en un numero finito de pasos.* Nuestra receta de cocina para el *risotto* era un algoritmo. Las instrucciones para fabricar un avión de papel a partir de un folio también lo son. El motor de búsqueda de Google es otro algoritmo. Obviamente, el grado de complejidad de esos algoritmos no es comparable entre sí. Pero todos son algoritmos. Los algoritmos tienen una **entrada** (input) y una **salida** (output), y entre ambas están los pasos o instrucciones. La entrada de un algoritmo pueden ser los ingredientes para cocinar un *risotto*, y la salida es el plato comestible. Este es un algoritmo computable pero no programable, porque ningún ordenador podría ejecutarlo. La entrada del algoritmo de Google es el texto que escribimos en la caja de búsqueda, y la salida es la lista de resultados. Este es un algoritmo computable y programable (de hecho, la gente de Google lo ha programado, ¿no?) En realidad, los algoritmos recogen operaciones tan sencillas que pueden ser realizadas con éxito por cualquiera. *Incluso por las máquinas*. **La unión de máquinas y algoritmos es lo que está cambiando el mundo**. El matemático británico [Alan Turing](https://es.wikipedia.org/wiki/Alan_Turing), famoso por haber *hackeado* la máquina Enigma de mensajes cifrados de los nazis muchos años antes de que se inventara el término \"*hackear*\", y por haberse suicidado tras sufrir una dura persecución debido a su condición homosexual, fue de los primeros que relacionó algoritmos y ordenadores. De hecho, fue de los primeros que imaginó un ordenador tal y como lo conocemos hoy. Así es: los ordenadores actuales son, en esencia, *Máquinas de Turing* mucho más potentes de lo que Turing pudo soñar. ![Alan Turing](/docs/prog-y-3d/_site/assets/images/01-alan-turing.jpg) **El trabajo de los programadores/as informáticos** consiste en traducir los problemas del mundo a un lenguaje que una máquina pueda entender. Así, **un programa de ordenador** es un algoritmo escrito en un lenguaje de programación. Es decir, un conjunto de miles (¡o millones!) de operaciones sencillas que, como las piezas de un puzle, encajan para dar lugar a la solución final. Los algoritmos se usan para cualquier cosa: predecir resultados electorales, calcular trayectorias de satélites, conocer nuestros gustos y preferencias... El mundo del trabajo se va *algoritmizando* poco a poco: las diferentes tareas se convierten en algoritmos y se automatiza el trabajo. **Las únicas tareas no computables, por el momento, son las relacionadas con la creatividad y las emociones**. ¡Así que ya sabes dónde seguirá existiendo trabajo en las próximas décadas! ## 1.5. Algunos algoritmos famosos en tiempos de internet La palabra algoritmo se ha puesto de moda en los últimos años. Los ordenadores pueden hacer cálculo mucho más deprisa, y con mucha más fiabilidad, que un cerebro humano. Desde la aparición de Internet, se ha producido un salto cualitativo y estamos llegando a computar cosas que antes parecían imposibles. Por eso han surgido disciplinas en plena ebullición como el *big data* o la inteligencia artificial. #### El Algoritmo de Facebook ![Edgerank, el algoritmo de Facebook](/docs/prog-y-3d/_site/assets/images/01-edgerank.jpg) En el *big data*, los algoritmos analizan millones de datos de los clientes. Hay algoritmos ejecutándose en los ordenadores de a bordo de los automóviles, en los satélites de control de tráfico o en las redes sociales. El algoritmo que decide qué ve cada usuario en su muro de Facebook fue uno de los primeros en utilizar *big data*. Es un algoritmo tan famoso que hasta tiene nombre propio: **EdgeRank**. Cada vez que Facebook realiza cambios importantes en *EdgeRank*, se produce un revuelo en Facebook. A principios de 2018, por ejemplo, Facebook decidió dar más importancia a los usuarios particulares que a las empresas, marcas y medios de comunicación, en un intento de que la red social volviera a ser más \"social\" y paliar un poco la invasión de las *fake news*. El cambio dio bastantes quebraderos de cabeza a empresas y medios y, en algunos casos, provocó pérdidas millonarias. #### Algoritmo de Google ![Pagerank, el algoritmo de Google](/docs/prog-y-3d/_site/assets/images/01-pagerank.jpg) Tal vez el algoritmo más famoso del mundo, después del de la multiplicación, sea el de Google. Creado en 1998 y llamado **PageRank**, su éxito revolucionario consistió en que rastreaba la web y daba resultados de búsqueda ordenados por su importancia. ¿Y cómo mide *PageRank* la importancia de cada web? Es un secreto mejor guardado que la fórmula de la Coca-cola. El *PageRank* original medía la importancia de una web por la cantidad de webs que estaban enlazadas a ella. Esa fue la clave de su éxito inicial. En la actualidad, sospecho que ni siquiera los ingenieros de Google están muy seguros de qué cosas mide *PageRank* y en qué medida influyen en sus resultados. Actualmente, *PageRank* es capaz de adaptar sus resultados al usuario (no es lo mismo ser un adulto que un niño, o lanzar una búsqueda desde Almería que hacerlo desde Silicon Valley), ofrecer mapas, imágenes, corregir la ortografía de la búsqueda o entender cuándo en la caja de búsqueda se escribe una pregunta. Y darle respuesta. #### El algoritmo de Amazon ![A9, el algoritmo de Amazon](/docs/prog-y-3d/_site/assets/images/01-amazon.jpg) ¿Despedido por un algoritmo? No es ciencia ficción. De hecho, es algo que ocurre desde hace años. Las máquinas toman decisiones en lugar de los humanos pero que afectan directamente los humanos. Entre 2017 y 2018, más de 300 empleados de Amazon fueron despedidos por falta de productividad en una de sus sedes en Baltimore. Lo llamativo es que detrás esta decisión no hubo una inteligencia humana, sino artificial. Amazon mide individual y automáticamente la productividad de cada trabajador en base al número de paquetes que confeccionan cada hora. El programa, en caso de detectar empleados de baja productividad, genera automáticamente advertencias e incluso procesa automáticamente despidos, sin la intervención de los supervisores. De esta forma, los empleados son supervisados por algoritmos que llegan hasta el punto de conocer el tiempo que emplean fuera de sus tareças. Por ejemplo, si los empleados dejan de escanear paquetes durante demasiado tiempo, el sistema genera automáticamente alertas y el empleado puede ser despedido. Por otro lado, Amazon ha sido acusado en repetidas ocasiones de manipular sus algoritmos de búsqueda de productos dentro de su web, para priorizar los productos que les son más rentables. Cosa que no es de extrañar, por otra parte, ¿no te parece? La cuestión es esta: *un pequeño cambio en un algoritmo puede afectar a una gran parte del comercio electrónico mundial y a miles de fabricantes y vendedores*. ## 1.6. Actividades #### Ejercicio 1 Vamos a escribir nuestro primer algoritmo. Así, sin miedo. Imagina que tienes que explicarle a un extraterrestre recién llegado a la Tierra cómo debe cruzar un semáforo para evitar ser arrollado por los coches. (Si la metáfora del extraterrestre te parece excesiva, imagina que se lo tienes que explicar a un niño o niña muy pequeño) El extraterrestre (o el niño) solo comprende órdenes muy sencillas: camina, no camines, mira la luz, ¿es verde?, ¿es roja?, y cosas así. Tienes que exponer las instrucciones en una lista de pasos o \"receta de cocina\" expresada con acciones sencillas como las anteriores. Venga, a ver qué te sale. (Nota: no te desesperes si no sabes ni cómo empezar. Eso le pasa a todo el mundo la primera vez) #### Ejercicio 2 Ahora lo vamos a complicar un poco más, enfrentándonos a un algoritmo clásico en las ciencias de la computación. Se trata de encontrar el camino más corto entre dos puntos. En nuestro caso, queremos llegar desde A (Salida) hasta F (Meta). Cada camino tiene un peso (el numerito indicado en él). Puedes considerar que ese peso es el tiempo o la distancia, da lo mismo. Constrúyete una tabla con todos los diferentes caminos o recorridos posibles y el valor total de tiempo (o distancia) que acaba sumando cada uno de ellos. ![Grafo de Dijkstra](/docs/prog-y-3d/_site/assets/images/01-grafo.jpg) ¿Cómo se podría construir un algoritmo genérico que encontrase el camino más corto entre dos puntos cualesquiera, en un mapa con cualquier número de puntos y cualquier número de contexiones? Trata de pensarlo unos minutos. Después, cuando notes que la cabeza va a explotarte, bichea un poco por Internet en busca del **algoritmo de Dijkstra**. Brevemente y con tus propias palabras, comenta en qué consiste y trata de aplicarlo al problema anterior. #### Ejercicio 3 Investiga en internet quién fue **Ada Lovelace** y explica en pocas frases qué relación tiene con el mundo de los algoritmos y la programación de ordenadores. #### Ejercicio 4 Investiga en Internet sobre el escándalo de **Cambridge Analytica** y responde con tus palabras (¡y brevemente!) a las siguientes cuestiones: 1. Detalla qué es Cambridge Analytica y a qué se dedicaba. 2. ¿Con qué fin recababa Cambridge Analytica datos y perfiles de usuarios? 3. ¿Cuándo y por qué se produjo un escándalo mundial relacionado directamente con ella? 4. Describe el funcionamiento del algoritmo de Cambridge Analytica y explica como pudo influenciar mediante el mismo en las victorias de Donald Trump en Estados Unidos y del Brexit en Inglaterra? 5. ¿Cuál fue el número de usuarios de Facebook afectados? ¿Cuantos miles de millones de dólaresperdió Facebook tras el escándalo? 6. Busca y encuentra un video corto en youtube donde aparezca Mark Zuckerberg declarando en el congreso de Estados Unidos, dando explicaciones sobre el escándalo de Cambridge Analytica. (No olvides activar los subtítulos si tienes problemas con el inglés). ¿Con qué argumentos se defendió Zuckerberg de las acusaciones? #### Ejercicio 5 Vamos investigar entre todos sobre algunos algoritmos famosos en la historia de la computación: 1. Algoritmo del viajante de comercio. 2. Algoritmo de los filósofos comensales. 3. Algoritmo quicksort 4. Algoritmo mergesort 5. Algoritmo bubblesort o algoritmo de la burbuja 6. Algoritmo auto-tune 7. Algoritmo de la transformada rápida de Fourier 8. Algoritmo OkCupid Date Matching 9. Algoritmo de las ocho reinas 10. Algoritmo de la criba de Eratóstenes 11. Algoritmo MD5 12. Algoritmo SHA1 Una vez que se te asigne uno de estos algoritmos, lo que tienes que investigar es muy sencillo: * ¿Qué problema pretende resolver ese algoritmo? * ¿Cómo lo resuelve? (Expresado en términos sencillos y de andar por casa) ",
    "url": "/docs/prog-y-3d/_site/pensamiento-computacional/",
    "relUrl": "/pensamiento-computacional/"
  },"2": {
    "doc": "2. Representación de la información",
    "title": "2. Representación de la información",
    "content": "# 2. Representación de la información {: .no_toc } El ordenador es una máquina digital, es decir, binaria. Cualquier aprendiz de programador/a debe conocer esa forma de codificación, y otras primas suyas (como la octal y la hexadecimal) antes de aventurarse en los vericuetos de la programación. Dedicaremos todo este tema a hacerlo. - TOC {:toc} ## 2.1. Los códigos Un **código** es un *método de representación de la información*. Se compone de un conjunto de símbolos, llamado **alfabeto**, y de un conjunto de **reglas** para combinar esos símbolos de forma correcta. Estos son algunos ejemplos de códigos que utilizas todos los días o que, al menos, conoces: * **Ejemplo 1**: la lengua castellana es un código. Su alfabeto es el abecedario (a, b, c, d, e ... z), pero los símbolos del alfabeto no se pueden combinar a lo loco, sino que existen unas reglas, y sólo siguiendo esas reglas se codifica correctamente la información, dando lugar a mensajes con sentido. Esas reglas las habéis estudiado en la asignatura de lengua castellana desde la enseñanza primaria. * **Ejemplo 2**: el código morse también es un código. Su alfabeto es muy reducido: sólo el punto (.) y la raya (–), pero combinando los dos símbolos correctamente, se puede transmitir cualquier información. * **Ejemplo 3**: el sistema de numeración decimal es un código. Tiene un alfabeto de 10 símbolos (0, 1, 2, 3, 4, 5, 6, 7, 8 y 9). Combinándolos según ciertas reglas, puede usarse para transmitir información. Pero ojo, no cualquier información, solamente información numérica. Hemos dicho que los códigos sirven para representar información, pero no que tengan que servir para representar toda la información posible. Aunque sólo sirva para los números, el sistema de numeración también es un código. ### 2.1.1. El código binario Pues bien, **el sistema de numeración binario también es un código**. Es muy parecido al sistema de numeración decimal, con la única diferencia de la cantidad de símbolos del alfabeto. Si el decimal tiene diez, el binario sólo tiene dos: el 0 y el 1. En todo lo demás son iguales, así que el sistema binario también sirve para representar información numérica. Pero, ¿puede representarse cualquier número con sólo dos símbolos? La respuesta es sí. El modo de hacerlo consiste en combinar los símbolos 0 y 1 adecuadamente, igual que hacemos con los números decimales. En el sistema decimal contamos así: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9. Cuando queremos pasar a la siguiente cantidad, empezamos a agrupar los dígitos de dos en dos: 10, 11, 12, 13, 14, 15, 16, 17, 18, 19. Al volver a terminar las unidades, vamos incrementando las decenas: 20, 21, 22, etc. (Esto se debe a que, en los sistemas de numeración, cada dígito tiene un valor posicional, es decir, tiene un valor diferente dependiendo del lugar que ocupe en el número general. Por ejemplo, en el número 283, el 3 tiene valor de tres, pero el 8 no tiene valor de ocho, sino de ochenta, y el 2 no tiene valor de dos, sino de doscientos) En binario, el razonamiento es el mismo. Empezamos a contar por 0 y 1, pero entonces ya hemos agotado los símbolos, así que empezamos a agruparlos: 10, 11. Como hemos vuelto a agotarlos, seguimos combinándolos: 100, 101, 110, 111, 1000, 1001, 1010, y así sucesivamente. Así, los 16 primeros números binarios comparados con sus equivalentes decimales son: Decimal|Binario -|- 0|0000 1|0001 2|0010 3|0011 4|0100 5|0101 6|0110 7|0111 8|1000 9|1001 10|1010 11|1011 12|1100 13|1101 14|1110 15|1111 Los números escritos en código binario tienen el mismo valor que en decimal, y sólo cambia la representación. Es decir, “15” en decimal y “1111” en binario representan exactamente a la misma idea: quince. #### Convertir números binarios a decimales Para obtener la representación decimal de un número binario hay que proceder según el Teorema Fundamental de la Normalización, del siguiente modo: 1. Numeramos la posición que ocupa cada dígito binario de derecha a izquierda, empezando por 0. Por ejemplo, en el número binario 1010011, numeraremos las posiciones así: ``` Posiciones --> 6 5 4 3 2 1 0 Dígitos --> 1 0 1 0 0 1 1 ``` 2. Multiplicamos cada dígito binario por 2 elevado a la posición del dígito y sumamos todos los resultados. Con el número del ejemplo anterior: 1 x 26 + 0 x 25 + 1 x 24 + 0 x 23 + 0 x 22 + 1 x 21 + 1 x 20 . 3. Ahora sólo nos quedaría sumar los resultados de todas las multiplicaciones: 64 + 0 + 16 + 0 + 0 + 2 + 1 = 83 . Por lo tanto, el número binario 1010011 es equivalente al número decimal 83. Es habitual indicar con un subíndice el sistema de numeración al que pertenece cada número, así: 10100112 = 8310 . #### Convertir números decimales a binarios El proceso contrario se realiza dividiendo sucesivamente el número decimal entre dos, y cogiendo el último cociente y todos los restos en el orden inverso al que los obtuvimos. Por ejemplo, vamos hallar la representación binaria del número 8310: . Tomando el último cociente (que siempre es 1) y todos los restos desde el último hacia el primero (es decir, 010011, siguiendo la dirección de la flecha), obtenemos el número binario 1010011. Por lo tanto, podemos decir que: 8310 = 10100112 . #### Operaciones aritméticas binarias La operaciones aritméticas binarias se realizan exactamente igual que las decimales, aunque teniendo la precaución de usar sólo los dos símbolos permitidos (0 y 1), lo que puede parecernos un poco extraño al principio. Por ejemplo, para realizar una suma de dos números binarios, escribiremos ambos números uno encima de otro, alineados a la derecha, como hacíamos cuando estábamos aprendiendo a sumar. Luego, iremos sumando los dígitos de derecha a izquierda, como haríamos con dos números decimales, con la precaución de sumar también el acarreo cuando se produzca. Vamos a sumar los números 110012 y 10112: ``` 1 1 1 10 (expresado en binario, 010000012) se le hace corresponder la letra \"A\", al 6610 la \"B\", al 6710 la \"C\", etc. De este modo, el ordenador puede también manejar letras, y lo hace del mismo modo en que maneja números: mediante combinaciones de ceros y unos. La siguiente tabla muestra los 127 primeros caracteres del código ASCII junto con el número al que corresponden en decimal, binario, octal y hexadecimal (estos dos últimos son sistemas de numeración que veremos enseguida): ![Tabla ASCII simplificada](/docs/prog-y-3d/_site/assets/images/02-tabla-ascii.png) (Fuente: Wikimedia Commons - Dominio público) Es importante resaltar que los códigos ASCII siempre tienen 8 dígitos binarios, rellenándose con ceros a la izquierda si fuera necesario. Así ocurre en el caso de la letra A, que, como hemos dicho, se representa con el código 01000001. Si te tomas la molestia de calcular cuántos caracteres diferentes pueden representarse con el código ASCII, verás que son exactamente 256. Suficientes para todos los caracteres habituales, ¿verdad? Aunque, un momento... ¿Y qué hay de los caracteres griegos? ¿O los caracteres cirílicos del ruso? Eso por no hablar del chino y o el japonés. Si queremos dar cabida a cualquier idioma del mundo, el código ASCII se nos queda rápidamente pequeño. Por eso se ideó otra forma de codificación de caracteres que es la que más se usa en la actualidad: Unicode. ### 2.1.3. El código UTF-8 de Unicode El código ASCII no es, desde luego, el único que existe para representar letras en binario, pero sí el más popular por motivos históricos. A finales de la década de 1980, se empezó a desarrollar un proyecto para codificar de forma unívoca todos los caracteres de todas las lenguas del mundo (¡incluidas lenguas muertas!). A ese proyecto se lo denominó **Unicode**. Unicode se ha impuesto con fuerza en la actualidad. Por ejemplo, este documento que estás leyendo ahora mismo está codificado con Unicode, en su versión UTF-8. Y es que Unicode tiene varias implementaciones: * **UTF-8**: los caracteres se codifican en grupos de 8 bits. Algunos solo necesitan 8 bits, pero otros necesitan 16, 24 o incluso 32 bits. Por ejemplo, la \"N\" se codifica con 8 bits (los mismos que en el viejo ASCII), pero la \"Ñ\" se codifica con 16: los 8 correspondientes a la \"N\" más los 8 correspondientes al símbolo \"~\" * **UTF-16**: los caracteres se codifican en grupos de 16 bits. Algunos solo necesitan 16 bits, pero otros necesitan el doble, es decir, 32. * **UTF-32**: los caracteres se codifican en grupos de 32 bits. Eso da un total de 232 caracteres posibles, más que suficientes para codificar todas las lenguas existentes en el mundo. Es la forma de Unicode más simple que existe. La codificación más popular es la **UTF-8 de Unicode**. Aunque es algo más compleja que la UTF-32, los textos codificados de este modo ocupan mucho menos espacio. Los primeros 127 caracteres del UTF-8 se corresponden con el viejo código ASCII. Por eso mismo, y para propósitos prácticos, las tablas clásicas de código ASCII siguen siendo vigentes, al menos hasta el carácter número 127. ### 2.1.4. El código hexadecimal Es importante conocer y saber manejar el código binario al ser el método de codificación que emplean los ordenadores digitales, pero este código tiene dos serios inconvenientes: 1. **Resulta difícil de manipular para nuestros cerebros**, que destán habituados a pensar en decimal (o habituados a no pensar en absoluto, que también se da el caso). 2. **Los números binarios pueden llegar a tener cantidades enormes de dígitos**. Es habitual trabajar con números de 16, 32 o 64 dígitos binarios, lo cual los convierte en inmanejables. Por este motivo, suelen usarse, en programación, otros dos sistemas de numeración llamados **octal** y **hexadecimal**. * El **sistema octal** maneja 8 símbolos distintos: 0, 1, 2, 3, 4, 5, 6 y 7. * El **sistema hexadecimal**, por su parte, tiene 16 símbolos: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E y F. Sin duda, el más utilizado de los dos es el hexadecimal y por este motivo nos vamos a detener en él, aunque haciendo notar que el octal funciona de la misma manera. En hexadecimal, por tanto, es normal ver números cuyos dígitos son letras del alfabeto. Por ejemplo: 2AF5 es un número válido escrito en hexadecimal (exactamente, 10997 en decimal). La forma de contar, por supuesto, es la misma: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, y después empezamos a agrupar los símbolos: 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 1A, 1B, 1C, 1D, 1E, 1F. Seguiríamos con 20, 21, 22, etc. Podemos construir una tabla para comparar los primeros números en los tres sistemas de numeración que conocemos. Hemos rellenado los primeros números binarios con ceros a la izquierda por razones que pronto se verán, pero en realidad los números no cambian (recuerda que un cero a la izquierda no tiene ningún valor, ni en binario ni en el resto de sistemas) Decimal|Binario|Hexadecimal -|-|- 0|0000|0 1|0001|1 2|0010|2 3|0011|3 4|0100|4 5|0101|5 6|0110|6 7|0111|7 8|1000|8 9|1001|9 10|1010|A 11|1011|B 12|1100|C 13|1101|D 14|1110|E 15|1111|F Si te fijas, cada dígito hexadecimal se corresponde exactamente con una combinación de 4 dígitos binarios. Así, por ejemplo, el número binario 1001 1101 se puede escribir más resumidamente como 9D en hexadecimal (porque 10012 equivale a 916 y 11012 equivale a D16). Y **esa es la gran utilidad del sistema hexadecimal**: permite manipular números binarios de forma más escueta y resumida, de manera que nos sean más fáciles de manejar a nosotros, los humanos, que somos muy propensos a cometer errores. #### Convertir números hexadecimales a decimales El mecanismo es el mismo que ya utilizamos para convertir números binarios, sólo que cambiando la base del sistema de numeración de 2 a 16, ya que ahora vamos a manejar números hexadecimales. Por lo tanto, los pasos a seguir son: 1. Numeramos las posiciones que ocupa cada dígito hexadecimal de derecha a izquierda, empezando por 0. Por ejemplo, en el número hexadecimal 2AF, numeraremos las posiciones así: ``` Posiciones --> 2 1 0 2 A F ``` 2. Multiplicamos cada dígito hexadecimal por 16 elevado a la posición del dígito y sumamos todos los resultados. Con el número 2AF lo haríamos así: 2 x 162 + A x 161 + F x 160 . Según la tabla de anterior, tenemos que el dígito hexadecimal A equivale a 10 en decimal, y que F equivale a 15. Por lo tanto la operación quedaría así: 2 x 162 + 10 x 161 + 15 x 160 . Ahora sólo nos falta resolver la operaciones y sumar: 2 x 256 + 10 x 16 + 15 x 1 = 687 . Por lo tanto, el número hexadecimal 2AF es equivalente al número decimal 687. Indicándolo con subíndices, lo expresaríamos así: 2AF16 = 68710 . #### Convertir números decimales a hexadecimales El proceso también es idéntico al realizado con números binarios, pero sustituyendo la división entre 2 por divisiones entre 16, que es la base del sistema hexadecimal. #### Relación entre números hexadecimales y binarios La verdadera utilidad del sistema hexadecimal es que **se puede utilizar en lugar del binario**, siendo más fácil de manejar. Para que ello sea posible, el paso de hexadecimal a binario y viceversa debe poder hacerse con mucha rapidez. Para convertir un número hexadecimal a binario, basta con **sustituir cada dígito hexadecimal por sus cuatro cifras binarias** correspondientes, según la tabla de correspondencias que hemos visto más arriba. Por ejemplo: 2AF16 = 0010 1010 11112 . Del mismo modo, para convertir un número binario a hexadecimal, lo agruparemos en bloques de 4 cifras binarias (empezando por la derecha) y buscaremos la correspondencia en la tabla. Por ejemplo, el número binario 100100 se convierte así: 0010 01002 = 2416 . Observa que hemos rellenado con ceros a la izquierda para obtener bloques de 4 dígitos binarios sin alterar la esencia del número. Por supuesto, no es obligatorio usar este truco de rellenar con ceros a la izquierda, pero las primeras veces puede facilitar las cosas. Con un poco de práctica conseguirás convertir binarios a hexadecimales y viceversa de un sólo vistazo y sin necesidad de consultar la tabla. ## 2.2. Unidades de medida de información Como hemos visto, el código binario es el fundamento del funcionamiento de los ordenadores: toda la información que el ordenador maneja, ya sea numérica o alfanumérica, se encuentra codificada en binario. Del mismo modo que para medir distancias se utiliza el metro, o para medir masas se utiliza el gramo, **para medir la cantidad de información almacenada o procesada en un ordenador existe una unidad de medida**. Como el ordenador representa toda la información en binario, **la unidad fudamental de medida de la cantidad de información es el dígito binario** (es decir, 0 ó 1), también llamado **BIT** (de BInary digiT) Un bit es realmente muy poca cantidad de información. Recuerda que, por ejemplo, para almacenar un sólo carácter en código ASCII son necesarios 7 u 8 bits. ¡Para un único carácter! Del mismo modo que el metro dispone de **múltiplos** (el decámetro, el hectómetro, el kilómetro, etc), también los tiene el bit, y son los siguientes: * **Bit**: Unidad fundamental de medida de la cantidad de información. * **Byte**: 1 byte equivale a 8 bits (un carácter). Esto no siempre ha sido así, pero, en la actualidad, se acepta la cifra de 8 como estándar. Cuidado con el nombre, porque se parecen y es un error común confundir el bit con el byte. * **Kibibyte (KiB)**: 1 kilobyte son 1024 bytes. Fïjate que es parecido al kilómetro (1000 metros), pero no exactamente igual. * **Mebibyte (MiB)**: 1 megabyte equivale a 1024 kilobytes. * **Gibibyte (GiB)**: 1 gigabyte equivale a 1024 megabytes. * **Tebibyte (TiB)**: 1 terabyte equivale a 1024 gigabytes * **Pebibyte (PiB)**: 1 pebibyte equivale a 1024 tebibytes. * **Exbibyte (EiB)**: 1 exbibyte equivale a 1024 pebibytes. Podemos resumir las unidades de medida de información en la siguiente tabla: ``` 1 Byte = 8 bits 1 KiB = 1024 Bytes 1 MiB = 1024 KiB 1 GiB = 1024 MiB 1 TiB = 1024 GiB 1 PiB = 1024 TiB 1 EiB = 1024 PiB ``` Existe otra colección de múltiplos del Byte que se incrementan en potencias de 10, como sucede con los múltiplos de otras magnitudes físicas (tales como el kilómetro, el kilogramo, etc). Se introdujeron hace unos años para acabar con la confusión que provocaba el hecho de que algunos fabricantes consideraban que 1 KB eran 1024 Bytes, mientras que otros decían que eran 1000 Bytes. Estas otras unidades son: * **Kilobyte (KB)**: 1 kilobyte son 1000 bytes. * **Megabyte (MB)**: 1 megabyte equivale a 1000 kilobytes. * **Gigabyte (GB)**: 1 gigabyte equivale a 1000 megabytes. * **Terabyte (TB)**: 1 terabyte equivale a 1000 gigabytes * **Petabyte (PB)**: 1 petabyte equivale a 1000 terabytes. * **Exabyte (EB)**: 1 exabyte equivale a 1000 petabytes. Podemos resumir las unidades de medida de información en la siguiente tabla: ``` 1 Byte = 8 bits 1 KB = 1000 Bytes 1 MB = 1000 KB 1 GB = 1000 MB 1 TB = 1000 GB 1 PB = 1000 TB 1 EB = 1000 EB ``` **Las unidades decimales son más pequeñas que las correspondientes binarias**. Es decir, 1 GB, por ejemplo, son menos Bytes que 1 GiB. La diferencia es tanto mayor cuanto más grande es la unidad. Por ejemplo, 1 KB es un 2,35% más pequeño que 1 KiB, pero 1 EB es un 13,3% más pequeño que 1 EiB. ¡Entre 1 EB y 1 EiB hay 150 millones de GB de diferencia! Por lo tanto, no es de extrañar que las compañías de telefonía o los fabricantes de dispositivos de almacenamiento publiciten sus capacidades en las unidades más pequeñas posible, para que lo que te ofertan parezca más de lo que es. Por último, hacemos notar que, en ocasiones, también se usan los mismos múltiplos para el bit, no para el Byte. Así, puedes encontrarte con megabits (Mb) o mebibits (Mib), que son, respectivamente, un millón (1.000.000) de bits y 220 bits (1.048.576). O con gigabits (Gb) o gigibits (Gib). La conversión entre los múltiplos del bit los del Byte se realiza multiplicando o dividiendo entre 8, como es lógico. Observa como **se usa la \"b\" minúscula para distinguir los bits de los Bytes**. ## 2.3. Ejercicios propuestos **Ejercicio 1**. Investiga y responde a las siguientes cuestiones: > a) ¿Por qué los ordenadores digitales sólo utilizan ceros y unos, es decir, códigos binarios, en lugar de manejar internamente códigos decimales, como hacemos los humanos? > b) ¿Por qué los humanos estamos habituados a un sistema de numeración basado en 10 símbolos y no a cualquier otro, por ejemplo, uno con 8 símbolos, o con 5, o con 12? **Ejercicio 2**. Tenemos un viejo ordenador con una capacidad de almacenamiento en la memoria principal de 2 GB. Suponiendo que un nombre ocupe 30 caracteres y un apellido ocupe 25, ¿cuántos nombres y apellidos puede almacenar este ordenador? **Ejercicio 3**. Convierte las siguientes cantidades de información: > a) 30 GB a MB > b) 128 KB a bits > c) 2 MB a bits > d) 64512 KiB a MiB **Ejercicio 4**. Convierte los siguientes números al sistema de numeración indicado: > a) 1001012 a decimal > b) 25410 a binario > c) 11111112 a decimal > d) 19110 a binario **Ejercicio 5**. Convierte los siguientes números entre los sistemas hexadecimal y binario, utilizando la tabla de conversión que hemos visto en este tema. Si puedes hacerlo sin mirar la tabla, mucho mejor. > a) 100111012 a hexadecimal > b) 1101001110110011012 a hexadecimal > c) 38C16 a binario > d) FDCA16 a binario **Ejercicio 6**. Escribe las palabras \"CELIA VIÑAS\" en código ASCII (en decimal y en hexadecimal). **Ejercicio 7**. La cantidad de memoria RAM de un ordenador personal medio ha ido creciendo imparablemente desde que los ordenadores personales se popularizaron en los años 80. Estas son algunas de esas cantidades: * Año 1982: 256 KiB * Año 1992: 4 MiB * Año 2002: 512 MiB * Año 2012: 4 GiB * Año 2022: 8 GiB Dibuja en un gráfico la evolución de estas cantidades y haz una proyección aproximada hasta el año 2032. ¿Cuánta memoria RAM usarán los ordenadores dentro de 10 años? Puedes usar un programa de hoja de cálculo para ayudarte. **Ejercicio 8**. El tamaño de los discos duros promedios de los ordenadores también ha ido creciendo desde hace cuarenta años. Haz una proyección parecida a la anterior para averiguar qué capacidad de almacenamiento en disco tendrán los ordenadores personales, previsiblemente, dentro de 10 años. * Año 1982: 10 MiB (los pocos ordenadores que tenían disco duro) * Año 1992: 1 GiB * Año 2002: 40 GiB * Año 2012: 240 GiB * Año 2022: 2 TiB ",
    "url": "/docs/prog-y-3d/_site/representacion-de-la-informacion/",
    "relUrl": "/representacion-de-la-informacion/"
  },"3": {
    "doc": "3. Introducción a la programación",
    "title": "3. Introducción a la programación",
    "content": "# 3. Introducción a la programación {: .no_toc } - TOC {:toc} ## 3.1. ¿Qué es exactamente eso de \"programar un ordenador\"? **Programar un ordenador** no es más que proporcionarle a la máquina un conjunto de instrucciones y datos para que realice una tarea. Esa tarea, generalmente, resuelve un problema concreto, que puede ir desde realizar complicados cálculos matemáticos hasta entretenernos con un videojuego en nuestros ratos de ocio. El conjunto de las instrucciones que conforma el programa se denomina **código fuente**, y tiene que estar escrito en un lenguaje comprensible por la máquina, es decir, un **lenguaje de programación**. Esas instrucciones se traducen a **código binario** (que, recuerda, es lo único que puede comprender el ordenador). La CPU de un ordenador está construida de manera que puede entender y ejecutar ciertas instrucciones binarias, gracias a lo cual nuestro programa acaba ejecutándose en las entrañas de la máquina. Este es un fragmento de un programa informático real escrito en lenguaje PHP. Implementa un algoritmo de ordenación de elementos llamado *Bubble Sort* o, en español, *método de la burbuja*. No es necesario, ni mucho menos, que lo entiendas de momento. Solo quiero que le eches un vistazo para que veas el aspecto que tiene un programa real (o un fragmento) escrito en un lenguaje real. ```php function bubble_Sort($my_array ) { do { $swapped = false; for( $i = 0, $c = count( $my_array ) - 1; $i $my_array[$i + 1] ) { list( $my_array[$i + 1], $my_array[$i] ) = array( $my_array[$i], $my_array[$i + 1] ); $swapped = true; } } } while( $swapped ); return $my_array; } $test_array = array(3, 0, 2, 5, -1, 4, 1); echo \"Original Array :\"; echo implode(', ',$test_array ); echo \"Sorted Array:\"; echo implode(', ',bubble_Sort($test_array)). PHP_EOL; ``` (Fuente: php.net) ### 3.1.2. Programas y algoritmos Para realizar un programa es necesario idear previamente un algoritmo. Esto es importante hasta el extremo de que, sin algoritmo, no existiría el programa. Un algoritmo, como hemos visto, es una **secuencia ordenada de acciones que conducen a la solución de un problema en un número finito de pasos simples**. Por ejemplo, vamos a escribir un algoritmo para determinar si un número entero cualquiera (que llamaremos N) es par o impar: ``` - Inicio del algoritmo - Paso 1. Preguntar qué número concreto es N. - Paso 2. Si N es divisible entre 2, entonces la solución es \"PAR\". - Paso 3. Si N no es divisible entre 2, entonces la solución es \"IMPAR\". - Paso 4. Imprimir la solución. - Fin del algoritmo ``` Recuerda que este algoritmo está **escrito para que lo ejecute un ordenador**, no para que lo ejecute una persona. Por eso el Paso 1 es \"Preguntar qué número es N\": porque el ordenador tendrá que preguntarnos a nosotros, los humanos, el número. Y por eso el Paso 4 es \"Imprimir la solución\": porque el ordenador nos ofrecerá el resultado imprimiéndolo en la pantalla o en un papel. Este algoritmo resuelve el problema planteado en un número finito de pasos simples. Lógicamente, al ordenador no le podemos dar estas instrucciones tal y como las hemos escrito, sino que habrá que expresarlo en un lenguaje de programación, pero esto es algo que trataremos más adelante. ### 3.1.3. Datos y tipos de datos Los algoritmos, como hemos dicho, son colecciones de instrucciones que resuelven un problema. Pero esas instrucciones **siempre trabajan con datos**, es decir, con información formalizada para su uso en un ordenador: * **Los datos de entrada** son datos que el algoritmo necesita para trabajar. En el ejemplo anterior, el número \"N\" es un dato de entrada. * **Los datos de salida** son datos que el algoritmo produce como resultado de sus cálculos. En el ejemplo anterior, \"solución\" es un dato de salida. Los datos siempre pertenecen a un **tipo de datos**, que es el rango de valores que ese dato puede tomar. Existen multitud de tipos de datos posibles, pero empezaremos trabajando solo con estos: * **Enteros**. Los datos de este tipo solo pueden tomar como valores números enteros (positivos o negativos). Ejemplos: 3, 28, -15, 0, 4982... * **Reales**. Números con decimales. Ejemplos: 18.25, -3.198887 * **Caracteres**. Letras, números, signos de puntuación... Ojo, si un dato es de tipo \"carácter\", solo puede contener en cada momento un único carácter. Ejemplos: 'a', 'Z', '&', '?' * **Cadenas de caracteres**. O, simplemente, *cadenas*. Son colecciones de letras, números, signos de puntuación... Es decir, palabras y cualquier cosa que se le parezca. Ejemplos: \"Hoy es lunes\", \"sgcv08 e98 ie7f83 ?so9&/\". Suelen distinguirse de los caracteres individuales por la doble comilla, aunque esto depende del lenguaje de programación. * **Lógicos o booleanos**. Estos datos solo pueden tener dos valores: *verdadero* o *falso*. ### 3.1.4. Variables y constantes Las **variables** de un algoritmo son como las variables en una ecuación matemática: representaciones de un dato a las que asignamos un nombre o identificador. En el algoritmo para averiguar si un número es par o impar, *N* es una variable y *solución* es otra variable. Las variables pueden tomar un valor perteneciente a un tipo de datos. Ese valor puede cambiar a lo largo del algoritmo (por eso se denominan *variables*). Lo que no puede cambiar es el tipo de datos al que pertenecen. Es decir: si una variable es entera, no puede cambiar y pasar a ser real durante la ejecución del programa. (Bueno, hay lenguajes que sí permiten hacer esto, pero esa es otra historia). Por eso, la mayoría de los lenguajes de programación exigen que les indiquemos a qué tipo de datos pertenece cada variable antes de usarlas por primera vez. Es algo que también haremos en pseudocódigo. Eso se denomina **declarar una variable**. Así pues, podemos mejorar el algoritmo anterior con la declaración de las variables \"N\" y \"solución\": ``` - Inicio del algoritmo - Declaración de variables: - N es un número entero. - solución es una cadena de caracteres. - Paso 1. Averiguar qué número es N. - Paso 2. Si N es divisible entre 2, entonces la solución es \"PAR\". - Paso 3. Si N no es divisible entre 2, entonces la solución es \"IMPAR\". - Paso 4. Imprimir la solución. - Fin del algoritmo ``` Las **constantes** se parecen a las variables: tienen un nombre y un tipo, y se les asigna un valor. La única diferencia es que una constante *no puede cambiar de valor durante la ejecución del algoritmo* y una variable sí. ### 3.1.5. Subalgoritmos Cuando un algoritmo es muy complejo, lo dividimos en trozos más simples que denominamos **subalgoritmos**. En programación, esos subalgoritmos se denominan **procedimientos** o **funciones**. Son casi la misma cosa, con una sutil diferencia que ya veremos cuando llegue el momento. Los lenguajes de programación reales, además de las instrucciones básicas que enseguida vamos a ver, tienen unas colecciones de funciones predefinidas llamadas **bibliotecas**. Esas funciones se encargan de realizar tareas habituales y repetitivas, de modo que nos ahorran un montón de trabajo. Por ejemplo, es posible escribir algoritmos para hacer cálculos matemáticos complejos, tales como logaritmos o raíces cuadradas. Para evitarnos ese trabajo, todos los lenguajes de programación disponen de una biblioteca de funciones matemáticas que incluye, entre otras muchas cosas, el cálculo de logaritmos y de raíces cuadradas para cuando los necesitemos. Así que vamos a suponer, cuando escribamos pseudocódigo, que también tenemos a nuestra disposición de esas bibliotecas de funciones. Algunos subalgoritmos o funciones que existen en todos los lenguajes de programación y que podemos considerar que también existen en pseudocódigo son las siguientes: * abs(x). Calcula el valor absoluto de x. Funciona con números reales y con enteros. * sen(x). Calcula el seno de x. Devuelve valores reales. * cos(x). Calcula el coseno de x. Devuelve valores reales. * exp(x). Calcula ex. Devuelve un real. * ln(x). Calcula el logaritmo neperiano de x. Devuelve un valor real. * redon(x). Redondea el número x al valor entero más próximo. El valor x será real, y la función devolverá un entero. * trunc(x). Trunca el número x, es decir, le elimina la parte decimal. El valor x será real, y la función devolverá un entero. * rc(x). Calcula la raíz cuadrada de x. Devuelve un valor real * azar(x). Genera un número al azar entre 0 y x. Supondremos que solo funciona con números enteros. ### 3.1.6. Expresiones y operadores Una **expresión** es una combinación de constantes, variables, operadores y funciones. Por ejemplo, esto es una expresión: rc((5 + x) / 2) . En esta expresión, aparecen dos constantes literales (5 y 2), una variable (x), dos operadores aritméticos (+ y /) y una función (rc, para calcular la raíz cuadrada), además de los paréntesis, que sirven para manipular la prioridad de las operaciones. Lógicamente, para resolver la expresión, es decir, para evaluar su resultado, debemos conocer cuál es el valor de la variable x. Si suponemos que la variable x tiene el valor 7, el resultado de la expresión será 2,449. La forma más habitual de encontrar una expresión es combinada con una **sentencia de asignación a una variable**. Por ejemplo: y En estos casos, la expresión (lo que hay a la derecha del signo \" (mayor que), = (igual que), != (distinto de), (mayor o igual que). El resultado de estas comparaciones siempre es un valor lógico, es decir, verdadero o falso. * **Operadoresl lógicos**: se utilizan para comparar otros datos lógicos y relacionarlos entre sí. Los más habituales son Y, O y NO. Estas palabras tienen el mismo significado que en la lengua natural. Observa, por ejemplo, este fragmento de pseudocódigo muy fácil de entender: ``` puntos_carnet = edad = Si edad >= 18 y puntos_carnet > 0 Entonces escribir \"Puedes conducir\" FinSi Si edad | Instrucción | Significado | . | Algoritmo nombre | Marca el comienzo de un algoritmo y le adjudica un nombre | . | FinAlgoritmo | Marca el final del algoritmo | . | Definir variable Como tipo | Declara una variable y le asigna un tipo. Los tipos válidos son Entero, Real, Carácter, Lógico y Cadena. | . | Leer variable | Entrada de datos. El programa lee un dato desde un dispositivo de entrada (si no se indica otra cosa, el teclado), asignando ese dato a la variable. | . | Escribir expresión | Salida de datos. La expresión se calcula y su resultado se muestra en la pantalla. | . | variable | Asignación. Se evalúa la expresión y el resultado se guarda en la variable. | . | Si condición Entonces &nbsp;&nbsp;&nbsp;&nbsp;acciones-1 SiNo &nbsp;&nbsp;&nbsp;&nbsp;acciones-2 FinSi | Estructura condicional. Se evalúa la condición. Si es verdadera, se ejecutan las \"acciones-1\". Si es falsa, se ejecutan las \"acciones-2\". | . | Segun expresión hacer &nbsp;&nbsp;&nbsp;&nbsp;valor-1: acciones-1; &nbsp;&nbsp;&nbsp;&nbsp;valor-2: acciones-2; &nbsp;&nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;&nbsp;&nbsp;valor-n: acciones-N; &nbsp;&nbsp;&nbsp;&nbsp;De otro modo: acciones-por-defecto; FinSegun | Condicional múltiple. Si la expresión se evaúa como\"valor-1\", se ejecutan las acciones-1. Si vale \"valor-2\", se ejecutan las acciones-2, y así sucesivamente. Si la expresión no coincide con ningún valor, se ejecutan las acciones-por-defecto. | . | Mientras condición &nbsp;&nbsp;&nbsp;&nbsp;acciones FinMientras | Bucle con condición al princio. Se realizan las acciones repetidamente mientras la condición siga siendo verdadera. | . | Repetir &nbsp;&nbsp;&nbsp;&nbsp;acciones Hasta Que condición | Bucle con condición al final. Se realizan las acciones repetidamente mientras la condición siga siendo verdadera. Observa que el cuerpo de este bucle se ejecuta al menos una vez, mientras que el del bucle anterior podría no ejecutarse nunca (si la condición es falsa desde el principio). | . | Para variable valor_inicial Hasta valor_final Hacer &nbsp;&nbsp;&nbsp;&nbsp;acciones FinPara | Bucle con iterador. Se asigna el valor_inicial a la variable. El bucle se repite hasta que la variable llega al valor_final. En cada iteración, la variable se incrementa en una unidad (se puede indicar otro incremento, pero, de momento, nos quedamos con ese). | . También existen instrucciones para crear y manejar subalgoritmos. Como nuestros programas, de momento, van a ser muy simples, aún no vamos a verlas. Nos dedicaremos a ellas cuando llegue el momento. ### 3.2.3. Un ejemplo sencillo de algoritmo escrito en pseudocódigo Vamos a terminar esta sección mostrando un ejemplo sencillo pero muy completo de algoritmo escrito en pseudocódigo. Se trata de escribir un algoritmo tal que, dados dos números enteros (que llamaremos A y B), nos dirá cuáles son los números enteros que existen entre A y B ordenados de menor a mayor. Lo primero que el algoritmo tendrá que hacer será pedirnos los valores de A y B. Después, tendrá que averiguar cuál de los dos es el menor (A o B), para poder luego meterse en un bucle que vaya desde el número menor hasta el número mayor, pasando por todos los valores intermedios e imprimiéndolos. Las instrucciones de ese algoritmo serían estas: ``` Algoritmo contar_numeros Definir A,B,inicio,final,i Como Entero Escribir 'Dime un número' Leer A Escribir 'Dime otro número' Leer B Si (A | Símbolo | Equivalencia en pseudocódigo | Significado | . | | Algoritmo nombre | Marca el comienzo de un algoritmo y le adjudica un nombre | . | | FinAlgoritmo | Marca el final del algoritmo | . | | Definir variable Como tipo | Declara una variable y le asigna un tipo. | . | | Leer variable | Entrada de datos. | . | | Escribir expresión | Salida de datos. | . | | variable | Asignación. | . | | Si condición Entonces &nbsp;&nbsp;&nbsp;&nbsp;acciones-1 SiNo &nbsp;&nbsp;&nbsp;&nbsp;acciones-2 FinSi | Estructura condicional. | . | | Segun expresion hacer &nbsp;&nbsp;&nbsp;&nbsp;valor-1: acciones-1; &nbsp;&nbsp;&nbsp;&nbsp;valor-2: acciones-2; &nbsp;&nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;&nbsp;&nbsp;valor-n: acciones-N; &nbsp;&nbsp;&nbsp;&nbsp;De otro modo: acciones-por-defecto; FinSegun | Condicional múltiple. | . | | Mientras Condición &nbsp;&nbsp;&nbsp;&nbsp;acciones FinMientras | Bucle con condición al princio. | . | | Repetir &nbsp;&nbsp;&nbsp;&nbsp;acciones Hasta Que Condición | Bucle con condición al final. | . | | Para variable valor_inicial Hasta valor_final Hacer &nbsp;&nbsp;&nbsp;&nbsp;acciones FinPara | Bucle con iterador. | . Recuerda que también existen símbolos para definir y utilizar **subalgoritmos**, destinados a dividir el algoritmo en trozos cuando resolvemos problemas complejos. Por ahora, nuestros problemas serán simples y no usaremos subalgoritmos. Cuando llegue el momento, explicaremos cómo se utilizan. Para terminar, te muestro el algoritmo para contar números enteros entre dos números cualesquiera, A y B, escrito como un diagrama de flujo. No dejes de comparar esta solución con la que planteamos en pseudocódigo un poco más arriba. Ambas son exactamente iguales, pero están descritas con una herramienta diferente. Es como si hubiéramos escrito la misma frase en dos idiomas distintos. ![Diagrama de flujo contar-numeros](/docs/prog-y-3d/_site/assets/images/03-contar-numeros.png) ## 3.4. Errores frecuentes entre principiantes En esta sección recopilo para ti algunas de las dudas, errores y pifias más frecuentes que, según mi experiencia como profesor de programación, suelen asaltar a los principantes. #### No es lo mismo 20 que \"20\" Así es. Cuando estás programando, no es lo mismo la instrucción ```Escribir 20``` (o cualquier otro número) que la instrucción ```Escribir \"20\"```, con el número entre comillas. Las cadenas de caracteres siempre se ponen entre comillas. Los números NO. Por eso, ```Escribir 20``` significa literalmente *mostrar en pantalla el número 20*, mientras que ```Escribir \"20\"``` significa *mostrar en pantalla la cadena de caracteres \"20\"*. Puede parecer lo mismo, pero no lo es. En una, 20 es un texto y, en otra, un número, y para el ordenador son cosas muy distintas (por ejemplo, no puedes sumar dos textos, pero sí dos números). #### Escribir \"a\" no es lo mismo que Escribir a Un caso particular de la confusión anterior, y muy frecuente cuando se empieza a programar, es confundir ```Escribir \"a\"``` (o cualquier otro carácter) con ```Escribir a```. La primera instrucción pide al ordenador que escriba un texto (en este ejemplo, una letra \"a\"). La segunda instrucción pide al ordenador que escriba *el contenido* de una variable. Es decir, en ```Escribir a```, la a debe ser una variable preexistente. Y, como todas las variables, debe tener un valor. La instrucción ```Escribir a``` pide al ordenador que escriba ese valor, no una letra \"a\". #### ¡Me hago un lío entre Escribir y Leer! A menudo me he encontrado con que las personas que se inician en la programación de ordenadores confunden *escribir* y *leer*: ¡no tienen claro cuándo utilizar una y cuándo la otra! Esta confusión se debe a un problema de punto de vista. El programador/a novato piensa los algoritmos *desde su punto de vista*, es decir, como si fuera él o ella quien debe ejecutar el algoritmo. La solución pasa por cambiar el punto de vista. **El algoritmo lo ejecutará un ordenador**, no nosotros. Los algoritmos son colecciones de órdenes para el ordenador, no para nosotros. Podemos pensar en el ordenador como en un esclavo obediente que hará todo lo que le pidamos (siempre que se lo pidamos en un lenguaje que pueda entender). Así, cuando le pedimos que ejecute una instrucción *escribir 'Hola'*, no somos nosotros los que vamos a escribir \"Hola\", sino que será la máquina la que lo hará. Y lo escribirá en su pantalla, que es la manera estandarizada en la que un ordenador escribe cosas. Y cuando le pidamos que ejecute *leer n*, será el ordenador el que leerá el valor de la variable n. ¿Y cómo se las apaña un ordenador para leer cosas? A través de un dispositivo de entrada. Es decir, a través del teclado. La instrucción *leer n* hará que el programa se detenga hasta que tecleemos algo, y ese algo se almacenará en la variable n. #### Errores lógicos: confundir Y con O Este también es un problema frecuente, incluso entre programadores experimentados. Recuerda que los operadores lógicos Y y O tienen exactamente el mismo significado que en español. A partir de ahí, solo te queda utilizar el sentido común. Si, aún así, te enfrentas con una expresión que no acabas de comprender, trata de descomponerla en expresiones más simples para asimilar mejor la lógica del problema. #### Confundir condición con iteración Otro error recurrente entre principiantes consiste en confundir la estructura condicional con la iterativa. En concreto, confudir *Si... Entonces* con *Mientras... Hacer*. Creo que se debe a que ambas instrucciones comparten la misma estructura: tienen una condición al principio y ejecutan una serie de acciones o no en función de esa condición. Pero hay una diferencia fundamental: las acciones de un *Si... Entonces* solo se ejecutarán **una o ninguna vez**, y luego el programa continuará. Las acciones de un *Mientras... Hacer* se ejecutarán **cero, una o muchas veces**, dependiendo de la condición. Por lo tanto, para saber si debes usar una u otra, pregúntate esto: \"¿tiene sentido que estas acciones se ejecuten muchas veces o, como máximo, se ejecutarán una vez?\". Si la respuesta es \"muchas veces\", necesitas un *Mientras... Hacer*. Si la respuesta es \"una vez\", necesitas un *Si... Entonces*. Pongamos un ejemplo. Imagina que estás escribiendo un programa que pida un número y determine si es negativo. Puedes tener la tentación de escribir esto: ``` leer N Mientras N ¡¡¡CUIDADO, ESTO ES UN ERROR!!! escribir \"El número es negativo\" FinMientras ``` Si haces eso, habrás provocado involuntariamente un bucle infinito, ya que, cuando el programa entre en el bucle, no logrará salir jamás de él porque la condición siempre será verdadera. Para no caer en este error, trata de responder a la pregunta que planteábamos antes. La única accion que hay dentro de este bucle es *Escribir \"El número es negativo\"*, así que debes preguntarte: \"¿mi programa tiene que escribir *El número es negativo* muchas veces, o solo una (en caso de que el número, en efecto, sea negativo)?\" La respuesta, obviamente, es que basta con una. Así que la solución correcta a este problema es: ``` leer N Si N Calcular el área y la circunferencia de un círculo cuyo radio será proporcionado a través del teclado. Recuerda que área = 3.14 x r x r y circunferencia = 2 x 3.14 x r **Ejercicio 2**. Pedir las cuatro notas de los exámenes del primer trimestre de un alumno y mostrar la nota media obtenida. **Ejercicio 3**. Calcular el precio de llenar una piscina de agua. Para ello se tienen que pedir al usuario las medidas de la piscina (largo, ancho y alto) y el precio del m​3​ del agua. Se mostrará el precio total. Supondremos que la piscina es de forma regular. #### Ejercicios con estructuras condicionales **Ejercicio 4**. Determinar si un número leído del teclado es positivo, negativo o cero. **Ejercicio 5**. Calcular la raíz cuadrada de un número introducido por teclado. Hay que tener la precaución de comprobar que el número sea positivo. **Ejercicio 6**. Leídos dos números por teclado, A y B, calcular la resta del mayor menos el menor. Por ejemplo, si A = 8 y B = 3, el resultado debe ser A – B, es decir, 5. Pero si A = 4 y B = 7, el resultado debe ser B – A, es decir, 3. **Ejercicio 7**. Averiguar si un número real introducido por teclado tiene o no parte fraccionaria (utilícese la función trunc() que aparece descrita en los apuntes) **Ejercicio 8**. Leer un número real y un tipo de moneda, que puede ser \"euro\" o \"peseta\". Convertir la cantidad al tipo de moneda indicado, suponiendo que está expresada en la otra. Por ejemplo, si la cantidad es 15 y la moneda es \"peseta\", se supondrá que se trata de 15 € y que hay que convertirlos a pesetas y, por lo tanto, el resultado debe ser 2495. **Ejercicio 9**. Leer tres números por teclado, X, Y y Z, y decidir si están ordenados de menor a mayor. **Ejercicio 10**. Como el anterior, pero para averiguar si los números son consecutivos. **Ejercicio 11**. Determinar si un año es bisiesto o no (los años bisiestos son múltiplos de 4; utilícese el operador módulo) **Ejercicio 12**. Determinar el número de cifras de un número entero. El algoritmo debe funcionar para números de hasta 5 cifras, considerando los negativos. Por ejemplo, si se introduce el número 5342, la respuesta del programa debe ser 4. Si se introduce –250, la respuesta debe ser 3. **Ejercicio 13**. Calcular las dos soluciones de una ecuación de segundo grado, del tipo ax2 + bx + c = 0. Los coeficientes a, b y c deberá introducirlos el usuario a través del teclado. #### Ejercicios con estructuras condicionales e iterativas **Ejercicio 14**. Escribir todos los números entre 1 y n, siendo n un entero introducido por teclado. **Ejercicio 15**. Escribir todos los números pares entre 1 y n. **Ejercicio 16**. Escribir todos los números impares entre dos números a y b introducidos por teclado. Antes habrá que comprobar cuál de los dos números (a o b) es mayor. **Ejercicio 17**. Calcular la suma de todos los números pares entre 1 y n, siendo n un entero introducido por teclado. Es decir, hay que calcular 2 + 4 + 6 + ... hasta n (o n-1, si n es un número impar). **Ejercicio 18**. Realiza un programa que calcule la suma de los n primeros números, donde n es un número introducido por teclado. Al terminar, el programa nos mostrará el mensaje \"¿Desea terminar? (S/N)\". Si el usuario escribe \"S\", el programa terminará, pero, si escribe \"N\", volverá a comenzar. **Ejercicio 19**. Calcular la nota media de un alumno a partir de las notas de todos sus exámenes a lo largo del curso. El programa nos irá pidiendo notas, pero no sabemos cuántas son. Para terminar de introducir valores, el usuario debe teclear un número negativo. Entonces, el programa calculará el promedio de todas las notas introducidas. **Ejercicio 20**. El usuario de este programa será un profesor, que introducirá las notas de sus 30 alumnos de una en una. El algoritmo debe decirle cuántos suspensos y cuántos aprobados hay. **Ejercicio 21**. Calcular el valor máximo de una serie de 10 números introducidos por teclado. **Ejercicio 22**. Generalizar el ejercicio anterior para que también se averigüe el valor mínimo y el medio. **Ejercicio 23**. Calcular el factorial de un número entero N. Recuerda que el factorial de un número es el producto de ese número por todos los enteros menores que él. Por ejemplo, el factorial de 5 (simbolizado 5!) se calcula como: 5! = 5 x 4 x 3 x 2 x 1. **Ejercicio 24**. Generar combinaciones al azar para la lotería primitiva (6 números entre 1 y 49). Debes utilizar la función azar(x) que vimos en los apuntes. Por ahora, no te preocupes porque los números puedan repetirse. **Ejercicio 25**. Generar combinaciones al azar para la quiniela (14 valores dentro del conjunto 1, X o 2). #### Ejercicios más avanzados **Ejercicio 26**. Determinar si un número N introducido por teclado es o no primo. Recuerda que un número primo es aquél que sólo es divisible por sí mismo y por la unidad. **Ejercicio 27**. Generalizar el algoritmo anterior para averiguar todos los números primos que existen entre 2 y N, siendo N un número introducido por teclado. **Ejercicio 28**. Introducida una hora por teclado (horas, minutos y segundos), se pretende sumar un segundo a ese tiempo e imprimir en la pantalla la hora que resulta (también en forma de horas, minutos y segundos). **Ejercicio 29**. La calculadora. Diseñar un algoritmo que lea dos números, A y B, y un operador (mediante una variable de tipo carácter), y calcule el resultado de operar A y B con esa operación. Por ejemplo, si A = 5 y B = 2, y operación = \"+\", el resultado debe ser 7. El algoritmo debe seguir pidiendo números y operaciones indefinidamente, hasta que el usuario decida terminar (utilizar un valor centinela para ello) #### Algunos juegos sencillos **Ejercicio 30. Juego del número secreto**. El ordenador elegirá un número al azar entre 1 y 100. El usuario irá introduciendo números por teclado, y el ordenador le irá dando pistas: \"mi número es mayor\" o \"mi número es menor\", hasta que el usuario acierte. Entonces el ordenador le felicitará y le comunicará el número de intentos que necesitó para acertar el número secreto**. **Ejercicio 31. Número de la suerte** El número de la suerte o *lucky number* es una tontuna que se han inventado los numerólogos y que se obtiene sumando todas las cifras de la fecha de nacimiento de un modo azaroso. Por ejemplo, como yo nací el 15 de octubre de 1974 (15-10-1974), se supone que mi número de la suerte es 15+10+1974 = 1999. Ahora sumo todas las cifras de 1999 así: 1+9+9+9 = 28. Como aún tengo dos dígitos, vuelvo a sumarlos. 2 + 8 = 10. Y, por último, 1 + 0 = 1. Por lo tanto, 1 es mi número de la suerte. Si alguna vez me toca la lotería y llevo un número acabado en 1, os aviso. Por ahora, nos conformamos con escribir un programa que, dada una fecha de nacimiento (día, mes y año), calcule el número de la suerte de esa persona. **Ejercicio 32. El juego de la ruleta** Escribe un programa que permita jugar a la ruleta con el ordenador. Supondremos que la ruleta tiene 20 números rojos y 20 negros. El jugador, que tendrá una suma de dinero inicial, apostará una cantidad (siempre menor que el dinero que le quede) a un número y un color. La ruleta, que puedes simular con el método azar(), la manejará el ordenador y comunicará al jugador el resultado. Si el jugador acierta, multiplicará por 10 el dinero apostado. Si falla, perderá el dinero apostado. El proceso se repetirá hasta que el jugador decida abandonar el juego, o bien se quede sin dinero. Por favor, abstenerse ludópatas. **Ejercicio 33. Juego de dados** Escribe un programa para jugar a los dados con el ordenador. Las reglas del juego son las siguientes: * El jugador humano dispondrá de una cantidad inicial de dinero que se introducirá por teclado. * El jugador apostará una cantidad de dinero (siempre igual o menor del que le queda) * Después, se tirarán tres dados (lo cual se puede simular con el método azar()) * Si en los tres dados sale la misma cantidad, el dinero apostado por el jugador: * Se multiplica por 5 si en los dados ha salido un 6 * Se multiplica por 3 si sale cualquier otra cantidad * Si en dos dados de los tres sale la misma cantidad, el dinero apostado se multiplica por 2 * En cualquier otro caso, el dinero apostado se pierde * El proceso se repite hasta que el jugador se queda sin dinero o hasta que decide dejar de jugar. **Ejercicio 34. Juego de las Tres en Raya** Vamos a hacer una versión del popular juego de las Tres en Raya para jugar contra el ordenador. No será un juego con inteligencia artificial como el de la WOPR (si no sabes qué es la WOPR, bueno, ¿para qué sirve wikipedia?), pero te permitirá pasar un buen rato programando, que es de lo que se trata. El juego se desarrolla en un tablero de 3 x 3 casillas en el que los jugadores van disponiendo sus fichas tratando de formar una línea vertical, horizontal o diagonal. Las fichas del jugador humano tendrán forma de aspa (X) y, las del ordenador, forma de círculo (O) . Al principio, el tablero está en blanco. Comenzará jugando el jugador humano, que colocará una ficha en el tablero. Después, será el turno del ordenador. El proceso se repite hasta que uno de los dos consigue colocar tres fichas formando una línea, o hasta que ya no es posible colocar más fichas (situación de “tablas”) *Aviso: este juego es más difícil de programar que los anteriores.* **Ejercicio 35**. Dibujar con asteriscos. Se trata de escribir un programa que sea capaz de dibujar en la pantalla, *mediante bucles*, estos bonitos diseños. Añade alguno de tu propia cosecha, por favor. (Por si queda alguna duda: el último se supone que es un árbol de navidad) ``` * *** ***** ******* * *** ***** ******* ***** *** * * * * * * * * * * * * * * *** * *** ***** ******* * *** ***** ******* ********* *********** ************* *** *** *** *** ``` **Ejercicio 36. Máquina tragaperras** Vamos a escribir ahora un programa que simule el funcionamiento de una máquina tragaperras. No es que yo tenga ningún problema con los juegos de azar, ¿eh?, es solo que son simples y adecuados para simular con un ordenador en el momento del curso en el que nos encontramos. Además, puedo dejarlos cuando quiera. El programa debe tener el siguiente comportamiento: a) Preguntará al usuario con cuánto dinero inicial desea jugar (en euros). Esta cantidad no puede ser menor que 1 euro ni mayor que 50. b) Cada jugada costará 0,50 euros, que se descontarán automáticamente del saldo que el jugador tenga en cada momento. c) Cada jugada consiste en una combinación de tres frutas elegidas al azar entre estas seis: * Manzana * Naranja * Fresa * Cereza * Limón * Sandía d) El jugador no gana nada si las tres frutas que salen son distintas. e) En cambio, si varias frutas coinciden, el jugador gana un premio, que pasa a incrementar su saldo. El premio será: * Si dos frutas cualesquiera son iguales: * 1) Si son dos cerezas, 3 euros * 2) Si son dos sandías, 2 euros * 3) Si no son ni sandías ni cerezas, 1 euro * Si las tres frutas son iguales: * 1) Si son tres cerezas, 30 euros * 2) Si son tres sandías, 20 euros * 3) Si son tres fresas, 10 euros * 4) Si no son ni cerezas, ni sandías, ni fresas, 5 euros f) Después de cada jugada, la máquina comunicará al jugador la combinación que ha salido y le dirá si ha ganado algún premio. g) Después de eso, la máquina le dirá al jugador cuál es su saldo actual y le preguntará si desea seguir jugando. Si el jugador se queda sin dinero, el juego terminará automáticamente sin preguntar nada. Este es un ejemplo de ejecución del programa: ``` *** BIENVENIDO AL JUEGO DE LA TRAGAPERRAS *** ¿Con cuánto dinero desea empezar (de 1 a 50 euros) ? 60 Cantidad incorrecta ¿Con cuánto dinero desea empezar (de 1 a 50 euros) ? 20 COMIENZA EL JUEGO... La combinación de esta jugada es: NARANJA – CEREZA – SANDÍA Lo siento, no ha obtenido ningún premio Su saldo actual es de 19,5 euros. ¿Desea jugar otra vez (S/N) ? S La combinación de esta jugada es: SANDÍA – SANDÍA - LIMÓN ¡Enhorabuena! Ha ganado 20 euros. Su saldo actual es de 39,5 euros. ¿Desea jugar otra vez (S/N) ? N ¡Hasta la próxima! ``` #### Desafíos matemáticos para personas valientes **Ejercicio 37**. Mínimo común múltiplo. El programa nos pedirá dos números y calculará el mínimo común múltiplo de ambos. *Atención: este ejercicio es de dificultad elevada*. **Ejercicio 38**. Máximo común divisor. Como el anterior, pero calculando el máximo común divisor. *Atención: este ejercicio es de dificultad elevada*. **Ejercicio 39**. Escribe un programa que pregunte al usuario su fecha de nacimiento y la fecha del día de hoy, y calcule la edad del usuario en años. (Aviso: no es tan fácil como parece) Este programa se puede mejorar haciendo que calcule la edad en años, meses y días (¡incluso en horas, minutos y segundos!), pero es una labor por ahora solo apta para los más atrevidos/as. ### 3.6. Ejercicios resueltos A continuación, vamos a mostrar la solución de algunos de los ejercicios anteriores. No de todos, porque entonces este texto sería interminable, pero si de bastantes de ellos. Ten en cuenta que, **en muchas ocasiones, hay más de una solución posible** igualmente válida. Si tú has logrado resolver el ejercicio por otra vía, puede que hayas dado con una de esas otras soluciones. Sin embargo, también hay soluciones inaceptables por su poca eficiencia aunque, en apariencia, parezcan funcionar bien. Ten en cuenta que, para ir de Almería a Granada, se puede ir por la autovía A-92 o se puede dar un rodeo por Barcelona. O por Júpiter y Saturno. De todos esos modos conseguiremos llegar a Granada, pero las últimas soluciones son tan ineficientes que no resultan aceptables. Lo mismo ocurre con los programas informáticos. Cuando tu solución sea muy diferente de la mía, pregúntate si la tuya da un rodeo mucho mayor que la mía para llegar al mismo sitio, o si, por el contrario, es igual de eficiente (¡o incluso más!). En este caso, enhorabuena: has dado con una de esas soluciones alternativas de las que hablaba. Por último, permíteme un consejo: **intenta resistir la tentación de mirar la solución a los ejercicios antes de hacerlos**. Es muy conveniente que pases un rato tratando de resolver los problemas por ti mismo/a antes de mirar la solución. Al menos, es muy conveniente si tu intención es aprender a programar. #### Ejercicios con estructura secuencial **Ejercicio 1**. Calcular el área y la circunferencia de un círculo cuyo radio será proporcionado a través del teclado. Recuerda que área = 3.14 x r x r y circunferencia = 2 x 3.14 x r *Solución en pseudocódigo:* ``` Algoritmo area_circulo Definir radio, area, circunferencia Como Real Escribir \"Dime el radio\" Leer radio area = 5 Entonces escribir \"Has aprobado, enhorabuena\" SiNo escribir \"Has suspendido, sigue jugando\" FinSi FinAlgoritmo ``` *Solución en diagrama de flujo:* ![Diagrama de flujo media_examenes](/docs/prog-y-3d/_site/assets/ejercicios-resueltos-pseint/03_02_media_examenes.png) **Ejercicio 3**. Calcular el precio de llenar una piscina de agua. Para ello se tienen que pedir al usuario las medidas de la piscina (largo, ancho y alto) y el precio del m​3​ del agua. Se mostrará el precio total. Supondremos que la piscina es de forma regular. *Solución en pseudocódigo:* ``` Algoritmo piscina Definir largo, ancho, alto como real Definir preciom3 como real Definir costeTotal Como Real Escribir \"¿Cuál es el largo de la piscina (en cm)?\" Leer largo Escribir \"¿Cuál es el ancho de la piscina (en cm)?\" Leer ancho Escribir \"¿Cuál es el alto de la piscina (en cm)?\" Leer alto Escribir \"¿Cuál es el precio del metro cúbico de agua (en euros)?\" Leer preciom3 coste 0 Entonces escribir \"El número es POSITIVO\" FinSi si n -10 y n -100) o (n >= 10 y n -1000) o (n >= 100 y n -10000) o (n >= 1000 y n -100000) o (n >= 10000 y n = 100000 Entonces Escribir \"Error, ese número tiene más de 5 cifras\" SiNo Escribir \"El número de cifras del número \", n, \" es \", numCifras FinSi FinAlgoritmo ``` *Solución en diagrama de flujo:* ![Diagrama de flujo contar-cifras](/docs/prog-y-3d/_site/assets/ejercicios-resueltos-pseint/03_12_contar_cifras.png) **Ejercicio 14**. Escribir todos los números entre 1 y n, siendo n un entero introducido por teclado. *Solución en pseudocódigo:* ``` Algoritmo contar_de_uno_a_n Definir n,i Como Entero Escribir 'Dime un número' Leer n i maximo) Entonces maximo = 1 y numero_apuesta 0 y cantidad_apuesta \"Ninguno\" o tablas = Verdadero mostrar(tablero) Si ganador = \"Ninguno\" Entonces Escribir \"El juego ha terminado en tablas\" SiNo Escribir \"El juego ha terminado. El ganador es: \", ganador FinSi FinAlgoritmo // -------------------------------------------- // Inicializa el tablero con espacios en blanco // -------------------------------------------- SubAlgoritmo inicializar(tablero por referencia) Definir i como entero Para i \" \") Entonces contador <- contador + 1 FinSi FinPara // Si todas las casillas están ya ocupadas y no hay ganador, // entonces estamos en tablas. Si contador = 9 Entonces tablas <- Verdadero SiNo tablas <- Falso FinSi FinSubAlgoritmo ``` (No mostramos la solución en diagrama de flujo porque ocupa demasiado espacio. No obstante, si te interesa verla, solo tienes que escribir el programa en PSeInt y pedirle que te muestre el diagrama de flujo equivalente) ",
    "url": "/docs/prog-y-3d/_site/introduccion-a-la-programacion/",
    "relUrl": "/introduccion-a-la-programacion/"
  },"4": {
    "doc": "4. Estructuras de datos. Subalgoritmos",
    "title": "4. Estructuras de datos. Subalgoritmos",
    "content": "# 4. Estructuras de datos. Subalgoritmos {: .no_toc } - TOC {:toc} Hasta ahora, hemos conocido las estructuras de control básicas de cualquier programa estructurado: secuencia, condición e iteración. Pero los programas no se componen solo de *instrucciones*, sino también de ***datos***. Todos los datos que hemos manejado hasta ahora eran simples, es decir, se almacenaban en variables en las que solo podíamos guardar un valor en cada momento. Las variables simples se nos quedan cortas en muchas ocasiones (repasa el programa de las 3 en raya, sin ir más lejos, para comprobarlo). En esos casos necesitamos una variable de tipo complejo o **estructura de datos**. En este capítulo hablaremos de las estructuras de datos y nos centraremos en la más utilizada con diferencia: el **array**. Después, introduciremos los conceptos de **subalgoritmo, función y biblioteca de funciones**, para terminar hablando de uno de los principios básicos de la ingeniería del software: la **reutilización del código**. ## 4.1. Estructuras de almacenamiento de datos Hemos trabajado, por el momento, con los tipos de datos básicos: enteros, reales, caracteres, lógicos... Es el momento de dar el salto a los **tipos de datos complejos**, también llamados **estructuras de datos**. Las estructuras de datos pueden ser de dos tipos: * **Estáticas**: son aquellas que ocupan un espacio determinado en la memoria del ordenador. Este espacio es invariable y se especifica durante la escritura del código fuente. * **Dinámicas**: son aquellas cuyo espacio ocupado en la memoria puede modificarse durante la ejecución del programa. Existe todo un universo de estructuras de datos: desde los arrays, presentes en casi cualquier programa, hasta estructuras mucho más exóticas como pilas, colas, listas enlazadas, árboles, grafos, etc. Nosotros no pretendemos verlas todas, ni mucho menos, pero sí que conozcas la más importante de todas: el array. ## 4.2. Arrays unidimensionales (vectores) Un **array** (también llamado **arreglo**, sobre todo en América latina) es una *agrupación de muchos datos individuales del mismo tipo bajo el mismo nombre*. Cada dato individual de un array es accesible mediante un índice. Por ejemplo, un array de números enteros es una colección de muchos números enteros a los que les adjudicamos un único identificador. El caso más simple de array es el **array unidimensional**, también llamado **vector**. Se trata, sin duda, del rey de las estructuras de almacenamiento. ### 4.2.1. Declaración de vectores La **declaración de un vector** en pseudocódigo (seguiremos usando la sintaxis de PSeInt) se hace así: ``` Definir nombre_variable Como tipo Dimension nombre_variable[tamaño] ``` Por ejemplo: ``` Definir serie como Entero Dimension serie[10] ``` La variable *serie* será un vector que contendrá 10 números enteros. Todos los números recibirán el mismo nombre, es decir, *serie*. Se puede acceder a cada uno de los números que forman el vector escribiendo a continuación del nombre un número entre corchetes. Ese número se denomina **índice**. Observa el siguiente ejemplo: ``` Definir serie como Entero Dimension serie[5] serie[2] +------------+----+----+----+----+----+ | Posiciones | 0 | 1 | 2 | 3 | 4 | serie = +------------+----+----+----+----+----+ | Valores | ? | ? | 20 | 15 | 35 | +------------+----+----+----+----+----+ . Observa algo muy importante: **el primer elemento del vector tiene el índice 0**, es decir, el primer elemento es **serie[0]**. Como este vector tiene 5 elementos, el último será serie[4], no serie[5]. Observa también que los elementos 0 y 1 no han sido utilizados y, por lo tanto, tienen un valor desconocido, exactamente lo mismo que ocurre con cualquier variable de tipo simple que no se inicialice. *(Nota: PSeInt se puede configurar para que el primer elemento del vector tenga índice 1, no 0, pero, como la mayor parte de los lenguajes de programación reales usan el 0, supondremos que PSeInt también lo está haciendo)* Como es lógico, se pueden construir vectores cuyos elementos sean de cualquier otro tipo simple, como números reales o caracteres, con la única restricción de que todos los elementos sean del mismo tipo. Y, por supuesto, pueden construirse vectores cuyos elementos sean otros vectores. Obtendremos así un array bidimensional, del que hablaremos un poco más adelante. ### 4.2.2. Manipulación de elementos de un vector Los vectores deben manipularse **elemento a elemento**. *No se pueden modificar todos los elementos a la vez.* Por ejemplo, **para asignar valores a los elementos de un vector**, esta sería la manera: ``` Definir serie como Entero Dimension serie[5] serie[0] +----+----+----+----+----+----+----+----+----+----+ | 0 | 1 | 2 | 3 | 4 | 5 | 3 | 14 | 9 | 8 | +----+----+----+----+----+----+----+----+----+----+ . Después de la ordenación, nos quedará este otro vector: +----+----+----+----+----+----+----+----+----+----+ | 0 | 1 | 2 | 3 | 3 | 4 | 5 | 8 | 9 | 14 | +----+----+----+----+----+----+----+----+----+----+ . Del mismo modo, se pueden ordenar los elementos con cualquier otro criterio: de mayor a menor, primero los pares y luego los impares, o cualquier otro que nos resulte útil para resolver un problema. Métodos de ordenación de vectores hay muchos, algunos muy simples (e ineficientes) y otros muy elaborados, y constituyen un área de estudio muy interesante dentro de la algorítmica. Aquí vamos a presentar uno de los métodos más sencillos que existen para ordenar un vector, de modo que te resulte fácil entenderlo. Para aprender los métodos más complejos y rápidos ya tendrás tiempo en el futuro, ¿no te parece? #### Ordenación mediante selección directa La **selección directa** es probablemente el método de ordenación más fácil de entender porque es lo que la mayoría de nosotros haríamos si tuviéramos que ordenar un conjunto de elementos a mano. Esto no quiere decir que sea fácil de programar para un principiante, pero vamos a intentarlo. Vamos a suponer que tratamos de ordenar un vector de números enteros de menor a mayor pero, como hemos dicho, la misma idea podría emplearse para ordenar cualquier otra cosa y mediante cualquier otro criterio. El método de selección directa recorre el vector desde el principio hasta localizar el elemento más pequeño, guardando su posición y su valor en dos variables que llamaremos *posicion_minimo* y *valor_minimo*. Al terminar, coloca ese elemento mínimo en la primera posición del vector y lo intercambia con el elemento que antes ocupaba esa primera posición. (Para hacer ese intercambio de valores, es necesario usar una variable auxiliar que llamaremos *aux*). El proceso se repite, pero ahora desde la *segunda* posición del vector original. De nuevo volvemos a buscar el elemento más pequeño mirándolos todos de uno en uno. Al terminar, colocamos ese elemento mínimo en la *segunda* posición del vector, intercambiándola por el número que antes estaba en la segunda posición. Volvemos a hacerlo, ahora desde la *tercera* posición del vector original, y así sucesivamente hasta terminar de recorrer el vector completo. **Observa con detenimiento el código fuente de esta implementación**. No pases por él de puntillas para dedicarte a otra cosa. Dedica unos minutos para tratar de ejecutarlo *a mano*, es decir, con papel y lápiz, apuntando el valor de las variables para ver cómo actúa el algoritmo y cómo construye, pasada tras pasada, el vector ordenado. ``` Algoritmo seleccion_directa Definir i, j, aux Como Entero Definir valor_minimo, posicion_minimo Como Entero Definir vector Como Entero Dimensión vector[100] // Primero, vamos a llenar el vector_original con valores al azar entre 1 y 500, por ejemplo Para i desde 0 hasta 99 Hacer vector[i] = 0 Entonces Escribir \"El dato \", dato, \" estaba en la posición \", posicion SiNo Escribir \"No he encontrado el dato \", dato, \" en el vector\" FinSi ``` #### Búsqueda binaria Para que esta búsqueda funcione, como hemos dicho, **el vector debe estar previamente ordenado**. El **método de búsqueda binaria** consiste en lo siguiente: * **Paso 1**. Supongamos que v es el vector y que contiene N elementos. Llamaremos *izq* a la posición del elemento izquierdo del array (inicialmente, izq = 0). Llamaremos *der* a la posición del elemento derecho del array (inicialmente, der = N-1) * **Paso 2**. Tomamos un x igual al punto medio entre izq y der, es decir, x busc Entonces // Seguiremos buscando por la mitad izquierda der 2N pasos. ¿No te parece una diferencia muy impresionante? Fíjate en estos datos: * Si el vector es pequeño (por ejemplo, N = 10): * a. La búsqueda secuencial necesita una media de 5 pasos. * b. La búsqueda binaria necesita una media de 3 pasos. * Si el vector es mediano (por ejemplo, N = 100): * a. La búsqueda secuencial necesita una media de 50 pasos. * b. La búsqueda binaria necesita una media de 6 ó 7 pasos. * Si el vector es grande (por ejemplo, N = 1000), la mejora de tiempo empieza a ser notable: * a. La búsqueda secuencial necesita una media de 500 pasos. * b. La búsqueda binaria necesita una media de… ¡10 pasos! * Si el vector es muy grande (por ejemplo, N = 100.000), la mejora de tiempo es aún mayor: * a. La búsqueda secuencial necesita una media de 50.000 pasos. * b. La búsqueda binaria necesita una media de sólo 16 pasos. La mejora en el tiempo de búsqueda es, por lo tanto, mayor cuanto mayor es el vector. Por eso dijimos que la búsqueda binaria se emplea cuando los vectores son muy grandes. ## 4.3. Arrays bidimiensionales (matrices) Una **matriz**, **tabla** o **array bidimiensional**, igual que un vector, es una colección de elementos individuales, todos del mismo tipo, agrupados bajo el mismo identificador. La diferencia con el vector es que, en el momento de declararlo y de acceder a cada elemento individual, debemos utilizar **dos índices** en lugar de uno. Una matriz de, por ejemplo, 4x4 elementos, se declara así: ``` Definir matriz como Entero Dimension matriz[4][4] ``` La variable *matriz* no consta de 4 elementos enteros, sino de 16, organizados en 4 filas y 4 columnas. Podemos representar gráficamente la matriz como una tabla: Filas | V +----+----+----+----+----+ | 0 | 1 | 2 | 3 | **Cada casilla de la matriz es identificable mediante una pareja de índices**. Normalmente, el primero de los índices se refiere a la fila y, el segundo, a la columna. Por ejemplo, si hacemos estas asignaciones: ``` matriz[0][0] Filas | V +----+----+----+----+----+ | 0 | 1 | 2 | 3 | Por descontado, los dos tamaños de la matriz pueden ser diferentes, obteniéndose tablas que son más anchas que altas o más altas que anchas. Por lo demás, **las matrices se utilizan exactamente igual que los vectores**. A modo de ejemplo, este sería el código para inicializar una matriz de 5x10 enteros con todos sus elementos a 0. Observa cómo se usan los dos bucles anidados para acceder a todos los elementos: ``` Definir i, j como Entero Definir m como Entero Dimension m[5][10] Para i 0 Entonces i b) y (c > d * raiz(k) ) entonces a b)y(c>d*raiz(k))entonces a b)``` o ```(a>b)```, pero a cualquier programador que deba leer nuestro código le resultará mucho más cómoda la primera forma. Por la misma razón, también es conveniente dejar líneas en blanco entre determinadas instrucciones del algoritmo cuando se considere que mejora la legibilidad. #### Identificadores A la hora de elegir identificadores de variables (o de algoritmos y subalgoritmos) es muy importante utilizar **nombres que sean significativos**, es decir, que den una idea de la información que almacena esa variable. Por ejemplo, si en un programa de nóminas vamos a guardar en una variable la edad de los empleados, es una buena ocurrencia llamar a esa variable \"edad\", pero no llamarla \"x\", \"a\" o \"cosa\". Ahora bien, dentro de esta política de elegir identificadores significativos, es conveniente optar por aquellos que sean lo más cortos posible, siempre que sean descifrables. Un identificador llamado \"edad_de_los_empleados\" es engorroso de escribir y leer, sobre todo si aparece muchas veces en el algoritmo, cuando probablemente \"edad_empl\" proporciona la misma información. Sin embargo, si lo acortamos demasiado (por ejemplo \"ed_em\") llegará un momento en el no quede claro lo que significa. Toda esta idea de significación de los identificadores es extensible a los nombres de los algoritmos, de las funciones, de los procedimientos, de los archivos y, en general, de todos los objetos relacionados con un programa. Por último, señalar que muchos lenguajes de programación distinguen entre mayúsculas y minúsculas, es decir, que para ellos no es lo mismo el identificador \"edad\" que \"Edad\" o \"EDAD\". Por convenio, los algoritmos suelen nombrarse con la primera letra en mayúscula y el resto en minúsculas, mientras que las variables y funciones suelen nombrarse con la todas las letras en minúscula. Excepción: si el identificador consta de más de una palabra. En ese caso, ¿cómo es conveniente escribirlo? Existen dos convenciones para eso: * **CamelCase**: si el identificador consta de más de una palabra, se escriben todas juntas y la primera letra de cada palabra se escribe en mayúsculas. Por ejemplo: ```edadEmpleado```. * **snake_case**: si el identificador consta de más de una palabra, se escriben separadas por el signo de subrayado (_). Por ejemplo: ```edad_empleado```. Elegir CamelCase o snake_case es una cuestión de gustos personales. Lo importante es que, optes por el estilo que optes, lo utilices siempre y no mezcles identificadores de un tipo con identificadores de otro. ## 4.6. Ejercicios propuestos Resuelve los siguientes ejercicios utilizando subalgoritmos cuando la complejidad del problema así lo requiera. Puedes hacerlo con todos, excepto los números 1, 2, 7 y 8, que son tan simples que difícilmente podrás sacar un subalgoritmo de ellos. #### Ejercicios de vectores (arrays unidimensionales) **Ejercicio 1: Inicializar un vector**. Escribe un programa en pseudocódigo en el que se defina un vector de 100 números enteros, se inicialicen todos los elementos al valor –1 y se impriman por pantalla. **Ejercicio 2: Inicializar un vector (más complejo)**. Define dos vectores de 100 números enteros, uno llamado *pares* y otro *impares*. Inicializa el primero con los 100 primeros números pares positivos (es decir, pares[0] contendrá el valor 2, pares[1] contendrá el valor 4, pares[2] contendrá el valor 6, y así sucesivamente). Inicializa el segundo con los 100 primeros números impares positivos. Imprímelo por pantalla para comprobar que lo has hecho correctamente. **Ejercicio 3: Lotería primitiva**. Escribe un programa que genere al azar una combinación para jugar a la lotería primitiva asegurándote de que ningún número se repite. Pista: puedes utilizar un array de 6 números enteros, asignando a cada posición un número entero aleatorio entre 1 y 49, y comprobando que el número asignado no es igual a ninguno de los asignados anteriormente. **Ejercicio 4. Estadística básica**. Escribe un programa que pida al usuario N números enteros (siendo N un valor introducido por teclado) y calcule el valor medio de todos ellos, mostrando luego en la pantalla los números que están por encima de la media y los que están por debajo de ella. **Ejercicio 5. Ordenar vector gigante**. Escribe un programa que defina un vector de 1000 elementos y lo inicialice con valores aleatorios entre 0 y 2.000.000. Posteriormente, el programa debe ordenar los elementos del array de menor a mayor. Prueba luego a cambiar el tamaño del vector hasta los 10.000, 100.000 y 1.000.000 de elementos. ¿El tiempo de respuesta del programa crece linealmente con el tamaño del vector? **Ejercicio 6. Vector creciente**. Escribe un programa que defina un vector de 10 enteros y lo rellene con números CRECIENTES al azar entre 1 y 100. Es decir, los números serán elegidos aleatoriamente pero siempre tienen que ser mayores que los anteriores: el número que ocupe la posición 1 debe ser mayor que el de la posición 0, el de la posición 2 mayor que el de la 1, y así sucesivamente. Después de eso, se pedirá al usuario un número entre 1 y el número mayor que exista en el vector. El número introducido por el usuario se insertará en la posición del vector adecuada para conservar el orden, desplazando los demás elementos hacia la derecha, de manera que se pierda el último elemento. Después de insertar el número introducido por el usuario, el contenido del vector debe mostrarse por la pantalla. El proceso se repetirá hasta que el usuario introduzca un número negativo. Por ejemplo, supongamos que el array generado al azar por el ordenador, después de ordenarlo, es este: 4 – 18 – 23 – 25 – 44 - 45 – 51 – 72 – 78 - 85 . Como el número más alto es 85, el programa debe pedir al usuario: Introduzca un número entre 1 y 85: _ . Si el usuario teclea, por ejemplo, el número 67, éste debe ser insertado en la posición adecuada para conservar el orden, es decir, entre los números 51 y 72, desplazando a los demás números hacia la derecha, con lo cual se pierde el mayor de todos ellos (85). El vector quedaría así: 4 – 18 – 23 – 25 – 44 - 45 – 51 – 67 - 72 – 78 . #### Ejercicios de matrices (arrays bidimensionales) **Ejercicio 7. Inicializar matriz simple**. Escribe un programa en el que se defina una matriz de 10x10 números enteros. Inicializa todos los elementos al valor –1. **Ejercicio 8. Inicializar matriz complejo**. Repite el ejercicio anterior, inicializando ahora todas las filas pares al valor 0 y todas las filas impares al valor –1. **Ejercicio 9. Sumar filas**. Escribe un programa que defina una matriz de 6x3 números enteros y luego pida al usuario que introduzca los valores de cada elemento. Después, el programa debe sumar los tres números de cada fila, mostrando los resultados. **Ejercicio 10. Permutar filas**. Escribe un programa que defina una matriz de 3x5 números enteros y luego pida al usuario que introduzca los valores de cada elemento. Después, debe permutar el contenido de la fila 3 por el de la fila 1, y mostrar por último el contenido de la matriz. **Ejercicio 11. Sumar matrices**. Escribe un programa que defina dos matrices de 10x5 números enteros y las inicialice con números aleatorios entre 0 y 255. Posteriormente, cada elemento de la primera matriz debe ser sumado con el mismo elemento de la segunda matriz, guardando el resultado en una tercera matriz. Se deben sumar todas las parejas de elementos y mostrar el resultado en la pantalla. **Ejercicio 12. Jugueteando con matrices**. Escribe un programa que genere al azar una matriz cuadrada de NxN números enteros (siendo N un valor introducido por el usuario) y que luego haga lo siguiente: * *Mostrar*. Mostrará la matriz tal y como ha sido generada. * *Perímetro*. Mostrará los elementos que ocupan el borde de la matriz, partiendo de la esquina superior izquierda y recorriéndola hacia la derecha y luego hacia abajo. * *Centro*. Mostrará los elementos que ocupan el centro geométrico de la matriz. Puede ser 1 (si N es impar) o 4 (si N es par). * *Espiral*. Hará un recorrido en espiral por la matriz partiendo de la esquina superior izquierda. Por ejemplo, si la matriz fuera de 4x4 y tuviera este contenido: ``` 4 6 7 8 2 4 3 9 0 1 3 4 7 3 3 5 ``` ...las distintas operaciones deben obtener este resultado: * Perímetro: 4 6 7 8 9 4 5 3 3 7 0 2 * Centro: 4 3 1 3 * Espiral: 4 6 7 8 9 4 5 3 3 7 0 2 4 3 3 1 ## 4.7. Ejercicios resueltos **Ejercicio 1: Inicializar un vector**. Escribe un programa en pseudocódigo en el que se defina un vector de 100 números enteros, se inicialicen todos los elementos al valor –1 y se impriman por pantalla. ``` Algoritmo InicializarVectorSimple Definir i, vector Como Entero Dimension vector[100] // Inicializamos el array Para i media Entonces Escribir vector[i] FinSi FinPara FinAlgoritmo ``` **Ejercicio 5. Ordenar vector gigante**. Escribe un programa que defina un vector de 1000 elementos y lo inicialice con valores aleatorios entre 0 y 2.000.000. Posteriormente, el programa debe ordenar los elementos del array de menor a mayor. Prueba luego a cambiar el tamaño del vector hasta los 10.000, 100.000 y 1.000.000 de elementos. ¿El tiempo de respuesta del programa crece linealmente con el tamaño del vector? ``` Algoritmo ordenar_array Definir n, i como Entero Definir vector Como Entero // Dimensionamos el array Escribir \"¿De qué tamaño quieres el array?\" Leer n Dimension vector[n] // Inicializamos el array con valores aleatorios Para i vector[j+1] Entonces aux = 1 y n v[posicion] posicion <- posicion + 1 FinMientras // Desplazamos el contenido del vector hacia la derecha desde esa posición Para i <- 8 hasta posicion con paso -1 hacer v[i+1] <- v[i] FinPara // Insertamos por fin el número y volvemos a mostrar el vector v[posicion] <- n mostrar_vector(v) FinAlgoritmo SubAlgoritmo mostrar_vector(v) Definir i como entero Para i desde 0 hasta 9 Hacer escribir sin saltar v[i], \" - \" FinPara Escribir \"\" FinSubAlgoritmo ``` **Ejercicio 7. Inicializar matriz simple**. Escribe un programa en el que se defina una matriz de 10x10 números enteros. Inicializa todos los elementos al valor –1. ``` Algoritmo inicializar_matriz_simple Definir fila, columna como entero Definir matriz como entero Dimension matriz(10,10) // Primero inicializamos la matriz Para fila <- 0 hasta 9 Hacer Para columna <- 0 hasta 9 Hacer matriz[fila, columna] <- -1 FinPara FinPara // Después mostramos la matriz por pantalla Para fila <- 0 hasta 9 Hacer Para columna <- 0 hasta 9 Hacer Escribir sin saltar matriz[fila, columna], \" \" FinPara Escribir \" \" // Hace el salto de línea al final de cada columna FinPara FinAlgoritmo ``` **Ejercicio 8. Inicializar matriz complejo**. Repite el ejercicio anterior, inicializando ahora todas las filas pares al valor 0 y todas las filas impares al valor –1. ``` Algoritmo inicializar_matriz_complejo Definir fila, columna como entero Definir matriz como entero Dimension matriz(10,10) // Primero inicializamos la matriz Para fila <- 0 hasta 9 Hacer Para columna <- 0 hasta 9 Hacer Si fila MOD 2 = 0 Entonces matriz[fila, columna] <- 0 SiNo matriz[fila, columna] <- -1 FinSi FinPara FinPara // Después mostramos la matriz por pantalla Para fila <- 0 hasta 9 Hacer Para columna <- 0 hasta 9 Hacer Si fila MOD 2 = 0 Entonces Escribir sin saltar \" \", matriz[fila, columna], \" \" SiNo Escribir sin saltar matriz[fila, columna], \" \" FinSi FinPara Escribir \" \" // Hace el salto de línea al final de cada columna FinPara FinAlgoritmo ``` **Ejercicio 12. Jugueteando con matrices**. Escribe un programa que genere al azar una matriz cuadrada de NxN números enteros (siendo N un valor introducido por el usuario) y que luego haga lo siguiente: * *Mostrar*. Mostrará la matriz tal y como ha sido generada. * *Perímetro*. Mostrará los elementos que ocupan el borde de la matriz, partiendo de la esquina superior izquierda y recorriéndola hacia la derecha y luego hacia abajo. * *Centro*. Mostrará los elementos que ocupan el centro geométrico de la matriz. Puede ser 1 (si N es impar) o 4 (si N es par). * *Espiral*. Hará un recorrido en espiral por la matriz partiendo de la esquina superior izquierda. Por ejemplo, si la matriz fuera de 4x4 y tuviera este contenido: ``` 4 6 7 8 2 4 3 9 0 1 3 4 7 3 3 5 ``` ...las distintas operaciones deben obtener este resultado: * Perímetro: 4 6 7 8 9 4 5 3 3 7 0 2 * Centro: 4 3 1 3 * Espiral: 4 6 7 8 9 4 5 3 3 7 0 2 4 3 3 1 ``` Algoritmo jugando_con_matrices // Atención: en esta solución supondremos que los arrays comienzan en el índice 0. // Si se configura PseInt para que empiecen en 1, habría que modificar el código, como es lógico. Definir matriz, tam Como Entero Escribir sin saltar \"Elige el tamaño de la matriz cuadrada: \" Leer tam Dimension matriz[tam,tam] inicializar_matriz(matriz, tam) mostrar_matriz(matriz, tam) perimetro(matriz, tam) centro(matriz, tam) espiral(matriz, tam) FinAlgoritmo SubAlgoritmo inicializar_matriz(matriz, tam) Definir f, c como entero Para f desde 0 hasta tam-1 hacer Para c desde 0 hasta tam-1 hacer matriz[f,c] <- azar(10) FinPara FinPara FinSubAlgoritmo SubAlgoritmo mostrar_matriz(matriz, tam) Definir f, c como entero Escribir \"MATRIZ:\" Para f desde 0 hasta tam-1 hacer Para c desde 0 hasta tam-1 hacer Escribir sin saltar matriz[f,c], \" \" FinPara Escribir \"\" FinPara FinSubAlgoritmo SubAlgoritmo perimetro(matriz, tam) Definir f, c como entero Escribir \"PERÍMETRO:\" Para c <- 0 hasta tam-1 Hacer Escribir sin saltar matriz[0, c], \" \" FinPara Para f <- 1 hasta tam-1 Hacer Escribir sin saltar matriz[f, tam-1], \" \" FinPara Para c <- tam-2 hasta 0 con paso -1 Hacer Escribir sin saltar matriz[tam-1, c], \" \" FinPara Para f <- tam-2 hasta 1 con paso -1 Hacer Escribir sin saltar matriz[f, 0], \" \" FinPara Escribir \"\" FinSubAlgoritmo SubAlgoritmo centro(matriz, tam) Definir c como entero Escribir \"CENTRO:\" Si tam % 2 = 0 entonces // Matriz de tamaño PAR. El centro consta de cuatro números c <- tam / 2 Escribir sin saltar matriz[c-1, c-1], \" \" Escribir sin saltar matriz[c-1, c], \" \" Escribir sin saltar matriz[c, c-1], \" \" Escribir sin saltar matriz[c, c] SiNo // Matriz de tamaño IMPAR. El centro es un solo número c <- trunc(tam / 2) Escribir sin saltar matriz[c, c] FinSi Escribir \"\" FinSubAlgoritmo SubAlgoritmo espiral(matriz, tam) Definir f, c, inicio, final como entero Escribir \"ESPIRAL:\" inicio <- 0 final <- tam-1 Mientras inicio < final hacer Para c <- inicio hasta final Hacer Escribir sin saltar matriz[inicio, c], \" \" FinPara Para f <- inicio+1 hasta final Hacer Escribir sin saltar matriz[f, final], \" \" FinPara Para c <- final-1 hasta inicio con paso -1 Hacer Escribir sin saltar matriz[final, c], \" \" FinPara Para f <- final-1 hasta inicio+1 con paso -1 Hacer Escribir sin saltar matriz[f, inicio], \" \" FinPara inicio <- inicio + 1 final <- final - 1 FinMientras Escribir \"\" FinSubAlgoritmo ``` ",
    "url": "/docs/prog-y-3d/_site/estructuras-de-datos/",
    "relUrl": "/estructuras-de-datos/"
  },"5": {
    "doc": "5. Lenguaje Javascript",
    "title": "Ventana nerviosa",
    "content": "Saltar Temblar Ocultar Mostrar ``` Lo siguiente es programar el código de cada una de las cuatro funciones Javascript, que se ejecutarán al pulsar cada botón. No te voy a decir lo que tienes que escribir en ellas, pero sí te voy a dar un par de pistas: * **Pista nº 1**. Hay un objeto en Javascript llamado ***window***, que nos permite alterar las propiedades de la ventana del navegador. Por ejemplo, nos permite cambiar su posición y su tamaño. En el apartado 5.2.11, sobre *Objetos predefinidos de Javascript*, hablamos de qué modo se puede cambiar eso. Observa que, en el fragmento de código anterior, hemos creado un objeto *window* llamado ***myWindow***. Es sobre ese objeto sobre el que tienes que actuar. * **Pista nº 2**. En el ejercicio anterior cambiábamos las propiedades *top* y *left* de un botón, pero los botones (y cualquier cosa que haya en una página web) tienen muchas otras propiedades (¡pero MUCHAS!). Una de ellas se llama ***visibility***, y puede tomar dos valores: *visible* o *hidden*. #### Ejercicio 5. Colorines Vamos a juguetear más con las propiedades de la página web cargada desde Javascript. En esta ocasión, construiremos una página con un cuadro de texto, un botón y un recuadro de color negro. Si escribimos en la caja de texto otro color (por ejemplo, \"orange\") y hacemos click en el botón, **el recuadro negro tiene que cambiar de color** y volverse naranja. El código HTML que puedes usar como base es este: ```html Colorines . ",
    "url": "/docs/prog-y-3d/_site/javascript/",
    "relUrl": "/javascript/"
  },"6": {
    "doc": "5. Lenguaje Javascript",
    "title": "Colorines",
    "content": "Cambiar color . ``` Observa que, además de preparar los tres elementos que necesitamos (el recuadro de color negro, la caja de texto y el botón), hemos añadido más elementos HTML como *head* o *title*. Esos elementos son necesarios para que la página web se considere bien formada. Si no sabes lo que significan (aunque es bastante evidente), puedes repasarlos en el capítulo dedicado a HTML. (El navegador se tragará la página web aunque no esté bien formada, pero lo correcto es hacerla bien dentro de lo posible). Ahora solo te falta escribir el código de la función Javascript para cambiar el color del recuadro. #### Ejercicio 6. Pelota de goma Busca en internet una imagen de una pelota que te guste y descárgala. En esa imagen no debe aparecer nada más, excepto la pelota. Luego insértala en una página web, así: ```html ``` En *'nombre-del-archivo-de-la-imagen'*, como es lógico, tendrás que escribir el nombre del archivo que contiene tu pelota. Le hemos asignado 100 píxeles de ancho y 100 de alto, pero si es demasiado pequeña o demasiado grande, siéntete libre de cambiar esas cantidades. **Ahora escribe en Javascript un programa para que la pelota rebote por la pantalla como si fuera una pelota de verdad.** Para conseguirlo, tendrás que: * Alterar de nuevo las propiedades *top* y *left* de la pelota * Usar las propiedades el objeto ***window*** para evitar que la pelota se salga de los márgenes de la pantalla. * Utilizar un **temporizador** para mover la pelota cada x milisegundos. Según el valor de x, la pelota se moverá más deprisa o más despacio. **Mejora para los más valientes**: trata de añadir un botón a este programa. Al pulsarlo, la pelota se detendrá. Al volver a pulsarlo, la pelota se pondrá en marcha de nuevo. #### Ejercicio 7. Tres en raya improved **Modifica el juego de las tres en raya para que sea más atractivo al usuario y más cómodo de jugar.** Encontrarás el código fuente del juego más arriba, en este mismo capítulo. Tienes que eliminar todas las entradas de datos mediante *prompt()* y sustituirlas por cajas de texto HTML, como esta: ```html ¿En qué casilla quieres poner tu pieza? (1-9) Aceptar ``` Al hacer clic en el botón, se ejecutará la función *colocar_pieza()*. Observa cómo se extrae el texto escrito en el cuadro de texto para llevárnoslo a una variable de Javascript (llamada *casilla*). También puedes mejorar la apariencia del juego alterando sus colores, tipografías, etc. Tendrás que investigar un poco en internet sobre cómo puede hacerse eso. #### Ejercicio 8. Tenis (Aviso: este ejercicio es de dificultad elevada) Ya sabes hacer que una pelota rebote (ejercicio 5). **Vamos a mejorar ese programa haciendo una versión del clásico juego de tenis *\"Pong\"***, el primer videojuego comercial de la historia. Si no conoces el *Pong*, bichea un poco por Internet para averiguar cómo es. ¡Y ahora trata de programar una versión actualizada en Javascript! #### Ejercicio 9. Carretera al infierno (Aviso: este ejercicio es de dificultad elevada) En esta ocasión, vamos a programar **un juego que llamaremos \"Carretera al infierno\"**. En el juego, manejaremos un coche (busca en internet la imagen de un coche visto desde arriba). El coche aparecerá en la parte inferior de la pantalla, centrado y mirando hacia arriba. Una carretera irá desplazándose de arriba a abajo. La carretera no será recta, sino que tendrá irregularidades aleatorias hacia la izquierda y hacia la derecha. Nuestro objetivo es mover el coche hacia la izquierda y hacia la derecha para evitar que se salga de la carretera. La carreterá se moverá cada vez más deprisa. **El objetivo del juego es aguantar la mayor cantidad posible de tiempo sin salirnos.** ## 5.7. Ejercicios resueltos Aquí iremos poniendo los ejercicios que resolvamos en clase. #### Ejercicio 1. Tabla de multiplicar ```html ",
    "url": "/docs/prog-y-3d/_site/javascript/",
    "relUrl": "/javascript/"
  },"7": {
    "doc": "5. Lenguaje Javascript",
    "title": "Tabla de multiplicar",
    "content": "``` ",
    "url": "/docs/prog-y-3d/_site/javascript/",
    "relUrl": "/javascript/"
  },"8": {
    "doc": "5. Lenguaje Javascript",
    "title": "5. Lenguaje Javascript",
    "content": "# 5. El lenguaje Javascript {: .no_toc } - TOC {:toc} El ordenador, como ya sabes, solo puede manejar ceros y unos, es decir, código o **lenguaje binario**. Los seres humanos, por el contrario, utilizamos un lenguaje mucho más complejo, con montones de símbolos y reglas sintácticas y semánticas, que denominamos **lenguaje natural** (aunque de \"natural\" tiene poco). Entre estos dos extremos (lenguaje binario y lenguaje natural) se encuentran los **lenguajes de programación**. Tienen cierto parecido con el lenguaje natural, pero son mucho más reducidos y estrictos en su sintaxis y semántica, para acercarse a las limitaciones del lenguaje binario. En este capítulo vamos a aprender a escribir algoritmos con un lenguaje de alto nivel llamado **Javascript**. Se trata de un lenguaje que ha alcanzado una popularidad enorme gracias a que se encuentra incrustado en todas las páginas web que visitas a diario. Javascript es la piedra angular de cualquier web, pero también puede usarse como un lenguaje de programación convencional para escribir algoritmos de forma rápida, que es lo que vamos a hacer en este tema. Lenguajes de programación hay muchos, así que también hablaremos de otros lenguajes y conoceremos los tipos y características de algunos de ellos. ## 5.1. Orientándose en la jungla de los lenguajes de programación Los lenguajes de programación constituyen un ecosistema muy extenso y en constante evolución. Para orientarse un poco en esa jungla, nada mejor que clasificar los lenguajes igual que los biólogos clasifican a las criaturas vivas. ### 5.1.1. Tipos de lenguaje según el nivel de abstracción: alto y bajo nivel Hay lenguajes de programación muy próximos al lenguaje binario: a éstos los llamamos **lenguajes de bajo nivel** de abstracción. Y los hay más próximos al lenguaje natural: son los **lenguajes de alto nivel** de abstracción. #### Lenguajes de bajo nivel Son los lenguajes más cercanos a la máquina. Los programas directamente escritos en código binario se dice que están en **lenguaje máquina** que, por lo tanto, es el lenguaje de más bajo nivel que existe. Las instrucciones del lenguaje máquina realizan tareas muy sencillas, como, por ejemplo, sumar dos números, detectar qué tecla se ha pulsado en el teclado o escribir algo en la pantalla del ordenador. Cuando se combinan adecuadamente muchas de estas instrucciones sencillas se obtiene un programa de ordenador que puede realizar tareas muy complejas. Por ejemplo, este puede ser el aspecto de una instrucción en lenguaje máquina para sumar dos números: ``` 0001 000100000101 110100110101 ``` Incomprensible, ¿verdad? A pesar de la simplicidad de las instrucciones del lenguaje máquina, la forma de escribirlas es muy complicada, ya que hay que hacerlo en binario. En los primeros años de la informática los ordenadores se programaban directamente en lenguaje máquina, lo cual convertía la tarea de programar en una verdadera pesadilla. Hoy en día nadie lo hace. Cuando los ordenadores fueron haciéndose más potentes, surgió la idea de utilizar el propio ordenador como **traductor**: ¿por qué no escribir instrucciones en un lenguaje más parecido al natural y que un programa de ordenador se encargue de traducir esa instrucción a su correspondiente instrucción en lenguaje máquina? Así apareció el **lenguaje ensamblador**, cuyas instrucciones son equivalentes a las del lenguaje máquina, pero se escriben con palabras similares a las del lenguaje humano. Por ejemplo, para sumar dos números, la instrucción en ensamblador puede tener un aspecto como este: ``` ADD D1 D2 ``` #### Lenguajes de alto nivel Siguiendo el razonamiento anterior (utilizar el propio ordenador como traductor), en la década de 1960 y, sobre todo, de 1970, se empezaron a desarrollar lenguajes cada vez más complejos, en los que cada instrucción ya no se correspondía exactamente con una instrucción del lenguaje máquina, sino con varias. Estos son los **lenguajes de alto nivel**. Lógicamente, la traducción desde un lenguaje de alto nivel a lenguaje máquina es mucho más compleja que desde lenguaje ensamblador, por lo que *los traductores se han hecho cada vez más complicados*. Una característica muy importante de los lenguajes de alto nivel es que **son independientes del hardware**, lo que implica que los programas desarrollados con estos lenguajes pueden ser ejecutados en ordenadores con hardware totalmente distinto. A esto se le llama **portabilidad**. Los programas encargados de traducir el código de alto nivel a código máquina se llaman **compiladores** e **intérpretes**. Son programas muy complejos que generan el código binario equivalente al código de alto nivel para una máquina concreta. Por lo tanto, el programa de alto nivel, que es portable de un hardware a otro, debe ser traducido a código máquina en cada tipo de máquina en la que se pretenda ejecutar. Los ejemplos de lenguajes de alto nivel son innumerables, y la lista incluye casi todos de los que has oído hablar alguna vez: Basic, Cobol, Fortran, Ada, C/C++, PHP, Python, Java, Perl, Ruby, Javascript, etc. #### Ventajas e inconvenientes de los lenguajes de alto y bajo nivel **LENGUAJES DE BAJO NIVEL**|**LENGUAJES DE ALTO NIVEL** -|- **Ventajas**|**Inconvenientes** Son comprensibles directamente por la máquina (aunque el ensamblador necesita una pequeña traducción)|Necesitan ser traducidos por medio de complicados programas (compiladores e intérpretes) Los programas se ejecutan muy rápidamente (si están bien escritos, claro)|La traducción automática del código de alto nivel al código máquina siempre genera programas menos eficientes que si se escribieran directamente en binario Ocupan menos espacio en memoria|Ocupan más espacio en memoria Permiten controlar directamente el hardware, por lo que son apropiados para la programación de sistemas|En general, solo pueden acceder al hardware utilizando al sistema operativo como intermediario. Pero, entonces, ¿cómo programar el sistema operativo, que necesita controlar directamente el hardware? **Inconvenientes**|**Ventajas** Son completamente dependientes del hardware. Un programa escrito para determinado tipo de máquina no funcionará en un ordenador con diferente arquitectura.|Son portables, es decir, independientes del hardware. Un programa escrito en una máquina puede funcionar en otra con hardware distinto, siempre que se vuelva a traducir a binario en la máquina nueva. Incluso los programas más sencillos son largos y farragosos|Los programas son más sencillos, ya que una sola instrucción puede equivaler a varias instrucciones binarias. Los programas son difíciles de escribir, depurar y mantener|Los programas son más fáciles de escribir, depurar y mantener Es imposible resolver problemas muy complejos|Es posible, aunque difícil, enfrentarse a problemas muy complejos Si echas un vistazo a la tabla anterior comprenderás que, en general, **es preferible usar lenguajes de alto nivel** la gran mayoría de las veces, reservando los de bajo nivel para casos muy concretos, como el desarrollo de ciertas partes de los sistemas operativos. También hay que destacar que no todos los lenguajes de alto nivel son iguales. Los hay de más alto nivel que otros. El lenguaje C, por ejemplo, tiene menor nivel de abstracción que, por ejemplo, Java. Esto hace que los programas escritos en C sean más rápidos y eficientes que los escritos en Java, aunque también pueden llegar a ser más difíciles de escribir y depurar. ### 5.1.2. Tipos de lenguaje según su generación Los lenguajes de programación también se clasifican según la generación a la que pertenecen. El lenguaje máquina fue el lenguaje de primera generación. Los ensambladores fueron los lenguajes de segunda generación. A partir de ahí, surgió una explosión de lenguajes diferentes que podemos clasificar como: * **Lenguajes de tercera generación** (o **imperativos**), en los que el programador escribe una secuencia de instrucciones que el ordenador debe ejecutar en un orden preestablecido. Son los lenguajes más \"clásicos\": C, Basic, Cobol, Fortran, Pascal, etc. * **Lenguajes de cuarta generación** (o **4GL**), dirigidos a facilitar la creación de interfaces con el usuario y con otras aplicaciones, como las bases de datos. Un ejemplo de estos lenguajes es SQL, universalmente utilizado para manipular bases de datos y omnipresente en muchas aplicaciones web actuales. * **Lenguajes orientados a objetos**, que son una evolucuión de los lenguajes de tercera generación y que permiten construir con mayor facilidad y robustez programas modulares complejos. Ejemplos de lenguajes orientados a objetos son C++, C#, Java, Javascript, Python, PHP o Ruby. Algunos de ellos son multiparadigma, es decir, permiten programar con orientación a objetos pero también permiten hacer programación estructurada clásica, sin objetos. * **Lenguajes declarativos** y **lenguajes funcionales**, propios de la inteligencia artificial, como Prolog o Lisp. * **Otros** tipos aún más específicos: lenguajes concurrentes, paralelos, distribuidos, etc. En general, podemos decir que un programador acostumbrado a trabajar con un lenguaje de tercera generación puede aprender con poco esfuerzo cualquier otro lenguaje de tercera generación y, con algo más de trabajo, un lenguaje orientado a objetos. Sin embargo, el \"salto\" a otros tipos de lenguajes, como los declarativos, cuesta más porque las fundamentos de estos lenguajes son muy diferentes. ### 5.1.3. Tipos de lenguaje según su forma de traducción Cuando programamos en un lenguaje distinto del lenguaje máquina, **nuestro código debe ser traducido a binario** para que el ordenador pueda entenderlo y ejecutarlo. Existe un programa específico encargado de hacer esa traducción y que, dependiendo del lenguaje en el que hayamos escrito nuestro programa, puede ser un *ensamblador*, un *compilador* o un *intérprete*. #### Ensambladores Se llaman **ensambladores** los programas encargados de **traducir los programas escritos en ensamblador a código binario**. Sí, ya lo sé: se usa el mismo nombre para referirse al *lenguaje* de programación y al *traductor* de ese lenguaje a código máquina. Es un lío. Como el lenguaje ensamblador es muy próximo al binario, estos traductores son programas relativamente sencillos. #### Compiladores El **compilador** es un programa que traduce el **código de alto nivel a código binario**. Es, por tanto, parecido al ensamblador, pero mucho más complejo, ya que las diferencias entre los lenguajes de alto nivel y el código binario son muy grandes. El programa escrito en lenguaje de alto nivel se denomina programa fuente o **código fuente**. El programa traducido a código binario se llama programa objeto o **código objeto**. Por lo tanto, el compilador se encarga de convertir el programa fuente en un programa objeto. Una vez que se ha obtenido el código objeto ya no es necesario volver a realizar la traducción (o compilación), a menos que se haga alguna modificación en el programa fuente, en cuyo caso habría que volver a compilarlo. El código objeto, una vez generado, puede ejecutarse en la máquina en la que fue compilado, o en otra de similares características (procesador, sistema operativo, etc.). Cuando se usa programación modular, puede ser necesario un proceso previo de enlace de los diferentes módulos antes de poder construir el programa ejecutable. #### Intérpretes El **intérprete** es un programa que **traduce el código de alto nivel a código binario** pero, a diferencia del compilador, lo hace **en tiempo de ejecución**. Es decir, no existe un proceso previo de traducción de todo el código fuente a código binario, sino que se va traduciendo y ejecutando instrucción por instrucción. #### Compiladores frente a intérpretes El **intérprete** es notablemente **más lento** que el compilador, ya que realiza la traducción al mismo tiempo que la ejecución. Además, esa traducción se lleva a cabo siempre que se ejecuta el programa, mientras que el compilador sólo la hace una vez. Hay un evidente malgasto de recursos. Sin embargo, muchos lenguajes muy populares en la actualidad, como Javascript, PHP o Python, suelen ser interpretados y no compilados. Alguna ventaja tendrá la interpretación frente a la compilación, ¿no crees? Pues sí: la **gran ventaja de los intérpretes** es que hacen que **los programas sean más portables**. Así, un programa compilado en una máquina PC bajo Windows no funcionará en un Mac o en un PC bajo Linux, a menos que se vuelva a compilar el programa fuente en el nuevo sistema. En cambio, un programa interpretado funcionará en todas las plataformas, siempre que dispongamos del intérprete en cada una de ellas. **JavaScript** es un ejemplo de lenguaje interpretado tremendamente popular gracias al crecimiento de Internet. Los programas escritos con JavaScript (llamados comúnmente *scripts*) pueden funcionar en cualquier máquina que disponga de un intérperte Javascript, y resulta que todos los navegadores web tienen uno. Por eso, **cualquier programa escrito en Javascript puede ejecutarse prácticamente en cualquier ordenador del mundo** sin tocarle ni una coma. En cambio, **C++**, por ejemplo, es un lenguaje compilado, lo que hace que los programas desarrollados con estos lenguajes se ejecuten más rápido (¡pero mucho más rápido!) que sus equivalentes en JavaScript. Sin embargo, tendrás que volver a compilarlos si deseas ejecutarlos en una máquina con diferente hardware o diferente sistema operativo. ### 5.1.4. Tipos de lenguaje según su tipado Por *tipado* nos referimos a la forma en la que los lenguajes de programación usan los tipos de datos. Ya sabes: entero, carácter, lógico, etc. Es decir, las categorías a las que puede pertenecer una variable. Pues bien, según su tipado, los lenguajes pueden ser: * **De tipado fuerte**: los tipos de datos no pueden mezclarse. Por ejemplo, no puedes sumar un entero y un real, porque son números de distinto tipo. Y mucho menos sumar un entero con un carácter. * **De tipado débil**: los tipos de datos pueden mezclarse y el lenguaje hace las conversiones de tipos implícitas que le parezca oportunas. Así, en estos lenguajes podrías sumar un entero con un real, o incluso un entero con un carácter. ¿Que cuál sería el resultado? Buena pregunta. Tendrás que probarlo, porque eso depende de las conversiones de tipo que haga el lenguaje. * **De tipado estático**: los tipos de datos se asignan al escribir el código y no pueden cambiarse durante la ejecución. Esto es típico de los compiladores (aunque no de todos). * **De tipado dinámico**: los tipos de datos pueden cambiarse alegremente durante la ejecución. Esto es típico de los intérpretes. Las dos primeras categorías y las dos segundas no son excluyentes. Por ejemplo, pueden existir lenguajes de tipado débil y dinámico, o bien fuerte y estático. Las otras combinaciones (fuerte y dinámico, débil y estático) pueden darse pero son menos habituales. ### 5.1.5. El *top ten* de los lenguajes de programación Es difícil saber cuales son los lenguajes más populares en un determinado momento porque no existen estadísticas fiables a nivel mundial. Además, las cosas pueden cambiar mucho de un territorio a otro. Sin embargo, ciertos sitios de internet, como **GitHub**, almacenan enormes cantidades de proyectos de software. GitHub, de hecho, es el mayor almacén de código fuente conocido, de modo que sus estadísticas nos pueden dar una idea bastante exacta de cuál es el grado de uso de cada lenguaje. Según [Madnight](https://madnight.github.io/githut), un proyecto que recopila y publica estadísticas de uso de lenguajes en GitHub, el *top ten* de lenguajes de programación más usados en GitHub es: Puesto|Lenguaje|Porcentaje de uso|Variación de uso en 12 meses -|-|-|- 1|JavaScript|17.955%|-2.192% 2|Python|15.943%|+0.071% 3|Java|12.977%|+1.573% 4|Go|8.203%|-0.612% 5|TypeScript|7.212%|-0.276% 6|C++|6.683%|-0.251% 7|Ruby|6.488%|+0.303% 8|PHP|4.937%|-0.093% 9|C#|3.366%|-0.350% 10|C|2.958%|+0.068% El porcentaje de uso indica la proporción de proyectos en GitHub que usan ese lenguaje de programación sobre el total de proyectos. La última cifra señala la variación interanual del porcentaje de uso. Estos datos son de tercer cuatrimestre de 2021. Para obtener datos de otras fechas, puedes visitar la web [https://madnight.github.io/](https://madnight.github.io/) Ten en cuenta de nuevo que esto no son cifras de uso absoluto de los lenguajes a nivel mundial. Solo se trata de una pista de cuál es la situación. De hecho, si consultas otras estadísticas como el [TIOBE index](https://tiobe.com/tiobe-index/), encontrarás datos diferentes. Según las cifras de Madnight, Javascript continúa siendo el lenguaje preferido por la mayoría de los programadores (aunque está lejos de sus tiempos memorables, donde llegó a utilizarse en casi el 30% de los proyectos activos en Github). Viejas glorias como Java, C++, PHP y C aguantan muy bien el tipo, con unos números muy estables, porque tienen una base de programadores muy fieles a sus espaldas, mientras que algunos lenguajes recientes como Go y Typescript se han hecho un hueco en el ránking de los 10 más usados. ## 5.2. ¡Bienvenidos a Javascript! ### 5.2.1. Características básicas de Javascript * Javascript es un lenguaje de **alto nivel**. * Es **imperativo y estructurado**. Admite **orientación a objetos basada en prototipos**, no en clases (puede que no entiendas lo que significa esto, pero de momento no importa). * Su **tipado es débil y dinámico**. * La **sintaxis** de sus estructuras de control está **heredada del lenguaje C**, como la de Java, PHP o Python, por lo que guarda bastantes semejanzas con estos otros lenguajes. * Es un **lenguaje interpretado**, pensado para ser ejecutado dentro de un navegador web. Por lo tanto, no es particularmente eficiente, pero sí muy portable. Sin embargo, también existen **compiladores y precompiladores** que permiten construir con Javascript cualquier tipo de programa, no solo aplicaciones web. * Es **altamente portable**. Cualquier programa en Javascript debería poder ejecutarse sin ninguna adaptación particular en cualquier navegador web reciente. * Su integración con los navegadores web hace que pueda manipular cualquier página web, incluso después de estar cargada en el navegador. * Es uno de los lenguajes de programación **más populares** del mundo en la actualidad. Aunque se ha intentado reemplazar muchas veces, ningún otro lenguaje lo ha conseguido (de momento). ### 5.2.2. Breve historia de Javascript Javascript fue un lenguaje creado en la década de 1990 para el ya desaparecido navegador web **Netscape Navigator**. En aquellos primeros tiempos de internet, las páginas web eran sitios muy poco vistosos, con mucho texto y unas pocas imágenes, y Javascript pretendía introducir un poco de movimiento y dinamismo en esas páginas tan aburridas. **Internet Explorer**, el principal competidor de Netscape, respondió creando el **VB Script** y, posteriormente, un lenguaje muy similar a Javascript (pero no igual) llamado **JScript**. Esos lenguajes no tuvieron éxito e Internet Explorer terminó por aceptar la existencia de Javascript. Aquella competición entre Netscape e Internet Explorer se llamó *guerra de los navegadores* y, aunque Netscape la perdió y acabó desapareciendo, Javascript ha permanecido hasta hoy como el heredero directo aquella época convulsa. Desde entonces, Javascript ha tenido una evolución enorme, y ha pasado de ser apenas un lenguaje de juguete con el que se podían conseguir un puñado de efectos dinámicos en los sitios web a ser un lenguaje muy potente y bien definido, capaz de sustentar la estructura de aplicaciones web complejas. Hoy en día, Javascript suele utilizarse con librerías y *frameworks* que mejoran su estructura y aumentan su potencia. El estándar del lenguaje está publicado por la **ECMA** (European Computer Manufacturers Association) y se denomina **ECMAScript**. Todos los navegadores web respetan ese estándar en gran medida. ### 5.2.3. Sintaxis básica de Javascript #### Generalidades sintácticas Hay algunas normas básicas de la sintaxis de Javascript que tienes que conocer: * **Los bloques de código se marcan con las llaves** ( **{** y **}** ). Por ejemplo, después de una sentencia *while* (equivalente al *mientras* de pseudocódigo) hay que abrir una llave. El cuerpo de bucle comprenderá desde esa llave de apertura hasta la siguiente llave de cierre, así: ```javascript while (condicion) { Instrucción 1 del bucle Instrucción 2 del bulce ... Instrucción N del bucle } ``` La llave de cierre, por tanto, sería el equivalente al *FinMientras* de pseudocódigo. * Todas las instrucciones **terminan con un punto y coma** ( **;** ). Excepción: si una instrucción contiene un bloque marcado con llaves ( { ... } ), se considera que esa instrucción termina al cerrar el bloque, y en ese caso no hace falta poner punto y coma. ```javascript a = 10; // La instrucción de asignación termina con ; while (condicion) { // Cuerpo del bucle } // El bucle termina con }, así que no necesita ; ``` * Los **identificadores** de variables, funciones, etc., no pueden empezar con un número ni contener espacios o símbolos especiales, salvo el de subrayado ( _ ) ```javascript a5 = 1; // Identificador de variable válido 5a = 1; // Identificador de variable NO válido ``` * Las **cadenas de caracteres** pueden encerrarse entre **comillas simples** ( '...' ) o **comillas dobles** ( \"...\" ) ```javascript a = \"Soy una cadena\"; b = 'Yo también soy una cadena'; ``` * El lenguaje es **sensitivo a las mayúsculas**. Es decir, no es lo mismo que una variable se llame *edad* que *Edad* o *EDAD*. #### Tipos de datos primitivos Javascript utiliza varios tipos de datos simples llamados **primitivos**. Los más importantes son: * **number**: números enteros y reales, indistintamente. * **string**: cadenas de caracteres. * **boolean**: datos de tipo lógico, es decir, de los que solo pueden valer *true* (verdadero) o *false* (falso). Como es un lenguaje de tipado dinámico, esos tipos **pueden variar durante la ejecución**, dependiendo de lo que hagas con las variables. De hecho, Javascript es tan flexible que **ni siquiera es necesario declarar las variables** (aunque es aconsejable). Es decir, que puedes usar una variable cuando la necesites sin tener que declararla antes. Las variables en Javascript se declaran con las palabras clave **var** o **let**. Las diferencias entre una y otra tienen que ver con el ámbito de la variable y las veremos enseguida. Por ejemplo: ```javascript var a = \"Hola\"; let b = 1; var c; d = 3; ``` En el código anterior hemos declarado tres variables, a, b y c. Observa que, **al declarar una variable, no se especifica el tipo**: Javascript decidirá su tipo en función del valor que se le asigne. Así pues, el tipo de la variable a será *string*, y el de la variable b será *number*. ¿Qué pasará con el tipo de la variable c? Hasta que no se le asigne algún valor, permanecerá *undefined*. Fíjate, por último, en que no hemos declarado la variable d, sino que la hemos usado directamente. Esto también es válido en Javascript, aunque, en general, poco recomendable por razones que comentaremos luego. El tipo de esta variable también será *number*. ### 5.2.4. Conversiones de tipo Javascript, como hemos dicho, es un lenguaje de **tipado dinámico**. Es decir, que las variables pueden variar de tipo a lo largo del programa: ```javascript var a = 1; // Variable tipo number // Aquí pueden ir varias instrucciones más a = \"Hola\"; // Ahora la variable es de tipo string ``` Además, Javascript también es un lenguaje **débilmente tipado**, lo que significa que no hace comprobaciones estrictas de tipos a la hora de asignar un valor a una variable o de comparar dos expresiones. Por ejemplo, estas instrucciones son correctas: ```javascript a = 5; // La variable a es de tipo number b = \"A\"; // La variable b es de tipo string c = a + b; // ¿Qué ocurre si las mezclamos en una expresión? ``` ¿Qué resultado crees que obtendrás con una mezcla de tipos como esta? ¿Por qué no haces la prueba? Cuando mezclas tipos, estás dejando que el lenguaje de programación decida cuál será el resultado, por lo que puedes obtener resultados imprevisibles. Es mejor que tú controles qué conversiones de tipo se hacen. Para eso, Javacript dispone de varias herramientas: * **typeof**: Nos dice de qué tipo es una variable. ```javascript a = 5; document.write(typeof a); // En la pantalla, aparecerá escrito \"number\" ``` * **String**: Convierte la variable a un *string* (cadena de caracteres). ```javascript a = 5; // a es el número entero 5 b = String(a); // b es la cadena \"5\" ``` * **parseInt** y **parseFloat**: Convierte la variable a un *number* entero o real (es decir, a sin decimales o con decimales). ```javascript a = \"5 pollos\"; // a es una cadena b = parseInt(a); // Javascript tratará de convertir la cadena a un número entero document.write(b); // ¿Qué crees que aparecerá en la pantalla? ``` ### 5.2.5. Asignación y ámbito de las variables La **asignación** de valores a variables en Javascript es fácil de explicar: se hace con el **símbolo igual (=)**, no con el símbolo 0) { let c = 3; // Variable local al bloque if document.write(\"La variable a vale \", a, \", la variable b vale \", b, \" y la variable c vale \", c); } } ``` En este ejemplo tenemos 3 variables: * La variable a vuelve a ser **global**, lo que significa que será accesible desde cualquier parte de este programa. * La variable b es **local a la función**. Está disponible desde su declaración hasta la llave de cierre de la función. * La variable c es **local a su bloque**. Es decir, está disponible desde su declaración hasta la llave de cierre del *if*. #### No declarar las variables Con Javascript, como ya hemos visto, es perfectamente posible **no declarar las variables** y usarlas sin más. Sin embargo, cuando haces este tipo de cosas, dejas que sea el lenguaje de programación el que tome decisiones por ti. En este caso, que decida sobre el ámbito de la variable. Por eso mi consejo es que *siempre* declares las variables, aunque no les asignes ningún valor inicial. Si decides usar las variables sin declarar, tienes que saber que Javascript las considerará a todas **globales**, independientemente del punto del programa donde hayas usado la variable por primera vez. ```javascript a = 1; // Variable global function mostrarMensaje() { b = 2; // Variable global if (b > 0) { c = 3; // Variable global document.write(\"La variable a vale \", a, \", la variable b vale \", b, \" y la variable c vale \", c); } } ``` ### 5.2.6. Operadores y expresiones Los **operadores y expresiones en Javascript** son iguales que los que hemos empleado en pseudocódigo: * Operadores **aritméticos**: +, -, \\*, /, % (este último significa *módulo de la división*). * Operadores **relacionales**: >, =, 0) { i--; // Equivalente a: i = i - 1 } ``` * Los **operadores lógicos** (Y, O, NO) se escriben de forma distinta: * **Y** se escribe **&&**. * **O** se escribe **\\|\\|**. * **NO** se escribe **!** (sí, sí, es una admiración). ```javascript if (a > 0) && (b > 0) { // Operador Y: tienen que darse las dos condiciones a la vez ... } ``` Hay algunas otras diferencias, desde luego, pero con esto ya tienes para hacer un buen montón de programas. ### 5.2.7. Estructuras de control Las **estructuras de control** en Javascript son muy similares a las que hemos utilizado en pseudocódigo, cambiando ligeramente la notación empleada. A continuación te muestro una tabla con las más habituales y su equivalente en pseudocódigo, sin entrar en explicaciones, porque supondremos que ya sabes manejarlas. Si no recuerdas para qué servía alguna de ellas, quizá sería buena idea que le dieras un repaso al capítulo dedicado al pseudocódigo. | Instrucción | Pseudocódigo | Javascript | . | Condicional simple | Si condición entonces &nbsp;&nbsp;&nbsp;acciones FinSi | if (condicion) { &nbsp;&nbsp;&nbsp;acciones } | . | Condicional doble | Si condicion entonces &nbsp;&nbsp;&nbsp;acciones SiNo &nbsp;&nbsp;&nbsp;acciones FinSi | if (condicion) { &nbsp;&nbsp;&nbsp;acciones } else { &nbsp;&nbsp;&nbsp;acciones } | . | Bucle tipo mientras | Mientras condicion hacer &nbsp;&nbsp;&nbsp;acciones FinMientras | while (condicion) { &nbsp;&nbsp;&nbsp;acciones } | . | Bucle tipo repetir | Repetir &nbsp;&nbsp;&nbsp;acciones Hasta Que condicion | do { &nbsp;&nbsp;&nbsp;acciones } while (condicion) | . | Bucle tipo para | Para variable &nbsp;&nbsp;&nbsp;acciones FinPara | for (variable = valor_inicial; variable != valor_final; variable = variable + incremento) { &nbsp;&nbsp;&nbsp;acciones } | . Fíjate en que casi todo se escribe del mismo modo que en pseudocódigo con un par de diferencias notables: * **DIFERENCIA 1: En el bucle tipo *repetir***, la condición de salida se expresa al revés (\"repetir mientras..\" en lugar de \"repetir hasta que...\". Lo verás mejor en este ejemplo que muestra los números del 1 al 100. Observa la condición del final del bucle: En pseudocódigo: ``` i = 100 ``` En Javascript: ```javascript i = 1; do { document.write(i); i++; } while (i | Instrucción | Pseudocódigo | Javascript | . | Entrada | Leer variable | variable = prompt(); | . | Salida | Escribir expresión | document.getElementById('selector').innerHTML = expresión; O bien: document.write(expresión); O bien: alert(expresión); | . Vamos a ver un poco más despacio cómo se usa cada una de estas funciones: #### Entrada de datos con prompt() La **entrada de datos** en Javascript puede hacerse de diversas maneras. En particular, usando **formularios HTML**, pero de momento no vamos a pelearnos con eso. En esta primera toma de contacto con el lenguaje, vamos a conformarnos con la función **prompt()**. Esta función muestra un mensaje en forma de ventana emergente y permite escribir un texto, asignándolo a una variable. Observa cómo se usa *prompt()* con este ejemplo escrito primero en pseudocódigo y luego en Javascript: Pseudocódigo: ``` Escribir(\"Dime un número\") Leer n ``` Javascript: ```javascript document.write(\"Dime un número\"); n = prompt(); ``` Si pruebas este código, verás que sucede algo raro: el mensaje \"Dime un número\" sale escrito en la ventana del navegador web, pero el número nos lo pide en una ventana emergente que se sitúa *por encima* del mensaje. ¡Y, en algunos navegadores, el mensaje \"Dime un número\" ni siquiera llega a verse! ![Prompt sin texto](/docs/prog-y-3d/_site/assets/images/05-prompt-sin-texto.png) Esto hace un efecto muy raro. ¿verdad? Para evitarlo, puedes **unir las dos instrucciones** en una sola, puesto que *prompt()* te permite incluir un mensaje en la caja de texto. Así: ```javascript n = prompt(\"Dime un número\"); ``` Al ejecutar este código, verás que el resultado es mucho más natural: ![Prompt con texto](/docs/prog-y-3d/_site/assets/images/05-prompt-con-texto.png) (Nota: la forma exacta en la que veas estas pantallas dependerá de tu navegador web, puesto que cada uno hace el *prompt* de manera ligeramente distinta) #### Salida de datos con innerHTML, document.write() y alert() La forma más sencilla de hacer la salida de datos con Javascript es usar **document.write()** o su hermana melliza, **document.writeln()**. Mira cómo se usa en este ejemplo y el resultado que produce en la ventana del navegador: Código: ```javascript ``` Resultado: ![Salida de datos con document.write()](/docs/prog-y-3d/_site/assets/images/05-salida-de-datos-con-document-write.png) La diferencia entre *write()* y *writeln()* es que la segunda insertará automáticamente un salto de línea tras la salida, y la primera no. Sin embargo, estas funciones tiene un grave problema: puede que el texto de salida *no se muestre inmediatamente*. La decisión de cuándo se muestra la salida la toma el navegador y hay poco que puedas hacer al respecto. Por eso, la usaremos en contadas ocasiones. Otra manera muy sencilla de hacer salida de datos es con **alert()**. Esta función muestra un texto en forma de ventana emergente. Parecido a *prompt()*, pero sin caja de texto para escribir. Observa a *alert()* en acción en el siguiente ejemplo: Código: ```javascript ``` Resultado: ![Salida de datos con alert()](/docs/prog-y-3d/_site/assets/images/05-salida-de-datos-con-alert.png) La salida con *alert()* es simple y efectiva, pero resulta muy invasiva. Si haces todo tu programa con *alert()*, el usuario se sentirá enseguida apabullado por esa cantidad de ventanas emergentes que le saltan a la cara. De modo que nos queda la tercera vía. Es la más enrevesada, pero también la mejor. Y, en fin, tampoco es tan complicado. Consiste en preparar una zona de la pantalla del navegador para hacer en ella la salida de datos, y luego acceder a la misma con **document.getElementById().innerHTML**. Si sabes un poco de **HTML**, el lenguaje de marcado con el que se codifican las páginas web, enseguida comprenderás lo que estamos haciendo. Si no tienes ni idea de HTML, no te preocupes. Basta con que sigas los pasos que proponemos aquí para que puedas ejecutar tus programas Javascript. Ya tendrás tiempo de aprender HTML más adelante. **Paso 1. Prepara la caja donde se hará la salida**. La caja se crea un la etiqueta **** de HTML, a la que puedes asignar un estilo de visualización. La primeras veces, puedes limitarte copiar y pegar este código en todos los programas Javascript que vayas a hacer: ```html ``` **Paso 2. Dentro de tu programa Javascript, utiliza *document.getElementById('salida').innerHTML = expresión* para hacer la salida**. Sí, lo sé, es un poco largo, pero Javascript es así. Por ejemplo, este código: ```html ``` ...producirá este resultado: ![Salida de datos con innerHTML](/docs/prog-y-3d/_site/assets/images/05-salida-de-datos-con-innerhtml.png) **Paso 3. Utiliza *document.getElementById('salida').innerHTML += expresión* si no quieres perder la salida anterior**. Es decir, si usas un **igual** (=), cada salida de datos borrará la pantalla. Si usas **más igual** (+=), la salida de datos se añadirá a la anterior, sin borrarla: ```html ``` **Paso 4 (OPTATIVO). Cambia las propiedades de tu caja de salida**. Intenta juguetear con las propiedades ***text-align***, ***border-style*** o ***border-color*** del *div* de salida. Además, hay muchas otras propiedades que puedes asignarle a esa caja. Si te atreves, investiga un poco cómo cambiar el color del texto o la tipografía. ### 5.2.10. Arrays Los **arrays en Javascript** son mucho más que simples arrays: se trata de elementos muy complejos y flexibles que se adaptan a multitud de soluciones. Aquí solo vamos a ver una introducción a los mismos. Conforme vayas profundizando en tu conocimiento de Javascript, descubrirás cosas nuevas sobre estas asombrosas estructuras y les sacarás más y más partido. #### Declaración de arrays Los arrays en Javascript se pueden **declarar** de diversas formas: ```javascript // Una forma de declarar un array: var ciudades = ['Almería', 'Granada', 'Málaga']; // Otra forma de declarar un array: var ciudades = new Array('Almería', 'Granada', 'Málaga'); // Esta es otra forma: var ciudades = new Array(3); ciudades[0] = 'Almería'; ciudades[1] = 'Granada'; ciudades[2] = 'Málaga'; // Y otra forma más: var ciudades = []; ciudades[0] = 'Almería'; ciudades[1] = 'Granada'; ciudades[2] = 'Málaga'; ``` Realmente, no todas estas formas son equivalentes, porque Javascript a veces tratará a la variable *ciudades* como un **Array** y a veces como un **objeto**. La diferencia entre una y otra cosa es tan sutil que, de momento, puedes desentenderte de ello. Si algún día te vuelves un experto en Javascript, ya entenderás esa diferencia. Por ahora, quédate con la idea de que todas estas formas son válidas para declarar un array. #### Características de los arrays en Javascript Como puedes observar por los ejemplos anteriores, los arrays de Javascript tienen dos características importantes: * **No es necesario indicar su tamaño al declararlos**, aunque se puede hacer. Esto se debe a que los arrays en Javascript son dinámicos: pueden crecer o decrecer durante la ejecución del programa. * **El índice empieza en 0**. Es decir, el primer elemento es el 0, el segundo es el 1, etc. * El **acceso a los elementos** del array se hace como en pseudocódigo: indicando el índice del elemento entre corchetes. Los arrays NO son variables primitivas (simples). Recuerda que esto significa que **siempre se pasan por referencia** a las funciones, mientras que las variables primitivas se pasan por valor. Repasa el paso de parámetros a funciones del que hablamos un poco más arriba si no recuerdas bien todo esto. Una cosa muy peculiar de los arrays de Javascript es que **sus elementos pueden ser de diferente tipo**. Por ejemplo: ```javascript // Este array tiene elementos del mismo tipo (strings): var ciudades = ['Almería', 'Granada', 'Málaga']; // Este array tiene elementos de diferente tipo: var miArray = ['Lunes', 5, ciudades]; ``` En el ejemplo anterior, el array *ciudades* solo contiene elementos de tipo *string*, mientras que el array *miArray* contiene elementos de tipo dispares: un *string*, un *number* y un *array*. Como ves, nada impide que un elemento de un array sea otro array. De hecho, un elemento de un array puede ser cualquier cosa. #### Propiedades y métodos Los arrays de Javascript, como cualquier objeto, tienen una serie de **propiedades y métodos**. Ya veremos exactamente qué son las propiedades y los métodos, pero de momento te basta saber que se trata de funciones y variables que *están dentro* del objeto de tipo array y que permiten usarlo. Algunas propiedades y métodos útiles de los arrays son: * **nombreArray.length**: devuelve el número de elementos del array. * **nombreArray.sort()**: ordena el array. * **nombreArray.push(valor)**: añade un elemento al array (a continuación de la última posición usada). Como consecuencia, el tamaño del array crecerá. * **nombreArray.pop()**: elimina el último elemento del array. Como consecuencia, el tamaño del array decrecerá. * **nombreArray.indexOf(valor)**: busca el elemento *valor* en el array y devuelve su posición (si lo encuentra) o -1 (si no lo encuentra). Hay muchas otras propiedades y métodos que puedes consultar en la [referencia oficial del lenguaje](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/Arrays). #### Recorrido de un array El **recorrido** de un array puede hacerse igual que en pseudocódigo, con la salvedad de que tendremos que averiguar la longitud del array antes de recorrerlo, puesto que el tamaño del array puede variar a lo largo del programa: ```javascript var ciudades = ['Almería', 'Granada', 'Málaga']; var longArray = ciudades.length; for (i = 0; i Púlsame ``` ¿Te imaginas lo que se verá en el navegador si cargas esa página? Pues sí: un botón cuyo texto será \"Púlsame\". Ahora mira el mismo código, ligeramente modificado: ```html Púlsame ``` Ese \"onclick\" a continuación del botón significa que **vamos a capturar el evento clic de ratón** asociado al botón. Al hacer clic sobre él, se ejecutará la función *procesar_boton()* de Javascript. Usaremos algún evento *onclick()* como este en los ejercicios para conseguir resultados curiosos. Sobre los eventos, se podría hablar muchísimo más, pero como introducción a Javascript es suficiente por ahora... ### 5.4.2. Temporizadores de Javascript Lo que te voy a contar ahora puede considerarse Javascript avanzado (o, al menos, no es Javascript básico). Pero lo vas a necesitar para hacer juegos y otras diversiones con Javascript y, en fin, tampoco es tan complicado... Se trata de los **temporizadores**. Un temporizador es como el cronómetro de una bomba de relojería de las que salen en las películas. Ya sabes, esas bombas que siempre tienen una pantalla LCD donde se ve una cuenta atrás que indica cuánto falta para que explote. (El temporizador es el cronómetro, no la bomba, que conste...) Un temporizador se pone en marcha así: ```javascript var timer = setTimeout('nombre-de-función', intervalo); ``` El *nombre-de-función* es exactamente eso: el nombre de alguna función Javascript que ya exista. El *intervalo* es un número entero. Lo que hace el temporizador es **iniciar una cuenta atrás de *intervalo* milisegundos y, cuando el cronómetro llega a cero, se ejecuta la función indicada**. Por ejemplo: ```javascript var timer = setTimeout('saludar', 1000); function saludar() { alert(\"Hola, mundo\"); } ``` Si ejecutas este código, verás que el saludo (¡Hola, mundo!) tarda exactamente un segundo en aparecer. El temporizador se ha encargado de ello. Nada más ejecutar el código, se ha puesto en marcha un temporizador cuyo encargo es ejecutar la función *saludar()* al cabo de 1000 milisegundos (es decir, un segundo). Programar acciones para que se realicen en el futuro abre muchísimas posibilidades. En particular, piensa en qué ocurriría si hacemos que la propia función *saludar()* vuelva a reestablecer el temporizador: ```javascript var timer = setTimeout('saludar', 1000); function saludar() { alert(\"Hola, mundo\"); setTimeout('saludar', 1000); } ``` Detente un momento a tratar de averiguar qué ocurriría al ejecutar este programa y por qué podríamos decir sin dudarlo que se trata de uno de los programas más plastas que hemos escrito hasta ahora. Si no te lo crees, pruébalo y lo comprobarás. Por último, si, por lo que sea, necesitas **detener un temporizador** que ya está en marcha, solo tienes que usar la función ***clearTimeout()***: ```javascript clearTimeout(timer); ``` Lógicamente, la variable *timer* debe ser la misma que usaste al crear el temporizador. ## 5.5. Un ejemplo completo: las tres en raya Llegó la hora de poner manos a la obra. Si hay una sección de este capítulo que tienes que leer con atención, es esta. Así que es un mal momento para tener prisa. Vamos a escribir un **programa completo en Javascript**. Te puede servir de plantilla para desarrollar tus propios programas a partir de aquí. El programa en cuestión será una versión del juego de **las tres en raya** que resolvimos en el tema de introducción a la programación. No dudes en repasar aquel ejercicio resuelto para ver el pseudocódigo, puesto que nuestro programa será una traducción literal de ese pseudocódigo a Javascript. Aquí tienes el código fuente completo. Estúdialo con atención y asegúrate de entenderlo todo (o un gran porcentaje) antes de continuar. Ah, y no dejes de compararlo línea a línea con el mismo código en pseudocódigo. ### 5.5.1. El código fuente ```html ``` ### 5.5.2. ¿Cómo ejecutar y depurar este programa? Guarda el programa anterior en un archivo de texto con extensión .html (por ejemplo, *3-en-raya.html*). Luego, sencillamente, haz doble clic sobre él para abrirlo. El sistema operativo usará el navegador web predeterminado de tu sistema para abrir el archivo y la ejecución comenzará. #### ¡Socorro! El programa no funciona ¿El resultado no es el esperado? Es lo habitual. Habrá algún error en el código y te tocará depurarlo. Las páginas web (con Javascript incluido) son extraordinariamente resistentes a los errores. No te mostrarán mensajes de error cada vez que haya algo mal escrito. Al contrario, permanecerán en silencio para no asustar al usuario de la web y provocar que salga corriendo de allí. Por ese motivo, los errores de Javascript solo se dejan ver en la \"sala de máquinas\" del navegador. Por supuesto, los programadores/as tienen una manera de acceder a esa \"sala de máquinas\". Pulsa **F12** en tu navegador para abrir la **consola de errores** de Javascript. Asegúrate de seleccionar la pestaña etiquetada como ***Console***. Verás algo como esto: ![Consola de errores de Javascript](/docs/prog-y-3d/_site/assets/images/05-consola-errores-javascript.png) En la consola de errores aparecen, en rojo, los mensajes de error que haya lanzado el intérprete de Javascript, indicándote el tipo de error y la línea en la que se ha detectado. Los mensajes estarán en inglés, por supuesto, pero ¿qué esperabas? Si quieres aprender a programar, tienes que acostumbrarte a manejar el inglés técnico. ¡Atención! Dependiendo del navegador que uses, puede que esa consola de errores se abra con otra combinación de teclas. Tendrás que bichear un poco por internet para averiguarlo. Lo habitual, sin embargo, es F12. Cuando hayas localizado el error, **regresa a tu editor de texto, haz los cambios necesarios, guarda las modificaciones y recarga la página** (pulsando **F5** en la mayoría de los navegadores). Si el navegador se había quedado colgado, tendrás que cerrarlo, esperar unos segundos y volver a abrirlo. Y así hasta que funcione. ¡Mucha paciencia y sangre fría! Recuerda siempre que la mayor parte del tiempo de programación se va en depurar programas, no en escribirlos. ## 5.6. Ejercicios propuestos #### Ejercicio 1. Tabla de multiplicar Vamos a empezar por algo sencillito. Escribe un programa en Javascript que pida un número y muestre la tabla de multiplicar de ese número. Puedes utilizar esta plantilla para tu primer programa: ```html ``` Recuerda que la salida la puedes enviar al 'salida' con la expresión: *document.getElementById('salida').innerHTML* #### Ejercicio 2. Juego del número secreto Ahora algo solo un poquito más complicado: una versión en Javascript del juego del número secreto. (Puedes encontrarlo resuelto en el capítulo \"Introducción a la programación\") #### Ejercicio 3. Botón saltarín Aquí empezamos a divertirnos. **Vamos a hacer una página web con un botón. Al pulsar ese botón, Javascript hará que ¡el botón cambie de sitio!** Para eso, capturaremos el **evento *click*** del botón. El botón lo tienes que crear antes mediante HTML. No importa que no sepas HTML. Solo echa un vistazo a este código: ```html Púlsame ``` Ahora solo te queda programar la función *mover_boton()*. Para lograr que el botón se mueva, tendrás que fijarte primero en cómo está el botón creado: tiene un **id**, un evento **onclick** y un **style**. Dentro del este último se definen dos propiedades: * **top** es la distancia desde la parte superior de la ventana del navegador hasta el botón. Lo hemos establecido en 100 píxeles (100px). * **left** es la distancia desde la parte izquierda de la ventana del navegador hasta el botón. Le hemos dado 200 píxeles. Pues bien, debes hacer que Javascript modifique esas dos propiedades. Por ejemplo, así: ```javascript function mover_boton() { document.getElementById('boton').style.top = '150px'; document.getElementById('boton').style.left = '250px'; } ``` Con eso, el botón se moverá al hacer clic sobre él, pero solo la primera vez. Quedará emplazado en la posición top = 150px y left = 250px y ya no se desplazará más. **¿Y si quisiéramos que se moviera *siempre* que hagamos clic sobre él?** Es es lo que tienes que conseguir en este ejercicio. #### Ejercicio 4. Ventana nerviosa y botones evanescentes **Ahora vamos a conseguir que una ventana entera del navegador se mueva al pulsar un botón. Y a hacer aparecer y desaparecer botones.** De hecho, vamos a crear cuatro botones: * **Botón \"Saltar\"**: al pulsarlo, la ventana dará un salto. Es decir, cambiará de posición.. * **Botón \"Temblar\"**: al pulsarlo, la ventana se pondrá a \"temblar\", como si tuviera frío o se hubiera puesto nerviosa, durante un rato. * **Botón \"Ocultar\"**: al pulsarlo, los dos botones anteriores desaparecerán de la vista. * **Botón \"Mostrar\"**: al pulsarlo, los botones desaparecidos volverán a aparecer. Esos cuatro botones puedes crearlos con este código HTML. También crearemos una segunda ventana del navegador, que será la que cambiará de posición: ```html ",
    "url": "/docs/prog-y-3d/_site/javascript/",
    "relUrl": "/javascript/"
  },"9": {
    "doc": "6. Orientación a objetos",
    "title": "6. Orientación a objetos",
    "content": "# 6. Orientación a objetos {: .no_toc } - TOC {:toc} En este capítulo vamos a introducir las técnicas de **programación orientada a objetos** y su implementación en Javascript. La programación orientada a objetos es una forma de programar (un *paradigma*, dicen los teóricos) que implica organizar el código fuente de una determinada manera. Desde que este paradigma se impuso con fuerza en la década de 1990, se ha comprobado que las aplicaciones orientadas a objetos son más fáciles de diseñar y de mantener que las aplicaciones que usan técnicas de programación más anticuadas (lo que se llama **programación estructurada clásica**). Javascript es un lenguaje orientado a objetos, aunque hace una interpretación un poco peculiar de lo que significa este concepto. En este capítulo, veremos primero qué es la programación orientada a objetos y luego nos centraremos en cómo aplicar esas ideas a Javascript. ## 6.1. Conceptos básicos de programación orientada a objetos Los párrafos que vienen a continuación se basan en un texto **Yukihiro Matsumoto**, el creador del lenguaje Ruby. La razón es sencilla: me parece una explicación insuperable (gracias a Matsumoto, claro, no a mí). Para entender qué significa exactamente **programación orientada a objetos**, primero tenemos que comprender en qué consiste la **programación tradicional** o no orientada a objetos. En programación tradicional, cualquier problema informático se resuelve codificando un conjunto de algoritmos que trabajan sobre un conjunto de datos. Es decir, los datos son elementos pasivos: es el código el que se encarga de hacer todo el trabajo por ellos. A medida que los proyectos crecen, el código también lo hace, y llega un momento en el que es imposible saber cómo funciona todo el sistema. Surgen interacciones imprevistas e impredecibles entre distintas partes del programa. El fallo más tonto, como un error tipográfico, puede convertirse en una pesadilla cuya localización puede suponer muchas horas de trabajo (y, en consecuencia, mucho dinero). Como dice Matsumoto, el mantenimiento de estos programas se convierte en algo parecido a **transportar un calamar gigante intentado que ninguno de sus tentáculos te alcance la cara**. Lo que hace la programación orientada a objetos es cambiar esta forma de trabajar. No supone una revolución con los métodos anteriores, sino un cambio en la forma en la que se hacen las mismas cosas de siempre. La mayoría del trabajo se delega a los propios datos, de modo que **los datos ya no son estáticos**, sino que se encargan de mantenerse en forma a sí mismos. De nuevo en palabras de Matsumoto: *dejamos de tratar cada pieza de dato como una caja en la que se puede abrir su tapa y arrojar cosas en ella y empezamos a tratarlos como máquinas funcionales cerradas con unos pocos interruptores y diales bien definidos*. Un dato en programación orientada a objetos (es decir, una caja con interruptores, botoncitos y diales) puede tener, en sus tripas, algo muy simple o muy complejo. No se puede saber desde el exterior y no se nos permite abrir la máquina (excepto cuando estamos completamente seguros de que algo está mal en su diseño), por lo que se nos obliga a utilizar los interruptores y leer los diales para interactuar con los datos. Una vez construida una de esas máquinas, no queremos tener que volver a pensar en cómo funciona internamente. ### 6.1.1. Un ejemplo sencillo para entender el concepto de \"objeto\" Seguimos con Matsumoto para ilustrar con un ejemplo sencillo qué es eso de una “máquina con unos pocos interruptores y diales”. Seguramente en tu cocina tienes un horno microondas (aunque, en realidad, para este ejemplo podrías elegir cualquier electrodoméstico). El horno consta, entre otros muchos subsistemas, de un temporizador. Su trabajo consiste en mantener el horno encendido durante un tiempo determinado por el usuario. ¿Cómo podríamos representar esto en un lenguaje de programación? En Javascript, por ejemplo, el temporizador podría ser, simplemente, una variable de tipo *number*. El programa manipularía esa variable disminuyendo el valor una vez por segundo, y permitiría al usuario establecer el tiempo inicial del temporizador antes de poner el horno en marcha. Con este enfoque tradicional, un error en cualquier parte del programa podría terminar asignando un valor falso a la variable, como un número negativo o un tiempo de varias horas. *Hay un número infinito de razones inesperadas por las que podría llegar a suceder esto*. Cualquiera con cierta experiencia programando sabe que se pueden perder horas o días tratando de encontrar ese error. Pero si programamos con un lenguaje orientado a objetos, *no pensaremos en el tipo de datos que mejor se ajusta a un temporizador de microondas, sino en el modo en el que un temporizador de microondas funciona en el mundo real*. No parece una gran diferencia, pero lo es. El programador, o el diseñador, necesitará dedicar cierto tiempo a decidir qué es exactamente un temporizador de microondas y cómo se espera que el mundo exterior interactúe con el. Por fin, construirá una pequeña máquina (una pieza de software) con controles que permitan establecer, consultar y disminuir su valor. Por ejemplo, podemos decidir crear el temporizador impidiendo asignarle un valor arbitrario, por la sencilla razón de que los temporizadores de microondas no trabajan de esa forma en el mundo real: solo permiten asignar múltiplos de 10 segundos, por lo general. Es decir: existen sólo unas cuantas cosas que un temporizador de microondas puede hacer, y sólo permitiremos esas cosas. Así, si alguien desde otra parte del programa trata de asignar algún valor no permitido al temporizador, como un número negativo, le resultará imposible hacerlo por la sencilla razón de que el propio temporizador no lo permitirá. Ya no es un dato \"tonto\" y estático, que permite que cualquiera lo manipule. Es un dato \"listo\", con control y autonomía sobre su propio comportamiento. *Lo hemos convertido en un **objeto***. De ese modo, estaremos protegiendo una parte del programa de errores cometidos en otras partes y que, en programación tradicional, se propagan como el fuego en un tanque de gasolina. Por si fuera poco, los lenguajes orientados a objetos nos permiten que, una vez que hayamos diseñado un temporizador de microondas (o el objeto que sea), podamos fabricar tantos como sea necesario. Habremos creado un patrón o molde de temporizador y, a partir de ese molde, se pueden construir objetos diferentes (pero similares) indefinidamente. Pues bien, el *molde* se conoce como **clase**, y cada temporizador concreto que fabriquemos a partir de ese molde se conoce como **objeto**. Aclaremos, sin embargo, que la programación orientada a objetos no es una solución milagrosa: nada impide, en cualquier lenguaje, escribir código poco claro, descuidado, inestable o directamente erróneo. A continuación hablaremos de los “interruptores y diales” del temporizador del microondas (métodos) y, un poco después, veremos como se construyen los moldes (clases). ### 6.1.2. Métodos En la programación orientada a objetos, como acabamos de ver, no se piensa en manipular los datos directamente desde el exterior de un objeto, sino que son los propios objetos los que deciden cómo se debe operar sobre ellos. Se pasa un mensaje al objeto y este mensaje provoca algún tipo de acción o respuesta significativa por parte del objeto. Esto ocurre sin que nos importe cómo realiza el objeto, interiormente, el trabajo. Las *tareas que podemos pedir que un objeto realice* (o lo que es lo mismo, los *mensajes* que el objeto comprende) son los **métodos**. En Javascript, se llama a un método con la **notación punto** (como en Java, C++, Python, Ruby o muchos otros lenguajes). El objeto con el que nos comunicamos se nombra a la izquierda del punto. Por ejemplo: ```javascript mi_cadena = \"Hoy es viernes\"; alert(\"Cadena convertida a mayúsculas: \" + mi_cadena.toUpperCase()); ``` Hemos enviado a un objeto llamado *mi_cadena* (que es, evidentemente, una cadena de caracteres) el menaje *toUpperCase()*. La salida por pantalla será: ``` Cadena convertida a mayúsculas: HOY ES VIERNES ``` Intuitivamente es fácil comprender lo que ha ocurrido aquí: al objeto *mi_cadena* se le ha pedido que nos calcule una versión de sí mismo con todos los caracteres convertidos en mayúscula. Técnicamente, lo que hemos hecho se llama **invocar el método *toUpperCase()*** del objeto mi_cadena. Otros objetos pueden hacer una interpretación un poco diferente de *toUpperCase()*, o no comprenderlo en absoluto. Cuando un objeto recibe un mensaje que no conoce, se produce un error. Por lo tanto, hay que conocer qué métodos son aceptables para un objeto, aunque no se necesita saber como están programados por dentro. Los métodos, recuerda, son como los diales del horno microondas: como usuario, tienes que saber qué diales existen y cómo usarlos, pero no cómo están construidos. ### 6.1.3. Atributos Los **atributos** de un objeto definen las **características** del mismo. Por ejemplo, un atributo del temporizador del microondas debería ser el número de segundos que éste debe permanecer activo, y un atributo de un objeto de tipo String debe de ser el número de caracteres de que consta la cadena. Al programador que usa un objeto deberían importarle un bledo los atributos del mismo. Él (o ella) se encargará de usar el objeto a través de sus métodos, y éstos operarán con los atributos, si ello es necesario, de forma totalmente transparente al programador. Es decir, los atributos raramente son accesibles desde el exterior del objeto, salvo que, por razones de diseño, el programador del objeto haya decidido lo contrario. ### 6.1.4. Herencia En programación orientada a objetos, unas clases pueden **heredar** de otras. El concepto de herencia, en este contexto, se parece a la herencia genética entre seres vivos. Un ser vivo hereda por vía genética ciertas características de sus progenitores. Del mismo modo, una clase puede heredear ciertas características de sus clases-madre. Esto es extraordinariamente útil para **reutilizar código** y, por lo tanto, facilitar y abaratar el desarrollo y el mantenimiento de las aplicaciones informáticas. Por ejemplo, si en una aplicación tenemos una clase llamada *Vehículo* con ciertos atributos (*matrícula*, *marca*, *modelo*, etc), podemos crear varias subclases o clases-hijas llamadas *Turismo*, *Camión* o *Bicicleta*. Todas ellas heredarán los atributos y métodos de la clase-madre. Es decir, todas tendrán *matrícula*, *marca* y *modelo*, por ejemplo. Pero algunas de las subclases pueden necesitar atributos o métodos adicionales (¿qué tal un atributo *número_plazas* para *Turismo*?), mientras que otras pueden prescindir de algunos atributos o métodos (las bicicletas no suelen tener matrícula). Sin embargo, todas las subclases siguen siendo vehículos, y el código fuente que hayamos escrito para la clase *Vehículo* sigue siendo válido en cada una de ellas, sin necesidad de reescribirlo. ## 6.2. Los objetos en Javascript Una vez comprendidos los conceptos básicos de programación orientada a objetos, vamos a ver cómo se utilizan en Javascript. Javascript ha hecho, históricamente, una interpretación un poco peculiar del paradigma de orientación a objetos. De hecho, se decía de él que no era un lenguaje orientado a objetos, sino orientado a prototipos. No importa demasiado lo que esto significa, al menos de momento. Afortunadamente, desde la versión EC6 del año 2015, Javascript admite definiciones de clases y objetos mucho más convencionales y respetuosas con el paradigma. ### 6.2.1. Creación de objetos con Javascript En JavaScript, **crear un objeto individual** es tan sencillo como declarar una variable con esta sintaxis: ```javascript var book = {}; ``` Por supuesto, esto creará un objeto llamado *book* que estará vacío. Para que el objeto tenga atributos y métodos, hay que rellenarlo con código. Observa el siguiente ejemplo: ```javascript var book = { title: 'The Lord of the Rings', year: 1954, genre: ['epic', 'fantasy'], getTitle: function() { alert(this.title); } getGenres: function () { alert(this.genre[0] + ' ' + this.genre[1]); }, }; ``` Este objeto se compone de **tres atributos** (*title, year, genre*) y dos métodos (*getGenres()* y *getTitle()*). A los atributos les hemos asignado algunos valores. De este modo, podemos invocar a los métodos y comprobar que el objeto responde correctamente. Así: ```javascript book.getTitle(); book.getGenres(); ``` El resultado serán dos pantallas de tipo *alert()* donde se nos mostrarán los textos \"The Lord of the Rings\" y \"epic fantasy\", respectivamente. En el objeto anterior, también podemos acceder y modificar los atributos del objeto. Observa este código: ```javascript alert(book.title); book.title = \"Harry Potter and the Philosopher's Stone\"; alert(book.title); ``` El primer *alert()* mostrará \"The Lord of the Rings\" (exactamente igual que el método *getTitle()*), mientras que el segundo *alert()* mostrará \"Harry Potter and the Philosopher's Stone\", porque hemos accedido y modificado el atributo *title* del objeto *book*. ### 6.2.2. El objeto \"this\" Es posible que te haya llamado la atención la presencia de la palabra ***this*** en el objeto *book*. Esa palabra se refiere **al objeto actual** sobre el que se está ejecutando el código. En el ejemplo, *this* es equivalente a *book*. Si, por ejemplo, le cambiásemos el nombre a la variable *book*, no será necesario cambiar el código fuente de sus métodos porque esos métodos se refieren a *this*, no a *book*. Puedes verlo mejor en este ejemplo: ```javascript var book1 = { title: 'The Lord of the Rings', getTitle: function() { alert(this.title); } } var book2 = { title: 'The Hunger Games', getTitle: function() { alert(this.title); } } ``` En el objeto *book1* podíamos haber utilizado el identificador *book1* en lugar de *this*, y funcionaría exactamente igual. Lo mismo suceden con *book2*. ¿Cuál es la ventaja, entonces, de usar *this*? Muy pronto aprenderemos a crear múltiples objetos a partir *del mismo código fuente*. En ese caso, ¿qué tendríamos que poner en el código fuente? Si escribimos *book1*, el código ya no funcionaría para *book2*, y si escribimos *book2*, no funcionaría para *book1*. En cambio, escribiendo *this*, el método *getTitle()* funciona con *book1*, con *book2* y con cualquier otro objeto que creemos a partir del mismo molde. ### 6.2.3. Las clases en Javascript *(**Nota importante**: como hemos dicho al principio, vamos a utilizar la sintaxis de Javascript EC6 y posterior. Si no sabes de qué estamos hablando, no te preocupes: solo tienes que mantener tu navegador web actualizado para asegurarte que entiende el Javascript moderno).* Como vimos antes, una **clase** en un molde a partir del cual podemos crear objetos idénticos (aunque luego cada uno pueda evolucionar de forma independiente del resto). Por ejemplo, podemos definir una clase *Book* que tenga en su interior los atributos (*title*, *genre*, etc) y los métodos (como *getTitle()*), y a partir de ella podemos crear todos los objetos de tipo *Book* que necesitemos. Así, solo habremos escrito el código fuente una vez, y lo podemos reutilizar tantas veces como sea necesario, no cada vez que vayamos a crear un libro. En Javascript, la clase *Book* se declara así: ```javascript class Book { title; // Atributo constructor(title) { // Método constructor this.title = title; } getTitle() { // Otro método alert(this.title); } } ``` Esta clase contiene: * **Un atributo** (*title*). * **El método *constructor()***, que se ejecutará automáticamente al crear cada nuevo objeto del tipo *Book*. Es importante que se llame exactamente así. Observa que tiene un parámetro, *title*. * **El método *getTitle()*** , que nos mostrará el título del libro mediante un *alert()*. Este método puede tener el nombre que queramos y podría hacer cualquier otra cosa con el libro. Nos limitamos al mostrar el título como ejemplo de algo que tiene sentido hacer con un libro. Ahora podemos crear todos los *Books* que queramos, y todos utilizarán el mismo código y tendrán los mismos atributos. Por ejemplo: ```javascript var book1 = new Book('The Lord of the Rings'); var book2 = new Book('The Hunger Games'); var book3 = new Book('The Neverending Story'); ``` Acabamos de crear tres objetos de tipo *Book* diferentes. Observa cómo se usa la palabra *new* delante del nombre de la clase y como, al crear cada libro, debemos pasar su título como parámetro. *Esto es así porque el constructor de la clase tenía un parámetro*, el título del libro. Ahora podemos usar los métodos de esos objetos, y cada uno actuará sobre su propio conjunto de atributos. Por ejemplo: ```javascript book1.getTitle(); book2.getTitle(); book3.getTitle(); ``` Este código provocará la ejecución de tres *alerts* consecutivos, que nos mostrarán, uno tras otro, los títulos de nuestros tres libros. (Nota: por convenio, el nombre de la clase suele escribirse con mayúscula inicial, mientras que el nombre de los atributos, métodos y objetos individuales se escribe empezando en minúsculas). ### 6.2.4. Herencia en Javascript *(Nuevamente, nos referiremos a cómo se maneja la herencia en las versiones recientes de Javascript (EC6 o posterior). ¡Asegúrate de tener tu navegador web actualizado!)* Cuando se crea una clase, se puede hacer desde cero o bien se puede basar en otra clase preexistente. En este segundo caso, la nueva clase **hereda los atributos y los métodos** de la **clase-madre** o **superclase**, a los que puede añadir sus propios atributos y métodos. Esto permite reutilizar grandes cantidades de código de forma bien organizada y sin necesidad de volver a escribirlo. Lo vamos a entender mejor con otro ejemplo. **Vamos a crear una clase nueva**, en esta ocasión llamada ***Person***. Tendrá dos atributos (*name* y *age*) y un método (*getName()*), además del constructor: ```javascript class Person { // Atributos name; age; // Método constructor constructor(firstname, lastname, age) { this.name = {firstname, lastname}; this.age = age; } // Otros métodos getName() { alert(\"Esta persona se llama: \" + this.name.firstname + \" \" + this.name.lastname); } } ``` En este caso, pasamos tres parámetros a la función constructora. Dos de ellos (*firstname* y *lastname*) los agrupamos dentro de un solo atributo (*name*). Por ese motivo, en el método *getName()* tenemos que acceder a cada uno de los elementos de *name* por separado. Podríamos haber utilizado dos atributos diferenciados, pero hemos preferido hacerlo así para darle un poco de variedad a los ejemplos y para que veas que el número de parámetros del constructor no tiene por qué coincidir con el número de atributos. Ahora, por supuesto, podemos **crear todos los objetos que queramos a partir de la clase *Person***. Por ejemplo: ```javascript var person1 = new Person('Juan', 'Pérez', 25); var person2 = new Person('Ana', 'López', 37); ``` A continuación, podemos **crear nuestras clases-hija** o **clases derivadas** que hereden de *Person*. Observa detenidamente este código y enseguida entenderás cómo funciona la herencia: ```javascript class Student extends Person { // Atributos adicionales course; // Método constructor constructor(firstname, lastname, age, course) { super(firstname, lastname, age); this.course = course; } // Otros métodos getCourse() { alert(\"Este estudiante está matriculado en el curso: \" + this.course); } } class Teacher extends Person { // Atributos adcicionales speciality; // Método constructor constructor(firstname, lastname, age, speciality) { super(firstname, lastname, age); this.speciality = speciality; } // Otros métodos getSpeciality() { alert(\"La especialidad de este profesor/a es: \" + this.speciality); } } ``` ¿No es cierto que los estudiantes y los profesores suelen ser personas (en la mayoría de los casos, al menos)? Pues bien, aquí hemos **definido dos nuevas clases llamadas *Student* y *Teacher***. Pero no las hemos definido *completamente*, sino que hemos **reutilizado la clase *Person***. Y lo hemos hecho indicando que **tanto *Student* como *Teacher* heredan de la clase *Person***. Esto se indica con la palabra ***extends*** en la declaración de la clase. Es decir, que las dos nuevas clases heredan todo el contenido de su clase-madre. Luego, simplemente, hemos añadido los nuevos atributos y nuevos métodos que existen en esas clases pero no tienen sentido en la clase-madre. Observa bien los constructores de *Student* y *Teacher*. Ahí encontrarás la palabra ***super***. En el siguiente apartado veremos lo que significa. El resto del código es bastante trivial. Ahora podemos hacer algo como esto y funcionará: ```javascript var person1 = new Person('Juan', 'Pérez', 25); var person2 = new Student('Ana', 'López', 16, '1º bachillerato A'); var person3 = new Teacher('Laura', 'Sánchez', 42, 'Matemáticas'); ``` Acabamos de crear tres personas diferentes. La primera es una persona genérica, la segunda es una estudiante (y tiene un atributo y un método extra del que carecen las personas genéricas) y la tercera es una profesora (con su propio atributo y método extra). (Por supuesto, los estudiantes y los profesores podrían tener más atributos y métodos adicionales, no solo uno). Por lo tanto, los tres objetos tendrán un método *getName()*, pero solo el *Student* tendrá un método *getCourse()* y solo el *Teacher* tendrá un método *getSpeciality()*: ```javascript person1.getName(); // Funciona person2.getName(); // Funciona person3.getName(); // Funciona person1.getCourse(); // NO FUNCIONA. person1 no es un Student person2.getCourse(); // Funciona person3.getCourse(); // NO FUNCIONA. person3 no es un Student person1.getSpeciality(); // NO FUNCIONA. person1 no es un Teacher person2.getSpeciality(); // NO FUNCIONA. person2 no es un Teacher person3.getSpeciality(); // Funciona ``` ### 6.2.5. El objeto \"super\" En los constructores de las clases *Student* y *Teacher* del apartado anterior hemos usado la palabra ***super***. ¿Qué significa exactamente? ***super*** es una **referencia a la superclase**. Por lo tanto, al escribir ```super(firstname, lastname, age)```, estamos **invocando al constructor de la superclase *Person***. Esto es **obligatorio** hacerlo en todos los constructores de las clases derivadas. Del mismo modo, si escribiéramos algo como ```super.getName()```, estaríamos invocando al método getName() de la clase madre, no de la clase actual. Esto, por supuesto, no es obligatorio, y solo lo haremos si realmente nuestro código lo necesita. ### 6.2.6. Algunos aspectos avanzados Como ves, la programación orientada a objetos no es más que una manera particular de organizar el código fuente en clases que se ha revelado muy útil a la hora de minimizar el tiempo y el esfuerzo para construir y mantener proyectos grandes. La programación orientada a objetos tiene otras características más avanzadas que vamos a describir muy brevemente, no porque sean complicadas de entender o de usar, sino porque solo tienen sentido cuando trabajas en proyectos muy grandes y con un conjunto de clases muy elaborado. Como de momento solo estamos aprendiendo, aún no necesitamos profundizar en ello. Ya lo harás cuando llegue tu momento y te lo pida el cuerpo. Lo que sí es importante es que estos conceptos te suenen para que puedas buscar información cuando lo necesites. * **Clases abstractas**: son clases de las que *no se pueden crear objetos*. ¿Entonces para qué sirven?, te preguntarás. Muy sencillo: para hacer herencia a partir de ellas. Normalmente, las clases abstractas son clases muy genéricas de las que no tiene sentido crear un objeto, porque ese objeto apenas sería funcional. La clase abstracta se limita a proporcionar un conjunto de atributos y métodos que heredan todas las clases-hija. * **Herencia múltiple**: ocurre cuando una clase hereda de varias clases-madre a la vez. Proporciona una enorme flexibilidad a la hora de diseñar nuestra arquitectura de clases, pero también provoca no pocos problemas. Muchos lenguajes, entre ellos Javascript, no la permiten. Otros, como C++ o Python, sí. * **Visibilidad**: los métodos y atributos de los objetos se pueden hacer **públicos o privados**. Si son públicos, quiere decir que pueden usarse desde cualquier lugar del código fuente. Si son privados, quiere decir que solo pueden usarse desde el código escrito dentro de la propia clase. Esto se hace para que el objeto funcione como una caja negra, cuyas \"tripas\" sean invisibles al exterior. Generalmente, los atributos de una clase suelen hacerse privados, mientras que la mayor parte de los métodos suelen ser públicos, pero puede haber tantas excepciones a esta regla que sería imposible enumerarlas. * **Sobrecarga**. Sobrecargar un método consiste en crear varias versiones del mismo que se diferencian por el número de parámetros. Puede llegar a ser muy útil en programas muy grandes con jerarquías de clases muy complejas. * **Polimorfismo**. Se llama *polimorfismo* a la capacidad de los lenguajes orientados a objetos de que existan varias versiones diferentes de un mismo elemento (métodos, generalmente) que se nombran del mismo modo pero se comportan de modo diferente. Probablemente sigues sin entender qué narices significa la frase anterior aunque la hayas leído varias veces, ¿verdad? Tranquilidad, porque a todo el mundo le ocurre la primera vez que le mencionan el término polimorfismo. Te lo explico con un ejemplo, pero tampoco te preocupes demasiado: no es algo que vayas a usar hasta dentro de muuucho tiempo. Imagina que tenemos una superclase llamada *Person* con sus clases derivadas como *Student* o *Teacher*. Es decir, como en los ejemplos anteriores. Hasta aquí, bien. Ahora sigue imaginando que tienes un método, el que sea, en la clase *Person*. Por ejemplo, *getProfession()*. Todos los objetos de tipo *Student* o *Teacher* heredarán el método *getProfession()*. Ahora bien, ¿tiene sentido que ese método sea el mismo para *Student* que para *Teacher*? Probablemente no. ¡Para empezar, el estudiante ni siquiera tiene profesión (aún)! Una cosa muy interesante que pueden hacer las clases-hija es **sobreescribir** los métodos, es decir, coger un método heredado y cambiar su código fuente. Así, puedes tener diferentes versiones del método *getProfession()*, una para cada clase de la jerarquía. Y ya lo tienes. Eso es una manifestación del **polimorfismo**: tener un método (*getProfession()*) con diferentes formas o implementaciones. Según cuál sea el objeto con el que lo llames, se ejecutará una versión u otra del método. Esto puede parecer una chorrada, pero con jerarquías de clases muy complejas ayuda a resolver situaciones muy chungas. Por ejemplo: ¿qué pasa si un profesor es, a su vez, estudiante en algún curso? Según el papel de esa persona en cada momento, habrá que ejecutar una versión diferente de *getProfession()*. Si has llegado hasta aquí en esta explicación, puedes volver a leer la definición de polimorfismo y seguramente sí la entenderás. ### 6.2.7. Objetos predefinidos de Javascript Ahora que ya conoces un poco sobre la programación orientada a objetos y cómo trabajar con ella en Javascript, puedo confesarte un secreto: *has estado utilizando objetos desde el primer momento en el que empezaste a trabajar con Javascript*. Así es. Como Javascript es un lenguaje orientado a objetos, hay un montón de objetos predefinidos que existen en todos los programas Javascript para que los uses si los necesitas. Por ejemplo, cuando hacías *Math.rand()*, estabas invocando al método *rand()* del **objeto *Math***. Este objeto es un poco especial, porque no necesitas crear una instancia. Es decir, no necesitas hacer ```var math = new Math()``` para usarlo. Con algunas clases ocurre esto, y se llaman **clases estáticas**. Otro objeto predefinido que seguro que has utilizado sin saber que lo era es el **objeto *window***. En este caso, es un objeto normal, no estático, pero no tenemos que crearlo con ```var window = new Window()``` porque Javascript lo crea automáticamente para nosotros cada vez que abrimos una ventana del navegador web. De hecho, los métodos *alert()* o *confirm()* son, en realidad, métodos del objeto *window*. Es decir, podemos escribir *window.alert()* o *window.confirm()*, y funcionarían exactamente igual. Lo que ocurre es que, si no indicamos un objeto delante del nombre del método, Javascript interpretará que se trata de un método del objeto *window*. Y así hay otro buen puñado de objetos predefinidos cuya existencia te conviene conocer. Algunos de ellos son: * **Math**: contiene un montón de métodos para operaciones matemáticas. * **window**: métodos y atributos para manejar la ventana del navegador donde se ejecuta la aplicación. * **Date**: para trabajar con fechas y horas. * **Number**: operaciones relacionadas con números. * **String**: para trabajar con cadenas de caracteres. * **Array**: para trabajar con arrays. * **JSON**: para trabajar con datos complejos codificados como JSON, un formato de intercambio de información muy utilizado con Javascript y otros lenguajes. * **Error**: para manipular los errores de ejecución y obtener información sobre ellos. ## 6.3. Un ejemplo completo Vamos a terminar esta pequeña introducción a la programación orientada a objetos mostrando un ejemplo completo desarrollado con Javascript. Puedes considerarlo un ejercicio resuelto. Es decir: *primero puedes intentar hacerlo tú, y luego comparar tu intento con mi solución*. No es necesario que tu solución y la mía sean idénticas, desde luego, puesto que siempre hay varias formas correctas de hacer lo mismo. #### Lo que queremos hacer Este es un ejemplo clásico para practicar la herencia entre clases, porque resulta fácil de entender y de programar. Se trata de escribir un programa que sea capaz de calcular ciertas magnitudes, como el área y el perímetro, de muchos tipos diferentes de figuras geométricas. Empezaremos por círculos, cuadrados y rectángulos, pero podríamos extender el programa con facilidad para abarcar otras figuras. Observa el diagrama de aquí abajo. Se trata de un **diagrama de clases**, una representación gráfica de las clases que existen en un programa y cómo heredan unas de otras. No te asustes: es sencillo leer un diagrama de clases. Más abajo te doy algunas pistas. ![Diagrama de clases - Figuras geométricas](/docs/prog-y-3d/_site/assets/images/06-01-figuras-geometricas.jpg) Cada \"caja\" de este diatrama es una clase, y en cada clase se indica su nombre, sus atributos y sus métodos. Delante de cada atributo y método verás un símbolo: + significa que ese atributo o método es público, es decir, accesible desde otras clases, y - significa que es privado, accesible solo desde la propia clase. Si no se indica lo contrario, Javascript considerará que los atributos y métodos son públicos. Es decir, todos los atributos y métodos que hemos usado hasta ahora son públicos. En sistemas complejos, es importante distinguir los atributos y métodos públicos de los privados. Además, el diagrama expresa cómo heredan las clases unas de otras. La clase *Figura* es la madre de toda la jerarquía, también llamada **superclase**. Las clases *Círculo* y *Rectángulo* son hijas de *Figura*, es decir, **subclases** o **clases derivadas**. Por último, la clase *Cuadrado* es subclase de *Rectángulo*. Por supuesto, podíamos haber añadido más figuras, pero con estas ya tienes entretenimiento para un rato. Observa, por cierto, como *Cuadrado* hereda de *Rectángulo*, y no directamente de *Figura*. El programa que vamos a escribir tiene que incluir lo siguiente: 1. **La superclase *Figura*** (figura geométrica), que contendrá: * Dos atributos: color (String) y relleno (boolean). * Un constructor que recibirá dos argumentos para inicializar los atributos. * *Getters* y *setters*, es decir, métodos para consultar el valor de los atributos (*getColor()* y *getRelleno()*) y para establecer el valor de los atributos (*setColor()* y *setRelleno()*). Entiendes por qué se llaman *getters* y *setters*, ¿verdad? * Un método *toString()* que devolverá la cadena: \"Soy una figura de color xxx y rellena/no rellena\", según lo que valgan los atributos en ese momento. 2. **Una subclase de *Figura* llamada *Círculo***. La clase *Círculo* contendrá: * Un atributo llamado *radio* (un número real). * Un constructor, como se ve en el diagrama de clases. * *Getter* y *setter* para el radio. * Los métodos *getArea()* y *getPerimetro()*. Si no recuerdas como calcular el área y el perímetro (o circunferencia) de un círculo... bueno, ¿para qué está la wikipedia? * El método *toString()* heredado de *Figura* se debe sobreescribir. Ahora, el método devolverá: \"Soy un círculo con radio = x, esta es mi superclase: yyy\", donde yyy es la salida del método *toString()* de la superclase de *Figura*. 4. **Una subclase de *Figura* llamada *Rectángulo***. La clase *Rectángulo* se comportará igual que *Círculo*, con las lógicas diferencias en atributos y métodos *getters* y *setters*. Mira el diagrama de clases si tienes alguna duda. 5. **Una subclase de *Rectángulo* llamada *Cuadrado***. Esta clase podía haberse modelado como subclase de *Figura*, pero es más cómodo hacerlo como subclase de *Rectángulo*, porque podemos aprovechar casi todo el código de su superclase. Basta con crear el siguiente constructor: ```javascript class Cuadrado { constructor(side) { super(side, side); // Llama al constructor de la superclase Rectangulo } } ``` * Además de crear el constructor, sobreescribiremos, como en los otros casos, el método *toString()*. * Atención, pregunta: ¿necesitarás sobreescribir *getArea()* y *getPerimetro()*, o funcionarán tal y como han sido heredados de *Rectángulo*? Haz la prueba a ver qué pasa... * También sobreescribiremos los métodos *setAlto()* y *setAncho()* para evitar que el largo y el ancho del cuadrado puedan tener dimensiones diferentes. 6. Finalmente, tendremos que escribir un fragmento de código para testear que todo lo anterior funcione, creando unas cuantas figuras de cada tipo y llamando a algunos métodos. #### Nuestra implementación En la implementación de la clase *Figura* vamos a usar comentarios en formato **javadoc**. Es una manera de escribir los comentarios que te vas a encontrar a menudo por ahí, puesto que se trata de un estándar de la industria. El resto de clases son tan sencillas que nos hemos ahorrado los comentarios para no complicar innecesariamente el código fuente. Como en otras ocasiones, tu trabajo aquí es intentar resolver el ejercicio antes de ver la solución. Y, una vez que empieces a leer la solución, hacerlo poco a poco y sin prisas. ```html Jerarquía de figuras geométricas . ``` ",
    "url": "/docs/prog-y-3d/_site/orientacion-a-objetos/",
    "relUrl": "/orientacion-a-objetos/"
  },"10": {
    "doc": "7. Bases de datos",
    "title": "7. Bases de datos",
    "content": "# 7. Bases de datos {: .no_toc } - TOC {:toc} ## 7.1. Almacenamiento de la información ### 7.1.1. Sistemas lógicos de almacenamiento Desde los primeros tiempos de la informática ha sido necesario **almacenar grandes cantidades de información** en soportes fisicos utilizando mecanismos que fueran independientes del propio soporte. Esos métodos de almacenamiento se denominan **sistemas de almacenamiento lógico**. ![Sistema de almacenamiento físico del IBM 360](/docs/prog-y-3d/_site/assets/images/07-01-dispositivo-almacenamiento-fisico.jpg) Sistema de almacenamiento físico del IBM 360, un ordenador de la década de 1960. Este ordenador utilizaba principalmente cintas magnéticas en lugar de discos duros para almacenar la información. En teoría, los usuarios no deberían ser conscientes de ello. Los sistemas de almacenamiento lógico nos permiten olvidarnos de cuál es el dispositivo físico donde se almacena realmente la información. El sistema lógico de almacenamiento más habitual es el **sistema de ficheros**. En él, la información se organiza en **directorios** (o carpetas) y **ficheros**, y luego un componente software del sistema operativo se encarga de traducir las operaciones lógicas sobre la información (por ejemplo, añadir un dato al final de un fichero) en operaciones físicas (por ejemplo, escribir un byte en determinado sector del disco duro). Las bases de datos que estudiaremos en este capítulo también son sistemas lógicos de almacenamiento, solo que más complejos que los sistemas de ficheros. El componente software encargado de traducir operaciones lógicas en físicas se denomia **sistema gestor de bases de datos**, y en este capítulo y el siguiente vamos a aprender a familiarizarnos con él. ### 7.1.2. Sistemas de ficheros Antes de comenzar a pelearnos con las bases de datos, conviene conocer por encima a su hermano pobre: el sistema de ficheros. Los **archivos o ficheros** son almacenes de información con una estructura determinada que se organizan en directorios (o carpetas) con organización jerárquica. Existen muchos sistemas de ficheros, dependiendo del sistema operativo: * **FAT16**: del antiguo MS-DOS y Windows 95. * **FAT32**: se introdujo en Windows 95 OSR2 y aún se usa masivamente a pesar de sus limitaciones. * **NTFS**: usado por los sistemas Windows desde Windows NT. * **ext2**, **ext3** y **ext4**: sistemas por defecto en la mayoría de las distribuciones Linux. * **ReiserFS**: otro sistema de ficheros soportado por las distribuciones Linux. * **CDFS** o **ISO 9660**: Es el sistema de ficheros nativo de los CD-ROM. * **UDF** o **ISO 13346**: Es un sistema de ficheros estandarizado usado en CDs, DVDs y Blu-Rays. * **HFS+**: sistema de ficheros nativo de MacOS. Los ficheros, a su vez, pueden ser de diferente tipo, según cómo se codifique la información en su interior: * **Ficheros de texto**: almacenan la información como texto, generalmente codificado como UTF-8. Estos ficheros pueden contener información de configuración de aplicaciones (ficheros .ini, .inf, .conf, etc), de código fuente (.html, .sql, .java, .php, etc), de texto plano o enriquecido (.txt, .rtf, .ps, etc) o información compleja codificada como XML o JSON (.xml, .json). * **Ficheros binarios**: son colecciones de bits con un formato específico que sólo pueden ser interpretadas por el programa adecuado. Hay incontables tipos de fichero binario: de imagen (.jpg, .gif, .png, etc), de vídeo (.avi, .mpg, .mp4, etc), comprimidos o empaquetados (.zip, .rar, .tar, .gz, etc), ejecutables y compilados (.exe, .com, .o, etc) y muchísimos más. Cada programa suele tener su propio formato de fichero nativo. Y los gestores de bases de datos no son una excepción. Por ejemplo * Access guarda las bases de datos en un fichero con extensión .mdb o .accdb * MySQL guarda las bases de datos en tres ficheros de extensión .frm, .myd y .myi ### 7.1.3. Bases de datos Una **base de datos** es una colección de ficheros relacionados entre sí que almacenan tanto la representación abstracta de un fragmento de información del mundo real como los datos correspondientes a ese fragmento del mundo. Las bases de datos, por lo tanto, son sistemas de almacenamiento de información más complejos y elaborados que los ficheros, puesto que no solo guardan la información en sí, sino también la forma en la que unos datos se relacionan con otros, y además proporcionan mecanismos para manipular esos datos. No se debe confundir la *base de datos* (los ficheros que guardan la información) con el *sistema gestor de base de datos* (el software que manipula esos ficheros). Existen varios tipos de bases de datos, pero las más extendidas desde hace décadas son las **bases de datos relacionales**. Durante este capítulo y el siguiente, nos referiremos exclusivamente a este tipo de bases de datos. #### Hitos históricos de las bases de datos * **Años 50**: solo existían los sistemas de ficheros secuenciales basados en cintas magnéticas. Tenían problemas de rendimiento, redundancia y mantenimiento. * **Años 60**: aparecen los primeros sistemas de ficheros aleatorios basados en discos magnéticos (discos duros). Surgen las primeras bases de datos, aunque todavía no eran relacionales y resultaban muy difíciles de manejar. * **1970**: Frank Codd, de IBM, publica un artículo crucial en la historia de la informática: *“A Relational Model of Data for Large Shared Data Banks”*. En él, sienta las bases del modelo relacional que todavía usamos en la actualidad. * **Años 80**: IBM crea DB2, un mítico gestor de bases de datos relacionales y, con él, el lenguaje SQL. * **Años 90**: IBM lanza DB2 Parallel Edition, que evolucionaría a DB2 Data Partition Feature, la primera base de datos distribuida. * **Finales de los 90**: BD2 y Oracle incorporan el paradigma de orientación a objetos. * **Año 2000 - actualidad**: la eclosión de Internet hace crecer el tamaño de las bases de datos de manera desconocida hasta ahora. Se generalizan bases de datos distribuidas y no relaciones (Google, Amazon, Facebook...), los sistemas de ayuda a la toma de decisiones, el *big data* y las bases de datos multidimensionales. Sin embargo, para aplicaciones convencionales, las bases de datos relacionales de Codd aún siguen utilizándose en la inmensa mayoría de los casos. #### Sistemas gestores de bases de datos Un **Sistema Gestor de Bases de Datos** (**SGBD** o **DBMS** en inglés) es el programa (o conjunto de programas) encargados de almacenar y manipular la información de una base de datos. Las **funciones** de un SGBD son: * Permitir el acceso sencillo y eficiente a los datos * Garantizar la integridad de los datos * Garantizar la seguridad de los datos * Almacenar no solo los datos, sino la estructura de los mismos y la forma en la que se relacionan unos con otros * Mantener estadísticas de uso * Permitir la concurrencia de usuarios (accesos múltiples simultáneos) * Independizar los datos físicos de las aplicaciones de usuario * Ofercer conectividad con el exterior * Incorporar herramientas de copia de seguridad Existen muchos sistemas gestores de bases de datos relacionales, algunos creados para manejar de forma sencilla bases de datos pequeñas y con pocos accesos, como **Microsoft Access** o **Libreoffice Base**, y otros pensados para soportar grandes volúmenes de información y muchos accesos simultáneos, como **MySQL**, **MariaDB**, **Oracle**, **SQL Server** o **PostgreSQL**. #### Conceptos clave en bases de datos relacionales Si hablamos exclusivamente de **bases de datos relacionales** (recuerda: existen otros tipos, pero las mayoritarias son las relacionales), hay ciertos conceptos que van a aparecer de forma recurrente a partir de ahora. Vamos a definirlos, pero no trates de retenerlos todos: te familiarizarás con ellos poco a poco a lo largo del capítulo. * **Tabla (o relación)**: la información en las bases de datos relacionales se organiza en tablas compuestas por filas y columnas. * **Registro**: un registro es cada una de las filas de cada tabla. Por ejemplo, en la base de datos de los clientes de una empresa, la tabla de clientes contendrá un cliente en cada fila. Pues bien, cada fila es un *registro*. * **Campo**: cada registro puede descomponerse casi siempre en fragmentos más pequeños. Por ejemplo, en la tabla de clientes, para cada cliente podemos almacenar su DNI, su nombre, sus apellidos, su domicilio, email, teléfono, etc. Cada uno de estos fragmentos de información se denomina *campo*. * **Tipo de dato**: es el dominio al que pertenece cada dato almacenado en cada campo, es decir, el tipo de dato (número entero, número real, cadena de caracteres, fecha, hora, etc) * **Campo clave**: es un campo que permite diferenciar unívocamente cada registro. Por ejemplo, el DNI es un posible campo clave de la tabla de clientes. * **Consulta**: las consultas sirven para buscar y extraer información de la base de datos. Son un mecanismo muy sencillo para hacer algo muy complicado: bucear entre toneladas de información para localizar justo lo que buscamos. * **Índice**: la base de datos construirá índices para acelerar el acceso a las tablas más voluminosas. Es un mecanismo interno de la base de datos que casi nunca necesitaremos manipular. #### Componentes de una base de datos relacional Los SGBD relacionales son programas muy complejos. Tanto que, independientemente de su desarrollador, suelen tener varios componentes: * **Lenguaje de definición de datos (DDL)**: nos permite crear la representación lógica de los datos y sus relaciones. * **Lenguaje de control de datos (DCL)**: sirve para gestionar los permisos de acceso. * **Lenguaje de control de transacciones (TCL)**: se utiliza para asegurar la integridad de los datos. * **Lenguaje de manipulación de datos (DML)**: nos permite insertar datos, borrarlos, modificarlos, etc. Pueden ser lenguajes procedimentales (el programador indica cómo se van a manipular los datos) o no procedimentales (el programador indica qué manipulación desea, y el SGBD se encarga de determinar los procedimientos más apropiados). * **Diccionario de datos**: es una base de datos especial, porque contiene información sobre el resto de bases de datos existentes en el sistema. * **Motor o monitor de la base de datos**: es el interfaz entre los datos y los programas de usuario. Se encarga del acceso seguro, íntegro y eficiente a los datos físicos. * **Administrador de la base de datos (DBA)**: es la persona encargada de controlar la privacidad y seguridad de los datos y realizar el mantenimiento de la base de datos. En el resto del capítulo aprenderemos a usar algunos de estos componentes y, en particular, nos centraremos en el lenguaje DML (de manipulación de datos), que es el que se utiliza la gran parte del tiempo que estamos trabajando con una base de datos. La implementación más popular de DML es, sin duda, el **lenguaje SQL**, al que dedicaremos bastante tiempo. SQL, así como otros lenguajes de la base de datos, puede usarse de tres formas distintas: * **A través de un programa cliente**: un programa cliente es aquel que nos permite conectarnos con el gestor de bases de datos y enviarle órdenes. Las respuestas también se reciben a través del programa cliente. Por ejemplo, para **MySQL** existen dos clientes muy populares, que son **PHPMyAdmin** y **MySQL Workbench**. * **De forma programada**: se compone un archivo con varias sentencias SQL que realizan una tarea más o menos compleja. Ese archivo se envía a la base de datos para que lo ejecute y la base de datos nos responde con el resultado. * **De forma embebida o empotrada**: se insertan las instrucciones SQL dentro de otro lenguaje *host* o huésped (por ejemplo, PHP, aunque puede ser casi cualquier otro). El programa se ejecuta y, durante la ejecución, se lanzan las sentencias SQL contra la base de datos. Los resultados serán devueltos en esta ocasión al programa huésped, que se encargará de procesarlos. Empezaremos usando SQL en las dos primeras formas, pero en aplicaciones web se usa continuamente de la tercera forma. La veremos cuando hablemos de desarrollo de aplicaciones con PHP. ## 7.2. El modelo de datos Antes de aprender el lenguaje SQL, tenemos que hacer otra cosa que muchos programadores detestan: **diseñar la base de datos** con la que vamos a trabajar. O, al menos, conocer un par de reglas básicas de diseño de bases de datos para poder afrontar con éxito la creación de bases de datos sencillas y para poder interpretar los diseños de otros programadores. Un **modelo de datos** es una simplificación (o *modelización*) de la parte del mundo que queremos convertir en una base de datos. El modelo de datos, por lo tanto, busca una representación de forma abstracta y no ambigua de los datos de la aplicación y las relaciones entre ellos. Para una aplicación dada, suelen existir varios modelos de datos válidos (e infinitos modelos incorrectos). En esta sección vamos a aprender a construir modelos de datos razonablemente correctos para sistemas sencillos. ### 7.2.1. Diagramas E-R Los **diagramas E-R** o **diagramas entidad-relación** son una representación gráfica de los datos del mundo real que pretendemos modelar. ¿Has visto alguna vez los planos de un arquitecto para una casa? El arquitecto no se limita a dibujar la planta de la casa, sino que elabora multitud de planos diferentes de la misma casa: instalaciones, cimentación, evacuación de agua, etc. Pues bien, para crear una aplicación informática, los \"arquitectos\" (que, en informática, se denominan **ingenieros**) también elaboran multitud de \"planos\" diferentes de la misma aplicación. **El diagrama E-R es uno de esos \"planos\"**. No es labor del programador elaborar esos planos. Siguiendo con la analogía anterior, si el ingeniero informático es como el arquitecto, en programador es como el albañil. Es decir, el programador se limita a seguir los planos que le facilita el arquitecto y, en todo caso, a realizar alguna pequeña corrección o sugerencia sobre el terreno. Entonces, si el diagrama E-R pertenece al dominio de la ingeniería informática, ¿por qué tenemos que aprender a hacerlos? Por una razón muy sencilla: si la aplicación es pequeña, no suele existir un proceso de ingeniería previa (igual que no contratamos a un arquitecto para construir la caseta del perro). Y es el programador/a quien debe hacer todo el trabajo. De entre todos los \"planos\" de la aplicación, el diagrama E-R es uno de los más importantes, sobre todo si hablamos de aplicaciones web. Así que es muy conveniente que aprendas a elaborarlos y a interpretarlos. Además, son muy sencillos de hacer. ### 7.2.2. Elementos de los diagramas E-R Los símbolos concretos de los diagramas E-R puede diferir ligeramente entre metodologías, pero en realidad significan lo mismo. Aquí veremos los llamados **diagramas de Chen**, por el taiwanés Peter P. Chen, que fue quién los creó en 1976 cuando trabajaba en la Universidad de Harvard (EEUU) y que son de los más extendidos en la industria. Son diagramas tan, tan sencillos, que se elaboran con solo tres elementos: Elemento|Significado|Símbolo -|-|- Entidades|Son los datos de interés para el sistema: categorías de objetos reales o abstractos de los que se necesita mantener información|![Diagramas ER - Entidades](/docs/prog-y-3d/_site/assets/images/07-02-diagramas-er-entidades.png) Atributos|Son las características propias de las entidades. Cada entidad puede tener varios atributos asociados|![Diagramas ER - Atributos](/docs/prog-y-3d/_site/assets/images/07-02-diagramas-er-atributos.png) Relaciones|Son las conexiones lógicas entre las entidades. Representan relaciones que existen en el mundo real y que son relevantes para nuestra aplicación|![Diagramas ER - Relaciones](/docs/prog-y-3d/_site/assets/images/07-02-diagramas-er-relaciones.png) Aquí te dejo un ejemplo de diagrama E-R. ¡No te asustes todavía! Solo es para que veas qué aspecto tiene uno de estos diagramas, no para que lo comprendas todo de golpe. En las siguientes secciones aprenderemos a hacer todo esto. ![Ejemplo de diagrama ER](/docs/prog-y-3d/_site/assets/images/07-02-diagramas-er-ejemplo.png) ### 7.2.3. Entidades En un diagrama E-R, las **entidades** representan las categorías de datos que son importantes para el sistema, es decir, datos que nuestra base de datos debe almacenar. * Pueden corresponderse con **objetos tangibles** (personas, artículos, libros, billetes de avión, etc) o con **objetos intangibles** (organizaciones, profesiones, sucesos, etc.) * Se refieren a categorías de objetos. Es decir, cada objeto individual del sistema será sólo una ocurrencia de la entidad. En ese sentido, se parecen a las clases de la programación orientada a objetos. * Se les asigna un nombre que debe ser un **sustativo**. Por ejemplo: CLIENTE, HOTEL, FACTURA, etc. Si no puedes asignarles un sustantivo con facilidad, probablemente no estás ante una entidad. * En particular, *nunca* deberías asignar un **verbo** a una entidad. Los verbos implican acciones, y las acciones son parte del código de tu programa, no de la base de datos. Es decir, una acción probablemente se referirá a algo que tu programa hace con los datos, no a los datos mismos, que es lo que estamos tratando de modelar ahora. ### 7.2.4. Atributos Los **atributos** son características que definen a cada entidad, como los atributos de las clases en programación orientada a objetos. * Los atributos pueden ser: * **Atributos clave**: diferencian a cada ocurrencia de todas las demás * **Atributos descriptores** (o \"normales\"): designan otras características propias de la entidad * Los atributos clave suelen distinguirse del resto anteponiendo el símbolo \"#\" al identificador del atributo. * Por ejemplo, la entidad CLIENTE puede tener como atributos: #dni, nombre, apellido1, apellido2, teléfono y email. Los atributos concretos dependerán de lo que necesite nuestra aplicación. * Cada atributo pertenece a un **dominio**, es decir, tiene un tipo de datos, y solo puede tomar valores dentro de ese dominio: número entero, número real, cadena de caracteres, fecha, hora, booleano, etc. Hay dos formas de representar los atributos de una entidad en un diagrama E-R. Puedes usar la que más te guste. Por ejemplo, para la entidad CLIENTE: ![Ejemplo de atributos en un diagrama ER](/docs/prog-y-3d/_site/assets/images/07-03-diagramas-er-ejemplo-de-atributos.png)|![Ejemplo de atributos en un diagrama ER](/docs/prog-y-3d/_site/assets/images/07-03-diagramas-er-ejemplo-de-atributos-2.png) ### 7.2.5. Relaciones Las **relaciones** representan las conexiones que existen entre las entidades en el mundo real. Se les asigna un nombre compuesto generalmente por **un verbo o sintagma verbal**. Por ejemplo: ![Ejemplo de relación en un diagrama ER](/docs/prog-y-3d/_site/assets/images/07-04-diagramas-er-ejemplo-de-relacion.png) Una relación **debería poder leerse** perfectamente en ambos sentidos y formar frases con significado. En el ejemplo anterior: * Los CLIENTES *reservan* HOTELES. * Los HOTELES *son reservados* por CLIENTES. Las dos frases tienen sentido, aunque lo habitual es que tengamos que cambiar el verbo a su forma pasiva en una de ellas. Es importante que tengas en cuenta que no hay por qué representar en la base de datos *todas* las relaciones que existen en el mundo real (que suelen ser numerosísimas), sino solo las que resultan relevantes para la aplicación. Si alguna vez tienes dudas sobre si debes incluir o no una relación en tu diagrama E-R, hazte esta pregunta. ¿Realmente necesito guardar *eso* en mi base de datos? ### 7.2.6. Grado de las relaciones Casi todas las relaciones son **binarias**, es decir, relacionan a dos entidades entre sí. Se dice que esas relaciones tienen **grado 2**. Pero también puede haber relaciones **ternarias** (grado 3), **cuaternarias** (grado 4) y, en general, **n-arias** (grado n), aunque son menos habituales cuanto mayor es el grado. Por ejemplo, esta es una relación ternaria: ![Ejemplo de relación ternaria en un diagrama ER](/docs/prog-y-3d/_site/assets/images/07-04-diagramas-er-ejemplo-de-relacion-ternaria.png) La recomendación general es que cualquier relación de grado mayor que 2 debe tratar de reducirse (sin perder información) a varias relaciones de grado 2, porque las relaciones no binarias son más difíciles de manejar. Sin embargo, esto no siempre es posible y tenemos que apañarnos con relaciones de grado 3 o 4. ### 7.2.7. Cardinalidad de las relaciones La **cardinalidad** de una relación es el número de ocurrencias de una entidad asociado a cada ocurrencia de la otra entidad. Sí, lo sé: esa frase no se entiende. Enseguida te lo explico mejor con un ejemplo. Antes, déjame decirte otra cosa incomprensible. Las cardinalidades pueden ser de tres tipos: * **De uno a uno**. Se simboliza como **1:1** * **De uno a muchos**, simbolizado **1:N** * **De muchos a muchos**, simbolizado **N:N** o también **N:M** Es muy importante identificar bien la cardinalidad de cada relación porque luego influirá a la hora de construir la base de datos. Ahora sí, vamos a comprender todo este galimatías mediante un ejemplo. Supón que tenemos una entidad llamada CLIENTE y otra entidad llamada HOTEL. Sabemos que ambas están conectadas mediante la relación RESERVA, porque, en el mundo real, los *clientes reservan hoteles* y los *hoteles son reservados por clientes*. ![Ejemplo de cardinalidad en un diagrama ER](/docs/prog-y-3d/_site/assets/images/07-05-diagramas-er-cardinalidad-1.png) Ahora bien, **¿cuál es la cardinalidad de esa relación?** ¿1:1, 1:N o N:N? Para responder a eso, siempre debes plantearte estas situaciones: 1. **Tomamos un CLIENTE cualquiera. ¿En cuántos hoteles puede hacer una reserva?** * Respuesta: en 0, 1 o MUCHOS. * Por lo tanto, en el lado del HOTEL de la relación, la *participación* es 0 como mínimo y N como máximo. Esto se simboliza con (0,N) ![Ejemplo de cardinalidad en un diagrama ER](/docs/prog-y-3d/_site/assets/images/07-05-diagramas-er-cardinalidad-2.png) 2. **Tomamos un HOTEL cualquiera . ¿Cuántos clientes pueden hacer la reserva en él?** * Respuesta: 0, 1 o MUCHOS clientes. * Por lo tanto, en el lado del CLIENTE la *participación* también es 0 como mínimo y N como máximo. Es decir, otra vez (0,N) ![Ejemplo de cardinalidad en un diagrama ER](/docs/prog-y-3d/_site/assets/images/07-05-diagramas-er-cardinalidad-3.png) 3. **Ahora tomamos el valor MÁXIMO de participación en cada extremo.** * En el extremo del CLIENTE, la participación era (0,N). Nos quedamos con el máximo: N * En el extemo del HOTEL, la participación también era (0,N). Nos quedamos con el maximo: N ![Ejemplo de cardinalidad en un diagrama ER](/docs/prog-y-3d/_site/assets/images/07-05-diagramas-er-cardinalidad-4.png) **Por lo tanto, *la cardinalidad de la relación RESERVA* es de N:N**, lo que se simboliza así en el diagrama E-R: ![Ejemplo de cardinalidad en un diagrama ER](/docs/prog-y-3d/_site/assets/images/07-05-diagramas-er-cardinalidad-5.png) #### Cardinalidad de relaciones N-arias Recuerda que las relaciones N-arias son aquellas en las que intervienen más de dos entidades. Es más complicado calcular la cardinalidad o establecer los atributos de la relación, pero por lo demás son iguales que las binarias. Por ejemplo: ![Ejemplo de cardinalidad en relación ternaria en un diagrama ER](/docs/prog-y-3d/_site/assets/images/07-05-diagramas-er-cardinalidad-relaciones-n-arias.png) #### Una grafía alternativa Existe otra forma de dibujar las entidades y las relaciones, prescindiendo del rombo. Y las cardinalidades de cada extremo también se indican gráficamente y no con números: ![Ejemplo de grafía alternativa para los diagramas ER](/docs/prog-y-3d/_site/assets/images/07-06-diagramas-er-grafia-alternativa.png) ### 7.2.8. Atributos propios de las relaciones No solo las entidades tienen atributos: **algunas relaciones complejas tienen sus propios atributos**. Suelen ser aquellos atributos que no encajan bien en ninguna de las entidades relacionadas. Por ejemplo: ![Ejemplo de relación con atributos](/docs/prog-y-3d/_site/assets/images/07-07-diagramas-er-atributos-de-relaciones.png) Intenta encajar el atributo *fecha de entrada* en cualquiera de las dos entidades y verás que no hay manera: * No encaja bien en CLIENTE, porque un cliente puede tener muchas fechas de entrada diferentes (una por cada reserva), no solo una. * No encaja bien en HOTEL, porque en cada hotel habrá un montón de fechas de entrada (una por cada cliente que haya reservado). * Por lo tanto, la fecha de entrada solo encaja en la relación. Si lo piensas, tiene sentido: la fecha de entrada es un atributo de la RESERVA, no del cliente ni del hotel. ### 7.2.9. Relaciones reflexivas En ocasiones, una entidad puede relacionarse consigo misma. ¿Que te parece raro? No lo es tanto. Mira esto: ![Ejemplo de relación reflexiva en diagrama ER](/docs/prog-y-3d/_site/assets/images/07-08-diagramas-er-relacion-reflexiva.png) Como los jefes también son, a su vez, empleados, ¿cómo podríamos modelar esta relación entre jefes y empleados sin una relación reflexiva? La respuesta es simple: no podríamos. O, al menos, no podríamos hacerlo *bien*. Las relaciones reflexivas existen por la sencilla razón de que también existen en el mundo real. ### 7.2.10. Entidades fuertes y débiles A veces, se distingue entre **entidades fuertes** y **entidades débiles**. * Las **entidades fuertes** no dependen de ninguna otra y tienen existencia por sí mismas. * Las **entidades débiles** sí dependen de otras, y pueden hacerlo de dos modos: * *Dependencia en existencia*: Las ocurrencias de la entidad débil necesitan que haya alguna ocurrencia de la fuerte para existir. Si no, no tienen sentido. * *Dependencia en identificación*: Cada ocurrencia de la entidad débil necesita de alguna ocurrencia de la fuerte para poder identificarse. Es decir, la entidad débil sólo puede formar su clave usando la clave de la entidad fuerte. Las entidades débiles suelen representarse así para distinguirlas de las fuertes: ![Ejemplo de entidades débiles](/docs/prog-y-3d/_site/assets/images/07-09-diagramas-er-entidades-debiles.png) He aquí un ejemplo de **dependencia en existencia**: imagina una base de datos de los empleados de una empresa en la que, además de la información de los propios empleados, guardamos la información de los hijos e hijas de estos empleados. Una ocurrencia de la entidad *Hijo* no tiene sentido si no tiene asociada al menos una ocurrencia de la entidad *Empleado*, no solo porque no podemos tener hijos sin empleados, sino porque, en el mundo real (que, no lo olvides, es lo que estamos tratando de modelar) es exactamente eso lo que ocurre: que no existen los hijos de empleados sin empleados. ![Ejemplo de dependencia en existencia](/docs/prog-y-3d/_site/assets/images/07-09-diagramas-er-entidades-debiles-dependencia-en-existencia.png) Y este es un ejemplo de **dependencia en identificación**. En este caso, no solo no tiene sentido que exista un *Municipio* que no esté asociado a ninguna *Provincia*, sino que incluso para identificar al municipio necesitamos saber a qué provincia pertenece (por ejemplo, porque puede haber municipios con el mismo nombre en provincias diferentes). ![Ejemplo de dependencia en identificación](/docs/prog-y-3d/_site/assets/images/07-09-diagramas-er-entidades-debiles-dependencia-en-identificacion.png) ### 7.2.11. Control de la redundancia Un diagrama ER es **redundante** si, al eliminar una relación, no se pierde información importante para el sistema. Las redundancias deben evitarse: son síntoma de un mal análisis y causarán problemas durante el diseño y la implementación, porque provocarán duplicidades en la información. Las redundancias pueden detectarse porque: * Hay ciclos en el diagrama E-R (¡pero, ojo, que no todos los ciclos son redundantes! Hay que pensarlo detenidamente antes de romper un ciclo) * Hay dos o más relaciones en el ciclo con el mismo significado * Las cardinalidades permiten eliminar una relación sin perder información (generalmente ocurre con cardinaridades 1:1 o, como mucho, 1:N) ### 7.2.12. Diagramas extendidos: relaciones jerárquicas Los **diagramas EE-R** (**diagramas entidad-relación extendidos**) permiten representar de forma especial una relación muy habitual en el mundo real cuyo significado, sin embargo, no puede atraparse completamente en un diagrama E-R convencional. Se trata de la **relación jerárquica**. En las relaciones jerárquicas, existe una entidad \"madre\" (o \"superentidad\") y una o varias entidades \"hijas\" (o \"subentidades\"), y se introduce el concepto de **herencia**, ya que las entidades hijas heredan todos los atributos de la entidad padre. Como en las clases de la programación orientada a objetos, vamos. Debes sospechar que estás ante una relación jerárquica si el nombre de la relación encaja bien con las palabras ***ES UN*** o ***PUEDE SER UN***. Por ejemplo, en una empresa dedicada al desarrollo de software: * Un EMPLEADO ***PUEDE SER UN*** PROGRAMADOR * Un EMPLEADO ***PUEDE SER UN*** COMERCIAL * Un EMPLEADO ***PUEDE SER UN*** DIRECTIVO Ahí tienes un ejemplo claro de relación jerárquica, que gráficamente se representa así: ![Ejemplo de relación jerárquica](/docs/prog-y-3d/_site/assets/images/07-10-diagramas-er-relacion-jerarquica.png) Observa que la relación no se dibuja con un rombo sino con un **triángulo invertido** y se prescinde de la etiqueta, que siempre sería *ES UN* o *PUEDE SER UN*. Por lo demás, estas relaciones puede tener atributos, como cualquier otra relación, y suelen ser N-arias. Las subentidades pueden añadir nuevos atributos propios o incluso redefinir algunos de los atributos de la superentidad si es necesario. #### Tipos de relaciones jerárquicas Hay varios **tipos de relaciones jerárquicas**, y es importante distinguirlas cuando modelamos nuestra base de datos porque afectará a la forma en la que implementemos la base de datos. **Según el solapamiento:** * **Relaciones exclusivas**: una ocurrencia de la entidad padre debe ser una ocurrencia de una y sólo una entidad hija * **Relaciones inclusivas**: una ocurrencia de la entidad padre puede ser una ocurrencia de varias entidades hijas **Según la extensión:** * **Relaciones totales**: una ocurrencia de la entidad padre debe ser, al menos, una ocurrencia de alguna entidad hija * **Relaciones parciales**: una ocurrencia de la entidad padre puede no ser ninguna ocurrencia de ninguna de sus entidades hijas Se puede dar cualquier combinación de ellas, pero no te preocupes: es fácil entender las diferencias entre unos y otros tipos de relación jerárquica con unos pocos ejemplos, como siempre: **RELACIÓN JERÁRQUICA EXCLUSIVA TOTAL** En este ejemplo, un EMPLEADO: * Puede pertenecer a una y solo una subentidad, es decir, no puede ser al mismo tiempo TÉCNICO y COMERCIAL o COMERCIAL y DIRECTIVO (**exclusiva**). * Tiene que pertenecer necesariamente a alguna de las subentidades, es decir, tiene que ser TÉCNICO, COMERCIAL o DIRECTIVO a la fuerza (**total**) ![Ejemplo de relación jerárquica exclusiva total](/docs/prog-y-3d/_site/assets/images/07-10-diagramas-er-relacion-jerarquica-exclusiva-total.png) **RELACIÓN JERÁRQUICA EXCLUSIVA PARCIAL** En el siguiente ejemplo, un LIBRO: * Puede pertenecer a una y solo una subentidad, es decir, no puede ser al mismo tiempo NOVELA y ENSAYO, por ejemplo (**exclusiva**). * Podría pertenecer a alguna subentidad no contemplada en la jerarquía, es decir, podría no ser ni NOVELA, ni ENSAYO ni POESÍA (**parcial**) ![Ejemplo de relación jerárquica exclusiva parcial](/docs/prog-y-3d/_site/assets/images/07-10-diagramas-er-relacion-jerarquica-exclusiva-parcial.png) **RELACIÓN JERÁRQUICA INCLUSIVA TOTAL** En este ejemplo, un UNIVERSITARIO: * Podría pertenecer simultáneamente a más de una subentidad, es decir, podría ser al mismo tiempo ESTUDIANTE y PROFESOR (por ejemplo, un profesor que se matricula como estudiante en algún curso de postgrado) (**inclusiva**). * Tiene que pertenecer a la fuerza a alguna de las subentidades, es decir, tiene que ser ESTUDIANTE, PROFESOR y OTROS (**total**). ![Ejemplo de relación jerárquica inclusiva total](/docs/prog-y-3d/_site/assets/images/07-10-diagramas-er-relacion-jerarquica-inclusiva-total.png) **RELACIÓN JERÁRQUICA INCLUSIVA PARCIAL** Y, en este último ejemplo, tenemos que un VEHÍCULO: * Podría pertenecer simultáneamente a más de una subentidad, es decir, podría considerarse al mismo tiempo TURISMO u FURGONETA (por ejemplo, un monovolumen) (**inclusiva**). * Podría pertenecer a alguna subentidad no contemplada en la jerarquía, es decir, podría no ser ni TURISMO, ni FURGONETA ni CAMIÓN (por ejemplo, una BICICLETA) (**parcial**). ![Ejemplo de relación jerárquica inclusiva parcial](/docs/prog-y-3d/_site/assets/images/07-10-diagramas-er-relacion-jerarquica-inclusiva-parcial.png) ## 7.3. Paso del diagrama E-R al modelo relacional Los diagramas E-R son una herramienta para representar gráficamente el **modelo conceptual** de una base de datos. Es decir, para crear un modelo abstracto y no ambiguo de la realidad. Pero un diagrama E-R no se puede implementar directamente en un ordenador. Antes hay que convertirlo a un **modelo lógico**, es decir, a un modelo implementable en un ordenador. El modelo lógico más popular desde hace décadas es el **modelo relacional**. En esta sección vamos a ver en qué consiste y cómo convertir nuestros diagramas E-R en tablas relacionales que podamos transformar en bases de datos reales. ### 7.3.1. Qué es el modelo relacional El modelo relacional se basa en el **álgebra relacional**, una rama de las matemáticas muy bien desarrollada. Por ese motivo, las tablas también se llaman **relaciones**, lo cual puede inducir a errores, porque en los diagramas E-R llamábamos relaciones a la conexiones entre entidades. Para evitar confusiones, nosotros llamaremos **tablas** a las relaciones del modelo relacional. Por lo tanto, **en el modelo relacional *toda la información se almacena en tablas***: * Cada tabla está compuesta por **filas**, que se llaman **registros** o **tuplas**. * Cada tabla tiene **columnas**, denominadas **campos**. * Cada **campo** tiene asignado un **dominio** o tipo de datos (número entero, número real, cadena de caracteres, etc). * Cada registro contiene la información correspondiente a una ocurrencia de una entidad o de una relación del diagrama E-R. Por ejemplo, la entidad CLIENTES puede convertirse en una tabla como esta: ![Ejemplo de relación jerárquica inclusiva parcial](/docs/prog-y-3d/_site/assets/images/07-11-ejemplo-de-tabla-relacional.png) Aunque los diagramas E-R y el modelo relacional se inventaron separadamente, ambos tienen una conexión muy estrecha que hace que los diagramas E-R puedan **convertirse en bases de datos relacionales con facilidad**. El paso de un modelo al otro se hace mediante unas reglas, aunque en determinados casos hay que saber saltárselas si existe una buena razón para ello. ### 7.3.2. Pasos para convertir un diagrama E-R en un modelo relacional La **conversión de un diagrama E-R a un modelo relacional**, es decir, a un **conjunto de tablas**, debe ser un proceso en el que *no se pierda información* y en el que obtengamos como resultado *una base de datos lo más optimizada posible*. Para lograr esos dos objetivos, **seguiremos siempre estos dos pasos**: 1. **Convertir el diagrama E-R (modelo conceptual) en un conjunto de tablas (modelo lógico) con las *reglas de paso a tablas*.** En esta transformación no se debe perder ninguna información, es decir, el modelo resultante debe ser semánticamente equivalente al modelo original. Este proceso se suele denominar **paso a tablas** y existen unas reglas muy sencillas para hacerlo bien. Las veremos enseguida. Solo tienes que seguirlas y obtendrás una base de datos relacional bien diseñada (siempre que tu diagrama E-R también estuviera bien diseñado, claro). 2. **Normalizar la base de datos.** Este proceso sirve para asegurar que la redundancia se mantiene a un nivel mínimo y que no se van a producir problemas durante la utilización de la base de datos. A continuación, vamos a ver cómo dar estos dos pasos. Pero antes necesitamos familiarizarnos con la terminología del modelo relacional. ### 7.3.3. Conceptos clave del modelo relacional Antes de comenzar a ver las reglas de paso a tablas, tienes que tener muy clara la **terminología del modelo relacional**. Si ya conoces estos términos, puedes saltar sin ningún problema al siguiente apartado. Muchos de estos conceptos ya han aparecido antes en diferentes momentos. Aquí vamos a organizarlos y a definirlos claramente antes de continuar. 1. **Tabla o relación** Es un conjunto de celdas dispuesto en *filas (registros)* y *columnas (campos)*. * Cada tabla guarda la información correspondiente a *una entidad* o *una relación* del modelo ER. * Cada *registro* guarda *una ocurrencia* de la entidad o relación. Por ejemplo, en una tabla de CLIENTES, cada registro guarda la información de *un cliente*. * Cada *campo* guarda *un atributo* de la entidad o relación. Por ejemplo, en una tabla de CLIENTES, cada campo guarda una parte de la información de los clientes. Así, existirá un campo *DNI*, un campo *nombre*, un campo *apellido1*, un campo *apellido2*, etc. Las celdas de la tabla deben contener *valores atómicos*. 2. **Dominio** Es el conjunto de valores que puede tomar un campo. Es decir, es el *tipo de datos* al que pertenece un campo. 3. **Clave primaria** Es un *campo o conjunto de campos* cuyos valores determinan unívocamente el valor del resto de campos del registro. Dicho de otra manera: el resto de campos del registro dependen funcionalmente de la clave primaria (véase “Normalización”). Por ejemplo, en una tabla CLIENTES, la clave primaria puede ser el DNI de los clientes, porque cada cliente tendrá un DNI diferente y es imposible que se repita. Suele crearse un campo específico para la clave primaria, al que casi siempre se le llama, por convenio, **ID** (de \"identificador\"). A veces se le agrega el nombre de la tabla: *idCliente* o *id_cliente*. 4. **Clave candidata** Es un campo o conjunto de campos que *podrían ser clave primaria*, pero no lo son. En algunas tablas encontraremos varias claves candidatas, pero solo una puede ser elegida como clave primaria. 5. **Clave ajena, externa o foránea** Es un campo o conjunto de campos de una tabla que, sin ser clave en dicha tabla, sí que *forman la clave primaria en alguna otra tabla* de la base de datos. En el siguiente ejemplo puedes ver todos esos elementos señalados en una tabla de ALUMNOS que puede pertenecer a la base de datos de un instituto, una universidad, una escuela de educación primaria, una academia de idiomas, etc. ![Partes de una tabla relacional](/docs/prog-y-3d/_site/assets/images/07-11-partes-de-una-tabla-relacional.png) ### 7.3.4. Reglas de paso a tablas Lo hemos dicho varias veces, pero lo repetimos: **en las bases de datos relacionales *sólo existen tablas***. La distinción entre \"entidad\" y \"relación\" desaparece. Tanto las entidades como las relaciones del modelo E-R deben convertirse en tablas. ¡Y no podemos perder información por el camino! A partir de ahora, representaremos de forma resumida las tablas del modelo relacional con el siguiente formato: ``` NOMBRE-DE-TABLA(campo-clave#, campo1, campo2, ..., campoN) ``` Por ejemplo: ``` ALUMNOS (id#, dni, nombre, apellido1, apellido2, domicilio, teléfono, fecha_nac, id_grupo) GRUPOS (id#, denominación, aula) ``` En esta representación resumida no se indican los dominios (es decir, los tipos de datos). Teniendo esto en cuenta, vamos a ver, uno a uno, cómo convertir en tablas del modelo relacional todos los elementos de los diagramas E-R: * Entidades y sus atributos * Relaciones 1:1 * Relaciones 1:N * Relaciones N:N * Relaciones de dependencia (entidades fuertes y débiles) * Relaciones reflexivas * Relaciones N-arias * Relaciones de jerarquía (superentidades y subentidades) #### Entidades y sus atributos Las **entidades** del diagrama E-R **se convierten en tablas** del modelo relacional. Siempre. Los **atributos** de la entidad pasan a ser **campos** de la tabla. Si algún atributo no es atómico (es decir, si se puede descomponer en atributos más pequeños) tendremos que arreglarlo durante la **normalización**, un proceso de revisión de las tablas que veremos más adelante. Por ejemplo, aquí puedes ver una entidad ALUMNOS convertida en una tabla del mismo nombre: ![Paso a tablas - Entidades y atributos](/docs/prog-y-3d/_site/assets/images/07-12-paso-a-tablas-entidades-y-atributos.png) #### Relaciones 1:1 Las **relaciones 1:1** del modelo E-R se convierten en **claves ajenas** del modelo relacional, aunque a veces hay que crear una **tabla nueva** para la relación. Para decidir qué hacer, necesitamos fijarnos muy bien en la **cardinalidad** de la relación: * **Si las dos entidades tienen participación (1,1)**, nos llevamos la clave primaria de una entidad como clave ajena a la otra (en principio, da igual cuál elijamos) (*ver ejemplo 1*). * **Si una de las entidades tiene participación (0,1) y la otra (1,1)**, nos llevamos la clave de la parte (1,1) a la parte (0,1) para evitar valores nulos (*ver ejemplo 2*). * **Si las dos entidades tienen participación (0,1)**, crearemos una tabla nueva para la relación, que contendrá las claves de las dos entidades más los atributos propios de la relación, si los hay. La clave de la nueva tabla será una cualquiera de las claves ajenas (*ver ejemplo 3*). * En los dos primeros casos, si la relación tiene **atributos**, nos los llevamos a la entidad donde hayamos migrado la clave. En el último caso, los posibles atributos se quedan en la tabla nueva. **Ejemplo 1**: aquí tenemos dos entidades con una relación 1:1. Las participaciones son (1,1) en ambos extremos. Por lo tanto, podemos mover la clave primaria como clave ajena a cualquiera de los dos extremos (el que nos parezca más lógico). Hemos decidido mover la clave de MATRICULA a la tabla de ALUMNOS. ![Paso a tablas - Relaciones 1:1 - Caso 1](/docs/prog-y-3d/_site/assets/images/07-12-paso-a-tablas-relaciones-1-1-A.png) Por lo tanto, el campo *num_matr* es una **clave ajena** en la tabla ALUMNOS. Lo hemos marcado con una línea punteada para indicar que es un *\"campo intruso\"* en esa tabla. Observa que el atributo de la relación viaja hasta ALUMNOS junto con la clave ajena. **Ejemplo 2**: en este caso, una de las participaciones es (0,1), así que movemos la clave primaria de VEHICULOS (el lado con participación mínima 0) a EMPLEADOS (el lado con participación mínima 1): ![Paso a tablas - Relaciones 1:1 - Caso 2](/docs/prog-y-3d/_site/assets/images/07-12-paso-a-tablas-relaciones-1-1-B.png) **Ejemplo 3**: aquí tenemos un caso en el que las dos participaciones son (0,1), así que se genera una tabla adicional para la relación. El atributo de la relación se queda en la tabla que acabamos de crear. Y la clave primaria de esa nueva tabla puede ser cualquiera de las claves primarias de las entidades relacionadas (hemos elegido *cod_catastro*). ![Paso a tablas - Relaciones 1:1 - Caso 3](/docs/prog-y-3d/_site/assets/images/07-12-paso-a-tablas-relaciones-1-1-C.png) #### Relaciones 1:N Las **relaciones 1:N** del modelo E-R se convierten en **claves ajenas** del modelo relacional. * La clave de la entidad que participa con cardinalidad 1 pasa como clave ajena a la entidad que participa con cardinalidad N. * Si la relación tiene atributos, nos los llevamos a la entidad donde hayamos migrado la clave. * ¡Cuidado! Hay una excepción a esta última regla: si la entidad que participa con cardinalidad 1 lo hace con (0,1) en lugar de (1,1), debe crearse una tabla para la relación si queremos suprimir los valores nulos. Esta nueva tabla tendrá como campos las claves de las otras dos tablas y, como clave, la de la entidad con cardinalidad N. **Ejemplo 1**: en este ejemplo aparece el caso más frecuente: una cardinalidad 1:N con una participación de (1,1) en uno de los lados y (0,N) o (1,N) en el otro lado. Simplemente, se lleva la clave del lado (1,1) a la tabla del otro lado como clave ajena: ![Paso a tablas - Relaciones 1:N - Caso 1](/docs/prog-y-3d/_site/assets/images/07-12-paso-a-tablas-relaciones-1-N-A.png) **Ejemplo 2**: aquí tenemos una participación (0,1) en el lado de cardinalidad 1. Es necesario crear una tabla para la relación y evitar así los valores nulos: ![Paso a tablas - Relaciones 1:N - Caso 2](/docs/prog-y-3d/_site/assets/images/07-12-paso-a-tablas-relaciones-1-N-B.png) #### Relaciones N:N Las **relaciones N:N** del modelo E-R son las más sencillas de pasar al modelo relacional: se convierten en **tablas** *siempre*. * Los campos de la nueva tabla serán las claves primarias de las dos entidades. * La clave primaria de la nueva tabla será el conjunto de claves ajenas. * Si hay atributos, se añaden a la nueva tabla como campos no clave. * Si alguna cardinalidad mínima es 0, la relación se resuelve exactamente igual. **Ejemplo**: ![Paso a tablas - Relaciones N:N](/docs/prog-y-3d/_site/assets/images/07-12-paso-a-tablas-relaciones-N-N.png) #### Relaciones de dependencia (entidades débiles) La **relaciones de dependencia** se resuelven según su cardinalidad, siguiendo las mismas reglas que el resto de relaciones. * Las dependencias en identificación suelen tener cardinalidad 1:1 o 1:N, por lo que no suelen generar tabla. * Excepción: si la dependencia es en identificación, la clave de la entidad fuerte debe expandirse a la entidad débil y formar parte de su clave primaria. * Además, es aconsejable que dicha clave se coloque en primer lugar en la lista de campos de la entidad débil. #### Relaciones N-arias Si se trata de una **relación N-aria** (ternaria, cuaternaria, etc), se pasa a tablas según las cardinalidades de las entidades participantes, siguiendo las reglas vistas anteriormente. * Normalmente generan una nueva tabla. Ante la duda y si no lo vemos claro, lo mejor es crear una tabla para la relación. Así nos aseguramos de no perder información. * Los campos de la nueva tabla serán las claves de las entidades que participan con cardinalidad N en la relación, más los atributos propios de la relación. * La clave de la nueva tabla será el conjunto de claves ajenas. * La clave de las entidades que participen con cardinalidad 1 no tienen por qué formar parte de la clave de la nueva tabla. Nuevamente, ante la duda y si no lo vemos claro, podemos incluirlas en la clave. La tabla será algo más ineficiente, pero nos aseguramos así de no tener problemas con la clave. **Ejemplo**: ![Paso a tablas - Relaciones n-arias](/docs/prog-y-3d/_site/assets/images/07-12-paso-a-tablas-relaciones-N-arias.png) #### Relaciones reflexivas La **relaciones reflexivas** se resuelven según su cardinalidad, siguiendo las mismas reglas que el resto de relaciones. Lo único que ocurre es que pueden ser más difíciles de comprender para nosotros, puesto que en los dos extremos de la relación encontramos la misma entidad. El truco está en asignar un papel diferente a la entidad en cada extremo de la relación, como si realmente fueran entidades distintas. **Por ejemplo**: cuando leamos la siguiente relación reflexiva, debemos pensar que el empleado de un extremo es el *jefe* y el del otro extremo es el *subordinado*. * Así, leyéndola en el sentido subordinado -> jefe, obtendremos algo como: \"un empleado (subordinado) *está a las órdendes de* uno o ningún empleado (jefe)\". * Y leyéndola en el otro sentido será algo como: \"un empleado (jefe) *tiene a sus órdenes* cero, uno o varios empleados (subordinados)\". Si tenemos esto claro, las tablas resultantes son fáciles de comprender. En este caso, vamos a tener que generar una tabla para la relación porque la cardinalidad es 1:N y la participación mínima en el lado 1 es (0,1). Por lo tanto, estamos aplicando a la relación reflexiva las mismas reglas de paso a tablas que a cualquier otra relación binaria. ![Paso a tablas - Relaciones reflexivas](/docs/prog-y-3d/_site/assets/images/07-12-paso-a-tablas-relaciones-reflexivas.png) #### Relaciones jerárquicas Las **relaciones jerárquicas** tienen sus propias reglas, aunque en ciertos casos peculiares podrían no ser adecuadas. Como normas aproximadas podemos dar estas reglas: * **Para cada superentidad**: Crear una tabla (a no ser que tenga pocos -o ningún- atributos). * **Para cada subentidad**: Crear una tabla para cada subentidad *que tenga atributos*. Si no tiene clave propia, la hereda de la superentidad. Si la subentidad no tiene atributos, no se crea tabla. * **Para la relación**: Depende de si es exclusiva o inclusiva: * Si la relación es **exclusiva**, el atributo \"tipo\" de la relación se añade a la tabla de la superentidad, excepto si todas las subentidades han generado tabla. * Si la relación es **inclusiva**, se pueden tomar dos caminos: * Opción 1: Crear una tabla para la superentidad y otra para cada subentidad, tengan o no atributos. No añadir el atributo \"tipo\" a la superentidad. * Opción 2: Crear una tabla para la relación que contenga como clave la clave de la superentidad y su propio atributo \"tipo\". Crear tablas sólo para las subentidades que tengan atributos. **Ejemplo de relación exclusiva**: ![Paso a tablas - Relaciones jerárquicas exclusivas](/docs/prog-y-3d/_site/assets/images/07-12-paso-a-tablas-relaciones-jerarquicas-exclusivas.png) **Ejemplo de relación inclusiva**: ![Paso a tablas - Relaciones jerárquicas inclusivas](/docs/prog-y-3d/_site/assets/images/07-12-paso-a-tablas-relaciones-jerarquicas-inclusivas.png) ### 7.3.5. Y después del paso a tablas, ¿qué? Una vez creada la lista de tablas, es necesario **revisarlas y detallarlas** antes de continuar. Para cada campo, especificaremos su **dominio genérico**. Es decir, su tipo de datos (entero, real, cadena, lógico, fecha, etc). En una pasada posterior, podemos detallar aún más el dominio (por ejemplo, para los enteros indicaremos el número de bits, para las cadenas, el número máximo de caracteres, etc) Después, para cada campo, se pueden añadir las restricciones semánticas, como: * NULL o NOT NULL, según admita o no valores nulos. * NOT UNIQUE o UNIQUE, según pueda repetirse o no su valor en diferentes registros de la tabla. * Generalmente, se considera que NULL y NOT UNIQUE son los valores por defecto, de manera que sólo hay que expresar las restricciones semánticas en caso de que sean NOT NULL y/o UNIQUE (por ejemplo, este es el caso de todas las claves primarias) Como resultado final de todo este proceso, debemos obtener una lista de tablas con todos sus campos detallados: claves primarias, claves ajenas, dominios y restricciones semánticas. Por ejemplo, este podría ser el aspecto de una tabla de facturas: ``` FACTURAS(numFactura#, fechaFactura, importe, observaciones, idCliente) - numFactura: entero(32 bits) UNIQUE NOT NULL - fechaFactura: fecha NOT NULL - importe: real NOT NULL - Observaciones: cadena(200) - idCliente: entero(16 bits) NOT NULL ``` ### 7.3.6. Normalización La **normalización** es un proceso de revisión de las tablas relacionales que sirve para **prevenir ciertos problemas habituales** en las bases de datos mal diseñadas. Esos problemas suelen tener que ver con la **redundancia en los datos** y las anomalías en modificaciones, inserciones y borrados. Ten en cuenta que la redundancia es la mayor enemiga de las bases de datos: puede producir incoherencias, y las incoherencias hacen que la base de datos deje de ser útil. ***La normalización consiste en un conjunto de técnicas que transforman un conjunto de tablas en otro equivalente donde las redundancias de información están minimizadas.*** Para lograrlo, el nuevo conjunto de tablas debe cumplir determinadas restricciones conocidas como **formas normales**. En las siguientes líneas, vamos a conocer las principales formas normales y cómo lograr que nuestra base de datos las cumpla. Pero antes tengo que presentarte a unas amigas muy importantes en esta historia: las *dependencias*. #### Dependencias Los datos de la base de datos tienen, por su propia naturaleza, una serie de **dependencias entre sí**. **Por ejemplo**: en una tabla CLIENTES, el campo *nombre_cliente* depende del campo *dni_cliente*, porque cada DNI tiene asociado un (y sólo un) nombre. Esto no ocurre al revés, puesto que puede haber varias personas con el mismo nombre. Es decir: si conocemos el DNI de un cliente, podemos averiguar su nombre sin ninguna duda. Pero si conocemos su nombre, no podemos saber con certeza cuál es su DNI. Se dice entonces que *el campo \"nombre_cliente\" depende funcionalmente del campo \"dni_cliente\"*, y se simboliza así: dni_cliente -> nombre_cliente . Si, en lugar de esos campos en concreto, hablamos de dos campos cualesquiera, llamados X e Y, se dice que ***Y depende funcionalmente de X si y sólo si cada valor de X tiene asociado en todo momento un único valor de Y***. Y se simboliza así: X -> Y . **Otro ejemplo** de dependencia funcional: una tabla FALTAS_ASISTENCIA de la base de datos de un instituto tiene esta dependencia funcional: (id_alumno, fecha, hora) -> tipo_falta . Esto significa que cada valor del trío *(id_alumno, fecha, hora)* tiene asociado un único valor de *tipo_falta*. En cambio, NO existe esta otra dependencia: id_alumno -> tipo_falta . Es decir, cada valor de *id_alumno* no tiene asociado un único valor de *tipo_falta*, sino varios, porque un alumno puede tener muchas faltas de diverso tipo a lo largo de su vida académica. #### Las formas normales Una **forma normal** es un conjunto de restricciones que deben cumplir los campos de una tabla respecto de las dependencias funcionales que tienen entre ellos. Si todos los campos cumplen las restricciones de una forma normal determinada, se dice que la tabla está en esa forma normal. Y existen varias formas normales, cada vez más restrictivas: * **1FN**: primera forma normal. * **2FN**: segunda forma normal. * **3FN**: tercera forma normal. * **FNBC**: forma normal de Boyce-Codd. * **4FN**: cuarta forma normal. * **5FN**: quinta forma normal. El objetivo de cualquier base de datos bien diseñada es **alcanzar al menos la FNBC**, es decir, transformar nuestras tablas hasta que estén en FNBC. #### Concepto intuitivo de forma normal (mediante un ejemplo) Antes de enfangarnos en la normalización de tablas a un nivel más formal, vamos a entender lo que significan las formas normales (y la normalización) de manera intuitiva mediante un ejemplo La 1FN, por ejemplo, establece (como vamos a ver enseguida) la siguiente restricción: \"no puede haber grupos de datos compuestos en un campo\". He aquí un ejemplo de una tabla de ALUMNOS que **no está en 1FN**: id_alumno|nombre|asignaturas -|-|- 1028|Susana Martínez López|Matemáticas, Lengua 1029|Raquel Molinero Sánchez|Matemáticas, Física, Química 1030|Antonio Suárez Bermúdez|Latín, Griego 1031|Juan Miguel Rubio Castro|Economía, Latín, Matemáticas etc|etc|etc Esta tabla **no está en 1FN porque el campo *asignaturas* contiene valores múltiples**: no es atómico. ¿Cómo se puede modificar para que esté en 1FN? Tenemos dos posibilidades. **POSIBILIDAD 1**. Esta solución resuelve el problema de la 1NF, pero introduce **redundancia** en la tabla (en este caso, los nombres de los alumnos/as repetidos varias veces), que es uno de los mayores pecados que puede cometer un diseñador de bases de datos. id_alumno|nombre|asignaturas -|-|- 1028|Susana Martínez López|Matemáticas 1028|Susana Martínez López|Lengua 1029|Raquel Molinero Sánchez|Matemáticas 1029|Raquel Molinero Sánchez|Física 1029|Raquel Molinero Sánchez|Química 1030|Antonio Suárez Bermúdez|Latín 1030|Antonio Suárez Bermúdez|Griego 1031|Juan Miguel Rubio Castro|Economía 1031|Juan Miguel Rubio Castro|Latín 1031|Juan Miguel Rubio Castro|Matemáticas etc|etc|etc **POSIBILIDAD 2**: Esta solución también consigue alcanzar la 1FN sin perder información. Pero tampoco es gratis: ha aumentado el número de tablas y, por tanto, la complejidad de nuestra base de datos. TABLA DE ALUMNOS id_alumno|nombre -|- 1028|Susana Martínez López 1029|Raquel Molinero Sánchez 1030|Antonio Suárez Bermúdez 1031|Juan Miguel Rubio Castro etc|etc TABLA DE MATRÍCULAS id_alumno|asignatura -|- 1028|Matemáticas 1028|Lengua 1029|Matemáticas 1029|Física 1029|Química 1030|Latín 1030|Griego 1031|Economía 1031|Latín 1031|Matemáticas etc|etc **CONCLUSIÓN**: ninguna solución es perfecta. Así que la pregunta que hay que hacerse siempre es: **¿Cuál de las soluciones es mejor?** Afortunadamente, esa pregunta siempre tiene una respuesta clara: * Será preferible la solución que esté en FNBC (forma normal de Boyce-Codd, que enseguida veremos). * Si no hay ninguna en FNBC, elegiremos, por orden de preferencia, la que esté en 3FN, 2FN o 1FN y que reduzca al máximo la redundancia de información. Por lo tanto, tenemos que conocer en qué consiste cada una de las formas normales para poder transformar nuestras tablas y dejarlas en un estado óptimo. ¡Vamos a ello! #### Primera forma normal (1NF) **Una tabla está en 1NF si y sólo si todos sus campos son atómicos**. Es decir, si no se pueden descomponer en datos (que tengan sentido) más pequeños. El primer paso en la normalización de una tabla debe ser, por tanto, eliminar los campos que contengan grupos de datos. Por ejemplo, observa esta tabla: ``` EMPLEADOS (id_empleado#, nombre, apellido1, apellido2, idioma) ``` Si un empleado habla varios idiomas, en el campo *idioma* habrá que guardar múltiples valores. En consecuenca, **esta tabla no está en 1NF.** La mejor solución es dividir la tabla en dos: ``` EMPLEADOS (id_empleado#, nombre, apellido1, apellido2) IDIOMAS (idioma#, id_empleado#) ``` #### Segunda forma normal (2NF) Para esta forma normal, debemos comprender el concepto de **dependencia funcional completa** (o plena), que se define así: > *Dado un grupo de campos (X1, X2), se dice que otro campo Y tiene dependencia funcional completa respecto de (X1, X2) si depende funcionalmente de (X1, X2) y no lo hace de ningún subconjunto de (X1, X2). Es decir, Y no debe depender funcionalmente ni de X1 ni de X2* Pues bien, una tabla está en 2NF si y sólo si: * Está en 1NF * **Todos los campos no clave tienen una dependencia funcional completa respecto de las claves candidatas.** Las dependencias no completas con la clave son una enorme fuente de errores en la implementación. Que no cunda el pánico. Lo entenderemos mejor con los ejemplos. **Ejemplo 1**: Consideremos esta tabla en la que se almacenan las ventas de piezas junto con los almacenes donde esas piezas se guardan. Una misma pieza puede existir en varios almacenes, por lo que el *id_almacén* debe formar parte de la clave primaria: ``` VENTAS (id_pieza#, id_almacén#, nombre_pieza, cantidad, dirección_almacén) ``` Esta tabla no está en 2NF porque *dirección_almacén* no tiene una dependencia funcional completa con la clave primaria, ya que también depende funcionalmente de *una parte* de la clave primaria: * (id_pieza, id_almacén) -> dirección_almacén * id_almacén -> dirección_almacén La mejor solución vuelve a ser dividir la tabla en dos: ``` VENTAS (id_pieza#, id_almacén#, nombre_pieza, cantidad) ALMACENES (id_almacén#, dirección_almacén) ``` **Ejemplo 2**: Observa a hora esta tabla y trata de decidir si está o no en 2NF antes de leer la solución (supongamos que un empleado pueda trabajar a la vez en varios proyectos, desempeñando una función diferente en cada uno): ``` PROYECTOS (id_proyecto#, id_empleado#, función_empleado) ``` ¿Lo tienes? Resulta que esta tabla SÍ está en 2NF porque: * (id_empleado, id_proyecto) -> función_empleado Si lo piensas un poco, NO EXISTE la dependencia id_empleado -> función_empleado, ni tampoco id_proyecto -> función_empleado, puesto que un empleado puede trabajar en varios proyectos y en cada proyecto puede haber muchos empleados. #### Tercera forma normal (3NF) Para la tercera forma normal, hay que comprender el concepto de **dependencia funcional transitiva**: > *Supongamos una tabla con tres campos, X, Y y Z, que tienen las siguientes dependencias funcionales:* > > *X -> Y* > > *Y -> Z* > > *Y -> X* > > *En tal caso, se dice que Z tiene una **dependencia funcional transitiva con X a través de Y**, y se representa así: X - - -> Z* Pues bien: **una tabla está en 3NF si y sólo si**: * Está en 2NF. * **Los campos no clave dependen de la clave *de forma no transitiva*.** Las dependencias transitivas con la clave pueden provocar muchos errores en la implementación. De nuevo, se entiende mejor con un ejemplo, pero tienes que pensar en ello detenidamente. **Ejemplo**: Supongamos esta tabla de vuelos de una compañía aérea: ``` VUELOS (num_vuelo#, fecha, origen, destino, id_compañía, nombre_compañía) ``` Esta tabla no está en 3NF porque nos encontramos estas dependencias: * num_vuelo -> id_compañía * id_compañía -> nombre_compañía * id_compañía -> num_vuelo * id_vuelo - - -> nombre_compañía (esta es la dependencia transitiva) La solución vuelve a ser dividir la tabla en dos: ``` VUELOS (num_vuelo#, fecha, origen, destino, id_compañía) COMPAÑÍAS (cód_compañía#, nombre_compañía) ``` Cada una de estas tablas ya no contiene dependencias transitivas y están en 3NF. #### Forma normal de Boyce-Codd (FNBC o BCNF) Para nuestra última forma normal, necesitamos introducir el concepto de **determinante**: > *Se llama determinante a cualquier conjunto de campos del cual otro campo depende funcionalmente de forma completa.* Pues bien: una tabla está en BCNF si y sólo si **todo determinante es una clave candidata**. **Ejemplo**: volvamos sobre nuestra tabla VENTAS, donde se almacenan las ventas de productos junto con el almacén donde esos productos se encuentran. ``` VENTAS (id_producto#, id_almacén#, nombre_producto, nombre_almacén, cantidad) ``` Supondremos, en este ejemplo, que los almacenes se pueden identificar unívocamente tanto por el id como por el nombre. En ese caso, en esta tabla hay una clave primaria *(id_producto, id_almacén)* y una clave candidata (id_producto, nombre_almacén). Pues bien, la tabla no está en BCFN porque existen cuatro determinantes: * (id_producto, id_almacén) -> cantidad * (id_producto, nombre_almacén) -> cantidad * id_almacén -> nombre_almacén * nombre_almacén -> id_almacén La solución es, como siempre, dividir la tabla en dos: ``` VENTAS (id_venta#, id_almacén#, cantidad) ALMACENES (id_almacén#, nombre_almacén#) ``` #### Diagramas de dependencias Los **diagramas de dependencias** son una herramienta útil para determinar las dependencias funcionales dentro de una tabla, que es el paso previo a cualquier intento de normalización. Consisten en una **representación gráfica de las dependencias** dentro de la tabla. Las dependencias se indican con flechas que salen de unos campos y apuntan a otros. Por ejemplo, vamos a hacer el diagrama de dependencias de la tabla de VENTAS que ya hemos usado varias veces con ligeras variaciones: ``` VENTAS (id_pieza#, id_almacén#, nombre_almacén, cantidad) ``` Supongamos que en esa tabla existen estas dependencias: * (id_pieza, id_almacén) -> cantidad * id_almacén -> nombre_almacén El diagrama de dependencias permite observar las dependencias con más facilidad (sobre todo si son muchas y complejas) y tiene un aspecto como este: ![Ejemplo de diagrama de dependencias](/docs/prog-y-3d/_site/assets/images/07-13-diagrama-de-dependencias.png) ## 7.4. Ejercicios propuestos En esta sección vamos a proponer varios casos prácticos sencillos pero, al mismo tiempo, realistas, ordenados por dificultad creciente. Primero encontrarás varios ejercicios en los que tendrás que diseñar un diagrama E-R y pasarlo a tablas. Más adelante hay otros ejercicios diseñados exclusivamente para practicar la normalización, ya que en esos diagramas E-R he introducido algunos errores con el fin de que te encuentres ciertos problemas habituales a la hora de normalizar bases de datos. *Es muy importante, como siempre, que intentes hacerlos antes de mirar las soluciones*, aunque no te salgan. El tiempo que hayas empleado en darle vueltas no es tiempo perdido, sino al contrario. Además, ten en cuenta que mi solución y la tuya no tienen por qué coincidir (siempre hay varias soluciones viables), aunque sí deberían asemejarse un poco. #### Ejercicio 1: Librería En este ejercicio, como en los cuatro siguientes, tienes que: 1. **Leer bien el enunciado** con los requisitos. Si necesitas hacer alguna suposición adicional, eres libre de hacerlo, siempre que sea razonable. 2. **Crear el diagrama E-R**. Para identificar las entidades, fíjate bien en los *sustantivos* que más se repitan en el enunciado. Probablemente serán entidades o atributos de entidades. Y olvídate de los verbos: probablemente serán procesos, es decir, funciones del programa que afectan poco o nada a la base de datos. 3. **Hacer el paso a tablas**. Se pretende desarrollar una aplicación informática para la gestión de una **librería** dedicada tan sólo a la venta de libros (no vende material de papelería) El programa debe permitir al dependiente de la librería **mantener los fondos bibliográficos** disponibles en el local, es decir: dar de alta nuevos libros, dar de baja libros y modificar libros existentes. La librería pertenece a un club de lectores, es decir, no todo el mundo puede comprar en la misma. Para comprar, es necesario ser un socio del club. Todos los socios tienen una cuenta de cliente creada en la librería. **Dibuja el diagrama E-R de este sistema y conviértelo en una lista de tablas relacionales.** #### Ejercicio 2: Cajero automático Se quiere construir el sistema informático que controle los **cajeros automáticos** de una entidad bancaria. En principio, trabajaremos sobre una versión simplificada de los cajeros automáticos reales, ya que sólo se podrán realizar dos operaciones: **sacar dinero y consultar el saldo**. Para operar en el cajero, el usuario ha de introducir su tarjeta, en la que están grabados magnéticamente sus datos: nombre, apellidos, número de tarjeta, contraseña y número de cuenta. El cliente puede ser propio, si tiene una cuenta en la entidad bancaria, o ajeno, si su cuenta pertenece a otra entidad. Después de introducir la tarjeta, el cliente teclea su contraseña. Si ésta es incorrecta, el cajero da otra oportunidad para teclearla. Si el cliente vuelve a fallar, la tarjeta se retiene y se anotan los datos de la operación fallida: identificador del cajero, número de operación, tipo de operación (R = retirar dinero, S = pedir saldo y O = otros), fecha, hora, número de tarjeta y mensaje emitido al cliente. Además, se genera un resguardo impreso con todos estos datos. Si el cliente teclea correctamente su contraseña, tiene acceso al menú de operaciones, que por ahora sólo tendrá dos opciones: sacar dinero y consultar saldo. **Dibuja el diagrama E-R de este sistema y conviértelo en una lista de tablas relacionales.** #### Ejercicio 3: Piscina Se quiere desarrollar un programa para informatizar la gestión de una **piscina y sus instalaciones deportivas**. Los servicios que hay que gestionar son: instalaciones deportivas (piscina, pistas de tenis, de baloncesto, etc.), vestuarios y duchas, servicio de comedor y el baño en la piscina propiamente dicho. Para cada servicio es necesario comprar la **entrada** correspondiente. Cada entrada indica a qué servicio da derecho, la fecha (y, en su caso, el horario) de disfrute y el precio de la misma. Cada servicio tiene un **aforo máximo** que no puede superarse. No se venderán entradas para un servicio cuando eso suponga superar el aforo. Existen diferentes tipos de usuarios: 1. **Estudiantes** (deben presentar el carnet de estudiante), que pueden usar gratuitamente las piscinas, los vestuarios, las duchas y las pistas deportivas. Tienen un 50% de descuento en el comedor. El carnet de estudiante recoge los siguientes datos: nombre, apellidos, dni, domicilio, teléfonos, nº de matrícula, titulación y curso, junto con una foto reciente. 2. **Empleados** (deben presentar su tarjeta identificativa), que pueden usar gratuitamente todos los servicios. La tarjeta contiene estos datos: nombre, apellidos, dni, domicilio, teléfono, nº de la seguridad social, categoría y antigüedad en la empresa (fecha de ingreso) 3. **Los familiares de los empleados**, que podrán beneficiarse de un 40% de descuento en el comedor y un 60% en las instalaciones deportivas, los vestuarios y las duchas. Deben presentar una tarjeta familiar, donde figuran sus datos personales y los del empleado con el que tienen parentesco, así como el grado de ese parentesco. **Dibuja el diagrama E-R de este sistema y conviértelo en una lista de tablas relacionales.** #### Ejercicio 4: Agencia de viajes Una **agencia de viajes** de la ciudad desea renovar su sistema informático. El programa de gestión debe encargarse, básicamente, de recibir las peticiones de los clientes y **buscar plazas hoteleras y pasajes de avión** que satisfagan esas peticiones. Cuando un cliente llega a la agencia, realiza una petición de viaje. Esa petición puede consistir en un **billete de avión**, en una **reserva de hotel** o en **ambas cosas**. La petición de viaje incluye la fecha de comienzo del mismo, la fecha de fin, el número de personas que van a realizar el viaje y la ciudad de destino. Además, si se trata de una reserva de hotel, en la petición se ha de indicar la categoría (nº de estrellas) que se desea contratar, el número de habitaciones y su tipo (individual, doble, matrimonio, etc). Y si se trata de un billete de avión, hay que indicar la hora deseada de salida y regreso y el tipo de pasaje que se desea (turista, primera clase, VIP, etc) Con la petición del cliente, la agencia de viajes realiza una primera selección: para el caso de los billetes de avión, busca en su propia base de datos de compañías aéreas los vuelos que mejor se adaptan a las peticiones del cliente. Para las reservas hoteleras, hace lo mismo con su base de datos de hoteles. De todas las opciones posibles, el programa debe escoger la que mejor relación calidad-precio presente. Esta elección se ofrecerá al cliente en forma de **presupuesto**. El presupuesto contiene estos datos: número de presupuesto, nombre del agente que atiende al cliente, fecha, hora, importes parciales desglosados e importe total, además de todos los datos concretos de viaje (hoteles, vuelos, etc.) **Dibuja el diagrama E-R de este sistema y conviértelo en una lista de tablas relacionales.** #### Ejercicio 5: Fuga del castillo *Atención: este ejercicio es de dificultad elevada*. Se pretende desarrollar un **videojuego** de tipo **aventura gráfica**. El jugador manejará a un personaje atrapado en un castillo medieval del que tiene que encontrar la salida. El castillo está compuesto por muchas **estancias** comunicadas entre sí mediante **puertas**. El jugador puede moverse libremente a través de esas puertas para pasar de una estancia a otra, excepto cuando una puerta está cerrada. En ese caso, tiene que encontrar antes la **llave** que abre esa puerta, que estará escondida en alguna otra habitación del castillo. La distribución de habitaciones, puertas y llaves ocultas es fija, es decir, es la misma en todas las partidas. Cada habitación, además, tiene unas dimesiones, aspecto y decoración propias que tampoco cambian de una partida a otra. En una de las habitaciones se esconde la llave que abre la puerta principal del castillo. El jugador debe encontrarla para poder escapar. Además de todo esto, el castillo está poblado por **fantasmas, muertos vivientes y cucarachas gigantes**. Todos se mueven libremente por las habitaciones del castillo siempre que las puertas estén abiertas, excepto los fantasmas, que por su naturaleza incorpórea pueden atravesar las puertas, aunque estén cerradas. Si el protagonista tropieza con uno de los monstruos, tiene que pelear con él para vencerle, o bien huir en otra dirección. Para pelear con los monstruos dispone de tres **armas** diferentes: un lanzallamas con el que pegar fuego a los fantasmas, un hacha con la que corta la cabeza de los muertos vivientes, y un insecticida especial que acaba con las cucarachas. Sin embargo, al comenzar la partida, el jugador no dispone de ninguna de las tres armas, sino que las irá encontrando por el camino. Además, el lanzallamas y el insecticida se van agotando conforme son usados, por lo que el jugador debe rellenarlos con recargas que irá encontrando también por las habitaciones. El protagonista tiene tres **vidas**. Cuando muere en el encuentro con uno de los monstruos, pierde una vida. Si gasta las tres, se termina la partida y el jugador pierde. En cualquier momento del juego, el jugador puede decidir grabar el estado actual de la partida para seguir jugando más tarde. También puede decidir cargar una partida antigua para seguir jugándola, o terminar el juego en ese momento. El juego termina con éxito si el jugador consigue salir del castillo. Existirá un registro con los diez mejores jugadores, donde aparecerán sus nombres junto con el tiempo que han tardado en escapar. Al terminar la partida con éxito, hay que decidir si el jugador debe figurar entre los diez mejores o no (dependiendo del tiempo que haya empleado). **Dibuja el diagrama E-R de este sistema y conviértelo en una lista de tablas relacionales.** #### Ejercicio 6: Carreras de caballos Dada la siguiente tabla: ``` CARRERAS(id_jinete#, id_caballo#, nombre_jinete, nombre_caballo, fecha_carrera, id_hipódromo, nombre_hipódromo, posición_final) ``` ... donde se supone que un jinete puede montar a varios caballos, pero cada caballo es montado siempre por el mismo jinete, se pide: 1. Explicar por qué la tabla NO está en BCNF y pasarla a BCNF. 2. Tomando de nuevo la tabla CARRERAS original, explicar por qué NO está en 2NF y pasarla a 2NF. 3. Con las tablas resultantes del apartado b), comprobar si están en 3NF y, en caso de no estarlo, pasarlas a 3NF. *(Nota: para hacer este ejercicio es conveniente que antes dibujes el **diagrama de dependencias**)*. #### Ejercicio 7: Autobuses urbanos Dado el siguiente modelo de datos de un sistema para la gestión de los autobuses urbanos de una ciudad, se pide **hacer el paso a tablas** relacionales y **normalizar las tablas hasta BCNF**. ![Diagrama ER del ejercicio 7](/docs/prog-y-3d/_site/assets/images/07-14-ejercicio-7-diagrama-er.png) #### Ejercicio 8: Red de bibliotecas públicas Supón que la red de bibliotecas públicas de tu localidad tuviera una base de datos cuyo análisis correspondiera al diagrama E-R que hay más abajo. **Pásalo a tablas y normalízalo hasta BCNF**. ![Diagrama ER del ejercicio 8](/docs/prog-y-3d/_site/assets/images/07-14-ejercicio-8-diagrama-er.png) ## 7.5. Ejercicios resueltos Aquí iremos poniendo la solución a los ejercicios conforme los vayamos viendo en clase. ",
    "url": "/docs/prog-y-3d/_site/bases-de-datos/",
    "relUrl": "/bases-de-datos/"
  },"11": {
    "doc": "8. El lenguaje SQL",
    "title": "8. El lenguaje SQL",
    "content": "# 8. El lenguaje SQL {: .no_toc } - TOC {:toc} Ya sabemos cómo crear bases de datos para nuestros programas a partir del mundo real: diseñamos un diagrama entidad-relación, lo refinamos, lo pasamos a tablas relacionales y, por último, revisamos esas tablas hasta que queden normalizadas. Sí, lo sé: es un proceso largo y aburrido, pero la base de datos es el cimiento de muchas aplicaciones. Por ejemplo, la inmensa mayoría de las aplicaciones web están basadas en una base de datos. Equivócate en el diseño de esa base de datos, y el resto de la aplicación jamás funcionará bien, por mucho empeño que pongas en el proceso de implementación. Así que vale la pena dedicar un tiempo al diseño de la base de datos. ¿Y luego qué? Bien, luego tienes que **acceder a esa base de datos para operar con ella**: insertar datos, modificarlos, borrarlos y, lo más habitual de todo, buscar información y recuperarla para que tu programa (aplicación web o lo que sea) la use. Para hacer todo eso existe un lenguaje estandarizado que soportan la mayoría de las bases de datos relaciones. Puede que tu nombre te suene: se llama **SQL**, y vamos a dedicar todo este capítulo a aprenderlo ## 8.1. Introducción a SQL ### 8.1.1. Breve historia de SQL **SQL (Structured Query Language)** es un lenguaje bastante antiguo en términos informáticos, porque su origen se remonta a 1970: * 1970: Edgar Frank Codd propone el modelo relacional y un **lenguaje de acceso al mismo** basado en el **álgebra relacional**. * 1977: IBM crea el lenguaje **SEQUEL**, basado en la teoría de Codd, para un SGBD experimental. * 1979: Oracle utiliza un derivado de SEQUEL por primera vez en un producto comercial. Se cambió su nombre a SQL (Structured Query Language) porque SEQUEL ya estaba registrado como marca comercial. * 1980: IBM lanza varios gestores de bases de datos, entre ellos el exitoso **DB2**, basados en SQL. * Década de 1980: SQL tiene un éxito espectacular y cada fabricante de bases de datos utiliza su propio dialecto. Se hace patente la necesidad de una estandarización. * 1986: Nace **SQL-86**, el primer estándar del lenguaje. Fue publicado por ANSI. ISO lo confirmó en 1987, por lo que a veces se denomina SQL-87. A partir de entonces, SQL se ha convertido en el lenguaje universal para acceso a bases de datos relacionales y su estándar ha sido revisado continuamente, dando lugar a diferentes versiones: SQL-89, SQL-92, SQL-99, SQL-2003, etc. La revisión más reciente, en el momento de escribir estas líneas, es SQL-2016. ### 8.1.2. Dialectos de SQL A pesar de que SQL se estandarizó hace mucho tiempo, los SGBD comerciales respetan solo aproximadamente ese estándar. Es decir, todos incluyen mejoras y añadidos sobre SQL para tratar de superar a los competidores. Estos añadidos son incompatibles entre diferentes SGBD. Por ese motivo, podemos hablar de ***dialectos* de SQL**. Si queremos que nuestra base de datos sea portable, hay intentar respetar al máximo el estándar SQL. ### 8.1.3. SQL, un lenguaje para todo Como vimos en el capítulo anterior, los SGBD relacionales tienen varios lenguajes incorporados: * **Lenguaje de definición de datos (DDL)**: nos permite crear la representación lógica de los datos y sus relaciones. * **Lenguaje de control de datos (DCL)**: sirve para gestionar los permisos de acceso. * **Lenguaje de control de transacciones (TCL)**: se utiliza para asegurar la integridad de los datos. * **Lenguaje de manipulación de datos (DML)**: nos permite insertar datos, borrarlos, modificarlos, etc. Una de las grandes bazas de SQL es que él solito se las apaña para hacer todas estas cosas. Otro aspecto increíble de SQL es que **no es un lenguaje imperativo**, es decir, no tienes que indicarle cómo hacer las cosas escribiendo algoritmos tradicionales. Más bien, a SQL le dices *el resultado que quieres obtener* y él se encarga de generar un algoritmo para obtenerlo de forma totalmente transparente. ## 8.2. Creando la estructura: lenguaje de definición de datos El **DDL o lenguaje de definición de datos** es un lenguaje pensado para crar la estructura lógica de la base de datos. Dicho en otras palabras, el DDL nos permite **crear las tablas, modificarlas y borrarlas**. SQL, como hemos dicho, incluye instrucciones para implemental el DDL. En concreto, las instrucciones más importantes del DDL de SQL son estas tres: * **CREATE TABLE**: para crear tablas. * **ALTER TABLE**: para modificar una tabla existente. * **DROP TABLE**: para eliminar tablas. Escribiremos, a partir de ahora, las palabras reservadas de SQL en MAYÚSCULA por convenio y para distinguirlas del resto. Realmente, SQL no distingue mayúsculas de minúsculas, así que puedes escribirlas como prefieras. ### 8.2.1. Creación de tablas: CREATE TABLE La instrucción **CREATE TABLE** sirve para **crear tablas** en la base de datos. Tiene muchísimas posibilidades. No es mi intención mostrártelas todas, porque para eso necesitarías un curso de SQL avanzado. Pero, a través de algunos ejemplos, aprenderás a usarla a un nivel básico enseguida. La **sintaxis básica** (que admite montones de añadidos, pero que raramente usarás, al menos al principio) es esta: ```sql CREATE TABLE nombre_de_tabla ( columna1 tipo, columna2 tipo, columna3 tipo, etc. ); ``` Por ejemplo, así se **crea una tabla** de *clientes*: ```sql CREATE TABLE clientes ( id INTEGER, nombre VARCHAR(100), apellido1 VARCHAR(100), apellido2 VARCHAR(100), fecha_nacimiento DATE, estatura DECIMAL(1,2), email VARCHAR(200) ); ``` SQL maneja multitud de **tipos de datos**, pero por ahora basta con que conozcas estos: * **INTEGER** = números enteros. Hay varios subtipos, como BIGINT (entero enorme), SMALLINT (entero pequeño), etc. Se diferencian entre sí por el número más grande que son capaces de almacenar. La mayoría de las veces, INTEGER es más que suficiente. * **VARCHAR** = cadenas de caracteres (se indica la longitud máxima entre paréntesis). * **CHAR** = cadenas de caracteres. Se diferencia de VARCHAR en que, si no se usan todos los caracteres, se rellenan con espacios. Con los VARCHAR no sucede eso: los caracteres que no se usan, simplemente, no existen. Ante la duda, usa siempre VARCHAR en lugar de CHAR. * **DECIMAL** = números reales (se indica entre paréntesis la cantidad de cifras antes y después de la coma decimal) * **DATE** = fechas. * **TIME** = horas. * **DATETIME** = fecha y hora. * **BLOB** = información binaria así, en general. Los campos BLOB pueden usarse para guardar imágenes, archivos ejecutables, secuencias de vídeo o de audio... * **TEXT** = información de texto de grandes dimensiones, que no nos quepa dentro de un VARCHAR o un CHAR. Ahora vamos a utilizar **algunos modificadores** en la tabla *clientes*: ```sql CREATE TABLE clientes ( id INTEGER NOT NULL UNIQUE AUTO_INCREMENT, nombre VARCHAR(100) NOT NULL, apellido1 VARCHAR(100) NOT NULL, apellido2 VARCHAR(100) NOT NULL, fecha_nacimiento DATE, estatura DECIMAL(1,2), email VARCHAR(200), PRIMARY KEY (id) ) DEFAULT CHARACTER SET utf-8 COLLATE utf8-spanish-ci; ``` Fíjate en que hemos añadido algunas cosas a algunas columnas: * **NOT NULL** significa que ese campo no puede quedarse en blanco, es decir, que todos los clientes deben tener obligatoriamente un valor asignado en ese campo. * **UNIQUE** significa que el valor de ese campo no puede repetirse, esto es, que debe ser diferente en todos los clientes de la tabla. * **AUTO_INCREMENT** hace que la base de datos, cada vez que se inserta un registro, asigne a este campo el número entero inmediatamente superior al que se asignó al último registro insertado. Solo funciona con campos de tipo INTEGER. Suele utilizarse en el campo ID de las tablas para no tener que ocuparnos de insertar nosotros un número manualmente. * **PRIMARY KEY** especifica cual es la clave primaria de la tabla. Pueden ponerse varios campos, separados por comas. Lo lógico es que la clave sea NOT NULL y UNIQUE al mismo tiempo. También hemos añadido algunos modificadores que afectan a toda la tabla, no solo a algunos campos: * **CHARACTER SET** indica la condificación de caracteres que va a usarse en la tabla. * **COLLATE** indica cómo van a ordenarse los caracteres en la tabla. Por ejemplo, usando utf8-spanish-ci nos aseguramos de que la Ñ va entre la N y la P. Si usásemos otras colaciones, la Ñ se ordenaría después de la Z. Los modificadores que se pueden emplear con un CREATE TABLE son muy numerosos, pero la mayoría se usan con muy poca frecuencia. Los principales son los que hemos visto en este ejemplo. Otro modificadorde uso frecuente es el que se emplea para la creación de **claves ajenas**. Obsérvalo en este otro ejemplo: ```sql CREATE TABLE clientes ( id INTEGER NOT NULL UNIQUE, nombre VARCHAR(100) NOT NULL, apellido1 VARCHAR(100) NOT NULL, apellido2 VARCHAR(100) NOT NULL, fecha_nacimiento DATE, estatura DECIMAL(1,2), email VARCHAR(200), id_ciudad INTEGER NOT NULL, PRIMARY KEY (id), FOREIGN KEY (id_ciudad) REFERENCES ciudades(id) ) DEFAULT CHARACTER SET utf-8 COLLATE utf8-spanish-ci; ``` Hemos añadido el campo *id_ciudad* que, obviamente, es una clave ajena que pertenece a la tabla *ciudades*. Pues bien, para informar a la base de datos que ese campo, en efecto, es una clave ajena, hay que usar FOREIGN KEY, indicándole la tabla (*ciudades*) y el campo (*id*) al que está enlazada nuestra clave ajena. Por último, debes saber que tanto a restricción de clave primaria como a las restricciones de claves ajenas puede **asignárseles un nombre**. Esto es importante si luego queremos modificar esas claves sin necesidad de borrar toda la tabla (con la consiguiente pérdida de datos) para volver a crearla. Se hace así: ```sql CREATE TABLE clientes ( ... CONSTRAINT pk_clientes PRIMARY KEY (id), CONSTRAINT fk_clientes_ciudades FOREIGN KEY (id_ciudad) REFERENCES ciudades(id) ); ``` Como ves, basta con añadir **CONSTRAINT nombre** a la restricción de clave primaria o de clave ajena. Esto asigna un nombre a esa restricción para poder referirnos a él más adelante (ver ALTER TABLE). El nombre para las restricciones de clave primaria suele empezar por las letras *pk_* (de \"primary key\") y el de las restricciones de clave ajena por *fk_* (de \"foreign key\"), pero esto solo es una convención que no tienes por qué respetar. ### 8.2.2. Modificación de tablas: ALTER TABLE La **modificación de la estructura de una tabla** que ya existe se hace con la instrucción **ALTER TABLE**. Vamos a ver cómo trabaja esta instrucción con unos ejemplos basado en la tabla *clientes* del apartado anterior. De nuevo, ALTER TABLE tiene muchísimas opciones, pero las que te voy a mostrar en estos ejemplos cubren el 99% de los usos habituales. En primer lugar, si queremos **añadir un campo** (o varios) a una tabla ya existente, haremos esto: ```sql ALTER TABLE clientes ADD telefono VARCHAR(15) NOT NULL; ``` También podemos **eliminar un campo** (o columna) existente (cuidado: todos los datos de ese campo se perderán): ```sql ALTER TABLE clientes DROP COLUMN email; ``` Podemos, asimismo, **renombrar campos**: ```sql ALTER TABLE clientes RENAME COLUMN email TO correo_electronico; ``` O podemos **modificar campos**, cambiando su tipo o sus restricciones (¡Ojo! Esto puede afectar a los datos que haya almacenados en ese campo, si la tabla ya tiene datos, puesto que el SGBD intentará convertirlos de un tipo de dato a otro. Si no lo consigue, la instrucción fallará): ```sql ALTER TABLE MODIFY COLUMN telefono INTEGER; ``` Por último, con ALTER TABLE se pueden **crear o borrar las restricciones** de la tabla, tales como claves primarias o claves ajenas. ```sql ALTER TABLE ADD CONSTRAINT pk_clientes PRIMARY KEY(id); ``` Para borrar una restricción, tendremos que haberles asignado un nombre al crear la tabla. Así: ```sql ALTER TABLE DROP CONSTRAINT pk_clientes; ``` ### 8.2.3. Borrado de tablas: DROP TABLE El **borrado de tablas** se hace en sql con la instrucción **DROP TABLE**. Es muy fácil de usar, puesto que solo hay que indicar el nombre de la tabla que queremos borrar. ¡Mucho cuidado! Esta acción es destructiva y perderás todos los datos que hubiera almacenados en esa tabla. Por ejemplo, para borrar la tabla *clientes* de los ejemplos anteriores, escribiríamos esto: ```sql DROP TABLE clientes; ``` ### 8.2.4. Algunas consideraciones sobre la integridad referencial La **integridad referencial** es un mecanismo de seguridad de las bases de datos que asegura que la información entre las claves ajenas y las claves primarias a las que hacen referencia permanezca siempre bien sincronizada. Enseguida pondremos un ejemplo en el que lo entenderás muy bien. Ahora lo importante es que quede claro esto: perder esa sincronización entre clave ajena y clave primaria (es decir, romper la integridad referencial) es equivalente a perder datos. Y, si una base de datos va por ahí perdiendo datos, ¿para qué narices sirve? #### Entendiendo qué es la integridad referencial En el siguiente ejemplo se ve muy bien en qué consiste la **pérdida de integridad referencial** y los problemas de pérdida de datos que causa. Imaginemos dos tablas de una base de datos más grande (por ejemplo, de una biblioteca): la tabla ***libros*** contiene información sobre los libros (*cod_libro* y *título*, entre otros campos), mientras que la tabla ***autores*** contiene información sobre los autores de los libros (*cod_autor* y *nombre*, entre otros campos). La tabla *libros* tiene una clave ajena, *cod_autor*, que es un campo que en realidad pertenece a la tabla *autores* pero que expandimos hasta *libros* para implementar la relación 1:N entre ambas entidades. ¡Repasa el capítulo anterior, sobre diseño de bases de datos, si no sabes de lo que estamos hablando! (En realidad, la relación entre *libros* y *autores* es N:N, porque un libro puede ser escrito por muchos autores y cada autor puede escribir muchos libros, pero aquí la consideramos una 1:N para simplificar el ejemplo) Este es el aspecto que podrían tener esas dos tablas o, al menos, un fragmento de ellas: ![Ejemplo de integridad referencial](/docs/prog-y-3d/_site/assets/images/08-01-integridad-referencial.png) No hay que se un lince para darse cuenta de que todos los códigos de autor que aparecen en la tabla *libros* se corresponden con autores que **realmente existen** en la tabla *autores*. ¿Pero qué pasaría si, por cualquier razón, un código de autor inexistente acabase por error en la tabla de *libros*? Entonces tendríamos algo como esto: ![Ejemplo de integridad referencial rota](/docs/prog-y-3d/_site/assets/images/08-01-integridad-referencial-rota.png) Ahí lo tenemos: el libro 484 (\"Ana Karenina\") está asociado al autor 32, que *no existe en la tabla de autores*. ¿El resultado? **Hemos perdido información**. Ya no hay manera de saber quién escribió ese libro. Es lo mismo que si hubiésemos borrado un registro, o parte de un registro, de una tabla, aunque en realidad nadie ha borrado nada. Te puedes estar diciendo: \"Sí, claro, ¿pero quién va a ser tan idiota de escribir un código que no existe en el campo *cod_autor*?\" Hay cientos de razones por las que el código equivocado puede acabar asignado a una clave ajena: puede tratarse de un error de programación en la aplicación cliente, puede haber un fallo de comunicaciones, puede ocurrir un problema de concurrencia, puede que alguien elimine, a propósito o sin querer, un autor que ya tenía libros asignados. Y sí, también hay gente idiota en el mundo, esto es incuestionable. Y algunos podrían acabar usando nuestra base de datos. Como el problema de la integridad referencial es tan frecuente y potencialmente devastador, **las bases de datos se autoprotegen e impiden que la integridad referencial pueda violarse**. El efecto colateral de esta obsesión por la protección de los datos es que *no podrás insertar los datos en cualquier orden*. En el ejemplo anterior, tendrás que insertar primero al autor del libro en la tabla *autores* y luego al libro en la tabla *libros*, y no al revés, porque en tal caso estarías violando la integridad referencial. #### Borrado en cascada El **borrado en cascada** es una de las formas que tiene la base de datos de proteger la integridad referencial. Uno de los errores más frecuentes que provoca la violación de la integridad referencial es el borrado de un registro de una tabla que está referenciado en otra tabla como clave ajena. Para entenderlo mejor, vamos a volver sobre nuestro ejemplo de la tabla ***libros*** y la tabla ***autores***. Supongamos que vamos a borrar un autor (el que tiene código 4): ![Ejemplo de integridad referencial - Borrado](/docs/prog-y-3d/_site/assets/images/08-01-integridad-referencial-borrado-1.png) El resultado de borrar ese registro es que se rompe la integridad referencial, porque el libro 485 hará referencia a un autor que ya no existe: ![Ejemplo de integridad referencial - Borrado](/docs/prog-y-3d/_site/assets/images/08-01-integridad-referencial-borrado-2.png) La base de datos impedirá este borrado para no violar la integridad referencial. Pero se puede hacer algo más: **activar el borrado en cascada**. Cuando se activa el borrado en cascada para una clave ajena, la base de datos se encargará de eliminar los registros adecuados si se borra un registro de la tabla a la que hace referencia esa clave ajena. Así también se protege la integridad referencial. En el ejemplo anterior, al borrar el autor 4, también se borrarán en cascada (¡y automáticamente!) *todos los libros escritos por ese autor*: ![Ejemplo de integridad referencial - Borrado](/docs/prog-y-3d/_site/assets/images/08-01-integridad-referencial-borrado-3.png) El borrado en cascada se habilita durante la creación de la tabla con el modificador **ON DELETE CASCADE**. Por ejemplo, si queremos habilitarlo para la tabla *libros* anterior: ```sql CREATE TABLE libros ( cod_libro INTEGER NOT NULL UNIQUE, titulo VARCHAR(500), cod_autor INTEGER NOT NULL, FOREIGN KEY (cod_autor) REFERENCES autores(cod_autor) ON DELETE CASCADE ); ``` #### Modificación en cascada La **modificación de registros** también puede provocar **fallos de integridad referencial**. Por ejemplo: ¿qué ocurre si modificamos la clave de un registro de nuestra tabla de *autores*? ![Ejemplo de integridad referencial - Modificación](/docs/prog-y-3d/_site/assets/images/08-01-integridad-referencial-modificacion-1.png) Aquí lo tenemos otra vez: al cambiar el código del autor \"Benito Pérez Galdós\" de 4 a 5, el libro 485 vuelve a quedarse sin autor. ¡Hemos perdido información de nuevo! ![Ejemplo de integridad referencial - Modificación](/docs/prog-y-3d/_site/assets/images/08-01-integridad-referencial-modificacion-2.png) Como en el caso del borrado, la base de datos **nos prohibirá** hacer este tipo de cosas para **proteger la integridad referencial**. Y, como en el caso del borrado, también existe la posibilidad de habilitar la **actualización o modificación en cascada**, de manera que, si cambia el valor de una clave primaria, pueda modificarse el valor de la clave ajena automáticamente: ![Ejemplo de integridad referencial - Modificación](/docs/prog-y-3d/_site/assets/images/08-01-integridad-referencial-modificacion-3.png) Para habilitar la modificación en cascada, hay que especificarlo con **ON UPDATE CASCADE** durante la creación en la clave ajena: ```sql CREATE TABLE libros ( cod_libro INTEGER NOT NULL UNIQUE, titulo VARCHAR(500), cod_autor INTEGER NOT NULL, FOREIGN KEY (cod_autor) REFERENCES autores(cod_autor) ON DELETE CASCADE ON UPDATE CASCADE ); ``` Como ves en este código, la actualización y el borrado en cascada pueden usarse simultáneamente. También pueden habilitarse más tarde, cuando la tabla ya está en uso, mediante un **ALTER TABLE**. ## 8.3. Usando los datos: lenguaje de manipulación de datos Hasta aquí hemos visto cómo SQL nos permite crear la estructura de la base de datos, es decir, las tablas con sus campos, tipos, restricciones, etc. Pero aún no lo hemos usado para **almacenar y manipular datos**, que es el objetivo final de toda base de datos. De eso se encarga otra parte de SQL llamada **DML** (lenguaje de manipulación de datos). En realidad, la creación de la estructura se hace solo una vez, cuando la base de datos se construye. Cuando la base de datos ya está en uso, raramente se altera la estructura, puesto que sería como modificar la estructura de una casa cuando ya está habitada: hay que meterse de albañiles y eso siempre es un engorro. *Durante la inmensa mayoría del tiempo de explotación de una base de datos, el SQL que se utiliza es el que vamos a ver en esta sección.* SQL tiene varias instrucciones para manipular datos, pero nos vamos a centrar en las cuatro más importantes: * **INSERT**: sirve para insertar datos en una tabla. * **UPDATE**: modifica datos ya existentes. * **DELETE**: elimina datos de una tabla. * **SELECT**: consulta datos de una o varias tablas. Insisto en la idea: estas instrucciones actúan a nivel de datos, es decir, de *registros* o *filas* de las tablas. Insertan, modifican y borran registros. Para insertar, modificar y borrar *campos* está el lenguaje de definición de datos, es decir, CREATE TABLE, ALTER TABLE o DROP TABLE. ### 8.3.1. Inserción de datos: INSERT La instrucción **INSERT** se utiliza para **insertar registros en una tabla**. Como siempre, vamos a aprender a utilizarla mediante algunos ejemplos. Supongamos que tenemos una tabla llamada *personas* con los siguientes campos: ``` PERSONAS(id, nombre, apellido1, apellido2, estatura, fecha_nacimiento, pais_nacimiento) ``` Esta tabla se habrá creado mediante esta instrucción: ```sql CREATE TABLE personas ( id INTEGER NOT NULL UNIQUE AUTO_INCREMENT, nombre VARCHAR(100) NOT NULL, apellido1 VARCHAR(100) NOT NULL, apellido2 VARCHAR(100) NOT NULL, estatura INTEGER, fecha_nacimiento DATE, pais_nacimiento VARCHAR(100), PRIMARY KEY (id) ); ``` Pues bien: para **insertar una fila** en esta tabla, basta con escribir esta instrucción **INSERT**: ```sql INSERT INTO personas(nombre, apellido1, apellido2, estatura, fecha_nacimiento, pais_nacimiento) VALUES ('José', 'Pérez', 'Sánchez', '179', '13/12/1998', 'México'); ``` En este código puedes observar varias cosas curiosas: * No indicamos el valor del campo *id* porque lo hemos declarado como AUTO_INCREMENT y la base de datos se encargará de asignarle un valor automáticamente. * Primero indicamos una lista de campos y luego una lista de valores. Los valores se asignarán a los campos en el mismo orden en el que están escritos. * No hacemos distinción entre campos de texto, numéricos o fechas: todos los valores se escriben entre comillas. Da igual que sean comillas simples (') o dobles (\"): SQL admite las dos. De hecho, los números pueden escribirse sin comillas, pero, para evitar errores, mi recomendación es que escribas todos los valores, siempre, entre comillas. Es posible no asignar valores a todos los campos. Por ejemplo, *estatura*, *fecha_nacimiento* y *pais_nacimiento* no están declarados como NOT NULL, es decir, que se pueden dejar en blanco, así que este INSERT también funcionaría: ```sql INSERT INTO personas(nombre, apellido1, apellido2) VALUES ('Susana', 'García', 'Moreno'); ``` En cambio, si intentamos dejar en blanco el nombre o uno de los dos apellidos, el INSERT fallará. ### 8.3.2. Modificación de datos: UPDATE La **modificación o actualización de registros** se hace mediante la instrucción **UPDATE**. La podemos ver en acción en este ejemplo basado en la misma tabla *personas* del apartado anterior: ```sql UPDATE personas SET nombre = 'Luis' WHERE id = 18; ``` Lo que hace UPDATE es localizar un registro que coincida con la condición expresada en la cláusula WHERE, el decir, localiza el registro cuyo id valga 18, y modifica el valor del campo *nombre* de ese registro, asignándole el valor \"Luis\". Se pueden actualizar varios campos a la vez: ```sql UPDATE personas SET nombre = 'Luis', estatura = '180' WHERE id = 25; ``` Y también se puede usar otra condición que no sea sobre el campo *id*. Por ejemplo, esta instrucción UPDATE actualizará todos los nombres almacenados como \"Paco\" y los cambiará por \"Francisco\". ```sql UPDATE personas SET nombre = 'Francisco' WHERE nombre = 'Paco'; ``` Por lo tanto, un UPDATE puede afectar 0, 1 o muchas filas de la tabla. ¡Mucho cuidado con ejecutar un UPDATE sin cláusula WHERE! Esa actualización afectará a **todos los registros** de la tabla: ```sql UPDATE personas SET nombre = 'Francisco'; ``` ¡Acabamos de cambiar el nombre de todas las personas de nuestra base de datos! ### 8.3.3. Borrado de datos: DELETE Para **eliminar registros** utilizamos la instrucción **DELETE**. Aquí tienes un ejemplo sobre la tabla *personas*. Vamos a borrar la persona con id = 18: ```sql DELETE FROM personas WHERE id = 18; ``` Al igual que UPDATE, DELETE localizará el registro (o registros) que coincida con la condición expresada en la cláusula WHERE. Y, una vez localizado, lo borrará. Obviamente, DELETE es una **instrucción destructiva** y debe usarse con cautela. Se pueden borrar varios registros a la vez. Por ejemplo, así borraremos a todas las personas cuyo primer apellido sea \"Pérez\": ```sql DELETE FROM personas WHERE apellido1 = 'Pérez'; ``` Y así borramos **todos los registros** de una tabla y la dejamos completamente vacía. ¡Utilízalo solo cuando estés muy seguro/a de lo que estás haciendo! ```sql DELETE FROM personas; ``` ## 8.4. Consultas. Las instrucción SELECT Para **buscar datos** entre las tablas de una base de datos se usa la sentencia **SELECT**. Estas búsquedas suelen recibir el nombre de **consultas**. El resultado de una búsqueda de datos tiene forma de tabla y está constituido por el conjunto de datos que cumplen unos **criterios de búsqueda**, porque, para buscar datos con SQL, no hace falta indicarle a la base de datos cómo hacer la búsqueda, sino *qué datos tiene que buscar*. Y ella se encarga de todo. Sí, es increíble, pero funciona. La sentencia SELECT es, probablemente, la más compleja del lenguaje SQL. Sin embargo, no necesitas conocerla en profundidad para sacarle partido. La mayor parte del tiempo, SELECT se usa en alguna de sus formas más simples. Si más adelante te vuelves un experto/a en bases de datos, ya aprenderás los usos más complejos. Para comprender mejor los siguientes ejemplos, vamos a suponer que nuestra tabla *personas* contiene estos siete registros (que quede claro que, en un caso real, la tabla podría tener cientos o miles de registros): id|nombre|apellido1|apellido2|estatura|fecha_nacimiento|pais_nacimiento -|-|-|-|-|-|- 1|Antonia|López|Zapata|171|18/02/2002|España 2|Micaela|Cruz|Ortega|168|23/03/1993|México 3|Luis Fernando|Guzmán|Rojas|174|01/01/2001|Colombia 4|Juan|López|Gutiérrez|191|28/02/1997|Argentina 5|Esteban|López|López|166|07/09/2001|México 6|Ana Lucía|Smith|López|185|19/01/2000|Argentina 7|Fernando José|Delgado|Aguas|157|17/08/1969|México ### 8.4.1. Seleccionar columnas de una tabla La sintaxis más básica concebible de una sentencia SELECT funcional es esta: ```sql SELECT columna1, columna2, ..., columnaN FROM nombre_tabla; ``` Por ejemplo, esta instrucción nos devolverá todos los registros de la tabla *personas*, pero seleccionando solo las columnas *nombre*, *apellido1* y *apellido2* y desechando todas las demás: ```sql SELECT nombre, apellido1, apellido2 FROM personas; ``` El resultado de la consulta será: ``` Antonia López Zapata Micaela Cruz Ortega Luis Fernando Guzmán Rojas Juan López Gutiérrez Esteban López López Ana Lucía Smith López Fernando José Delgado Aguas ``` El símbolo * (asterisco) significa \"todas las columnas\". De modo que esto nos devolverá todo el contenido de la tabla *personas* sin excepción: ```sql SELECT * FROM personas; ``` El resultado de esta consulta será: ``` 1 Antonia López Zapata 171 18/02/2002 España 2 Micaela Cruz Ortega 168 23/03/1993 México 3 Luis Fernando Guzmán Rojas 174 01/01/2001 Colombia 4 Juan López Gutiérrez 191 28/02/1997 Argentina 5 Esteban López López 166 07/09/2001 México 6 Ana Lucía Smith López 185 19/01/2000 Argentina 7 Fernando José Delgado Aguas 157 17/08/1969 México ``` ### 8.4.2. Filtrar resultados: la cláusula WHERE Normalmente, no vamos a necesitar *todos* los registros de una tabla, sino que queremos localizar alguno o algunos en concreto. Para eso sirven las búsquedas, ¿no? Para encontrar unos pocos resultados entre un montón de datos. Pues bien, para **filtrar esos resultados** se utiliza la **cláusula WHERE**. Es sencilla de comprender. Simplemente, se indica una **condición** que afecte a alguno de los campos de la tabla, y la base de datos se encargará de encontrar para nosotros los registros que cumplan esa condición. Por ejemplo, esta consulta nos devuelve los nombres y apellidos de todas las personas cuya estatura es igual a 168 cm (recuerda que *estatura* es un campo de nuestra tabla *personas*): ```sql SELECT nombre, apellido1, apellido2 FROM personas WHERE estatura = '168'; ``` Como resultado, solo obtendremos un registro, porque solo una persona cumple esa condición: ``` Micaela Cruz Ortega ``` La condición puede utilizar los **operadores de comparación** habituales: * **Igual que**: = * **Mayor que**: > * **Mayor o igual**: >= * **Menor que**: '170'; ``` El resultado será: ``` Antonia López Zapata Luis Fernando Guzmán Rojas Juan López Gutiérrez Ana Lucía Smith López ``` Esta otra consulta localiza a todas las personas cuyo primer apellido es \"López\" y que miden más de 170 cm: ```sql SELECT nombre, apellido1, apellido2 FROM personas WHERE apellido1 = 'López' AND estatura > '170'; ``` Resultado: ``` Antonia López Zapata Juan López Gutiérrez ``` Y esta otra busca a todas las personas que tienen \"López\" como primer o segundo apellido y que han nacido antes del año 2002. Observa cómo se pueden usar paréntesis para agrupar condiciones: ```sql SELECT nombre, apellido1, apellido2 FROM personas WHERE (apellido1 = 'López' OR apellido2 = 'López') AND fecha_nacimiento = 3 ; ``` Resultado: ``` México 3 ``` ### 8.4.7. Obtener resultados de varias tablas: JOIN Hasta ahora, solo hemos visto ejemplos de consultas que obtienen datos de una sola tabla, pero es muy frecuente que queramos **extraer datos de varias tablas relacionadas entre sí**. SQL permite hacer eso con la cláusula **JOIN**. Para comprender cómo funciona JOIN, necesitamos añadir una o dos tablas a nuestra base de datos, así que los siguientes ejemplos se basarán en estas tres tablas: ``` PERSONAS(id, nombre, apellido1, apellido2, estatura, fecha_nacimiento, id_pais) PAISES(id, nombre, id_continente) CONTINENTES(id, nombre) ``` Como puedes imaginarte, el campo *id_pais* de la tabla *PERSONAS* es una clave ajena que está relacionada con el campo *id* de la tabla *PAISES*. Del mismo modo, *id_continente* en la tabla *PAISES* es una clave ajena enlazada con *id* en la tabla CONTINENTES. Para que quede más claro, te muestro un ejemplo de lo que podrían contener estas tablas: **TABLA PERSONAS** id|nombre|apellido1|apellido2|estatura|fecha_nacimiento|id_pais -|-|-|-|-|-|- 1|Antonia|López|Zapata|171|18/02/2002|3 2|Micaela|Cruz|Ortega|168|23/03/1993|1 3|Luis Fernando|Guzmán|Rojas|174|01/01/2001|2 4|Juan|López|Gutiérrez|191|28/02/1997|7 5|Esteban|López|López|166|07/09/2001|1 6|Ana Lucía|Smith|López|185|19/01/2000|7 7|Fernando José|Delgado|Aguas|157|17/08/1969|1 etc|etc|etc|etc|etc|etc|etc **TABLA PAISES** id|nombre|id_continente -|-|- 1|México|2 2|Colombia|2 3|España|4 4|Australia|5 5|China|3 6|Egipto|1 7|Argentina|2 etc|etc|etc **TABLA CONTINENTES** id|nombre -|- 1|África 2|América 3|Asia 4|Europa 5|Oceanía Ahora el nombre del país no está almacenado directamente en la tabla *personas*, sino en la tabla *paises*. Ambas tablas se relacionan gracias al campo *id_pais*. Lo mismo ocurre entre *paises* y *continentes*. Por lo tanto, si necesitamos recuperar, por ejemplo, **los nombres y apellidos de todas las personas junto con su país de nacimiento**, será necesario mezclar los datos de las tablas *personas* y *paises*. Esto se hace así: ```sql SELECT personas.nombre, apellido1, apellido2, paises.nombre FROM personas JOIN paises ON personas.id_pais = paises.id ``` El resultado será: ``` Antonia López Zapata España Micaela Cruz Ortega México Luis Fernando Guzmán Rojas Colombia Juan López Gutiérrez Argentina Esteban López López México Ana Lucía Smith López Argentina Fernando José Delgado Aguas México ``` Observa algunas cosas importantes en esta sentencia: * En la **clásula FROM** indicamos la tabla principal de nuestra consulta (*personas*). * En la **clásula JOIN** indicamos la segunda tabla de nuestra consulta (*paises*) y le indicamos a SQL cuál es el campo que relaciona *personas* con *paises* (```personas.id_pais = paises.id```). * En la lista de campos, tenemos dos campos llamados *nombre*, uno perteneciente a la tabla *personas* (el nombre de la persona) y otro perteneciente a la tabla *paises* (el nombre del país). Por eso es necesario distinguirlos poniendo delante el identificador de la tabla (*personas.nombre* y *paises.nombre*). Con *apellido1* y *apellido2* no hace falta, puesto que esos campos solo existen en la tabla *personas*. Y poco más hay que decir sobre los JOIN. Son así de sencillos. SQL se encargará de mostrar a cada persona con su país correspondiente, cruzando los datos de las dos tablas. Se puede hacer **JOIN de más de dos tablas**. En esos casos, basta con cruzar las tablas por parejas. Por ejemplo, para mostrar la lista de personas junto con su país y su continente de nacimiento, primero cruzaremos *personas* con *paises* y después *paises* con *continentes*. No se puede cruzar directamente *personas* con *continentes* porque no tienen ningún campo en común, es decir, no están directamente relacionadas entre sí. ```sql SELECT personas.nombre, apellido1, apellido2, paises.nombre, continentes.nombre FROM personas JOIN paises ON personas.id_pais = paises.id JOIN continentes ON paises.id_continente = continentes.id ``` El resultado de esta consulta será: ``` Antonia López Zapata España Europa Micaela Cruz Ortega México América Luis Fernando Guzmán Rojas Colombia América Juan López Gutiérrez Argentina América Esteban López López México América Ana Lucía Smith López Argentina América Fernando José Delgado Aguas México América ``` Por último, **las consultas con JOIN también pueden llevar cláusulas WHERE, ORDER BY, GROUP BY o HAVING**, como cualquier otra consulta. Por ejemplo, vamos a buscar los nombres, apellidos, país de nacimiento y continente de todas las personas nacidas a partir de 1 de enero del año 2000 y vamos a ordenar los resultados por apellidos: ```sql SELECT personas.nombre, apellido1, apellido2, paises.nombre, continentes.nombre FROM personas JOIN paises ON personas.id_pais = paises.id JOIN continentes ON paises.id_continente = continentes.id WHERE fecha_nacimiento >= '01/01/2000' ORDER BY apellido1, apellido2; ``` El resultado será: ``` Luis Fernando Guzmán Rojas Colombia América Esteban López López México América Antonia López Zapata España Europa Ana Lucía Smith López Argentina América ``` ### 8.4.8. SQL avanzado: introducción a las subconsultas Hay ciertas situaciones en las que nos encontramos con una consulta tan compleja que no se puede resolver con las herramientas que hemos visto hasta ahora. En esos casos, **utilizar una subconsulta en una cláusula WHERE o HAVING** suele obrar milagros. Sin embargo, no conviene abusar de este recurso: las consultas con subconsultas siempre consumen más recursos y son más lentas de ejecutar que las consultas convencionales. La subconsulta se inserta en cualquier cláusula WHERE o HAVING con alguno de estos operadores: * **ANY**, **ALL** o **SOME**. * **IN** o **NOT IN**. * **EXISTS** o **NOT EXISTS**. * **=, >, >=, '180'); ``` (por supuesto, esto mismo puede resolverse sin usar UNION) * La combinación de estas dos consultas con **UNION** nos devuelve la lista de personas que han nacido en Argentina **O** que miden más de 180 cm. Cualquier persona que cumpla una de las dos condiciones estará en el resultado final. * Si combinásemos las mismas consultas con **INSERSECT** en lugar de con UNION, lo que obtendríamos sería la lista de personas que nacieron en Argentina **Y** que miden más de 180 cm. Es decir, las personas que formen parte de los dos resultados y, por lo tanto, cumplan *a la vez* las dos condiciones. Fíjate en que en el enunciado solo hemos cambiado una \"O\" por una \"Y\", pero es que esa es precisamente la diferencia entre UNION e INTERSECT. * Por último, si combinamos las mismas consultas con **EXCEPT**, obtendremos la lista de personas que nacieron en Argentina, excepto las que miden más de 180 cm. Habremos eliminado del primer SELECT los resultados que estén en el segundo SELECT. Esto es, obtendremos la lista de personas nacidas en argentina que miden 180 cm o menos. Es un lío desde el punto de vista lógico, ¿verdad? Y es que no se te habrán escapado las semejanzas de UNION, INTERSECT y EXCEPT con los operadores lógicos Y, O y NO. En efecto, UNION, INSERSECT y EXCEPT son los equivalentes a Y, O y NO a nivel de consultas completas. Aplicaremos UNION, INSERSECT y EXCEPT a algunas de las consultas más complejas de nuestros ejercicios propuestos. ## 8.5. ¿Y cómo puedo probar todo esto? Seguro que te has hecho esta pregunta mientras leías los ejemplos de este capítulo y tal vez incluso intentabas resolverlos por tu cuenta. Es una excelente pregunta. Para ejecutar SQL **necesitas un gestor de bases de datos relacionales**. Puede instalar un gestor de escritorio, para bases de datos domésticas, como *Microsoft Access* o *Libreoffice Base*, o puedes decantarte por un gestor profesional en red, como *MySQL, MariaDB, Oracle, SQLite* o *SQL Server*. En realidad, da igual, porque el SQL es más o menos igual en todos. (Digo \"más o menos\" porque cada base de datos hace su propia interpretación del estándar SQL y puede haber pequeñas diferencias entre uno y otro). Si nunca has usado una base de datos profesional como MySQL, Oracle u SQL Server, probablemente **lo más sencillo es que empieces por Microsoft Access o Libreoffice Base**. Si, en cambio, ya conoces las bases de datos profesionales, no necesitas leer este apartado. Puedes pasar directamente a los ejercicios, aunque probablemente tampoco los necesites. 1. **Instala Microsoft Access (forma parte del paquete Microsoft Office) o Libreoffice Base (forma parte del paquete Libreoffice)** en tu ordenador. Microsoft ofrece una versión online de su Office. Recuerda que Microsoft Office es un paquete de software propietario y que copiar y usar programas de forma fraudulenta es un delito penal. Libreoffice, en cambio, es software libre y puedes usarlo y distribuirlo libremente. Eso sí: ¡Descárgalo solo de la web oficial, por favor! 2. **Arranca el programa** (claro). 3. **En Microsoft Access**, crea una base de datos (o abre una existente). Ahora puedes ejecutar tus sentencias SQL pulsando el botón \"Create\" de la parte superior de la pantalla, y luego seleccionando \"Query design\" -> \"Show table\" -> \"SQL view\". Escribe tu sentencia SQL y pulsa \"Run\" para probarla. 4. **En Libreoffice Base**, crea una base de datos (o abre una existente). Selecciona \"Tool - SQL\" y luego \"Create Query in SQL view\". En la pantalla siguiente, haz clic en \"View\" -> \"Switch Design View On/Off\". Escribe tu sentencia SQL y pulsa \"Run\" para probarla. En realidad, todo esto no tiene nada que ver con aprender SQL, sino con aprender a manejar un determinado programa. Elige el tuyo y bichea un poco hasta que averigües cómo se ejecuta el SQL. Se presupone de ti que eres un usuario/a de ordenadores de nivel medio-avanzado, y por eso quieres aprender a programar. No tiene mucho sentido explicar aquí cómo ejecutar SQL en cada gestor de bases de datos porque puede haber importantes diferencias entre un gestor de bases de datos y otro o, incluso, entre versiones del mismo programa. Y, en última instancia, es algo tan simple como trastear un rato con el programa. ## 8.6. Ejercicios propuestos Como de costumbre, vamos a proponer una batería de ejercicios de SQL para que practiques todo lo que hemos visto a lo largo de este capítulo. Muchos de ellos los encontrarás resueltos en la siguiente sección. Ya sabes lo que digo siempre: es una pésima idea mirar las soluciones antes de haber intentado resolverlos por tu cuenta. #### Ejercicio 1: compañía de seguros Una compañía de seguros dispone de una base de datos con las siguientes tablas: * Personas (dni#, nombre, apellidos, dirección, ciudad, país) * Coches (matrícula#, marca, modelo, potencia, conductor, seguro) * Seguros (núm-póliza#, compañía, tipo, franquicia, dni-tomador, fecha) Las claves ajenas son estas: * Coches.conductor → Personas.dni (es decir, el campo *coches.conductor* es una clave ajena de *personas.dni*) * Coches.seguro → Seguros.núm-póliza (el campo *coches.seguro* es una clave ajena de *seguros.num-numpoliza*) * Seguros.dni-tomador → Personas.dni (el campo *seguros.dni-tomador* es una clave ajena de *personas.dni*) Se pide escribir el código SQL necesario para: **a) Crear las tablas** (CREATE TABLE), suponiendo las siguientes restricciones: * Todas las claves primarias y ajenas son campos obligatorios (no pueden ser nulos). Además, las claves primarias no pueden tomar valores repetidos. * *Personas.país* tendrá, por defecto, el valor \"España\". Personas.ciudad tendrá, por defecto, el valor \"Almería\". * Hay que activar el borrado y actualización en cascada en todas las relaciones. * Es conveniente definir todas las claves como restricciones (*constraints*), con el objeto de poder modificarlas más adelante. * Todos los datos son cadenas de caracteres (la longitud puedes elegirla tú, siempre que sea razonable), excepto los siguientes: * *Coches.potencia* es un número real con tres cifras enteras y dos cifras decimales. * *Seguros.núm-póliza* es un número entero largo. * *Seguros.franquicia* es un número real con seis cifras enteras y dos decimales. * *Seguros.fecha* es de tipo fecha (claro) **b) Realizar los siguientes cambios en las tablas** (ALTER TABLE, INSERT, UPDATE, DELETE): 1. Agregar a la tabla Personas el campo *sexo*, con un sólo carácter y obligatorio. 2. Desactivar el borrado en cascada (no la actualización) de la clave ajena en la tabla Seguros. 3. Insertar estos registros: * En *Personas*, DNI = 1111A, Juan Martín, C/ Barco, Roquetas de Mar, España * En *Seguros*, Nº Póliza = 1, Compañía = Mapfre, Franquicia = 299,95 €, Tomador = Juan Martín 4. Modificar todos los seguros de tipo \"Todo riesgo\" para que la franquicia sea de 120 € 5. Borrar todas las personas que no vivan ni en España ni en Portugal. **c) Realizar las siguientes consultas** (SELECT): 1. Nombre y apellidos, ordenados alfabéticamente, de todas las personas que viven en ciudades que empiezan por \"A\". 2. Compañías de seguros que aseguran coches de la marca Seat y cuyas pólizas fueron contratadas después del año 2005. 3. Precio medio de las franquicias de los coches asegurados por la compañía Mapfre y cuya potencia es mayor de 100 caballos. 4. Nombre, apellidos, marca, modelo y compañía aseguradora de los vehículos cuyos dueños tienen varios coches y están asegurados en compañías diferentes. #### Ejercicio 2: Biblioteca Una base de datos de una biblioteca que lleva algún tiempo funcionando contiene, entre otras tablas, estas dos: * Libros (cód-libro#, título, editorial, cód-autor) * Autores (cód-autor#, nombre, apellidos, país, fecha-nacimiento) Por un error de implementación, el campo *libros.cód-autor* no se hizo clave ajena durante la creación de la tabla. Ahora se ha intentado crear la clave ajena con un ALTER TABLE, pero la base de datos impide la ejecución de la instrucción, alegando que se produce una violación de la integridad referencial. 1. ¿A qué puede deberse que la base de datos esté dándonos ese error? 2. ¿Cómo puede solucionarse? Escribe el código SQL que estimes necesario para intentar arreglar el problema. #### Ejercicio 3: academia de idiomas La base de datos de una academia de idiomas está formada por las siguientes tablas: * PROFESORES(#dni-prof, nombre, apellidos, idioma) * ALUMNOS(#dni-alum, nombre, apellidos) * GRUPOS(#cod-grupo, denominación) * HORARIOS(#cod-grupo, #día-semana, #dni-prof, hora-inicio, hora-fin, aula) Se pide escribir las sentencias SQL necesarias para: 1. Crear la tabla HORARIOS. Las claves y las horas son campos obligatorios. El aula es un número entero, y, aunque no es obligatorio, tomará por defecto el valor 1. 2. Modificar la tabla ALUMNOS para agregar el campo \"cod-grupo\", que es una clave ajena. 3. Insertar el registro [\"12345678-Z\", \"Juan\", \"López López\", \"Italiano\"] en la tabla PROFESORES. 4. Consultar los nombres y apellidos de los profesores que dan clase de francés de lunes a jueves a partir de las 16:00 horas, junto con la denominación de los grupos a los que dan clase y el horario de cada día. 5. Consultar los nombres y apellidos de los alumnos que reciben clases de al menos dos idiomas diferentes. 6. Consultar los nombres y apellidos de los alumnos que reciben clases de INGLÉS y de FRANCÉS. 7. Consultar los nombres y apellidos de los alumnos que reciben clases de INGLÉS o de FRANCÉS. 8. Consultar los nombres y apellidos de los alumnos que reciben clases de INGLÉS pero no reciben clases de ALEMÁN. #### Ejercicio 4: concesionario de automóviles Una empresa de venta de coches nuevos y usados tiene en su base de datos estas tablas: * COCHES(cod_coche#, marca, modelo, color, precio, tipo) – tipo puede ser \"nuevo\", \"km. 0\" o \"usado\" * COCHES_USADOS(cod_coche#, año, kilometraje, descuento, cod_desperfecto) * DESPERFECTOS(cod_desperfecto#, descripción, observaciones) * TIENDAS(cod_tienda#, ciudad, provincia, dirección, teléfono) * COCHES-ESTÁN-EN-TIENDAS (cod_coche#, cod_tienda#, cantidad) * CLIENTES (cod_cliente#, nombre, apellidos, domicilio, ciudad, provincia) * VENTAS(cod_coche#, cod_tienda#, cod_cliente#, fecha) A partir de esas tablas, se pide: 1. Crear la tabla COCHES, de forma coherente a cómo la hayas diseñado en el primer apartado. Utiliza tipos de datos SQL adecuados a la información que se guardará en cada campo. El campo cod_coche es obligatorio, y el campo precio tiene 10000,00 como valor por defecto. 2. Se ha detectado que algunos clientes tienen una \"provincia\" con valor nulo, pero, en cambio, sí que tienen un valor asignado al campo \"ciudad\". Escribe la(s) intrucción(es) SQL necesarias para arreglar este problema de la mejor manera que se te ocurra. 3. Obtener el NIF de los clientes y los códigos de tienda que no sean de la misma ciudad. 4. Obtener la matrícula, la marca y el modelo de los coches vendidos en tiendas de la provincia de Madrid que no hayan sido vendidos en ninguna otra provincia. 5. Obtener el código, ciudad y dirección de las tiendas que tengan entre 5 y 10 vehículos usados que sean de marca \"Renault\" y modelo \"Megane\". 6. Obtener el código, marca y modelo del coche, así como el nombre y apellidos del cliente, de todos los vehículos vendidos a un cliente de Almería por un concesionario de Almería. 7. Obtener el nombre y apellidos de clientes que hayan adquirido un coche en algún concesionario que posea actualmente en stock el vehículo marca \"Seat\", modelo \"León\". 8. Obtener los nombres y apellidos de clientes que no han comprado ningún coche de color rojo a ningún concesionario de Andalucía. #### Ejercicio 5 Las siguientes tablas contienen información sobre la liga de fútbol (equipos, jugadores, árbitros y partidos): * FUTBOLISTAS (cod-futbolista#, nombre, apellidos, fecha-nac, peso, estatura) * PARTIDOS (cod-partido#, jornada, fecha, resultado) * PARTICIPAN (cod-futbolista#, cod-partido#, minutos, goles, tarjetas) - Relación entre FUTBOLISTAS y PARTIDOS * EQUIPOS (nombre-eq#, año_fundación, presidente, num_socios, estadio) * JUEGAN (nombre-eq-casa#, nombre_eq_visitante#, cod_partido#) - Relación entre EQUIPOS y PARTIDOS * CONTRATOS (num-contrato#, cod-futbolista, nombre-eq, fecha-contrato, duración, ficha, claúsulas) * ÁRBITROS (num-colegiado#, colegio, nombre, apellidos, num-temporadas) * ARBITRAN (cod-partido#, num-colegiado#, función) - Relación entre ÁRBITROS y PARTIDOS (\"función\" puede ser \"principal\", \"juez de línea\" o \"cuarto\") Realiza estas consultas en lenguaje SQL: 1. El número de goles marcados por el jugador Pantuflo Zapatilla en los partidos del mes de febrero de 2007. 2. El nombre de los equipos contra los que ha jugado el Almería en partidos arbitrados por Esquinas Torres, así como el resultado y la jornada de esos partidos. 3. Todos los datos de la plantilla de futbolistas del Real Madrid. 4. Buscar el nombre y la estatura del futbolista más alto del FC Barcelona. ## 8.7. Ejercicios resueltos Aquí iremos resolviendo los ejercicios propuestos en el apartado anterior. Recuerda que es importante que, antes de mirar las soluciones, trates de hacerlos por tu cuenta. ",
    "url": "/docs/prog-y-3d/_site/lenguaje-sql/",
    "relUrl": "/lenguaje-sql/"
  },"12": {
    "doc": "9. Tecnologías de impresión 3D",
    "title": "9. Tecnologías de impresión 3D",
    "content": "# 9. Tecnologías de impresión 3D {: .no_toc } - TOC {:toc} Estamos acostumbrados a la **impresión 2D**, ¿verdad? Desde hace décadas las impresoras 2D imprimen en papel a un precio asequible y con multitud de técnicas: láser, inyección de tinta, matricial, térmica, etc. En la segunda década del siglo XXI, **la impresión 3D asequible también se convirtió en una realidad**. Sin embargo, todavía es un mundo bastante desconocido para muchas personas. En este capítulo vamos a recorrer la historia de las impresoras 3D, en qué consiste este tipo de impresión y cómo funciona, los tipos de impresoras que existen y cómo podemos iniciarnos en este mundillo. ## 9.1. Tecnologías de impresión 3D La **impresión 3D** se refiere a un un grupo de *tecnologías de fabricación capaces de crear objeto tridimensionales mediante la superposición de capas sucesivas* de un determinado material. Por lo tanto, con estas técnicas se pueden **crear objetos físicos a partir de un modelo digital**. ### 9.1.1. Un poco de historia Aunque nos puede parecer una tecnología moderna, en el año 1976 ya se desarrollaron los primeros equipos y materiales de construcción para la impresión en 3D. Unos años después, en 1981, Hideo Kodama, uno de los precursores de la impresión 3D, inventó dos métodos de fabricación de un modelo tridimensional con un polímero plástico que se endurecía al darle la luz. ![Primeras máquinas de impresión 3D - Hideo Kodama](/docs/prog-y-3d/_site/assets/images/09-01-hideo-kodama.jpg) Hideo Kodama y sus primeros diseños de impresora 3D de los años 70. En 1984 se patentaron varias tecnologías basadas en un proceso llamado **estereolitografía**, que se basa en ir añadiendo capas mediante polímeros plásticos que se endurecían al aplicarles radiación ultravioleta. Además, se definió un sistema para generar objetos tridimensionales mediante la creación de un patrón del objeto que dio lugar al **formato de archivo STL**, que es ampliamente aceptado hoy en día para la impresión 3D. En el año 1992 se desarrolló la primera máquina de impresión 3D de tipo **SLA** (tecnología estereolotigráfica), obra de la compañía *3D Systems*. Un láser ultravioleta iba solidificando un polímero capa por capa para crear objetos tridimensionales. A pesar de que no eran piezas muy perfectas, hacía pensar en el gran potencial que podía ofrecer este tipo de máquinas. ![Primera máquina de impresión 3D SLA](/docs/prog-y-3d/_site/assets/images/09-02-primera-impresora-sla.jpg) Aspecto de la primera impresora 3D por SLA, del año 1992. Siete años después, en 1999, hubo bastante revuelo cuando el equipo de investigación del Instituto de Wake Forest de Medicina Regenerativa (Carolina del Norte, EEUU) presentó la primera impresora 3D capaz de crear tejido orgánico. Esto abrió otro campo de aplicación de la tecnología de impresión 3D del que se esperan grandes resultados en los próximos años. En 2006 se construyó la primera impresora de tipo **SLS** o de sintetización de láser selectivo. Esta tecnología utiliza un láser para fundir materiales durante el proceso de impresión 3D. Representó una gran esperanza en la fabricación de piezas industriales, prótesis, etc. Un par de años más tarde, a través de un proyecto llamado *RepRap*, vió la luz la primera impresora capaz de replicar sus propios componentes, lo que permitía construir impresoras idénticas, piezas de repuesto o impresoras autorreparables. En el año 2011, los ingenieros de la Universidad de Shouthampton diseñaron un avión no tripulado impreso en 3D y fabricado en tan solo una semana. En ese mismo año, se pudo ver también el primer prototipo de un coche cuya carrocería había sido creada a través de la impresión 3D. En los últimos años hemos visto aplicaciones múltiples de la impresión 3D: implantes dentales, prótesis de huesos, material sanitario, piezas industriales, joyas... Y también hemos asistido a un abataramiento progresivo de las impresoras y sus consumibles. ### 9.1.2. Cómo funciona la impresión 3D El proceso de impresión 3D consiste en **crear objetos en tres dimensiones a partir de la superposición de capas de abajo hacia arriba**. La impresión 3D requiere de la cooperación de 3 elementos: * Un **software** adecuado para crear los modelos 3D y controlar el proceso de impresión. * La propia **impresora 3D**. * Los **consumibles** o materiales utilizados durante el proceso de impresión. Antes de comenzar la impresión, el software de impresión divide el modelo 3D en capas tan finas como el diámetro del material que se vaya a emplear para imprimir. Para cada capa, la impresora se va desplazando sobre el plano para ir liberando material sobre las coordenadas correspondientes y así ir formando la figura en tres dimensiones. El material de impresión, una vez depositado, se endurece y adquiere su forma definitiva. Por lo tanto, lo primero que necesitamos para imprimir un objeto en tres dimensiones es **un archivo creado con algún software de modelado 3D**. Lo siguiente es utilizar **el material más adecuado** para su fabricación. Las impresoras más habituales en la actualidad utilizan materiales **termoplásticos**, es decir, filamentos de plástico que se ablandan con el calor para poder darle forma, y que vuelve a endurecerse al enfriarse. Sin embargo, también existen impresoras capaces de utilizar otros materiales como metal, resinas sintéticas u otros polímeros. Estas impresoras tienen un coste mayor puesto que deben ser capaces de fundir los materiales a mayor temperatura. Y, por último, está **la propia impresora**. Casi todas se parecen entre sí y la mayor diferencia se da en su tamaño, su velocidad y el tipo de material que pueden utilizar para imprimir los modelos 3D. Ejemplo de impresión 3D por SLA o estereolitografía ### 9.1.3. Métodos de impresión 3D Aunque la mayoría de las impresoras actuales actúan fundiendo un material para ir creando las capas, hay algunas que depositan materiales líquidos que son solidificados con diferentes tecnologías, como la luz ultravioleta. Entre los métodos más utilizados en la impresión 3D tenemos: * **Modelado por deposición fundida (FDM)**: el material fundido, generalmente un termoplástico, se deposita en capas que se solidifican a temperatura ambiente. *Son las impresoras más habituales en la actualidad.* * **Estereolitografía (SLA)**: se utilizan resinas líquidas que se solidifican con luz ultravioleta. Una luz láser va creando capas de resina sólida hasta formar el objeto. Los objetos así obtenidos suelen ser mucho más perfectos y duraderos que los que se obtienen con la tecnología FDM, aunque el coste de estas impresoras es considerablemente mayor. Por eso se usan más en la industria que en la impresión doméstica, aunque ya existen los primeros modelos de sobremesa. * **Impresión por inyección**: En este método, la impresora crea los objetos inyectando un líquido dentro de un molde, lo que permite crear objetos con gran precisión y rapidez y, además, mezclar materiales y colores. El molde se retira cuando el líquido se ha solidificado. Los propios moldes pueden fabricarse previamente con impresoras 3D de tipo SLA. * **Fotopolimerización por luz ultravioleta**: se utiliza un recipiente de polímero líquido que es expuesto a la luz de un proyector bajo determinadas condiciones. El polímero se endurece a medida que la placa de montaje se va moviendo hacia abajo muy poco a poco para ir creando las distintas capas. * **Fotopolimerización por absorción de fotones (SLS)**: el objeto 3D es creado a partir de un bloque de gel que un láser va endureciendo selectivamente. Posteriormente, se retiran las partes de gel no endurecidas por el láser, y el resultado es el objeto 3D. ![Tipos de impresora 3D](/docs/prog-y-3d/_site/assets/images/09-04-tipos-de-impresora-3d.jpg) Algunos tipos de impresora 3D ### 9.1.4. Materiales Como hemos visto, se utilizan diferentes materiales según la tecnología de impresión. Cada material satisface una serie de propiedades (resistencia, precisión, conductividad, etc) y las piezas que se crean a partir de ellos tendrán diferentes usos. Los **materiales más utilizados** en la actualidad son: * **Ácido poliláctico (PLA)**: Se trata de un termoplástico con propiedades similares a las del tereftalato de polietileno (PET) que se utiliza habitualmente para hacer envases, solo que más fácil de colorear. * **Tereftalato de polietileno (PET)**: el mismo plástico utilizado para envases de bebidas. Se trata de un plástico ligero, resistente y reutilizable indefinidamente. Su problema es que no admite muchas coloraciones. * **Laywood**: es similar al PLA, pero mezclado con madera en polvo en diferentes porcentajes para ofrecer un resultado con un aspecto similar a la madera y que se puede pintar y lijar fácilmente. * **Acrilonitrilo butadieno estireno (ABS)**: un plástico muy resistente y que aguanta altas temperaturas. Ofrece cierta flexibilidad y es fácil de pintar. * **Poliestireno de alto impacto (HIPS)**: es una variedad de los poliestireno (el clásico \"corcho blanco\"), muy ligero aunque bastante frágil. Se modifica mediante diversos aditivos para mejorar su resistencia o su elasticidad. * **Elastómero termoplástico (TPE)**: otro termoplástico, en este caso dotado de una enorme elasticidad. * **Laybrick**: Se trata de un material que resulta de la mezcla de ciertos plásticos y yeso. Los objetos adquieren así un aspecto semejante a la piedra y se puedan pintar y lijar fácilmente. * **Nylon**: fibra textil sintética, muy elástica y resistente, utilizada para la fabricación y confección de tejidos y telas. * **Metales amorfos (BGM)**: aleaciones metálicas cuya estructura atómica (denominada \"amorfa\" o desordenada) permite que sean fácilmente maleables antes de su solidificación. ![Materiales para impresoras 3D](/docs/prog-y-3d/_site/assets/images/09-05-materiales-impresoras-3d.jpg) Algunos de los materiales disponibles en la actualidad para impresión 3D ### 9.1.5. Aplicaciones de la impresión en 3D Las **aplicaciones** de la impresión 3D son múltiples y muy variadas gracias a las diferentes técnicas y materiales que se pueden utilizar en función del tipo de objeto, precisión de detalles y resistencia. Algunos de los ámbitos de aplicación de la impresión de objetos en tres dimensiones son: * **Medicina y salud**: Ya se pueden crear ciertas prótesis con impresoras 3D (por ejemplo, en odontología). Muy pronto se fabricarán tejidos tolerables por el organismo. En el momento de escribir estas líneas, por ejemplo, la fabricación de piel sintética biocompatible está en fase de experimentación con animales. En un futuro no muy lejano se podrán recrear órganos humanos totalmente funcionales. También se puede fabricar material de uso médico con gran rapidez y facilidad. * **Educación**: se pueden crear modelos tridimensionales de conceptos abstractos o difícilmente disponibles para facilitar su estudio y comprensión: figuras geométricas, órganos, animales, piezas encajables, etc. * **Industria**: en el sector industrial, poder crear piezas para repuestos o para maquinaria nueva supone un gran ahorro de tiempo y de costes. * **Arqueología**: se pueden replicar objetos reales sin el complejo y laborioso proceso de modelado, reconstrucción, etc. * **Moda**: la industria de la moda también está aprovechando las ventajas de la impresión 3D para fabricar de forma rápida y sin apenas costes accesorios, calzado, complementos, bolsos, joyas o incluso prendas de ropa impresas en piezas que posteriormente se ensamblan entre sí. * **Comida y alimentación**: una de las aplicaciones más increíbles de la impresión 3D es la posibilidad de crear alimentos a partir de materiales comestibles y moldeables. Otro uso muy habitual es la fabricación de moldes en repostería. * **Otros**: la impresión 3D se puede aplicar en muchos otros ámbitos: fabricación de juguetes, réplica de antigüedades, jardinería, realización de maquetas para arquitectura, cine o televisión, creación de armamento (sí, sí: lo has leído bien; las armas creadas con impresoras 3D ya son un problema de seguridad pública)... Muchas de sus aplicaciones ni siquiera las hemos imaginado todavía. ![Maqueta construida con impresora 3D](/docs/prog-y-3d/_site/assets/images/09-06-maqueta-3d.jpg) La realización rápida, barata y precisa de maquetas es un ejemplo de aplicación práctica de de las impresoras 3D ### 9.1.6. El futuro de la impresión 3D La impresión 3D ha evolucionado mucho en los últimos años y ya ha quedado clara la infinidad de posibilidades que ofrece. Se espera que en el futuro cercano cobre aún mayor protagonismo. Las **aplicaciones futuras** de las impresoras 3D que probablemente más van a **revolucionar el mundo** son: * La creación de órganos humanos artificiales: corazones y riñones impresos serán casi con total seguridad los primeros en trasplantarse con éxito a seres humanos. * Fabricación de viviendas a medida, impresas en piezas que luego se ensamblarán, con propiedades térmicas y acústicas nunca vistas hasta ahora, y con unos tiempo de construcción de días en lugar de meses o años. * Creación de alimentos nuevos, nutricionalmente equilibrados, económicos y sostenibles desde el punto de vista ambiental. ![Comida impresa con impresora 3D](/docs/prog-y-3d/_site/assets/images/09-07-comida-3d.jpg) Objetos 3D comestibles creados con una impresora ## 9.2. Modelado y diseño diseño 3D Para imprimir cualquier cosa en 3D, primero hay que diseñarla y modelarla con el software adecuado. El **modelado y diseño 3D** se ha convertido en unas de las tendencias con más fuerza en el campo del diseño en las últimas décadas, no solo por las impresoras 3D. Se trata de un ámbito el diseño que cuenta con gran versatilidad y posibilidades infinitas en muchísimos campos, como la arquitectura, la ingeniería o la industria del entretenimiento. En este apartado vamos a conocer algo más sobre el diseño y modelado 3D. ### 9.2.1. En qué consiste el diseño 3D El diseño y modelado 3D es una manera de **recrear objetos trimensionales en la pantalla plana del ordenador**. Estos objetos se crean, generalmente, mediante **la unión de muchos polígonos** de pequeño tamaño entre sí, constituyendo lo que se denomina una **malla tridimensional**. Los polígonos son lo suficientemente pequeños como para que no se aprecie su existencia y, además, el software 3D es capaz de suavizar la conexión entre ellos. ![Ejemplo de modelo de malla](/docs/prog-y-3d/_site/assets/images/09-08-malla-3d.jpg) Ejemplo de modelo de malla creado con Blender A los polígonos se les aplica una **textura** para simular materiales, y los modelos pueden ser mejorados mediante la iluminación y otros efectos específicos, como el movimiento del agua o la simulación de fenómenos atmosféricos. ![Ejemplo de modelo de malla texturizado](/docs/prog-y-3d/_site/assets/images/09-09-malla-texturizada.jpg) El modelo anterior, texturizado Los modelos se pueden rotar, escalar y, en general, manipular muy fácilmente con el software adecuado. También se pueden animar (para la industria del cine, de la publicidad o de los videojuegos), renderizar (para crear imágenes fotorrealistas) o exportar a diferentes formatos (para, por ejemplo, imprimirlos en una impresora 3D). ### 9.2.2. Breve historia del diseño 3D Ya en la década de 1960 se crearon los primeros sistemas de Diseño Asistido por Computadora (CAD). Patrick Hanratty, conocido mundialmente conocido como \"el Padre del CAD\", ideó el primer sistema CAD, llamado **PRONTO**, ni más ni menos que en 1957. ![PRONTO, el primer sistema de CAD de la historia](/docs/prog-y-3d/_site/assets/images/09-10-pronto.jpg) PRONTO, el primer sistema CAD de la historia En los años 70 aparecieron varios sistemas de diseño y dibujo automatizado, sobre todo orientado al 2D, pero no fue hasta los años 80, con la popularización del ordenador personal, que se popularizaron los programas de diseño 2D entre el público en general. El más popular de todos fue, sin duda, **AutoCAD**, cuya primera versión salió al mercado en 1982. AutoCAD sigue siendo hoy la aplicación de referencia en arquitectura y delineación. ![AutoCAD en su versión 1 de 1982 y en una versión reciente](/docs/prog-y-3d/_site/assets/images/09-11-autocad.jpg) AutoCAD en su versión 1 (año 1982) y en una versión reciente Ya en los años 90 se generalizaron los programas de diseño 3D, como 3D Studio o Maya. La industria del cine, a partir de la aparición del estudio *Pixar* y su gran éxito de 1995, *Toy Story*, los hizo mejorar rápidamente, y esas mejoras llegaron muy pronto al mercado de la informática personal. En la actualidad, existe una enorme variedad de herramientas de diseño 2D y 3D, tanto libres como propietarias, algunas online y otras instalables en nuestros ordenadores o smartphones, algunas muy simples y otras tremendamente complejas y orientadas al mercado profesional. ![Blender, el software libre para modelado y animación 3D](/docs/prog-y-3d/_site/assets/images/09-12-blender.jpg) Blender es el software libre para modelado y animación 3D más popular y más completo del mercado ### 9.2.3. Programas de diseño 3D Aunque, como hemos dicho, hay muchos programas de modelado y diseño 3D, estos son algunos de los más importantes: * **Maya**. Creado por Autodesk (los creadores de AutoCAD), es un programa animación, renderizado y simulación. También puede hacer modelado 3D, aunque no es su fuerte. Se utiliza en el desarrollo de videojuegos, películas de animación y efectos visuales para cine, televisión y publicidad. * **3DS MAX**. También conocido como 3D Studio Max, es la apuesta de Autodesk para hacer modelado 3D. * **Blender**. Un software libre nacido para competir con Maya y 3DS. Aunque al principio resultaba más limitado, en la actualidad sus prestaciones no tienen nada que envidiar a sus hermanos propietarios. Es una herramienta todo-en-uno: permite hacer modelado 2D y 3D, animación, renderizado y simulación. Es altamente configurable y se puede programar en Python. Funciona en cualquier plataforma (Windows, MAC o Linux). * **Sketchup**. Es otro programa de modelado 2D y 3D muy popular, utilizado sobre todo en el ámbito de diseño de interiores, diseño industrial y arquitectura. * **Solidworks**. Es un software de diseño 3D bastante popular, sobre todo en el ámbito educativo, aunque también tiene aplicaciones profesionales. Es propietario y solo corre bajo sistemas Windows. * **TinkerCAD**. Un herramienta online de Autodesk para hacer modelos 3D y descargarlos. Su uso es gratuito y, aunque es más limitada que los otros programas, el hecho de que esté disponible online, sin necesidad de instalar ningún programa adicional en nuestro ordenador, la hace muy interesante. Pero modelo creado con estos programas no puede imprimirse directamente: antes hay que **dividirlo en capas** (*slices*) con un software específico, como **Makerware**, **Cura** o **Repetier**. Estos programas nos dejarán especificar ciertos parámetros de la impresión, como la altura de cada capa. A menor altura, más precisa (aunque más lenta) resultará la impresión. ### 9.2.4. Formatos de archivo Los modelos 3D creados con cualquiera de estos programas (o muchos otros que existen en el mercado) pueden manejar muchos formatos, pero en impresión 3D suele usarse el **formato STL**. La mayoría de las impresoras admitirán modelos 3D almacenados con este formato. Cuando el modelo 3D está fragmentado en capas, ya lo tenemos listo para pasarlo a nuestra impresora. La mayoría de ellas cuentan con un puerto USB para poder insertar una memoria Flash o un disco duro externo donde debemos llevar guardado el modelo que queremos imprimir. Algunos modelos más avanzados también disponen de una conexión de red. ## 9.3. Impresión 3D por FDM Las **impresoras 3D por FDM** son sin duda **las impresoras de 3D más extendidas en la actualidad**, ya que son relativamente sencillas de construir y baratas de adquirir. FDM, por cierto, significa *modelado por deposición fundida* (o *fused deposition modeling* en inglés). Las impresoras FDM basan en 4 elementos principales: * Una **placa** (también llamada **cama**) de impresión en la que se imprime la pieza. * Una **bobina de filamento termoplástico** que sirve como material de impresión * Una **cabeza de extrusión** también llamada **extrusor**. * Un **bastidor** donde descansa el extrusor y que le permite moverse en los 3 ejes del espacio (X, Y, Z). ![Partes de una impresora 3D por FDM](/docs/prog-y-3d/_site/assets/images/09-13-impresora-fdm-partes.jpg) Partes de una impresora 3D por FDM El filamento es succionado lentamente por el extrusor, que lo calienta, lo derrite y lo deposita de forma precisa sobre la cama de impresión. El extrusor se puede mover sobre la cama en cualquiera de los 3 ejes del espacio, y va ascendiendo poco a poco conforme avanza la impresión, para depositar así cada capa del modelo. La velocidad de impresión puede ajustarse en la mayoría de las impresoras. Si el modelo 3D es muy complejo, tendremos que usar una velocidad baja para que se imprima correctamente, con lo que la impresión puede demorarse varias horas. En cambio, un modelo 3D sencillo puede imprimirse a alta velocidad y estar listo en minutos. La impresión 3D comienza cuando la máquina alcanza **una temperatura alrededor de los 200°C**, necesaria para la fusión del material termoplástico. Entre los **materiales de impresión 3D** más populares en las impresoras FDM se encuentran el **PLA** (ácido poliacético) y el **ABS** (Acrilonitrilo butadieno estireno). Son plásticos baratos y resistentes, que funden a temperaturas relativamente bajas (unos 200º C) y que se pueden encontrar en bobinas de muchos colores en el mercado. El modelo no debe moverse ni un milímetro durante la impresión, o acabará saliendo un monstruo deforme. Para lograrlo, es habitual impregnar la cama con alguna sustancia levemente pegajosa (un poco de laca para el pelo suele dar buen resultado). Algunos modelos, por su forma, pueden necesitar soportes específicos para no caerse o desplazarse mientras se imprimen. Estos soportes pueden estar hechos del mismo material que el objeto impreso, con lo cual quedarán adheridos a él, o de un material que sea soluble en agua para poder retirarlos posteriormente sumergiendo la pieza en agua. Obviamente, el tamaño máximo del objeto que se puede imprimir con una de estas impresoras depende del tamaño de la cama y del tamaño del bastidor donde va colocado el extrusor. A mayor tamaño, mayor es el precio de la impresora. Algunas impresoras 3D domésticas de gama alta están equipadas con varios extrusores para combinar varios colores o materiales. Una impresora 3D por FDM trabajando ## 9.4. Actividades propuestas **Ejercicio 1**. Busca tres aplicaciones de las impresoras 3D (presentes o futuras) que te parezcan sorprendentes y que no se hayan mencionado en este tema. **Ejercicio 2**. Busca los precios actuales de los tipos principales de impresora 3D. Para cada tipo de impresora, busca al menos tres modelos: uno de gama baja, otro de gama media y otro de gama alta. Elabora una tabla comparativa. ¿Qué tipo de impresora es, en promedio, más asequible? ¿Y cuáles son las más caras? **Ejercicio 3**. No todo lo que rodea a las impresoras 3D son buenas noticias. Cada vez que los seres humanos inventamos una nueva tecnología, a alguien se le ocurre utilizarla de manera poco recomendable. Lee [este artículo](https://www.vozpopuli.com/internacional/armas-impresoras-3d-europa.html) y trata de imaginar otros peligros que pueden suponer, en el presente y en el futuro, las impresoras 3D. **Ejercicio 4**. En el tema hemos mencionado los paquetes de software de modelado 3D más importantes, como *Maya*, *Blender* o *3DS Max*. Busca en internet información acerca de qué software utiliza la industria del entretenimiento (cine, televisión, publicidad, videojuegos...) para hacer los modelos y animaciones 3D que vemos a diario. ",
    "url": "/docs/prog-y-3d/_site/tecnologias-de-impresion-3d/",
    "relUrl": "/tecnologias-de-impresion-3d/"
  },"13": {
    "doc": "10. Modelado e impresión 3D",
    "title": "10. Modelado e impresión 3D",
    "content": "# 10. Modelado e impresión 3D {: .no_toc } - TOC {:toc} En este capítulo vamos a aprender a usar una herramienta de **modelado 3D** llamada **TinkerCAD**. Se trata de una aplicación online muy sencilla (para tratarse de modelado 3D), intuitiva y gratuita que puede usarse desde cualquier navegador web, independientemente de tu sistema operativo. Posteriormente, veremos como los modelos 3D creados con TinkerCAD puede **trocearse en capas** (*slicing*) para su tratamiento con una impresora 3D y qué tenemos que hacer para **obtener ese modelo finalmente impreso**. ## 10.1. Software para diseño 3D: TinkerCAD *(Este apartado está adaptado del artículo \"Mega Tutorial TinkerCAD, cómo utilizarlo Paso a Paso\", publicado por Jorge Lorenzo en https://of3lia.com/tinkercad-tutorial-completo/)* Aunque existen programas de modelado 3D tan alucinantes como *Blender*, *Maya* o *3DSmax* (el primero de ellos, encima, gratuito), para aprender los fundamentos de estas técnicas sin complicarse mucho la vida, sin duda lo más apropiado es **TinkerCAD**. TinkerCAD es versátil, no hace falta instalarlo, es muy potente, es muy estable y, además, es online. Es verdad que resulta algo más limitado que sus hermanos mayores, ya que no tiene tantas opciones como otros programa de modelado 3D, pero, para la gran mayoría de nosotros, lo que ofrece TinkerCAD es más que suficiente. ### 10.1.1. Qué es TinkerCAD y cómo funciona **TinkerCAD** es un **programa de modelado 3D** que crea las piezas con el método *lowpoly*, que consiste en la **unión de polígonos** en un número relativamente bajo (comparado con otros programas) para crear los modelos. TinkerCAD trae un montón de figuras geométricas predefinidas para que las puedas usar en tus diseños. Para crear un perro, por ejemplo, tendrías que pensar qué conjunto de figuras es más adecuado unir: cilindros para las patas, una esfera para la cabeza, dos conos para las orejas... Cada una de estas figuras está constituida por un montón de polígonos que TinkerCAD maneja por nosotros. XXX imagen de perro cutre Además, como TinkerCAD es online, no hay que descargarlo, instalarlo ni configurarlo: basta con crearse una cuenta en su web [www.tinkercad.com](https://www.tinkercad.com/). Existen cuentas de tres tipos: * Educadores: pensada para profesores/as que quieren usar TinkerCAD en sus clases. * Estudiantes: para alumnos/as de los profesores anteriores. Los profesores pueden crear clases y los estudiantes pueden unirse a esas clases. Los miembros de una clase pueden interactuar entre ellos, ver sus diferentes trabajos o colaborar en grupos. * Cuentas personales: para el público en general. XXX imagen home + imagen tipos usuario ### 10.1.2. Moviéndose por TinkerCAD Los controles de TinkerCAD son muy sencillos. Eso sí, necesitarás un ratón con ruleta central. Estos son los principales: * **Click izquierdo**: Selección. * **Click derecho**: Rotación. * **Ruleta del ratón**: Zoom. * **Click en ruleta ratón**: Traslación. Cuando seleccionas un objeto, aparecen unos controles muy intuitivos a su alrededor para **moverlo, rotarlo y escalarlo**. Además, también puedes mover el **cubo** que hay en la parte superior izquierda para mover todo el objeto y si das doble click en sus caras posicionas tu vista de forma perpendicular a ese plano. XXX tutorial-tinkercad-2 ### 10.1.3. El panel de control En esta imagen puedes ver el aspecto del **panel de control** de TinkerCAD con sus áreas principales numeradas: XXX tutorial-tinkercad-3 Las áreas del panel de control son estas: 1. **Espacio de trabajo**. El cuadrado grande es la superficie de trabajo y el pequeño son las opciones de dicha superficie: tamaño total, tamaño de la rejilla y unidades de medición. 2. **Modos de visualización**. El primero es el ***cubo*** de visualización, que nos permite rotar el objeto. Después tenemos la ***vista inicial***, para volver a la visualización estándar, los controles de ***zoom*** (para acercarnos o alejarnos del objeto) y el ***cambio de vista*** (para activar o desactivar la perspectiva isométrica). 3. **Zona de edición de objetos**. Aquí podremos ocultar objetos si nos molestan, hacer simetrías, agrupar, desagrupar y alinear. Es una de las herramientas que más usaremos. 4. **Zona de usuario**: importar y exportar archivos y acceder funcionalidades adicionales. 5. **Banco de piezas**. Aquí está toda la (enorme) biblioteca de pieza prediseñadas de TinkerCAD. Esta es una de las principales características que diferencian a TinkerCAD de otros programas de modelado 3D: la enorme cantidad de figuras predefinidas que existen. Otros programas tienen solo cubos, conos, cilindros y poco más. Encima de la biblioteca encontrarás las herramientas del **plano de trabajo** y la **regla**. Más adelante veremos para qué sirven. 6. **Herramientas de edición del documento**: copiar, pegar, duplicar, eliminar, rehacer, deshacer... Si hacemos click justo al lado del nombre del documento, podremos cambiar su visibilidad y su tipo de licencia. ### 10.1.4. Cómo modelar objetos 3D con TinkerCAD **Modelar objetos 3D** con TinkerCAD es muy fácil, al menos en comparación con otros programas de diseño 3D. Vamos a hacer recorrido por el proceso mediante unos ejemplos, revisando con ellos las cuatro cosas fundamentales que se usan en todos los modelados. Una vez que hayas asimilado esas cuatro cosas, podrás aplicarlas por tu cuenta para diseñar cualquier otro objeto, simplemente dejando volar tu imaginación. #### Hacer uniones y vaciados entre formas Una de las cosas más habituales que se han en los programas de diseño 3D es **unir dos objetos** entre sí. Para entender cómo funciona, sigue estos pasos: 1. Arrastra un cubo al espacio de trabajo. 2. Arrastra un cilindro al espacio de trabajo. 3. Agranda el cilindro. 4. Mete el cubo en el cilindro y vuelve a pulsar el cubo. 5. Ahora te toca decidir: déjalo como está o selecciona la opción *\"hueco\"*. Cuando te decidas, pulsa *\"Agrupar\"*. Si has escogido la primera opción, se habrá formado un sólido a partir de la **unión** de las dos piezas. La pieza resultante es ahora una sola, y cuando la escales o la muevas se moverá como tal. Si has escogido la segunda opción 2, se habrá formado un sólido a partir de la **diferencia** de una pieza con la otra. Es decir, has escogido que el cubo sea un hueco. Y si juntas un sólido con un hueco, ¿qué tienes? Muy fácil: un sólido con un agujero. Acabas de practicar tu primer **vaciado** de piezas. La unión y el vaciado son dos de las operaciones más comunes durante el modelado. Si controlas bien estas dos operaciones, puedes hacer casi cualquier cosa. tutorial-tinkercad-7 #### Cambiar el plano de trabajo Sigamos trabajando con nuestro sólido con agujero, al que vamos a llamar *\"cabaña\"*. Ahora queremos ponerle un bonito **tejado cónico**. Para ello, podemos crear un cono, agrandarlo y subirlo hasta la parte superior de nuestro objeto, ¿verdad? Pero *hay una solución más fácil*. Seleccionar la herramienta **Plano de trabajo** y sitúa el nuevo plano sobre el tejado de nuestra pieza. Verás que también puedes ponerlo en las paredes, en la puerta o donde te dé la gana. tutorial-tinkercad-8 Ahora crea un cono sobre el plano y listo. Como ves, el nuevo plano de trabajo tiene otro color para distinguirlo del original. Esta es herramienta es muy útil para no tener que mover objetos continuamente hasta colocarlos en su lugar. Además, no necesitas tener una cara plana para crear un nuevo plano de trabajo: incluso puedes hacerlo tangente a una esfera. Para **volver al plano de trabajo original**, pulsa sobre la herramienta y selecciónalo otra vez. Así de sencillo. tutorial-tinkercad-9 #### Transformar, alinear y medir El siguiente ejemplo lo vamos a hacer con **cuatro esferas** coloreadas como las fichas del parchís: tutorial-tinkercad-10 Lo primero que haremos será **transformarlas**. Para ello, selecciona una de ellas (la azul, por ejemplo), y verás que salen varios iconos: * Los **puntos blancos** transforman la pieza en dos dimensiones a la vez (X e Y) o solo el eje Z. * Los **puntos negros** transforman la pieza en una sola dimensión (X o Y). * La **flecha negra** superior mueve el objeto hacia arriba y hacia abajo. * Las **flechas curvas** rotan la pieza en cualquiera de los 3 ejes (X, Y o Z). Si, además, pulsas la **tecla Mayúsculas** y mueves uno de los puntos blancos, la figura se **escala** uniformemente. tutorial-tinkercad-11 Otra cuestión fundamental es **alinear objetos**. Cuando tienes varios objetos, a menudo necesitarás dejarlos perfectamente alineados. Hacerlo a mano es tedioso e inexacto. TinkerCAD lo hace por ti. Simplemente, selecciona la esfera roja y la esfera verde y pulsa \"Alinear\". Vamos a alinearlas en la línea media del eje longitudinal. tutorial-tinkercad-12 Y ahora intena alinear todas las esferas entre sí, en disposición de rectángulo. tutorial-tinkercad-13 Finalmente, vamos a ver para que sirve la **regla**. Al posicionar la regla te darás cuenta de dos cosas: * Puedes cambiar todas las medidas de la pelota (ya que las ves). * Puedes cambiar la posición relativa de los objetos con respecto a la regla. tutorial-tinkercad-14 Esto te ayudará a saber la posición relativa entre los objetos, por si necesitas medidas exactas. Vamos a probarlo poniendo las esferas en forma de cuadrado de 40 mm de lado. tutorial-tinkercad-15 Si interiorizas todo esto bien (a base de practicar un buen rato), ya puedes considerarte un usuario/a avanzado/a en TinkerCAD. Pero aún vamos a aprender un par de cosas más... ### 10.1.5. Edición de modelos STL para impresión 3D TinkerCAD también puede manipular modelos 3D hechos por otras personas, aunque hayan usado otros programas. Por ejemplo, vamos a diseñar una taza con la cabeza de Ironman capaz de contener en su interior una lata de refresco convencional. Ve a la web de [Thingiverse](https://www.thingiverse.com/), un portal donde los usuarios suben sus diseños 3D para que otros usuarios puedan descargarlos libremente, y descárgarte el busto de Ironman (simplemente, busca \"Ironman Bust\"): tutorial-tinkercad-16 (Si tienes problemas para descargarlo, inténtalo desde [aquí](XXX link a STL de ironman en assets)) Ahora sigue estos pasos: * Escala el busto para que mida 140 mm de ancho. * Crea 3 cubos huecos para quitarle toda la parte del cuerpo (hombros incluidos). El cubo central hasta la barbilla mide 63mm de alto. Ahora se los restamos. * Inserta un cilindro de 67mm de diámetro y 115mm de alto. Esto es debido a que las latas convencionales de refresco miden 66mm de diámetro, y tenemos que dejar al menos 1mm de holgura. * Inserta un toroide (o \"donut\") como mango. * Haz la unión de todos los elementos. tutorial-tinkercad-17 Más o menos así debería quedarte el resultado: ¡una taza de Ironman para latas diseñada en cinco minutos! tutorial-tinkercad-18 🧠 XXXYYY Genera Formas Imposibles con CAD online: Diseños de TinkerCAD 3D Cuando has usado las formas básicas te habrás dado cuenta de que cada objeto tenía sus propiedades concretas, pero ¿y si hubiera objetos con otras propiedades? ¿y sí los pudiéramos crear nosotros y darle las propiedades quisiéramos. Pues los hay, y están en el generador de formas. 🌈 Generación de Figuras en TinkerCAD Predefinidas El generador de formas está en el mismo lugar que las formas básicas pero otra pestaña diferente. Ten en cuenta que todos estos objetos tienen propiedades modificables, una pared no será una simple pared, podrás cambiarla el grosor, grosor de los ladrillos, ancho, alto… Entre todo lo que puedes hacer, tienes: Mapas de los E.E.U.U., regiones de China y Japón, Australia, y Europa. Una casa con jardín. Importar archivos .svg Generador de código QR. Diagramas circulares y de barras. Figuras del Carcassonne. Cuatro tipos de engranaje. Un generador de funciones 3D y otro de superficies. Un taladro (la boquilla) y Un mandala. Una caja ventilada para meter placas electrónicas. Un reflector parabólico paramétrico. Perfiles aerodinámicos de avión. Una matriz circular de perfil personalizable. Una matriz 3D con cubos y nomenclatura matriz. La curva de Moebyus. Un árbol con fractales. El mosaico de Penrose. Simuladores de terreno (rocoso y de hierva). tutorial-tinkercad-19 Y así hasta 17 páginas completas, yo me he quedado loco con lo de la generación de curvas 3D ¿tú no? Ya me imagino haciendo un megamapa de Estados Unidos impreso en 3D para un trabajo de colegio con mi hijo/a o explicándoles las funciones con diagramas 3D. No tiene límites. 🖲️ Programa y crea tus propios objetos 3D online Si te mola JavaScript y TinkerCAD, el generador de formas mediante código es lo tuyo. Vete a panel de Formas/ You / Tus generadores de Formas, te creas un nuevo proyecto y a disfrutar. tutorial-tinkercad-20 También puedes ver el código JavaScript de otros en las figuras del generador de formas, si pulsas sobre uno cualquiera te pondrá debajo si su código está disponible o no. tutorial-tinkercad-21 ¿Ves cómo mola? Yo no entiendo ni papa de JavaScript (lo mío es C++), pero mira que cosas tan chulas comparte la gente. ¡Viva la comunidad maker! tutorial-tinkercad-22 👶🏻 Espacios adicionales en TinkerCAD para niños (y mayores) que casi nadie conoce Lo de que casi nadie conoce, no es por que estén muy escondidos, sino que la gente cuando piensa en TinkerCAD solo piensa en un programa de diseño 3D online para niños, y para nada es así. Te voy a enseñar alguno de los rincones más sorprendentes de este programa. 💡 Crea Diseños y Simulaciones con Arduino y Circuits TinkerCAD te permite hacer montajes con componentes de Arduino y lo mejor de todo: los puedes simular. Es una pasada y vicia mucho, perfecto para dar clases o aprender cuando no se tiene recursos materiales para hacerlo. tutorial-tinkercad-23 🐉 Diseña tus porpios Mods para Minecraft Mods significa modificaciones, y es que en Minecraft puedes importar tus propias figuras y edificios, siempre que estén hechos por cuadrados. Como una imagen vale más que mil palabras y mil imágenes más que una imagen, te dejo un video flipante del tema. 🏰 Haz construcciones técnicas con Lego En este caso tenemos lo mismo, pero con Lego. Personalmente no le acabo de pillar el punto a esto, ya que lo mismo que tardas en diseñar algo básico en el programa lo tardas montando tú en casa. Te dejo a un video de alguien haciendo un 3D Benchy y si se lo pillas tú me lo cuentas en comentarios. Actualización: Aunque sigo sin verle tanto la gracia, hay una nueva funcionalidad que permite transformar cualquier figura 3D en Lego para que puedas montarla y no tengas que pensar cómo hacerlo. Está bien 🙂 📝 Esto no acaba aquí guaperas: Ejercicio Práctico. ¿Te has enterado de algo? No contestes, y haz mi ejercicio. Consiste en replicar el coche de Of3lia de forma un tanto apañada y solo mediante las figuras básicas. Si quieres ahorrar tiempo usa el truco de cambio de plano y alinea cuanto puedas. No te doy más pistas. 3, 2, 1… Al lío 🙂 tutorial-tinkercad-27 tutorial-tinkercad-28 tutorial-tinkercad-29 Solución ▶️ Más Tutoriales de TinkerCAD en Video He estado buscando algunos tutoriales de TinkerCAD en video por si te venían mejor, aunque personalmente, creo que vas a tardar más en verlos que en leerte este artículo, pero hay gente que lo asume mejor. El mejor que he encontrado es este, que es el único que no me parece un petardo de ver. Disfrútalo 🙂 💙 ¿Qué te ha parecido mi tutorial de TinkerCAD el mejor programa de diseño 3D online? Disfruto muchísimo haciendo estos tutoriales la verdad, pero es una matada. Espero que hayas disfrutado este tutorial de tinkercad 3d para diseñar en español, inglés o el idioma que sea, es lo chulo de esto, solo hace falta contar y ya. Si has llegado aqúi, mis enhorabuenas, casi nadie lo consigue. Me encantaría saber que te ha parecido el post y cualquierduda quetengas, no dudes en ponérmela por aquí 🙂 Si quieres ver más programas de diseño 3D (los que yo uso), te dejo un post estupendo que hice hace poco (y lo actualizo). Un abrazo y hasta la próxima. ## 10.2. Software para *slicing* (laminado) ## 10.3. Creación e impresión de figuras básicas ## 10.4. Transformación, rotación y unión de figuras básicas ## 10.5. Formatos de archivo para impresión 3D ## 10.6. Pruebas de impresión ## 10.7. Actividades propuestas ",
    "url": "/docs/prog-y-3d/_site/modelado-e-impresion-3d/",
    "relUrl": "/modelado-e-impresion-3d/"
  },"14": {
    "doc": "X. Entornos integrados de desarrollo",
    "title": "X. Entornos integrados de desarrollo",
    "content": "# 7. Entornos integrados de desarrollo {: .no_toc } - TOC {:toc} **Entornos integrados de desarrollo. Depuración. Ciclo de vida del software. Trabajo en equipo y mejora continua. Control de versiones. Metodologías ágiles: Scrum.** XXX ## 7.1. Editores de texto XXX ## 7.2. Editores de código Estrictamente hablando, Visual Studio Code es un **editor de código**, no un IDE. Los editores de código son soluciones intermedias entre los editores de texto (más sencillos) y los IDEs (más sofisticados). Los editores de código no solo permiten editar el texto, sino que proporcionan herramientas adicionales para el programador: atajos de teclado, resalto de la sintaxis del lenguaje, autocompleción del texto, etc. XXX la hora de codear que le facilita a la vida a los devs. ¿Por ejemplo? syntax highlighting (coloreado de sintaxis) o code completion (que ayuda a completar los nombres de clases, métodos, campos y palabras clave). ¿Cuál es la particularidad de los IDE? Son entornos de desarrollo mucho más complejos que integran varias herramientas para el desarrollo de software en una sola aplicación. Y tan solo uno de sus componentes es editor de código. ¿Qué es Visual Studio Code? Como dijimos, para cada editor de código existe una subcultura asociada. Los programadores se encargan de mantener vivos estos editores, ofrecen mejoras y actualizaciones y promueven su uso entre aquellas personas que recién se inician en el mundo del desarrollo. Lo que es seguro, es que, para quienes recién comienzan, Visual Studio Code es la puerta de entrada. Este editor de código fue desarrollado por Windows -aunque también funciona muy bien en Mac-. ¿Qué ofrece? Una consola integrada, atajos y comandos que te ayudan a codear más rápido y extensiones muy útiles. Este editor es gratuito, open-source, muy estable y rápido, y proporciona acciones y recursos muy interesantes que lo convierten en uno de los preferidos por los desarrolladores. ¿Qué podemos hacer con VS Code? Autocompletar con IntelliSense Descripción automática en tiempo real de la API Abrir y ordenar múltiples carpetas Realizar una comparación de versión lado a lado Editar de manera colaborativa y en vivo Es compatible con más de 30 lenguajes. Visual Studio Code es muy amigable para quienes recién comienzan a aprender a programar, así que si recién estás dando tus primeros pasos en programación y quieres una herramienta que te potencie, ya sabes. Introducción Como desarrollador, es importante disponer de las mejores herramientas para realizar el trabajo. En el pasado, Salesforce ofreció muchas herramientas y cada una de ellas proporcionaba algo que faltaba en otras del mercado. Esta guía de inicio rápido le ayudará a familiarizarse en el próximo paso hacia nuestras increíbles herramientas para desarrolladores: Salesforce Extensions con Visual Studio Code. Pero primero, ¿qué es un IDE? Un IDE, o entorno de desarrollo integrado, se compone de un editor de código, herramientas de automatización de creación, un depurador y una finalización de código inteligente. Visual Studio Code ofrece todos estos componentes. Seguir la ruta juntos ¿Desea seguir con un instructor a medida que trabaja en este paso? Eche un vistazo a este video, que forma parte de la serie Trail Together en Trailhead Live. Encontrará un vínculo a la sesión completa en la sección Recursos. Instalación de Visual Studio Code Puede instalar Visual Studio Code en cualquier computadora que utilice macOS, Windows o Linux. Los requisitos del sistema son relativamente asequibles, por lo que puede ejecutarse en cualquier computadora. Descargue e instale la versión más reciente de Visual Studio Code para su sistema operativo. Si ya instaló Visual Studio Code, no es necesario volver a instalarlo. Inicie Visual Studio Code. Familiarizarse con la interfaz Página de bienvenida de Visual Studio Code. La página de bienvenida de Visual Studio Code se abrirá automáticamente la primera vez que ejecute la aplicación. Esta página ofrece numerosos vínculos de acceso directo que permiten comenzar a trabajar con nuevos archivos, aprender acerca de Visual Studio Code o incluso personalizar la interfaz en función de sus preferencias. En Learn (Aprender), haga clic en Interface Overview (Descripción general de la interfaz) para abrir una descripción visual de las distintas características de Visual Studio Code. La superposición Interface Overview (Descripción general) de la interfaz destaca elementos clave de navegación en el IDE de VS.Esta superposición le permite visualizar todo lo que es capaz de hacer Visual Studio Code. La barra inferior muestra las notificaciones, las advertencias y los errores actuales. También permite cambiar al terminal integrado. En la parte izquierda del editor podrá utilizar el explorador de archivos, buscar archivos, gestionar su código fuente, iniciar o depurar su código y gestionar extensiones. (En un futuro, también se instalarán varias extensiones para ayudar con el desarrollo.) Por último, también hay un menú que permite ejecutar comandos en el editor. Esta es otra sección que exploraremos muy pronto. Haga clic en cualquier punto de la pantalla para descartar la superposición visual. En Iniciar, haga clic en New file (Nuevo archivo). Haga clic en Text Editor (Editor de texto). En este espacio podemos comenzar a escribir. Agregue el texto Hello World en la línea 1. Documento sin título con Hello World en la primera línea de código. Cierre el archivo sin guardar. Nota Puesto que aún no guardó el código, Visual Studio Code no destaca nada. ## 7.3. Entornos integrados de desarrollo Un **IDE** o **Entorno intrado de desarrollo** es un programa informático que proporciona, dentro del mismo programa, acceso a todas las funciones fundamentales para el desarrollo de software: edicion del código fuente, compilación, depuración, ejecución.. Con estas herramientas resulta mucho más cómodo y rápido programar que utilizando cada una de esas herramientas por separado. Algunos IDEs son monstruos devorarrecursos que disponen de herramientas adicionales potentísimas, como autocompleción de sentencias, generador automático de código, analizador del rendimiento, refactorizador, soporte multilenguaje... Otros son más simples y ligeros, y disponen de un editor sencillo y unos pocos menús para guardar, editar y ejecutar los programas. La elección del IDE es algo muy personal. Llegarás a una conclusión después de tener alguna experiencia con varios de ellos. En este capítulo vamos a introducir el uso de un IDE con una enorme aceptación en los últimos años: **Visual Studio Code**. Hay muchísimos IDEs en el mercado, algunos muy complejos como Netbeans o Eclipse, otros muy livianos como Geany, Vim o Atom. ¿En qué se diferencian unos de otros? Hay varios factores cruciales: velocidad, versatilidad, rendimiento, complementos, funcionalidad, compatibilidad con determinados lenguajes, apariencia, etc. Cada desarrollador ha tenido siempre sus preferencias, pero en los últimos tiempos parece haber un consenso imposible entre los programadores de todo el mundo: Visual Studio Code es el IDE número uno del mundo. ",
    "url": "/docs/prog-y-3d/_site/entornos-integrados-de-desarrollo/",
    "relUrl": "/entornos-integrados-de-desarrollo/"
  },"15": {
    "doc": "X. Seguridad y privacidad",
    "title": "X. Seguridad y privacidad",
    "content": "# 9. Seguridad y privacidad {: .no_toc } - TOC {:toc} Seguridad y privacidad. Acceso a la información de las bases de datos. ",
    "url": "/docs/prog-y-3d/_site/seguridad-y-privacidad/",
    "relUrl": "/seguridad-y-privacidad/"
  },"16": {
    "doc": "About",
    "title": "About",
    "content": "Estos apuntes han sido elaborados por Antonio Zapata Sierra y Alfredo Moreno Vozmediano, del Departamento de Informática del IES Celia Viñas de Almería, y se publican aquí con licencia [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/), lo que quiere decir que eres libre de usar este material, copiarlo, distribuirlo y modificarlo siempre que el resultado de todo eso mantenga la misma licencia y cites la autoría original. Algunos fragmentos (pocos) están tomados y adaptados de otras fuentes. Cuando eso ocurre, lo indicamos claramente en el texto. Debes atenerte a la licencia de los sitios web de origen para esos fragmentos. ",
    "url": "/docs/prog-y-3d/_site/about/",
    "relUrl": "/about/"
  },"17": {
    "doc": "Introd. a la prog. y al diseño 3D",
    "title": "Introd. a la prog. y al diseño 3D",
    "content": "Esta es la documentación (apuntes) de ***Introducción a la programación y al diseño 3D***, optativa de 2º de Bachillerato ofertada por el IES Celia Viñas de Almería (España). 1. TOC {:toc} ",
    "url": "/docs/prog-y-3d/_site/",
    "relUrl": "/"
  }
}
