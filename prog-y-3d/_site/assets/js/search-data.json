{"0": {
    "doc": "0. Presentación de la asignatura",
    "title": "0. Presentación de la asignatura",
    "content": "# 0. Presentación de la asignatura {: .no_toc } - TOC {:toc} ## 0.1. Contextualización y horario La asignatura **Introducción a la programación y al diseño 3D** se imparte como optativa en segundo curso de Bachillerato en el IES Celia Viñas de Almería y tiene una duración de 72 horas (2 horas semanales). El profesor encargado de impartirla durante el curso 2021-2022 es **Alfredo Moreno Vozmediano**, miembro del Departamento de Informática. Salvo cambio de criterio de la dirección del centro, durante el curso actual, el **horario** de clases será el siguiente: * Miércoles de 9:05 a 10:05 horas (aula 19). * Jueves de 12:35 a 13:35 horas (aula ?). ## 0.2. Objetivos Los objetivos de esta asignatura son los siguientes: 1. Comprender el impacto del pensamiento computacional en la sociedad actual. 2. Producir programas informáticos plenamente funcionales. 3. Integrarse en un equipo de desarrollo de software que sea capaz de afrontar proyectos de cierta envergadura. 4. Desarrollar la capacidad de abstracción. 5. Emplear la creatividad en el desarrollo de aplicaciones informáticas para resolver problemas y fomentar la capacidad de expresión personal. 6. Recopilar, almacenar y procesar datos con el objetivo de encontrar patrones, descubrir conexiones y resolver problemas. 7. Analizar cómo la representación, el almacenamiento, la seguridad y la transmisión de datos requiere de manipulación computacional, y comprender los riesgos de seguridad y privacidad existentes cuando se trata de información personal. 8. Conocer los fundamentos y aplicaciones del Diseño Asistido por Ordenador y capacitar para el diseño de objetos bidimensionales y tridimensionales sencillos. 9. Fomentar el trabajo en equipo y la comunicación interpersonal. ## 0.3. Contenido Los contenidos de la asignatura se dividen en **cuatro bloques y 12 unidades didácticas**. Los resumimos a continuación. **Bloque 1. Representación digital y pensamiento computacional** * UD1. Características, ejemplos e importancia del pensamiento computacional. * UD2. Representación de la información. Bits, bytes, múltiplos y submúltiplos. Almacenamiento, transmisión y tratamiento de la información binaria. Representaciones octal y hexadecimal. ASCII y Unicode. **Bloque 2. Introducción a la programación** * UD3. Lenguajes de programación. Tipos de lenguajes. Estructura de un programa informático. Tipos básicos de datos. Constantes y variables. Operadores y expresiones. Comentarios. Pseudocódigo y diagramas de flujo. Estructuras de control: secuencial, condicional e iterativa. * UD4. Estructuras de datos. Funciones y bibliotecas de funciones. Reutilización de código. Facilidades para la entrada y salida de datos de usuario. Manipulación de archivos. * UD5. Orientación a objetos. Clases, objetos y constructores. Herencia. Subclases y superclases. Polimorfismo y sobrecarga. Encapsulamiento y ocultación. * UD6. Entornos integrados de desarrollo. Depuración. Ciclo de vida del software. Trabajo en equipo y mejora continua. Control de versiones. Metodologías ágiles: Scrum. * UD7. Lenguajes de programación reales. Java, Python o PHP. **Bloque 3. Datos e Información** * UD8. Almacenamiento de la información. Ficheros. Bases de datos relacionales. Sistemas gestores de bases de datos. Diseño conceptual. Diagramas entidad-relación. Normalización hasta 3FN y FNBC. Definición y manipulación. * UD9. Comandos básicos de SQL: DDL, DML y DCL. * UD10. Seguridad y privacidad. Acceso a los información de las bases de datos. **Bloque 4. Diseño 3D** * UD11. Tecnologías de impresión 3D. Utilidad y posibilidades del diseño 3D. Impresión 3D por FDM. Impresoras 3D por FDM. Partes, funcionamiento y mantenimiento básico. * UD12. Modelado e impresión 3D. Software para diseño 3D y software para slicing (laminado). Creación e impresión de figuras básicas. Transformación, rotación y unión de figuras básicas. Formatos para impresión 3D. Pruebas de impresión. ## 0.4. Evaluación y calificación A lo largo de curso se evaluarán los siguientes elementos: * **Observación del trabajo diario** en el aula (calificación de 1 a 10). * **Actividades, prácticas y proyectos** (calificación de 1 a 10). * **Test de conocimientos** (exámenes) (calificación de 1 a 10). Para aprobar cada **evaluación trimestral**, es necesario **obtener al menos un 5** en cada uno de los apartados anteriores. La nota trimestral se calculará así: * Observación directa y trabajo diario: 30% * Prácticas y proyectos: 40% * Tests de conocimientos: 30% La **nota final del curso** se obtendrá mediante una media aritmética de las calificaciones obtenidas en cada trimestre. Se hará un examen teórico-práctico final, con actividades de un nivel similar a las propuestas en las prácticas y proyectos, para las personas que no hayan superado alguna de las evaluaciones trimestrales. Asimismo, habrá una recuperación en septiembre con la misma naturaleza y que abarcará toda la materia impartida durante el curso. ",
    "url": "/docs/prog-y-3d/_site/presentacion/",
    "relUrl": "/presentacion/"
  },"1": {
    "doc": "1. Pensamiento computacional",
    "title": "1. Pensamiento computacional",
    "content": "# 1. Pensamiento computacional {: .no_toc } - TOC {:toc} ## 1.1. ¿Qué es eso del pensamiento computacional? El pensamiento computacional es un proceso de **formulación y resolución de problemas que utiliza los conceptos de la ingeniería informática**. Es decir, consiste en pensar como lo haría un científico-informático cuando está frente un problema y tener la habilidad y la actitud para que nos sea útil tanto en nuestra vida personal como profesional. Hemos dicho \"vida personal\", sí. Uno de los errores más frecuentes cuando se habla de *pensamiento computacional* es considerar que solo se aplica a la Informática. El pensamiento computacional **sirve para resolver problemas cotidianos haciendo uso de las técnicas y habilidades de los programadores/as informáticos** y obtener así soluciones que pueden ser representadas mediante una serie de pasos o instrucciones. Aquí tienes un vídeo que desarrolla esta interesante idea en tres minutos: ## 1.2. Características del pensamiento computacional Según las definiciones que hemos visto en el apartado anterior, el pensamiento computacional es un proceso de resolución de problemas que incluye las siguientes características: * Reformular problemas de forma que se permita el uso de un ordenador y otras herramientas para ayudar a resolverlos. * Organizar y analizar lógicamente la información. * Representar la información a través de abstracciones como los modelos y las simulaciones. * Automatizar soluciones haciendo uso del pensamiento algorítmico (estableciendo una serie de pasos ordenados para llegar a la solución). * Identificar, analizar e implementar posibles soluciones con el objetivo de lograr la combinación más efectiva y eficiente de pasos y recursos. * Generalizar y transferir este proceso de resolución de problemas para ser capaz de resolver una gran variedad de familias de problemas. #### Ejemplo de pensamiento computacional Escribir **una receta de cocina** siguiendo unos pasos o instrucciones sería un buen primer ejemplo de aplicación para el pensamiento computacional. Por ejemplo, supongamos que queremos cocinar un *risotto* utilizando un sobre de comida preparada (para que sea más rápido). No te preocupes si no tienes ni idea de lo que es un *risotto*. En realidad, y gracias al pensamiento computacional, no necesitas saber lo que es para prepararlo, puesto que el pensamiento computacional te permite disponer de una receta. En este caso, los pasos de la receta serían más o menos estos: 1. Abrir el sobre 2. Poner a calentar el agua 3. Esperar a que el agua hierva 4. Si hierve, verter el sobre 5. Remover el contenido de la olla 6. Apagar el fuego y dejar reposar 7. Servir en el plato para \"x\" personas Si sigues esos pasos, seguro que puedes obtener algo comestible aunque no tengas ni idea de qué estás cocinando en realidad, ¿verdad? El pensamiento computacional consiste en enfrentarse a un problema (como \"cocinar un *risotto*\") y obtener una solución (como una \"receta\") que permita solucionarlo todas las veces que sean necesarias. Si la \"receta\" anterior la escribiéramos usando un lenguaje de programación, tendríamos en nuestras manos un programa de ordenador. De hecho, podemos \"escribirla\" en un lenguaje de programación por bloques gráficos, como el popular *Scratch*, y nos quedaría algo así: ![Ejemplo de receta escrita con Scratch](/docs/prog-y-3d/_site/assets/images/01-scratch.jpg) ## 1.3. El pensamiento computacional vs la programación Los términos \"pensamiento computacional\" y \"programación\" no son sinónimos. Esta es una confusión muy habitual. La programación solo es una de las posibles herramientas con la que se pone en práctica el pensamiento computacional. Por eso la programación y el pensamiento computacional comparten los mismos procesos cognitivos. La programación limita sus procesos de resolución de problemas al ámbito de la informática. Para ello, hace uso de diferentes lenguajes de programación. Puedes pedir a un ordenador que haga muchas cosas, pero no que prepare un *risotto*. Así que el pensamiento computacional puede aplicarse a problemas más allá de la informática. > ***Curiosidad**: ¿sabías que las peronas que aprenden a utilizar un lenguaje de programación muestran mayor capacidad de atención y autonomía, y obtienen en promedio mejores resultados en pruebas matemáticas, que las que no saben programar?* [Diversos estudios](https://www.redalyc.org/pdf/547/54741184011.pdf) han demostrado que, mediante los lenguajes de programación, se desarrollan ciertas habilidades cognitivas como: * El pensamiento lógico. * La creatividad. * El razonamiento abstracto. * La capacidad de resolución de problemas. Así que, si quieres orientar tu vida académica hacia las ciencias o la ingeniería, aprender a programar puede ser una herramienta muy útil para ti. Pero incluso si tus preferencias académicas van por otro camino, las rutinas de pensamiento computacional que adquirirás programando te reportarán muchos beneficios que quizá no sospechabas. ## 1.4. Algoritmos y descomposición de problemas Tanto el pensamiento computacional como la programación utilizan procesos cognitivos idénticos, como hemos dicho. Y el principal de ellos se denomina **\"Divide y vencerás\"** (*\"Divide and Conquer\"* en inglés). Es decir: descompón tu problema en problemas más pequeños, hasta que sean lo suficientente pequeños para afrontarlos. Y luego reúnelos todos como un puzle para componer la solución final. Fácil de explicar, difícil de hacer. ![Divide y vencerás](/docs/prog-y-3d/_site/assets/images/01-divide-y-venceras.jpg) El pensamiento computacional busca encontrar una \"receta\" para resolver cualquier problema computable. Esas recetas se denominan **algoritmos**. Un algoritmo, por tanto, es *un conjunto de pasos que, aplicados sistemáticamente a unos datos de entrada apropiados, resuelven un problema en un numero finito de pasos.* Nuestra receta de cocina para el *risotto* era un algoritmo. Las instrucciones para fabricar un avión de papel a partir de un folio también lo son. El motor de búsqueda de Google es otro algoritmo. Obviamente, el grado de complejidad de esos algoritmos no es comparable entre sí. Pero todos son algoritmos. Los algoritmos tienen una **entrada** (input) y una **salida** (output), y entre ambas están los pasos o instrucciones. La entrada de un algoritmo pueden ser los ingredientes para cocinar un *risotto*, y la salida es el plato comestible. Este es un algoritmo computable pero no programable, porque ningún ordenador podría ejecutarlo. La entrada del algoritmo de Google es el texto que escribimos en la caja de búsqueda, y la salida es la lista de resultados. Este es un algoritmo computable y programable (de hecho, la gente de Google lo ha programado, ¿no?) En realidad, los algoritmos recogen operaciones tan sencillas que pueden ser realizadas con éxito por cualquiera. *Incluso por las máquinas*. **La unión de máquinas y algoritmos es lo que está cambiando el mundo**. El matemático británico [Alan Turing](https://es.wikipedia.org/wiki/Alan_Turing), famoso por haber *hackeado* la máquina Enigma de mensajes cifrados de los nazis muchos años antes de que se inventara el término \"*hackear*\", y por haberse suicidado tras sufrir una dura persecución debido a su condición homosexual, fue de los primeros que relacionó algoritmos y ordenadores. De hecho, fue de los primeros que imaginó un ordenador tal y como lo conocemos hoy. Así es: los ordenadores actuales son, en esencia, *Máquinas de Turing* mucho más potentes de lo que Turing pudo soñar. ![Alan Turing](/docs/prog-y-3d/_site/assets/images/01-alan-turing.jpg) **El trabajo de los programadores/as informáticos** consiste en traducir los problemas del mundo a un lenguaje que una máquina pueda entender. Así, **un programa de ordenador** es un algoritmo escrito en un lenguaje de programación. Es decir, un conjunto de miles (¡o millones!) de operaciones sencillas que, como las piezas de un puzle, encajan para dar lugar a la solución final. Los algoritmos se usan para cualquier cosa: predecir resultados electorales, calcular trayectorias de satélites, conocer nuestros gustos y preferencias... El mundo del trabajo se va *algoritmizando* poco a poco: las diferentes tareas se convierten en algoritmos y se automatiza el trabajo. **Las únicas tareas no computables, por el momento, son las relacionadas con la creatividad y las emociones**. ¡Así que ya sabes dónde seguirá existiendo trabajo en las próximas décadas! ## 1.5. Algunos algoritmos famosos en tiempos de internet La palabra algoritmo se ha puesto de moda en los últimos años. Los ordenadores pueden hacer cálculo mucho más deprisa, y con mucha más fiabilidad, que un cerebro humano. Desde la aparición de Internet, se ha producido un salto cualitativo y estamos llegando a computar cosas que antes parecían imposibles. Por eso han surgido disciplinas en plena ebullición como el *big data* o la inteligencia artificial. #### El Algoritmo de Facebook ![Edgerank, el algoritmo de Facebook](/docs/prog-y-3d/_site/assets/images/01-edgerank.jpg) En el *big data*, los algoritmos analizan millones de datos de los clientes. Hay algoritmos ejecutándose en los ordenadores de a bordo de los automóviles, en los satélites de control de tráfico o en las redes sociales. El algoritmo que decide qué ve cada usuario en su muro de Facebook fue uno de los primeros en utilizar *big data*. Es un algoritmo tan famoso que hasta tiene nombre propio: **EdgeRank**. Cada vez que Facebook realiza cambios importantes en *EdgeRank*, se produce un revuelo en Facebook. A principios de 2018, por ejemplo, Facebook decidió dar más importancia a los usuarios particulares que a las empresas, marcas y medios de comunicación, en un intento de que la red social volviera a ser más \"social\" y paliar un poco la invasión de las *fake news*. El cambio dio bastantes quebraderos de cabeza a empresas y medios y, en algunos casos, provocó pérdidas millonarias. #### Algoritmo de Google ![Pagerank, el algoritmo de Google](/docs/prog-y-3d/_site/assets/images/01-pagerank.jpg) Tal vez el algoritmo más famoso del mundo, después del de la multiplicación, sea el de Google. Creado en 1998 y llamado **PageRank**, su éxito revolucionario consistió en que rastreaba la web y daba resultados de búsqueda ordenados por su importancia. ¿Y cómo mide *PageRank* la importancia de cada web? Es un secreto mejor guardado que la fórmula de la Coca-cola. El *PageRank* original medía la importancia de una web por la cantidad de webs que estaban enlazadas a ella. Esa fue la clave de su éxito inicial. En la actualidad, sospecho que ni siquiera los ingenieros de Google están muy seguros de qué cosas mide *PageRank* y en qué medida influyen en sus resultados. Actualmente, *PageRank* es capaz de adaptar sus resultados al usuario (no es lo mismo ser un adulto que un niño, o lanzar una búsqueda desde Almería que hacerlo desde Silicon Valley), ofrecer mapas, imágenes, corregir la ortografía de la búsqueda o entender cuándo en la caja de búsqueda se escribe una pregunta. Y darle respuesta. #### El algoritmo de Amazon ![A9, el algoritmo de Amazon](/docs/prog-y-3d/_site/assets/images/01-amazon.jpg) ¿Despedido por un algoritmo? No es ciencia ficción. De hecho, es algo que ocurre desde hace años. Las máquinas toman decisiones en lugar de los humanos pero que afectan directamente los humanos. Entre 2017 y 2018, más de 300 empleados de Amazon fueron despedidos por falta de productividad en una de sus sedes en Baltimore. Lo llamativo es que detrás esta decisión no hubo una inteligencia humana, sino artificial. Amazon mide individual y automáticamente la productividad de cada trabajador en base al número de paquetes que confeccionan cada hora. El programa, en caso de detectar empleados de baja productividad, genera automáticamente advertencias e incluso procesa automáticamente despidos, sin la intervención de los supervisores. De esta forma, los empleados son supervisados por algoritmos que llegan hasta el punto de conocer el tiempo que emplean fuera de sus tareças. Por ejemplo, si los empleados dejan de escanear paquetes durante demasiado tiempo, el sistema genera automáticamente alertas y el empleado puede ser despedido. Por otro lado, Amazon ha sido acusado en repetidas ocasiones de manipular sus algoritmos de búsqueda de productos dentro de su web, para priorizar los productos que les son más rentables. Cosa que no es de extrañar, por otra parte, ¿no te parece? La cuestión es esta: *un pequeño cambio en un algoritmo puede afectar a una gran parte del comercio electrónico mundial y a miles de fabricantes y vendedores*. ## 1.6. Actividades #### Ejercicio 1 Vamos a escribir nuestro primer algoritmo. Así, sin miedo. Imagina que tienes que explicarle a un extraterrestre recién llegado a la Tierra cómo debe cruzar un semáforo para evitar ser arrollado por los coches. (Si la metáfora del extraterrestre te parece excesiva, imagina que se lo tienes que explicar a un niño o niña muy pequeño) El extraterrestre (o el niño) solo comprende órdenes muy sencillas: camina, no camines, mira la luz, ¿es verde?, ¿es roja?, y cosas así. Tienes que exponer las instrucciones en una lista de pasos o \"receta de cocina\" expresada con acciones sencillas como las anteriores. Venga, a ver qué te sale. (Nota: no te desesperes si no sabes ni cómo empezar. Eso le pasa a todo el mundo la primera vez) #### Ejercicio 2 Ahora lo vamos a complicar un poco más, enfrentándonos a un algoritmo clásico en las ciencias de la computación. Se trata de encontrar el camino más corto entre dos puntos. En nuestro caso, queremos llegar desde A (Salida) hasta F (Meta). Cada camino tiene un peso (el numerito indicado en él). Puedes considerar que ese peso es el tiempo o la distancia, da lo mismo. Constrúyete una tabla con todos los diferentes caminos o recorridos posibles y el valor total de tiempo (o distancia) que acaba sumando cada uno de ellos. ![Grafo de Dijkstra](/docs/prog-y-3d/_site/assets/images/01-grafo.jpg) ¿Cómo se podría construir un algoritmo genérico que encontrase el camino más corto entre dos puntos cualesquiera, en un mapa con cualquier número de puntos y cualquier número de contexiones? Trata de pensarlo unos minutos. Después, cuando notes que la cabeza va a explotarte, bichea un poco por Internet en busca del **algoritmo de Dijkstra**. Brevemente y con tus propias palabras, comenta en qué consiste y trata de aplicarlo al problema anterior. #### Ejercicio 3 Investiga en internet quién fue **Ada Lovelace** y explica en pocas frases qué relación tiene con el mundo de los algoritmos y la programación de ordenadores. #### Ejercicio 4 Investiga en Internet sobre el escándalo de **Cambridge Analytica** y responde con tus palabras (¡y brevemente!) a las siguientes cuestiones: 1. Detalla qué es Cambridge Analytica y a qué se dedicaba. 2. ¿Con qué fin recababa Cambridge Analytica datos y perfiles de usuarios? 3. ¿Cuándo y por qué se produjo un escándalo mundial relacionado directamente con ella? 4. Describe el funcionamiento del algoritmo de Cambridge Analytica y explica como pudo influenciar mediante el mismo en las victorias de Donald Trump en Estados Unidos y del Brexit en Inglaterra? 5. ¿Cuál fue el número de usuarios de Facebook afectados? ¿Cuantos miles de millones de dólaresperdió Facebook tras el escándalo? 6. Busca y encuentra un video corto en youtube donde aparezca Mark Zuckerberg declarando en el congreso de Estados Unidos, dando explicaciones sobre el escándalo de Cambridge Analytica. (No olvides activar los subtítulos si tienes problemas con el inglés). ¿Con qué argumentos se defendió Zuckerberg de las acusaciones? #### Ejercicio 5 Vamos investigar entre todos sobre algunos algoritmos famosos en la historia de la computación: 1. Algoritmo del viajante de comercio. 2. Algoritmo de los filósofos comensales. 3. Algoritmo quicksort 4. Algoritmo mergesort 5. Algoritmo bubblesort o algoritmo de la burbuja 6. Algoritmo auto-tune 7. Algoritmo de la transformada rápida de Fourier 8. Algoritmo OkCupid Date Matching 9. Algoritmo de las ocho reinas 10. Algoritmo de la criba de Eratóstenes 11. Algoritmo MD5 12. Algoritmo SHA1 Una vez que se te asigne uno de estos algoritmos, lo que tienes que investigar es muy sencillo: * ¿Qué problema pretende resolver ese algoritmo? * ¿Cómo lo resuelve? (Expresado en términos sencillos y de andar por casa) ",
    "url": "/docs/prog-y-3d/_site/pensamiento-computacional/",
    "relUrl": "/pensamiento-computacional/"
  },"2": {
    "doc": "2. Representación de la información",
    "title": "2. Representación de la información",
    "content": "# 2. Representación de la información {: .no_toc } El ordenador es una máquina digital, es decir, binaria. Cualquier aprendiz de programador/a debe conocer esa forma de codificación, y otras primas suyas (como la octal y la hexadecimal) antes de aventurarse en los vericuetos de la programación. Dedicaremos todo este tema a hacerlo. - TOC {:toc} ## 2.1. Los códigos Un **código** es un *método de representación de la información*. Se compone de un conjunto de símbolos, llamado **alfabeto**, y de un conjunto de **reglas** para combinar esos símbolos de forma correcta. Estos son algunos ejemplos de códigos que utilizas todos los días o que, al menos, conoces: * **Ejemplo 1**: la lengua castellana es un código. Su alfabeto es el abecedario (a, b, c, d, e ... z), pero los símbolos del alfabeto no se pueden combinar a lo loco, sino que existen unas reglas, y sólo siguiendo esas reglas se codifica correctamente la información, dando lugar a mensajes con sentido. Esas reglas las habéis estudiado en la asignatura de lengua castellana desde la enseñanza primaria. * **Ejemplo 2**: el código morse también es un código. Su alfabeto es muy reducido: sólo el punto (.) y la raya (–), pero combinando los dos símbolos correctamente, se puede transmitir cualquier información. * **Ejemplo 3**: el sistema de numeración decimal es un código. Tiene un alfabeto de 10 símbolos (0, 1, 2, 3, 4, 5, 6, 7, 8 y 9). Combinándolos según ciertas reglas, puede usarse para transmitir información. Pero ojo, no cualquier información, solamente información numérica. Hemos dicho que los códigos sirven para representar información, pero no que tengan que servir para representar toda la información posible. Aunque sólo sirva para los números, el sistema de numeración también es un código. ### 2.1.1. El código binario Pues bien, **el sistema de numeración binario también es un código**. Es muy parecido al sistema de numeración decimal, con la única diferencia de la cantidad de símbolos del alfabeto. Si el decimal tiene diez, el binario sólo tiene dos: el 0 y el 1. En todo lo demás son iguales, así que el sistema binario también sirve para representar información numérica. Pero, ¿puede representarse cualquier número con sólo dos símbolos? La respuesta es sí. El modo de hacerlo consiste en combinar los símbolos 0 y 1 adecuadamente, igual que hacemos con los números decimales. En el sistema decimal contamos así: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9. Cuando queremos pasar a la siguiente cantidad, empezamos a agrupar los dígitos de dos en dos: 10, 11, 12, 13, 14, 15, 16, 17, 18, 19. Al volver a terminar las unidades, vamos incrementando las decenas: 20, 21, 22, etc. (Esto se debe a que, en los sistemas de numeración, cada dígito tiene un valor posicional, es decir, tiene un valor diferente dependiendo del lugar que ocupe en el número general. Por ejemplo, en el número 283, el 3 tiene valor de tres, pero el 8 no tiene valor de ocho, sino de ochenta, y el 2 no tiene valor de dos, sino de doscientos) En binario, el razonamiento es el mismo. Empezamos a contar por 0 y 1, pero entonces ya hemos agotado los símbolos, así que empezamos a agruparlos: 10, 11. Como hemos vuelto a agotarlos, seguimos combinándolos: 100, 101, 110, 111, 1000, 1001, 1010, y así sucesivamente. Así, los 16 primeros números binarios comparados con sus equivalentes decimales son: Decimal|Binario -|- 0|0000 1|0001 2|0010 3|0011 4|0100 5|0101 6|0110 7|0111 8|1000 9|1001 10|1010 11|1011 12|1100 13|1101 14|1110 15|1111 Los números escritos en código binario tienen el mismo valor que en decimal, y sólo cambia la representación. Es decir, “15” en decimal y “1111” en binario representan exactamente a la misma idea: quince. #### Convertir números binarios a decimales Para obtener la representación decimal de un número binario hay que proceder según el Teorema Fundamental de la Normalización, del siguiente modo: 1. Numeramos la posición que ocupa cada dígito binario de derecha a izquierda, empezando por 0. Por ejemplo, en el número binario 1010011, numeraremos las posiciones así: ``` Posiciones --> 6 5 4 3 2 1 0 Dígitos --> 1 0 1 0 0 1 1 ``` 2. Multiplicamos cada dígito binario por 2 elevado a la posición del dígito y sumamos todos los resultados. Con el número del ejemplo anterior: 1 x 26 + 0 x 25 + 1 x 24 + 0 x 23 + 0 x 22 + 1 x 21 + 1 x 20 . 3. Ahora sólo nos quedaría sumar los resultados de todas las multiplicaciones: 64 + 0 + 16 + 0 + 0 + 2 + 1 = 83 . Por lo tanto, el número binario 1010011 es equivalente al número decimal 83. Es habitual indicar con un subíndice el sistema de numeración al que pertenece cada número, así: 10100112 = 8310 . #### Convertir números decimales a binarios El proceso contrario se realiza dividiendo sucesivamente el número decimal entre dos, y cogiendo el último cociente y todos los restos en el orden inverso al que los obtuvimos. Por ejemplo, vamos hallar la representación binaria del número 8310: . Tomando el último cociente (que siempre es 1) y todos los restos desde el último hacia el primero (es decir, 010011, siguiendo la dirección de la flecha), obtenemos el número binario 1010011. Por lo tanto, podemos decir que: 8310 = 10100112 . #### Operaciones aritméticas binarias La operaciones aritméticas binarias se realizan exactamente igual que las decimales, aunque teniendo la precaución de usar sólo los dos símbolos permitidos (0 y 1), lo que puede parecernos un poco extraño al principio. Por ejemplo, para realizar una suma de dos números binarios, escribiremos ambos números uno encima de otro, alineados a la derecha, como hacíamos cuando estábamos aprendiendo a sumar. Luego, iremos sumando los dígitos de derecha a izquierda, como haríamos con dos números decimales, con la precaución de sumar también el acarreo cuando se produzca. Vamos a sumar los números 110012 y 10112: ``` 1 1 1 10 (expresado en binario, 010000012) se le hace corresponder la letra \"A\", al 6610 la \"B\", al 6710 la \"C\", etc. De este modo, el ordenador puede también manejar letras, y lo hace del mismo modo en que maneja números: mediante combinaciones de ceros y unos. La siguiente tabla muestra los 127 primeros caracteres del código ASCII junto con el número al que corresponden en decimal, binario, octal y hexadecimal (estos dos últimos son sistemas de numeración que veremos enseguida): ![Tabla ASCII simplificada](/docs/prog-y-3d/_site/assets/images/02-tabla-ascii.png) (Fuente: Wikimedia Commons - Dominio público) Es importante resaltar que los códigos ASCII siempre tienen 8 dígitos binarios, rellenándose con ceros a la izquierda si fuera necesario. Así ocurre en el caso de la letra A, que, como hemos dicho, se representa con el código 01000001. Si te tomas la molestia de calcular cuántos caracteres diferentes pueden representarse con el código ASCII, verás que son exactamente 256. Suficientes para todos los caracteres habituales, ¿verdad? Aunque, un momento... ¿Y qué hay de los caracteres griegos? ¿O los caracteres cirílicos del ruso? Eso por no hablar del chino y o el japonés. Si queremos dar cabida a cualquier idioma del mundo, el código ASCII se nos queda rápidamente pequeño. Por eso se ideó otra forma de codificación de caracteres que es la que más se usa en la actualidad: Unicode. ### 2.1.3. El código UTF-8 de Unicode El código ASCII no es, desde luego, el único que existe para representar letras en binario, pero sí el más popular por motivos históricos. A finales de la década de 1980, se empezó a desarrollar un proyecto para codificar de forma unívoca todos los caracteres de todas las lenguas del mundo (¡incluidas lenguas muertas!). A ese proyecto se lo denominó **Unicode**. Unicode se ha impuesto con fuerza en la actualidad. Por ejemplo, este documento que estás leyendo ahora mismo está codificado con Unicode, en su versión UTF-8. Y es que Unicode tiene varias implementaciones: * **UTF-8**: los caracteres se codifican en grupos de 8 bits. Algunos solo necesitan 8 bits, pero otros necesitan 16, 24 o incluso 32 bits. Por ejemplo, la \"N\" se codifica con 8 bits (los mismos que en el viejo ASCII), pero la \"Ñ\" se codifica con 16: los 8 correspondientes a la \"N\" más los 8 correspondientes al símbolo \"~\" * **UTF-16**: los caracteres se codifican en grupos de 16 bits. Algunos solo necesitan 16 bits, pero otros necesitan el doble, es decir, 32. * **UTF-32**: los caracteres se codifican en grupos de 32 bits. Eso da un total de 232 caracteres posibles, más que suficientes para codificar todas las lenguas existentes en el mundo. Es la forma de Unicode más simple que existe. La codificación más popular es la **UTF-8 de Unicode**. Aunque es algo más compleja que la UTF-32, los textos codificados de este modo ocupan mucho menos espacio. Los primeros 127 caracteres del UTF-8 se corresponden con el viejo código ASCII. Por eso mismo, y para propósitos prácticos, las tablas clásicas de código ASCII siguen siendo vigentes, al menos hasta el carácter número 127. ### 2.1.4. El código hexadecimal Es importante conocer y saber manejar el código binario al ser el método de codificación que emplean los ordenadores digitales, pero este código tiene dos serios inconvenientes: 1. **Resulta difícil de manipular para nuestros cerebros**, que destán habituados a pensar en decimal (o habituados a no pensar en absoluto, que también se da el caso). 2. **Los números binarios pueden llegar a tener cantidades enormes de dígitos**. Es habitual trabajar con números de 16, 32 o 64 dígitos binarios, lo cual los convierte en inmanejables. Por este motivo, suelen usarse, en programación, otros dos sistemas de numeración llamados **octal** y **hexadecimal**. * El **sistema octal** maneja 8 símbolos distintos: 0, 1, 2, 3, 4, 5, 6 y 7. * El **sistema hexadecimal**, por su parte, tiene 16 símbolos: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E y F. Sin duda, el más utilizado de los dos es el hexadecimal y por este motivo nos vamos a detener en él, aunque haciendo notar que el octal funciona de la misma manera. En hexadecimal, por tanto, es normal ver números cuyos dígitos son letras del alfabeto. Por ejemplo: 2AF5 es un número válido escrito en hexadecimal (exactamente, 10997 en decimal). La forma de contar, por supuesto, es la misma: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, y después empezamos a agrupar los símbolos: 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 1A, 1B, 1C, 1D, 1E, 1F. Seguiríamos con 20, 21, 22, etc. Podemos construir una tabla para comparar los primeros números en los tres sistemas de numeración que conocemos. Hemos rellenado los primeros números binarios con ceros a la izquierda por razones que pronto se verán, pero en realidad los números no cambian (recuerda que un cero a la izquierda no tiene ningún valor, ni en binario ni en el resto de sistemas) Decimal|Binario|Hexadecimal -|-|- 0|0000|0 1|0001|1 2|0010|2 3|0011|3 4|0100|4 5|0101|5 6|0110|6 7|0111|7 8|1000|8 9|1001|9 10|1010|A 11|1011|B 12|1100|C 13|1101|D 14|1110|E 15|1111|F Si te fijas, cada dígito hexadecimal se corresponde exactamente con una combinación de 4 dígitos binarios. Así, por ejemplo, el número binario 1001 1101 se puede escribir más resumidamente como 9D en hexadecimal (porque 10012 equivale a 916 y 11012 equivale a D16). Y **esa es la gran utilidad del sistema hexadecimal**: permite manipular números binarios de forma más escueta y resumida, de manera que nos sean más fáciles de manejar a nosotros, los humanos, que somos muy propensos a cometer errores. #### Convertir números hexadecimales a decimales El mecanismo es el mismo que ya utilizamos para convertir números binarios, sólo que cambiando la base del sistema de numeración de 2 a 16, ya que ahora vamos a manejar números hexadecimales. Por lo tanto, los pasos a seguir son: 1. Numeramos las posiciones que ocupa cada dígito hexadecimal de derecha a izquierda, empezando por 0. Por ejemplo, en el número hexadecimal 2AF, numeraremos las posiciones así: ``` Posiciones --> 2 1 0 2 A F ``` 2. Multiplicamos cada dígito hexadecimal por 16 elevado a la posición del dígito y sumamos todos los resultados. Con el número 2AF lo haríamos así: 2 x 162 + A x 161 + F x 160 . Según la tabla de anterior, tenemos que el dígito hexadecimal A equivale a 10 en decimal, y que F equivale a 15. Por lo tanto la operación quedaría así: 2 x 162 + 10 x 161 + 15 x 160 . Ahora sólo nos falta resolver la operaciones y sumar: 2 x 256 + 10 x 16 + 15 x 1 = 687 . Por lo tanto, el número hexadecimal 2AF es equivalente al número decimal 687. Indicándolo con subíndices, lo expresaríamos así: 2AF16 = 68710 . #### Convertir números decimales a hexadecimales El proceso también es idéntico al realizado con números binarios, pero sustituyendo la división entre 2 por divisiones entre 16, que es la base del sistema hexadecimal. #### Relación entre números hexadecimales y binarios La verdadera utilidad del sistema hexadecimal es que **se puede utilizar en lugar del binario**, siendo más fácil de manejar. Para que ello sea posible, el paso de hexadecimal a binario y viceversa debe poder hacerse con mucha rapidez. Para convertir un número hexadecimal a binario, basta con **sustituir cada dígito hexadecimal por sus cuatro cifras binarias** correspondientes, según la tabla de correspondencias que hemos visto más arriba. Por ejemplo: 2AF16 = 0010 1010 11112 . Del mismo modo, para convertir un número binario a hexadecimal, lo agruparemos en bloques de 4 cifras binarias (empezando por la derecha) y buscaremos la correspondencia en la tabla. Por ejemplo, el número binario 100100 se convierte así: 0010 01002 = 2416 . Observa que hemos rellenado con ceros a la izquierda para obtener bloques de 4 dígitos binarios sin alterar la esencia del número. Por supuesto, no es obligatorio usar este truco de rellenar con ceros a la izquierda, pero las primeras veces puede facilitar las cosas. Con un poco de práctica conseguirás convertir binarios a hexadecimales y viceversa de un sólo vistazo y sin necesidad de consultar la tabla. ## 2.2. Unidades de medida de información Como hemos visto, el código binario es el fundamento del funcionamiento de los ordenadores: toda la información que el ordenador maneja, ya sea numérica o alfanumérica, se encuentra codificada en binario. Del mismo modo que para medir distancias se utiliza el metro, o para medir masas se utiliza el gramo, **para medir la cantidad de información almacenada o procesada en un ordenador existe una unidad de medida**. Como el ordenador representa toda la información en binario, **la unidad fudamental de medida de la cantidad de información es el dígito binario** (es decir, 0 ó 1), también llamado **BIT** (de BInary digiT) Un bit es realmente muy poca cantidad de información. Recuerda que, por ejemplo, para almacenar un sólo carácter en código ASCII son necesarios 7 u 8 bits. ¡Para un único carácter! Del mismo modo que el metro dispone de **múltiplos** (el decámetro, el hectómetro, el kilómetro, etc), también los tiene el bit, y son los siguientes: * **Bit**: Unidad fundamental de medida de la cantidad de información. * **Byte**: 1 byte equivale a 8 bits (un carácter). Esto no siempre ha sido así, pero, en la actualidad, se acepta la cifra de 8 como estándar. Cuidado con el nombre, porque se parecen y es un error común confundir el bit con el byte. * **Kibibyte (KiB)**: 1 kilobyte son 1024 bytes. Fïjate que es parecido al kilómetro (1000 metros), pero no exactamente igual. * **Mebibyte (MiB)**: 1 megabyte equivale a 1024 kilobytes. * **Gibibyte (GiB)**: 1 gigabyte equivale a 1024 megabytes. * **Tebibyte (TiB)**: 1 terabyte equivale a 1024 gigabytes * **Pebibyte (PiB)**: 1 pebibyte equivale a 1024 tebibytes. * **Exbibyte (EiB)**: 1 exbibyte equivale a 1024 pebibytes. Podemos resumir las unidades de medida de información en la siguiente tabla: ``` 1 Byte = 8 bits 1 KiB = 1024 Bytes 1 MiB = 1024 KiB 1 GiB = 1024 MiB 1 TiB = 1024 GiB 1 PiB = 1024 TiB 1 EiB = 1024 PiB ``` Existe otra colección de múltiplos del Byte que se incrementan en potencias de 10, como sucede con los múltiplos de otras magnitudes físicas (tales como el kilómetro, el kilogramo, etc). Se introdujeron hace unos años para acabar con la confusión que provocaba el hecho de que algunos fabricantes consideraban que 1 KB eran 1024 Bytes, mientras que otros decían que eran 1000 Bytes. Estas otras unidades son: * **Kilobyte (KB)**: 1 kilobyte son 1000 bytes. * **Megabyte (MB)**: 1 megabyte equivale a 1000 kilobytes. * **Gigabyte (GB)**: 1 gigabyte equivale a 1000 megabytes. * **Terabyte (TB)**: 1 terabyte equivale a 1000 gigabytes * **Petabyte (PB)**: 1 petabyte equivale a 1000 terabytes. * **Exabyte (EB)**: 1 exabyte equivale a 1000 petabytes. Podemos resumir las unidades de medida de información en la siguiente tabla: ``` 1 Byte = 8 bits 1 KB = 1000 Bytes 1 MB = 1000 KB 1 GB = 1000 MB 1 TB = 1000 GB 1 PB = 1000 TB 1 EB = 1000 EB ``` **Las unidades decimales son más pequeñas que las correspondientes binarias**. Es decir, 1 GB, por ejemplo, son menos Bytes que 1 GiB. La diferencia es tanto mayor cuanto más grande es la unidad. Por ejemplo, 1 KB es un 2,35% más pequeño que 1 KiB, pero 1 EB es un 13,3% más pequeño que 1 EiB. ¡Entre 1 EB y 1 EiB hay 150 millones de GB de diferencia! Por lo tanto, no es de extrañar que las compañías de telefonía o los fabricantes de dispositivos de almacenamiento publiciten sus capacidades en las unidades más pequeñas posible, para que lo que te ofertan parezca más de lo que es. Por último, hacemos notar que, en ocasiones, también se usan los mismos múltiplos para el bit, no para el Byte. Así, puedes encontrarte con megabits (Mb) o mebibits (Mib), que son, respectivamente, un millón (1.000.000) de bits y 220 bits (1.048.576). O con gigabits (Gb) o gigibits (Gib). La conversión entre los múltiplos del bit los del Byte se realiza multiplicando o dividiendo entre 8, como es lógico. Observa como **se usa la \"b\" minúscula para distinguir los bits de los Bytes**. ",
    "url": "/docs/prog-y-3d/_site/representacion-de-la-informacion/",
    "relUrl": "/representacion-de-la-informacion/"
  },"3": {
    "doc": "3. Introducción a la programación",
    "title": "3. Introducción a la programación",
    "content": "# 3. Introducción a la programación {: .no_toc } - TOC {:toc} ## 3.1. ¿Qué es exactamente eso de \"programar un ordenador\"? **Programar un ordenador** no es más que proporcionarle a la máquina un conjunto de instrucciones y datos para que realice una tarea. Esa tarea, generalmente, resuelve un problema concreto, que puede ir desde realizar complicados cálculos matemáticos hasta entretenernos con un videojuego en nuestros ratos de ocio. El conjunto de las instrucciones que conforma el programa se denomina **código fuente**, y tiene que estar escrito en un lenguaje comprensible por la máquina, es decir, un **lenguaje de programación**. Esas instrucciones se traducen a **código binario** (que, recuerda, es lo único que puede comprender el ordenador). La CPU de un ordenador está construida de manera que puede entender y ejecutar ciertas instrucciones binarias, gracias a lo cual nuestro programa acaba ejecutándose en las entrañas de la máquina. Este es un fragmento de un programa informático real escrito en lenguaje PHP. Implementa un algoritmo de ordenación de elementos llamado *Bubble Sort* o, en español, *método de la burbuja*. No es necesario, ni mucho menos, que lo entiendas de momento. Solo quiero que le eches un vistazo para que veas el aspecto que tiene un programa real (o un fragmento) escrito en un lenguaje real. ```php function bubble_Sort($my_array ) { do { $swapped = false; for( $i = 0, $c = count( $my_array ) - 1; $i $my_array[$i + 1] ) { list( $my_array[$i + 1], $my_array[$i] ) = array( $my_array[$i], $my_array[$i + 1] ); $swapped = true; } } } while( $swapped ); return $my_array; } $test_array = array(3, 0, 2, 5, -1, 4, 1); echo \"Original Array :\"; echo implode(', ',$test_array ); echo \"Sorted Array:\"; echo implode(', ',bubble_Sort($test_array)). PHP_EOL; ``` (Fuente: php.net) ### 3.1.2. Programas y algoritmos Para realizar un programa es necesario idear previamente un algoritmo. Esto es importante hasta el extremo de que, sin algoritmo, no existiría el programa. Un algoritmo, como hemos visto, es una **secuencia ordenada de acciones que conducen a la solución de un problema en un número finito de pasos simples**. Por ejemplo, vamos a escribir un algoritmo para determinar si un número entero cualquiera (que llamaremos N) es par o impar: ``` - Inicio del algoritmo - Paso 1. Preguntar qué número concreto es N. - Paso 2. Si N es divisible entre 2, entonces la solución es \"PAR\". - Paso 3. Si N no es divisible entre 2, entonces la solución es \"IMPAR\". - Paso 4. Imprimir la solución. - Fin del algoritmo ``` Recuerda que este algoritmo está **escrito para que lo ejecute un ordenador**, no para que lo ejecute una persona. Por eso el Paso 1 es \"Preguntar qué número es N\": porque el ordenador tendrá que preguntarnos a nosotros, los humanos, el número. Y por eso el Paso 4 es \"Imprimir la solución\": porque el ordenador nos ofrecerá el resultado imprimiéndolo en la pantalla o en un papel. Este algoritmo resuelve el problema planteado en un número finito de pasos simples. Lógicamente, al ordenador no le podemos dar estas instrucciones tal y como las hemos escrito, sino que habrá que expresarlo en un lenguaje de programación, pero esto es algo que trataremos más adelante. ### 3.1.3. Datos y tipos de datos Los algoritmos, como hemos dicho, son colecciones de instrucciones que resuelven un problema. Pero esas instrucciones **siempre trabajan con datos**, es decir, con información formalizada para su uso en un ordenador: * **Los datos de entrada** son datos que el algoritmo necesita para trabajar. En el ejemplo anterior, el número \"N\" es un dato de entrada. * **Los datos de salida** son datos que el algoritmo produce como resultado de sus cálculos. En el ejemplo anterior, \"solución\" es un dato de salida. Los datos siempre pertenecen a un **tipo de datos**, que es el rango de valores que ese dato puede tomar. Existen multitud de tipos de datos posibles, pero empezaremos trabajando solo con estos: * **Enteros**. Los datos de este tipo solo pueden tomar como valores números enteros (positivos o negativos). Ejemplos: 3, 28, -15, 0, 4982... * **Reales**. Números con decimales. Ejemplos: 18.25, -3.198887 * **Caracteres**. Letras, números, signos de puntuación... Ojo, si un dato es de tipo \"carácter\", solo puede contener en cada momento un único carácter. Ejemplos: 'a', 'Z', '&', '?' * **Cadenas de caracteres**. O, simplemente, *cadenas*. Son colecciones de letras, números, signos de puntuación... Es decir, palabras y cualquier cosa que se le parezca. Ejemplos: \"Hoy es lunes\", \"sgcv08 e98 ie7f83 ?so9&/\". Suelen distinguirse de los caracteres individuales por la doble comilla, aunque esto depende del lenguaje de programación. * **Lógicos o booleanos**. Estos datos solo pueden tener dos valores: *verdadero* o *falso*. ### 3.1.4. Variables y constantes Las **variables** de un algoritmo son como las variables en una ecuación matemática: representaciones de un dato a las que asignamos un nombre o identificador. En el algoritmo para averiguar si un número es par o impar, *N* es una variable y *solución* es otra variable. Las variables pueden tomar un valor perteneciente a un tipo de datos. Ese valor puede cambiar a lo largo del algoritmo (por eso se denominan *variables*). Lo que no puede cambiar es el tipo de datos al que pertenecen. Es decir: si una variable es entera, no puede cambiar y pasar a ser real durante la ejecución del programa. (Bueno, hay lenguajes que sí permiten hacer esto, pero esa es otra historia). Por eso, la mayoría de los lenguajes de programación exigen que les indiquemos a qué tipo de datos pertenece cada variable antes de usarlas por primera vez. Es algo que también haremos en pseudocódigo. Eso se denomina **declarar una variable**. Así pues, podemos mejorar el algoritmo anterior con la declaración de las variables \"N\" y \"solución\": ``` - Inicio del algoritmo - Declaración de variables: - N es un número entero. - solución es una cadena de caracteres. - Paso 1. Averiguar qué número es N. - Paso 2. Si N es divisible entre 2, entonces la solución es \"PAR\". - Paso 3. Si N no es divisible entre 2, entonces la solución es \"IMPAR\". - Paso 4. Imprimir la solución. - Fin del algoritmo ``` Las **constantes** se parecen a las variables: tienen un nombre y un tipo, y se les asigna un valor. La única diferencia es que una constante *no puede cambiar de valor durante la ejecución del algoritmo* y una variable sí. ### 3.1.5. Subalgoritmos Cuando un algoritmo es muy complejo, lo dividimos en trozos más simples que denominamos **subalgoritmos**. En programación, esos subalgoritmos se denominan **procedimientos** o **funciones**. Son casi la misma cosa, con una sutil diferencia que ya veremos cuando llegue el momento. Los lenguajes de programación reales, además de las instrucciones básicas que enseguida vamos a ver, tienen unas colecciones de funciones predefinidas llamadas **bibliotecas**. Esas funciones se encargan de realizar tareas habituales y repetitivas, de modo que nos ahorran un montón de trabajo. Por ejemplo, es posible escribir algoritmos para hacer cálculos matemáticos complejos, tales como logaritmos o raíces cuadradas. Para evitarnos ese trabajo, todos los lenguajes de programación disponen de una biblioteca de funciones matemáticas que incluye, entre otras muchas cosas, el cálculo de logaritmos y de raíces cuadradas para cuando los necesitemos. Así que vamos a suponer, cuando escribamos pseudocódigo, que también tenemos a nuestra disposición de esas bibliotecas de funciones. Algunos subalgoritmos o funciones que existen en todos los lenguajes de programación y que podemos considerar que también existen en pseudocódigo son las siguientes: * abs(x). Calcula el valor absoluto de x. Funciona con números reales y con enteros. * sen(x). Calcula el seno de x. Devuelve valores reales. * cos(x). Calcula el coseno de x. Devuelve valores reales. * exp(x). Calcula ex. Devuelve un real. * ln(x). Calcula el logaritmo neperiano de x. Devuelve un valor real. * redon(x). Redondea el número x al valor entero más próximo. El valor x será real, y la función devolverá un entero. * trunc(x). Trunca el número x, es decir, le elimina la parte decimal. El valor x será real, y la función devolverá un entero. * rc(x). Calcula la raíz cuadrada de x. Devuelve un valor real * azar(x). Genera un número al azar entre 0 y x. Supondremos que solo funciona con números enteros. ### 3.1.6. Expresiones y operadores Una **expresión** es una combinación de constantes, variables, operadores y funciones. Por ejemplo, esto es una expresión: rc((5 + x) / 2) . En esta expresión, aparecen dos constantes literales (5 y 2), una variable (x), dos operadores aritméticos (+ y /) y una función (rc, para calcular la raíz cuadrada), además de los paréntesis, que sirven para manipular la prioridad de las operaciones. Lógicamente, para resolver la expresión, es decir, para evaluar su resultado, debemos conocer cuál es el valor de la variable x. Si suponemos que la variable x tiene el valor 7, el resultado de la expresión será 2,449. La forma más habitual de encontrar una expresión es combinada con una **sentencia de asignación a una variable**. Por ejemplo: y En estos casos, la expresión (lo que hay a la derecha del signo \" (mayor que), = (igual que), != (distinto de), (mayor o igual que). El resultado de estas comparaciones siempre es un valor lógico, es decir, verdadero o falso. * **Operadoresl lógicos**: se utilizan para comparar otros datos lógicos y relacionarlos entre sí. Los más habituales son Y, O y NO. Estas palabras tienen el mismo significado que en la lengua natural. Observa, por ejemplo, este fragmento de pseudocódigo muy fácil de entender: ``` puntos_carnet = edad = Si edad >= 18 y puntos_carnet > 0 Entonces escribir \"Puedes conducir\" FinSi Si edad | Instrucción | Significado | . | Algoritmo nombre | Marca el comienzo de un algoritmo y le adjudica un nombre | . | FinAlgoritmo | Marca el final del algoritmo | . | Definir variable Como tipo | Declara una variable y le asigna un tipo. Los tipos válidos son Entero, Real, Carácter, Lógico y Cadena. | . | Leer variable | Entrada de datos. El programa lee un dato desde un dispositivo de entrada (si no se indica otra cosa, el teclado), asignando ese dato a la variable. | . | Escribir expresión | Salida de datos. La expresión se calcula y su resultado se muestra en la pantalla. | . | variable | Asignación. Se evalúa la expresión y el resultado se guarda en la variable. | . | Si condición Entonces &nbsp;&nbsp;&nbsp;&nbsp;acciones-1 SiNo &nbsp;&nbsp;&nbsp;&nbsp;acciones-2 FinSi | Estructura condicional. Se evalúa la condición. Si es verdadera, se ejecutan las \"acciones-1\". Si es falsa, se ejecutan las \"acciones-2\". | . | Segun expresión hacer &nbsp;&nbsp;&nbsp;&nbsp;valor-1: acciones-1; &nbsp;&nbsp;&nbsp;&nbsp;valor-2: acciones-2; &nbsp;&nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;&nbsp;&nbsp;valor-n: acciones-N; &nbsp;&nbsp;&nbsp;&nbsp;De otro modo: acciones-por-defecto; FinSegun | Condicional múltiple. Si la expresión se evaúa como\"valor-1\", se ejecutan las acciones-1. Si vale \"valor-2\", se ejecutan las acciones-2, y así sucesivamente. Si la expresión no coincide con ningún valor, se ejecutan las acciones-por-defecto. | . | Mientras condición &nbsp;&nbsp;&nbsp;&nbsp;acciones FinMientras | Bucle con condición al princio. Se realizan las acciones repetidamente mientras la condición siga siendo verdadera. | . | Repetir &nbsp;&nbsp;&nbsp;&nbsp;acciones Hasta Que condición | Bucle con condición al final. Se realizan las acciones repetidamente mientras la condición siga siendo verdadera. Observa que el cuerpo de este bucle se ejecuta al menos una vez, mientras que el del bucle anterior podría no ejecutarse nunca (si la condición es falsa desde el principio). | . | Para variable valor_inicial Hasta valor_final Hacer &nbsp;&nbsp;&nbsp;&nbsp;acciones FinPara | Bucle con iterador. Se asigna el valor_inicial a la variable. El bucle se repite hasta que la variable llega al valor_final. En cada iteración, la variable se incrementa en una unidad (se puede indicar otro incremento, pero, de momento, nos quedamos con ese). | . También existen instrucciones para crear y manejar subalgoritmos. Como nuestros programas, de momento, van a ser muy simples, aún no vamos a verlas. Nos dedicaremos a ellas cuando llegue el momento. ### 3.2.3. Un ejemplo sencillo de algoritmo escrito en pseudocódigo Vamos a terminar esta sección mostrando un ejemplo sencillo pero muy completo de algoritmo escrito en pseudocódigo. Se trata de escribir un algoritmo tal que, dados dos números enteros (que llamaremos A y B), nos dirá cuáles son los números enteros que existen entre A y B ordenados de menor a mayor. Lo primero que el algoritmo tendrá que hacer será pedirnos los valores de A y B. Después, tendrá que averiguar cuál de los dos es el menor (A o B), para poder luego meterse en un bucle que vaya desde el número menor hasta el número mayor, pasando por todos los valores intermedios e imprimiéndolos. Las instrucciones de ese algoritmo serían estas: ``` Algoritmo contar_numeros Escribir \"Dime un número\" Leer A Escribir \"Dime otro número\" Leer B Si A | Símbolo | Equivalencia en pseudocódigo | Significado | . | | Algoritmo nombre | Marca el comienzo de un algoritmo y le adjudica un nombre | . | | FinAlgoritmo | Marca el final del algoritmo | . | | Definir variable Como tipo | Declara una variable y le asigna un tipo. | . | | Leer variable | Entrada de datos. | . | | Escribir expresión | Salida de datos. | . | | variable | Asignación. | . | | Si condición Entonces &nbsp;&nbsp;&nbsp;&nbsp;acciones-1 SiNo &nbsp;&nbsp;&nbsp;&nbsp;acciones-2 FinSi | Estructura condicional. | . | | Segun expresion hacer &nbsp;&nbsp;&nbsp;&nbsp;valor-1: acciones-1; &nbsp;&nbsp;&nbsp;&nbsp;valor-2: acciones-2; &nbsp;&nbsp;&nbsp;&nbsp;... &nbsp;&nbsp;&nbsp;&nbsp;valor-n: acciones-N; &nbsp;&nbsp;&nbsp;&nbsp;De otro modo: acciones-por-defecto; FinSegun | Condicional múltiple. | . | | Mientras Condición &nbsp;&nbsp;&nbsp;&nbsp;acciones FinMientras | Bucle con condición al princio. | . | | Repetir &nbsp;&nbsp;&nbsp;&nbsp;acciones Hasta Que Condición | Bucle con condición al final. | . | | Para variable valor_inicial Hasta valor_final Hacer &nbsp;&nbsp;&nbsp;&nbsp;acciones FinPara | Bucle con iterador. | . Recuerda que también existen símbolos para definir y utilizar **subalgoritmos**, destinados a dividir el algoritmo en trozos cuando resolvemos problemas complejos. Por ahora, nuestros problemas serán simples y no usaremos subalgoritmos. Cuando llegue el momento, explicaremos cómo se utilizan. Para terminar, te muestro el algoritmo para contar números enteros entre dos números cualesquiera, A y B, escrito como un diagrama de flujo. No dejes de comparar esta solución con la que planteamos en pseudocódigo un poco más arriba. Ambas son exactamente iguales, pero están descritas con una herramienta diferente. Es como si hubiéramos escrito la misma frase en dos idiomas distintos. ![Diagrama de flujo contar-numeros](/docs/prog-y-3d/_site/assets/images/03-contar-numeros.png) ## 3.4. Errores frecuentes entre principiantes En esta sección recopilo para ti algunas de las dudas, errores y pifias más frecuentes que, según mi experiencia como profesor de programación, suelen asaltar a los principantes. #### No es lo mismo 20 que \"20\" Así es. Cuando estás programando, no es lo mismo la instrucción ```Escribir 20``` (o cualquier otro número) que la instrucción ```Escribir \"20\"```, con el número entre comillas. Las cadenas de caracteres siempre se ponen entre comillas. Los números NO. Por eso, ```Escribir 20``` significa literalmente *mostrar en pantalla el número 20*, mientras que ```Escribir \"20\"``` significa *mostrar en pantalla la cadena de caracteres \"20\"*. Puede parecer lo mismo, pero no lo es. En una, 20 es un texto y, en otra, un número, y para el ordenador son cosas muy distintas (por ejemplo, no puedes sumar dos textos, pero sí dos números). #### Escribir \"a\" no es lo mismo que Escribir a Un caso particular de la confusión anterior, y muy frecuente cuando se empieza a programar, es confundir ```Escribir \"a\"``` (o cualquier otro carácter) con ```Escribir a```. La primera instrucción pide al ordenador que escriba un texto (en este ejemplo, una letra \"a\"). La segunda instrucción pide al ordenador que escriba *el contenido* de una variable. Es decir, en ```Escribir a```, la a debe ser una variable preexistente. Y, como todas las variables, debe tener un valor. La instrucción ```Escribir a``` pide al ordenador que escriba ese valor, no una letra \"a\". #### ¡Me hago un lío entre Escribir y Leer! A menudo me he encontrado con que las personas que se inician en la programación de ordenadores confunden *escribir* y *leer*: ¡no tienen claro cuándo utilizar una y cuándo la otra! Esta confusión se debe a un problema de punto de vista. El programador/a novato piensa los algoritmos *desde su punto de vista*, es decir, como si fuera él o ella quien debe ejecutar el algoritmo. La solución pasa por cambiar el punto de vista. **El algoritmo lo ejecutará un ordenador**, no nosotros. Los algoritmos son colecciones de órdenes para el ordenador, no para nosotros. Podemos pensar en el ordenador como en un esclavo obediente que hará todo lo que le pidamos (siempre que se lo pidamos en un lenguaje que pueda entender). Así, cuando le pedimos que ejecute una instrucción *escribir 'Hola'*, no somos nosotros los que vamos a escribir \"Hola\", sino que será la máquina la que lo hará. Y lo escribirá en su pantalla, que es la manera estandarizada en la que un ordenador escribe cosas. Y cuando le pidamos que ejecute *leer n*, será el ordenador el que leerá el valor de la variable n. ¿Y cómo se las apaña un ordenador para leer cosas? A través de un dispositivo de entrada. Es decir, a través del teclado. La instrucción *leer n* hará que el programa se detenga hasta que tecleemos algo, y ese algo se almacenará en la variable n. #### Errores lógicos: confundir Y con O Este también es un problema frecuente, incluso entre programadores experimentados. Recuerda que los operadores lógicos Y y O tienen exactamente el mismo significado que en español. A partir de ahí, solo te queda utilizar el sentido común. Si, aún así, te enfrentas con una expresión que no acabas de comprender, trata de descomponerla en expresiones más simples para asimilar mejor la lógica del problema. #### Confundir condición con iteración Otro error recurrente entre principiantes consiste en confundir la estructura condicional con la iterativa. En concreto, confudir *Si... Entonces* con *Mientras... Hacer*. Creo que se debe a que ambas instrucciones comparten la misma estructura: tienen una condición al principio y ejecutan una serie de acciones o no en función de esa condición. Pero hay una diferencia fundamental: las acciones de un *Si... Entonces* solo se ejecutarán **una o ninguna vez**, y luego el programa continuará. Las acciones de un *Mientras... Hacer* se ejecutarán **cero, una o muchas veces**, dependiendo de la condición. Por lo tanto, para saber si debes usar una u otra, pregúntate esto: \"¿tiene sentido que estas acciones se ejecuten muchas veces o, como máximo, se ejecutarán una vez?\". Si la respuesta es \"muchas veces\", necesitas un *Mientras... Hacer*. Si la respuesta es \"una vez\", necesitas un *Si... Entonces*. Pongamos un ejemplo. Imagina que estás escribiendo un programa que pida un número y determine si es negativo. Puedes tener la tentación de escribir esto: ``` leer N Mientras N ¡¡¡CUIDADO, ESTO ES UN ERROR!!! escribir \"El número es negativo\" FinMientras ``` Si haces eso, habrás provocado involuntariamente un bucle infinito, ya que, cuando el programa entre en el bucle, no logrará salir jamás de él porque la condición siempre será verdadera. Para no caer en este error, trata de responder a la pregunta que planteábamos antes. La única accion que hay dentro de este bucle es *Escribir \"El número es negativo\"*, así que debes preguntarte: \"¿mi programa tiene que escribir *El número es negativo* muchas veces, o solo una (en caso de que el número, en efecto, sea negativo)?\" La respuesta, obviamente, es que basta con una. Así que la solución correcta a este problema es: ``` leer N Si N 3​ del agua. Se mostrará el precio total. Supondremos que la piscina es de forma regular. **Ejercicio 4**. Determinar si un número leído del teclado es positivo, negativo o cero. **Ejercicio 5**. Calcular la raíz cuadrada de un número introducido por teclado. Hay que tener la precaución de comprobar que el número sea positivo. #### Ejercicios con estructuras condicionales **Ejercicio 6**. Leídos dos números por teclado, A y B, calcular la resta del mayor menos el menor. Por ejemplo, si A = 8 y B = 3, el resultado debe ser A – B, es decir, 5. Pero si A = 4 y B = 7, el resultado debe ser B – A, es decir, 3. **Ejercicio 7**. Averiguar si un número real introducido por teclado tiene o no parte fraccionaria (utilícese la función trunc() que aparece descrita en los apuntes) **Ejercicio 8**. Leer un número real y un tipo de moneda, que puede ser \"euro\" o \"peseta\". Convertir la cantidad al tipo de moneda indicado, suponiendo que está expresada en la otra. Por ejemplo, si la cantidad es 15 y la moneda es \"peseta\", se supondrá que se trata de 15 € y que hay que convertirlos a pesetas y, por lo tanto, el resultado debe ser 2495. **Ejercicio 9**. Leer tres números por teclado, X, Y y Z, y decidir si están ordenados de menor a mayor. **Ejercicio 10**. Como el anterior, pero para averiguar si los números son consecutivos. **Ejercicio 11**. Determinar si un año es bisiesto o no (los años bisiestos son múltiplos de 4; utilícese el operador módulo) **Ejercicio 12**. Determinar el número de cifras de un número entero. El algoritmo debe funcionar para números de hasta 5 cifras, considerando los negativos. Por ejemplo, si se introduce el número 5342, la respuesta del programa debe ser 4. Si se introduce –250, la respuesta debe ser 3. **Ejercicio 13**. Calcular las dos soluciones de una ecuación de segundo grado, del tipo ax2 + bx + c = 0. Los coeficientes a, b y c deberá introducirlos el usuario a través del teclado. #### Ejercicios con estructuras condicionales e iterativas **Ejercicio 14**. Escribir todos los números entre 1 y n, siendo n un entero introducido por teclado. **Ejercicio 15**. Escribir todos los números pares entre 1 y n. **Ejercicio 16**. Escribir todos los números impares entre dos números a y b introducidos por teclado. Antes habrá que comprobar cuál de los dos números (a o b) es mayor. **Ejercicio 17**. Calcular la suma de todos los números pares entre 1 y n, siendo n un entero introducido por teclado. Es decir, hay que calcular 2 + 4 + 6 + ... hasta n (o n-1, si n es un número impar). **Ejercicio 18**. Realiza un programa que calcule la suma de los n primeros números, donde n es un número introducido por teclado. Al terminar, el programa nos mostrará el mensaje \"¿Desea terminar? (S/N)\". Si el usuario escribe \"S\", el programa terminará, pero, si escribe \"N\", volverá a comenzar. **Ejercicio 19**. Calcular la nota media de un alumno a partir de las notas de todos sus exámenes a lo largo del curso. El programa nos irá pidiendo notas, pero no sabemos cuántas son. Para terminar de introducir valores, el usuario debe teclear un número negativo. Entonces, el programa calculará el promedio de todas las notas introducidas. **Ejercicio 20**. El usuario de este programa será un profesor, que introducirá las notas de sus 30 alumnos de una en una. El algoritmo debe decirle cuántos suspensos y cuántos aprobados hay. **Ejercicio 21**. Calcular el valor máximo de una serie de 10 números introducidos por teclado. **Ejercicio 22**. Generalizar el ejercicio anterior para que también se averigüe el valor mínimo y el medio. **Ejercicio 23**. Calcular el factorial de un número entero N. Recuerda que el factorial de un número es el producto de ese número por todos los enteros menores que él. Por ejemplo, el factorial de 5 (simbolizado 5!) se calcula como: 5! = 5 x 4 x 3 x 2 x 1. **Ejercicio 24**. Generar combinaciones al azar para la lotería primitiva (6 números entre 1 y 49). Debes utilizar la función azar(x) que vimos en los apuntes. Por ahora, no te preocupes porque los números puedan repetirse. **Ejercicio 25**. Generar combinaciones al azar para la quiniela (14 valores dentro del conjunto 1, X o 2) #### Ejercicios más avanzados **Ejercicio 26**. Determinar si un número N introducido por teclado es o no primo. Recuerda que un número primo es aquél que sólo es divisible por sí mismo y por la unidad. **Ejercicio 27**. Generalizar el algoritmo anterior para averiguar todos los números primos que existen entre 2 y N, siendo N un número introducido por teclado. **Ejercicio 28**. Introducida una hora por teclado (horas, minutos y segundos), se pretende sumar un segundo a ese tiempo e imprimir en la pantalla la hora que resulta (también en forma de horas, minutos y segundos). **Ejercicio 29**. La calculadora. Diseñar un algoritmo que lea dos números, A y B, y un operador (mediante una variable de tipo carácter), y calcule el resultado de operar A y B con esa operación. Por ejemplo, si A = 5 y B = 2, y operación = \"+\", el resultado debe ser 7. El algoritmo debe seguir pidiendo números y operaciones indefinidamente, hasta que el usuario decida terminar (utilizar un valor centinela para ello) **Ejercicio 30**. Juego del número secreto. El ordenador elegirá un número al azar entre 1 y 100. El usuario irá introduciendo números por teclado, y el ordenador le irá dando pistas: \"mi número es mayor\" o \"mi número es menor\", hasta que el usuario acierte. Entonces el ordenador le felicitará y le comunicará el número de intentos que necesitó para acertar el número secreto. **Ejercicio 31**. Mínimo común múltiplo. El programa nos pedirá dos números y calculará el mínimo común múltiplo de ambos. *Atención: este ejercicio es de dificultad elevada*. **Ejercicio 32**. Máximo común divisor. Como el anterior, pero calculando el máximo común divisor. *Atención: este ejercicio es de dificultad elevada*. ",
    "url": "/docs/prog-y-3d/_site/introduccion-a-la-programacion/",
    "relUrl": "/introduccion-a-la-programacion/"
  },"4": {
    "doc": "4. Estructuras de datos",
    "title": "4. Estructuras de datos",
    "content": "# 4. Estructuras de datos {: .no_toc } - TOC {:toc} Estructuras de datos. Funciones y bibliotecas de funciones. Reutilización de código. Facilidades para la entrada y salida de datos de usuario. Manipulación de archivos. ",
    "url": "/docs/prog-y-3d/_site/estructuras-de-datos/",
    "relUrl": "/estructuras-de-datos/"
  },"5": {
    "doc": "5. Orientación a objetos",
    "title": "5. Orientación a objetos",
    "content": "# 5. Orientación a objetos {: .no_toc } - TOC {:toc} Orientación a objetos. Clases, objetos y constructores. Herencia. Subclases y superclases. Polimorfismo y sobrecarga. Encapsulamiento y ocultación. ",
    "url": "/docs/prog-y-3d/_site/orientacion-a-objetos/",
    "relUrl": "/orientacion-a-objetos/"
  },"6": {
    "doc": "6. Entornos integrados de desarrollo",
    "title": "6. Entornos integrados de desarrollo",
    "content": "# 6. Entornos integrados de desarrollo {: .no_toc } - TOC {:toc} Entornos integrados de desarrollo. Depuración. Ciclo de vida del software. Trabajo en equipo y mejora continua. Control de versiones. Metodologías ágiles: Scrum. ",
    "url": "/docs/prog-y-3d/_site/entornos-integrados-de-desarrollo/",
    "relUrl": "/entornos-integrados-de-desarrollo/"
  },"7": {
    "doc": "7. Lenguaje PHP",
    "title": "7. Lenguaje PHP",
    "content": "# 7. Lenguaje PHP {: .no_toc } ATENCIÓN: este capítulo aún está en fase de redacción y su contenido es provisional. ¡No lo leas todavía! . - TOC {:toc} Tipos de lenguajes según su nivel de abstracción y su modo de traducción. Historia de los lenguajes de programación. El lenguaje PHP El ordenador, como es sabido, solo puede manejar ceros y unos, es decir, código o lenguaje binario. Los seres humanos, por el contrario, utilizamos un lenguaje mucho más complejo, con montones de símbolos y reglas sintácticas y semánticas, que denominaremos lenguaje natural. Entre estos dos extremos (lenguaje binario y lenguaje natural) se encuentran los lenguajes de programación. Tienen cierto parecido con el lenguaje natural, pero son mucho más reducidos y estrictos en su sintaxis y semántica, para acercarse a las limitaciones del lenguaje binario. Hay lenguajes de programación muy próximos al lenguaje binario: a éstos los llamamos lenguajes de bajo nivel de abstracción. Y los hay más próximos al lenguaje natural: son los lenguajes de alto nivel de abstracción. Lenguajes de bajo nivel Son los lenguajes más cercanos a la máquina. Los programas directamente escritos en código binario se dice que están en lenguaje máquina que, por lo tanto, es el lenguaje de más bajo nivel que existe. Las instrucciones del lenguaje máquina realizan tareas muy sencillas, como, por ejemplo, sumar dos números, detectar qué tecla se ha pulsado en el teclado o escribir algo en la pantalla del ordenador. Cuando se combinan adecuadamente muchas de estas instrucciones sencillas se obtiene un programa de ordenador que puede realizar tareas muy complejas. A pesar de la simplicidad de las instrucciones del lenguaje máquina, la forma de escribirlas es muy complicada, ya que hay que hacerlo en binario. En los primeros años de la informática los ordenadores se programaban directamente en lenguaje máquina, lo cual convertía la tarea de programar en una verdadera pesadilla. Por ejemplo, una instrucción para sumar dos números en lenguaje máquina puede tener este aspecto: 110100100101110010100010001001111010010110110 Cuando los ordenadores fueron haciéndose más potentes, pronto se vio que con el lenguaje máquina no se podrían crear programas que aprovechasen esa potencia por la sencilla razón de que era demasiado difícil programar así: no se podía hacer nada demasiado complicado porque el cerebro humano no está “diseñado” para pensar en binario. Surgió entonces la idea de utilizar el propio ordenador como traductor: ¿por qué no escribir una instrucción como la anterior, que suma dos números, de una forma más parecida al lenguaje humano y que luego un pequeño programa de ordenador se encargue de traducir esa instrucción a su correspondiente ristra de ceros y unos? Así apareció el lenguaje ensamblador, cuyas instrucciones son equivalentes a las del lenguaje máquina, pero se escriben con palabras similares a las del lenguaje humano. Por ejemplo, para sumar dos números, la instrucción en ensamblador puede ser algo como: ADD D1, D2 Los lenguajes de bajo nivel se caracterizan por ser dependientes del hardware de la máquina. Es decir: un programa escrito en lenguaje máquina o en ensamblador para un procesador con arquitectura x86 no funcionará, por ejemplo, en un smartphone con arquitectura ARM, a menos que sea modificado sustancialmente. Incluso puede tener serios problemas para funcionar en máquinas de la misma familia pero con el resto del hardware diferente, o con un sistema operativo distinto. Lenguajes de alto nivel Siguiendo el razonamiento anterior (utilizar el propio ordenador como traductor), en los años sesenta se empezaron a desarrollar lenguajes cada vez más complejos, en los que cada instrucción ya no se correspondía exactamente con una instrucción del lenguaje máquina, sino con varias. Estos son los lenguajes de alto nivel o, simplemente, L.A.N. (no confundir con \"red de área local\") Lógicamente, la traducción desde un lenguaje de alto nivel a lenguaje máquina es mucho más compleja que desde lenguaje ensamblador, por lo que los traductores se han hecho cada vez más complicados. Una característica muy importante de los lenguajes de alto nivel es que son independientes del hardware, lo que implica que los programas desarrollados con estos lenguajes pueden ser ejecutados en ordenadores con hardware totalmente distinto. A esto se le llama portabilidad. Los programas encargados de traducir el código de alto nivel a código máquina se llaman compiladores e intérpretes. Son programas muy complejos que generan el código binario equivalente al código de alto nivel para una máquina concreta. Por lo tanto, el programa de alto nivel, que es portable de un hardware a otro, debe ser traducido a código máquina en cada tipo de máquina en la que se pretenda ejecutar. Los ejemplos de lenguajes de alto nivel son innumerables, y la lista incluye casi todos de los que has oído hablar alguna vez: Basic, Cobol, Fortran, Ada, C, PHP, Python, Java, Perl, etc. Comparación entre los lenguajes de alto y bajo nivel LENGUAJES DE BAJO NIVEL LENGUAJES DE ALTO NIVEL Ventajas Inconvenientes Son comprensibles directamente por la máquina (aunque el ensamblador necesita una pequeña traducción) Necesitan ser traducidos por medio de complicados programas (compiladores e intérpretes) Los programas se ejecutan muy rápidamente (si están bien escritos, claro) La traducción automática del código de alto nivel al código máquina siempre genera programas menos eficientes que si se escribieran directamente en binario Ocupan menos espacio en memoria Ocupan más espacio en memoria Permiten controlar directamente el hardware, por lo que son apropiados para la programación de sistemas En general, solo pueden acceder al hardware utilizando al sistema operativo como intermediario. Pero, entonces, ¿cómo programar el sistema operativo, que necesita controlar directamente el hardware? Inconvenientes Ventajas Son completamente dependientes del hardware. Un programa escrito para determinado tipo de máquina no funcionará en un ordenador con diferente arquitectura. Son portables, es decir, independientes del hardware. Un programa escrito en una máquina puede funcionar en otra con hardware distinto, siempre que se vuelva a traducir a binario en la máquina nueva. Incluso los programas más sencillos son largos y farragosos Los programas son más sencillos, ya que una sola instrucción puede equivaler a varias instrucciones binarias. Los programas son difíciles de escribir, depurar y mantener Los programas son más fáciles de escribir, depurar y mantener Es imposible resolver problemas muy complejos Es posible, aunque difícil, enfrentarse a problemas muy complejos Enfrentando las ventajas e inconvenientes de unos y otros, se concluye que, en general, es preferible usar lenguajes de alto nivel para el desarrollo de aplicaciones, reservando los de bajo nivel para casos muy concretos en los que la velocidad de ejecución o el control del hardware sean vitales. Por ejemplo, los sistemas operativos más conocidos, como Windows, MacOS o Linux, están programados casi en su totalidad con lenguajes de alto nivel (generalmente C o C++), reservando un pequeño porcentaje del código a rutinas en ensamblador. También hay que destacar que no todos los lenguajes de alto nivel son iguales. Los hay de \"más alto nivel\" que otros. C tiene sin duda menor nivel de abstracción que, por ejemplo, Visual Basic; pero, por eso mismo, los programas en C son más rápidos y eficientes que los escritos en Visual Basic, aunque también pueden llegar a ser más difíciles de escribir y depurar. Categorías dentro de los lenguajes de alto nivel Para terminar con esta vista preliminar sobre el mundo de los lenguajes de programación, mencionaremos que los lenguajes de alto nivel se suelen subdividir en categorías tales como: • Lenguajes de tercera generación (o imperativos), en los que el programador escribe una secuencia de instrucciones que el ordenador debe ejecutar en un orden preestablecido. Son los lenguajes que nosotros vamos a manejar. Todos los lenguajes \"clásicos\" pertenecen a esta categoría: C, Basic, Cobol, Fortran, etc. • Lenguajes de cuarta generación (o 4GL), dirigidos a facilitar la creación de interfaces con el usuario y con otras aplicaciones, como las bases de datos. Un ejemplo de estos lenguajes es SQL. • Lenguajes orientados a objetos, que son una evolucuión de los lenguajes de tercera generación y que permiten construir con mayor facilidad y robustez programas modulares complejos. Ejemplos de lenguajes orientados a objetos son C++, Java, Python, PHP o Ruby. Algunos de ellos son multiparadigma, es decir, permiten programar con orientación a objetos pero también permiten hacer programación estructurada clásica, sin objetos. • Lenguajes declarativos y funcionales, propios de la inteligencia artificial, como Prolog o Lisp. • Otos tipos más específicos: lenguajes concurrentes, paralelos, distribuidos, etc. En general, podemos decir que un programador acostumbrado a trabajar con un lenguaje de tercera generación puede aprender con poco esfuerzo cualquier otro lenguaje de tercera generación, y, con algo más de trabajo, un lenguaje orientado a objetos. Sin embargo, el \"salto\" a otros tipos de lenguajes, como los declarativos, cuesta más porque la raíz misma de estos lenguajes es diferente. 1.2 Ensambladores, compiladores e intérpretes Cuando programamos en un lenguaje distinto del lenguaje máquina, nuestro código debe ser traducido a binario para que el ordenador pueda entenderlo y ejecutarlo. Existe un programa específico encargado de hacer esa traducción y que, dependiendo del lenguaje en el que hayamos escrito nuestro programa, puede ser un ensamblador, un compilador o un intérprete. Ensambladores Se llaman ensambladores los programas encargados de traducir los programas escritos en ensamblador a código binario. Fíjate que tanto el programa traductor como el lenguaje se llaman del mismo modo: ensamblador. Como el lenguaje ensamblador es muy próximo al binario, estos traductores son programas relativamente sencillos. Compiladores El compilador es un programa que traduce el código de alto nivel a código binario. Es, por tanto, parecido al ensamblador, pero mucho más complejo, ya que las diferencias entre los lenguajes de alto nivel y el código binario son muy grandes. El programa escrito en lenguaje de alto nivel se denomina programa fuente o código fuente. El programa traducido a código binario se llama programa objeto o código objeto. Por lo tanto, el compilador se encarga de convertir el programa fuente en un programa objeto. Una vez que se ha obtenido el programa objeto ya no es necesario volver a realizar la traducción (o compilación), a menos que se haga alguna modificación en el programa fuente, en cuyo caso habría que volver a compilarlo. El programa objeto, una vez generado, puede ejecutarse en la máquina en la que fue compilado, o en otra de similares características (procesador, sistema operativo, etc.). Cuando se usa programación modular, puede ser necesario un proceso previo de enlace de los diferentes módulos, pero de esto ya hablaremos más adelante. Intérpretes El intérprete es un programa que traduce el código de alto nivel a código binario pero, a diferencia del compilador, lo hace en tiempo de ejecución. Es decir, no se hace un proceso previo de traducción de todo el programa fuente a binario, sino que se va traduciendo y ejecutando instrucción por instrucción. Compiladores frente a intérpretes El intérprete es notablemente más lento que el compilador, ya que realiza la traducción al mismo tiempo que la ejecución. Además, esa traducción se lleva a cabo siempre que se ejecuta el programa, mientras que el compilador sólo la hace una vez. Por estos motivos, un mismo programa interpretado y compilado se ejecuta mucho más despacio en el primer caso. La ventaja de los intérpretes es que hacen que los programas sean más portables. Así, un programa compilado en una máquina PC bajo Windows no funcionará en un Macintosh, o en un PC bajo Linux, a menos que se vuelva a compilar el programa fuente en el nuevo sistema. En cambio, un programa interpretado funcionará en todas las plataformas, siempre que dispongamos del intérprete en cada una de ellas. JavaScript es un ejemplo de lenguaje interpretado. Esto permite que los programas JavaScript (llamados comúnmente scripts) puedan funcionar en cualquier máquina que disponga de un navegador de Internet capaz de interpretarlos. En cambio, C/C++ es un lenguaje compilado, lo que hace que los programas desarrollados con estos lenguajes se ejecuten más rápido que sus equivalentes en JavaScript, aunque obliga a volver a compilarlos si se desea ejecutarlos en una máquina con diferente hardware o diferente sistema operativo. Por último, hay ciertos lenguajes que pueden ejecutarse de forma interpretada o de forma compilada. No es el caso de C. El lenguaje C está orientado a obtener la velocidad de ejecución más alta posible, y por eso siempre se compila. Pero ya es hora de empezar a hablar del lenguaje C, ¿no es así? Vamos a ello. ### 3.1.3. Tipos de lenguaje En los comienzos de la programación informática, se utilizaban lenguajes máquina muy básicos y limitados como el sistema binario (uso de los números 0 y 1 en distintas combinaciones); más tarde comenzaron a surgir lenguajes que hacían uso de códigos de palabras, y luego, conjuntos de algoritmos mucho más complejos que se denominaron lenguajes de alto nivel. Los lenguajes de programación más conocidos y usados: ◦ Java ◦ C, C++ y C# ◦ Scratch ◦ HTML / XML ◦ Python ◦ Visual Basic .NET ◦ PHP ◦ Java ◦ JavaScript XXX añadir gráfica con estadísitca de uso de lenguajes en GitHub Cada uno de estos lenguajes tiene un grado de complejidad diferente y, por lo tanto, algunos serán más fáciles de aprender que otros. Como aprender a programar desde cero es una tarea compleja, en esta unidad comenzaremos acercarnos a la programación por bloques. Este tipo de programación permite una presentación visual del paradigma y metodología de la programación informática permitiendo centrarse en la lógica de la programación dejando a un lado la sintaxis propia de los lenguajes de programación (puntos y comas, paréntesis, etc). Universidades líderes en tecnología como Berkeley o el MIT, enseñan este tipo de programación por bloques en sus primeros cursos. ",
    "url": "/docs/prog-y-3d/_site/lenguaje-php/",
    "relUrl": "/lenguaje-php/"
  },"8": {
    "doc": "8. Bases de datos",
    "title": "8. Bases de datos",
    "content": "# 8. Bases de datos {: .no_toc } - TOC {:toc} Almacenamiento de la información. Ficheros. Bases de datos relacionales. Sistemas gestores de bases de datos. Diseño conceptual. Diagramas entidad-relación. Normalización hasta 3FN y FNBC. Definición y manipulación. ",
    "url": "/docs/prog-y-3d/_site/bases-de-datos/",
    "relUrl": "/bases-de-datos/"
  },"9": {
    "doc": "9. El lenguaje SQL",
    "title": "9. El lenguaje SQL",
    "content": "# 9. El lenguaje SQL {: .no_toc } - TOC {:toc} Comandos básicos de SQL: DDL, DML y DCL. ",
    "url": "/docs/prog-y-3d/_site/lenguaje-sql/",
    "relUrl": "/lenguaje-sql/"
  },"10": {
    "doc": "10. Seguridad y privacidad",
    "title": "10. Seguridad y privacidad",
    "content": "# 10. Seguridad y privacidad {: .no_toc } - TOC {:toc} Seguridad y privacidad. Acceso a la información de las bases de datos. ",
    "url": "/docs/prog-y-3d/_site/seguridad-y-privacidad/",
    "relUrl": "/seguridad-y-privacidad/"
  },"11": {
    "doc": "11. Tecnologías de impresión 3D",
    "title": "11. Tecnologías de impresión 3D",
    "content": "# 11. Tecnologías de impresión 3D {: .no_toc } - TOC {:toc} Tecnologías de impresión 3D. Utilidad y posibilidades del diseño 3D. Impresión 3D por FDM. Impresoras 3D por FDM. Partes, funcionamiento y mantenimiento básico. ",
    "url": "/docs/prog-y-3d/_site/tecnologias-de-impresion-3d/",
    "relUrl": "/tecnologias-de-impresion-3d/"
  },"12": {
    "doc": "12. Modelado e impresión 3D",
    "title": "12. Modelado e impresión 3D",
    "content": "# 12. Modelado e impresión 3D {: .no_toc } - TOC {:toc} Modelado e impresión 3D. Software para diseño 3D y software para slicing (laminado). Creación e impresión de figuras básicas. Transformación, rotación y unión de figuras básicas. Formatos para impresión 3D. Pruebas de impresión. ",
    "url": "/docs/prog-y-3d/_site/modelado-e-impresion-3d/",
    "relUrl": "/modelado-e-impresion-3d/"
  },"13": {
    "doc": "About",
    "title": "About",
    "content": "Estos apuntes han sido elaborados por Antonio Zapata Sierra y Alfredo Moreno Vozmediano, del Departamento de Informática del IES Celia Viñas de Almería, y se publican aquí con licencia [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/), lo que quiere decir que eres libre de usar este material, copiarlo, distribuirlo y modificarlo siempre que el resultado de todo eso mantenga la misma licencia y cites la autoría original. Algunos fragmentos (pocos) están tomados y adaptados de otras fuentes. Cuando eso ocurre, lo indicamos claramente en el texto. Debes atenerte a la licencia de los sitios web de origen para esos fragmentos. ",
    "url": "/docs/prog-y-3d/_site/about/",
    "relUrl": "/about/"
  },"14": {
    "doc": "Introd. a la prog. y al diseño 3D",
    "title": "Introd. a la prog. y al diseño 3D",
    "content": "Esta es la documentación (apuntes) de ***Introducción a la programación y al diseño 3D***, optativa de 2º de Bachillerato ofertada por el IES Celia Viñas de Almería (España). 1. TOC {:toc} ",
    "url": "/docs/prog-y-3d/_site/",
    "relUrl": "/"
  }
}
