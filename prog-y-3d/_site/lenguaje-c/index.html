<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <title>9. El lenguaje C - PROG Y 3D</title> <link rel="shortcut icon" href="/docs/prog-y-3d/_site/favicon.ico" type="image/x-icon"> <link rel="stylesheet" href="/docs/prog-y-3d/_site/assets/css/just-the-docs-default.css"> <script type="text/javascript" src="/docs/prog-y-3d/_site/assets/js/vendor/lunr.min.js"></script> <script type="text/javascript" src="/docs/prog-y-3d/_site/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>El lenguaje C | PROG Y 3D</title> <meta name="generator" content="Jekyll v4.2.2" /> <meta property="og:title" content="El lenguaje C" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Apuntes de la asignatura “Introducción a la programación y al diseño 3D”, optativa de 2º curso de bachillerato ofertada por el IES Celia Viñas de Almería (España)" /> <meta property="og:description" content="Apuntes de la asignatura “Introducción a la programación y al diseño 3D”, optativa de 2º curso de bachillerato ofertada por el IES Celia Viñas de Almería (España)" /> <link rel="canonical" href="https://iescelia.org//docs/prog-y-3d/_site/lenguaje-c/" /> <meta property="og:url" content="https://iescelia.org//docs/prog-y-3d/_site/lenguaje-c/" /> <meta property="og:site_name" content="PROG Y 3D" /> <meta property="og:type" content="website" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="El lenguaje C" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","description":"Apuntes de la asignatura “Introducción a la programación y al diseño 3D”, optativa de 2º curso de bachillerato ofertada por el IES Celia Viñas de Almería (España)","headline":"El lenguaje C","url":"https://iescelia.org//docs/prog-y-3d/_site/lenguaje-c/"}</script> <!-- End Jekyll SEO tag --> </head> <body> <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header"> <a href="https://iescelia.org//docs/prog-y-3d/_site/" class="site-title lh-tight"> PROG Y 3D </a> <a href="#" id="menu-button" class="site-button"> <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg> </a> </div> <nav role="navigation" aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item active"><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="https://iescelia.org//docs/prog-y-3d/_site/" class="nav-list-link">Introd. a la prog. y al diseño 3D</a><ul class="nav-list "><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="https://iescelia.org//docs/prog-y-3d/_site/presentacion/" class="nav-list-link">0. Presentación de la asignatura</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="https://iescelia.org//docs/prog-y-3d/_site/bases-de-datos/" class="nav-list-link">1. Bases de datos</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="https://iescelia.org//docs/prog-y-3d/_site/lenguaje-sql/" class="nav-list-link">2. El lenguaje SQL</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="https://iescelia.org//docs/prog-y-3d/_site/tecnologias-de-impresion-3d/" class="nav-list-link">3. Tecnologías de impresión 3D</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="https://iescelia.org//docs/prog-y-3d/_site/modelado-e-impresion-3d/" class="nav-list-link">4. Modelado e impresión 3D</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="https://iescelia.org//docs/prog-y-3d/_site/pensamiento-computacional/" class="nav-list-link">5. Pensamiento computacional</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="https://iescelia.org//docs/prog-y-3d/_site/representacion-de-la-informacion/" class="nav-list-link">6. Representación de la información</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="https://iescelia.org//docs/prog-y-3d/_site/introduccion-a-la-programacion/" class="nav-list-link">7. Introducción a la programación</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="https://iescelia.org//docs/prog-y-3d/_site/estructuras-de-datos/" class="nav-list-link">8. Estructuras de datos. Subalgoritmos</a><ul class="nav-list"></ul></li><li class="nav-list-item active"><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="https://iescelia.org//docs/prog-y-3d/_site/lenguaje-c/" class="nav-list-link active">9. El lenguaje C</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="https://iescelia.org//docs/prog-y-3d/_site/orientacion-a-objetos-c++/" class="nav-list-link">10. Orientación a objetos con C++</a><ul class="nav-list"></ul></li></ul></li><li class="nav-list-item"><a href="https://iescelia.org//docs/prog-y-3d/_site/about/" class="nav-list-link">About</a></li></ul> </nav> <footer class="site-footer"> This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll. </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search PROG Y 3D" aria-label="Search PROG Y 3D" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> </div> <div id="main-content-wrap" class="main-content-wrap"> <nav aria-label="Breadcrumb" class="breadcrumb-nav"> <ol class="breadcrumb-nav-list"> <li class="breadcrumb-nav-list-item"><a href="https://iescelia.org//docs/prog-y-3d/_site/">Introd. a la prog. y al diseño 3D</a></li> <li class="breadcrumb-nav-list-item"><span>9. El lenguaje C</span></li> </ol> </nav> <div id="main-content" class="main-content" role="main"> <h1 class="no_toc" id="9-el-lenguaje-c"> <a href="#9-el-lenguaje-c" class="anchor-heading" aria-labelledby="9-el-lenguaje-c"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9. El lenguaje C </h1> <ul id="markdown-toc"> <li><a href="#91-orientándose-en-la-jungla-de-los-lenguajes-de-programación" id="markdown-toc-91-orientándose-en-la-jungla-de-los-lenguajes-de-programación">9.1. Orientándose en la jungla de los lenguajes de programación</a> <ul> <li><a href="#911-tipos-de-lenguaje-según-el-nivel-de-abstracción-alto-y-bajo-nivel" id="markdown-toc-911-tipos-de-lenguaje-según-el-nivel-de-abstracción-alto-y-bajo-nivel">9.1.1. Tipos de lenguaje según el nivel de abstracción: alto y bajo nivel</a></li> <li><a href="#912-tipos-de-lenguaje-según-su-generación" id="markdown-toc-912-tipos-de-lenguaje-según-su-generación">9.1.2. Tipos de lenguaje según su generación</a></li> <li><a href="#913-tipos-de-lenguaje-según-su-forma-de-traducción" id="markdown-toc-913-tipos-de-lenguaje-según-su-forma-de-traducción">9.1.3. Tipos de lenguaje según su forma de traducción</a></li> <li><a href="#914-tipos-de-lenguaje-según-su-tipado" id="markdown-toc-914-tipos-de-lenguaje-según-su-tipado">9.1.4. Tipos de lenguaje según su tipado</a></li> <li><a href="#915-el-top-ten-de-los-lenguajes-de-programación" id="markdown-toc-915-el-top-ten-de-los-lenguajes-de-programación">9.1.5. El <em>top ten</em> de los lenguajes de programación</a></li> </ul> </li> <li><a href="#92-bienvenidos-a-c" id="markdown-toc-92-bienvenidos-a-c">9.2. ¡Bienvenidos a C!</a> <ul> <li><a href="#921--características-básicas-de-c" id="markdown-toc-921--características-básicas-de-c">9.2.1. Características básicas de C</a></li> <li><a href="#922-breve-historia-de-c" id="markdown-toc-922-breve-historia-de-c">9.2.2. Breve historia de C</a></li> <li><a href="#923-sintaxis-básica-de-c" id="markdown-toc-923-sintaxis-básica-de-c">9.2.3. Sintaxis básica de C</a></li> <li><a href="#924-conversiones-de-tipo" id="markdown-toc-924-conversiones-de-tipo">9.2.4. Conversiones de tipo</a></li> <li><a href="#925-asignación" id="markdown-toc-925-asignación">9.2.5. Asignación</a></li> <li><a href="#926-operadores-y-expresiones" id="markdown-toc-926-operadores-y-expresiones">9.2.6. Operadores y expresiones</a></li> <li><a href="#927-estructuras-de-control" id="markdown-toc-927-estructuras-de-control">9.2.7. Estructuras de control</a></li> <li><a href="#928-algoritmo-principal-y-subalgoritmos" id="markdown-toc-928-algoritmo-principal-y-subalgoritmos">9.2.8. Algoritmo principal y Subalgoritmos</a></li> <li><a href="#929-entrada-y-salida-en-c" id="markdown-toc-929-entrada-y-salida-en-c">9.2.9. Entrada y salida en C</a></li> <li><a href="#9210-cadenas-de-caracteres" id="markdown-toc-9210-cadenas-de-caracteres">9.2.10. Cadenas de caracteres</a></li> <li><a href="#9211-arrays" id="markdown-toc-9211-arrays">9.2.11. Arrays</a></li> <li><a href="#9212-funciones-de-la-librería-estándar" id="markdown-toc-9212-funciones-de-la-librería-estándar">9.2.12. Funciones de la librería estándar</a></li> <li><a href="#9213-librerías-no-estándar-que-molan-ncurses" id="markdown-toc-9213-librerías-no-estándar-que-molan-ncurses">9.2.13. Librerías no estándar que molan: ncurses</a></li> <li><a href="#9214-librerías-no-estándar-que-molan-sdl" id="markdown-toc-9214-librerías-no-estándar-que-molan-sdl">9.2.14. Librerías no estándar que molan: SDL</a></li> </ul> </li> <li><a href="#93-escribiendo-programas-en-c" id="markdown-toc-93-escribiendo-programas-en-c">9.3. Escribiendo programas en C</a> <ul> <li><a href="#931-estructura-de-un-programa-en-c" id="markdown-toc-931-estructura-de-un-programa-en-c">9.3.1. Estructura de un programa en C</a></li> <li><a href="#932-caja-de-herramientas" id="markdown-toc-932-caja-de-herramientas">9.3.2. Caja de herramientas</a></li> <li><a href="#933-flujo-de-trabajo" id="markdown-toc-933-flujo-de-trabajo">9.3.3. Flujo de trabajo</a></li> <li><a href="#934-dónde-y-cómo-escribir-el-código-fuente" id="markdown-toc-934-dónde-y-cómo-escribir-el-código-fuente">9.3.4. Dónde y cómo escribir el código fuente</a></li> </ul> </li> <li><a href="#94-c-avanzado-punteros-y-estructuras-de-datos" id="markdown-toc-94-c-avanzado-punteros-y-estructuras-de-datos">9.4. C avanzado: punteros y estructuras de datos</a></li> <li><a href="#95-un-ejemplo-completo-las-tres-en-raya" id="markdown-toc-95-un-ejemplo-completo-las-tres-en-raya">9.5. Un ejemplo completo: las tres en raya</a> <ul> <li><a href="#951-el-código-fuente" id="markdown-toc-951-el-código-fuente">9.5.1. El código fuente</a></li> <li><a href="#952-cómo-ejecutar-y-depurar-este-programa" id="markdown-toc-952-cómo-ejecutar-y-depurar-este-programa">9.5.2. ¿Cómo ejecutar y depurar este programa?</a></li> </ul> </li> <li><a href="#96-ejercicios-propuestos" id="markdown-toc-96-ejercicios-propuestos">9.6. Ejercicios propuestos</a></li> <li><a href="#97-ejercicios-resueltos" id="markdown-toc-97-ejercicios-resueltos">9.7. Ejercicios resueltos</a></li> </ul> <p>El ordenador, como ya sabrás a estas alturas, solo puede manejar ceros y unos, es decir, código o <strong>lenguaje binario</strong>. Los seres humanos, por el contrario, utilizamos un lenguaje mucho más complejo, con montones de símbolos y reglas sintácticas y semánticas, que denominamos <strong>lenguaje natural</strong> (aunque de “natural” tiene poco).</p> <p>Entre estos dos extremos (lenguaje binario y lenguaje natural) se encuentran los <strong>lenguajes de programación</strong>. Tienen cierto parecido con el lenguaje natural, pero son mucho más reducidos y estrictos en su sintaxis y semántica, para acercarse a las limitaciones del lenguaje binario.</p> <p>En este capítulo vamos a aprender a escribir algoritmos con un lenguaje llamado <strong>C</strong> y, más adelante, con una variante de C llamada <strong>C++</strong>. Se trata, en realidad, de dos lenguajes de programación distintos, si bien C++ es un superconjunto de C, es decir, todo el lenguaje C está incluido en C++ y, además, tiene algunas cosas adicionales.</p> <p>Se trata de dos lenguajes muy veteranos pero que siguen gozando de una gran popularidad en el mundo profesional de la programación, sobre todo de la programación de sistemas u otros programas que requieran gran velocidad de procesamiento, como los motores de videojuegos.</p> <p>Lenguajes de programación hay muchos, así que también hablaremos de otros lenguajes y conoceremos los tipos y características de algunos de ellos.</p> <h2 id="91-orientándose-en-la-jungla-de-los-lenguajes-de-programación"> <a href="#91-orientándose-en-la-jungla-de-los-lenguajes-de-programación" class="anchor-heading" aria-labelledby="91-orientándose-en-la-jungla-de-los-lenguajes-de-programación"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.1. Orientándose en la jungla de los lenguajes de programación </h2> <p>Los lenguajes de programación constituyen un ecosistema muy extenso y en constante evolución. Para orientarse un poco en esa jungla, nada mejor que clasificar los lenguajes igual que los biólogos clasifican a las criaturas vivas.</p> <h3 id="911-tipos-de-lenguaje-según-el-nivel-de-abstracción-alto-y-bajo-nivel"> <a href="#911-tipos-de-lenguaje-según-el-nivel-de-abstracción-alto-y-bajo-nivel" class="anchor-heading" aria-labelledby="911-tipos-de-lenguaje-según-el-nivel-de-abstracción-alto-y-bajo-nivel"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.1.1. Tipos de lenguaje según el nivel de abstracción: alto y bajo nivel </h3> <p>Hay lenguajes de programación muy próximos al lenguaje binario: a éstos los llamamos <strong>lenguajes de bajo nivel</strong> de abstracción. Y los hay más próximos al lenguaje natural: son los <strong>lenguajes de alto nivel</strong> de abstracción.</p> <h4 id="lenguajes-de-bajo-nivel"> <a href="#lenguajes-de-bajo-nivel" class="anchor-heading" aria-labelledby="lenguajes-de-bajo-nivel"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Lenguajes de bajo nivel </h4> <p>Son los lenguajes más cercanos a la máquina. Los programas directamente escritos en código binario se dice que están en <strong>lenguaje máquina</strong> que, por lo tanto, es el lenguaje de más bajo nivel que existe.</p> <p>Las instrucciones del lenguaje máquina realizan tareas muy sencillas, como, por ejemplo, sumar dos números, detectar qué tecla se ha pulsado en el teclado o escribir algo en la pantalla del ordenador. Cuando se combinan adecuadamente muchas de estas instrucciones sencillas se obtiene un programa de ordenador que puede realizar tareas muy complejas.</p> <p>Por ejemplo, este puede ser el aspecto de una instrucción en lenguaje máquina para sumar dos números:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0001 000100000101 110100110101
</code></pre></div></div> <p>Incomprensible, ¿verdad?</p> <p>A pesar de la simplicidad de las instrucciones del lenguaje máquina, la forma de escribirlas es muy complicada, ya que hay que hacerlo en binario. En los primeros años de la informática los ordenadores se programaban directamente en lenguaje máquina, lo cual convertía la tarea de programar en una verdadera pesadilla. Hoy en día nadie lo hace.</p> <p>Cuando los ordenadores fueron haciéndose más potentes, surgió la idea de utilizar el propio ordenador como <strong>traductor</strong>: ¿por qué no escribir instrucciones en un lenguaje más parecido al natural y que un programa de ordenador se encargue de traducir esa instrucción a su correspondiente instrucción en lenguaje máquina?</p> <p>Así apareció el <strong>lenguaje ensamblador</strong>, cuyas instrucciones son equivalentes a las del lenguaje máquina, pero se escriben con palabras similares a las del lenguaje humano. Por ejemplo, para sumar dos números, la instrucción en ensamblador puede tener un aspecto como este:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ADD D1 D2
</code></pre></div></div> <h4 id="lenguajes-de-alto-nivel"> <a href="#lenguajes-de-alto-nivel" class="anchor-heading" aria-labelledby="lenguajes-de-alto-nivel"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Lenguajes de alto nivel </h4> <p>Siguiendo el razonamiento anterior (utilizar el propio ordenador como traductor), en la década de 1960 y, sobre todo, de 1970, se empezaron a desarrollar lenguajes cada vez más complejos, en los que cada instrucción ya no se correspondía exactamente con una instrucción del lenguaje máquina, sino con varias. Estos son los <strong>lenguajes de alto nivel</strong>.</p> <p>Lógicamente, la traducción desde un lenguaje de alto nivel a lenguaje máquina es mucho más compleja que desde lenguaje ensamblador, por lo que <em>los traductores se han hecho cada vez más complicados</em>.</p> <p>Una característica muy importante de los lenguajes de alto nivel es que <strong>son independientes del hardware</strong>, lo que implica que los programas desarrollados con estos lenguajes pueden ser ejecutados en ordenadores con hardware totalmente distinto. A esto se le llama <strong>portabilidad</strong>.</p> <p>Los programas encargados de traducir el código de alto nivel a código máquina se llaman <strong>compiladores</strong> e <strong>intérpretes</strong>. Son programas muy complejos que generan el código binario equivalente al código de alto nivel para una máquina concreta. Por lo tanto, el programa de alto nivel, que es portable de un hardware a otro, debe ser traducido a código máquina en cada tipo de máquina en la que se pretenda ejecutar.</p> <p>Los ejemplos de lenguajes de alto nivel son innumerables, y la lista incluye casi todos de los que has oído hablar alguna vez: Basic, Cobol, Fortran, Ada, C/C++, PHP, Python, Java, Perl, Ruby, Javascript, etc.</p> <h4 id="ventajas-e-inconvenientes-de-los-lenguajes-de-alto-y-bajo-nivel"> <a href="#ventajas-e-inconvenientes-de-los-lenguajes-de-alto-y-bajo-nivel" class="anchor-heading" aria-labelledby="ventajas-e-inconvenientes-de-los-lenguajes-de-alto-y-bajo-nivel"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ventajas e inconvenientes de los lenguajes de alto y bajo nivel </h4> <div class="table-wrapper"><table> <thead> <tr> <th><strong>LENGUAJES DE BAJO NIVEL</strong></th> <th><strong>LENGUAJES DE ALTO NIVEL</strong></th> </tr> </thead> <tbody> <tr> <td><strong>Ventajas</strong></td> <td><strong>Inconvenientes</strong></td> </tr> <tr> <td>Son comprensibles directamente por la máquina (aunque el ensamblador necesita una pequeña traducción)</td> <td>Necesitan ser traducidos por medio de complicados programas (compiladores e intérpretes)</td> </tr> <tr> <td>Los programas se ejecutan muy rápidamente (si están bien escritos, claro)</td> <td>La traducción automática del código de alto nivel al código máquina siempre genera programas menos eficientes que si se escribieran directamente en binario</td> </tr> <tr> <td>Ocupan menos espacio en memoria</td> <td>Ocupan más espacio en memoria</td> </tr> <tr> <td>Permiten controlar directamente el hardware, por lo que son apropiados para la programación de sistemas</td> <td>En general, solo pueden acceder al hardware utilizando al sistema operativo como intermediario. Pero, entonces, ¿cómo programar el sistema operativo, que necesita controlar directamente el hardware?</td> </tr> <tr> <td><strong>Inconvenientes</strong></td> <td><strong>Ventajas</strong></td> </tr> <tr> <td>Son completamente dependientes del hardware. Un programa escrito para determinado tipo de máquina no funcionará en un ordenador con diferente arquitectura.</td> <td>Son portables, es decir, independientes del hardware. Un programa escrito en una máquina puede funcionar en otra con hardware distinto, siempre que se vuelva a traducir a binario en la máquina nueva.</td> </tr> <tr> <td>Incluso los programas más sencillos son largos y farragosos</td> <td>Los programas son más sencillos, ya que una sola instrucción puede equivaler a varias instrucciones binarias.</td> </tr> <tr> <td>Los programas son difíciles de escribir, depurar y mantener</td> <td>Los programas son más fáciles de escribir, depurar y mantener</td> </tr> <tr> <td>Es imposible resolver problemas muy complejos</td> <td>Es posible, aunque difícil, enfrentarse a problemas muy complejos</td> </tr> </tbody> </table></div> <p>Si echas un vistazo a la tabla anterior comprenderás que, en general, <strong>es preferible usar lenguajes de alto nivel</strong> la gran mayoría de las veces, reservando los de bajo nivel para casos muy concretos, como el desarrollo de ciertas partes de los sistemas operativos.</p> <p>También hay que destacar que no todos los lenguajes de alto nivel son iguales. Los hay de más alto nivel que otros. El lenguaje C, por ejemplo, tiene menor nivel de abstracción que, por ejemplo, Java. Esto hace que los programas escritos en C sean más rápidos y eficientes que los escritos en Java, aunque también pueden llegar a ser más difíciles de escribir y depurar.</p> <h3 id="912-tipos-de-lenguaje-según-su-generación"> <a href="#912-tipos-de-lenguaje-según-su-generación" class="anchor-heading" aria-labelledby="912-tipos-de-lenguaje-según-su-generación"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.1.2. Tipos de lenguaje según su generación </h3> <p>Los lenguajes de programación también se clasifican según la generación a la que pertenecen.</p> <p>El lenguaje máquina fue el lenguaje de primera generación. Los ensambladores fueron los lenguajes de segunda generación. A partir de ahí, surgió una explosión de lenguajes diferentes que podemos clasificar como:</p> <ul> <li><strong>Lenguajes de tercera generación</strong> (o <strong>imperativos</strong>), en los que el programador escribe una secuencia de instrucciones que el ordenador debe ejecutar en un orden preestablecido. Son los lenguajes más “clásicos”: C, Basic, Cobol, Fortran, Pascal, etc.</li> <li><strong>Lenguajes de cuarta generación</strong> (o <strong>4GL</strong>), dirigidos a facilitar la creación de interfaces con el usuario y con otras aplicaciones, como las bases de datos. Un ejemplo de estos lenguajes es SQL, universalmente utilizado para manipular bases de datos y omnipresente en muchas aplicaciones web actuales.</li> <li><strong>Lenguajes orientados a objetos</strong>, que son una evolucuión de los lenguajes de tercera generación y que permiten construir con mayor facilidad y robustez programas modulares complejos. Ejemplos de lenguajes orientados a objetos son C++, C#, Java, Javascript, Python, PHP o Ruby. Algunos de ellos son multiparadigma, es decir, permiten programar con orientación a objetos pero también permiten hacer programación estructurada clásica, sin objetos.</li> <li><strong>Lenguajes declarativos</strong> y <strong>lenguajes funcionales</strong>, propios de la inteligencia artificial, como Prolog o Lisp.</li> <li><strong>Otros</strong> tipos aún más específicos: lenguajes concurrentes, paralelos, distribuidos, etc.</li> </ul> <p>En general, podemos decir que un programador acostumbrado a trabajar con un lenguaje de tercera generación puede aprender con poco esfuerzo cualquier otro lenguaje de tercera generación y, con algo más de trabajo, un lenguaje orientado a objetos. Sin embargo, el “salto” a otros tipos de lenguajes, como los declarativos, cuesta más porque las fundamentos de estos lenguajes son muy diferentes.</p> <h3 id="913-tipos-de-lenguaje-según-su-forma-de-traducción"> <a href="#913-tipos-de-lenguaje-según-su-forma-de-traducción" class="anchor-heading" aria-labelledby="913-tipos-de-lenguaje-según-su-forma-de-traducción"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.1.3. Tipos de lenguaje según su forma de traducción </h3> <p>Cuando programamos en un lenguaje distinto del lenguaje máquina, <strong>nuestro código debe ser traducido a binario</strong> para que el ordenador pueda entenderlo y ejecutarlo. Existe un programa específico encargado de hacer esa traducción y que, dependiendo del lenguaje en el que hayamos escrito nuestro programa, puede ser un <em>ensamblador</em>, un <em>compilador</em> o un <em>intérprete</em>.</p> <h4 id="ensambladores"> <a href="#ensambladores" class="anchor-heading" aria-labelledby="ensambladores"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ensambladores </h4> <p>Se llaman <strong>ensambladores</strong> los programas encargados de <strong>traducir los programas escritos en ensamblador a código binario</strong>.</p> <p>Sí, ya lo sé: se usa el mismo nombre para referirse al <em>lenguaje</em> de programación y al <em>traductor</em> de ese lenguaje a código máquina. Es un lío.</p> <p>Como el lenguaje ensamblador es muy próximo al binario, estos traductores son programas relativamente sencillos.</p> <h4 id="compiladores"> <a href="#compiladores" class="anchor-heading" aria-labelledby="compiladores"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Compiladores </h4> <p>El <strong>compilador</strong> es un programa que traduce el <strong>código de alto nivel a código binario</strong>.</p> <p>Es, por tanto, parecido al ensamblador, pero mucho más complejo, ya que las diferencias entre los lenguajes de alto nivel y el código binario son muy grandes.</p> <p>El programa escrito en lenguaje de alto nivel se denomina programa fuente o <strong>código fuente</strong>. El programa traducido a código binario se llama programa objeto o <strong>código objeto</strong>. Por lo tanto, el compilador se encarga de convertir el programa fuente en un programa objeto.</p> <p>Una vez que se ha obtenido el código objeto ya no es necesario volver a realizar la traducción (o compilación), a menos que se haga alguna modificación en el programa fuente, en cuyo caso habría que volver a compilarlo.</p> <p>El código objeto, una vez generado, puede ejecutarse en la máquina en la que fue compilado, o en otra de similares características (procesador, sistema operativo, etc.). Cuando se usa programación modular, puede ser necesario un proceso previo de enlace de los diferentes módulos antes de poder construir el programa ejecutable.</p> <h4 id="intérpretes"> <a href="#intérpretes" class="anchor-heading" aria-labelledby="intérpretes"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Intérpretes </h4> <p>El <strong>intérprete</strong> es un programa que <strong>traduce el código de alto nivel a código binario</strong> pero, a diferencia del compilador, lo hace <strong>en tiempo de ejecución</strong>.</p> <p>Es decir, no existe un proceso previo de traducción de todo el código fuente a código binario, sino que se va traduciendo y ejecutando instrucción por instrucción.</p> <h4 id="compiladores-frente-a-intérpretes"> <a href="#compiladores-frente-a-intérpretes" class="anchor-heading" aria-labelledby="compiladores-frente-a-intérpretes"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Compiladores frente a intérpretes </h4> <p>El <strong>intérprete</strong> es notablemente <strong>más lento</strong> que el compilador, ya que realiza la traducción al mismo tiempo que la ejecución. Además, esa traducción se lleva a cabo siempre que se ejecuta el programa, mientras que el compilador sólo la hace una vez. Hay un evidente malgasto de recursos.</p> <p>Sin embargo, los intérpretes tienen una gran ventaja sobre los compiladores, y es que logran que <strong>los programas sean más portables</strong>, es decir, que puedan ejecutarse en diferentes máquinas con diferentes sistemas operativos sin apenas cambios.</p> <p>Así, un programa <em>compilado</em> en una máquina PC bajo Windows no funcionará en un Mac o en un PC bajo Linux, a menos que se vuelva a compilar el programa fuente en el nuevo sistema. En cambio, un programa <em>interpretado</em> funcionará en todas las plataformas, siempre que dispongamos del intérprete en cada una de ellas.</p> <p><strong>C/C++ es un ejemplo de lenguaje compilado. Python es un ejemplo de lenguaje interpretado.</strong></p> <p>Eso significa que un programa escrito, por ejemplo, con <strong>Python</strong>, puede funcionar en cualquier máquina que disponga de un intérperte Python, que, hoy en día, es casi cualquiera. Por eso, <strong>cualquier programa escrito en Python puede ejecutarse prácticamente en cualquier ordenador del mundo</strong> sin tocarle ni una coma.</p> <p>En cambio, los programas desarrollados con C/C++ se ejecuten <strong>más rápido</strong> (¡pero mucho más rápido!) que sus equivalentes en Python. Sin embargo, <strong>tendrás que volver a compilarlos</strong> si deseas ejecutarlos en una máquina con diferente hardware o diferente sistema operativo.</p> <h3 id="914-tipos-de-lenguaje-según-su-tipado"> <a href="#914-tipos-de-lenguaje-según-su-tipado" class="anchor-heading" aria-labelledby="914-tipos-de-lenguaje-según-su-tipado"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.1.4. Tipos de lenguaje según su tipado </h3> <p>Por <em>tipado</em> nos referimos a la forma en la que los lenguajes de programación usan los tipos de datos. Ya sabes: entero, carácter, lógico, etc. Es decir, las categorías a las que puede pertenecer una variable.</p> <p>Pues bien, según su tipado, los lenguajes pueden ser:</p> <ul> <li><strong>De tipado fuerte</strong>: los tipos de datos no pueden mezclarse. Por ejemplo, no puedes sumar un entero y un real, porque son números de distinto tipo. Y mucho menos sumar un entero con un carácter.</li> <li><strong>De tipado débil</strong>: los tipos de datos pueden mezclarse y el lenguaje hace las conversiones de tipos implícitas que le parezca oportunas. Así, en estos lenguajes podrías sumar un entero con un real, o incluso un entero con un carácter. ¿Que cuál sería el resultado? Buena pregunta. Tendrás que probarlo, porque eso depende de las conversiones de tipo que haga el lenguaje.</li> <li><strong>De tipado estático</strong>: los tipos de datos se asignan al escribir el código y no pueden cambiarse durante la ejecución. Esto es típico de los compiladores (aunque no de todos).</li> <li><strong>De tipado dinámico</strong>: los tipos de datos pueden cambiarse alegremente durante la ejecución. Esto es típico de los intérpretes.</li> </ul> <p>Las dos primeras categorías y las dos segundas no son excluyentes. Por ejemplo, pueden existir lenguajes de tipado débil y dinámico, o bien fuerte y estático. Las otras combinaciones (fuerte y dinámico, débil y estático) pueden darse pero son menos habituales.</p> <h3 id="915-el-top-ten-de-los-lenguajes-de-programación"> <a href="#915-el-top-ten-de-los-lenguajes-de-programación" class="anchor-heading" aria-labelledby="915-el-top-ten-de-los-lenguajes-de-programación"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.1.5. El <em>top ten</em> de los lenguajes de programación </h3> <p>Es difícil saber cuales son los lenguajes más populares en un determinado momento porque no existen estadísticas fiables a nivel mundial. Además, las cosas pueden cambiar mucho de un territorio a otro.</p> <p>Sin embargo, ciertos sitios de internet, como <strong>GitHub</strong>, almacenan enormes cantidades de proyectos de software. GitHub, de hecho, es el mayor almacén de código fuente conocido, de modo que sus estadísticas nos pueden dar una idea bastante exacta de cuál es el grado de uso de cada lenguaje.</p> <p>Según <a href="https://madnight.github.io/githut">Madnight</a>, un proyecto que recopila y publica estadísticas de uso de lenguajes en GitHub, el <em>top ten</em> de lenguajes de programación más usados en GitHub es:</p> <div class="table-wrapper"><table> <thead> <tr> <th>Puesto</th> <th>Lenguaje</th> <th>Porcentaje de uso</th> <th>Variación de uso en 12 meses</th> </tr> </thead> <tbody> <tr> <td>1</td> <td>JavaScript</td> <td>17.955%</td> <td>-2.192%</td> </tr> <tr> <td>2</td> <td>Python</td> <td>15.943%</td> <td>+0.071%</td> </tr> <tr> <td>3</td> <td>Java</td> <td>12.977%</td> <td>+1.573%</td> </tr> <tr> <td>4</td> <td>Go</td> <td>8.203%</td> <td>-0.612%</td> </tr> <tr> <td>5</td> <td>TypeScript</td> <td>7.212%</td> <td>-0.276%</td> </tr> <tr> <td>6</td> <td>C++</td> <td>6.683%</td> <td>-0.251%</td> </tr> <tr> <td>7</td> <td>Ruby</td> <td>6.488%</td> <td>+0.303%</td> </tr> <tr> <td>8</td> <td>PHP</td> <td>4.937%</td> <td>-0.093%</td> </tr> <tr> <td>9</td> <td>C#</td> <td>3.366%</td> <td>-0.350%</td> </tr> <tr> <td>10</td> <td>C</td> <td>2.958%</td> <td>+0.068%</td> </tr> </tbody> </table></div> <p>El porcentaje de uso indica la proporción de proyectos en GitHub que usan ese lenguaje de programación sobre el total de proyectos. La última cifra señala la variación interanual del porcentaje de uso.</p> <p>Estos datos son de tercer cuatrimestre de 2021. Para obtener datos de otras fechas, puedes visitar la web <a href="https://madnight.github.io/">https://madnight.github.io/</a></p> <p>Ten en cuenta de nuevo que esto no son cifras de uso absoluto de los lenguajes a nivel mundial. Solo se trata de una pista de cuál es la situación. De hecho, si consultas otras estadísticas como el <a href="https://tiobe.com/tiobe-index/">TIOBE index</a>, encontrarás datos diferentes.</p> <p>Según estas cifras, el conjunto de proyectos que usan lenguaje C o cualquiera de sus variantes (C++ o C#) es muy significativo, sobre todo teniendo en cuenta que C es un lenguaje de la década de 1970, lo cual constituye una eternidad en informática. Que un lenguaje mantenga su vigencia durante tanto tiempo indica lo robusto y confiable que es. Seguramente seguirá con nosotros dentro de muchos años, cuando otros competidores de esta lista ya hayan caído en el olvido.</p> <h2 id="92-bienvenidos-a-c"> <a href="#92-bienvenidos-a-c" class="anchor-heading" aria-labelledby="92-bienvenidos-a-c"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.2. ¡Bienvenidos a C! </h2> <h3 id="921--características-básicas-de-c"> <a href="#921--características-básicas-de-c" class="anchor-heading" aria-labelledby="921--características-básicas-de-c"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.2.1. Características básicas de C </h3> <ul> <li>C es un lenguaje de <strong>alto nivel</strong>, aunque a veces se le considera de <strong>nivel intermedio</strong>, porque permite manipular detalles del hardware que para otros lenguajes resultan innacesibles.</li> <li>Es <strong>imperativo y estructurado</strong>. Admite <strong>orientación a objetos</strong> (aunque entonces se llama C++).</li> <li>Su <strong>tipado es estático y débil</strong>. Eso significa que hay que indicar el tipo de datos de las variables antes de usarlas y que se pueden hacer mezclas de tipos.</li> <li>La <strong>sintaxis</strong> de sus estructuras de control se parece a las de Java, Javascript, PHP o Python, porque todos estos lenguajes son herederos naturales de C.</li> <li>Es un <strong>lenguaje compilado</strong>, pensado para producir código máquina rápido y eficiente. Si quieres velocidad de ejecución, C es tu lenguaje.</li> <li>Es <strong>altamente portable</strong> (para ser un lenguaje compilado). Existen compiladores de C para todos los sistemas y arquitecturas. Si respetas el estándar de C, no tendrás dificultad para migrar las aplicaciones a cualquier sistema.</li> <li>Es un lenguaje de programación <strong>muy popular</strong> y <strong>muy veterano</strong>. Aunque se ha intentado reemplazar muchas veces, ningún lenguaje lo ha conseguido y tiene una base de programadores muy fieles.</li> </ul> <h3 id="922-breve-historia-de-c"> <a href="#922-breve-historia-de-c" class="anchor-heading" aria-labelledby="922-breve-historia-de-c"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.2.2. Breve historia de C </h3> <p>A principios de la década de 1970, los laboratorios Bell necesitaban un nuevo sistema operativo. Hasta ese momento, la mayoría de los sistemas operativos estaban escritos en lenguaje ensamblador (muy parecido al lenguaje máquina) para que el resultado fuera un programa lo suficientemente rápido.</p> <p>Pero los programas escritos en ensamblador son difíciles de mantener y Bell quería que su nuevo sistema operativo se pudiera mantener y modificar con facilidad. Por lo tanto, se decidieron a inventar un lenguaje nuevo con el que programar su sistema operativo.</p> <p>Tras varios intentos, Brian Kerningham y Dennis Ritchie, dos ingenieros de laboratorios Bell, terminaron de diseñar el lenguaje C en un ordenador DEC PDP-11 y, con él, desarrollaron el sistema operativo Unix.</p> <p>El tándem C - Unix ha sido una referencia fundamental en el mundo de la programación en el último medio siglo, y C se ha convertido en uno de los lenguajes de programación más populares y longevos de la historia de la informática. C creció en popularidad muy rápidamente y sigue siendo uno de los lenguajes fundamentales tanto en el mundo educativo como en el mundo profesional.</p> <p>El primer estándar de C (ANSI C) no apareció hasta 1990, por lo que es posible encontrar diferentes dialectos de C ligeramente incompatibles entre sí.</p> <p>Una evolución de C fue el lenguaje C++ que, a parte de todas las características del ANSI C, incluye la posibilidad de orientación a objetos, una técnica de programación ligeramente diferente de la programación estructurada. Algo más tarde, en el año 2000, Microsoft patentó el lenguaje C#, otra evolución de C++ orientada al desarrollo de aplicaciones en red para la plataforma .NET de esta compañía.</p> <p>Otros lenguajes han sido diseñados para permitir que los no programadores puedan leer y comprender los programas y, presumiblemente, aprender a escribir los suyos propios para resolver problemas sencillos. Por el contrario, C fue creado, influenciado y probado en vivo por programadores profesionales. El resultado es que C da al programador lo que muchos programadores piden: unas pocas y bien escogidas palabras clave, una biblioteca poderosa y estandarizada, unas mínimas restricciones y un máximo control sobre lo que sucede en el interior de la máquina.</p> <p>Si a esto unimos que el código objeto generado por C es casi tan eficiente como el ensamblador, se entenderá por qué lleva medio siglo siendo uno de los lenguajes más populares entre los programadores profesionales.</p> <p>C también tiene sus detractores que lo acusan de ser confuso, críptico y demasiado flexible. En efecto, con C se pueden desarrollar las técnicas de programación estructurada, pero también se puede programar “código espagueti”. Esto, sin embargo, ocurre con todos los lenguajes: incluso los que tienen una sintaxis más estilizada y elegante, como Python o Ruby, pueden generar código absolutamente ininteligible en manos de un programador manazas.</p> <h3 id="923-sintaxis-básica-de-c"> <a href="#923-sintaxis-básica-de-c" class="anchor-heading" aria-labelledby="923-sintaxis-básica-de-c"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.2.3. Sintaxis básica de C </h3> <p>En este apartado vamos a aprender cómo se escriben en C las estructuras de control y el resto de instrucciones básicas.</p> <h4 id="generalidades-sintácticas"> <a href="#generalidades-sintácticas" class="anchor-heading" aria-labelledby="generalidades-sintácticas"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Generalidades sintácticas </h4> <p>Hay algunas normas básicas de la sintaxis de C que tienes que conocer:</p> <ul> <li><strong>Los bloques de código se marcan con las llaves</strong> ( <strong>{</strong> y <strong>}</strong> ). Por ejemplo, después de una sentencia <em>while</em> (equivalente al <em>mientras</em> de pseudocódigo) hay que abrir una llave. El cuerpo de bucle comprenderá desde esa llave de apertura hasta la siguiente llave de cierre, así:</li> </ul> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="k">while</span> <span class="p">(</span><span class="n">condicion</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Instrucci</span><span class="err">ó</span><span class="n">n</span> <span class="mi">1</span> <span class="n">del</span> <span class="n">bucle</span>
      <span class="n">Instrucci</span><span class="err">ó</span><span class="n">n</span> <span class="mi">2</span> <span class="n">del</span> <span class="n">bulce</span>
      <span class="p">...</span>
      <span class="n">Instrucci</span><span class="err">ó</span><span class="n">n</span> <span class="n">N</span> <span class="n">del</span> <span class="n">bucle</span>
   <span class="p">}</span>
</code></pre></div></div> <p>La llave de cierre, por tanto, sería el equivalente al <em>FinMientras</em> de pseudocódigo.</p> <ul> <li> <p>Todas las instrucciones <strong>terminan con un punto y coma</strong> ( <strong>;</strong> ). Excepción: si una instrucción contiene un bloque marcado con llaves ( { … } ), se considera que esa instrucción termina al cerrar el bloque, y en ese caso no hace falta poner punto y coma.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>                     <span class="cm">/* La instrucción de asignación termina con ; */</span>
 <span class="k">while</span> <span class="p">(</span><span class="n">condicion</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Cuerpo del bucle */</span>
 <span class="p">}</span>                           <span class="cm">/* El bucle termina con }, así que no necesita ; */</span>
</code></pre></div> </div> </li> <li> <p>Los <strong>identificadores</strong> de variables, funciones, etc., no pueden empezar con un número ni contener espacios o símbolos especiales, salvo el de subrayado ( _ )</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">a5</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>     <span class="cm">/* Identificador de variable válido */</span>
 <span class="mi">5</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>     <span class="cm">/* Identificador de variable NO válido */</span>
</code></pre></div> </div> </li> <li> <p>Las <strong>cadenas de caracteres</strong> deben encerrarse entre <strong>comillas dobles</strong> ( “…” ). Los <strong>caracteres</strong> individuales se encierran entre <strong>comillas simples</strong>.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="s">"Soy una cadena"</span><span class="p">;</span>   <span class="cm">/* Cadena de caracteres */</span>
 <span class="sc">'C'</span><span class="p">;</span>                <span class="cm">/* Carácter individual */</span>
</code></pre></div> </div> </li> <li> <p>El lenguaje es <strong>sensitivo a las mayúsculas</strong>. Es decir, no es lo mismo que una variable se llame <em>edad</em> que <em>Edad</em> o <em>EDAD</em>.</p> </li> </ul> <h4 id="tipos-de-datos-simples"> <a href="#tipos-de-datos-simples" class="anchor-heading" aria-labelledby="tipos-de-datos-simples"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Tipos de datos simples </h4> <p>C utiliza varios tipos de datos <strong>simples</strong> porque solo pueden contener un valor en cada momento (como en pseudocódigo). Los más importantes son:</p> <ul> <li><strong>int</strong>: números enteros. Admite modificadores como <strong>long</strong> (para enteros largos) o <strong>short</strong> (para enteros cortos). Por ejemplo, el tipo <em>int</em> permite usar números entre –32768 a 32767, mientras que el tipo <em>long int</em> admite números entre –2147483648 a 2147483647.</li> <li><strong>float</strong>: número reales. El tipo <strong>double</strong> se usa para lo mismo, pero tiene más precisión y admite números mayores.</li> <li><strong>char</strong>: caracteres.</li> <li><strong>void</strong>: vacío. Se usa en funciones que no devuelven nada o que tienen una lista de parámetros vacía.</li> </ul> <p>Observa que en C no existe el tipo de dato <strong>lógico o booleano</strong>. Se utiliza en su lugar el tipo <em>int</em>, representando el 0 el valor falso y cualquier otra cantidad (normalmente 1) el valor verdadero.</p> <h4 id="declaración-de-variables"> <a href="#declaración-de-variables" class="anchor-heading" aria-labelledby="declaración-de-variables"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Declaración de variables </h4> <p>Todas las variables tienen que <strong>declararse</strong> antes de su primer uso. Esto se hace así:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>   <span class="cm">/* Declaración de la variable a, de tipo entero */</span>
<span class="kt">char</span> <span class="n">b</span><span class="p">;</span>  <span class="cm">/* Declaración de la variable b, de tipo carácter */</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>  <span class="cm">/* Uso de la variable a */</span>
<span class="n">b</span> <span class="o">=</span> <span class="sc">'z'</span><span class="p">;</span> <span class="cm">/* Uso de la variable b */</span>
</code></pre></div></div> <p>Observa que, al declarar una variable, hay que especificar su tipo.</p> <p>Todas las variables son <strong>locales</strong> a la función o bloque de código donde estén definidas, salvo que se indique otra cosa, dejando de existir al finalizar el bloque actual. Aunque pueden crearse variables globales, su uso está tan desaconsejado que ni siquiera te voy a explicar cómo se hace.</p> <h3 id="924-conversiones-de-tipo"> <a href="#924-conversiones-de-tipo" class="anchor-heading" aria-labelledby="924-conversiones-de-tipo"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.2.4. Conversiones de tipo </h3> <p>C es un lenguaje <strong>débilmente tipado</strong>, es decir, no hace comprobaciones estrictas de tipos a la hora de asignar un valor a una variable o de comparar dos expresiones.</p> <p>Por ejemplo, estas instrucciones son correctas:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">a</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
</code></pre></div></div> <p>¡Hemos asignado un valor entero a la variable <em>a</em>, que es de tipo <em>float</em>!</p> <p>En otros lenguajes esto no está permitido, pero en C se realizan conversiones automáticas de tipo cuando en una misma expresión aparecen datos de tipos diferentes. Esto, que en principio es una ventaja, pues elimina algunas limitaciones engorrosas, otras veces es peligroso porque algunos datos pueden cambiar extrañamente de valor al hacerse esa conversión automática.</p> <p>La conversión puede ser de dos clases:</p> <ul> <li> <p><strong>Asignación de un valor a una variable que permita más precisión</strong>. Por ejemplo, asignar un número entero a una variable <em>float</em>. En este caso, el número se convierte a real añadiendo “.0” a la parte decimal. No hay pérdida de información.</p> </li> <li> <p><strong>Asignación de un valor a una variable que permita menos precisión</strong>. Por ejemplo, asignar un número <em>long int</em> a una variable de tipo <em>int</em>. En este caso, el número se recorta, perdiendo sus bits más significativos, es decir, los dígitos binarios que estén más a la izquierda. Por lo tanto, hay pérdida de información. Hay que tener mucho cuidado con este tipo de conversiones.</p> </li> </ul> <p>Además de las conversiones automáticas de tipo, el programador puede <strong>forzar la conversión de tipos</strong> a voluntad utilizando <strong>moldes</strong>.</p> <p>Un molde es una expresión de un tipo de datos entre paréntesis que aparece delante de un dato. Entonces, antes de evaluar la expresión, el dato es convertido al tipo especificado en el molde. Por ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">a</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</code></pre></div></div> <p>Sin el molde <code class="language-plaintext highlighter-rouge">(float)</code>, la división <code class="language-plaintext highlighter-rouge">a/2</code> sería entera, ya que a es una variable de tipo <em>int</em>, y se perdería la parte decimal. Al aplicar el molde, se convierte momentáneamente el valor entero 5 al valor real 5.0 y se evalúa la expresión, que ahora sí se realiza como división real, conservando sus decimales.</p> <h3 id="925-asignación"> <a href="#925-asignación" class="anchor-heading" aria-labelledby="925-asignación"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.2.5. Asignación </h3> <p>La <strong>asignación</strong> de valores a variables en C es fácil de explicar: se hace con el <strong>símbolo igual (=)</strong>, no con el símbolo &lt;= que usábamos en pseudocódigo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>      <span class="cm">/* Declaración de la variable a */</span>
<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Declaración y asignación de valor a la variable b */</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>  <span class="cm">/* Asignación de valor a la variable a */</span>
</code></pre></div></div> <p>Observa cómo, en la segunda instrucción, hemos declarado y asignado valor a una variable en la misma línea.</p> <h3 id="926-operadores-y-expresiones"> <a href="#926-operadores-y-expresiones" class="anchor-heading" aria-labelledby="926-operadores-y-expresiones"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.2.6. Operadores y expresiones </h3> <p>Los <strong>operadores y expresiones en C</strong> son iguales que los que hemos empleado en pseudocódigo:</p> <ul> <li>Operadores <strong>aritméticos</strong>: +, -, *, /, % (este último significa <em>módulo de la división</em>).</li> <li>Operadores <strong>relacionales</strong>: &gt;, &lt;, &gt;=, &lt;=…</li> </ul> <p>Sin embargo, hay algunas <strong>diferencias</strong> importantes entre el pseudocódigo de PseInt y C. Son estas:</p> <ul> <li> <p>La <strong>asignación</strong>, como ya hemos visto más arriba, se hace con el <strong>símbolo igual (=)</strong>, no con &lt;=.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>        <span class="cm">/* A la variable a se le asigna el valor 5 */</span>
 <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>    <span class="cm">/* A la variable b se le asigna el valor a + 1 */</span>
</code></pre></div> </div> </li> <li> <p>La <strong>comparación de igualdad</strong> se hace con un <strong>doble igual (==)</strong>, no con un solo igual (=). Esto es así para distinguir la comparación de la asignación.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>    <span class="cm">/* Comparación: ¿es a igual a 5? */</span>
     <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>   <span class="cm">/* Asignación: b toma el valor a + 1 */</span>
 <span class="p">}</span>
</code></pre></div> </div> </li> <li> <p>Existe el <strong>operador incremento (++)</strong>. Se utiliza para sumar una unidad a una variable.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">i</span><span class="o">++</span><span class="p">;</span>         <span class="cm">/* Esto es equivalente a: i = i + 1 */</span>
 <span class="p">}</span>
</code></pre></div> </div> </li> <li> <p>También existe el <strong>operador decremento (- -)</strong>, para restar una unidad a una variable.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">i</span><span class="o">--</span><span class="p">;</span>     <span class="cm">/* Equivalente a: i = i - 1 */</span>
 <span class="p">}</span>
</code></pre></div> </div> </li> <li> <p>Los <strong>operadores lógicos</strong> (Y, O, NO) se escriben de forma distinta:</p> <ul> <li><strong>Y</strong> se escribe <strong>&amp;&amp;</strong>.</li> <li><strong>O</strong> se escribe <strong>||</strong>.</li> <li><strong>NO</strong> se escribe <strong>!</strong> (sí, sí, es una admiración).</li> </ul> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>   <span class="cm">/* Operador Y: tienen que darse las dos condiciones a la vez */</span>
     <span class="p">...</span>
 <span class="p">}</span>
</code></pre></div> </div> </li> </ul> <p>Hay algunas otras diferencias, desde luego, pero con esto ya tienes para hacer un buen montón de programas.</p> <h3 id="927-estructuras-de-control"> <a href="#927-estructuras-de-control" class="anchor-heading" aria-labelledby="927-estructuras-de-control"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.2.7. Estructuras de control </h3> <p>Las <strong>estructuras de control</strong> en C son muy similares a las que hemos utilizado en pseudocódigo, cambiando ligeramente la notación empleada.</p> <p>A continuación te muestro una tabla con las más habituales y su equivalente en pseudocódigo, sin entrar en explicaciones, porque supondremos que ya sabes manejarlas. Si no recuerdas para qué servía alguna de ellas, quizá sería buena idea que le dieras un repaso al capítulo dedicado al pseudocódigo.</p> <div class="table-wrapper"><table> <tr> <th>Instrucción</th> <th>Pseudocódigo</th> <th>Lenguaje C</th> </tr> <tr> <td>Condicional simple</td> <td> <code> Si condición entonces<br /> &nbsp;&nbsp;&nbsp;acciones<br /> FinSi </code> </td> <td> <code> if (condicion) {<br /> &nbsp;&nbsp;&nbsp;acciones<br /> } </code> </td> </tr> <tr> <td>Condicional doble</td> <td> <code> Si condicion entonces<br /> &nbsp;&nbsp;&nbsp;acciones<br /> SiNo<br /> &nbsp;&nbsp;&nbsp;acciones<br /> FinSi </code> </td> <td> <code> if (condicion) {<br /> &nbsp;&nbsp;&nbsp;acciones<br /> }<br /> else {<br /> &nbsp;&nbsp;&nbsp;acciones<br /> } </code> </td> </tr> <tr> <td>Bucle tipo mientras</td> <td> <code> Mientras condicion hacer<br /> &nbsp;&nbsp;&nbsp;acciones<br /> FinMientras </code> </td> <td> <code> while (condicion) {<br /> &nbsp;&nbsp;&nbsp;acciones<br /> } </code> </td> </tr> <tr> <td>Bucle tipo repetir</td> <td> <code> Repetir<br /> &nbsp;&nbsp;&nbsp;acciones<br /> Hasta Que condicion </code> </td> <td> <code> do {<br /> &nbsp;&nbsp;&nbsp;acciones<br /> } while (condicion) </code> </td> </tr> <tr> <td>Bucle tipo para</td> <td> <code> Para variable &lt;- valor_inicial hasta valor_final con paso incremento hacer<br /> &nbsp;&nbsp;&nbsp;acciones<br /> FinPara </code> </td> <td> <code> for (variable = valor_inicial; variable != valor_final; variable = variable + incremento) {<br /> &nbsp;&nbsp;&nbsp;acciones<br /> } </code> </td> </tr> </table></div> <p>Fíjate en que casi todo se escribe del mismo modo que en pseudocódigo con un par de diferencias notables:</p> <ul> <li> <p><strong>DIFERENCIA 1: En el bucle tipo <em>repetir</em></strong>, la condición de salida se expresa al revés (“repetir mientras..” en lugar de “repetir hasta que…”. Lo verás mejor en este ejemplo que muestra los números del 1 al 100. Observa la condición del final del bucle:</p> <p>En pseudocódigo:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> i &lt;- 1
 Repetir
    Escribir i
    i &lt;- i + 1
 Hasta que i &gt;= 100
</code></pre></div> </div> <p>En C:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
 <span class="k">do</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">i</span><span class="o">++</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">);</span>
</code></pre></div> </div> </li> <li> <p><strong>DIFERENCIA 2: En el bucle tipo <em>para</em></strong> hay que indicar la asignación a la variable que controla el bucle, la condición de salida y la forma en la que esa variable cambiará en cada iteración. Observa este ejemplo:</p> <p>En pseudocódigo:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Para i &lt;- 1 hasta 10 hacer
    Escribir i
 FinPara
</code></pre></div> </div> <p>En C:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
 <span class="p">}</span>
</code></pre></div> </div> <p>Si el <strong>paso</strong> del bucle no es +1 (es decir, si la variable que controla el bucle no incrementa su valor de 1 en 1 en cada iteración), hay que indicarlo de este modo:</p> <p>En pseudocódigo:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Para i &lt;- 1 hasta 10 con paso 2 hacer
    Escribir i
 FinPara
</code></pre></div> </div> <p>En C:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
 <span class="p">}</span>
</code></pre></div> </div> <p>Por último, recuerda que en C existe una abreviatura para <code class="language-plaintext highlighter-rouge">i = i + 1</code>, que se escribe <code class="language-plaintext highlighter-rouge">i++</code>, por lo que lo más habitual es encontrar los bucles de tipo <em>para</em> escritos así:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span><span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
 <span class="p">}</span>
</code></pre></div> </div> </li> </ul> <h3 id="928-algoritmo-principal-y-subalgoritmos"> <a href="#928-algoritmo-principal-y-subalgoritmos" class="anchor-heading" aria-labelledby="928-algoritmo-principal-y-subalgoritmos"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.2.8. Algoritmo principal y Subalgoritmos </h3> <p>C es un <strong>lenguaje modular</strong> hasta el extremo de que todas las líneas de código deben pertenecer a alguna función, incluyendo las instrucciones del algoritmo principal, que se escriben en una función llamada <em>principal</em> (<strong><em>main</em></strong> en inglés)</p> <h4 id="la-función-main"> <a href="#la-función-main" class="anchor-heading" aria-labelledby="la-función-main"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> La función <em>main()</em> </h4> <p>La <strong>función <em>main()</em></strong> contiene el algoritmo o módulo principal del programa. La ejecución de un programa siempre empieza por la primera línea de la función <em>main()</em>.</p> <p>Esta función, como todas las funciones de C, puede devolver un valor. El valor devuelto por <em>main()</em> debe ser de tipo entero (<em>int</em>). Esto se utiliza para pasar algún valor al programa que haya llamado al nuestro, que suele ser el sistema operativo. Si <em>main()</em> no devuelve un número entero al sistema operativo mediante una sentencia return, entonces nuestro programa devolverá un número desconocido.</p> <p>(Moraleja: es una buena idea incluir un <em>return</em> al final de la función <em>main()</em>. Generalmente, la devolución de un 0 indica al sistema operativo que el programa a finalizado sin problemas, mientras que cualquier otro valor señala que se ha producido algún error).</p> <p>Por lo tanto, la forma habitual de la función <em>main()</em> será:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
   <span class="p">...</span><span class="n">instrucciones</span> <span class="n">del</span> <span class="n">algoritmo</span> <span class="n">principal</span><span class="p">...</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>Observa que <em>main()</em> no tiene argumentos, por lo que aparece el identificador <em>void</em> entre paréntesis en la declaración. También se pueden utilizar argumentos en <em>main()</em>, pero eso es algo que no trataremos de momento.</p> <h4 id="las-funciones-en-c"> <a href="#las-funciones-en-c" class="anchor-heading" aria-labelledby="las-funciones-en-c"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Las funciones en C </h4> <p>La declaración de funciones se hace de forma similar a la empleada en pseudocódigo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tipo_devuelto</span> <span class="n">nombre_funci</span><span class="err">ó</span><span class="n">n</span> <span class="p">(</span><span class="n">par</span><span class="err">á</span><span class="n">metros_formales</span><span class="p">)</span>
<span class="p">{</span>
   <span class="p">...</span><span class="n">instrucciones</span><span class="p">...</span>
   <span class="k">return</span> <span class="n">expresi</span><span class="err">ó</span><span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>Observa que las únicas diferencias con el pseudocódigo son que no se usa la palabra “función”, que las llaves { y } sustituyen a <em>inicio</em> y <em>fin</em>, y que se emplea la palabra <em>return</em> en lugar de devolver.</p> <p>Si el tipo_devuelto es <em>void</em>, se considera que la función no devuelve ningún valor y que, por lo tanto, es un procedimiento. Entonces, un procedimiento en C se declara así:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">nombre_procedimiento</span> <span class="p">(</span><span class="n">par</span><span class="err">á</span><span class="n">metros_formales</span><span class="p">)</span>
<span class="p">{</span>
   <span class="p">...</span><span class="n">instrucciones</span><span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="paso-de-parámetros"> <a href="#paso-de-parámetros" class="anchor-heading" aria-labelledby="paso-de-parámetros"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Paso de parámetros </h4> <p>Los parámetros formales son, como en pseudocódigo, una lista de tipos e identificadores que se sustituirán por los parámetros actuales y se usarán como variables dentro de la función.</p> <p>Los parámetros se pasan normalmente <strong>por valor</strong>, pero también se pueden pasar por referencia. El paso de parámetros por referencia admite dos sitaxis ligeramente diferentes en C: anteponiendo el <strong>operador *</strong> (asterisco) al nombre del parámetro (equivalente a usar la expresión <em>por referencia</em> en pseudocódigo) o anteponiendo el <strong>operador &amp;</strong>.</p> <p><strong>Paso de parámetros por valor</strong></p> <p>Por ejemplo, en esta función el paso de parámetros es por valor:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">funcion1</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
   <span class="p">...</span><span class="n">c</span><span class="err">ó</span><span class="n">digo</span> <span class="n">de</span> <span class="n">la</span> <span class="n">funci</span><span class="err">ó</span><span class="n">n</span>
<span class="p">}</span>
</code></pre></div></div> <p>Esto quiere decir que <em>funcion1()</em> recibirá únicamente el valor de los dos parámetros, x e y. Podrá utilizar esos valores a lo largo de su código, e incluso podrá cambiarlos. Pero cualquier cambio en x e y no afectará a los parámetros actuales, es decir, a los parámetros del programa que llamó a <em>funcion1()</em>.</p> <p><strong>Paso de parámetros por referencia con el operador *</strong></p> <p>En la siguiente función, el paso del parámetro “x” es por valor y el del parámetro “y”, por referencia:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">funcion2</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
   <span class="p">...</span><span class="n">c</span><span class="err">ó</span><span class="n">digo</span> <span class="n">de</span> <span class="n">la</span> <span class="n">funci</span><span class="err">ó</span><span class="n">n</span>
<span class="p">}</span>
</code></pre></div></div> <p>En este caso, cada vez que se vaya a usar el parámetro “y” dentro del código de la función, será necesario acompañarlo del asterisco. Por ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">17</span> <span class="o">+</span> <span class="o">*</span><span class="n">y</span><span class="p">;</span>
</code></pre></div></div> <p>(Hay algunas excepciones a esta regla, pero ahora no vienen a cuento).</p> <p>En la llamada a la función hay que indicar explícitamente qué parámetro se está pasando por referencia utilizando el operador &amp;. Por lo tanto, para llamar a <em>funcion2()</em> con los parámetros a y b habrá que escribir:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">resultado</span> <span class="o">=</span> <span class="n">funcion2</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</code></pre></div></div> <p>Observa que el segundo parámetro (el que se pasa por referencia), lleva delante el operador &amp;.</p> <p>Si dentro de la función se cambia el valor de y, también cambiará el valor de b fuera de la función, ya que ambas variables han quedado ligadas por el paso por referencia. En cambio, las variables x y a son independientes. (Si todo esto te suena a chino, repásate el apartado dedicado al paso de parámetros en el tema de introducción a la programación en pseudocódigo, donde se explicaba con más detalle).</p> <p><strong>Paso de parámetros por referencia con el operador &amp;</strong></p> <p>Otra forma de pasar un parámetro por referencia es usar el operador &amp; en los parámetros formales, así:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">funcion3</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
   <span class="p">...</span><span class="n">c</span><span class="err">ó</span><span class="n">digo</span> <span class="n">de</span> <span class="n">la</span> <span class="n">funci</span><span class="err">ó</span><span class="n">n</span>
<span class="p">}</span>
</code></pre></div></div> <p>En esta función, el parámetro x se pasa por valor y el parámetro y se pasa por referencia. Utilizando esta sintaxis no es necesario añadir asteriscos cada vez que se usa la y en el cuerpo de la función, ni tampoco usar “&amp;” en la llamada a la función.</p> <p>Esta tercera forma de paso por referencia no es estándar en C, sino que es propia de C++, por lo que evitaremos utilizarla de momento.</p> <h4 id="juntándolo-todo-en-un-ejemplo"> <a href="#juntándolo-todo-en-un-ejemplo" class="anchor-heading" aria-labelledby="juntándolo-todo-en-un-ejemplo"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Juntándolo todo en un ejemplo </h4> <p>En el siguiente ejemplo se ilustran los dos tipos de paso de parámetros y, en el paso por referencia, las dos sintaxis alternativas de que dispone C.</p> <p>El ejemplo muestra tres funciones muy similares que reciben dos parámetros, a y b. Las tres intentan intercambiar el valor de a y b mediante una tercera variable llamada tmp. Sin embargo, en la primera de ellas el intercambio no tiene ningún efecto en el programa <em>main()</em>, ya que los parámetros están pasados por valor. En las otras dos funciones sí que se consigue el intercambio, ya que los parámetros está pasados por referencia.</p> <p>No te preocupes si no entiendes toda la sintaxis de este ejemplo. Lo interesante ahora es que veas cuál es la forma correcta de escribir cada tipo de paso de parámetros.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="c1">// Paso de parámetros por valor.</span>
<span class="c1">// En este ejemplo, esta función no tendrá el efecto deseado, porque las variables</span>
<span class="c1">// del programa principal no se verán afectadas.</span>
<span class="kt">void</span> <span class="nf">intercambiar1</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
     <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
     <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
     <span class="n">b</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Paso de parámetros por referencia, sintaxis 1.</span>
<span class="c1">// Esta función sí que consigue intercambiar los valores de las variables</span>
<span class="c1">// del programa principal.</span>
<span class="kt">void</span> <span class="nf">intercambiar2</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
     <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
     <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
     <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Paso de parámetros por referencia, sintaxis 2.</span>
<span class="c1">// Esta función también consigue su objetivo. A todos los efectos,</span>
<span class="c1">// es idéntica a la función anterior.</span>
<span class="kt">void</span> <span class="nf">intercambiar3</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
     <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
     <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
     <span class="n">b</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// Programa principal</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">dato1</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span> <span class="n">dato2</span> <span class="o">=</span> <span class="mi">90</span><span class="p">;</span>
    
    <span class="n">printf</span><span class="p">(</span><span class="s">"Antes de la llamada a las funcioens: dato1 = %i, dato2 = %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dato1</span><span class="p">,</span> <span class="n">dato2</span><span class="p">);</span>
    <span class="n">intercambiar1</span><span class="p">(</span><span class="n">dato1</span><span class="p">,</span> <span class="n">dato2</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Después de intercambiar1: dato1 = %i, dato2 = %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dato1</span><span class="p">,</span> <span class="n">dato2</span><span class="p">);</span>
    <span class="n">intercambiar2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dato1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dato2</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Después de intercambiar2: dato1 = %i, dato2 = %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dato1</span><span class="p">,</span> <span class="n">dato2</span><span class="p">);</span>
    <span class="n">intercambiar3</span><span class="p">(</span><span class="n">dato1</span><span class="p">,</span> <span class="n">dato2</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Después de intercambiar3: dato1 = %i, dato2 = %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dato1</span><span class="p">,</span> <span class="n">dato2</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="prototipos-de-funciones"> <a href="#prototipos-de-funciones" class="anchor-heading" aria-labelledby="prototipos-de-funciones"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Prototipos de funciones </h4> <p>En C no es necesario escribir las funciones (subalgoritmos) antes de su primera invocación. El mecanismo de compilación y enlace de C permite, de hecho, que las funciones puedan estar físicamente en un archivo distinto del lugar desde el que se invocan.</p> <p>En la práctica, esto plantea un problema: C no tiene forma de saber si la llamada a una función se hace correctamente, es decir, si se le pasan los argumentos debidos y con el tipo correcto, ni si el resutado devuelto es asignado a una variable del tipo adecuado.</p> <p>Para conseguir que C realice esas comprobaciones durante la compilación se utilizan los <strong>prototipos de función</strong>. Un prototipo de función es, simplemente, <em>la declaración de una función</em>. Es decir, la primera línea del código la función.</p> <p>El prototipo debe aparecer antes de que la función se invoque por primera vez, aunque el código completo de la función esté en otra parte. Los prototipos permiten al compilador comprobar que los argumentos de la función coinciden en tipo y número con los de la invocación de la misma, y que el tipo devuelto es el correcto.</p> <p>Los prototipos suelen aparecer al principio del programa, antes de la función <em>main()</em>. Observa, en el siguiente ejemplo, que el prototipo de la función <em>calcular_area()</em> se coloca delante de <em>main()</em>. Sin embargo, el código concreto de esta función no aparece hasta después (incluso podría estar situado en otro archivo diferente):</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">calcular_area</span> <span class="p">(</span><span class="kt">float</span> <span class="n">base</span><span class="p">,</span> <span class="kt">float</span> <span class="n">altura</span><span class="p">);</span>	<span class="c1">// Prototipo de la función</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>				<span class="c1">// Algoritmo principal</span>
<span class="p">{</span>
   <span class="p">...</span><span class="n">instrucciones</span><span class="p">...</span>
   <span class="n">area</span> <span class="o">=</span> <span class="n">calcular_area</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">);</span>
   <span class="p">...</span><span class="n">m</span><span class="err">á</span><span class="n">s</span> <span class="n">instrucciones</span><span class="p">...</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">calcular_area</span><span class="p">(</span><span class="kt">float</span> <span class="n">base</span><span class="p">,</span> <span class="kt">float</span> <span class="n">altura</span><span class="p">)</span>	<span class="c1">// Código de la función (podría estar incluso en otro archivo)</span>
<span class="p">{</span>
   <span class="p">...</span> <span class="n">instrucciones</span><span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>Cuando se vayan a usar funciones de librería, como <em>fabs()</em> (valor absoluto), <em>sqrt()</em> (raíz cuadrada) o cualquier otra, hay que escribir sus prototipos antes de la función <em>main()</em>. Sin embargo, como estas funciones no las hemos escrito nosotros, desconocemos cuales son sus prototipos.</p> <p>En C se soluciona este problema con los <strong>archivos de cabecera</strong>, que son archivos que incluyen en su interior los prototipos de las funciones, entre otras cosas.</p> <p>Hay muchos archivos de cabecera en la librería estándar de C. Por ejemplo, el archivo <strong>math.h</strong> tiene los prototipos de todas las funciones matemáticas. Todos los archivos de cabecera tienen la <strong>extensión .h</strong> en su nombre (h de “header”).</p> <p>Para incluir un archivo de cabecera en nuestro programa se utiliza <strong>#include</strong>, que no es exactamente una instrucción de C, sino una <strong>directiva de compilación</strong>. Ya hemos visto otra directiva de compilación: #define, que usábamos para definir constantes. Las directivas de compilación indican al compilador cómo se debe comportar y, aunque estrictamente hablando no son instrucciones de C, para nosotros es como si lo fueran.</p> <p>Por ejemplo, esta línea de código sirve para incluir todos los prototipos de las funciones de librería matemática en nuestro programa:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;math.h&gt;</span><span class="cp">
</span></code></pre></div></div> <h3 id="929-entrada-y-salida-en-c"> <a href="#929-entrada-y-salida-en-c" class="anchor-heading" aria-labelledby="929-entrada-y-salida-en-c"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.2.9. Entrada y salida en C </h3> <p>La entrada y salida de datos en C, es decir, la traducción de las instrucciones leer() y escribir() de pseudocódigo, es uno de los aspectos más difíciles de C para los principiantes.</p> <p>El estándar ANSI C dispone de muchas funciones para hacer las entradas y salidas de datos. En concreto, dispone de un subconjunto de ellas para hacer la entrada y salida por consola, es decir, por teclado y pantalla.</p> <p>Podemos clasificar estas funciones de E/S en dos grupos:</p> <ul> <li><strong>Funciones de E/S simples</strong>: <em>getchar(), putchar(), gets(), puts()</em></li> <li><strong>Funciones de E/S con formato</strong>: <em>printf(), scanf()</em></li> </ul> <p>Las más utilizadas y versátiles son sin duda las segundas, así que nos detendremos en ellas.</p> <h4 id="salida-de-datos-con-printf"> <a href="#salida-de-datos-con-printf" class="anchor-heading" aria-labelledby="salida-de-datos-con-printf"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Salida de datos con <em>printf()</em> </h4> <p>La función <em>printf()</em> (de “print” = imprimir y “f” = formato) sirve para escribir datos en el dispositivo de salida estándar (generalmente la pantalla) con un formato determinado por el programador. La forma general de utilizarla es la siguiente:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">printf</span><span class="p">(</span><span class="n">cadena_de_formato</span><span class="p">,</span> <span class="n">datos</span><span class="p">);</span>
</code></pre></div></div> <p>El prototipo de <em>printf()</em> se encuentra en el archivo de cabecera <strong>&lt;stdio.h&gt;</strong> (de “std” = standard e “io” = input/output, es decir, “stdio” es un acrónimo de “entrada/salida estándar”).</p> <p>El primer argumento, la <em>cadena_de_formato</em>, especifica el modo en el que se deben mostrar los datos que aparecen a continuación. Esta cadena se compone de una serie de códigos de formato que indican a C qué tipo de datos son los que se desean imprimir.</p> <p>Todos los códigos están precedidos del símbolo de porcentaje (“%”). Por ejemplo, el código “%i” indica a la función que se desea escribir un número de tipo <em>int</em>, y el código “%f”, que se desea escribir un número real de tipo <em>float</em>.</p> <p>La forma más simple de utilizar <em>printf()</em> es:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div></div> <p>Esto escribirá el valor de la variable entera a en la pantalla, es decir, 5. Fíjate que el primer argumento de printf() es una cadena (y, por lo tanto, se escribe entre comillas) cuyo contenido es el código del tipo de dato que se pretende escribir. El segundo argumento es el dato mismo.</p> <p>En una sola instrucción <em>printf()</em> pueden escribirse varios datos. Por ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">x</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">.</span><span class="mi">33</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%i%f"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</code></pre></div></div> <p>Observa detenidamente la cadena de formato: primero aparece “%i” y luego “%f”. Esto indica que el primer dato que debe imprimirse es un entero, y el segundo, un real. Después, aparecen esos datos separados por comas y exactamente en el mismo orden que en la cadena de formato: primero la variable entera y luego la variable real. El resultado será que en la pantalla se escribirán los números 5 y 10.33.</p> <p>Algunos de los códigos de formato que se pueden utilizar en <em>printf()</em> son:</p> <ul> <li><strong>%c</strong>: para imprimir caracteres individuales.</li> <li><strong>%i</strong> o <strong>%d</strong>: para imprimir números enteros.</li> <li><strong>%u</strong>: para imprimir números enteros sin signo.</li> <li><strong>%f</strong>: para imprimir números reales.</li> <li><strong>%e</strong>: para imprimir números reales en notación científica.</li> <li><strong>%s</strong>: para imprimir cadenas de caracteres (strings).</li> <li><strong>%o</strong> y <strong>%x</strong>: para imprimir números en octal y en hexadecimal, respectivamente.</li> </ul> <p>Algunos de estos código admiten modificadores. Los más habituales son:</p> <ul> <li><strong>Los códigos numéricos como “%i” o “%f”</strong> permiten insertar modificadores de longitud como “l” (longitud doble) o “h” (longitud corta). Así, por ejemplo, “%ld” indica que se va a imprimir un entero de longitud doble (long int); “%hu” sirve para enteros cortos sin signo (unsigned short int); “%lf” indica que se imprimirá un número real de longitud doble (double), etc.</li> <li><strong>El código “%f”</strong> (números reales) se pueden usar con un modificador de posiciones decimales que se desean mostrar. Por ejemplo, con “%3.4f” obligamos a que se impriman tres dígitos a la izquierda de la coma decimal y cuatro a la derecha. La escritura se justifica a la derecha. Para justificarla a la izquierda se utiliza el modificador “-“, de esta forma: “%-10.4f”.</li> <li><strong>El código “%s”</strong> (cadenas de caracteres) se puede combinar con un especificador de longitud máxima y mínima de la cadena. Por ejemplo, “%4.8s” escribe una cadena de al menos cuatro caracteres y no más de ocho. Si la cadena tiene más, se pierden los que excedan de ocho. También se puede utilizar el modificador “-“ para alinear el texto a la izquierda.</li> </ul> <p>Además de los códigos de formato, en la cadena de formato puede aparecer cualquier texto entremezclado con los códigos. A la hora de escribir en la pantalla, los códigos serán sustituidos por los datos correspondientes. Por ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">x</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">.</span><span class="mi">33</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"El número entero es %i y el real es %f"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</code></pre></div></div> <p>Lo que aparecerá en la pantalla al ejecutar este fragmento de código será:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>El número entero es 5 y el real es 10.33
</code></pre></div></div> <p>Una última observación sobre <em>printf()</em>: hay ciertos caracteres que no son directamente imprimibles desde el teclado. Uno de ellos es el <strong>salto de línea</strong>. Para poder ordenar a <em>printf()</em> que escriba un salto de línea (o cualquier otro carácter no imprimible) se utilizan los códigos de barra invertida, que con códigos especiales precedidos del carácter “".</p> <p>En concreto, el carácter “salto de línea” se indica con el código “\n”. Observa las diferencias entre estos dos bloques de instrucciones para intentar comprender la importancia del salto de línea:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"La variable a vale %i"</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"La variable a vale %i"</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div></div> <p>El resultado en la pantalla de la ejecución de estas instrucciones es:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>La variable a vale 5La variable a vale 14
</code></pre></div></div> <p>Veamos el mismo ejemplo usando el código del salto de línea (\n):</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"La variable a vale %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"La variable a vale %i"</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div></div> <p>El resultado en la pantalla será:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>La variable a vale 5
La variable a vale 14

</code></pre></div></div> <h4 id="entrada-de-datos-con-scanf"> <a href="#entrada-de-datos-con-scanf" class="anchor-heading" aria-labelledby="entrada-de-datos-con-scanf"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Entrada de datos con scanf() </h4> <p>La función <em>scanf()</em> es, en muchos sentidos, la inversa de <em>printf()</em>. Puede leer desde el dispositivo de entrada estándar (normalmente el teclado) datos de cualquier tipo de los manejados por el compilador, convirtiéndolos al formato interno apropiado. Funciona de manera análoga a <em>printf()</em>, por lo que su sintaxis es:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scanf</span><span class="p">(</span><span class="n">cadena_de_formato</span><span class="p">,</span> <span class="n">datos</span><span class="p">);</span>
</code></pre></div></div> <p>El prototipo de <em>scanf()</em> se encuentra en el archivo de cabecera <strong>&lt;stdio.h&gt;</strong>, como <em>printf()</em>.</p> <p>La <em>cadena_de_formato</em> tiene la misma composición que la de printf(). Los datos son las variables donde se desea almacenar el dato o datos leidos desde el teclado. <strong>¡Cuidado!</strong> Con los tipos simples, es necesario utilizar el operador &amp; delante del nombre de la variable, porque esa variable se pasa por referencia a <em>scanf()</em> para que ésta pueda modificarla.</p> <p>Por ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">x</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Escribe un número entero:"</span><span class="p">);</span>
<span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Ahora escribe un número entero y un número real:"</span><span class="p">);</span>
<span class="n">scanf</span><span class="p">(</span><span class="s">"%d%f"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Escribe una cadena:"</span><span class="p">);</span>
<span class="n">scanf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
</code></pre></div></div> <p>La función <em>scanf()</em> tiene alguna otra funcionalidad añadida para el manejo de cadenas de caracteres que ya veremos en su momento.</p> <h4 id="ejemplo-de-uso-de-scanf-y-printf"> <a href="#ejemplo-de-uso-de-scanf-y-printf" class="anchor-heading" aria-labelledby="ejemplo-de-uso-de-scanf-y-printf"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ejemplo de uso de scanf() y printf() </h4> <p>Debido a la relativa complejidad de estas funciones de entrada y salida, vamos a presentar un pequeño ejemplo de traducción de pseudocódigo a C. Se trata de un algoritmo que lee dos números enteros, A y B. Si A es mayor que B los resta, y en otro caso los suma.</p> <p>Observa detenidamente la correspondencia entre cada pareja de instrucciones, especialmente las de entrada y salida.</p> <p><strong>Pseudocódigo:</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>algoritmo suma_y_resta
   definir a, b como entero
   escribir "Introduzca dos números enteros";
   leer a
   leer b
   si a &lt; b entonces
       escribir "La suma de a y b es:", a+b
   sino
       escribir "La resta de a menos b es:", a–b
finAlgoritmo
</code></pre></div></div> <p><strong>Lenguaje C:</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Programa suma y resta */</span>
<span class="cp">#include stdio.h
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>   
  <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">"Introduzca dos números enteros</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">"%d%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)</span> 
     <span class="n">printf</span><span class="p">(</span><span class="s">"La suma de %d y %d es: %d"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">);</span>
  <span class="k">else</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">"La resta de %d menos %d es: %d"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="err">–</span><span class="n">b</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="funciones-para-es-simple-por-consola"> <a href="#funciones-para-es-simple-por-consola" class="anchor-heading" aria-labelledby="funciones-para-es-simple-por-consola"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Funciones para E/S simple por consola </h4> <p>Técnicamente, con <em>printf()</em> y <em>scanf()</em> es posible escribir y leer cualquier tipo de datos desde cualquier dispositivo de salida o entrada, no solo la pantalla y el teclado.</p> <p>En la práctica, aunque <em>printf()</em> resulta bastante efectiva y versátil, <em>scanf()</em> puede darte muchos dolores de cabeza. Para hacerte una idea, sólo tienes que probar a hacer un <em>scanf()</em> de un número entero e inmediatamente después otro <em>scanf()</em> de una cadena de caracteres. El segundo <em>scanf()</em> fallará. La razón es bastante rocambolesca: el flujo de entrada no consumirá el carácter de retorno de carro al leer el número entero, por lo que dicho carácter se adjudicará al segundo <em>scanf()</em> automáticamente.</p> <p>Por suerte, <strong>existe otro grupo de funciones en ANSI C específicamente diseñadas para hacer la E/S por consola</strong>, es decir, por teclado y pantalla, de manera más simple. Las resumimos en el siguiente cuadro.</p> <p>Los prototipos de estas funciones, como el de <em>scanf()</em>, se encuentran en el archivo de cabecera <strong><em>stdio.h</em></strong>, así que tendrás que incluirlo en tu código para poder usarlas.</p> <ul> <li> <p><strong><em>getchar()</em></strong>: Espera a que se pulse una tecla seguida de INTRO y devuelve su valor. Muestra el eco en la pantalla, es decir, la tecla pulsada aparece en la pantalla.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">char</span> <span class="n">car</span><span class="p">;</span>
 <span class="n">car</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">();</span>
 <span class="n">printf</span><span class="p">(</span><span class="s">"Tecla pulsada:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
</code></pre></div> </div> </li> <li><strong><em>putchar(c)</em></strong>: Escribe el carácter <em>c</em> en la pantalla.</li> <li> <p><strong><em>gets(cadena)</em></strong>: Lee del teclado una cadena de caracteres seguida de INTRO.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">char</span> <span class="n">cadena</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
 <span class="n">gets</span><span class="p">(</span><span class="n">cadena</span><span class="p">);</span>
 <span class="n">printf</span><span class="p">(</span><span class="s">"Cadena tecleada:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
 <span class="n">puts</span><span class="p">(</span><span class="n">cadena</span><span class="p">);</span>
</code></pre></div> </div> </li> <li><strong><em>puts(cadena)</em></strong>: Escribe una cadena de caracteres en la pantalla (ver ejemplo anterior).</li> </ul> <p>Por lo tanto, <strong>para evitar los problemas que a menudo causa <em>scanf()</em>, podemos recurrir a <em>gets()</em></strong> para leer las cadenas de caracteres. Si necesitamos leer un número, podemos usar <em>gets()</em> y luego <strong>convertir la cadena</strong> a un tipo de dato numérico con las funciones de conversión <em>atoi()</em> y <em>atof()</em>, como se muestra en el siguiente ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">cadena</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">x</span><span class="p">;</span>

<span class="n">gets</span><span class="p">(</span><span class="n">cadena</span><span class="p">);</span>      <span class="c1">// Leemos una cadena de caracteres</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">cadena</span><span class="p">);</span>  <span class="c1">// Convertimos la cadena en un número entero</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">atof</span><span class="p">(</span><span class="n">cadena</span><span class="p">);</span>  <span class="c1">// Convertimos la cadena en un número real</span>
</code></pre></div></div> <p>Las funciones de conversión <em>atoi()</em> y <em>atof()</em> tratarán de convertir la cadena en un número, si ello es posible (es decir, si la cadena realmente contiene números).</p> <p>Pero cuidado: si se teclean más caracteres de los que caben en la cadena, el resultado es imprevisible (a menudo el programa fallará durante la ejecución). Esto puede solucionarse utilizando <em>fgets()</em> en lugar de <em>gets()</em>, que es una función más compleja y no vamos a explicar aquí. Puedes buscar información en internet si te interesa el tema.</p> <p>Tal vez pienses que resulta demasiado complicado hacer algo muy simple como una entrada de datos por teclado. Tienes razón. Pero ten en cuenta dos cosas: las entradas de datos nunca son simples (son el punto donde el usuario interacciona con más libertad con el programa, y los usuarios humanos tendemos a hacer cosas impredecibles y complicadas), y C es un lenguaje de nivel intermedio más que de alto nivel, por lo que muchas tareas de alto nivel, simplemente, no las resolverá por nosotros. En ese sentido, C requiere del programador prestar atención a ciertos detalles que podría obviar en otros lenguajes.</p> <h3 id="9210-cadenas-de-caracteres"> <a href="#9210-cadenas-de-caracteres" class="anchor-heading" aria-labelledby="9210-cadenas-de-caracteres"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.2.10. Cadenas de caracteres </h3> <p>Las <strong>cadenas</strong> de caracteres en C son, en realidad, <strong>arrays de caracteres</strong>.</p> <p>Aunque veremos los arrays en el próximo apartado, si ya sabes pseudocódigo quizá no te sorprenda saber que una cadena se declara así:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">cadena</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>		<span class="cm">/* Declaración de una cadena de 50 caracteres */</span>
</code></pre></div></div> <p>La cadenas tienen ciertas peculiaridades que comentaremos en este apartado, pero todo lo que digamos en el siguiente sobre arrays también será aplicable a las cadenas.</p> <h4 id="declaración-y-manipulación-de-cadenas"> <a href="#declaración-y-manipulación-de-cadenas" class="anchor-heading" aria-labelledby="declaración-y-manipulación-de-cadenas"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Declaración y manipulación de cadenas </h4> <p>Las cadenas pueden manipularse elemento por elemento, como cualquier array. Por ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">cadena</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
<span class="n">cadena</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'H'</span><span class="p">;</span>
<span class="n">cadena</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'o'</span><span class="p">;</span>
<span class="n">cadena</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'l'</span><span class="p">;</span>
<span class="n">cadena</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'a'</span><span class="p">;</span>
</code></pre></div></div> <p>Las cadenas deben tener, después de su último carácter válido, un carácter especial llamado <strong>nulo</strong>. Este carácter marca el final de la cadena. El carácter nulo se simboliza con <strong>el código \0</strong>. Por lo tanto, en el ejemplo anterior habría que agregar la siguiente línea para que la cadena estuviera completa:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cadena</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
</code></pre></div></div> <p><strong>Todas las cadenas deben terminar en un carácter nulo</strong>. De lo contrario, podemos tener problemas al imprimirlas en la pantalla o al realizar con ellas cualquier otro proceso. En consecuencia, en una cadena definida como la anterior, de 50 caracteres, en realidad sólo tienen cabida 49, ya que siempre hay que reservar una posición para el carácter nulo.</p> <p>La declaración de una cadena puede ir acompañada de una inicialización mediante una constante. En este caso, la constante debe ir encerrada entre comillas dobles, al tratarse de una cadena y no de caracteres sueltos. Por ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">cadena</span><span class="p">[</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Hola"</span><span class="p">;</span>
</code></pre></div></div> <p>En inicializaciones de este tipo, el compilador se encarga de añadir el carácter nulo. Por último, señalemos que no es necesario indicar el tamaño de la cadena si se inicializa al mismo tiempo que se declara. Por ejemplo, la declaración anterior puede sustituirse por esta otra:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">cadena</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"Hola"</span><span class="p">;</span>
</code></pre></div></div> <p>Esto se denomina array de longitud indeterminada. El compilador, al encontrar una declaración así, crea una cadena del tamaño suficiente para contener todos los caracteres. Esto vale no sólo para las cadenas, sino que también es aplicable a cualquier otro tipo de array que se inicialice al mismo tiempo que se declare.</p> <h4 id="funciones-para-manejo-de-cadenas"> <a href="#funciones-para-manejo-de-cadenas" class="anchor-heading" aria-labelledby="funciones-para-manejo-de-cadenas"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Funciones para manejo de cadenas </h4> <p>La mayor parte de las veces las cadenas son manipuladas mediante el uso de funciones de librería específicas. En este apartado comentaremos las más comunes.</p> <p><strong>Funciones de lectura y escritura</strong></p> <p>Para leer por teclado una cadena de caracteres se puede utilizar también la función <em>scanf()</em> con la cadena de formato “%s”. Como las cadenas son arrays, no es preciso anteponer el símbolo &amp; al nombre de la variable. Sin embargo, es preferible emplear la función <strong><em>gets()</em></strong> por estar específicamente diseñada para la lectura de cadenas. Por ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">cadena</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Introduzca su nombre "</span><span class="p">);</span>
<span class="n">gets</span><span class="p">(</span><span class="n">cadena</span><span class="p">);</span>
</code></pre></div></div> <p>Tanto <em>scanf()</em> como <strong>gets()</strong> insertan automáticamente el carácter “\0” al final de la cadena.</p> <p>De manera análoga podemos emplear la función <em>printf()</em> para escribir el contenido de una cadena en la pantalla, pero preferiremos la función <strong><em>puts()</em></strong>, específica de las cadenas. Por ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">cadena</span><span class="p">[</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Hola, mundo"</span><span class="p">;</span>
<span class="n">puts</span><span class="p">(</span><span class="n">cadena</span><span class="p">);</span>
</code></pre></div></div> <h4 id="funciones-de-tratamiento-de-cadenas"> <a href="#funciones-de-tratamiento-de-cadenas" class="anchor-heading" aria-labelledby="funciones-de-tratamiento-de-cadenas"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Funciones de tratamiento de cadenas </h4> <p>Las funciones de librería ANSI C para manejar cadenas suelen empezar por las letras “str” (de “string”, que significa “cadena” en inglés) y utilizan el archivo de cabecera <strong><em>string.h</em></strong>.</p> <p>Entre las funciones más habituales encontramos las siguientes:</p> <ul> <li> <p><strong><em>strcpy()</em></strong>: Copia el contenido de una cadena en otra, incluyendo el carácter nulo. Su sintaxis es:</p> <p>El siguiente ejemplo es otra versión (artificialmente enrevesada) del “hola, mundo”:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">char</span> <span class="n">cad1</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
 <span class="kt">char</span> <span class="n">cad2</span><span class="p">[</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Hola"</span><span class="p">;</span>
 <span class="n">strcpy</span><span class="p">(</span><span class="n">cad1</span><span class="p">,</span> <span class="n">cad2</span><span class="p">);</span>
 <span class="n">strcpy</span><span class="p">(</span><span class="n">cad2</span><span class="p">,</span> <span class="s">"mundo"</span><span class="p">);</span>
 <span class="n">printf</span><span class="p">(</span><span class="s">"%s, %s"</span><span class="p">,</span> <span class="n">cad1</span><span class="p">,</span> <span class="n">cad2</span><span class="p">);</span>
</code></pre></div> </div> </li> <li> <p><strong><em>strlen()</em></strong>: Devuelve la longitud de una cadena, es decir, el número de caracteres de que consta, sin contar el carácter nulo. Por ejemplo, en este fragmento de código el resultado debe ser 11. Fíjate que la variable cadena tiene una longitud total de 50 caracteres, pero <em>strlen()</em> sólo cuenta los que efectivamente se están usando, es decir, los que hay hasta el carácter nulo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">char</span> <span class="n">cadena</span><span class="p">[</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Hola, mundo"</span><span class="p">;</span>
 <span class="kt">int</span> <span class="n">longitud</span><span class="p">;</span>
 <span class="n">longitud</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">cadena</span><span class="p">);</span>
 <span class="n">printf</span><span class="p">(</span><span class="s">"La longitud es %i"</span><span class="p">,</span> <span class="n">longitud</span><span class="p">);</span>
</code></pre></div> </div> </li> <li> <p><strong><em>strcmp()</em></strong>: Compara dos cadenas. Devuelve el valor 0 si son iguales, un valor mayor que 0 si la primera es alfabéticamente mayor que la segunda, o un valor menor que 0 en caso contrario. Por ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">char</span> <span class="n">cad1</span><span class="p">[</span><span class="mi">50</span><span class="p">],</span> <span class="n">cad2</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
 <span class="kt">int</span> <span class="n">comparacion</span><span class="p">;</span>
 <span class="n">printf</span><span class="p">(</span><span class="s">"Introduzca dos cadenas"</span><span class="p">);</span>
 <span class="n">scanf</span><span class="p">(</span><span class="s">"%s %s"</span><span class="p">,</span> <span class="n">cad1</span><span class="p">,</span> <span class="n">cad2</span><span class="p">);</span>
 <span class="n">comparacion</span> <span class="o">=</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">cad1</span><span class="p">,</span> <span class="n">cad2</span><span class="p">);</span>
 <span class="k">if</span> <span class="p">(</span><span class="n">comparacion</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Las dos cadenas son iguales"</span><span class="p">);</span>
</code></pre></div> </div> </li> <li> <p><strong><em>strcat()</em></strong>: Concatena dos cadenas. Esta función añade la <em>cadena2</em> al final de la <em>cadena1</em>, incluyendo el carácter nulo. El resultado del siguiente ejemplo debe ser, otra vez, “hola, mundo”:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">char</span> <span class="n">cad1</span><span class="p">[</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Hola, "</span><span class="p">;</span>
 <span class="kt">char</span> <span class="n">cad2</span><span class="p">[</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="s">"mundo"</span><span class="p">;</span>
 <span class="n">strcat</span><span class="p">(</span><span class="n">cad1</span><span class="p">,</span> <span class="n">cad2</span><span class="p">);</span>
 <span class="n">prinft</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">cad1</span><span class="p">);</span>
</code></pre></div> </div> </li> </ul> <h4 id="las-cadenas-y-la-validación-de-los-datos-de-entrada"> <a href="#las-cadenas-y-la-validación-de-los-datos-de-entrada" class="anchor-heading" aria-labelledby="las-cadenas-y-la-validación-de-los-datos-de-entrada"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Las cadenas y la validación de los datos de entrada </h4> <p>Una de las principales fuentes de error de los programas son los datos de entrada incorrectos. Por ejemplo, si un programa está preparado para leer un número entero pero el usuario, por error o por mala fe, introduce un carácter, la función <em>scanf()</em> fallará y el programa se detendrá.</p> <p>En otros lenguajes de más alto nivel, el propio lenguaje tiene mecanismos para prevenir estos errores. Pero recuerda que C es un lenguaje de nivel intermedio, pensado para producir código máquina supereficiente y rápido. El precio a pagar por ello es que el lenguaje no hará ninguna comprobación de este tipo de errores: es responsabilidad del programador preverlos.</p> <p>Hay un modo bastante sencillo de hacer esto: <strong>leer todos los datos de entrada como cadenas y, luego, convertirlos al tipo de dato adecuado</strong>.</p> <p>Observa el siguiente ejemplo. Sirve para leer un número entero por teclado, pero previniendo los errores provocados por el usuario que antes mencionábamos. Se utiliza la función <em>atoi()</em>, que convierte una cadena a un número entero:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">n</span><span class="p">;</span>		<span class="c1">// El número entero que se pretende leer por teclado</span>
<span class="kt">char</span> <span class="n">cad</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>	<span class="c1">// La cadena que se usará para prevenir errores de lectura</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Introduzca un número entero"</span><span class="p">);</span>
<span class="n">gets</span><span class="p">(</span><span class="n">cad</span><span class="p">);</span>		<span class="c1">// No se lee un número entero, sino una cadena</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">cad</span><span class="p">);</span>	<span class="c1">// Se convierte la cadena a entero</span>
</code></pre></div></div> <h3 id="9211-arrays"> <a href="#9211-arrays" class="anchor-heading" aria-labelledby="9211-arrays"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.2.11. Arrays </h3> <p>Un <strong>array</strong>, como ya vimos en pseudocódigo, es una agrupación de muchos datos individuales del mismo tipo bajo el mismo nombre. Cada dato individual de un array es accesible mediante un <strong>índice</strong>.</p> <p>El caso más simple de array es el <strong>array unidimensional</strong>. Por ejemplo, un array unidimensional de números enteros es una colección de muchos números enteros a los que les adjudicamos un único identificador.</p> <h4 id="declaración-de-arrays"> <a href="#declaración-de-arrays" class="anchor-heading" aria-labelledby="declaración-de-arrays"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Declaración de arrays </h4> <p>La declaración de un array en C se hace así:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tipo_de_datos</span> <span class="n">nombre_array</span><span class="p">[</span><span class="n">n</span><span class="err">ú</span><span class="n">mero_de_elementos</span><span class="p">];</span>
</code></pre></div></div> <p>Por ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">serie</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</code></pre></div></div> <p>La variable <em>serie</em> será un array que contendrá 10 números enteros. Los 10 números reciben el mismo nombre, es decir, <em>serie</em>. Se puede acceder a cada uno de los números que forman el array escribiendo a continuación del nombre un número entre corchetes. Ese número se denomina índice. Lo puedes ver en el siguiente ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">serie</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="n">serie</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="n">serie</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
<span class="n">serie</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">serie</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">serie</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="n">serie</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
</code></pre></div></div> <p>El array <em>serie</em> puede almacenar hasta 10 números enteros. Las posiciones empiezan a numerarse en el 0, así que <em>serie[2]</em> se refiere, en realidad, a la tercera posición. En ella se almacena el número 20. En la cuarta posición (<em>serie[3]</em>) se almacena el número 15. Luego se suman ambos valores, y el resultado se almacena en la quinta posición (<em>serie[4]</em>). Finalmente, se imprime en la pantalla el resultado de la suma, es decir, 35.</p><pre>
            +------------+----+----+----+----+----+
            | Posiciones |  0 |  1 |  2 |  3 |  4 |
    serie = +------------+----+----+----+----+----+
            | Valores    |  ? |  ? | 20 | 15 | 35 |
            +------------+----+----+----+----+----+
</pre><p>C no realiza comprobación de los índices de los arrays, por lo que es perfectamente posible utilizar un índice fuera del rango válido (por ejemplo, <em>serie[17]</em>). Es responsabilidad del programador evitar que esto ocurra, porque los efectos serán desastrosos para el programa.</p> <p>Como es lógico, se pueden construir arrays cuyos elementos sean de cualquier otro tipo simple, como <em>float</em> o <em>double</em>, con la única restricción de que todos los elementos sean del mismo tipo. Los arrays de caracteres se denominan <strong>cadenas de caracteres</strong>, y ya hablamos de ellos en el apartado anterior.</p> <p>También es posible construir arrays cuyos elementos sean de un tipo complejo. Así, podemos tener arrays de arrays o de otros tipos que no vamos a estudiar en este curso de introducción.</p> <h4 id="manipulación-de-los-elementos-individuales-de-un-array"> <a href="#manipulación-de-los-elementos-individuales-de-un-array" class="anchor-heading" aria-labelledby="manipulación-de-los-elementos-individuales-de-un-array"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Manipulación de los elementos individuales de un array </h4> <p>Los arrays en C deben manipularse elemento a elemento. No se pueden modificar todos los elementos a la vez.</p> <p>Para asignar valores a los elementos de un array, por lo tanto, el mecanismo es este:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">serie</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="n">serie</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">serie</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">serie</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="p">...</span><span class="n">etc</span><span class="p">...</span>
</code></pre></div></div> <p>La inicialización de los valores de un array también puede hacerse conjuntamente en el momento de declararlo, así:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">serie</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">14</span><span class="p">};</span>
</code></pre></div></div> <p>El resultado de esta declaración será un array de 5 elementos de tipo entero a los que se les asigna los valores 5, 3, 7, 9 y 14.</p> <p>Cada elemento del array es, a todos los efectos, una variable que puede usarse independientemente de los demás elementos. Así, por ejemplo, un elemento del array serie puede usarse en una instrucción de salida igual que cualquier variable simple de tipo <em>int</em>:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">serie</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="n">serie</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="n">serie</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</code></pre></div></div> <p>Del mismo modo, pueden usarse elementos de array en una instrucción de entrada. Por ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">serie</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="n">scanf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">serie</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">serie</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">serie</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">15</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="n">serie</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</code></pre></div></div> <h4 id="recorrido-de-un-array"> <a href="#recorrido-de-un-array" class="anchor-heading" aria-labelledby="recorrido-de-un-array"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Recorrido de un array </h4> <p>Una forma habitual de manipular un array es <strong>acceder secuencialmente</strong> a todos sus elementos, uno tras otro.</p> <p>Para ello, <strong>se utiliza un bucle con contador</strong>, de modo que la variable contador nos sirve como índice para acceder a cada uno de los elementos del array.</p> <p>Supongamos, por ejemplo, que tenemos un array de 10 números enteros declarado como <code class="language-plaintext highlighter-rouge">int v[10]</code> y una variable entera declarada como <code class="language-plaintext highlighter-rouge">int i</code>. Por medio de un bucle, con ligeras modificaciones, podemos realizar todas estas operaciones:</p> <p><strong>1) Inicializar todos los elementos a un valor cualquiera</strong> (por ejemplo, 0):</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>2) Inicializar todos los elementos con valores introducidos por teclado</strong>:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">"Escribe el valor del elemento nº %i: "</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
   <span class="n">scanf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>3) Mostrar todos los elementos en la pantalla</strong>:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">"El elemento nº %i vale %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>4) Realizar alguna operación que implique a todos los elementos</strong>. Por ejemplo, sumarlos:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">suma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">suma</span> <span class="o">=</span> <span class="n">suma</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="arrays-y-funciones"> <a href="#arrays-y-funciones" class="anchor-heading" aria-labelledby="arrays-y-funciones"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Arrays y funciones </h4> <p>Para <strong>pasar un array como argumento</strong> a una función, en la llamada a la función se escribe simplemente el nombre del array, sin índices.</p> <p>Los arrays en C <strong>siempre se pasan por referencia</strong>, nunca por valor. Por lo tanto, si algún elemento del array se modifica en una función, también será modificado en la función desde la que fue invocada.</p> <p>Como siempre se pasan por referencia, no es necesario utilizar el símbolo &amp; delante del parámetro.</p> <p>Por ejemplo, supongamos que <em>serie</em> es un array de 15 números enteros. Para pasarlo como parámetro a una función llamada <em>funcion1()</em> escribiríamos simplemente esto:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">serie</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span>
<span class="n">funcion1</span><span class="p">(</span><span class="n">serie</span><span class="p">);</span>
</code></pre></div></div> <p>En cuanto a la declaración de la función, el parámetro de tipo array se especifica esta maneras:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">funcion1</span> <span class="p">(</span><span class="kt">int</span> <span class="n">serie</span><span class="p">[</span><span class="mi">15</span><span class="p">])</span> <span class="p">{</span>
   <span class="p">...</span><span class="n">c</span><span class="err">ó</span><span class="n">digo</span> <span class="n">de</span> <span class="n">la</span> <span class="n">funci</span><span class="err">ó</span><span class="n">n</span><span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>Dentro de la función, el array <em>serie</em> puede usarse del mismo modo que en el programa que la llama, es decir, no es preciso utilizar el operador asterisco ni nada por el estilo.</p> <h4 id="un-programa-de-ejemplo-que-usa-arrays-y-funciones"> <a href="#un-programa-de-ejemplo-que-usa-arrays-y-funciones" class="anchor-heading" aria-labelledby="un-programa-de-ejemplo-que-usa-arrays-y-funciones"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Un programa de ejemplo que usa arrays y funciones </h4> <p>Para ilustrar todo esto, te muestro programa que sirve para leer 50 números por teclado y calcular la suma, la media y la desviación típica de todos los valores.</p> <p>Lee el código detenidamente, prestando sobre todo atención al uso de los arrays y a cómo se pasan como parámetros.</p> <p>Los números de la serie se almacenarán en un array de tipo <em>float</em> de 50 posiciones llamado <em>valores</em>. La introducción de datos en el array se hace en la función <em>introducir_valores()</em>. Como los arrays siempre se pasan por referencia, al modificar el array <em>valores</em> dentro de la función, también se modificará en el algoritmo principal.</p> <p>Después, se llama a 3 funciones que calculan las tres magnitudes (suma, media y desviación). El array también se pasa por referencia a estas funciones, ya que en C no hay modo de pasar un array por valor.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;math.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">float</span> <span class="n">valores</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
	<span class="kt">float</span> <span class="n">suma</span><span class="p">,</span> <span class="n">media</span><span class="p">,</span> <span class="n">desviacion</span><span class="p">;</span>
	
	<span class="n">introducir_valores</span><span class="p">(</span><span class="n">valores</span><span class="p">);</span>
	<span class="n">suma</span> <span class="o">=</span> <span class="n">calcular_suma</span><span class="p">(</span><span class="n">valores</span><span class="p">);</span>	
	<span class="n">media</span> <span class="o">=</span> <span class="n">calcular_media</span><span class="p">(</span><span class="n">valores</span><span class="p">,</span> <span class="n">suma</span><span class="p">);</span>
	<span class="n">desviacion</span> <span class="o">=</span> <span class="n">calcular_desviacion</span><span class="p">(</span><span class="n">valores</span><span class="p">,</span> <span class="n">media</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"La suma es %f, la media es %f y la desviación es %f"</span><span class="p">,</span> <span class="n">suma</span><span class="p">,</span> <span class="n">media</span><span class="p">,</span> <span class="n">desviacion</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Lee 50 números y los almacena en el array N pasado por referencia */</span>
<span class="kt">void</span> <span class="nf">introducir_valores</span><span class="p">(</span><span class="kt">float</span> <span class="n">n</span><span class="p">[</span><span class="mi">50</span><span class="p">])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">49</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Introduzca el valor nº %d: "</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">"%f"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Devuelve la suma todos los elementos del array n */</span>
<span class="kt">float</span> <span class="nf">calcular_suma</span><span class="p">(</span><span class="kt">float</span> <span class="n">n</span><span class="p">[</span><span class="mi">50</span><span class="p">])</span>	
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">suma</span><span class="p">;</span>
	<span class="n">suma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">49</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">suma</span> <span class="o">=</span> <span class="n">suma</span> <span class="o">+</span> <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">suma</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Devuelve el valor medio de los elementos del array n. Necesita conocer la suma de los elementos para calcular la media */</span>
<span class="kt">float</span> <span class="nf">calcular_media</span><span class="p">(</span><span class="kt">float</span> <span class="n">n</span><span class="p">[</span><span class="mi">50</span><span class="p">],</span> <span class="kt">float</span> <span class="n">suma</span><span class="p">)</span>	
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">media</span><span class="p">;</span>
	<span class="n">media</span> <span class="o">=</span> <span class="n">suma</span> <span class="o">/</span> <span class="mi">50</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">media</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Calcula la desviación típica de los elementos del array n. Necesita conocer la media para hacer los cálculos */</span>
<span class="kt">float</span> <span class="nf">calcular_desviacion</span><span class="p">(</span><span class="kt">float</span> <span class="n">n</span><span class="p">[</span><span class="mi">50</span><span class="p">],</span> <span class="kt">float</span> <span class="n">media</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">diferencias</span><span class="p">;</span>
	<span class="n">diferencias</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">49</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">diferencias</span> <span class="o">=</span> <span class="n">diferencias</span> <span class="o">+</span> <span class="n">abs</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="err">–</span> <span class="n">media</span><span class="p">)</span> <span class="p">;</span>
	<span class="n">diferencias</span> <span class="o">=</span> <span class="n">diferencias</span> <span class="o">/</span> <span class="mi">50</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">diferencias</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="9212-funciones-de-la-librería-estándar"> <a href="#9212-funciones-de-la-librería-estándar" class="anchor-heading" aria-labelledby="9212-funciones-de-la-librería-estándar"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.2.12. Funciones de la librería estándar </h3> <p>La siguiente lista resume algunas funciones de uso frecuente de ANSI C. Para cada función se muestra su prototipo y se explica brevemente cuál es su cometido y cuáles sus datos de entrada y salida. También se indica el archivo de cabecera donde se encuentra el prototipo.</p> <p>Debes tener en cuenta que ANSI C dispone de muchas otras funciones. Si en algún momento las necesitas, una búsqueda rápida por internet te proporcionará información de sobra. Eso sí, asegúrate que la función que vayas a usar pertenezca al estándar ANSI C. Solo así tendrás la garantía de que tu compilador la reconocerá y de que tu programa será portable a otros sistemas.</p> <p><strong>Funciones de entrada/salida</strong></p> <div class="table-wrapper"><table> <thead> <tr> <th>Función</th> <th>Prototipo</th> <th>Utilidad</th> <th>Archivo de cabecera</th> </tr> </thead> <tbody> <tr> <td><strong><em>getchar()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">int getchar(void)</code></td> <td>Devuelve un carácter leido por teclado mostrando el eco. Es necesario pulsar INTRO</td> <td>stdio.h</td> </tr> <tr> <td><strong><em>gets()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">char* gets(char* cadena)</code></td> <td>Lee una cadena de caracteres del dispositivo estándar de entrada y la sitúa en la posición apuntada por cadena</td> <td>stdio.h</td> </tr> <tr> <td><strong><em>printf()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">int printf(const char* formato, lista_argumentos)</code></td> <td>Salida estándar con formato. Véase el texto del capítulo para más detalles</td> <td>stdio.h</td> </tr> <tr> <td><strong><em>putchar()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">int putchar(int carácter)</code></td> <td>Escribe carácter en la pantalla</td> <td>stdio.h</td> </tr> <tr> <td><strong><em>puts()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">int puts(const char* cadena)</code></td> <td>Escribe cadena en el dispositivo estándar de salidastdio.h</td> <td> </td> </tr> <tr> <td><strong><em>scanf()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">int scanf(const char* formato, lista_argumentos)</code></td> <td>Entrada estándar con formato. Véase el texto del capítulo para más detalles</td> <td>stdio.h</td> </tr> </tbody> </table></div> <p><strong>Funciones de caracteres</strong></p> <div class="table-wrapper"><table> <thead> <tr> <th>Función</th> <th>Prototipo</th> <th>Utilidad</th> <th>Archivo de cabecera</th> </tr> </thead> <tbody> <tr> <td><strong><em>isalnum()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">int isalnum(int carácter)</code></td> <td>Devuelve 1 si el carácter es alfanumérico (letra o número), o 0 si no lo es</td> <td>ctype.h</td> </tr> <tr> <td><strong><em>isalpha()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">int isalpha(int carácter)</code></td> <td>Devuelve 1 si el carácter es alfabético (una letra mayúscula o minúscula), o 0 si no lo es</td> <td>ctype.h</td> </tr> <tr> <td><strong><em>isdigit()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">int isdigit(int carácter)</code></td> <td>Devuelve 1 si el carácter es numérico, o 0 si no lo es</td> <td>ctype.h</td> </tr> <tr> <td><strong><em>isupper()</em></strong> e <strong><em>islower()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">int isupper(int carácter); int islower(int carácter);</code></td> <td>La primera devuelve 1 si el carácter es una letra mayúscula y 0 en otro caso. La segunda, al revés</td> <td>ctype.h</td> </tr> </tbody> </table></div> <p><strong>Funciones matemáticas</strong></p> <div class="table-wrapper"><table> <thead> <tr> <th>Función</th> <th>Prototipo</th> <th>Utilidad</th> <th>Archivo de cabecera</th> </tr> </thead> <tbody> <tr> <td><strong><em>abs()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">int abs(int número)</code></td> <td>Devuelve el valor absoluto de número</td> <td>stdlib.h</td> </tr> <tr> <td><strong><em>cos()</em></strong><br /><strong><em>sin()</em></strong><br /><strong><em>tan()</em></strong><br /><strong><em>acos()</em></strong><br /><strong><em>asin()</em></strong><br /><strong><em>atan()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">double acos(double argumento)</code></td> <td>Todas tienen un prototipo similar. Calculan y devuelven, respectivamente, el arcocoseno, el arcoseno, el arcotangente, el coseno, el seno y la tangente de argumento. Los ángulos se expresan en radianes</td> <td>math.h</td> </tr> <tr> <td><strong><em>ceil()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">double ceil(double número)</code></td> <td>Redondea número por exceso. P. ej: ceil(3.2) devuelve 4</td> <td>math.h</td> </tr> <tr> <td><strong><em>exp()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">double exp(double potencia)</code></td> <td>Calcula el exponencial epotencia</td> <td>math.h</td> </tr> <tr> <td><strong><em>fabs()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">double fabs(double número)</code></td> <td>Devuelve el valor absoluto de número</td> <td>math.h</td> </tr> <tr> <td><strong><em>floor()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">double floor(double número)</code></td> <td>Redondea número por defecto. P. ej: floor(3.8) devuelve 3</td> <td>math.h</td> </tr> <tr> <td><strong><em>log()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">double log(double número)</code></td> <td>Devuelve el logaritmo natural de número</td> <td>math.h</td> </tr> <tr> <td><strong><em>log10()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">double log10(double número)</code></td> <td>Devuelve el logaritmo decimal de número</td> <td>math.h</td> </tr> <tr> <td><strong><em>pow()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">double log(double base, double exp)</code></td> <td>Devuelve la potencia de base elevado a exp</td> <td>math.h</td> </tr> <tr> <td><strong><em>sqrt()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">double sqrt(double número)</code></td> <td>Devuelve la raiz cuadrada de número</td> <td>math.h</td> </tr> </tbody> </table></div> <p><strong>Funciones variadas</strong></p> <div class="table-wrapper"><table> <thead> <tr> <th>Función</th> <th>Prototipo</th> <th>Utilidad</th> <th>Archivo de cabecera</th> </tr> </thead> <tbody> <tr> <td><strong><em>atof()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">double atof(char* cadena)</code></td> <td>Convierte la cadena en un número real. Si la cadena no contiene un número real válido, devuelve 0</td> <td>stdlib.h</td> </tr> <tr> <td><strong><em>atoi()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">int atoi(char* cadena)</code></td> <td>Convierte la cadena en un número entero. Si la cadena no contiene un número entero válido, devuelve 0</td> <td>stdlib.h</td> </tr> <tr> <td><strong><em>atof()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">double atof(char* cadena)</code></td> <td>Convierte la cadena en un número real. Si la cadena no contiene un número real válido, devuelve 0</td> <td>stdlib.h</td> </tr> <tr> <td><strong><em>itoa()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">char* itoa(int número, int base)</code></td> <td>Convierte el número en una cadena. La base de la cadena resultante se determina en base</td> <td>stdlib.h</td> </tr> <tr> <td><strong><em>rand()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">int rand(void)</code></td> <td>Devuelve un número entero al azar entre 0 y RAND_MAX (RAND_MAX es una constante definida en stdlib.h)</td> <td>stdlib.h</td> </tr> <tr> <td><strong><em>randomize()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">void randomize(void)</code></td> <td>Inicializa el generador de números aleatorio. Es necesario invocar esta función si después se va a usar random()</td> <td>stdlib.h</td> </tr> <tr> <td><strong><em>random()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">int random(int máximo)</code></td> <td>Devuelve un número al azar entre 0 y máximo – 1</td> <td>stdlib.h</td> </tr> </tbody> </table></div> <h3 id="9213-librerías-no-estándar-que-molan-ncurses"> <a href="#9213-librerías-no-estándar-que-molan-ncurses" class="anchor-heading" aria-labelledby="9213-librerías-no-estándar-que-molan-ncurses"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.2.13. Librerías no estándar que molan: ncurses </h3> <p>XXX <em>Texto pendiente de revisar</em> XXX</p> <p>4.1 Qué es Ncurses Ncurses es una librería de funciones para el manejo de interfaces basadas en texto. Es decir, se trata de un conjunto de funciones, ya programadas, que podemos utilizar en nuestros programas para mejorar su presentación. Como Ncurses no es una librería estándar de C, es necesario ordenar al compilador que la enlace con nuestro programa. Esto se hace añadiendo la opción –lncurses al comando gcc. Por ejemplo: • gcc holamundo.c: compila holamundo.c sin enlazarlo con la librería Ncurses • gcc –lncurses holamundo.c: compila holamundo.c enlazándolo con Ncurses Además, debemos hacer un #include <ncurses.h> en el programa que vaya a utilizar estas funciones. Ncurses tiene muchísimas funciones, pero nosotros sólo nos referiremos aquí a las más básicas, que nos permitirán añadir color a nuestros textos y controlar libremente la posición del cursor de escritura. Pero Ncurses va mucho más allá, permitiendo la creación de capas de texto superpuestas, menús desplegables y muchas otras cosas en la consola de texto. 4.2 Inicialización de Ncurses Para utilizar las funciones de Ncurses en nuestro programa, basta con que incluyamos la siguiente llamada: initscr(); Esta función crea una ventana de texto. La ventana se llama stdscr (que significa "standard screen", es decir, "pantalla estándar"). A partir de aquí podremos utilizar cualquier función de Ncurses, pues todas actúan sobre esa ventana (se pueden crear varias ventanas sobre stdscr, pero nosotros no profundizaremos en esa posibilidad). Por ejemplo, una función que suele ir justo después es: keypad (stdscr, 1); Esto sirve para activar la recepción de teclas especiales (como F1, F2, ESC, etc). Si no llamamos a keypad(), no podremos utilizar ese tipo de teclas en nuestro programa. El segundo parámetro sirve para activar (1) o desactivar (0) la recepción de teclas especiales. A continuación se enumeran las principales funciones de inicialización de Ncurses: initscr() Inicializa Ncurses y crea la pantalla estándar. Debe ser invocada antes que cualquier otra función de la librería. initscr();</ncurses.h></p> <p>keypad() Activa / desactiva la recepción de teclas especiales, como F1, ESC, Intro, etc. Si activar = 1, se activa la recepción. Si activar = 0, se desactiva. keypad(stdscr, activar); echo() noecho() Activa / desactiva el eco de caracteres. Si el eco está activo, lo que se escriba en el teclado aparece en la pantalla. Si está inactivo, no. echo(); noecho(); cbreak() nocbreak() Activa / desactiva el envío inmediato de teclas. Normalmente, cuando se teclea algo no es enviado al programa hasta que no se pulsa “intro”. La función cbreak() hace que todo cuanto se teclee sea enviado al programa sin necesidad de “intro”. La función nocbreak() desactiva este comportamiento cbreak(); nocbreak(); nodelay() Activa / desactiva la espera para lectura de teclado. Las funciones para leer un solo carácter, como getch(), detienen la ejecución del programa hasta que se pulsa alguna tecla. Llamando a esta función con el parámetro activar = 1, conseguiremos que el programa no se detenga en getch() aunque no se pulse tecla alguna. Para desactivarlo, llamaremos a la función con activar = 0. nodelay(stdscr, activar); endwin() Finaliza Ncurses. Hay que llamar a esta función antes de terminar el programa para liberar la memoria ocupada y restaurar la consola al estado inicial. 4.3 Escribir y leer Cuando utilicemos Ncurses debemos olvidarnos de las funciones de entrada/salida estándar, como scanf(), printf(), gets() o puts(). En su lugar usaremos estas otras funciones: printw() putstr() Para escribir usaremos la función printw(), que funciona igual que printf() pero sobre una ventana de Ncurses. También podemos usar putstr(), que es como puts(), es decir, sirve para imprimir cadenas getstr() getch() Para leer disponemos de getstr(), que es como gets(), es decir, sirve para leer cadenas por teclado. De modo que, si queremos leer un número, debemos leerlo como cadena y luego convertirlo a número (con las funciones estándar atoi(), atof(), etc) También podemos usar getch(), que lee un único carácter. move() Para colocar el cursor usaremos move(y,x). Esto ubica el cursor en la columna x y la fila y de la pantalla. ¡Atención! Se indica primero la fila y luego la columna. refresh() Actualiza la pantalla. Es el único modo de asegurarnos de que los cambios realizados se muestren instantáneamente. 4.4 Colores Antes de utilizar los colores hay que inicializarlos llamando a la función start_color() sin argumentos, así: if (has_colors()) start_color(); La llamada previa a has_colors() se realiza para asegurarnos de que nuestra consola soporta el uso de colores. Es raro encontrar una consola que no permita colores, pero existen, así que no está de más hacer la comprobación. Una vez hecho esto, podemos utilizar los colores básicos definidos en ncurses.h, cuyas constantes son: COLOR_BLACK, COLOR_WHITE, COLOR_YELLOW, etc. Para utilizar esos colores se deben agrupar en parejas: un color para el texto junto con un color para el fondo. A cada pareja se le asigna un número a través de la función init_pair(), así: init_pair(1, COLOR_YELLOW, COLOR_BLUE); Esto define a la pareja nº 1 como texto amarillo sobre fondo azul. De este modo podemos definir, por lo general, hasta 64 parejas. Después, para activar una pareja, haremos esta llamada: attron(COLOR_PAIR(1)); Esto activa la pareja de colores nº 1, de manera que todo el texto que aparezca en la pantalla a partir de este momento se verá amarillo con el fondo azul. La función attron(), además de para activar parejas de colores, sirve para cambiar otros atributos del texto. Por ejemplo, lo siguiente se utiliza para escribir en negrita: attron(A_BOLD); Puedes obtener más información sobre attron() en las páginas de manual (escribiendo man attron) 4.5 Ejemplo de uso de Ncurses Para terminar esta breve introducción a la librería Ncurses mostraremos un ejemplo ilustrativo del uso de algunas de las funciones que aquí se han visto. El siguiente programa utiliza Ncurses para escribir el texto HOLA en color rojo sobre fondo azul y el texto MUNDO en color amarillo sobre fondo verde. El texto HOLA aparece en la línea 11, y MUNDO en la 12. Luego, el programa espera hasta que se pulsa la tecla “flecha arriba”, y entonces termina. #include <ncurses.h> int main(void) { char carácter; initscr(); // Inicializa Ncurses keypad(stdscr, 1); // Activa teclas especiales (como las flechas) cbreak(); // Para no tener que pulsar Intro tras cada carácter if (has_colors()) start_color(); // Inicializa colores init_pair(1, COLOR_RED, COLOR_BLUE); // Pareja 1 = Texto rojo, fondo azul init_pair(2, COLOR_YELLOW, COLOR_GREEN); // Pareja 2 = Texto amarillo, fondo verde attron(COLOR_PAIR(1)); // Activa pareja 1 move(11, 1); printw("HOLA"); attron(COLOR_PAIR(2)); // Activa pareja 2 move(12, 1); printw("MUNDO"); do { carácter = getch(); // Lee un carácter desde el teclado } while (carácter != KEY_UP); endwin(); // Finaliza Ncurses return 0; }</ncurses.h></p> <h3 id="9214-librerías-no-estándar-que-molan-sdl"> <a href="#9214-librerías-no-estándar-que-molan-sdl" class="anchor-heading" aria-labelledby="9214-librerías-no-estándar-que-molan-sdl"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.2.14. Librerías no estándar que molan: SDL </h3> <p>XXX <em>Texto pendiente de revisar</em> XXX</p> <p>aplicaciones gráficas con C El siguiente apartado está extraído de mi libro “Ajedrez en C: cómo programar un juego de ajedrez en lenguaje C y que funcione”. Allí se hacía una introducción a la librería SDL para dotar de interfaz gráfico al juego que se pretendía desarrollar. He decidido incluir una adaptación de ese texto en este libro como un apéndice porque la librería SDL es lo suficientemente potente como para merecer la atención de cualquier interesado en el desarrollo en C. SDL (iniciales de Single DirectMedia Layer) es una biblioteca libre, con licencia zlib, disponible para múltiples plataformas (entre ellas, Linux y Windows). Puedes bajarte la última versión de http://www.libsdl.org Esta biblioteca contiene un conjunto muy completo de funciones para manejar gráficos, además de sonidos y distintos dispositivos multimedia (ratón, CD-ROM, etc). Teniendo en cuenta la complejidad intrínseca a estos dispositivos, la librería es razonablemente sencilla de usar. Nosotros sólo nos vamos a centrar en la parte de SDL dedicada a los gráficos. Si quieres más información, en la página web reseñada antes encontrarás una completa documentación. 5.1 Instalación de SDL SDL no es una librería C estándar, es decir, no viene “de serie” con el compilador de C. En realidad, tampoco ncurses lo es, pero su uso está tan extendido en entornos Unix que viene incorporada a las librerías del compilador gcc. En cambio, la librería SDL debe ser instalada antes de poder utilizarla. A continuación describimos el proceso de instalación en Linux y en Windows Instalación de SDL en Linux • Bájate la última versión de la librería de la web de SDL. Necesitarás el paquete de la librería propiamente dicho (denominado runtime) y el paquete de desarrollo. El paquete runtime tiene un nombre similar a este: SDL-x.x.x-1.i386.rpm, donde “x.x.x” es la versión de la libería e “i386” indica para qué tipo de procesador está compilado. El paquete de desarrollo debe llamarse SDL-devel-x.x.x-i386.rpm o algo similar. • Instala ambos paquetes en tu sistema. Con el paquete runtime es suficiente para ejecutar programas que usen la librería SDL, pero si además quieres escribir programas nuevos que usen esta librería (y es nuestro caso), también necesitarás el paquete de desarrollo. Instalación de SDL en Windows • Bájate la última versión de la librería de la web de SDL. Necesitarás la librería de vínculos dinámicos (denominada dll) y el paquete de desarrollo. La librería de vínculos dinámicos suele venir comprimida en un archivo cuyo nombre es similar a: SDL-x.x.x-win32.zip, donde “x.x.x” es la versión de la libería. Existirán varios paquetes de desarrollo para varios compiladores. Mi consejo es que bajes el que está preparado para el compilador de GNU, cuyo nombre es SDL-devel-x.x.x-mingw32.tar o algo similar. También encontrarás paquetes para Visual C++ y otros compiladores. • Descomprime la librería de vínculos dinámicos. Debes obtener un archivo llamado sdl.dll. Copia este archivo al directorio /windows/system32, o bien ubícalo en la misma carpeta en la que vaya a estar el programa ejecutable del ajedrez. • Descomprime el paquete de desarrollo. Encontrarás varios directorios y, dentro de ellos, multitud de archivos. Copia los archivos en los directorios del mismo nombre de tu compilador. Por ejemplo, el copia el directorio “include” del paquete de desarrollo al directorio “include” de la carpeta donde esté instalado tu compilador. Repite la operación para todos los directorios cuyo nombre coincida. 5.2 Compilación y enlace Al no ser SDL una librería estándar, el enlace entre nuestro programa y las funciones de SDL no se produce automáticamente. Hay que indicarle al enlazador (o linker) lo que debe hacer. Compilación y enlace en Linux Si, por ejemplo, nuestro programa ejecutable se llama “ajedrez” y se construye a partir de 3 programas objeto, llamados “ajedrez.o”, “movs.o” e “interfaz.o”, debemos modificar la primera parte de nuestro Makefile de este modo: ajedrez: ajedrez.o movs.o interfaz.o gcc -g <code class="language-plaintext highlighter-rouge">sdl-config –-cflags</code> -o ajedrez ajedrez.o movs.o interfaz.o <code class="language-plaintext highlighter-rouge">sdl-config –-libs</code> Fíjate bien en que las comillas son en realidad acentos graves, es decir, invertidos e inclinados hacia atrás. Debes respetar la sintaxis para que funcione. Eso es todo lo que tienes que hacer para compilar son SDL. Si te interesa saber POR QUÉ, sigue leyendo. Si no, puedes pasar al siguiente apartado. En realidad, lo que hay escrito entre esas comillas invertidas son comandos de SDL que indican la configuración de la librería. Estos comandos los puedes ejecutar desde la consola, obteniendo más o menos esto: $ sdl-config –cflags -I/usr/local/include -I/usr/local/include/SDL -D_REENTRANT $ sdl-config –libs -L/usr/local/lib -lSDL -lpthread Al añadir estos comandos dentro del Makefile, enmarcados entre esas comillas invertidas, obligamos a la herramienta make a ejecutar los comandos y a sustituir el texto entrecomillado por el resultado del comando. Es decir, sería como si hubiéramos puesto esto en el Makefile: ajedrez: ajedrez.o movs.o interfaz.o gcc -g -I/usr/local/include -I/usr/local/include/SDL -D_REENTRANT -o ajedrez ajedrez.o movs.o interfaz.o -L/usr/local/lib -lSDL -lpthread Pero preferiremos la primera forma porque es más corta y, además, funcionará en todas las situaciones, mientras que esta segunda depende de dónde y cómo se haya instalado la librería SDL (fíjate que hace referencia a directorios concretos de nuestro sistema) Compilación y enlace en Windows Lo siguiente sirve para compilar y enlazar con SDL desde el compilador Dev-C++, que tiene licencia GNU y es gratuito. Con otros compiladores el proceso debe ser similar, aunque es posible que necesites bajar otro paquete de desarrollo adaptado al compilador concreto. Para poder compilar y enlazar la libería SDL tienes que abrir las opciones del proyecto (menú “Proyecto”) y activar la pestaña “Parámetros”. En el cuadro con el título “Linker” escribe lo siguiente: -lmingw32 -lSDLmain –lSDL Si has instalado correctamente la librería SDL, con esto debería bastar. Recuerda que el archivo sdl.dll debe estar en la misma carpeta que el programa ejecutable (o, si no, instalado con las liberías del sistema de Windows) 5.3 Inicialización y terminación de la pantalla gráfica Una vez instalada la libería y preparado el compilador, podemos usar las funciones de SDL como cualquier otra función estándar de C. Su uso es exactamente igual en Windows y en Linux, por lo que el programa que obtendremos debería compilar sin necesidad de hacerle ningún cambio en ambos sistemas. Para usar los gráficos, hay que hacer un #include &lt;SDL/SDL.h&gt; en el archivo fuente, como es natural. Aparece dos veces el nombre “SDL” porque el archivo SDL.h está dentro de una carpeta llamada SDL. Lo siguiente que hay que hacer es inicializar la pantalla gráfica. Para eso disponemos de dos funciones: SDL_Init() y SDL_SetVideoMode(): SDL_Init(). Debe ser la primera función en invocarse. No se puede usar ninguna otra función de SDL si antes no se ha llamado a esta. Hay que pasarle un parámetro que indica qué tipo de sistema multimedia queremos manejar (la tarjeta de vídeo, la de sonido, el CD-ROM, etc). En nuestro caso será la tarjeta de vídeo, ya que sólo nos interesa manipular gráficos. La constante para ello es SDL_INIT_VIDEO: SDL_Init(SDL_INIT_VIDEO); La fución SDL_Init() devuelve –1 si ocurre algún error al iniciar el sistema de gráficos. En ese caso, el programa no podrá continuar, de modo que debemos comprobar el valor devuelto por SDL_Init(). SDL_SetVideoMode(). Esta debe ser la segunda función en invocarse, justo a continuación de SDL_Init(). Sirve para establecer el tipo de pantalla gráfica que queremos. Hay que indicarle el tamaño en píxels, el número de bits de color y los atributos de la pantalla. Por ejemplo: SDL_SetVideoMode(800, 600, 16, SDL_ANYFORMAT | SDL_DOUBLEBUFFER); Esto crea una ventana gráfica de 800x600 píxels, con 16 bits de profundidad de color. El último parámetro, SDL_ANYFORMAT, es una constante que indica a SDL que puede seleccionar otra profundidad de color si la elegida no está disponible. Este cuarto parámetro puede tomar otros muchos valores que no vamos a ver, pero sí señalaremos que es conveniente añadir la constante SDL_DOUBLEBUFFER por motivos de rendimiento (ver ejemplo más abajo). SDL_SetVideoMode() devuelve un puntero a una estructura llamada SDL_Surface, definida en SDL.h, o NULL si ocurre algún error. Este puntero nos será imprescidible para manejar la pantalla gráfica, así que debes guardarlo en una variable. Esta variable, además, debe ser global si se va a usar en otras partes del programa, contraviniendo una de las buenas prácticas de programación más universales que existen. Sin embargo, si no lo haces así, la variable no funcionará correctamente. Puedes imaginar que el puntero a SDL_Surface es como el puntero a FILE que devuelve la función fopen(). Sin ese puntero a FILE no se puede manejar el archivo. Pues bien, sin el puntero a SDL_Surface no podemos manejar la pantalla gráfica. Visto así, la función SDL_SetVideoMode() es parecida a fopen(), solo que aplicada a los gráficos en lugar de a los archivos. Aquí tienes un ejemplo de inicialización de la pantalla gráfica: #include &lt;SDL/SDL.h&gt;<br /> … SDL_Surface *pantalla; // Esta variable debe ser GLOBAL … if (SDL_Init(SDL_INIT_VIDEO) == -1) { puts(“Error en la inicialización del sistema de vídeo\n”); SDL_Quit(); exit(-1); }</p> <p>pantalla = SDL_SetVideoMode(800, 600, 16, SDL_ANYFORMAT|SDL_DOUBLEBUF); if (pantalla == NULL) { puts(“Fallo al establecer el modo de vídeo\n”); SDL_Quit(); exit(-1); } … SDL_Quit(); // Esto se hace al final del programa Tan importante como inicializar la pantalla gráfica es finalizarla. Ten en cuenta que la pantalla gráfica consume muchos recursos, y éstos deben ser liberados antes de que el programa termine su ejecución. Para eso tenemos la función SDL_Quit(), que se invoca sin argumentos (observa el ejemplo) 5.4 Dibujar gráficos en la pantalla Ya tenemos nuestra pantalla gráfica inicializada y lista para empezar a dibujar en ella. Pero, ¿qué tipo de objetos se pueden dibujar? Aunque las librerías gráficas permiten al programador pintar píxels individuales en cualquier punto de la pantalla, lo habitual es trabajar con imágenes previamente existentes llamadas sprites. Un sprite es una imagen guardada en un archivo que puede ser cargada por el programa y mostrada en cualquier parte de la pantalla gráfica y tantas veces como sea necesario. Por lo tanto, lo primero que necesitas es hacerte con una colección de sprites para tu programa. Si, por ejemplo, suponemos que estamos desarrollando un de ajedrez, necesitaríamos los siguientes: • Una imagen del tablero. • Una imagen de cada una de las piezas. • Opcionalmente, una imagen de fondo para decorar la pantalla. Los archivos con las imágenes deben estar en formato BMP. SDL admite otros formatos, pero el BMP es con diferencia el más fácil de manipular, así que es una muy buena idea empezar por las imágenes BMP y luego, cuando ya las manejes bien, dar el salto a otros formatos con compresión. Para dibujar una imagen en cualquier punto de la pantalla, hay que hacer dos cosas que pasamos a describir con detalle: • Cargar la imagen en la memoria (procedente de un archivo BMP) • Mostrar la imagen en la pantalla Cargar imágenes en la memoria Sólo es necesario cargar las imágenes una vez. Normalmente, se hará al principio del programa, justo después de la inicialización de SDL. Una vez cargadas en la memoria, podremos utilizarlas tantas veces como las necesitemos, a menos que liberemos el espacio de memoria que ocupan. La liberación de espacio, por tanto, debería hacerse al final del programa, justo antes de terminar. Para cargar una imagen BMP se usa la función SDL_LoadBMP(), de esta forma: SDL_Surface *tablero;</p> <p>tablero = SDL_LoadBMP(“tablero.bmp”); if (fondo == NULL) { printf(“Error al cargar el archivo tablero.bmp”); SDL_Quit(); exit(-1); } Observa que SDL_LoadBMP() devuelve un puntero a SDL_Surface. Este puntero será necesario para luego mostrar la imagen en cualquier lugar de la pantalla. La variable “fondo” debe ser global si se va a usar en más de una función (si es local y la pasamos como parámetro a otra función, SDL fallará). Las imágenes son rectangulares. En muchas ocasiones, necesitamos mostrar una imagen encima de otra. Es el caso de las piezas, que se mostrarán encima del tablero. Cuando esto ocurre, el color de fondo de la pieza (que decidimos que fuera negro) aparecerá encima del tablero como un desagradable recuadro de color negro. En estas situaciones, hay que avisar a SDL de que, para este sprite en concreto, el color negro va a ser transparente, es decir, no debe ser mostrado. Esto se hace así: SDL_Surface *peon_blanco; Uint32 color; // Para definir el color de transparencia (donde proceda)</p> <p>// Cargamos la imagen del peón blanco peon_blanco = SDL_LoadBMP(“peon_bl.bmp”); if (peon_blanco == NULL) { printf(“Error al cargar el archivo peon_bl.bmp”); SDL_Quit(); exit(-1); }</p> <p>// Definimos la transparencia (color negro = (0,0,0) ) color = SDL_MapRGB(peon_blanco-&gt;format, 0, 0, 0); SDL_SetColorKey(cuadro1, SDL_SRCCOLORKEY | SDL_RLEACCEL, color); Las imágenes cargadas en memoria deben ser liberadas antes de finalizar el programa con una llamada a SDL_FreeSurface(). Por ejemplo, para liberar la memoria ocupada por la imagen “tablero.bmp” que hemos cargado antes usaremos el puntero que obtuvimos al cargarla, así: SDL_FreeSurface(tablero); Mostrar imágenes en la pantalla Una vez cargada una imagen BMP en la memoria, podemos mostrarla en la pantalla a través del puntero SDL_Surface que obtuvimos al cargarla. Una imagen cargada puede ser mostrada todas las veces que queramos en cualquier posición de la pantalla. Por ejemplo, para mostrar la imagen del tablero (que cargamos en un ejemplo del apartado anterior) haríamos lo siguiente (luego comentamos el código) SDL_Rect rect; rect = (SDL_Rect) {10, 10, 400, 400}; SDL_BlitSurface(tablero, NULL, pantalla, &amp;rect); SDL_Flip(pantalla); La variable “rect” es de tipo SDL_Rect, y define un área rectangular de la pantalla. El área rectangular empieza en las coordenadas (10, 10) (esquina superior izquierda de la pantalla) y mide 400 píxels de ancho y 400 de alto, es decir, termina en (410, 410) SDL_BlitSurface() es la función que se encarga de mostrar en la pantalla un sprite. La variable “tablero” es de tipo SDL_Surface<em>, y debe ser la que nos devolvió SDL_LoadBMP() al cargar la imagen del tablero. La variable “pantalla” también es una SDL_Surface</em>, y debe ser la que nos devolvió SDL_SetVideoMode() al inicializar la pantalla gráfica. Ya dijimos que los punteros que nos devuelven estas funciones son imprescidibles y que debíamos definirlos como variables globales. La variable “rect” es el área rectangular que acabamos de definir. Fíjate que “rect” es la que indica en qué lugar de la pantalla va a aparecer el sprite. En este ejemplo, aparecerá en (10,10). Se le han reservado 400x400 píxels para dibujarse, es decir, hasta la posición (410, 410). Si el sprite en más pequeño, no pasará nada (ocupará lo que mida realmente). Si es más grande, se truncará. Por último, SDL_Flip() hace que lo que acabamos de dibujar se muestre realmente en la pantalla. Su efecto es parecido al de la función refresh() de ncurses. En realidad, todo lo que dibujamos se escribe en una zona de memoria específica y, al hacer SDL_Flip(), esa zona de memoria se vuelca sobre la memoria de vídeo, apareciendo todo en la pantalla. Esto representa el movimiento de gran cantidad de información entre distintas zonas de memoria, lo cual es un proceso relativamente lento. Por eso, si vamos a dibujar varios sprites consecutivos, es mejor hacer una sola vez SDL_Flip(), al final, cuando los hayamos dibujado todos. Llamar a SDL_Flip() después de dibujar cada sprite ralentizará notablemente el funcionamiento de nuestro programa. 5.5 Control del teclado Para leer el teclado en una ventana gráfica creada con SDL no se pueden usar las funciones estándar (como getchar() o gets()), ni mucho menos las de ncurses (como getstr()). SDL solo permite leer los caracteres de uno en uno, y no muestra eco por la pantalla (si queremos eco, tenemos que mostrar los caracteres nosotros mismos después de leerlos) Por lo demás, la forma de capturar un carácter tecleado es similar a la de ncurses, solo que un poco más complicada. A continuación se muestra un código de ejemplo: SDL_Event evento; // Para leer el teclado</p> <p>// Leer teclado if (SDL_PollEvent(&amp;evento)) // Comprobar si se ha pulsado una tecla { if (evento.type == SDL_KEYDOWN) // Efectivamente, se ha pulsado una tecla { switch (evento.key.keysym.sym) // Vamos a mirar qué ecla es { case SDLK_UP: …acciones…; break; // Flecha arriba case SDLK_DOWN: …acciones…; break; // Flecha abajo case SDLK_LEFT: …acciones…; break; // Felcha izquierda case SDLK_RIGHT: …acciones…; break; // Flecha derecha case SDLK_RETURN: …acciones…; break; // Intro case SDLK_ESCAPE: …acciones…; break; // ESC case SDLK_m: …acciones…; break; // Tecla “m” (menú) } } } Existen constantes para cualquiera de las otras teclas del teclado. Todas empiezan por “SDLK_”. Por ejemplo, la tecla “a” tendrá el código “SDLK_a”. 5.6 Definición de colores Aunque en general trataremos con imágenes ya creadas (como la del tablero o las de las piezas), es posible que necesites definir algún color para usarlo directamente sobre la pantalla gráfica (por ejemplo, para usar transparencias o para escribir un texto) En SDL no hay colores predefinidos, como en ncurses. Los colores debemos definirlos nosotros mezclando los colores básicos RGB (rojo, verde y azul) Hay dos formas de definir un color: con una variable de tipo “SDL_Color” o con una variable de tipo “Uint32”. El uso de una u otra dependerá de para qué queramos usar ese color: a) Con una variable de tipo SDL_Color. Se usaría así: SDL_Color color; <br /> color = (SDL_Color) {50, 150, 200, 255}; Los cuatro números definen el color. Deben ser números comprendidos entre 0 y 255. El primero es el nivel de rojo (R), el segundo el nivel de verde (G) y el tercero, el nivel de azul (B). El cuarto número es el brillo. El color definido en este ejemplo tiene mucho azul, bastante verde y poco rojo. El resultado debe ser un azul amarillento. b) Con una variable de tipo Uint32, que se usaría así: Uint32 color; color = SDL_MapRGB(pantalla-&gt;format, 50, 150, 200);<br /> En esta ocasión, “pantalla” debe ser un puntero a una imagen SDL_Surface que hayamos cargado previamente. Los tres valores siguientes son los niveles RGB. No hay nivel de brillo, porque éste se toma de la imagen apuntada por “pantalla”. De las dos maneras se pueden definir colores para usarlos posteriormente. Si el color lo necesitamos para una transparencia, recurriremos al segundo método (de hecho, ya vimos un ejemplo de ello al estudiar cómo se cargaban y mostaban las imágenes en SDL; allí usamos el color negro como transparencia). Si el color lo necesitamos para escribir un texto en la pantalla gráfica, usaremos el primer método (como se podrá ver en el siguiente apartado) 5.7 Mostrar texto en la pantalla gráfica: la librería SDL_TTF La librería SDL no permite directamente la escritura de texto en la pantalla gráfica. Esto se debe a que la pantalla gráfica, por definición, no admite caracteres, sino únicamente imágenes. Por fortuna, a la sombra de SDL se han creado multitud de librerías adicionales que, partiendo de SDL, complementan y mejoran sus prestaciones. Una de ellas es SDL_TTF. La libería SDL_TTF permite cargar fuentes true type que estén guardadas en archivos “.ttf” y manejarlas como si fueran imágenes BMP en la pantalla gráfica generada por SDL. Necesitamos SDL_TTF, por lo tanto, para escribir los mensajes de usuario y las opciones del menú. Instalación, compilación y enlace de SDL_TTF La instalación de la librería SDL_TTF es similar a la de SDL, tanto en Linux como en Windows, de modo que puedes remitirte al apartado correspondiente para recordar cómo se hacía. En cuanto a la compilación y enlace, sólo tienes que añadir la opción “-lSDL_ttf” a la línea de compilación del Makefile: gcc -g <code class="language-plaintext highlighter-rouge">opciones de SDL</code> -o ajedrez ajedrez.o movs.o… <code class="language-plaintext highlighter-rouge">más opciones de SDL</code> -lSDL_ttf Si estamos compilando en Windows con Dev-C++, agregaremos “-lSDL_ttf” a Opciones del Proyecto / Parámetros / Linker. Inicialización de SDL_TTF Igual que SDL, la librería SDL_TTF necesita ser inicializada antes de usarla, y finalizada antes de terminar el programa para liberar los recursos adquiridos. Como SDL_TTF corre por debajo de SDL, debe ser inicializada después de SDL, y debe ser terminada antes que SDL. La inicialización de SDL_TTF se hace simplemente así: if(TTF_Init() == -1) { printf(“Fallo al inicializar SDL_TTF”); exit(-1); }<br /> Inmediatamente después podemos cargar una fuente true type de un archivo TTF, así: TTF_Font* fuente; …. fuente = TTF_OpenFont(“arial.ttf”, 14); if(fuente == NULL) { printf(“Fallo al abrir la fuente”); exit(-1); } TTF_SetFontStyle(fuente, TTF_STYLE_BOLD); La variable “fuente” es un puntero a TTF_Font. Debe ser una variable global por el mismo motivo que las variables SDL_Surface<em>. La función TTF_OpenFont() abre el archivo “arial.ttf” y carga el tipo de letra Arial en tamaño 14 para su uso en el programa. Después es conveniente comprobar que el puntero “fuente” contenga un valor válido y no NULL. Por último, la función TTF_SetFontStyle() puede usarse para determinar el estilo de la fuente. Tenemos varias posibilidades: TTF_STYLE_BOLD (negrita), TTF_STYLE_ITALIC (cursiva), TTF_STYLE_UNDERLINE (subrayado) y TTF_STYLE_NORMAL. Si queremos combinar varios estilos, podemos separarlos por el operador “|”. Por ejemplo, para poner la fuente en negrita y cursiva escribiríamos esto: TTF_SetFontStyle(fuente, TTF_STYLE_BOLD | TTF_STYLE_ITALIC); Finalización de SDL_TTF El proceso de finalización es inverso y complementario al de inicialización. Primero habrá que liberar todas las fuentes cargadas durante la inicialización, y luego hay que terminar el subsistema SDL_TTF. Para liberar una fuente escribiremos sencillamente: TTF_CloseFont(fuente); La variable “fuente” será de tipo TTF_Font</em>, y debe coincidir con la que nos devolvió la función TTF_OpenFont(). Esta operación la repetiremos con cada una de las fuentes que hayamos cargado. Después finalizaremos SDL_TTF escribiendo: TTF_Quit(); Recuerda que esto debe hacerse ANTES de SDL_Quit(), ya que SDL_TTF depende de SDL. Escribir texto con SDL_TTF Todo esto lo hacemos con un objetivo: poder escribir texto en la pantalla gráfica y sustituir así todas las funciones printw() y similares. Para escribir un texto hay que hacer dos cosas: primero, convertirlo en una imagen; segundo, mostrar la imagen en la pantalla. La conversión de un texto en una imagen se hace con la función TTF_Render(): SDL_Color color; SDL_Surface* txt_img;</p> <p>color = (SDL_Color) {255,100,100,255}; txt_img = TTF_RenderText_Blended(fuente, “Hola mundo”, color); if(txt_img == NULL) { printf(“Fallo al renderizar el texto”); exit(-1); } Como ves, hay que hacer bastantes cosas para mostrar un texto en la pantalla gráfica, pero todo es acostumbrarse. Primero, hay que definir un color para el texto (cómo se definen los colores es algo que vimos en el epígrafe anterior). En este caso, hemos escogido un rojo brillante. Después se invoca a TTF_RenderText(), pasándole como parámetros el puntero a la fuente que obtuvimos con TTF_OpenFont(), el texto que queremos mostrar y el color. La función nos devuelve un puntero de tipo SDL_Surface* que, si recuerdas, es exactamente el mismo que usábamos con las imágenes cargadas desde un archivo BMP. En realidad, la función TTF_RenderText() tiene tres formas: • TTF_RenderText_Solid(): realiza una conversión del texto en imagen rápida pero de poca calidad. • TTF_RenderText_Shaded(): la imagen resultante es de gran calidad pero tiene un recuadro negro alrededor • TTF_RenderText_Blended(): la imagen resultante es de gran calidad y sin recuadro negro En general preferiremos el modo “Blended”, que es el que proporciona mejores resultados. El modo “Shaded” se puede usar en determinados lugares (si no hay otra imagen debajo del texto). El modo “Solid” sólo debe usarse si hay que mostrar mucho texto y el modo “Blended” se revela demasiado lento. Hasta aquí, sólo hemos convertido el texto “Hola mundo” en una imagen, pero aún no la hemos mostrado en la pantalla. Para hacerlo procederemos como con cualquier otra imagen: // Mostramos el texto como si fuera una imagen rect = (SDL_Rect) { 500, 280, 100, 30 }; SDL_BlitSurface(txt_img, NULL, pantalla, &amp;rect); SDL_Flip(scr); Se supone que “rect” es de tipo SDL_Rect y que pantalla es el puntero a SDL_Surface* que nos devolvió SDL_SetVideoMode() al inicializar SDL. Así, el texto “Hola mundo” se mostrará en la posición (500, 280) de la pantalla gráfica, reservándose para él 100 píxels de ancho y 30 de alto.</p> <h2 id="93-escribiendo-programas-en-c"> <a href="#93-escribiendo-programas-en-c" class="anchor-heading" aria-labelledby="93-escribiendo-programas-en-c"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.3. Escribiendo programas en C </h2> <p>Ya conocemos cómo se manejan los principales elementos de un programa con C: variables, instrucciones de control, asignaciones, funciones, etc.</p> <p>Ahora nos queda saber cómo juntamos todo eso para escribir nuestros programas, ¿no te parece?</p> <h3 id="931-estructura-de-un-programa-en-c"> <a href="#931-estructura-de-un-programa-en-c" class="anchor-heading" aria-labelledby="931-estructura-de-un-programa-en-c"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.3.1. Estructura de un programa en C </h3> <p>Ya estamos en condiciones de echar un vistazo a cual será el aspecto de (casi) todos los programas que escribamos en C.</p> <p>Todo programa C, desde el más pequeño hasta el más complejo, tiene un <strong>programa principal</strong> ubicado en la función <strong><em>main()</em></strong>.</p> <p>Además, por encima de <em>main()</em> deben aparecer los <strong>prototipos de funciones</strong> (y esto implica a los archivos de cabecera, si se utilizan funciones de librería) y las variables y constantes globales, si las hay. Por debajo de <em>main()</em> encontraremos el código de las funciones de usuario.</p> <p>Por lo tanto, la <strong>estructura habitual de nuestros programas en C</strong> debería ser esta:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Comentario inicial: nombre del programa, del programador, fecha, etc */</span>

<span class="cm">/* Archivos de cabecera (prototipos de funciones de librería) */</span>
<span class="cp">#include</span> <span class="cpf">&lt;archivo_cabecera.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;archivo_cabecera.h&gt;</span><span class="cp">
</span>
<span class="cm">/* Prototipos de funciones escritas por nosotros */</span>
<span class="kt">float</span> <span class="n">funci</span><span class="err">ó</span><span class="n">n1</span> <span class="p">(</span><span class="n">argumentos</span><span class="p">);</span>
<span class="kt">float</span> <span class="n">funci</span><span class="err">ó</span><span class="n">n2</span> <span class="p">(</span><span class="n">argumentos</span><span class="p">);</span>

<span class="cm">/* Variables globales */</span>
<span class="kt">int</span> <span class="n">variable_global1</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">variable_global2</span><span class="p">;</span>

<span class="cm">/* Algoritmo principal */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
   <span class="cm">/* Variables locales del algoritmo principal */</span>
   <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
   <span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
   <span class="p">...</span>
   <span class="p">...</span>
   <span class="cm">/* Instrucciones del algoritmo principal */</span>
   <span class="p">...</span>
   <span class="n">funci</span><span class="err">ó</span><span class="n">n1</span><span class="p">(</span><span class="n">argumentos</span><span class="p">);</span>
   <span class="p">...</span>
   <span class="n">funci</span><span class="err">ó</span><span class="n">n2</span><span class="p">(</span><span class="n">argumentos</span><span class="p">);</span>
   <span class="p">...</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Código completo de las funciones escritas por nosotros */</span>
<span class="kt">float</span> <span class="n">funci</span><span class="err">ó</span><span class="n">n1</span> <span class="p">(</span><span class="n">argumentos</span><span class="p">)</span>
<span class="p">{</span>
   <span class="cm">/* Variables locales e instrucciones de este subalgoritmo */</span>
<span class="p">}</span>
<span class="kt">float</span> <span class="n">funci</span><span class="err">ó</span><span class="n">n2</span> <span class="p">(</span><span class="n">argumentos</span><span class="p">)</span>
<span class="p">{</span>
   <span class="cm">/* Variables locales e instrucciones de este subalgoritmo */</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="932-caja-de-herramientas"> <a href="#932-caja-de-herramientas" class="anchor-heading" aria-labelledby="932-caja-de-herramientas"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.3.2. Caja de herramientas </h3> <p>¿Qué necesitamos para comenzar a escribir programas en C? ¿Tendrás que instalar un montón de programas de desarrollo en tu ordenador?</p> <p>La verdad es que no. Para desarrollar con Javascript basta con que tengas instalado:</p> <ul> <li> <p><strong>Un editor de texto</strong>. No te sirve Microsoft Word ni Libreoffice Writer. Tiene que ser un editor de texto <em>plano</em>, es decir, que no introduzca información de formato en el archivo. Solo el texto.</p> <p>Existen muchísimos editores de estas características, porque son programas muy simples y livianos. El <strong>bloc de notas</strong> de Windows o el editor <strong>gedit</strong> de los sistemas Linux con escritorio Gnome (como Educandos) son dos de ellos.</p> <p>Un editor de texto para programación que ha tenido un crecimiento espectacular en los últimos años a nivel aficionado y profesional es <strong><a href="https://code.visualstudio.com/">Visual Studio Code</a></strong>. Es multiplataforma (tiene versiones para Windows, Linux y Mac) y de código abierto. Y es una auténtica maravilla, así que te recomiendo lo instales (¡siempre desde los repositorios de tu distribución Linux o desde la web oficial si trabajas con Windows, por favor!) y lo instales.</p> <p>Para programar en C con Visual Studio Code, tendrás que instalar las extensiones para C/C++, pero no te preocupes porque es muy fácil y no tardarás más de un minuto. En los ejercicios propuestos lo haremos.</p> </li> <li> <p><strong>Un compilador de C/C++</strong>. Todos los sistemas Linux llevan instalador un compilador de C muy popular llamado <strong>gcc</strong>. Si trabajas en Windows, lo más recomendable es que instales <strong>MinGW</strong>, una versión de gcc para Windows. Descárgala de la <a href="https://www.mingw-w64.org/">web del fabricante</a> y sigue las instrucciones de instalación.</p> <p>Nota: en Windows tendrás agregar la ruta hasta el ejecutable de Mingw en el PATH del sistema. La forma exacta de conseguir esto puede diferir según tu versión de Windows, y deberías buscar ayuda si no sabes cómo hacerlo (obviamente, este no es libro sobre Windows). En los sistemas Linux, esto no será necesario.</p> </li> </ul> <h3 id="933-flujo-de-trabajo"> <a href="#933-flujo-de-trabajo" class="anchor-heading" aria-labelledby="933-flujo-de-trabajo"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.3.3. Flujo de trabajo </h3> <p>Cuando se trabaja con C, la implementación de un programa suele dividirse en varias subfases: edición, compilación, enlace y depuración. Te las describo brevemente:</p> <ol> <li><strong>Edición del código fuente</strong>. Editar consiste en escribir el código fuente del programa en el lenguaje seleccionado, en nuestro caso C, con un editor de texto plano como <strong>Visual Studio Code</strong>.</li> <li><strong>Compilación</strong>. Una vez escrito el programa, debe traducirse a binario en un proceso llamado <em>compilación</em>. Esto puede hacerse desde la línea de comandos, aunque algunos editores de texto permiten hacerlo desde el propio editor. Es el caso de <em>Visual Studio Code</em>. Si has instalado las extensiones para C/C++, bastará con que vayas al menú <strong>Run</strong> o que pulses el <strong>botón “Play”</strong> que aparece arriba y a la derecha del editor.</li> <li><strong>Enlace</strong>. Si tu programa es muy complejo, tu código fuente ocupará varios archivos. En tal caso, hay que compilarlos de uno en uno y después <em>enlazarlos</em> entre sí para generar un único programa ejecutable. No te preocupes de momento por esto, porque tus primeros programas estarán en un solo archivo y, además, cuando llegue el momento, <em>Visual Studio Code</em> se encargará de hacer el enlace automáticamente por nosotros.de librerías entre diferentes aplicaciones.</li> <li> <p><strong>Depuración</strong>. Ningún programa está bien escrito a la primera. Nunca. Lo normal es que el compilador te informe de que hay multitud de errores en tu código fuente. Tendrás que leer cuidadosamente los mensajes de error para corregirlos. Por fortuna, el compilador te informará de la línea exacta donde localizó el error, e incluso te dirá de qué tipo de error se trata.</p> <p>Una vez corregidos los errores de escritura, cuando el programa empiece a funcionar, es posible que no haga exactamente lo que tú pretendías que hiciera. También tendrás que corregir estos errores de ejecución.</p> <p>XXX <em>captura de pantalla de extensión C++ y botón “Play”</em> XXX</p> </li> </ol> <h3 id="934-dónde-y-cómo-escribir-el-código-fuente"> <a href="#934-dónde-y-cómo-escribir-el-código-fuente" class="anchor-heading" aria-labelledby="934-dónde-y-cómo-escribir-el-código-fuente"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.3.4. Dónde y cómo escribir el código fuente </h3> <p>Los programas escritos en C suelen guardarse en dos tipos de archivo:</p> <ul> <li><strong>Archivos con extensión .c</strong>. Estos archivos contienen el grueso del código fuente. En particular, la función <em>main()</em>, que es necesaria en cualquier programa en C.</li> <li><strong>Archivos con extensión .h</strong>. Estos archivos contienen los prototipos de funciones y otras definiciones necesarias para que el programa funcione bien. Al principio, no escribirás ningún archivo de este tipo, pero sí que tendrás que incluir (con <em>#include</em>) muchos de ellos.</li> </ul> <h2 id="94-c-avanzado-punteros-y-estructuras-de-datos"> <a href="#94-c-avanzado-punteros-y-estructuras-de-datos" class="anchor-heading" aria-labelledby="94-c-avanzado-punteros-y-estructuras-de-datos"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.4. C avanzado: punteros y estructuras de datos </h2> <p>XXX <em>Texto pendiente de redactar</em> XXX</p> <h2 id="95-un-ejemplo-completo-las-tres-en-raya"> <a href="#95-un-ejemplo-completo-las-tres-en-raya" class="anchor-heading" aria-labelledby="95-un-ejemplo-completo-las-tres-en-raya"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.5. Un ejemplo completo: las tres en raya </h2> <p>XXX <em>Texto pendiente de revisar a partir de aquí</em> XXX</p> <p>Llegó la hora de poner manos a la obra.</p> <p>Si hay una sección de este capítulo que tienes que leer con atención, es esta. Así que es un mal momento para tener prisa.</p> <p>Vamos a escribir un <strong>programa completo en Javascript</strong>. Te puede servir de plantilla para desarrollar tus propios programas a partir de aquí.</p> <p>El programa en cuestión será una versión del juego de <strong>las tres en raya</strong> que resolvimos en el tema de introducción a la programación. No dudes en repasar aquel ejercicio resuelto para ver el pseudocódigo, puesto que nuestro programa será una traducción literal de ese pseudocódigo a Javascript.</p> <p>Aquí tienes el código fuente completo. Estúdialo con atención y asegúrate de entenderlo todo (o un gran porcentaje) antes de continuar. Ah, y no dejes de compararlo línea a línea con el mismo código en pseudocódigo.</p> <h3 id="951-el-código-fuente"> <a href="#951-el-código-fuente" class="anchor-heading" aria-labelledby="951-el-código-fuente"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.5.1. El código fuente </h3> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">'salida'</span> <span class="na">style=</span><span class="s">'text-align: center; border-style: solid; border-color: black; font-family: mono'</span><span class="nt">&gt;&lt;/div&gt;</span>
<span class="nt">&lt;script&gt;</span>
<span class="c1">//-------------------------</span>
<span class="c1">//   ALGORITMO PRINCIPAL</span>
<span class="c1">//-------------------------</span>
<span class="kd">var</span> <span class="nx">tablero</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">ganador</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">tablas</span><span class="p">;</span>

<span class="nx">inicializar</span><span class="p">(</span><span class="nx">tablero</span><span class="p">)</span>   <span class="c1">// Esto es un subalgoritmo. Está escrito más abajo</span>
<span class="k">do</span> <span class="p">{</span>
   <span class="nx">mostrar</span><span class="p">(</span><span class="nx">tablero</span><span class="p">);</span>
   <span class="nx">colocar_pieza_humano</span><span class="p">(</span><span class="nx">tablero</span><span class="p">);</span>
   <span class="nx">ganador</span> <span class="o">=</span> <span class="nx">comprobar_ganador</span><span class="p">(</span><span class="nx">tablero</span><span class="p">);</span>
   <span class="nx">tablas</span> <span class="o">=</span> <span class="nx">comprobar_tablas</span><span class="p">(</span><span class="nx">tablero</span><span class="p">);</span>
   <span class="k">if</span> <span class="p">((</span><span class="nx">ganador</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">Ninguno</span><span class="dl">"</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">tablas</span> <span class="o">==</span> <span class="kc">false</span><span class="p">))</span> <span class="p">{</span>
      <span class="nx">colocar_pieza_ordenador</span><span class="p">(</span><span class="nx">tablero</span><span class="p">);</span>
      <span class="nx">ganador</span> <span class="o">=</span> <span class="nx">comprobar_ganador</span><span class="p">(</span><span class="nx">tablero</span><span class="p">);</span>
      <span class="nx">tablas</span> <span class="o">=</span> <span class="nx">comprobar_tablas</span><span class="p">(</span><span class="nx">tablero</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">}</span>
<span class="k">while</span> <span class="p">((</span><span class="nx">ganador</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">Ninguno</span><span class="dl">"</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">tablas</span> <span class="o">==</span> <span class="kc">false</span><span class="p">));</span>
	
<span class="nx">mostrar</span><span class="p">(</span><span class="nx">tablero</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">ganador</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">Ninguno</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
   <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">salida</span><span class="dl">'</span><span class="p">).</span><span class="nx">innerHTML</span> <span class="o">+=</span> <span class="dl">"</span><span class="s2">EL JUEGO HA TERMINADO EN TABLAS</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
   <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">salida</span><span class="dl">'</span><span class="p">).</span><span class="nx">innerHTML</span> <span class="o">+=</span> <span class="dl">"</span><span class="s2">EL JUEGO HA TERMINADO. EL GANADOR ES: </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">ganador</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// --------------------------------------------</span>
<span class="c1">// Inicializa el tablero con espacios en blanco</span>
<span class="c1">// --------------------------------------------</span>
<span class="kd">function</span> <span class="nx">inicializar</span><span class="p">(</span><span class="nx">tablero</span><span class="p">)</span> <span class="p">{</span>
   <span class="c1">//let i;</span>
   <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Como tablero es un array, se pasa por referencia y los cambios que</span>
      <span class="c1">// hagamos aquí se reflejarán en el algoritmo principal</span>
      <span class="nx">tablero</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// --------------------------------------------</span>
<span class="c1">// Muestra el estado actual del tablero</span>
<span class="c1">// --------------------------------------------</span>
<span class="kd">function</span> <span class="nx">mostrar</span><span class="p">(</span><span class="nx">tablero</span><span class="p">)</span> <span class="p">{</span>
   <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">salida</span><span class="dl">'</span><span class="p">).</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">ESTADO ACTUAL DEL TABLERO&lt;br&gt;</span><span class="dl">"</span><span class="p">;</span>
   <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">salida</span><span class="dl">'</span><span class="p">).</span><span class="nx">innerHTML</span> <span class="o">+=</span> <span class="dl">"</span><span class="s2">+-+-+-+&lt;br&gt;</span><span class="dl">"</span><span class="p">;</span>
   <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">salida</span><span class="dl">'</span><span class="p">).</span><span class="nx">innerHTML</span> <span class="o">+=</span> <span class="dl">"</span><span class="s2">|</span><span class="dl">"</span> <span class="o">+</span> <span class="nx">tablero</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">|</span><span class="dl">"</span> <span class="o">+</span> <span class="nx">tablero</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">|</span><span class="dl">"</span> <span class="o">+</span> <span class="nx">tablero</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">|&lt;br&gt;</span><span class="dl">"</span><span class="p">;</span>
   <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">salida</span><span class="dl">'</span><span class="p">).</span><span class="nx">innerHTML</span> <span class="o">+=</span> <span class="dl">"</span><span class="s2">+-+-+-+&lt;br&gt;</span><span class="dl">"</span><span class="p">;</span>
   <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">salida</span><span class="dl">'</span><span class="p">).</span><span class="nx">innerHTML</span> <span class="o">+=</span> <span class="dl">"</span><span class="s2">|</span><span class="dl">"</span> <span class="o">+</span> <span class="nx">tablero</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">|</span><span class="dl">"</span> <span class="o">+</span> <span class="nx">tablero</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">|</span><span class="dl">"</span> <span class="o">+</span> <span class="nx">tablero</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">|&lt;br&gt;</span><span class="dl">"</span><span class="p">;</span>
   <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">salida</span><span class="dl">'</span><span class="p">).</span><span class="nx">innerHTML</span> <span class="o">+=</span> <span class="dl">"</span><span class="s2">+-+-+-+&lt;br&gt;</span><span class="dl">"</span><span class="p">;</span>
   <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">salida</span><span class="dl">'</span><span class="p">).</span><span class="nx">innerHTML</span> <span class="o">+=</span> <span class="dl">"</span><span class="s2">|</span><span class="dl">"</span> <span class="o">+</span> <span class="nx">tablero</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">|</span><span class="dl">"</span> <span class="o">+</span> <span class="nx">tablero</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">|</span><span class="dl">"</span> <span class="o">+</span> <span class="nx">tablero</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">|&lt;br&gt;</span><span class="dl">"</span><span class="p">;</span>
   <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">salida</span><span class="dl">'</span><span class="p">).</span><span class="nx">innerHTML</span> <span class="o">+=</span> <span class="dl">"</span><span class="s2">+-+-+-+&lt;br&gt;</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ---------------------------------------------------</span>
<span class="c1">// Coloca una pieza del jugador humano en el tablero</span>
<span class="c1">// ---------------------------------------------------</span>
<span class="kd">function</span> <span class="nx">colocar_pieza_humano</span><span class="p">(</span><span class="nx">tablero</span><span class="p">)</span> <span class="p">{</span>
   <span class="kd">var</span> <span class="nx">casilla</span><span class="p">,</span> <span class="nx">casilla_correcta</span><span class="p">;</span>
   <span class="k">do</span> <span class="p">{</span>
      <span class="nx">casilla</span> <span class="o">=</span> <span class="nx">prompt</span><span class="p">(</span><span class="dl">"</span><span class="s2">¿En qué casilla quieres poner una pieza? (1-9)</span><span class="dl">"</span><span class="p">);</span>
      <span class="nx">casilla_correcta</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">tablero</span><span class="p">[</span><span class="nx">casilla</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
         <span class="nx">tablero</span><span class="p">[</span><span class="nx">casilla</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">X</span><span class="dl">"</span><span class="p">;</span>
         <span class="nx">casilla_correcta</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
         <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">salida</span><span class="dl">'</span><span class="p">).</span><span class="nx">innerHTML</span> <span class="o">+=</span> <span class="dl">"</span><span class="s2">Error: Esa casilla ya está ocupada&lt;br&gt;</span><span class="dl">"</span><span class="p">;</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="k">while</span> <span class="p">(</span><span class="nx">casilla_correcta</span> <span class="o">==</span> <span class="kc">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ---------------------------------------------------</span>
<span class="c1">// Coloca una pieza del ordenador en el tablero</span>
<span class="c1">// ---------------------------------------------------</span>
<span class="kd">function</span> <span class="nx">colocar_pieza_ordenador</span><span class="p">(</span><span class="nx">tablero</span><span class="p">)</span> <span class="p">{</span>
   <span class="kd">var</span> <span class="nx">casilla</span><span class="p">,</span> <span class="nx">casilla_correcta</span><span class="p">;</span>
   <span class="nx">casilla_correcta</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
   <span class="k">do</span> <span class="p">{</span>
      <span class="nx">casilla</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">round</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span><span class="o">*</span><span class="mi">9</span><span class="p">);</span>
      <span class="nx">alert</span><span class="p">(</span><span class="dl">"</span><span class="s2">Voy a colocar mi pieza en la casilla </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">casilla</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">tablero</span><span class="p">[</span><span class="nx">casilla</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
         <span class="nx">tablero</span><span class="p">[</span><span class="nx">casilla</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">;</span>
         <span class="nx">casilla_correcta</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
         <span class="nx">alert</span><span class="p">(</span><span class="dl">"</span><span class="s2">¡Está ocupada! Voy a elegir otra</span><span class="dl">"</span><span class="p">);</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="k">while</span> <span class="p">(</span><span class="nx">casilla_correcta</span> <span class="o">==</span> <span class="kc">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ---------------------------------------------------</span>
<span class="c1">// Comprueba si hay un ganador según el estado del </span>
<span class="c1">// tablero. Devuelve "Ninguno", "Humano" u "Ordenador"</span>
<span class="c1">// ---------------------------------------------------</span>
<span class="kd">function</span> <span class="nx">comprobar_ganador</span><span class="p">(</span><span class="nx">tablero</span><span class="p">)</span> <span class="p">{</span>
   <span class="kd">var</span> <span class="nx">ganador</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Ninguno</span><span class="dl">"</span><span class="p">;</span>
   <span class="c1">// Comprobamos primera fila</span>
   <span class="k">if</span> <span class="p">((</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nx">tablero</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nx">tablero</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">X</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
         <span class="nx">ganador</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Humano</span><span class="dl">"</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
         <span class="nx">ganador</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Ordenador</span><span class="dl">"</span><span class="p">;</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="c1">// Comprobamos segunda fila</span>
   <span class="k">if</span> <span class="p">((</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="nx">tablero</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="nx">tablero</span><span class="p">[</span><span class="mi">6</span><span class="p">]))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">X</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
         <span class="nx">ganador</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Humano</span><span class="dl">"</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
         <span class="nx">ganador</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Ordenador</span><span class="dl">"</span><span class="p">;</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="c1">// Comprobamos tercera fila</span>
   <span class="k">if</span> <span class="p">((</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">==</span> <span class="nx">tablero</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">==</span> <span class="nx">tablero</span><span class="p">[</span><span class="mi">9</span><span class="p">]))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">X</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
         <span class="nx">ganador</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Humano</span><span class="dl">"</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
         <span class="nx">ganador</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Ordenador</span><span class="dl">"</span><span class="p">;</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="c1">// Comprobamos primera columna</span>
   <span class="k">if</span> <span class="p">((</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nx">tablero</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nx">tablero</span><span class="p">[</span><span class="mi">7</span><span class="p">]))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">X</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
         <span class="nx">ganador</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Humano</span><span class="dl">"</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
         <span class="nx">ganador</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Ordenador</span><span class="dl">"</span><span class="p">;</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="c1">// Comprobamos segunda columna</span>
   <span class="k">if</span> <span class="p">((</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="nx">tablero</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="nx">tablero</span><span class="p">[</span><span class="mi">8</span><span class="p">]))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">X</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
         <span class="nx">ganador</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Humano</span><span class="dl">"</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
         <span class="nx">ganador</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Ordenador</span><span class="dl">"</span><span class="p">;</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="c1">// Comprobamos tercera columna</span>
   <span class="k">if</span> <span class="p">((</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="nx">tablero</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="nx">tablero</span><span class="p">[</span><span class="mi">9</span><span class="p">]))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">X</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
         <span class="nx">ganador</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Humano</span><span class="dl">"</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
         <span class="nx">ganador</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Ordenador</span><span class="dl">"</span><span class="p">;</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="c1">// Comprobamos una diagonal</span>
   <span class="k">if</span> <span class="p">((</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nx">tablero</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nx">tablero</span><span class="p">[</span><span class="mi">9</span><span class="p">]))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">X</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
         <span class="nx">ganador</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Humano</span><span class="dl">"</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
         <span class="nx">ganador</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Ordenador</span><span class="dl">"</span><span class="p">;</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="c1">// Comprobamos la otra diagonal</span>
   <span class="k">if</span> <span class="p">((</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="nx">tablero</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="nx">tablero</span><span class="p">[</span><span class="mi">7</span><span class="p">]))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">X</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
         <span class="nx">ganador</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Humano</span><span class="dl">"</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">tablero</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">O</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
         <span class="nx">ganador</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Ordenador</span><span class="dl">"</span><span class="p">;</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">ganador</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// -------------------------------------------</span>
<span class="c1">// Comprueba si hay una situación de tablas</span>
<span class="c1">// según el estado actual del tablero. Devuelve</span>
<span class="c1">// verdadero si hay tablas o falso en otro caso.</span>
<span class="c1">// -------------------------------------------</span>
<span class="kd">function</span> <span class="nx">comprobar_tablas</span><span class="p">(</span><span class="nx">tablero</span><span class="p">)</span> <span class="p">{</span>
   <span class="kd">var</span> <span class="nx">tablas</span><span class="p">;</span>
   <span class="kd">var</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">contador</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">tablero</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
         <span class="nx">contador</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>
   <span class="p">}</span>
	
	<span class="c1">// Si todas las casillas están ya ocupadas y no hay ganador,</span>
	<span class="c1">// entonces estamos en tablas.</span>
   <span class="k">if</span> <span class="p">(</span><span class="nx">contador</span> <span class="o">==</span> <span class="mi">9</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">tablas</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="k">else</span> <span class="p">{</span>
      <span class="nx">tablas</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">tablas</span><span class="p">;</span>
<span class="p">}</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div> <h3 id="952-cómo-ejecutar-y-depurar-este-programa"> <a href="#952-cómo-ejecutar-y-depurar-este-programa" class="anchor-heading" aria-labelledby="952-cómo-ejecutar-y-depurar-este-programa"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.5.2. ¿Cómo ejecutar y depurar este programa? </h3> <p>Guarda el programa anterior en un archivo de texto con extensión .html (por ejemplo, <em>3-en-raya.html</em>).</p> <p>Luego, sencillamente, haz doble clic sobre él para abrirlo. El sistema operativo usará el navegador web predeterminado de tu sistema para abrir el archivo y la ejecución comenzará.</p> <h4 id="socorro-el-programa-no-funciona"> <a href="#socorro-el-programa-no-funciona" class="anchor-heading" aria-labelledby="socorro-el-programa-no-funciona"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> ¡Socorro! El programa no funciona </h4> <p>¿El resultado no es el esperado? Es lo habitual. Habrá algún error en el código y te tocará depurarlo.</p> <p>Las páginas web (con Javascript incluido) son extraordinariamente resistentes a los errores. No te mostrarán mensajes de error cada vez que haya algo mal escrito.</p> <p>Al contrario, permanecerán en silencio para no asustar al usuario de la web y provocar que salga corriendo de allí.</p> <p>Por ese motivo, los errores de Javascript solo se dejan ver en la “sala de máquinas” del navegador. Por supuesto, los programadores/as tienen una manera de acceder a esa “sala de máquinas”.</p> <p>Pulsa <strong>F12</strong> en tu navegador para abrir la <strong>consola de errores</strong> de Javascript. Asegúrate de seleccionar la pestaña etiquetada como <strong><em>Console</em></strong>. Verás algo como esto:</p> <p><img src="/docs/prog-y-3d/_site/assets/images/05-consola-errores-javascript.png" alt="Consola de errores de Javascript" /></p> <p>En la consola de errores aparecen, en rojo, los mensajes de error que haya lanzado el intérprete de Javascript, indicándote el tipo de error y la línea en la que se ha detectado. Los mensajes estarán en inglés, por supuesto, pero ¿qué esperabas? Si quieres aprender a programar, tienes que acostumbrarte a manejar el inglés técnico.</p> <p>¡Atención! Dependiendo del navegador que uses, puede que esa consola de errores se abra con otra combinación de teclas. Tendrás que bichear un poco por internet para averiguarlo. Lo habitual, sin embargo, es F12.</p> <p>Cuando hayas localizado el error, <strong>regresa a tu editor de texto, haz los cambios necesarios, guarda las modificaciones y recarga la página</strong> (pulsando <strong>F5</strong> en la mayoría de los navegadores).</p> <p>Si el navegador se había quedado colgado, tendrás que cerrarlo, esperar unos segundos y volver a abrirlo.</p> <p>Y así hasta que funcione.</p> <p>¡Mucha paciencia y sangre fría! Recuerda siempre que la mayor parte del tiempo de programación se va en depurar programas, no en escribirlos.</p> <h2 id="96-ejercicios-propuestos"> <a href="#96-ejercicios-propuestos" class="anchor-heading" aria-labelledby="96-ejercicios-propuestos"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.6. Ejercicios propuestos </h2> <p>XXX añadir un primer ejercicio que sea HOLA MUNDO e instalar Visual Studio Code + Extensión C/C++ de Microsoft.</p> <h4 id="ejercicio-1-tabla-de-multiplicar"> <a href="#ejercicio-1-tabla-de-multiplicar" class="anchor-heading" aria-labelledby="ejercicio-1-tabla-de-multiplicar"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ejercicio 1. Tabla de multiplicar </h4> <p>Vamos a empezar por algo sencillito.</p> <p>Escribe un programa en Javascript que pida un número y muestre la tabla de multiplicar de ese número.</p> <p>Puedes utilizar esta plantilla para tu primer programa:</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">'salida'</span> <span class="na">style=</span><span class="s">'text-align: center; border-style: solid; border-color: black'</span><span class="nt">&gt;&lt;/div&gt;</span>
<span class="nt">&lt;script&gt;</span>
   <span class="c1">// Escribe aquí el programa de la tabla de multiplicar</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div> <p>Recuerda que la salida la puedes enviar al &lt;div&gt; ‘salida’ con la expresión: <em>document.getElementById(‘salida’).innerHTML</em></p> <h4 id="ejercicio-2-juego-del-número-secreto"> <a href="#ejercicio-2-juego-del-número-secreto" class="anchor-heading" aria-labelledby="ejercicio-2-juego-del-número-secreto"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ejercicio 2. Juego del número secreto </h4> <p>Ahora algo solo un poquito más complicado: una versión en Javascript del juego del número secreto.</p> <p>(Puedes encontrarlo resuelto en el capítulo “Introducción a la programación”)</p> <h4 id="ejercicio-3-botón-saltarín"> <a href="#ejercicio-3-botón-saltarín" class="anchor-heading" aria-labelledby="ejercicio-3-botón-saltarín"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ejercicio 3. Botón saltarín </h4> <p>Aquí empezamos a divertirnos.</p> <p><strong>Vamos a hacer una página web con un botón. Al pulsar ese botón, Javascript hará que ¡el botón cambie de sitio!</strong></p> <p>Para eso, capturaremos el <strong>evento <em>click</em></strong> del botón.</p> <p>El botón lo tienes que crear antes mediante HTML. No importa que no sepas HTML. Solo echa un vistazo a este código:</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;body&gt;</span>
   <span class="nt">&lt;button</span> <span class="na">id=</span><span class="s">'boton'</span> <span class="na">onclick=</span><span class="s">'mover_boton()'</span> <span class="na">style=</span><span class="s">'position: absolute; top: 100px; left: 200px'</span><span class="nt">&gt;</span>Púlsame<span class="nt">&lt;/button&gt;</span>
   <span class="nt">&lt;script&gt;</span>
      <span class="kd">function</span> <span class="nx">mover_boton</span><span class="p">()</span> <span class="p">{</span>
          <span class="c1">// Escribe aquí tu código javascript</span>
      <span class="p">}</span>
   <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/body&gt;</span>
</code></pre></div></div> <p>Ahora solo te queda programar la función <em>mover_boton()</em>.</p> <p>Para lograr que el botón se mueva, tendrás que fijarte primero en cómo está el botón creado: tiene un <strong>id</strong>, un evento <strong>onclick</strong> y un <strong>style</strong>. Dentro del este último se definen dos propiedades:</p> <ul> <li><strong>top</strong> es la distancia desde la parte superior de la ventana del navegador hasta el botón. Lo hemos establecido en 100 píxeles (100px).</li> <li><strong>left</strong> es la distancia desde la parte izquierda de la ventana del navegador hasta el botón. Le hemos dado 200 píxeles.</li> </ul> <p>Pues bien, debes hacer que Javascript modifique esas dos propiedades. Por ejemplo, así:</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">mover_boton</span><span class="p">()</span> <span class="p">{</span>
   <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">boton</span><span class="dl">'</span><span class="p">).</span><span class="nx">style</span><span class="p">.</span><span class="nx">top</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">150px</span><span class="dl">'</span><span class="p">;</span>
   <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">boton</span><span class="dl">'</span><span class="p">).</span><span class="nx">style</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">250px</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>Con eso, el botón se moverá al hacer clic sobre él, pero solo la primera vez. Quedará emplazado en la posición top = 150px y left = 250px y ya no se desplazará más.</p> <p><strong>¿Y si quisiéramos que se moviera <em>siempre</em> que hagamos clic sobre él?</strong> Es es lo que tienes que conseguir en este ejercicio.</p> <h4 id="ejercicio-4-ventana-nerviosa-y-botones-evanescentes"> <a href="#ejercicio-4-ventana-nerviosa-y-botones-evanescentes" class="anchor-heading" aria-labelledby="ejercicio-4-ventana-nerviosa-y-botones-evanescentes"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ejercicio 4. Ventana nerviosa y botones evanescentes </h4> <p><strong>Ahora vamos a conseguir que una ventana entera del navegador se mueva al pulsar un botón. Y a hacer aparecer y desaparecer botones.</strong></p> <p>De hecho, vamos a crear cuatro botones:</p> <ul> <li><strong>Botón “Saltar”</strong>: al pulsarlo, la ventana dará un salto. Es decir, cambiará de posición..</li> <li><strong>Botón “Temblar”</strong>: al pulsarlo, la ventana se pondrá a “temblar”, como si tuviera frío o se hubiera puesto nerviosa, durante un rato.</li> <li><strong>Botón “Ocultar”</strong>: al pulsarlo, los dos botones anteriores desaparecerán de la vista.</li> <li><strong>Botón “Mostrar”</strong>: al pulsarlo, los botones desaparecidos volverán a aparecer.</li> </ul> <p>Esos cuatro botones puedes crearlos con este código HTML. También crearemos una segunda ventana del navegador, que será la que cambiará de posición:</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;body&gt;</span>
   <span class="nt">&lt;h1&gt;</span>Ventana nerviosa<span class="nt">&lt;/h1&gt;</span>
   <span class="nt">&lt;button</span> <span class="na">id=</span><span class="s">'btn_saltar'</span> <span class="na">onclick=</span><span class="s">'btn_saltar()'</span><span class="nt">&gt;</span>Saltar<span class="nt">&lt;/button&gt;</span>
   <span class="nt">&lt;button</span> <span class="na">id=</span><span class="s">'btn_temblar'</span> <span class="na">onclick=</span><span class="s">'btn_temblar()'</span><span class="nt">&gt;</span>Temblar<span class="nt">&lt;/button&gt;</span>
   <span class="nt">&lt;button</span> <span class="na">id=</span><span class="s">'btn_ocultar'</span> <span class="na">onclick=</span><span class="s">'btn_ocultar()'</span><span class="nt">&gt;</span>Ocultar<span class="nt">&lt;/button&gt;</span>
   <span class="nt">&lt;button</span> <span class="na">id=</span><span class="s">'btn_mostrar'</span> <span class="na">onclick=</span><span class="s">'btn_mostrar()'</span><span class="nt">&gt;</span>Mostrar<span class="nt">&lt;/button&gt;</span>
   <span class="nt">&lt;script&gt;</span>
      <span class="nx">myWindow</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="dl">''</span><span class="p">,</span> <span class="dl">''</span><span class="p">,</span> <span class="dl">'</span><span class="s1">width=300, height=200</span><span class="dl">'</span><span class="p">);</span> 
      <span class="kd">function</span> <span class="nx">btn_saltar</span><span class="p">()</span> <span class="p">{</span>
          <span class="c1">// Escribe aquí tu código javascript para cuando se pulse el botón "Saltar"</span>
      <span class="p">}</span>
      <span class="kd">function</span> <span class="nx">btn_temblar</span><span class="p">()</span> <span class="p">{</span>
          <span class="c1">// Escribe aquí tu código javascript para cuando se pulse el botón "Temblar"</span>
      <span class="p">}</span>
      <span class="kd">function</span> <span class="nx">btn_ocultar</span><span class="p">()</span> <span class="p">{</span>
          <span class="c1">// Escribe aquí tu código javascript para cuando se pulse el botón "Ocultar"</span>
      <span class="p">}</span>
      <span class="kd">function</span> <span class="nx">btn_mostrar</span><span class="p">()</span> <span class="p">{</span>
          <span class="c1">// Escribe aquí tu código javascript para cuando se pulse el botón "Mostrar"</span>
      <span class="p">}</span>
   <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/body&gt;</span>
</code></pre></div></div> <p>Lo siguiente es programar el código de cada una de las cuatro funciones Javascript, que se ejecutarán al pulsar cada botón.</p> <p>No te voy a decir lo que tienes que escribir en ellas, pero sí te voy a dar un par de pistas:</p> <ul> <li> <p><strong>Pista nº 1</strong>. Hay un objeto en Javascript llamado <strong><em>window</em></strong>, que nos permite alterar las propiedades de la ventana del navegador. Por ejemplo, nos permite cambiar su posición y su tamaño. En el apartado 5.2.11, sobre <em>Objetos predefinidos de Javascript</em>, hablamos de qué modo se puede cambiar eso.</p> <p>Observa que, en el fragmento de código anterior, hemos creado un objeto <em>window</em> llamado <strong><em>myWindow</em></strong>. Es sobre ese objeto sobre el que tienes que actuar.</p> </li> <li> <p><strong>Pista nº 2</strong>. En el ejercicio anterior cambiábamos las propiedades <em>top</em> y <em>left</em> de un botón, pero los botones (y cualquier cosa que haya en una página web) tienen muchas otras propiedades (¡pero MUCHAS!). Una de ellas se llama <strong><em>visibility</em></strong>, y puede tomar dos valores: <em>visible</em> o <em>hidden</em>.</p> </li> </ul> <h4 id="ejercicio-5-colorines"> <a href="#ejercicio-5-colorines" class="anchor-heading" aria-labelledby="ejercicio-5-colorines"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ejercicio 5. Colorines </h4> <p>Vamos a juguetear más con las propiedades de la página web cargada desde Javascript.</p> <p>En esta ocasión, construiremos una página con un cuadro de texto, un botón y un recuadro de color negro.</p> <p>Si escribimos en la caja de texto otro color (por ejemplo, “orange”) y hacemos click en el botón, <strong>el recuadro negro tiene que cambiar de color</strong> y volverse naranja.</p> <p>El código HTML que puedes usar como base es este:</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;html&gt;</span>
<span class="nt">&lt;head&gt;</span>
   <span class="nt">&lt;title&gt;</span>Colorines<span class="nt">&lt;/title&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
   <span class="nt">&lt;h1&gt;</span>Colorines<span class="nt">&lt;/h1&gt;</span>
   <span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">'caja_color'</span> <span class="na">style=</span><span class="s">'position: absolute; top: 5%; left: 70%; width: 25%; height: 20%; background-color: black'</span><span class="nt">&gt;&lt;/div&gt;</span>
   <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">'text'</span> <span class="na">id=</span><span class="s">'color'</span> <span class="na">value=</span><span class="s">'yellow'</span><span class="nt">&gt;</span>
   <span class="nt">&lt;button</span> <span class="na">id=</span><span class="s">'boton'</span> <span class="na">onclick=</span><span class="s">'cambiar_color()'</span><span class="nt">&gt;</span>Cambiar color<span class="nt">&lt;/button&gt;</span>
   <span class="nt">&lt;script&gt;</span>
      <span class="kd">function</span> <span class="nx">cambiar_color</span><span class="p">()</span> <span class="p">{</span>
         <span class="c1">// Escribe aquí el código Javascript</span>
      <span class="p">}</span>
   <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div> <p>Observa que, además de preparar los tres elementos que necesitamos (el recuadro de color negro, la caja de texto y el botón), hemos añadido más elementos HTML como <em>head</em> o <em>title</em>. Esos elementos son necesarios para que la página web se considere bien formada. Si no sabes lo que significan (aunque es bastante evidente), puedes repasarlos en el capítulo dedicado a HTML.</p> <p>(El navegador se tragará la página web aunque no esté bien formada, pero lo correcto es hacerla bien dentro de lo posible).</p> <p>Ahora solo te falta escribir el código de la función Javascript para cambiar el color del recuadro.</p> <h4 id="ejercicio-6-pelota-de-goma"> <a href="#ejercicio-6-pelota-de-goma" class="anchor-heading" aria-labelledby="ejercicio-6-pelota-de-goma"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ejercicio 6. Pelota de goma </h4> <p>Busca en internet una imagen de una pelota que te guste y descárgala. En esa imagen no debe aparecer nada más, excepto la pelota.</p> <p>Luego insértala en una página web, así:</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;body&gt;</span>
   <span class="nt">&lt;img</span>  <span class="na">id=</span><span class="s">'pelota'</span> <span class="na">src=</span><span class="s">'nombre-del-archivo-de-la-imagen'</span> <span class="na">style=</span><span class="s">'position: absolute; width: 100px; height: 100px'</span><span class="nt">&gt;</span>
<span class="nt">&lt;/body&gt;</span>  
</code></pre></div></div> <p>En <em>‘nombre-del-archivo-de-la-imagen’</em>, como es lógico, tendrás que escribir el nombre del archivo que contiene tu pelota. Le hemos asignado 100 píxeles de ancho y 100 de alto, pero si es demasiado pequeña o demasiado grande, siéntete libre de cambiar esas cantidades.</p> <p><strong>Ahora escribe en Javascript un programa para que la pelota rebote por la pantalla como si fuera una pelota de verdad.</strong></p> <p>Para conseguirlo, tendrás que:</p> <ul> <li>Alterar de nuevo las propiedades <em>top</em> y <em>left</em> de la pelota</li> <li>Usar las propiedades el objeto <strong><em>window</em></strong> para evitar que la pelota se salga de los márgenes de la pantalla.</li> <li>Utilizar un <strong>temporizador</strong> para mover la pelota cada x milisegundos. Según el valor de x, la pelota se moverá más deprisa o más despacio.</li> </ul> <p><strong>Mejora para los más valientes</strong>: trata de añadir un botón a este programa. Al pulsarlo, la pelota se detendrá. Al volver a pulsarlo, la pelota se pondrá en marcha de nuevo.</p> <h4 id="ejercicio-7-tres-en-raya-improved"> <a href="#ejercicio-7-tres-en-raya-improved" class="anchor-heading" aria-labelledby="ejercicio-7-tres-en-raya-improved"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ejercicio 7. Tres en raya improved </h4> <p><strong>Modifica el juego de las tres en raya para que sea más atractivo al usuario y más cómodo de jugar.</strong> Encontrarás el código fuente del juego más arriba, en este mismo capítulo.</p> <p>Tienes que eliminar todas las entradas de datos mediante <em>prompt()</em> y sustituirlas por cajas de texto HTML, como esta:</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>¿En qué casilla quieres poner tu pieza? (1-9)
<span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">'text'</span> <span class="na">id=</span><span class="s">'casilla'</span><span class="nt">&gt;</span>
<span class="nt">&lt;button</span> <span class="na">onclick=</span><span class="s">'colocar_pieza()'</span><span class="nt">&gt;</span>Aceptar<span class="nt">&lt;/button&gt;</span>

<span class="nt">&lt;script&gt;</span>
   <span class="kd">function</span> <span class="nx">colocar_pieza</span><span class="p">()</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">casilla</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">casilla</span><span class="dl">'</span><span class="p">).</span><span class="nx">value</span><span class="p">;</span>
      <span class="c1">// A partir de aquí, iría el código para colocar la pieza del jugador en esa casilla</span>
   <span class="p">}</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div> <p>Al hacer clic en el botón, se ejecutará la función <em>colocar_pieza()</em>. Observa cómo se extrae el texto escrito en el cuadro de texto para llevárnoslo a una variable de Javascript (llamada <em>casilla</em>).</p> <p>También puedes mejorar la apariencia del juego alterando sus colores, tipografías, etc. Tendrás que investigar un poco en internet sobre cómo puede hacerse eso.</p> <h4 id="ejercicio-8-tenis"> <a href="#ejercicio-8-tenis" class="anchor-heading" aria-labelledby="ejercicio-8-tenis"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ejercicio 8. Tenis </h4> <p>(Aviso: este ejercicio es de dificultad elevada)</p> <p>Ya sabes hacer que una pelota rebote (ejercicio 5). <strong>Vamos a mejorar ese programa haciendo una versión del clásico juego de tenis <em>“Pong”</em></strong>, el primer videojuego comercial de la historia.</p> <p>Si no conoces el <em>Pong</em>, bichea un poco por Internet para averiguar cómo es.</p> <p>¡Y ahora trata de programar una versión actualizada en Javascript!</p> <h4 id="ejercicio-9-carretera-al-infierno"> <a href="#ejercicio-9-carretera-al-infierno" class="anchor-heading" aria-labelledby="ejercicio-9-carretera-al-infierno"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ejercicio 9. Carretera al infierno </h4> <p>(Aviso: este ejercicio es de dificultad elevada)</p> <p>En esta ocasión, vamos a programar <strong>un juego que llamaremos “Carretera al infierno”</strong>.</p> <p>En el juego, manejaremos un coche (busca en internet la imagen de un coche visto desde arriba). El coche aparecerá en la parte inferior de la pantalla, centrado y mirando hacia arriba.</p> <p>Una carretera irá desplazándose de arriba a abajo. La carretera no será recta, sino que tendrá irregularidades aleatorias hacia la izquierda y hacia la derecha. Nuestro objetivo es mover el coche hacia la izquierda y hacia la derecha para evitar que se salga de la carretera.</p> <p>La carreterá se moverá cada vez más deprisa. <strong>El objetivo del juego es aguantar la mayor cantidad posible de tiempo sin salirnos.</strong></p> <h2 id="97-ejercicios-resueltos"> <a href="#97-ejercicios-resueltos" class="anchor-heading" aria-labelledby="97-ejercicios-resueltos"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.7. Ejercicios resueltos </h2> <p>Aquí iremos poniendo los ejercicios que resolvamos en clase.</p> <h4 id="ejercicio-1-tabla-de-multiplicar-1"> <a href="#ejercicio-1-tabla-de-multiplicar-1" class="anchor-heading" aria-labelledby="ejercicio-1-tabla-de-multiplicar-1"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ejercicio 1. Tabla de multiplicar </h4> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;h1&gt;</span>Tabla de multiplicar<span class="nt">&lt;/h1&gt;</span>
<span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">'salida'</span> <span class="na">style=</span><span class="s">'text-align: center; border-style: solid; border-color: black'</span><span class="nt">&gt;&lt;/div&gt;</span>
<span class="nt">&lt;script&gt;</span>
   <span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">prompt</span><span class="p">(</span><span class="dl">"</span><span class="s2">Dime un número</span><span class="dl">"</span><span class="p">);</span>
   <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">salida</span><span class="dl">'</span><span class="p">).</span><span class="nx">innerHTML</span> <span class="o">+=</span> <span class="nx">n</span> <span class="o">+</span> <span class="dl">"</span><span class="s2"> x </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">i</span> <span class="o">+</span> <span class="dl">"</span><span class="s2"> = </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">n</span><span class="o">*</span><span class="nx">i</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">&lt;br&gt;</span><span class="dl">"</span><span class="p">;</span>
   <span class="p">}</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div> <hr> <h2 class="text-delta">Table of contents</h2> <ul> </ul> </div> </div> <div class="search-overlay"></div> </div> </body> </html>
