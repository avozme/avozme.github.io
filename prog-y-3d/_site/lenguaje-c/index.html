<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <title>9. El lenguaje C - PROG Y 3D</title> <link rel="shortcut icon" href="/docs/prog-y-3d/_site/favicon.ico" type="image/x-icon"> <link rel="stylesheet" href="/docs/prog-y-3d/_site/assets/css/just-the-docs-default.css"> <script type="text/javascript" src="/docs/prog-y-3d/_site/assets/js/vendor/lunr.min.js"></script> <script type="text/javascript" src="/docs/prog-y-3d/_site/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>El lenguaje C | PROG Y 3D</title> <meta name="generator" content="Jekyll v4.2.2" /> <meta property="og:title" content="El lenguaje C" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Apuntes de la asignatura “Introducción a la programación y al diseño 3D”, optativa de 2º curso de bachillerato ofertada por el IES Celia Viñas de Almería (España)" /> <meta property="og:description" content="Apuntes de la asignatura “Introducción a la programación y al diseño 3D”, optativa de 2º curso de bachillerato ofertada por el IES Celia Viñas de Almería (España)" /> <link rel="canonical" href="https://iescelia.org//docs/prog-y-3d/_site/lenguaje-c/" /> <meta property="og:url" content="https://iescelia.org//docs/prog-y-3d/_site/lenguaje-c/" /> <meta property="og:site_name" content="PROG Y 3D" /> <meta property="og:type" content="website" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="El lenguaje C" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","description":"Apuntes de la asignatura “Introducción a la programación y al diseño 3D”, optativa de 2º curso de bachillerato ofertada por el IES Celia Viñas de Almería (España)","headline":"El lenguaje C","url":"https://iescelia.org//docs/prog-y-3d/_site/lenguaje-c/"}</script> <!-- End Jekyll SEO tag --> </head> <body> <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header"> <a href="https://iescelia.org//docs/prog-y-3d/_site/" class="site-title lh-tight"> PROG Y 3D </a> <a href="#" id="menu-button" class="site-button"> <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg> </a> </div> <nav role="navigation" aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item active"><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="https://iescelia.org//docs/prog-y-3d/_site/" class="nav-list-link">Introd. a la prog. y al diseño 3D</a><ul class="nav-list "><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="https://iescelia.org//docs/prog-y-3d/_site/presentacion/" class="nav-list-link">0. Presentación de la asignatura</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="https://iescelia.org//docs/prog-y-3d/_site/bases-de-datos/" class="nav-list-link">1. Bases de datos</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="https://iescelia.org//docs/prog-y-3d/_site/lenguaje-sql/" class="nav-list-link">2. El lenguaje SQL</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="https://iescelia.org//docs/prog-y-3d/_site/tecnologias-de-impresion-3d/" class="nav-list-link">3. Tecnologías de impresión 3D</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="https://iescelia.org//docs/prog-y-3d/_site/modelado-e-impresion-3d/" class="nav-list-link">4. Modelado e impresión 3D</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="https://iescelia.org//docs/prog-y-3d/_site/pensamiento-computacional/" class="nav-list-link">5. Pensamiento computacional</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="https://iescelia.org//docs/prog-y-3d/_site/representacion-de-la-informacion/" class="nav-list-link">6. Representación de la información</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="https://iescelia.org//docs/prog-y-3d/_site/introduccion-a-la-programacion/" class="nav-list-link">7. Introducción a la programación</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="https://iescelia.org//docs/prog-y-3d/_site/estructuras-de-datos/" class="nav-list-link">8. Estructuras de datos. Subalgoritmos</a><ul class="nav-list"></ul></li><li class="nav-list-item active"><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="https://iescelia.org//docs/prog-y-3d/_site/lenguaje-c/" class="nav-list-link active">9. El lenguaje C</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="https://iescelia.org//docs/prog-y-3d/_site/orientacion-a-objetos-c++/" class="nav-list-link">10. Orientación a objetos con C++</a><ul class="nav-list"></ul></li></ul></li><li class="nav-list-item"><a href="https://iescelia.org//docs/prog-y-3d/_site/about/" class="nav-list-link">About</a></li></ul> </nav> <footer class="site-footer"> This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll. </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search PROG Y 3D" aria-label="Search PROG Y 3D" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> </div> <div id="main-content-wrap" class="main-content-wrap"> <nav aria-label="Breadcrumb" class="breadcrumb-nav"> <ol class="breadcrumb-nav-list"> <li class="breadcrumb-nav-list-item"><a href="https://iescelia.org//docs/prog-y-3d/_site/">Introd. a la prog. y al diseño 3D</a></li> <li class="breadcrumb-nav-list-item"><span>9. El lenguaje C</span></li> </ol> </nav> <div id="main-content" class="main-content" role="main"> <h1 class="no_toc" id="9-el-lenguaje-c"> <a href="#9-el-lenguaje-c" class="anchor-heading" aria-labelledby="9-el-lenguaje-c"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9. El lenguaje C </h1> <ul id="markdown-toc"> <li><a href="#91-orientándose-en-la-jungla-de-los-lenguajes-de-programación" id="markdown-toc-91-orientándose-en-la-jungla-de-los-lenguajes-de-programación">9.1. Orientándose en la jungla de los lenguajes de programación</a> <ul> <li><a href="#911-tipos-de-lenguaje-según-el-nivel-de-abstracción-alto-y-bajo-nivel" id="markdown-toc-911-tipos-de-lenguaje-según-el-nivel-de-abstracción-alto-y-bajo-nivel">9.1.1. Tipos de lenguaje según el nivel de abstracción: alto y bajo nivel</a></li> <li><a href="#912-tipos-de-lenguaje-según-su-generación" id="markdown-toc-912-tipos-de-lenguaje-según-su-generación">9.1.2. Tipos de lenguaje según su generación</a></li> <li><a href="#913-tipos-de-lenguaje-según-su-forma-de-traducción" id="markdown-toc-913-tipos-de-lenguaje-según-su-forma-de-traducción">9.1.3. Tipos de lenguaje según su forma de traducción</a></li> <li><a href="#914-tipos-de-lenguaje-según-su-tipado" id="markdown-toc-914-tipos-de-lenguaje-según-su-tipado">9.1.4. Tipos de lenguaje según su tipado</a></li> <li><a href="#915-el-top-ten-de-los-lenguajes-de-programación" id="markdown-toc-915-el-top-ten-de-los-lenguajes-de-programación">9.1.5. El <em>top ten</em> de los lenguajes de programación</a></li> </ul> </li> <li><a href="#92-bienvenidos-a-c" id="markdown-toc-92-bienvenidos-a-c">9.2. ¡Bienvenidos a C!</a> <ul> <li><a href="#921--características-básicas-de-c" id="markdown-toc-921--características-básicas-de-c">9.2.1. Características básicas de C</a></li> <li><a href="#922-breve-historia-de-c" id="markdown-toc-922-breve-historia-de-c">9.2.2. Breve historia de C</a></li> <li><a href="#923-sintaxis-básica-de-c" id="markdown-toc-923-sintaxis-básica-de-c">9.2.3. Sintaxis básica de C</a></li> <li><a href="#924-conversiones-de-tipo" id="markdown-toc-924-conversiones-de-tipo">9.2.4. Conversiones de tipo</a></li> <li><a href="#925-asignación" id="markdown-toc-925-asignación">9.2.5. Asignación</a></li> <li><a href="#926-operadores-y-expresiones" id="markdown-toc-926-operadores-y-expresiones">9.2.6. Operadores y expresiones</a></li> <li><a href="#927-estructuras-de-control" id="markdown-toc-927-estructuras-de-control">9.2.7. Estructuras de control</a></li> <li><a href="#928-algoritmo-principal-y-subalgoritmos" id="markdown-toc-928-algoritmo-principal-y-subalgoritmos">9.2.8. Algoritmo principal y Subalgoritmos</a></li> <li><a href="#929-entrada-y-salida-en-c" id="markdown-toc-929-entrada-y-salida-en-c">9.2.9. Entrada y salida en C</a></li> <li><a href="#9210-cadenas-de-caracteres" id="markdown-toc-9210-cadenas-de-caracteres">9.2.10. Cadenas de caracteres</a></li> <li><a href="#9211-arrays" id="markdown-toc-9211-arrays">9.2.11. Arrays</a></li> <li><a href="#9212-funciones-de-la-librería-estándar" id="markdown-toc-9212-funciones-de-la-librería-estándar">9.2.12. Funciones de la librería estándar</a></li> <li><a href="#9213-librerías-no-estándar-que-molan-ncurses" id="markdown-toc-9213-librerías-no-estándar-que-molan-ncurses">9.2.13. Librerías no estándar que molan: ncurses</a></li> <li><a href="#9214-librerías-no-estándar-que-molan-sdl" id="markdown-toc-9214-librerías-no-estándar-que-molan-sdl">9.2.14. Librerías no estándar que molan: SDL</a></li> </ul> </li> <li><a href="#93-escribiendo-programas-en-c" id="markdown-toc-93-escribiendo-programas-en-c">9.3. Escribiendo programas en C</a> <ul> <li><a href="#931-estructura-de-un-programa-en-c" id="markdown-toc-931-estructura-de-un-programa-en-c">9.3.1. Estructura de un programa en C</a></li> <li><a href="#932-caja-de-herramientas" id="markdown-toc-932-caja-de-herramientas">9.3.2. Caja de herramientas</a></li> <li><a href="#933-flujo-de-trabajo" id="markdown-toc-933-flujo-de-trabajo">9.3.3. Flujo de trabajo</a></li> <li><a href="#934-dónde-y-cómo-escribir-el-código-fuente" id="markdown-toc-934-dónde-y-cómo-escribir-el-código-fuente">9.3.4. Dónde y cómo escribir el código fuente</a></li> </ul> </li> <li><a href="#94-c-avanzado-punteros-y-estructuras-de-datos" id="markdown-toc-94-c-avanzado-punteros-y-estructuras-de-datos">9.4. C avanzado: punteros y estructuras de datos</a></li> <li><a href="#95-un-ejemplo-completo-las-tres-en-raya" id="markdown-toc-95-un-ejemplo-completo-las-tres-en-raya">9.5. Un ejemplo completo: las tres en raya</a> <ul> <li><a href="#951-el-código-fuente" id="markdown-toc-951-el-código-fuente">9.5.1. El código fuente</a></li> <li><a href="#952-cómo-ejecutar-y-depurar-este-programa" id="markdown-toc-952-cómo-ejecutar-y-depurar-este-programa">9.5.2. ¿Cómo ejecutar y depurar este programa?</a></li> </ul> </li> <li><a href="#96-ejercicios-propuestos" id="markdown-toc-96-ejercicios-propuestos">9.6. Ejercicios propuestos</a></li> <li><a href="#97-ejercicios-resueltos" id="markdown-toc-97-ejercicios-resueltos">9.7. Ejercicios resueltos</a></li> </ul> <p>El ordenador, como ya sabrás a estas alturas, solo puede manejar ceros y unos, es decir, código o <strong>lenguaje binario</strong>. Los seres humanos, por el contrario, utilizamos un lenguaje mucho más complejo, con montones de símbolos y reglas sintácticas y semánticas, que denominamos <strong>lenguaje natural</strong> (aunque de “natural” tiene poco).</p> <p>Entre estos dos extremos (lenguaje binario y lenguaje natural) se encuentran los <strong>lenguajes de programación</strong>. Tienen cierto parecido con el lenguaje natural, pero son mucho más reducidos y estrictos en su sintaxis y semántica, para acercarse a las limitaciones del lenguaje binario.</p> <p>En este capítulo vamos a aprender a escribir algoritmos con un lenguaje llamado <strong>C</strong> y, más adelante, con una variante de C llamada <strong>C++</strong>. Se trata, en realidad, de dos lenguajes de programación distintos, si bien C++ es un superconjunto de C, es decir, todo el lenguaje C está incluido en C++ y, además, tiene algunas cosas adicionales.</p> <p>Se trata de dos lenguajes muy veteranos pero que siguen gozando de una gran popularidad en el mundo profesional de la programación, sobre todo de la programación de sistemas u otros programas que requieran gran velocidad de procesamiento, como los motores de videojuegos.</p> <p>Lenguajes de programación hay muchos, así que también hablaremos de otros lenguajes y conoceremos los tipos y características de algunos de ellos.</p> <h2 id="91-orientándose-en-la-jungla-de-los-lenguajes-de-programación"> <a href="#91-orientándose-en-la-jungla-de-los-lenguajes-de-programación" class="anchor-heading" aria-labelledby="91-orientándose-en-la-jungla-de-los-lenguajes-de-programación"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.1. Orientándose en la jungla de los lenguajes de programación </h2> <p>Los lenguajes de programación constituyen un ecosistema muy extenso y en constante evolución. Para orientarse un poco en esa jungla, nada mejor que clasificar los lenguajes igual que los biólogos clasifican a las criaturas vivas.</p> <h3 id="911-tipos-de-lenguaje-según-el-nivel-de-abstracción-alto-y-bajo-nivel"> <a href="#911-tipos-de-lenguaje-según-el-nivel-de-abstracción-alto-y-bajo-nivel" class="anchor-heading" aria-labelledby="911-tipos-de-lenguaje-según-el-nivel-de-abstracción-alto-y-bajo-nivel"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.1.1. Tipos de lenguaje según el nivel de abstracción: alto y bajo nivel </h3> <p>Hay lenguajes de programación muy próximos al lenguaje binario: a éstos los llamamos <strong>lenguajes de bajo nivel</strong> de abstracción. Y los hay más próximos al lenguaje natural: son los <strong>lenguajes de alto nivel</strong> de abstracción.</p> <h4 id="lenguajes-de-bajo-nivel"> <a href="#lenguajes-de-bajo-nivel" class="anchor-heading" aria-labelledby="lenguajes-de-bajo-nivel"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Lenguajes de bajo nivel </h4> <p>Son los lenguajes más cercanos a la máquina. Los programas directamente escritos en código binario se dice que están en <strong>lenguaje máquina</strong> que, por lo tanto, es el lenguaje de más bajo nivel que existe.</p> <p>Las instrucciones del lenguaje máquina realizan tareas muy sencillas, como, por ejemplo, sumar dos números, detectar qué tecla se ha pulsado en el teclado o escribir algo en la pantalla del ordenador. Cuando se combinan adecuadamente muchas de estas instrucciones sencillas se obtiene un programa de ordenador que puede realizar tareas muy complejas.</p> <p>Por ejemplo, este puede ser el aspecto de una instrucción en lenguaje máquina para sumar dos números:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0001 000100000101 110100110101
</code></pre></div></div> <p>Incomprensible, ¿verdad?</p> <p>A pesar de la simplicidad de las instrucciones del lenguaje máquina, la forma de escribirlas es muy complicada, ya que hay que hacerlo en binario. En los primeros años de la informática los ordenadores se programaban directamente en lenguaje máquina, lo cual convertía la tarea de programar en una verdadera pesadilla. Hoy en día nadie lo hace.</p> <p>Cuando los ordenadores fueron haciéndose más potentes, surgió la idea de utilizar el propio ordenador como <strong>traductor</strong>: ¿por qué no escribir instrucciones en un lenguaje más parecido al natural y que un programa de ordenador se encargue de traducir esa instrucción a su correspondiente instrucción en lenguaje máquina?</p> <p>Así apareció el <strong>lenguaje ensamblador</strong>, cuyas instrucciones son equivalentes a las del lenguaje máquina, pero se escriben con palabras similares a las del lenguaje humano. Por ejemplo, para sumar dos números, la instrucción en ensamblador puede tener un aspecto como este:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ADD D1 D2
</code></pre></div></div> <h4 id="lenguajes-de-alto-nivel"> <a href="#lenguajes-de-alto-nivel" class="anchor-heading" aria-labelledby="lenguajes-de-alto-nivel"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Lenguajes de alto nivel </h4> <p>Siguiendo el razonamiento anterior (utilizar el propio ordenador como traductor), en la década de 1960 y, sobre todo, de 1970, se empezaron a desarrollar lenguajes cada vez más complejos, en los que cada instrucción ya no se correspondía exactamente con una instrucción del lenguaje máquina, sino con varias. Estos son los <strong>lenguajes de alto nivel</strong>.</p> <p>Lógicamente, la traducción desde un lenguaje de alto nivel a lenguaje máquina es mucho más compleja que desde lenguaje ensamblador, por lo que <em>los traductores se han hecho cada vez más complicados</em>.</p> <p>Una característica muy importante de los lenguajes de alto nivel es que <strong>son independientes del hardware</strong>, lo que implica que los programas desarrollados con estos lenguajes pueden ser ejecutados en ordenadores con hardware totalmente distinto. A esto se le llama <strong>portabilidad</strong>.</p> <p>Los programas encargados de traducir el código de alto nivel a código máquina se llaman <strong>compiladores</strong> e <strong>intérpretes</strong>. Son programas muy complejos que generan el código binario equivalente al código de alto nivel para una máquina concreta. Por lo tanto, el programa de alto nivel, que es portable de un hardware a otro, debe ser traducido a código máquina en cada tipo de máquina en la que se pretenda ejecutar.</p> <p>Los ejemplos de lenguajes de alto nivel son innumerables, y la lista incluye casi todos de los que has oído hablar alguna vez: Basic, Cobol, Fortran, Ada, C/C++, PHP, Python, Java, Perl, Ruby, Javascript, etc.</p> <h4 id="ventajas-e-inconvenientes-de-los-lenguajes-de-alto-y-bajo-nivel"> <a href="#ventajas-e-inconvenientes-de-los-lenguajes-de-alto-y-bajo-nivel" class="anchor-heading" aria-labelledby="ventajas-e-inconvenientes-de-los-lenguajes-de-alto-y-bajo-nivel"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ventajas e inconvenientes de los lenguajes de alto y bajo nivel </h4> <div class="table-wrapper"><table> <thead> <tr> <th><strong>LENGUAJES DE BAJO NIVEL</strong></th> <th><strong>LENGUAJES DE ALTO NIVEL</strong></th> </tr> </thead> <tbody> <tr> <td><strong>Ventajas</strong></td> <td><strong>Inconvenientes</strong></td> </tr> <tr> <td>Son comprensibles directamente por la máquina (aunque el ensamblador necesita una pequeña traducción)</td> <td>Necesitan ser traducidos por medio de complicados programas (compiladores e intérpretes)</td> </tr> <tr> <td>Los programas se ejecutan muy rápidamente (si están bien escritos, claro)</td> <td>La traducción automática del código de alto nivel al código máquina siempre genera programas menos eficientes que si se escribieran directamente en binario</td> </tr> <tr> <td>Ocupan menos espacio en memoria</td> <td>Ocupan más espacio en memoria</td> </tr> <tr> <td>Permiten controlar directamente el hardware, por lo que son apropiados para la programación de sistemas</td> <td>En general, solo pueden acceder al hardware utilizando al sistema operativo como intermediario. Pero, entonces, ¿cómo programar el sistema operativo, que necesita controlar directamente el hardware?</td> </tr> <tr> <td><strong>Inconvenientes</strong></td> <td><strong>Ventajas</strong></td> </tr> <tr> <td>Son completamente dependientes del hardware. Un programa escrito para determinado tipo de máquina no funcionará en un ordenador con diferente arquitectura.</td> <td>Son portables, es decir, independientes del hardware. Un programa escrito en una máquina puede funcionar en otra con hardware distinto, siempre que se vuelva a traducir a binario en la máquina nueva.</td> </tr> <tr> <td>Incluso los programas más sencillos son largos y farragosos</td> <td>Los programas son más sencillos, ya que una sola instrucción puede equivaler a varias instrucciones binarias.</td> </tr> <tr> <td>Los programas son difíciles de escribir, depurar y mantener</td> <td>Los programas son más fáciles de escribir, depurar y mantener</td> </tr> <tr> <td>Es imposible resolver problemas muy complejos</td> <td>Es posible, aunque difícil, enfrentarse a problemas muy complejos</td> </tr> </tbody> </table></div> <p>Si echas un vistazo a la tabla anterior comprenderás que, en general, <strong>es preferible usar lenguajes de alto nivel</strong> la gran mayoría de las veces, reservando los de bajo nivel para casos muy concretos, como el desarrollo de ciertas partes de los sistemas operativos.</p> <p>También hay que destacar que no todos los lenguajes de alto nivel son iguales. Los hay de más alto nivel que otros. El lenguaje C, por ejemplo, tiene menor nivel de abstracción que, por ejemplo, Java. Esto hace que los programas escritos en C sean más rápidos y eficientes que los escritos en Java, aunque también pueden llegar a ser más difíciles de escribir y depurar.</p> <h3 id="912-tipos-de-lenguaje-según-su-generación"> <a href="#912-tipos-de-lenguaje-según-su-generación" class="anchor-heading" aria-labelledby="912-tipos-de-lenguaje-según-su-generación"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.1.2. Tipos de lenguaje según su generación </h3> <p>Los lenguajes de programación también se clasifican según la generación a la que pertenecen.</p> <p>El lenguaje máquina fue el lenguaje de primera generación. Los ensambladores fueron los lenguajes de segunda generación. A partir de ahí, surgió una explosión de lenguajes diferentes que podemos clasificar como:</p> <ul> <li><strong>Lenguajes de tercera generación</strong> (o <strong>imperativos</strong>), en los que el programador escribe una secuencia de instrucciones que el ordenador debe ejecutar en un orden preestablecido. Son los lenguajes más “clásicos”: C, Basic, Cobol, Fortran, Pascal, etc.</li> <li><strong>Lenguajes de cuarta generación</strong> (o <strong>4GL</strong>), dirigidos a facilitar la creación de interfaces con el usuario y con otras aplicaciones, como las bases de datos. Un ejemplo de estos lenguajes es SQL, universalmente utilizado para manipular bases de datos y omnipresente en muchas aplicaciones web actuales.</li> <li><strong>Lenguajes orientados a objetos</strong>, que son una evolucuión de los lenguajes de tercera generación y que permiten construir con mayor facilidad y robustez programas modulares complejos. Ejemplos de lenguajes orientados a objetos son C++, C#, Java, Javascript, Python, PHP o Ruby. Algunos de ellos son multiparadigma, es decir, permiten programar con orientación a objetos pero también permiten hacer programación estructurada clásica, sin objetos.</li> <li><strong>Lenguajes declarativos</strong> y <strong>lenguajes funcionales</strong>, propios de la inteligencia artificial, como Prolog o Lisp.</li> <li><strong>Otros</strong> tipos aún más específicos: lenguajes concurrentes, paralelos, distribuidos, etc.</li> </ul> <p>En general, podemos decir que un programador acostumbrado a trabajar con un lenguaje de tercera generación puede aprender con poco esfuerzo cualquier otro lenguaje de tercera generación y, con algo más de trabajo, un lenguaje orientado a objetos. Sin embargo, el “salto” a otros tipos de lenguajes, como los declarativos, cuesta más porque las fundamentos de estos lenguajes son muy diferentes.</p> <h3 id="913-tipos-de-lenguaje-según-su-forma-de-traducción"> <a href="#913-tipos-de-lenguaje-según-su-forma-de-traducción" class="anchor-heading" aria-labelledby="913-tipos-de-lenguaje-según-su-forma-de-traducción"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.1.3. Tipos de lenguaje según su forma de traducción </h3> <p>Cuando programamos en un lenguaje distinto del lenguaje máquina, <strong>nuestro código debe ser traducido a binario</strong> para que el ordenador pueda entenderlo y ejecutarlo. Existe un programa específico encargado de hacer esa traducción y que, dependiendo del lenguaje en el que hayamos escrito nuestro programa, puede ser un <em>ensamblador</em>, un <em>compilador</em> o un <em>intérprete</em>.</p> <h4 id="ensambladores"> <a href="#ensambladores" class="anchor-heading" aria-labelledby="ensambladores"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ensambladores </h4> <p>Se llaman <strong>ensambladores</strong> los programas encargados de <strong>traducir los programas escritos en ensamblador a código binario</strong>.</p> <p>Sí, ya lo sé: se usa el mismo nombre para referirse al <em>lenguaje</em> de programación y al <em>traductor</em> de ese lenguaje a código máquina. Es un lío.</p> <p>Como el lenguaje ensamblador es muy próximo al binario, estos traductores son programas relativamente sencillos.</p> <h4 id="compiladores"> <a href="#compiladores" class="anchor-heading" aria-labelledby="compiladores"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Compiladores </h4> <p>El <strong>compilador</strong> es un programa que traduce el <strong>código de alto nivel a código binario</strong>.</p> <p>Es, por tanto, parecido al ensamblador, pero mucho más complejo, ya que las diferencias entre los lenguajes de alto nivel y el código binario son muy grandes.</p> <p>El programa escrito en lenguaje de alto nivel se denomina programa fuente o <strong>código fuente</strong>. El programa traducido a código binario se llama programa objeto o <strong>código objeto</strong>. Por lo tanto, el compilador se encarga de convertir el programa fuente en un programa objeto.</p> <p>Una vez que se ha obtenido el código objeto ya no es necesario volver a realizar la traducción (o compilación), a menos que se haga alguna modificación en el programa fuente, en cuyo caso habría que volver a compilarlo.</p> <p>El código objeto, una vez generado, puede ejecutarse en la máquina en la que fue compilado, o en otra de similares características (procesador, sistema operativo, etc.). Cuando se usa programación modular, puede ser necesario un proceso previo de enlace de los diferentes módulos antes de poder construir el programa ejecutable.</p> <h4 id="intérpretes"> <a href="#intérpretes" class="anchor-heading" aria-labelledby="intérpretes"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Intérpretes </h4> <p>El <strong>intérprete</strong> es un programa que <strong>traduce el código de alto nivel a código binario</strong> pero, a diferencia del compilador, lo hace <strong>en tiempo de ejecución</strong>.</p> <p>Es decir, no existe un proceso previo de traducción de todo el código fuente a código binario, sino que se va traduciendo y ejecutando instrucción por instrucción.</p> <h4 id="compiladores-frente-a-intérpretes"> <a href="#compiladores-frente-a-intérpretes" class="anchor-heading" aria-labelledby="compiladores-frente-a-intérpretes"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Compiladores frente a intérpretes </h4> <p>El <strong>intérprete</strong> es notablemente <strong>más lento</strong> que el compilador, ya que realiza la traducción al mismo tiempo que la ejecución. Además, esa traducción se lleva a cabo siempre que se ejecuta el programa, mientras que el compilador sólo la hace una vez. Hay un evidente malgasto de recursos.</p> <p>Sin embargo, los intérpretes tienen una gran ventaja sobre los compiladores, y es que logran que <strong>los programas sean más portables</strong>, es decir, que puedan ejecutarse en diferentes máquinas con diferentes sistemas operativos sin apenas cambios.</p> <p>Así, un programa <em>compilado</em> en una máquina PC bajo Windows no funcionará en un Mac o en un PC bajo Linux, a menos que se vuelva a compilar el programa fuente en el nuevo sistema. En cambio, un programa <em>interpretado</em> funcionará en todas las plataformas, siempre que dispongamos del intérprete en cada una de ellas.</p> <p><strong>C/C++ es un ejemplo de lenguaje compilado. Python es un ejemplo de lenguaje interpretado.</strong></p> <p>Eso significa que un programa escrito, por ejemplo, con <strong>Python</strong>, puede funcionar en cualquier máquina que disponga de un intérperte Python, que, hoy en día, es casi cualquiera. Por eso, <strong>cualquier programa escrito en Python puede ejecutarse prácticamente en cualquier ordenador del mundo</strong> sin tocarle ni una coma.</p> <p>En cambio, los programas desarrollados con C/C++ se ejecuten <strong>más rápido</strong> (¡pero mucho más rápido!) que sus equivalentes en Python. Sin embargo, <strong>tendrás que volver a compilarlos</strong> si deseas ejecutarlos en una máquina con diferente hardware o diferente sistema operativo.</p> <h3 id="914-tipos-de-lenguaje-según-su-tipado"> <a href="#914-tipos-de-lenguaje-según-su-tipado" class="anchor-heading" aria-labelledby="914-tipos-de-lenguaje-según-su-tipado"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.1.4. Tipos de lenguaje según su tipado </h3> <p>Por <em>tipado</em> nos referimos a la forma en la que los lenguajes de programación usan los tipos de datos. Ya sabes: entero, carácter, lógico, etc. Es decir, las categorías a las que puede pertenecer una variable.</p> <p>Pues bien, según su tipado, los lenguajes pueden ser:</p> <ul> <li><strong>De tipado fuerte</strong>: los tipos de datos no pueden mezclarse. Por ejemplo, no puedes sumar un entero y un real, porque son números de distinto tipo. Y mucho menos sumar un entero con un carácter.</li> <li><strong>De tipado débil</strong>: los tipos de datos pueden mezclarse y el lenguaje hace las conversiones de tipos implícitas que le parezca oportunas. Así, en estos lenguajes podrías sumar un entero con un real, o incluso un entero con un carácter. ¿Que cuál sería el resultado? Buena pregunta. Tendrás que probarlo, porque eso depende de las conversiones de tipo que haga el lenguaje.</li> <li><strong>De tipado estático</strong>: los tipos de datos se asignan al escribir el código y no pueden cambiarse durante la ejecución. Esto es típico de los compiladores (aunque no de todos).</li> <li><strong>De tipado dinámico</strong>: los tipos de datos pueden cambiarse alegremente durante la ejecución. Esto es típico de los intérpretes.</li> </ul> <p>Las dos primeras categorías y las dos segundas no son excluyentes. Por ejemplo, pueden existir lenguajes de tipado débil y dinámico, o bien fuerte y estático. Las otras combinaciones (fuerte y dinámico, débil y estático) pueden darse pero son menos habituales.</p> <h3 id="915-el-top-ten-de-los-lenguajes-de-programación"> <a href="#915-el-top-ten-de-los-lenguajes-de-programación" class="anchor-heading" aria-labelledby="915-el-top-ten-de-los-lenguajes-de-programación"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.1.5. El <em>top ten</em> de los lenguajes de programación </h3> <p>Es difícil saber cuales son los lenguajes más populares en un determinado momento porque no existen estadísticas fiables a nivel mundial. Además, las cosas pueden cambiar mucho de un territorio a otro.</p> <p>Sin embargo, ciertos sitios de internet, como <strong>GitHub</strong>, almacenan enormes cantidades de proyectos de software. GitHub, de hecho, es el mayor almacén de código fuente conocido, de modo que sus estadísticas nos pueden dar una idea bastante exacta de cuál es el grado de uso de cada lenguaje.</p> <p>Según <a href="https://madnight.github.io/githut">Madnight</a>, un proyecto que recopila y publica estadísticas de uso de lenguajes en GitHub, el <em>top ten</em> de lenguajes de programación más usados en GitHub es:</p> <div class="table-wrapper"><table> <thead> <tr> <th>Puesto</th> <th>Lenguaje</th> <th>Porcentaje de uso</th> <th>Variación de uso en 12 meses</th> </tr> </thead> <tbody> <tr> <td>1</td> <td>JavaScript</td> <td>17.955%</td> <td>-2.192%</td> </tr> <tr> <td>2</td> <td>Python</td> <td>15.943%</td> <td>+0.071%</td> </tr> <tr> <td>3</td> <td>Java</td> <td>12.977%</td> <td>+1.573%</td> </tr> <tr> <td>4</td> <td>Go</td> <td>8.203%</td> <td>-0.612%</td> </tr> <tr> <td>5</td> <td>TypeScript</td> <td>7.212%</td> <td>-0.276%</td> </tr> <tr> <td>6</td> <td>C++</td> <td>6.683%</td> <td>-0.251%</td> </tr> <tr> <td>7</td> <td>Ruby</td> <td>6.488%</td> <td>+0.303%</td> </tr> <tr> <td>8</td> <td>PHP</td> <td>4.937%</td> <td>-0.093%</td> </tr> <tr> <td>9</td> <td>C#</td> <td>3.366%</td> <td>-0.350%</td> </tr> <tr> <td>10</td> <td>C</td> <td>2.958%</td> <td>+0.068%</td> </tr> </tbody> </table></div> <p>El porcentaje de uso indica la proporción de proyectos en GitHub que usan ese lenguaje de programación sobre el total de proyectos. La última cifra señala la variación interanual del porcentaje de uso.</p> <p>Estos datos son de tercer cuatrimestre de 2021. Para obtener datos de otras fechas, puedes visitar la web <a href="https://madnight.github.io/">https://madnight.github.io/</a></p> <p>Ten en cuenta de nuevo que esto no son cifras de uso absoluto de los lenguajes a nivel mundial. Solo se trata de una pista de cuál es la situación. De hecho, si consultas otras estadísticas como el <a href="https://tiobe.com/tiobe-index/">TIOBE index</a>, encontrarás datos diferentes.</p> <p>Según estas cifras, el conjunto de proyectos que usan lenguaje C o cualquiera de sus variantes (C++ o C#) es muy significativo, sobre todo teniendo en cuenta que C es un lenguaje de la década de 1970, lo cual constituye una eternidad en informática. Que un lenguaje mantenga su vigencia durante tanto tiempo indica lo robusto y confiable que es. Seguramente seguirá con nosotros dentro de muchos años, cuando otros competidores de esta lista ya hayan caído en el olvido.</p> <h2 id="92-bienvenidos-a-c"> <a href="#92-bienvenidos-a-c" class="anchor-heading" aria-labelledby="92-bienvenidos-a-c"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.2. ¡Bienvenidos a C! </h2> <p>C es un lenguaje muy antiguo pero plenamente vigente en muchos ámbitos de la <strong>informática y diversas ingenierías</strong>.</p> <p>¡C tiene más de 50 años, lo que es una auténtica burrada en informática!</p> <p>Sin embargo, sigue usándose en la actualidad. <strong>Por algo será.</strong></p> <p>Por un lado, C genera código máquina tan eficiente que ningún otro lenguaje puede igualarlo. Y puedes acceder directamente al hardware de tu máquina desde C, o incluso incrustar código ensamblador.</p> <p>Por si esto fuera poco, C (o su hermano mayor, C++, que veremos en el siguiente tema) se utiliza mucho en la actualidad en diversos ámbitos donde se necesita acceder al hardware o que los programas se ejecuten muy, muy rápido:</p> <ul> <li>Desarrollo de sistemas. Gran parte de Windows, Linux, iOS o Android están programados en C.</li> <li>Desarrollo de drivers para los sistemas operativos.</li> <li>Robótica y automática.</li> <li>Sistemas integrados en electrodomésticos: televisores, microondas, frigoríficos, routers, etc.</li> <li>Sistemas integrados en los automóviles: ABS, ESP, climatización, visualización de información en tiempo real, control de los sensores…</li> <li>Aprendizaje. Con C aprenderás a programar de verdad, sin que librerías enormes o <em>frameworks</em> te oculten lo que pasa en las entrañas de la máquina.</li> </ul> <p>Por todas estas razones, C es un lenguaje estupendo para iniciarse en la programación, así que ¡vamos a ello!</p> <h3 id="921--características-básicas-de-c"> <a href="#921--características-básicas-de-c" class="anchor-heading" aria-labelledby="921--características-básicas-de-c"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.2.1. Características básicas de C </h3> <ul> <li>C es un lenguaje de <strong>nivel intermedio</strong>. Tiene características de los lenguajes de alto nivel pero, al mismo tiempo, permite manipular detalles del hardware que para otros lenguajes resultan innacesibles y genera código máquina ultrarrápido.</li> <li>Es <strong>imperativo y estructurado</strong>. Admite <strong>orientación a objetos</strong> (aunque entonces se llama C++).</li> <li>Su <strong>tipado es estático y débil</strong>. Eso significa que hay que indicar el tipo de datos de las variables antes de usarlas y que se pueden hacer mezclas de tipos.</li> <li>La <strong>sintaxis</strong> de sus estructuras de control se parece a las de Java, Javascript, PHP o Python, porque todos estos lenguajes son herederos naturales de C.</li> <li>Es un <strong>lenguaje compilado</strong>, pensado para producir código máquina rápido y eficiente. Si quieres velocidad de ejecución, C es tu lenguaje.</li> <li>Es <strong>altamente portable</strong> (para ser un lenguaje compilado). Existen compiladores de C para todos los sistemas y arquitecturas. Si respetas el estándar de C, no tendrás dificultad para migrar las aplicaciones a cualquier sistema.</li> <li>Es un lenguaje de programación <strong>muy popular</strong> y <strong>muy veterano</strong>. Aunque se ha intentado reemplazar muchas veces, ningún lenguaje lo ha conseguido y tiene una base de programadores muy fieles.</li> </ul> <h3 id="922-breve-historia-de-c"> <a href="#922-breve-historia-de-c" class="anchor-heading" aria-labelledby="922-breve-historia-de-c"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.2.2. Breve historia de C </h3> <p>A principios de la década de 1970, los laboratorios Bell necesitaban un nuevo sistema operativo. Hasta ese momento, la mayoría de los sistemas operativos estaban escritos en lenguaje ensamblador (muy parecido al lenguaje máquina) para que el resultado fuera un programa lo suficientemente rápido.</p> <p>Pero los programas escritos en ensamblador son difíciles de mantener y Bell quería que su nuevo sistema operativo se pudiera mantener y modificar con facilidad. Por lo tanto, se decidieron a inventar un lenguaje nuevo con el que programar su sistema operativo.</p> <p>Tras varios intentos, Brian Kerningham y Dennis Ritchie, dos ingenieros de laboratorios Bell, terminaron de diseñar el lenguaje C en un ordenador DEC PDP-11 y, con él, desarrollaron el sistema operativo Unix.</p> <p>El tándem C - Unix ha sido una referencia fundamental en el mundo de la programación en el último medio siglo, y C se ha convertido en uno de los lenguajes de programación más populares y longevos de la historia de la informática. C creció en popularidad muy rápidamente y sigue siendo uno de los lenguajes fundamentales tanto en el mundo educativo como en el mundo profesional.</p> <p>El primer estándar de C (ANSI C) no apareció hasta 1990, por lo que es posible encontrar diferentes dialectos de C ligeramente incompatibles entre sí.</p> <p>Una evolución de C fue el lenguaje C++ que, a parte de todas las características del ANSI C, incluye la posibilidad de orientación a objetos, una técnica de programación ligeramente diferente de la programación estructurada. Algo más tarde, en el año 2000, Microsoft patentó el lenguaje C#, otra evolución de C++ orientada al desarrollo de aplicaciones en red para la plataforma .NET de esta compañía.</p> <p>Otros lenguajes han sido diseñados para permitir que los no programadores puedan leer y comprender los programas y, presumiblemente, aprender a escribir los suyos propios para resolver problemas sencillos. Por el contrario, C fue creado, influenciado y probado en vivo por programadores profesionales. El resultado es que C da al programador lo que muchos programadores piden: unas pocas y bien escogidas palabras clave, una biblioteca poderosa y estandarizada, unas mínimas restricciones y un máximo control sobre lo que sucede en el interior de la máquina.</p> <p>Si a esto unimos que el código objeto generado por C es casi tan eficiente como el ensamblador, se entenderá por qué lleva medio siglo siendo uno de los lenguajes más populares entre los programadores profesionales.</p> <p>C también tiene sus detractores que lo acusan de ser confuso, críptico y demasiado flexible. En efecto, con C se pueden desarrollar las técnicas de programación estructurada, pero también se puede programar “código espagueti”. Esto, sin embargo, ocurre con todos los lenguajes: incluso los que tienen una sintaxis más estilizada y elegante, como Python o Ruby, pueden generar código absolutamente ininteligible en manos de un programador manazas.</p> <h3 id="923-sintaxis-básica-de-c"> <a href="#923-sintaxis-básica-de-c" class="anchor-heading" aria-labelledby="923-sintaxis-básica-de-c"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.2.3. Sintaxis básica de C </h3> <p>En este apartado vamos a aprender cómo se escriben en C las estructuras de control y el resto de instrucciones básicas.</p> <h4 id="generalidades-sintácticas"> <a href="#generalidades-sintácticas" class="anchor-heading" aria-labelledby="generalidades-sintácticas"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Generalidades sintácticas </h4> <p>Hay algunas normas básicas de la sintaxis de C que tienes que conocer:</p> <ul> <li><strong>Los bloques de código se marcan con las llaves</strong> ( <strong>{</strong> y <strong>}</strong> ). Por ejemplo, después de una sentencia <em>while</em> (equivalente al <em>mientras</em> de pseudocódigo) hay que abrir una llave. El cuerpo de bucle comprenderá desde esa llave de apertura hasta la siguiente llave de cierre, así:</li> </ul> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="k">while</span> <span class="p">(</span><span class="n">condicion</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Instrucci</span><span class="err">ó</span><span class="n">n</span> <span class="mi">1</span> <span class="n">del</span> <span class="n">bucle</span>
      <span class="n">Instrucci</span><span class="err">ó</span><span class="n">n</span> <span class="mi">2</span> <span class="n">del</span> <span class="n">bulce</span>
      <span class="p">...</span>
      <span class="n">Instrucci</span><span class="err">ó</span><span class="n">n</span> <span class="n">N</span> <span class="n">del</span> <span class="n">bucle</span>
   <span class="p">}</span>
</code></pre></div></div> <p>La llave de cierre, por tanto, sería el equivalente al <em>FinMientras</em> de pseudocódigo.</p> <ul> <li> <p>Todas las instrucciones <strong>terminan con un punto y coma</strong> ( <strong>;</strong> ). Excepción: si una instrucción contiene un bloque marcado con llaves ( { … } ), se considera que esa instrucción termina al cerrar el bloque, y en ese caso no hace falta poner punto y coma.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>                     <span class="cm">/* La instrucción de asignación termina con ; */</span>
 <span class="k">while</span> <span class="p">(</span><span class="n">condicion</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Cuerpo del bucle */</span>
 <span class="p">}</span>                           <span class="cm">/* El bucle termina con }, así que no necesita ; */</span>
</code></pre></div> </div> </li> <li> <p>Los <strong>identificadores</strong> de variables, funciones, etc., no pueden empezar con un número ni contener espacios o símbolos especiales, salvo el de subrayado ( _ )</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">a5</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>     <span class="cm">/* Identificador de variable válido */</span>
 <span class="mi">5</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>     <span class="cm">/* Identificador de variable NO válido */</span>
</code></pre></div> </div> </li> <li> <p>Las <strong>cadenas de caracteres</strong> deben encerrarse entre <strong>comillas dobles</strong> ( “…” ). Los <strong>caracteres</strong> individuales se encierran entre <strong>comillas simples</strong>.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="s">"Soy una cadena"</span><span class="p">;</span>   <span class="cm">/* Cadena de caracteres */</span>
 <span class="sc">'C'</span><span class="p">;</span>                <span class="cm">/* Carácter individual */</span>
</code></pre></div> </div> </li> <li> <p>El lenguaje es <strong>sensitivo a las mayúsculas</strong>. Es decir, no es lo mismo que una variable se llame <em>edad</em> que <em>Edad</em> o <em>EDAD</em>.</p> </li> </ul> <h4 id="tipos-de-datos-simples"> <a href="#tipos-de-datos-simples" class="anchor-heading" aria-labelledby="tipos-de-datos-simples"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Tipos de datos simples </h4> <p>C utiliza varios tipos de datos <strong>simples</strong> porque solo pueden contener un valor en cada momento (como en pseudocódigo). Los más importantes son:</p> <ul> <li><strong>int</strong>: números enteros. Admite modificadores como <strong>long</strong> (para enteros largos) o <strong>short</strong> (para enteros cortos). Por ejemplo, el tipo <em>int</em> permite usar números entre –32768 a 32767, mientras que el tipo <em>long int</em> admite números entre –2147483648 a 2147483647.</li> <li><strong>float</strong>: número reales. El tipo <strong>double</strong> se usa para lo mismo, pero tiene más precisión y admite números mayores.</li> <li><strong>char</strong>: caracteres.</li> <li><strong>void</strong>: vacío. Se usa en funciones que no devuelven nada o que tienen una lista de parámetros vacía.</li> </ul> <p>Observa que en C no existe el tipo de dato <strong>lógico o booleano</strong>. Se utiliza en su lugar el tipo <em>int</em>, representando el 0 el valor falso y cualquier otra cantidad (normalmente 1) el valor verdadero.</p> <h4 id="declaración-de-variables"> <a href="#declaración-de-variables" class="anchor-heading" aria-labelledby="declaración-de-variables"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Declaración de variables </h4> <p>Todas las variables tienen que <strong>declararse</strong> antes de su primer uso. Esto se hace así:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>   <span class="cm">/* Declaración de la variable a, de tipo entero */</span>
<span class="kt">char</span> <span class="n">b</span><span class="p">;</span>  <span class="cm">/* Declaración de la variable b, de tipo carácter */</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>  <span class="cm">/* Uso de la variable a */</span>
<span class="n">b</span> <span class="o">=</span> <span class="sc">'z'</span><span class="p">;</span> <span class="cm">/* Uso de la variable b */</span>
</code></pre></div></div> <p>Observa que, al declarar una variable, hay que especificar su tipo.</p> <p>Todas las variables son <strong>locales</strong> a la función o bloque de código donde estén definidas, salvo que se indique otra cosa, dejando de existir al finalizar el bloque actual. Aunque pueden crearse variables globales, su uso está tan desaconsejado que ni siquiera te voy a explicar cómo se hace.</p> <h3 id="924-conversiones-de-tipo"> <a href="#924-conversiones-de-tipo" class="anchor-heading" aria-labelledby="924-conversiones-de-tipo"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.2.4. Conversiones de tipo </h3> <p>C es un lenguaje <strong>débilmente tipado</strong>, es decir, no hace comprobaciones estrictas de tipos a la hora de asignar un valor a una variable o de comparar dos expresiones.</p> <p>Por ejemplo, estas instrucciones son correctas:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">a</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
</code></pre></div></div> <p>¡Hemos asignado un valor entero a la variable <em>a</em>, que es de tipo <em>float</em>!</p> <p>En otros lenguajes esto no está permitido, pero en C se realizan conversiones automáticas de tipo cuando en una misma expresión aparecen datos de tipos diferentes. Esto, que en principio es una ventaja, pues elimina algunas limitaciones engorrosas, otras veces es peligroso porque algunos datos pueden cambiar extrañamente de valor al hacerse esa conversión automática.</p> <p>La conversión puede ser de dos clases:</p> <ul> <li> <p><strong>Asignación de un valor a una variable que permita más precisión</strong>. Por ejemplo, asignar un número entero a una variable <em>float</em>. En este caso, el número se convierte a real añadiendo “.0” a la parte decimal. No hay pérdida de información.</p> </li> <li> <p><strong>Asignación de un valor a una variable que permita menos precisión</strong>. Por ejemplo, asignar un número <em>long int</em> a una variable de tipo <em>int</em>. En este caso, el número se recorta, perdiendo sus bits más significativos, es decir, los dígitos binarios que estén más a la izquierda. Por lo tanto, hay pérdida de información. Hay que tener mucho cuidado con este tipo de conversiones.</p> </li> </ul> <p>Además de las conversiones automáticas de tipo, el programador puede <strong>forzar la conversión de tipos</strong> a voluntad utilizando <strong>moldes</strong>.</p> <p>Un molde es una expresión de un tipo de datos entre paréntesis que aparece delante de un dato. Entonces, antes de evaluar la expresión, el dato es convertido al tipo especificado en el molde. Por ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">a</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</code></pre></div></div> <p>Sin el molde <code class="language-plaintext highlighter-rouge">(float)</code>, la división <code class="language-plaintext highlighter-rouge">a/2</code> sería entera, ya que a es una variable de tipo <em>int</em>, y se perdería la parte decimal. Al aplicar el molde, se convierte momentáneamente el valor entero 5 al valor real 5.0 y se evalúa la expresión, que ahora sí se realiza como división real, conservando sus decimales.</p> <h3 id="925-asignación"> <a href="#925-asignación" class="anchor-heading" aria-labelledby="925-asignación"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.2.5. Asignación </h3> <p>La <strong>asignación</strong> de valores a variables en C es fácil de explicar: se hace con el <strong>símbolo igual (=)</strong>, no con el símbolo &lt;= que usábamos en pseudocódigo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>      <span class="cm">/* Declaración de la variable a */</span>
<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Declaración y asignación de valor a la variable b */</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>  <span class="cm">/* Asignación de valor a la variable a */</span>
</code></pre></div></div> <p>Observa cómo, en la segunda instrucción, hemos declarado y asignado valor a una variable en la misma línea.</p> <h3 id="926-operadores-y-expresiones"> <a href="#926-operadores-y-expresiones" class="anchor-heading" aria-labelledby="926-operadores-y-expresiones"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.2.6. Operadores y expresiones </h3> <p>Los <strong>operadores y expresiones en C</strong> son iguales que los que hemos empleado en pseudocódigo:</p> <ul> <li>Operadores <strong>aritméticos</strong>: +, -, *, /, % (este último significa <em>módulo de la división</em>).</li> <li>Operadores <strong>relacionales</strong>: &gt;, &lt;, &gt;=, &lt;=…</li> </ul> <p>Sin embargo, hay algunas <strong>diferencias</strong> importantes entre el pseudocódigo de PseInt y C. Son estas:</p> <ul> <li> <p>La <strong>asignación</strong>, como ya hemos visto más arriba, se hace con el <strong>símbolo igual (=)</strong>, no con &lt;=.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>        <span class="cm">/* A la variable a se le asigna el valor 5 */</span>
 <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>    <span class="cm">/* A la variable b se le asigna el valor a + 1 */</span>
</code></pre></div> </div> </li> <li> <p>La <strong>comparación de igualdad</strong> se hace con un <strong>doble igual (==)</strong>, no con un solo igual (=). Esto es así para distinguir la comparación de la asignación.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>    <span class="cm">/* Comparación: ¿es a igual a 5? */</span>
     <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>   <span class="cm">/* Asignación: b toma el valor a + 1 */</span>
 <span class="p">}</span>
</code></pre></div> </div> </li> <li> <p>Existe el <strong>operador incremento (++)</strong>. Se utiliza para sumar una unidad a una variable.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">i</span><span class="o">++</span><span class="p">;</span>         <span class="cm">/* Esto es equivalente a: i = i + 1 */</span>
 <span class="p">}</span>
</code></pre></div> </div> </li> <li> <p>También existe el <strong>operador decremento (- -)</strong>, para restar una unidad a una variable.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">i</span><span class="o">--</span><span class="p">;</span>     <span class="cm">/* Equivalente a: i = i - 1 */</span>
 <span class="p">}</span>
</code></pre></div> </div> </li> <li> <p>Los <strong>operadores lógicos</strong> (Y, O, NO) se escriben de forma distinta:</p> <ul> <li><strong>Y</strong> se escribe <strong>&amp;&amp;</strong>.</li> <li><strong>O</strong> se escribe <strong>||</strong>.</li> <li><strong>NO</strong> se escribe <strong>!</strong> (sí, sí, es una admiración).</li> </ul> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>   <span class="cm">/* Operador Y: tienen que darse las dos condiciones a la vez */</span>
     <span class="p">...</span>
 <span class="p">}</span>
</code></pre></div> </div> </li> </ul> <p>Hay algunas otras diferencias, desde luego, pero con esto ya tienes para hacer un buen montón de programas.</p> <h3 id="927-estructuras-de-control"> <a href="#927-estructuras-de-control" class="anchor-heading" aria-labelledby="927-estructuras-de-control"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.2.7. Estructuras de control </h3> <p>Las <strong>estructuras de control</strong> en C son muy similares a las que hemos utilizado en pseudocódigo, cambiando ligeramente la notación empleada.</p> <p>A continuación te muestro una tabla con las más habituales y su equivalente en pseudocódigo, sin entrar en explicaciones, porque supondremos que ya sabes manejarlas. Si no recuerdas para qué servía alguna de ellas, quizá sería buena idea que le dieras un repaso al capítulo dedicado al pseudocódigo.</p> <div class="table-wrapper"><table> <tr> <th>Instrucción</th> <th>Pseudocódigo</th> <th>Lenguaje C</th> </tr> <tr> <td>Condicional simple</td> <td> <code> Si condición entonces<br /> &nbsp;&nbsp;&nbsp;acciones<br /> FinSi </code> </td> <td> <code> if (condicion) {<br /> &nbsp;&nbsp;&nbsp;acciones<br /> } </code> </td> </tr> <tr> <td>Condicional doble</td> <td> <code> Si condicion entonces<br /> &nbsp;&nbsp;&nbsp;acciones<br /> SiNo<br /> &nbsp;&nbsp;&nbsp;acciones<br /> FinSi </code> </td> <td> <code> if (condicion) {<br /> &nbsp;&nbsp;&nbsp;acciones<br /> }<br /> else {<br /> &nbsp;&nbsp;&nbsp;acciones<br /> } </code> </td> </tr> <tr> <td>Bucle tipo mientras</td> <td> <code> Mientras condicion hacer<br /> &nbsp;&nbsp;&nbsp;acciones<br /> FinMientras </code> </td> <td> <code> while (condicion) {<br /> &nbsp;&nbsp;&nbsp;acciones<br /> } </code> </td> </tr> <tr> <td>Bucle tipo repetir</td> <td> <code> Repetir<br /> &nbsp;&nbsp;&nbsp;acciones<br /> Hasta Que condicion </code> </td> <td> <code> do {<br /> &nbsp;&nbsp;&nbsp;acciones<br /> } while (condicion) </code> </td> </tr> <tr> <td>Bucle tipo para</td> <td> <code> Para variable &lt;- valor_inicial hasta valor_final con paso incremento hacer<br /> &nbsp;&nbsp;&nbsp;acciones<br /> FinPara </code> </td> <td> <code> for (variable = valor_inicial; variable != valor_final; variable = variable + incremento) {<br /> &nbsp;&nbsp;&nbsp;acciones<br /> } </code> </td> </tr> </table></div> <p>Fíjate en que casi todo se escribe del mismo modo que en pseudocódigo con un par de diferencias notables:</p> <ul> <li> <p><strong>DIFERENCIA 1: En el bucle tipo <em>repetir</em></strong>, la condición de salida se expresa al revés (“repetir mientras..” en lugar de “repetir hasta que…”. Lo verás mejor en este ejemplo que muestra los números del 1 al 100. Observa la condición del final del bucle:</p> <p>En pseudocódigo:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> i &lt;- 1
 Repetir
    Escribir i
    i &lt;- i + 1
 Hasta que i &gt;= 100
</code></pre></div> </div> <p>En C:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
 <span class="k">do</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">i</span><span class="o">++</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">);</span>
</code></pre></div> </div> </li> <li> <p><strong>DIFERENCIA 2: En el bucle tipo <em>para</em></strong> hay que indicar la asignación a la variable que controla el bucle, la condición de salida y la forma en la que esa variable cambiará en cada iteración. Observa este ejemplo:</p> <p>En pseudocódigo:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Para i &lt;- 1 hasta 10 hacer
    Escribir i
 FinPara
</code></pre></div> </div> <p>En C:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
 <span class="p">}</span>
</code></pre></div> </div> <p>Si el <strong>paso</strong> del bucle no es +1 (es decir, si la variable que controla el bucle no incrementa su valor de 1 en 1 en cada iteración), hay que indicarlo de este modo:</p> <p>En pseudocódigo:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Para i &lt;- 1 hasta 10 con paso 2 hacer
    Escribir i
 FinPara
</code></pre></div> </div> <p>En C:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
 <span class="p">}</span>
</code></pre></div> </div> <p>Por último, recuerda que en C existe una abreviatura para <code class="language-plaintext highlighter-rouge">i = i + 1</code>, que se escribe <code class="language-plaintext highlighter-rouge">i++</code>, por lo que lo más habitual es encontrar los bucles de tipo <em>para</em> escritos así:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span><span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
 <span class="p">}</span>
</code></pre></div> </div> </li> </ul> <h3 id="928-algoritmo-principal-y-subalgoritmos"> <a href="#928-algoritmo-principal-y-subalgoritmos" class="anchor-heading" aria-labelledby="928-algoritmo-principal-y-subalgoritmos"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.2.8. Algoritmo principal y Subalgoritmos </h3> <p>C es un <strong>lenguaje modular</strong> hasta el extremo de que todas las líneas de código deben pertenecer a alguna función, incluyendo las instrucciones del algoritmo principal, que se escriben en una función llamada <em>principal</em> (<strong><em>main</em></strong> en inglés)</p> <h4 id="la-función-main"> <a href="#la-función-main" class="anchor-heading" aria-labelledby="la-función-main"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> La función <em>main()</em> </h4> <p>La <strong>función <em>main()</em></strong> contiene el algoritmo o módulo principal del programa. La ejecución de un programa siempre empieza por la primera línea de la función <em>main()</em>.</p> <p>Esta función, como todas las funciones de C, puede devolver un valor. El valor devuelto por <em>main()</em> debe ser de tipo entero (<em>int</em>). Esto se utiliza para pasar algún valor al programa que haya llamado al nuestro, que suele ser el sistema operativo. Si <em>main()</em> no devuelve un número entero al sistema operativo mediante una sentencia return, entonces nuestro programa devolverá un número desconocido.</p> <p>(Moraleja: es una buena idea incluir un <em>return</em> al final de la función <em>main()</em>. Generalmente, la devolución de un 0 indica al sistema operativo que el programa a finalizado sin problemas, mientras que cualquier otro valor señala que se ha producido algún error).</p> <p>Por lo tanto, la forma habitual de la función <em>main()</em> será:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
   <span class="p">...</span><span class="n">instrucciones</span> <span class="n">del</span> <span class="n">algoritmo</span> <span class="n">principal</span><span class="p">...</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>Observa que <em>main()</em> no tiene argumentos, por lo que aparece el identificador <em>void</em> entre paréntesis en la declaración. También se pueden utilizar argumentos en <em>main()</em>, pero eso es algo que no trataremos de momento.</p> <h4 id="las-funciones-en-c"> <a href="#las-funciones-en-c" class="anchor-heading" aria-labelledby="las-funciones-en-c"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Las funciones en C </h4> <p>La declaración de funciones se hace de forma similar a la empleada en pseudocódigo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tipo_devuelto</span> <span class="n">nombre_funci</span><span class="err">ó</span><span class="n">n</span> <span class="p">(</span><span class="n">par</span><span class="err">á</span><span class="n">metros_formales</span><span class="p">)</span>
<span class="p">{</span>
   <span class="p">...</span><span class="n">instrucciones</span><span class="p">...</span>
   <span class="k">return</span> <span class="n">expresi</span><span class="err">ó</span><span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>Observa que las únicas diferencias con el pseudocódigo son que no se usa la palabra “función”, que las llaves { y } sustituyen a <em>inicio</em> y <em>fin</em>, y que se emplea la palabra <em>return</em> en lugar de devolver.</p> <p>Si el tipo_devuelto es <em>void</em>, se considera que la función no devuelve ningún valor y que, por lo tanto, es un procedimiento. Entonces, un procedimiento en C se declara así:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">nombre_procedimiento</span> <span class="p">(</span><span class="n">par</span><span class="err">á</span><span class="n">metros_formales</span><span class="p">)</span>
<span class="p">{</span>
   <span class="p">...</span><span class="n">instrucciones</span><span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="paso-de-parámetros"> <a href="#paso-de-parámetros" class="anchor-heading" aria-labelledby="paso-de-parámetros"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Paso de parámetros </h4> <p>Los parámetros formales son, como en pseudocódigo, una lista de tipos e identificadores que se sustituirán por los parámetros actuales y se usarán como variables dentro de la función.</p> <p>Los parámetros se pasan normalmente <strong>por valor</strong>, pero también se pueden pasar por referencia. El paso de parámetros por referencia admite dos sitaxis ligeramente diferentes en C: anteponiendo el <strong>operador *</strong> (asterisco) al nombre del parámetro (equivalente a usar la expresión <em>por referencia</em> en pseudocódigo) o anteponiendo el <strong>operador &amp;</strong>.</p> <p><strong>Paso de parámetros por valor</strong></p> <p>Por ejemplo, en esta función el paso de parámetros es por valor:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">funcion1</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
   <span class="p">...</span><span class="n">c</span><span class="err">ó</span><span class="n">digo</span> <span class="n">de</span> <span class="n">la</span> <span class="n">funci</span><span class="err">ó</span><span class="n">n</span>
<span class="p">}</span>
</code></pre></div></div> <p>Esto quiere decir que <em>funcion1()</em> recibirá únicamente el valor de los dos parámetros, x e y. Podrá utilizar esos valores a lo largo de su código, e incluso podrá cambiarlos. Pero cualquier cambio en x e y no afectará a los parámetros actuales, es decir, a los parámetros del programa que llamó a <em>funcion1()</em>.</p> <p><strong>Paso de parámetros por referencia con el operador *</strong></p> <p>En la siguiente función, el paso del parámetro “x” es por valor y el del parámetro “y”, por referencia:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">funcion2</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
   <span class="p">...</span><span class="n">c</span><span class="err">ó</span><span class="n">digo</span> <span class="n">de</span> <span class="n">la</span> <span class="n">funci</span><span class="err">ó</span><span class="n">n</span>
<span class="p">}</span>
</code></pre></div></div> <p>En este caso, cada vez que se vaya a usar el parámetro “y” dentro del código de la función, será necesario acompañarlo del asterisco. Por ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">17</span> <span class="o">+</span> <span class="o">*</span><span class="n">y</span><span class="p">;</span>
</code></pre></div></div> <p>(Hay algunas excepciones a esta regla, pero ahora no vienen a cuento).</p> <p>En la llamada a la función hay que indicar explícitamente qué parámetro se está pasando por referencia utilizando el operador &amp;. Por lo tanto, para llamar a <em>funcion2()</em> con los parámetros a y b habrá que escribir:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">resultado</span> <span class="o">=</span> <span class="n">funcion2</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</code></pre></div></div> <p>Observa que el segundo parámetro (el que se pasa por referencia), lleva delante el operador &amp;.</p> <p>Si dentro de la función se cambia el valor de y, también cambiará el valor de b fuera de la función, ya que ambas variables han quedado ligadas por el paso por referencia. En cambio, las variables x y a son independientes. (Si todo esto te suena a chino, repásate el apartado dedicado al paso de parámetros en el tema de introducción a la programación en pseudocódigo, donde se explicaba con más detalle).</p> <p><strong>Paso de parámetros por referencia con el operador &amp;</strong></p> <p>Otra forma de pasar un parámetro por referencia es usar el operador &amp; en los parámetros formales, así:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">funcion3</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
   <span class="p">...</span><span class="n">c</span><span class="err">ó</span><span class="n">digo</span> <span class="n">de</span> <span class="n">la</span> <span class="n">funci</span><span class="err">ó</span><span class="n">n</span>
<span class="p">}</span>
</code></pre></div></div> <p>En esta función, el parámetro x se pasa por valor y el parámetro y se pasa por referencia. Utilizando esta sintaxis no es necesario añadir asteriscos cada vez que se usa la y en el cuerpo de la función, ni tampoco usar “&amp;” en la llamada a la función.</p> <p>Esta tercera forma de paso por referencia no es estándar en C, sino que es propia de C++, por lo que evitaremos utilizarla de momento.</p> <h4 id="juntándolo-todo-en-un-ejemplo"> <a href="#juntándolo-todo-en-un-ejemplo" class="anchor-heading" aria-labelledby="juntándolo-todo-en-un-ejemplo"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Juntándolo todo en un ejemplo </h4> <p>En el siguiente ejemplo se ilustran los dos tipos de paso de parámetros y, en el paso por referencia, las dos sintaxis alternativas de que dispone C.</p> <p>El ejemplo muestra tres funciones muy similares que reciben dos parámetros, a y b. Las tres intentan intercambiar el valor de a y b mediante una tercera variable llamada tmp. Sin embargo, en la primera de ellas el intercambio no tiene ningún efecto en el programa <em>main()</em>, ya que los parámetros están pasados por valor. En las otras dos funciones sí que se consigue el intercambio, ya que los parámetros está pasados por referencia.</p> <p>No te preocupes si no entiendes toda la sintaxis de este ejemplo. Lo interesante ahora es que veas cuál es la forma correcta de escribir cada tipo de paso de parámetros.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="c1">// Paso de parámetros por valor.</span>
<span class="c1">// En este ejemplo, esta función no tendrá el efecto deseado, porque las variables</span>
<span class="c1">// del programa principal no se verán afectadas.</span>
<span class="kt">void</span> <span class="nf">intercambiar1</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
     <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
     <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
     <span class="n">b</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Paso de parámetros por referencia, sintaxis 1.</span>
<span class="c1">// Esta función sí que consigue intercambiar los valores de las variables</span>
<span class="c1">// del programa principal.</span>
<span class="kt">void</span> <span class="nf">intercambiar2</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
     <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
     <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
     <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Paso de parámetros por referencia, sintaxis 2.</span>
<span class="c1">// Esta función también consigue su objetivo. A todos los efectos,</span>
<span class="c1">// es idéntica a la función anterior.</span>
<span class="kt">void</span> <span class="nf">intercambiar3</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
     <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
     <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
     <span class="n">b</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// Programa principal</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">dato1</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span> <span class="n">dato2</span> <span class="o">=</span> <span class="mi">90</span><span class="p">;</span>
    
    <span class="n">printf</span><span class="p">(</span><span class="s">"Antes de la llamada a las funcioens: dato1 = %i, dato2 = %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dato1</span><span class="p">,</span> <span class="n">dato2</span><span class="p">);</span>
    <span class="n">intercambiar1</span><span class="p">(</span><span class="n">dato1</span><span class="p">,</span> <span class="n">dato2</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Después de intercambiar1: dato1 = %i, dato2 = %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dato1</span><span class="p">,</span> <span class="n">dato2</span><span class="p">);</span>
    <span class="n">intercambiar2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dato1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dato2</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Después de intercambiar2: dato1 = %i, dato2 = %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dato1</span><span class="p">,</span> <span class="n">dato2</span><span class="p">);</span>
    <span class="n">intercambiar3</span><span class="p">(</span><span class="n">dato1</span><span class="p">,</span> <span class="n">dato2</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Después de intercambiar3: dato1 = %i, dato2 = %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dato1</span><span class="p">,</span> <span class="n">dato2</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="prototipos-de-funciones"> <a href="#prototipos-de-funciones" class="anchor-heading" aria-labelledby="prototipos-de-funciones"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Prototipos de funciones </h4> <p>En C no es necesario escribir las funciones (subalgoritmos) antes de su primera invocación. El mecanismo de compilación y enlace de C permite, de hecho, que las funciones puedan estar físicamente en un archivo distinto del lugar desde el que se invocan.</p> <p>En la práctica, esto plantea un problema: C no tiene forma de saber si la llamada a una función se hace correctamente, es decir, si se le pasan los argumentos debidos y con el tipo correcto, ni si el resutado devuelto es asignado a una variable del tipo adecuado.</p> <p>Para conseguir que C realice esas comprobaciones durante la compilación se utilizan los <strong>prototipos de función</strong>. Un prototipo de función es, simplemente, <em>la declaración de una función</em>. Es decir, la primera línea del código la función.</p> <p>El prototipo debe aparecer antes de que la función se invoque por primera vez, aunque el código completo de la función esté en otra parte. Los prototipos permiten al compilador comprobar que los argumentos de la función coinciden en tipo y número con los de la invocación de la misma, y que el tipo devuelto es el correcto.</p> <p>Los prototipos suelen aparecer al principio del programa, antes de la función <em>main()</em>. Observa, en el siguiente ejemplo, que el prototipo de la función <em>calcular_area()</em> se coloca delante de <em>main()</em>. Sin embargo, el código concreto de esta función no aparece hasta después (incluso podría estar situado en otro archivo diferente):</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">calcular_area</span> <span class="p">(</span><span class="kt">float</span> <span class="n">base</span><span class="p">,</span> <span class="kt">float</span> <span class="n">altura</span><span class="p">);</span>	<span class="c1">// Prototipo de la función</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>				<span class="c1">// Algoritmo principal</span>
<span class="p">{</span>
   <span class="p">...</span><span class="n">instrucciones</span><span class="p">...</span>
   <span class="n">area</span> <span class="o">=</span> <span class="n">calcular_area</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">);</span>
   <span class="p">...</span><span class="n">m</span><span class="err">á</span><span class="n">s</span> <span class="n">instrucciones</span><span class="p">...</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">calcular_area</span><span class="p">(</span><span class="kt">float</span> <span class="n">base</span><span class="p">,</span> <span class="kt">float</span> <span class="n">altura</span><span class="p">)</span>	<span class="c1">// Código de la función (podría estar incluso en otro archivo)</span>
<span class="p">{</span>
   <span class="p">...</span> <span class="n">instrucciones</span><span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>Cuando se vayan a usar funciones de librería, como <em>fabs()</em> (valor absoluto), <em>sqrt()</em> (raíz cuadrada) o cualquier otra, hay que escribir sus prototipos antes de la función <em>main()</em>. Sin embargo, como estas funciones no las hemos escrito nosotros, desconocemos cuales son sus prototipos.</p> <p>En C se soluciona este problema con los <strong>archivos de cabecera</strong>, que son archivos que incluyen en su interior los prototipos de las funciones, entre otras cosas.</p> <p>Hay muchos archivos de cabecera en la librería estándar de C. Por ejemplo, el archivo <strong>math.h</strong> tiene los prototipos de todas las funciones matemáticas. Todos los archivos de cabecera tienen la <strong>extensión .h</strong> en su nombre (h de “header”).</p> <p>Para incluir un archivo de cabecera en nuestro programa se utiliza <strong>#include</strong>, que no es exactamente una instrucción de C, sino una <strong>directiva de compilación</strong>. Ya hemos visto otra directiva de compilación: #define, que usábamos para definir constantes. Las directivas de compilación indican al compilador cómo se debe comportar y, aunque estrictamente hablando no son instrucciones de C, para nosotros es como si lo fueran.</p> <p>Por ejemplo, esta línea de código sirve para incluir todos los prototipos de las funciones de librería matemática en nuestro programa:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;math.h&gt;</span><span class="cp">
</span></code></pre></div></div> <h3 id="929-entrada-y-salida-en-c"> <a href="#929-entrada-y-salida-en-c" class="anchor-heading" aria-labelledby="929-entrada-y-salida-en-c"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.2.9. Entrada y salida en C </h3> <p>La entrada y salida de datos en C, es decir, la traducción de las instrucciones leer() y escribir() de pseudocódigo, es uno de los aspectos más difíciles de C para los principiantes.</p> <p>El estándar ANSI C dispone de muchas funciones para hacer las entradas y salidas de datos. En concreto, dispone de un subconjunto de ellas para hacer la entrada y salida por consola, es decir, por teclado y pantalla.</p> <p>Podemos clasificar estas funciones de E/S en dos grupos:</p> <ul> <li><strong>Funciones de E/S simples</strong>: <em>getchar(), putchar(), gets(), puts()</em></li> <li><strong>Funciones de E/S con formato</strong>: <em>printf(), scanf()</em></li> </ul> <p>Las más utilizadas y versátiles son sin duda las segundas, así que nos detendremos en ellas.</p> <h4 id="salida-de-datos-con-printf"> <a href="#salida-de-datos-con-printf" class="anchor-heading" aria-labelledby="salida-de-datos-con-printf"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Salida de datos con <em>printf()</em> </h4> <p>La función <em>printf()</em> (de “print” = imprimir y “f” = formato) sirve para escribir datos en el dispositivo de salida estándar (generalmente la pantalla) con un formato determinado por el programador. La forma general de utilizarla es la siguiente:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">printf</span><span class="p">(</span><span class="n">cadena_de_formato</span><span class="p">,</span> <span class="n">datos</span><span class="p">);</span>
</code></pre></div></div> <p>El prototipo de <em>printf()</em> se encuentra en el archivo de cabecera <strong>&lt;stdio.h&gt;</strong> (de “std” = standard e “io” = input/output, es decir, “stdio” es un acrónimo de “entrada/salida estándar”).</p> <p>El primer argumento, la <em>cadena_de_formato</em>, especifica el modo en el que se deben mostrar los datos que aparecen a continuación. Esta cadena se compone de una serie de códigos de formato que indican a C qué tipo de datos son los que se desean imprimir.</p> <p>Todos los códigos están precedidos del símbolo de porcentaje (“%”). Por ejemplo, el código “%i” indica a la función que se desea escribir un número de tipo <em>int</em>, y el código “%f”, que se desea escribir un número real de tipo <em>float</em>.</p> <p>La forma más simple de utilizar <em>printf()</em> es:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div></div> <p>Esto escribirá el valor de la variable entera a en la pantalla, es decir, 5. Fíjate que el primer argumento de printf() es una cadena (y, por lo tanto, se escribe entre comillas) cuyo contenido es el código del tipo de dato que se pretende escribir. El segundo argumento es el dato mismo.</p> <p>En una sola instrucción <em>printf()</em> pueden escribirse varios datos. Por ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">x</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">.</span><span class="mi">33</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%i%f"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</code></pre></div></div> <p>Observa detenidamente la cadena de formato: primero aparece “%i” y luego “%f”. Esto indica que el primer dato que debe imprimirse es un entero, y el segundo, un real. Después, aparecen esos datos separados por comas y exactamente en el mismo orden que en la cadena de formato: primero la variable entera y luego la variable real. El resultado será que en la pantalla se escribirán los números 5 y 10.33.</p> <p>Algunos de los códigos de formato que se pueden utilizar en <em>printf()</em> son:</p> <ul> <li><strong>%c</strong>: para imprimir caracteres individuales.</li> <li><strong>%i</strong> o <strong>%d</strong>: para imprimir números enteros.</li> <li><strong>%u</strong>: para imprimir números enteros sin signo.</li> <li><strong>%f</strong>: para imprimir números reales.</li> <li><strong>%e</strong>: para imprimir números reales en notación científica.</li> <li><strong>%s</strong>: para imprimir cadenas de caracteres (strings).</li> <li><strong>%o</strong> y <strong>%x</strong>: para imprimir números en octal y en hexadecimal, respectivamente.</li> </ul> <p>Algunos de estos código admiten modificadores. Los más habituales son:</p> <ul> <li><strong>Los códigos numéricos como “%i” o “%f”</strong> permiten insertar modificadores de longitud como “l” (longitud doble) o “h” (longitud corta). Así, por ejemplo, “%ld” indica que se va a imprimir un entero de longitud doble (long int); “%hu” sirve para enteros cortos sin signo (unsigned short int); “%lf” indica que se imprimirá un número real de longitud doble (double), etc.</li> <li><strong>El código “%f”</strong> (números reales) se pueden usar con un modificador de posiciones decimales que se desean mostrar. Por ejemplo, con “%3.4f” obligamos a que se impriman tres dígitos a la izquierda de la coma decimal y cuatro a la derecha. La escritura se justifica a la derecha. Para justificarla a la izquierda se utiliza el modificador “-“, de esta forma: “%-10.4f”.</li> <li><strong>El código “%s”</strong> (cadenas de caracteres) se puede combinar con un especificador de longitud máxima y mínima de la cadena. Por ejemplo, “%4.8s” escribe una cadena de al menos cuatro caracteres y no más de ocho. Si la cadena tiene más, se pierden los que excedan de ocho. También se puede utilizar el modificador “-“ para alinear el texto a la izquierda.</li> </ul> <p>Además de los códigos de formato, en la cadena de formato puede aparecer cualquier texto entremezclado con los códigos. A la hora de escribir en la pantalla, los códigos serán sustituidos por los datos correspondientes. Por ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">x</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">.</span><span class="mi">33</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"El número entero es %i y el real es %f"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</code></pre></div></div> <p>Lo que aparecerá en la pantalla al ejecutar este fragmento de código será:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>El número entero es 5 y el real es 10.33
</code></pre></div></div> <p>Una última observación sobre <em>printf()</em>: hay ciertos caracteres que no son directamente imprimibles desde el teclado. Uno de ellos es el <strong>salto de línea</strong>. Para poder ordenar a <em>printf()</em> que escriba un salto de línea (o cualquier otro carácter no imprimible) se utilizan los códigos de barra invertida, que con códigos especiales precedidos del carácter “".</p> <p>En concreto, el carácter “salto de línea” se indica con el código “\n”. Observa las diferencias entre estos dos bloques de instrucciones para intentar comprender la importancia del salto de línea:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"La variable a vale %i"</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"La variable a vale %i"</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div></div> <p>El resultado en la pantalla de la ejecución de estas instrucciones es:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>La variable a vale 5La variable a vale 14
</code></pre></div></div> <p>Veamos el mismo ejemplo usando el código del salto de línea (\n):</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"La variable a vale %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"La variable a vale %i"</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
</code></pre></div></div> <p>El resultado en la pantalla será:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>La variable a vale 5
La variable a vale 14

</code></pre></div></div> <h4 id="entrada-de-datos-con-scanf"> <a href="#entrada-de-datos-con-scanf" class="anchor-heading" aria-labelledby="entrada-de-datos-con-scanf"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Entrada de datos con scanf() </h4> <p>La función <em>scanf()</em> es, en muchos sentidos, la inversa de <em>printf()</em>. Puede leer desde el dispositivo de entrada estándar (normalmente el teclado) datos de cualquier tipo de los manejados por el compilador, convirtiéndolos al formato interno apropiado. Funciona de manera análoga a <em>printf()</em>, por lo que su sintaxis es:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scanf</span><span class="p">(</span><span class="n">cadena_de_formato</span><span class="p">,</span> <span class="n">datos</span><span class="p">);</span>
</code></pre></div></div> <p>El prototipo de <em>scanf()</em> se encuentra en el archivo de cabecera <strong>&lt;stdio.h&gt;</strong>, como <em>printf()</em>.</p> <p>La <em>cadena_de_formato</em> tiene la misma composición que la de printf(). Los datos son las variables donde se desea almacenar el dato o datos leidos desde el teclado. <strong>¡Cuidado!</strong> Con los tipos simples, es necesario utilizar el operador &amp; delante del nombre de la variable, porque esa variable se pasa por referencia a <em>scanf()</em> para que ésta pueda modificarla.</p> <p>Por ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">x</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Escribe un número entero:"</span><span class="p">);</span>
<span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Ahora escribe un número entero y un número real:"</span><span class="p">);</span>
<span class="n">scanf</span><span class="p">(</span><span class="s">"%d%f"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Escribe una cadena:"</span><span class="p">);</span>
<span class="n">scanf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
</code></pre></div></div> <p>La función <em>scanf()</em> tiene alguna otra funcionalidad añadida para el manejo de cadenas de caracteres que ya veremos en su momento.</p> <h4 id="ejemplo-de-uso-de-scanf-y-printf"> <a href="#ejemplo-de-uso-de-scanf-y-printf" class="anchor-heading" aria-labelledby="ejemplo-de-uso-de-scanf-y-printf"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ejemplo de uso de scanf() y printf() </h4> <p>Debido a la relativa complejidad de estas funciones de entrada y salida, vamos a presentar un pequeño ejemplo de traducción de pseudocódigo a C. Se trata de un algoritmo que lee dos números enteros, A y B. Si A es mayor que B los resta, y en otro caso los suma.</p> <p>Observa detenidamente la correspondencia entre cada pareja de instrucciones, especialmente las de entrada y salida.</p> <p><strong>Pseudocódigo:</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>algoritmo suma_y_resta
   definir a, b como entero
   escribir "Introduzca dos números enteros";
   leer a
   leer b
   si a &lt; b entonces
       escribir "La suma de a y b es:", a+b
   sino
       escribir "La resta de a menos b es:", a–b
finAlgoritmo
</code></pre></div></div> <p><strong>Lenguaje C:</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Programa suma y resta */</span>
<span class="cp">#include stdio.h
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>   
  <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">"Introduzca dos números enteros</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">"%d%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)</span> 
     <span class="n">printf</span><span class="p">(</span><span class="s">"La suma de %d y %d es: %d"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">);</span>
  <span class="k">else</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">"La resta de %d menos %d es: %d"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="err">–</span><span class="n">b</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="funciones-para-es-simple-por-consola"> <a href="#funciones-para-es-simple-por-consola" class="anchor-heading" aria-labelledby="funciones-para-es-simple-por-consola"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Funciones para E/S simple por consola </h4> <p>Técnicamente, con <em>printf()</em> y <em>scanf()</em> es posible escribir y leer cualquier tipo de datos desde cualquier dispositivo de salida o entrada, no solo la pantalla y el teclado.</p> <p>En la práctica, aunque <em>printf()</em> resulta bastante efectiva y versátil, <em>scanf()</em> puede darte muchos dolores de cabeza. Para hacerte una idea, sólo tienes que probar a hacer un <em>scanf()</em> de un número entero e inmediatamente después otro <em>scanf()</em> de una cadena de caracteres. El segundo <em>scanf()</em> fallará. La razón es bastante rocambolesca: el flujo de entrada no consumirá el carácter de retorno de carro al leer el número entero, por lo que dicho carácter se adjudicará al segundo <em>scanf()</em> automáticamente.</p> <p>Por suerte, <strong>existe otro grupo de funciones en ANSI C específicamente diseñadas para hacer la E/S por consola</strong>, es decir, por teclado y pantalla, de manera más simple. Las resumimos en el siguiente cuadro.</p> <p>Los prototipos de estas funciones, como el de <em>scanf()</em>, se encuentran en el archivo de cabecera <strong><em>stdio.h</em></strong>, así que tendrás que incluirlo en tu código para poder usarlas.</p> <ul> <li> <p><strong><em>getchar()</em></strong>: Espera a que se pulse una tecla seguida de INTRO y devuelve su valor. Muestra el eco en la pantalla, es decir, la tecla pulsada aparece en la pantalla.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">char</span> <span class="n">car</span><span class="p">;</span>
 <span class="n">car</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">();</span>
 <span class="n">printf</span><span class="p">(</span><span class="s">"Tecla pulsada:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
</code></pre></div> </div> </li> <li><strong><em>putchar(c)</em></strong>: Escribe el carácter <em>c</em> en la pantalla.</li> <li> <p><strong><em>gets(cadena)</em></strong>: Lee del teclado una cadena de caracteres seguida de INTRO.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">char</span> <span class="n">cadena</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
 <span class="n">gets</span><span class="p">(</span><span class="n">cadena</span><span class="p">);</span>
 <span class="n">printf</span><span class="p">(</span><span class="s">"Cadena tecleada:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
 <span class="n">puts</span><span class="p">(</span><span class="n">cadena</span><span class="p">);</span>
</code></pre></div> </div> </li> <li><strong><em>puts(cadena)</em></strong>: Escribe una cadena de caracteres en la pantalla (ver ejemplo anterior).</li> </ul> <p>Por lo tanto, <strong>para evitar los problemas que a menudo causa <em>scanf()</em>, podemos recurrir a <em>gets()</em></strong> para leer las cadenas de caracteres. Si necesitamos leer un número, podemos usar <em>gets()</em> y luego <strong>convertir la cadena</strong> a un tipo de dato numérico con las funciones de conversión <em>atoi()</em> y <em>atof()</em>, como se muestra en el siguiente ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">cadena</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">x</span><span class="p">;</span>

<span class="n">gets</span><span class="p">(</span><span class="n">cadena</span><span class="p">);</span>      <span class="c1">// Leemos una cadena de caracteres</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">cadena</span><span class="p">);</span>  <span class="c1">// Convertimos la cadena en un número entero</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">atof</span><span class="p">(</span><span class="n">cadena</span><span class="p">);</span>  <span class="c1">// Convertimos la cadena en un número real</span>
</code></pre></div></div> <p>Las funciones de conversión <em>atoi()</em> y <em>atof()</em> tratarán de convertir la cadena en un número, si ello es posible (es decir, si la cadena realmente contiene números).</p> <p>Pero cuidado: si se teclean más caracteres de los que caben en la cadena, el resultado es imprevisible (a menudo el programa fallará durante la ejecución). Esto puede solucionarse utilizando <em>fgets()</em> en lugar de <em>gets()</em>, que es una función más compleja y no vamos a explicar aquí. Puedes buscar información en internet si te interesa el tema.</p> <p>Tal vez pienses que resulta demasiado complicado hacer algo muy simple como una entrada de datos por teclado. Tienes razón. Pero ten en cuenta dos cosas: las entradas de datos nunca son simples (son el punto donde el usuario interacciona con más libertad con el programa, y los usuarios humanos tendemos a hacer cosas impredecibles y complicadas), y C es un lenguaje de nivel intermedio más que de alto nivel, por lo que muchas tareas de alto nivel, simplemente, no las resolverá por nosotros. En ese sentido, C requiere del programador prestar atención a ciertos detalles que podría obviar en otros lenguajes.</p> <h3 id="9210-cadenas-de-caracteres"> <a href="#9210-cadenas-de-caracteres" class="anchor-heading" aria-labelledby="9210-cadenas-de-caracteres"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.2.10. Cadenas de caracteres </h3> <p>Las <strong>cadenas</strong> de caracteres en C son, en realidad, <strong>arrays de caracteres</strong>.</p> <p>Aunque veremos los arrays en el próximo apartado, si ya sabes pseudocódigo quizá no te sorprenda saber que una cadena se declara así:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">cadena</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>		<span class="cm">/* Declaración de una cadena de 50 caracteres */</span>
</code></pre></div></div> <p>La cadenas tienen ciertas peculiaridades que comentaremos en este apartado, pero todo lo que digamos en el siguiente sobre arrays también será aplicable a las cadenas.</p> <h4 id="declaración-y-manipulación-de-cadenas"> <a href="#declaración-y-manipulación-de-cadenas" class="anchor-heading" aria-labelledby="declaración-y-manipulación-de-cadenas"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Declaración y manipulación de cadenas </h4> <p>Las cadenas pueden manipularse elemento por elemento, como cualquier array. Por ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">cadena</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
<span class="n">cadena</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'H'</span><span class="p">;</span>
<span class="n">cadena</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'o'</span><span class="p">;</span>
<span class="n">cadena</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'l'</span><span class="p">;</span>
<span class="n">cadena</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'a'</span><span class="p">;</span>
</code></pre></div></div> <p>Las cadenas deben tener, después de su último carácter válido, un carácter especial llamado <strong>nulo</strong>. Este carácter marca el final de la cadena. El carácter nulo se simboliza con <strong>el código \0</strong>. Por lo tanto, en el ejemplo anterior habría que agregar la siguiente línea para que la cadena estuviera completa:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cadena</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
</code></pre></div></div> <p><strong>Todas las cadenas deben terminar en un carácter nulo</strong>. De lo contrario, podemos tener problemas al imprimirlas en la pantalla o al realizar con ellas cualquier otro proceso. En consecuencia, en una cadena definida como la anterior, de 50 caracteres, en realidad sólo tienen cabida 49, ya que siempre hay que reservar una posición para el carácter nulo.</p> <p>La declaración de una cadena puede ir acompañada de una inicialización mediante una constante. En este caso, la constante debe ir encerrada entre comillas dobles, al tratarse de una cadena y no de caracteres sueltos. Por ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">cadena</span><span class="p">[</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Hola"</span><span class="p">;</span>
</code></pre></div></div> <p>En inicializaciones de este tipo, el compilador se encarga de añadir el carácter nulo. Por último, señalemos que no es necesario indicar el tamaño de la cadena si se inicializa al mismo tiempo que se declara. Por ejemplo, la declaración anterior puede sustituirse por esta otra:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">cadena</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"Hola"</span><span class="p">;</span>
</code></pre></div></div> <p>Esto se denomina array de longitud indeterminada. El compilador, al encontrar una declaración así, crea una cadena del tamaño suficiente para contener todos los caracteres. Esto vale no sólo para las cadenas, sino que también es aplicable a cualquier otro tipo de array que se inicialice al mismo tiempo que se declare.</p> <h4 id="funciones-para-manejo-de-cadenas"> <a href="#funciones-para-manejo-de-cadenas" class="anchor-heading" aria-labelledby="funciones-para-manejo-de-cadenas"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Funciones para manejo de cadenas </h4> <p>La mayor parte de las veces las cadenas son manipuladas mediante el uso de funciones de librería específicas. En este apartado comentaremos las más comunes.</p> <p><strong>Funciones de lectura y escritura</strong></p> <p>Para leer por teclado una cadena de caracteres se puede utilizar también la función <em>scanf()</em> con la cadena de formato “%s”. Como las cadenas son arrays, no es preciso anteponer el símbolo &amp; al nombre de la variable. Sin embargo, es preferible emplear la función <strong><em>gets()</em></strong> por estar específicamente diseñada para la lectura de cadenas. Por ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">cadena</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Introduzca su nombre "</span><span class="p">);</span>
<span class="n">gets</span><span class="p">(</span><span class="n">cadena</span><span class="p">);</span>
</code></pre></div></div> <p>Tanto <em>scanf()</em> como <strong>gets()</strong> insertan automáticamente el carácter “\0” al final de la cadena.</p> <p>De manera análoga podemos emplear la función <em>printf()</em> para escribir el contenido de una cadena en la pantalla, pero preferiremos la función <strong><em>puts()</em></strong>, específica de las cadenas. Por ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">cadena</span><span class="p">[</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Hola, mundo"</span><span class="p">;</span>
<span class="n">puts</span><span class="p">(</span><span class="n">cadena</span><span class="p">);</span>
</code></pre></div></div> <h4 id="funciones-de-tratamiento-de-cadenas"> <a href="#funciones-de-tratamiento-de-cadenas" class="anchor-heading" aria-labelledby="funciones-de-tratamiento-de-cadenas"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Funciones de tratamiento de cadenas </h4> <p>Las funciones de librería ANSI C para manejar cadenas suelen empezar por las letras “str” (de “string”, que significa “cadena” en inglés) y utilizan el archivo de cabecera <strong><em>string.h</em></strong>.</p> <p>Entre las funciones más habituales encontramos las siguientes:</p> <ul> <li> <p><strong><em>strcpy()</em></strong>: Copia el contenido de una cadena en otra, incluyendo el carácter nulo. Su sintaxis es:</p> <p>El siguiente ejemplo es otra versión (artificialmente enrevesada) del “hola, mundo”:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">char</span> <span class="n">cad1</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
 <span class="kt">char</span> <span class="n">cad2</span><span class="p">[</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Hola"</span><span class="p">;</span>
 <span class="n">strcpy</span><span class="p">(</span><span class="n">cad1</span><span class="p">,</span> <span class="n">cad2</span><span class="p">);</span>
 <span class="n">strcpy</span><span class="p">(</span><span class="n">cad2</span><span class="p">,</span> <span class="s">"mundo"</span><span class="p">);</span>
 <span class="n">printf</span><span class="p">(</span><span class="s">"%s, %s"</span><span class="p">,</span> <span class="n">cad1</span><span class="p">,</span> <span class="n">cad2</span><span class="p">);</span>
</code></pre></div> </div> </li> <li> <p><strong><em>strlen()</em></strong>: Devuelve la longitud de una cadena, es decir, el número de caracteres de que consta, sin contar el carácter nulo. Por ejemplo, en este fragmento de código el resultado debe ser 11. Fíjate que la variable cadena tiene una longitud total de 50 caracteres, pero <em>strlen()</em> sólo cuenta los que efectivamente se están usando, es decir, los que hay hasta el carácter nulo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">char</span> <span class="n">cadena</span><span class="p">[</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Hola, mundo"</span><span class="p">;</span>
 <span class="kt">int</span> <span class="n">longitud</span><span class="p">;</span>
 <span class="n">longitud</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">cadena</span><span class="p">);</span>
 <span class="n">printf</span><span class="p">(</span><span class="s">"La longitud es %i"</span><span class="p">,</span> <span class="n">longitud</span><span class="p">);</span>
</code></pre></div> </div> </li> <li> <p><strong><em>strcmp()</em></strong>: Compara dos cadenas. Devuelve el valor 0 si son iguales, un valor mayor que 0 si la primera es alfabéticamente mayor que la segunda, o un valor menor que 0 en caso contrario. Por ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">char</span> <span class="n">cad1</span><span class="p">[</span><span class="mi">50</span><span class="p">],</span> <span class="n">cad2</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
 <span class="kt">int</span> <span class="n">comparacion</span><span class="p">;</span>
 <span class="n">printf</span><span class="p">(</span><span class="s">"Introduzca dos cadenas"</span><span class="p">);</span>
 <span class="n">scanf</span><span class="p">(</span><span class="s">"%s %s"</span><span class="p">,</span> <span class="n">cad1</span><span class="p">,</span> <span class="n">cad2</span><span class="p">);</span>
 <span class="n">comparacion</span> <span class="o">=</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">cad1</span><span class="p">,</span> <span class="n">cad2</span><span class="p">);</span>
 <span class="k">if</span> <span class="p">(</span><span class="n">comparacion</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Las dos cadenas son iguales"</span><span class="p">);</span>
</code></pre></div> </div> </li> <li> <p><strong><em>strcat()</em></strong>: Concatena dos cadenas. Esta función añade la <em>cadena2</em> al final de la <em>cadena1</em>, incluyendo el carácter nulo. El resultado del siguiente ejemplo debe ser, otra vez, “hola, mundo”:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">char</span> <span class="n">cad1</span><span class="p">[</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Hola, "</span><span class="p">;</span>
 <span class="kt">char</span> <span class="n">cad2</span><span class="p">[</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="s">"mundo"</span><span class="p">;</span>
 <span class="n">strcat</span><span class="p">(</span><span class="n">cad1</span><span class="p">,</span> <span class="n">cad2</span><span class="p">);</span>
 <span class="n">prinft</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">cad1</span><span class="p">);</span>
</code></pre></div> </div> </li> </ul> <h4 id="las-cadenas-y-la-validación-de-los-datos-de-entrada"> <a href="#las-cadenas-y-la-validación-de-los-datos-de-entrada" class="anchor-heading" aria-labelledby="las-cadenas-y-la-validación-de-los-datos-de-entrada"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Las cadenas y la validación de los datos de entrada </h4> <p>Una de las principales fuentes de error de los programas son los datos de entrada incorrectos. Por ejemplo, si un programa está preparado para leer un número entero pero el usuario, por error o por mala fe, introduce un carácter, la función <em>scanf()</em> fallará y el programa se detendrá.</p> <p>En otros lenguajes de más alto nivel, el propio lenguaje tiene mecanismos para prevenir estos errores. Pero recuerda que C es un lenguaje de nivel intermedio, pensado para producir código máquina supereficiente y rápido. El precio a pagar por ello es que el lenguaje no hará ninguna comprobación de este tipo de errores: es responsabilidad del programador preverlos.</p> <p>Hay un modo bastante sencillo de hacer esto: <strong>leer todos los datos de entrada como cadenas y, luego, convertirlos al tipo de dato adecuado</strong>.</p> <p>Observa el siguiente ejemplo. Sirve para leer un número entero por teclado, pero previniendo los errores provocados por el usuario que antes mencionábamos. Se utiliza la función <em>atoi()</em>, que convierte una cadena a un número entero:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">n</span><span class="p">;</span>		<span class="c1">// El número entero que se pretende leer por teclado</span>
<span class="kt">char</span> <span class="n">cad</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>	<span class="c1">// La cadena que se usará para prevenir errores de lectura</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Introduzca un número entero"</span><span class="p">);</span>
<span class="n">gets</span><span class="p">(</span><span class="n">cad</span><span class="p">);</span>		<span class="c1">// No se lee un número entero, sino una cadena</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">cad</span><span class="p">);</span>	<span class="c1">// Se convierte la cadena a entero</span>
</code></pre></div></div> <h3 id="9211-arrays"> <a href="#9211-arrays" class="anchor-heading" aria-labelledby="9211-arrays"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.2.11. Arrays </h3> <p>Un <strong>array</strong>, como ya vimos en pseudocódigo, es una agrupación de muchos datos individuales del mismo tipo bajo el mismo nombre. Cada dato individual de un array es accesible mediante un <strong>índice</strong>.</p> <p>El caso más simple de array es el <strong>array unidimensional</strong>. Por ejemplo, un array unidimensional de números enteros es una colección de muchos números enteros a los que les adjudicamos un único identificador.</p> <h4 id="declaración-de-arrays"> <a href="#declaración-de-arrays" class="anchor-heading" aria-labelledby="declaración-de-arrays"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Declaración de arrays </h4> <p>La declaración de un array en C se hace así:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tipo_de_datos</span> <span class="n">nombre_array</span><span class="p">[</span><span class="n">n</span><span class="err">ú</span><span class="n">mero_de_elementos</span><span class="p">];</span>
</code></pre></div></div> <p>Por ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">serie</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</code></pre></div></div> <p>La variable <em>serie</em> será un array que contendrá 10 números enteros. Los 10 números reciben el mismo nombre, es decir, <em>serie</em>. Se puede acceder a cada uno de los números que forman el array escribiendo a continuación del nombre un número entre corchetes. Ese número se denomina índice. Lo puedes ver en el siguiente ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">serie</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="n">serie</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="n">serie</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
<span class="n">serie</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">serie</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">serie</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="n">serie</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
</code></pre></div></div> <p>El array <em>serie</em> puede almacenar hasta 10 números enteros. Las posiciones empiezan a numerarse en el 0, así que <em>serie[2]</em> se refiere, en realidad, a la tercera posición. En ella se almacena el número 20. En la cuarta posición (<em>serie[3]</em>) se almacena el número 15. Luego se suman ambos valores, y el resultado se almacena en la quinta posición (<em>serie[4]</em>). Finalmente, se imprime en la pantalla el resultado de la suma, es decir, 35.</p><pre>
            +------------+----+----+----+----+----+
            | Posiciones |  0 |  1 |  2 |  3 |  4 |
    serie = +------------+----+----+----+----+----+
            | Valores    |  ? |  ? | 20 | 15 | 35 |
            +------------+----+----+----+----+----+
</pre><p>C no realiza comprobación de los índices de los arrays, por lo que es perfectamente posible utilizar un índice fuera del rango válido (por ejemplo, <em>serie[17]</em>). Es responsabilidad del programador evitar que esto ocurra, porque los efectos serán desastrosos para el programa.</p> <p>Como es lógico, se pueden construir arrays cuyos elementos sean de cualquier otro tipo simple, como <em>float</em> o <em>double</em>, con la única restricción de que todos los elementos sean del mismo tipo. Los arrays de caracteres se denominan <strong>cadenas de caracteres</strong>, y ya hablamos de ellos en el apartado anterior.</p> <p>También es posible construir arrays cuyos elementos sean de un tipo complejo. Así, podemos tener arrays de arrays o de otros tipos que no vamos a estudiar en este curso de introducción.</p> <h4 id="manipulación-de-los-elementos-individuales-de-un-array"> <a href="#manipulación-de-los-elementos-individuales-de-un-array" class="anchor-heading" aria-labelledby="manipulación-de-los-elementos-individuales-de-un-array"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Manipulación de los elementos individuales de un array </h4> <p>Los arrays en C deben manipularse elemento a elemento. No se pueden modificar todos los elementos a la vez.</p> <p>Para asignar valores a los elementos de un array, por lo tanto, el mecanismo es este:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">serie</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="n">serie</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">serie</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">serie</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="p">...</span><span class="n">etc</span><span class="p">...</span>
</code></pre></div></div> <p>La inicialización de los valores de un array también puede hacerse conjuntamente en el momento de declararlo, así:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">serie</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">14</span><span class="p">};</span>
</code></pre></div></div> <p>El resultado de esta declaración será un array de 5 elementos de tipo entero a los que se les asigna los valores 5, 3, 7, 9 y 14.</p> <p>Cada elemento del array es, a todos los efectos, una variable que puede usarse independientemente de los demás elementos. Así, por ejemplo, un elemento del array serie puede usarse en una instrucción de salida igual que cualquier variable simple de tipo <em>int</em>:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">serie</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="n">serie</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="n">serie</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</code></pre></div></div> <p>Del mismo modo, pueden usarse elementos de array en una instrucción de entrada. Por ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">serie</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="n">scanf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">serie</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">serie</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">serie</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">15</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="n">serie</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</code></pre></div></div> <h4 id="recorrido-de-un-array"> <a href="#recorrido-de-un-array" class="anchor-heading" aria-labelledby="recorrido-de-un-array"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Recorrido de un array </h4> <p>Una forma habitual de manipular un array es <strong>acceder secuencialmente</strong> a todos sus elementos, uno tras otro.</p> <p>Para ello, <strong>se utiliza un bucle con contador</strong>, de modo que la variable contador nos sirve como índice para acceder a cada uno de los elementos del array.</p> <p>Supongamos, por ejemplo, que tenemos un array de 10 números enteros declarado como <code class="language-plaintext highlighter-rouge">int v[10]</code> y una variable entera declarada como <code class="language-plaintext highlighter-rouge">int i</code>. Por medio de un bucle, con ligeras modificaciones, podemos realizar todas estas operaciones:</p> <p><strong>1) Inicializar todos los elementos a un valor cualquiera</strong> (por ejemplo, 0):</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>2) Inicializar todos los elementos con valores introducidos por teclado</strong>:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">"Escribe el valor del elemento nº %i: "</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
   <span class="n">scanf</span><span class="p">(</span><span class="s">"%i"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>3) Mostrar todos los elementos en la pantalla</strong>:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">"El elemento nº %i vale %i</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>4) Realizar alguna operación que implique a todos los elementos</strong>. Por ejemplo, sumarlos:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">suma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">suma</span> <span class="o">=</span> <span class="n">suma</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="arrays-y-funciones"> <a href="#arrays-y-funciones" class="anchor-heading" aria-labelledby="arrays-y-funciones"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Arrays y funciones </h4> <p>Para <strong>pasar un array como argumento</strong> a una función, en la llamada a la función se escribe simplemente el nombre del array, sin índices.</p> <p>Los arrays en C <strong>siempre se pasan por referencia</strong>, nunca por valor. Por lo tanto, si algún elemento del array se modifica en una función, también será modificado en la función desde la que fue invocada.</p> <p>Como siempre se pasan por referencia, no es necesario utilizar el símbolo &amp; delante del parámetro.</p> <p>Por ejemplo, supongamos que <em>serie</em> es un array de 15 números enteros. Para pasarlo como parámetro a una función llamada <em>funcion1()</em> escribiríamos simplemente esto:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">serie</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span>
<span class="n">funcion1</span><span class="p">(</span><span class="n">serie</span><span class="p">);</span>
</code></pre></div></div> <p>En cuanto a la declaración de la función, el parámetro de tipo array se especifica esta maneras:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">funcion1</span> <span class="p">(</span><span class="kt">int</span> <span class="n">serie</span><span class="p">[</span><span class="mi">15</span><span class="p">])</span> <span class="p">{</span>
   <span class="p">...</span><span class="n">c</span><span class="err">ó</span><span class="n">digo</span> <span class="n">de</span> <span class="n">la</span> <span class="n">funci</span><span class="err">ó</span><span class="n">n</span><span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>Dentro de la función, el array <em>serie</em> puede usarse del mismo modo que en el programa que la llama, es decir, no es preciso utilizar el operador asterisco ni nada por el estilo.</p> <h4 id="un-programa-de-ejemplo-que-usa-arrays-y-funciones"> <a href="#un-programa-de-ejemplo-que-usa-arrays-y-funciones" class="anchor-heading" aria-labelledby="un-programa-de-ejemplo-que-usa-arrays-y-funciones"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Un programa de ejemplo que usa arrays y funciones </h4> <p>Para ilustrar todo esto, te muestro programa que sirve para leer 50 números por teclado y calcular la suma, la media y la desviación típica de todos los valores.</p> <p>Lee el código detenidamente, prestando sobre todo atención al uso de los arrays y a cómo se pasan como parámetros.</p> <p>Los números de la serie se almacenarán en un array de tipo <em>float</em> de 50 posiciones llamado <em>valores</em>. La introducción de datos en el array se hace en la función <em>introducir_valores()</em>. Como los arrays siempre se pasan por referencia, al modificar el array <em>valores</em> dentro de la función, también se modificará en el algoritmo principal.</p> <p>Después, se llama a 3 funciones que calculan las tres magnitudes (suma, media y desviación). El array también se pasa por referencia a estas funciones, ya que en C no hay modo de pasar un array por valor.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;math.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">float</span> <span class="n">valores</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
	<span class="kt">float</span> <span class="n">suma</span><span class="p">,</span> <span class="n">media</span><span class="p">,</span> <span class="n">desviacion</span><span class="p">;</span>
	
	<span class="n">introducir_valores</span><span class="p">(</span><span class="n">valores</span><span class="p">);</span>
	<span class="n">suma</span> <span class="o">=</span> <span class="n">calcular_suma</span><span class="p">(</span><span class="n">valores</span><span class="p">);</span>	
	<span class="n">media</span> <span class="o">=</span> <span class="n">calcular_media</span><span class="p">(</span><span class="n">valores</span><span class="p">,</span> <span class="n">suma</span><span class="p">);</span>
	<span class="n">desviacion</span> <span class="o">=</span> <span class="n">calcular_desviacion</span><span class="p">(</span><span class="n">valores</span><span class="p">,</span> <span class="n">media</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"La suma es %f, la media es %f y la desviación es %f"</span><span class="p">,</span> <span class="n">suma</span><span class="p">,</span> <span class="n">media</span><span class="p">,</span> <span class="n">desviacion</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Lee 50 números y los almacena en el array N pasado por referencia */</span>
<span class="kt">void</span> <span class="nf">introducir_valores</span><span class="p">(</span><span class="kt">float</span> <span class="n">n</span><span class="p">[</span><span class="mi">50</span><span class="p">])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">49</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Introduzca el valor nº %d: "</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">"%f"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Devuelve la suma todos los elementos del array n */</span>
<span class="kt">float</span> <span class="nf">calcular_suma</span><span class="p">(</span><span class="kt">float</span> <span class="n">n</span><span class="p">[</span><span class="mi">50</span><span class="p">])</span>	
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">suma</span><span class="p">;</span>
	<span class="n">suma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">49</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">suma</span> <span class="o">=</span> <span class="n">suma</span> <span class="o">+</span> <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">suma</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Devuelve el valor medio de los elementos del array n. Necesita conocer la suma de los elementos para calcular la media */</span>
<span class="kt">float</span> <span class="nf">calcular_media</span><span class="p">(</span><span class="kt">float</span> <span class="n">n</span><span class="p">[</span><span class="mi">50</span><span class="p">],</span> <span class="kt">float</span> <span class="n">suma</span><span class="p">)</span>	
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">media</span><span class="p">;</span>
	<span class="n">media</span> <span class="o">=</span> <span class="n">suma</span> <span class="o">/</span> <span class="mi">50</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">media</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Calcula la desviación típica de los elementos del array n. Necesita conocer la media para hacer los cálculos */</span>
<span class="kt">float</span> <span class="nf">calcular_desviacion</span><span class="p">(</span><span class="kt">float</span> <span class="n">n</span><span class="p">[</span><span class="mi">50</span><span class="p">],</span> <span class="kt">float</span> <span class="n">media</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">diferencias</span><span class="p">;</span>
	<span class="n">diferencias</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">49</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">diferencias</span> <span class="o">=</span> <span class="n">diferencias</span> <span class="o">+</span> <span class="n">abs</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="err">–</span> <span class="n">media</span><span class="p">)</span> <span class="p">;</span>
	<span class="n">diferencias</span> <span class="o">=</span> <span class="n">diferencias</span> <span class="o">/</span> <span class="mi">50</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">diferencias</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="9212-funciones-de-la-librería-estándar"> <a href="#9212-funciones-de-la-librería-estándar" class="anchor-heading" aria-labelledby="9212-funciones-de-la-librería-estándar"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.2.12. Funciones de la librería estándar </h3> <p>La siguiente lista resume algunas funciones de uso frecuente de ANSI C. Para cada función se muestra su prototipo y se explica brevemente cuál es su cometido y cuáles sus datos de entrada y salida. También se indica el archivo de cabecera donde se encuentra el prototipo.</p> <p>Debes tener en cuenta que ANSI C dispone de muchas otras funciones. Si en algún momento las necesitas, una búsqueda rápida por internet te proporcionará información de sobra. Eso sí, asegúrate que la función que vayas a usar pertenezca al estándar ANSI C. Solo así tendrás la garantía de que tu compilador la reconocerá y de que tu programa será portable a otros sistemas.</p> <p><strong>Funciones de entrada/salida</strong></p> <div class="table-wrapper"><table> <thead> <tr> <th>Función</th> <th>Prototipo</th> <th>Utilidad</th> <th>Archivo de cabecera</th> </tr> </thead> <tbody> <tr> <td><strong><em>getchar()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">int getchar(void)</code></td> <td>Devuelve un carácter leido por teclado mostrando el eco. Es necesario pulsar INTRO</td> <td>stdio.h</td> </tr> <tr> <td><strong><em>gets()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">char* gets(char* cadena)</code></td> <td>Lee una cadena de caracteres del dispositivo estándar de entrada y la sitúa en la posición apuntada por cadena</td> <td>stdio.h</td> </tr> <tr> <td><strong><em>printf()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">int printf(const char* formato, lista_argumentos)</code></td> <td>Salida estándar con formato. Véase el texto del capítulo para más detalles</td> <td>stdio.h</td> </tr> <tr> <td><strong><em>putchar()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">int putchar(int carácter)</code></td> <td>Escribe carácter en la pantalla</td> <td>stdio.h</td> </tr> <tr> <td><strong><em>puts()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">int puts(const char* cadena)</code></td> <td>Escribe cadena en el dispositivo estándar de salidastdio.h</td> <td> </td> </tr> <tr> <td><strong><em>scanf()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">int scanf(const char* formato, lista_argumentos)</code></td> <td>Entrada estándar con formato. Véase el texto del capítulo para más detalles</td> <td>stdio.h</td> </tr> </tbody> </table></div> <p><strong>Funciones de caracteres</strong></p> <div class="table-wrapper"><table> <thead> <tr> <th>Función</th> <th>Prototipo</th> <th>Utilidad</th> <th>Archivo de cabecera</th> </tr> </thead> <tbody> <tr> <td><strong><em>isalnum()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">int isalnum(int carácter)</code></td> <td>Devuelve 1 si el carácter es alfanumérico (letra o número), o 0 si no lo es</td> <td>ctype.h</td> </tr> <tr> <td><strong><em>isalpha()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">int isalpha(int carácter)</code></td> <td>Devuelve 1 si el carácter es alfabético (una letra mayúscula o minúscula), o 0 si no lo es</td> <td>ctype.h</td> </tr> <tr> <td><strong><em>isdigit()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">int isdigit(int carácter)</code></td> <td>Devuelve 1 si el carácter es numérico, o 0 si no lo es</td> <td>ctype.h</td> </tr> <tr> <td><strong><em>isupper()</em></strong> e <strong><em>islower()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">int isupper(int carácter); int islower(int carácter);</code></td> <td>La primera devuelve 1 si el carácter es una letra mayúscula y 0 en otro caso. La segunda, al revés</td> <td>ctype.h</td> </tr> </tbody> </table></div> <p><strong>Funciones matemáticas</strong></p> <div class="table-wrapper"><table> <thead> <tr> <th>Función</th> <th>Prototipo</th> <th>Utilidad</th> <th>Archivo de cabecera</th> </tr> </thead> <tbody> <tr> <td><strong><em>abs()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">int abs(int número)</code></td> <td>Devuelve el valor absoluto de número</td> <td>stdlib.h</td> </tr> <tr> <td><strong><em>cos()</em></strong><br /><strong><em>sin()</em></strong><br /><strong><em>tan()</em></strong><br /><strong><em>acos()</em></strong><br /><strong><em>asin()</em></strong><br /><strong><em>atan()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">double acos(double argumento)</code></td> <td>Todas tienen un prototipo similar. Calculan y devuelven, respectivamente, el arcocoseno, el arcoseno, el arcotangente, el coseno, el seno y la tangente de argumento. Los ángulos se expresan en radianes</td> <td>math.h</td> </tr> <tr> <td><strong><em>ceil()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">double ceil(double número)</code></td> <td>Redondea número por exceso. P. ej: ceil(3.2) devuelve 4</td> <td>math.h</td> </tr> <tr> <td><strong><em>exp()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">double exp(double potencia)</code></td> <td>Calcula el exponencial epotencia</td> <td>math.h</td> </tr> <tr> <td><strong><em>fabs()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">double fabs(double número)</code></td> <td>Devuelve el valor absoluto de número</td> <td>math.h</td> </tr> <tr> <td><strong><em>floor()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">double floor(double número)</code></td> <td>Redondea número por defecto. P. ej: floor(3.8) devuelve 3</td> <td>math.h</td> </tr> <tr> <td><strong><em>log()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">double log(double número)</code></td> <td>Devuelve el logaritmo natural de número</td> <td>math.h</td> </tr> <tr> <td><strong><em>log10()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">double log10(double número)</code></td> <td>Devuelve el logaritmo decimal de número</td> <td>math.h</td> </tr> <tr> <td><strong><em>pow()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">double log(double base, double exp)</code></td> <td>Devuelve la potencia de base elevado a exp</td> <td>math.h</td> </tr> <tr> <td><strong><em>sqrt()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">double sqrt(double número)</code></td> <td>Devuelve la raiz cuadrada de número</td> <td>math.h</td> </tr> </tbody> </table></div> <p><strong>Funciones variadas</strong></p> <div class="table-wrapper"><table> <thead> <tr> <th>Función</th> <th>Prototipo</th> <th>Utilidad</th> <th>Archivo de cabecera</th> </tr> </thead> <tbody> <tr> <td><strong><em>atof()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">double atof(char* cadena)</code></td> <td>Convierte la cadena en un número real. Si la cadena no contiene un número real válido, devuelve 0</td> <td>stdlib.h</td> </tr> <tr> <td><strong><em>atoi()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">int atoi(char* cadena)</code></td> <td>Convierte la cadena en un número entero. Si la cadena no contiene un número entero válido, devuelve 0</td> <td>stdlib.h</td> </tr> <tr> <td><strong><em>atof()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">double atof(char* cadena)</code></td> <td>Convierte la cadena en un número real. Si la cadena no contiene un número real válido, devuelve 0</td> <td>stdlib.h</td> </tr> <tr> <td><strong><em>itoa()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">char* itoa(int número, int base)</code></td> <td>Convierte el número en una cadena. La base de la cadena resultante se determina en base</td> <td>stdlib.h</td> </tr> <tr> <td><strong><em>rand()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">int rand(void)</code></td> <td>Devuelve un número entero al azar entre 0 y RAND_MAX (RAND_MAX es una constante definida en stdlib.h)</td> <td>stdlib.h</td> </tr> <tr> <td><strong><em>randomize()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">void randomize(void)</code></td> <td>Inicializa el generador de números aleatorio. Es necesario invocar esta función si después se va a usar random()</td> <td>stdlib.h</td> </tr> <tr> <td><strong><em>random()</em></strong></td> <td><code class="language-plaintext highlighter-rouge">int random(int máximo)</code></td> <td>Devuelve un número al azar entre 0 y máximo – 1</td> <td>stdlib.h</td> </tr> </tbody> </table></div> <h3 id="9213-librerías-no-estándar-que-molan-ncurses"> <a href="#9213-librerías-no-estándar-que-molan-ncurses" class="anchor-heading" aria-labelledby="9213-librerías-no-estándar-que-molan-ncurses"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.2.13. Librerías no estándar que molan: ncurses </h3> <p>Además de las librerías estándar ANSI, existen muchas (¡muchísimas!) librerías de terceros que se pueden usar en nuestros programas. Las que vamos a ver a continuación nos permitirán introducir colores, sonidos y movimientos en nuestros programas, pero debes tener presente una cosa: al no ser librerías estándar, los programas creados con estas librerías serán más difícilmente portables a otros sistemas.</p> <h4 id="qué-es-ncurses"> <a href="#qué-es-ncurses" class="anchor-heading" aria-labelledby="qué-es-ncurses"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Qué es Ncurses </h4> <p><strong>Ncurses</strong> es una <strong>librería para el manejo de interfaces basadas en texto</strong>.</p> <p>Es decir, se trata de un conjunto de funciones ya programadas que podemos utilizar en nuestros programas de texto para mejorar su aspecto.</p> <p>Como Ncurses no es una librería estándar de C, es necesario ordenar al compilador que la enlace con nuestro programa.</p> <p>Si compilas desde la consola, esto se hace añadiendo la opción –lncurses al comando <em>gcc</em>. Por ejemplo:</p> <ul> <li><code class="language-plaintext highlighter-rouge">gcc holamundo.c</code>: compila holamundo.c sin enlazarlo con la librería Ncurses</li> <li><code class="language-plaintext highlighter-rouge">gcc -lncurses holamundo.c</code>: compila holamundo.c enlazándolo con Ncurses</li> </ul> <p>Si trabajas desde desde Visual Studio Code y tienes la librería Ncurses instalada en tu sistema, no es necesario que hagas nada en especial. Un simple <code class="language-plaintext highlighter-rouge">#include &lt;ncurses.h&gt;</code> bastará para poder usar la librería.</p> <p>Ncurses tiene muchísimas funciones, pero nosotros sólo nos referiremos aquí a las más básicas, que nos permitirán añadir color a nuestros textos y controlar libremente la posición del cursor de escritura. Pero Ncurses va mucho más allá, permitiendo la creación de capas de texto superpuestas, menús desplegables y muchas otras cosas en la consola de texto.</p> <h4 id="inicialización-de-ncurses"> <a href="#inicialización-de-ncurses" class="anchor-heading" aria-labelledby="inicialización-de-ncurses"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Inicialización de Ncurses </h4> <p>Para utilizar las funciones de Ncurses en nuestro programa, basta con que incluyamos la siguiente llamada:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">initscr</span><span class="p">();</span>
</code></pre></div></div> <p>Esta función crea una ventana de texto. La ventana se llama <em>stdscr</em> (que significa “standard screen”, es decir, “pantalla estándar”). A partir de aquí podremos utilizar cualquier función de Ncurses, pues todas actúan sobre esa ventana (se pueden crear varias ventanas sobre stdscr, pero nosotros no profundizaremos en esa posibilidad). Por ejemplo, una función que suele ir justo después es:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">keypad</span> <span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div> <p>Esto sirve para activar la recepción de teclas especiales (como F1, F2, ESC, etc). Si no llamamos a keypad(), no podremos utilizar ese tipo de teclas en nuestro programa. El segundo parámetro sirve para activar (1) o desactivar (0) la recepción de teclas especiales.</p> <p>A continuación te dejo una lista con las principales funciones de inicialización de Ncurses:</p> <ul> <li><strong>initscr()</strong>. Inicializa Ncurses y crea la pantalla estándar. Debe ser invocada antes que cualquier otra función de la librería.</li> <li><strong>keypad()</strong>. Activa / desactiva la recepción de teclas especiales, como F1, ESC, Intro, etc. Si activar = 1, se activa la recepción. Si activar = 0, se desactiva.</li> <li><strong>echo()</strong> y <strong>noecho()</strong>. Activa / desactiva el eco de caracteres. Si el eco está activo, lo que se escriba en el teclado aparece en la pantalla. Si está inactivo, no.</li> <li><strong>cbreak()</strong> y <strong>nocbreak()</strong>. Activa / desactiva el envío inmediato de teclas. Normalmente, cuando se teclea algo no es enviado al programa hasta que no se pulsa “intro”. La función cbreak() hace que todo cuanto se teclee sea enviado al programa sin necesidad de “intro”. La función nocbreak() desactiva este comportamiento</li> <li> <p><strong>nodelay(stdscr)</strong>. Activa / desactiva la espera para lectura de teclado. Las funciones para leer un solo carácter, como getch(), detienen la ejecución del programa hasta que se pulsa alguna tecla. Llamando a esta función con el parámetro activar = 1, conseguiremos que el programa no se detenga en getch() aunque no se pulse tecla alguna. Para desactivarlo, llamaremos a la función con activar = 0.</p> </li> <li><strong>endwin()</strong>. Finaliza Ncurses. Hay que llamar a esta función antes de terminar el programa para liberar la memoria ocupada y restaurar la consola al estado inicial.</li> </ul> <h4 id="escribir-y-leer-con-ncurses"> <a href="#escribir-y-leer-con-ncurses" class="anchor-heading" aria-labelledby="escribir-y-leer-con-ncurses"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Escribir y leer con ncurses </h4> <p>Cuando utilicemos Ncurses debemos olvidarnos de las funciones de entrada/salida estándar, como <em>scanf()</em>, <em>printf()</em>, <em>gets()</em> o <em>puts()</em>. En su lugar usaremos estas otras funciones:</p> <ul> <li><strong>printw()</strong> y <strong>putstr()</strong>. Para escribir usaremos la función <em>printw()</em>, que funciona igual que <em>printf()</em> pero sobre una ventana de Ncurses. También podemos usar <em>putstr()</em>, que es como <em>puts()</em>, es decir, sirve para imprimir cadenas</li> <li><strong>getstr()</strong> y <strong>getch()</strong>. Para leer disponemos de <em>getstr()</em>, que es como <em>gets()</em>, es decir, sirve para leer cadenas por teclado. De modo que, si queremos leer un número, debemos leerlo como cadena y luego convertirlo a número (con las funciones estándar <em>atoi()</em>, <em>atof()</em>, etc). También podemos usar <em>getch()</em>, que lee un único carácter.</li> <li><strong>move()</strong>. Posiciona el cursor de texto en la columna x y la fila y de la pantalla. ¡Atención! Se indica primero la fila y luego la columna.</li> <li><strong>refresh()</strong>. Actualiza la pantalla. Es el único modo de asegurarnos de que los cambios realizados se muestren instantáneamente. Si no, Ncurses decidirá cuándo actualizar la pantalla por su cuenta, y te aseguro que no lo hace continuamente.</li> </ul> <h4 id="dar-color-a-nuestro-texto"> <a href="#dar-color-a-nuestro-texto" class="anchor-heading" aria-labelledby="dar-color-a-nuestro-texto"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Dar color a nuestro texto </h4> <p>Antes de utilizar los colores en la terminal de texto hay que inicializarlos llamando a la función <em>start_color()</em> sin argumentos, así:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">has_colors</span><span class="p">())</span>
  <span class="n">start_color</span><span class="p">();</span>
</code></pre></div></div> <p>La llamada previa a <em>has_colors()</em> se realiza para asegurarnos de que nuestra consola soporta el uso de colores. Es raro encontrar una consola que no permita colores, pero existen, así que no está de más hacer la comprobación.</p> <p>Una vez hecho esto, podemos utilizar los colores básicos definidos en <em>ncurses.h</em>, cuyas constantes son COLOR_BLACK, COLOR_WHITE, COLOR_YELLOW, etc.</p> <p>Para utilizar esos colores se deben agrupar en parejas: un color para el texto junto con un color para el fondo. A cada pareja se le asigna un número a través de la función <em>init_pair()</em>. Por ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">init_pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">COLOR_YELLOW</span><span class="p">,</span> <span class="n">COLOR_BLUE</span><span class="p">);</span>
</code></pre></div></div> <p>Esto define a la <em>pareja de colores nº 1</em> como <em>texto amarillo sobre fondo azul</em>. De este modo podemos definir, por lo general, hasta 64 parejas.</p> <p>Después, para <strong>activar una pareja de color</strong>, haremos esta llamada:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">attron</span><span class="p">(</span><span class="n">COLOR_PAIR</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</code></pre></div></div> <p>Esto activa la pareja de colores nº 1, de manera que todo el texto que aparezca en la pantalla a partir de este momento se verá amarillo con el fondo azul.</p> <p>La función <em>attron()</em>, además de para activar parejas de colores, sirve para cambiar otros atributos del texto. Por ejemplo, lo siguiente se utiliza para escribir en <strong>negrita</strong>:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">attron</span><span class="p">(</span><span class="n">A_BOLD</span><span class="p">);</span>
</code></pre></div></div> <p>Puedes obtener más información sobre attron() en las páginas de manual (escribiendo <code class="language-plaintext highlighter-rouge">$ man attron</code> en la consola) o en internet (por ejemplo, <a href="https://linux.die.net/man/3/attron">aquí</a>).</p> <h4 id="ejemplo-de-uso-de-ncurses"> <a href="#ejemplo-de-uso-de-ncurses" class="anchor-heading" aria-labelledby="ejemplo-de-uso-de-ncurses"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ejemplo de uso de Ncurses </h4> <p>Para terminar esta breve introducción a la librería Ncurses mostraremos un ejemplo ilustrativo del uso de algunas de las funciones que aquí se han visto.</p> <p>El siguiente programa utiliza Ncurses para escribir el texto HOLA en color rojo sobre fondo azul y el texto MUNDO en color amarillo sobre fondo verde. El texto HOLA aparece en la línea 11, y MUNDO en la 12. Luego, el programa espera hasta que se pulsa la tecla “flecha arriba”, y entonces termina.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;ncurses.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">car</span><span class="err">á</span><span class="n">cter</span><span class="p">;</span>
  <span class="n">initscr</span><span class="p">();</span>         <span class="c1">// Inicializa Ncurses</span>
  <span class="n">keypad</span><span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// Activa teclas especiales (como las flechas)</span>
  <span class="n">cbreak</span><span class="p">();</span>          <span class="c1">// Para no tener que pulsar Intro tras cada carácter </span>
  <span class="k">if</span> <span class="p">(</span><span class="n">has_colors</span><span class="p">())</span> <span class="n">start_color</span><span class="p">();</span>         <span class="c1">// Inicializa colores</span>
  <span class="n">init_pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">COLOR_RED</span><span class="p">,</span> <span class="n">COLOR_BLUE</span><span class="p">);</span>     <span class="c1">// Pareja 1 = Texto rojo, fondo azul</span>
  <span class="n">init_pair</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">COLOR_YELLOW</span><span class="p">,</span> <span class="n">COLOR_GREEN</span><span class="p">);</span> <span class="c1">// Pareja 2 = Texto amarillo, fondo verde</span>
  <span class="n">attron</span><span class="p">(</span><span class="n">COLOR_PAIR</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>    <span class="c1">// Activa pareja 1</span>
  <span class="n">move</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">printw</span><span class="p">(</span><span class="s">"HOLA"</span><span class="p">);</span>
  <span class="n">attron</span><span class="p">(</span><span class="n">COLOR_PAIR</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>    <span class="c1">// Activa pareja 2</span>
  <span class="n">move</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">printw</span><span class="p">(</span><span class="s">"MUNDO"</span><span class="p">);</span>
  <span class="k">do</span>
  <span class="p">{</span>  
       <span class="n">car</span><span class="err">á</span><span class="n">cter</span> <span class="o">=</span> <span class="n">getch</span><span class="p">();</span>  <span class="c1">// Lee un carácter desde el teclado</span>
  <span class="p">}</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">car</span><span class="err">á</span><span class="n">cter</span> <span class="o">!=</span> <span class="n">KEY_UP</span><span class="p">);</span>
  <span class="n">endwin</span><span class="p">();</span>  <span class="c1">// Finaliza Ncurses</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="9214-librerías-no-estándar-que-molan-sdl"> <a href="#9214-librerías-no-estándar-que-molan-sdl" class="anchor-heading" aria-labelledby="9214-librerías-no-estándar-que-molan-sdl"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.2.14. Librerías no estándar que molan: SDL </h3> <p><strong>SDL</strong> (iniciales de <em>Single DirectMedia Layer</em>) es una biblioteca de C libre y disponible para múltiples plataformas (entre ellas, Linux y Windows). Puedes bajarte la última versión de <a href="http://www.libsdl.org">http://www.libsdl.org</a>.</p> <p>Esta biblioteca contiene un conjunto muy completo de funciones para manejar gráficos, además de sonidos y distintos dispositivos multimedia (ratón, CD-ROM, etc). Muchos programas escritos en C (en particular, videojuegos) se han desarrollado con SDL. Además, la librería es razonablemente sencilla de usar.</p> <p>Nosotros sólo nos vamos a centrar en la parte de SDL dedicada a los gráficos. Si quieres más información, en la página web reseñada antes encontrarás una completa documentación.</p> <h4 id="instalación-de-sdl"> <a href="#instalación-de-sdl" class="anchor-heading" aria-labelledby="instalación-de-sdl"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Instalación de SDL </h4> <p>SDL no es una librería C estándar, es decir, no viene “de serie” con el compilador de C. En realidad, tampoco <em>ncurses</em> lo es, pero su uso está tan extendido en entornos Unix que viene incorporada a las librerías del compilador gcc.</p> <p>En cambio, la librería SDL debe ser instalada antes de poder utilizarla. A continuación describimos el proceso de instalación en Linux y en Windows</p> <p><strong>Instalación de SDL en Linux</strong></p> <ul> <li>Bájate la última versión de la librería de la web de SDL. Necesitarás el paquete de la librería propiamente dicho (denominado runtime) y el paquete de desarrollo. El paquete runtime tiene un nombre similar a este: SDL-x.x.x-1.i386.rpm, donde “x.x.x” es la versión de la libería e “i386” indica para qué tipo de procesador está compilado. El paquete de desarrollo debe llamarse SDL-devel-x.x.x-i386.rpm o algo similar.</li> <li>Instala ambos paquetes en tu sistema. Con el paquete runtime es suficiente para ejecutar programas que usen la librería SDL, pero si además quieres escribir programas nuevos que usen esta librería (y es nuestro caso), también necesitarás el paquete de desarrollo.</li> </ul> <p><strong>Instalación de SDL en Windows</strong></p> <ul> <li>Bájate la última versión de la librería de la web de SDL. Necesitarás la librería de vínculos dinámicos (denominada dll) y el paquete de desarrollo. La librería de vínculos dinámicos suele venir comprimida en un archivo cuyo nombre es similar a: SDL-x.x.x-win32.zip, donde “x.x.x” es la versión de la libería. Existirán varios paquetes de desarrollo para varios compiladores. Mi consejo es que bajes el que está preparado para el compilador de GNU, cuyo nombre es SDL-devel-x.x.x-mingw32.tar o algo similar. También encontrarás paquetes para Visual C++ y otros compiladores.</li> <li>Descomprime la librería de vínculos dinámicos. Debes obtener un archivo llamado sdl.dll. Copia este archivo al directorio /windows/system32, o bien ubícalo en la misma carpeta en la que vaya a estar el programa ejecutable del ajedrez.</li> <li>Descomprime el paquete de desarrollo. Encontrarás varios directorios y, dentro de ellos, multitud de archivos. Copia los archivos en los directorios del mismo nombre de tu compilador. Por ejemplo, el copia el directorio “include” del paquete de desarrollo al directorio “include” de la carpeta donde esté instalado tu compilador. Repite la operación para todos los directorios cuyo nombre coincida.</li> </ul> <h4 id="compilación-y-enlace"> <a href="#compilación-y-enlace" class="anchor-heading" aria-labelledby="compilación-y-enlace"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Compilación y enlace </h4> <p>Al no ser SDL una librería estándar, el enlace entre nuestro programa y las funciones de SDL no se produce automáticamente. Hay que indicarle al enlazador (o linker) lo que debe hacer.</p> <p>Si estás utilizando Visual Studio Code, la forma de hacer que SDL se enlace con tu programa es XXX.</p> <p>Si utilizas otro entorno de desarrollo distinto de Visual Studio Code, el proceso debe ser muy parecido, pero tendrás que mirar la documentación de ese entorno de desarrollo para ver los detalles.</p> <h4 id="inicialización-y-terminación-de-la-pantalla-gráfica"> <a href="#inicialización-y-terminación-de-la-pantalla-gráfica" class="anchor-heading" aria-labelledby="inicialización-y-terminación-de-la-pantalla-gráfica"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Inicialización y terminación de la pantalla gráfica </h4> <p>Una vez instalada la libería y preparado el compilador, podemos usar las funciones de SDL como cualquier otra función estándar de C. Su uso es exactamente igual en Windows y en Linux, por lo que el programa que obtendremos debería compilar sin necesidad de hacerle ningún cambio en ambos sistemas.</p> <p>Para usar los gráficos, hay que hacer un <code class="language-plaintext highlighter-rouge">#include &lt;SDL/SDL.h&gt;</code> en el archivo fuente, como es natural. Aparece dos veces el nombre “SDL” porque el archivo SDL.h está dentro de una carpeta llamada SDL.</p> <p>Lo siguiente que hay que hacer es <strong>inicializar la pantalla gráfica</strong>. Para eso disponemos de dos funciones: <em>SDL_Init()</em> y <em>SDL_SetVideoMode()</em>:</p> <ul> <li> <p><strong><em>SDL_Init()</em></strong>. Debe ser la primera función en invocarse. No se puede usar ninguna otra función de SDL si antes no se ha llamado a esta. Hay que pasarle un parámetro que indica qué tipo de sistema multimedia queremos manejar (la tarjeta de vídeo, la de sonido, el CD-ROM, etc). En nuestro caso será la tarjeta de vídeo, ya que sólo nos interesa manipular gráficos. La constante para ello es SDL_INIT_VIDEO:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">SDL_Init</span><span class="p">(</span><span class="n">SDL_INIT_VIDEO</span><span class="p">);</span>
</code></pre></div> </div> <p>La fución SDL_Init() devuelve –1 si ocurre algún error al iniciar el sistema de gráficos. En ese caso, el programa no podrá continuar, de modo que debemos comprobar el valor devuelto por SDL_Init().</p> </li> <li> <p><strong><em>SDL_SetVideoMode()</em></strong>. Esta debe ser la segunda función en invocarse, justo a continuación de SDL_Init(). Sirve para establecer el tipo de pantalla gráfica que queremos. Hay que indicarle el tamaño en píxels, el número de bits de color y los atributos de la pantalla. Por ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">SDL_SetVideoMode</span><span class="p">(</span><span class="mi">1200</span><span class="p">,</span> <span class="mi">960</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="n">SDL_ANYFORMAT</span> <span class="o">|</span> <span class="n">SDL_DOUBLEBUFFER</span><span class="p">);</span>
</code></pre></div> </div> <p>Esto crea una ventana gráfica de 1200x960 píxeles, con 24 bits de profundidad de color. El último parámetro, <em>SDL_ANYFORMAT</em>, es una constante que indica a SDL que puede seleccionar otra profundidad de color si la elegida no está disponible. Este cuarto parámetro puede tomar otros muchos valores que no vamos a ver, pero sí señalaremos que es conveniente añadir la constante <em>SDL_DOUBLEBUFFER</em> por motivos de rendimiento (ver ejemplo más abajo).</p> <p><em>SDL_SetVideoMode()</em> devuelve un puntero a una estructura llamada <em>SDL_Surface</em>, definida en <em>SDL.h</em>, o NULL si ocurre algún error. Este puntero nos será imprescidible para manejar la pantalla gráfica, así que <strong>debes guardarlo en una variable</strong>.</p> <p>Esta variable, además, debe ser <strong>global</strong> si se va a usar en otras partes del programa, contraviniendo una de las buenas prácticas de programación más universales que existen. Sin embargo, si no lo haces así, la variable no funcionará correctamente.</p> <p>Aquí tienes un ejemplo de inicialización de la pantalla gráfica:</p> </li> </ul> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cp">#include</span> <span class="cpf">&lt;SDL/SDL.h&gt;</span><span class="c1">  </span><span class="cp">
</span>  <span class="p">...</span>
  <span class="n">SDL_Surface</span> <span class="o">*</span><span class="n">pantalla</span><span class="p">;</span>	<span class="c1">// Esta variable debe ser GLOBAL</span>
  <span class="p">...</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">SDL_Init</span><span class="p">(</span><span class="n">SDL_INIT_VIDEO</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"Error en la inicialización del sistema de vídeo</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">SDL_Quit</span><span class="p">();</span>
    <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">pantalla</span> <span class="o">=</span> <span class="n">SDL_SetVideoMode</span><span class="p">(</span><span class="mi">1280</span><span class="p">,</span> <span class="mi">960</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">SDL_ANYFORMAT</span><span class="o">|</span><span class="n">SDL_DOUBLEBUF</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pantalla</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"Fallo al establecer el modo de vídeo</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">SDL_Quit</span><span class="p">();</span>
    <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="p">...</span>
  <span class="n">SDL_Quit</span><span class="p">();</span>		<span class="c1">// Esto se hace al final del programa</span>
</code></pre></div></div> <p>Tan importante como inicializar la pantalla gráfica es <strong>finalizarla</strong>. Ten en cuenta que la pantalla gráfica consume muchos recursos, y éstos deben ser liberados antes de que el programa termine su ejecución. Para eso tenemos la función <em>SDL_Quit()</em>, que se invoca sin argumentos (observa el ejemplo)</p> <h4 id="dibujar-gráficos-en-la-pantalla"> <a href="#dibujar-gráficos-en-la-pantalla" class="anchor-heading" aria-labelledby="dibujar-gráficos-en-la-pantalla"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Dibujar gráficos en la pantalla </h4> <p>Ya tenemos nuestra pantalla gráfica inicializada y lista para empezar a dibujar en ella. Pero, ¿qué tipo de objetos se pueden dibujar?</p> <p>Aunque las librerías gráficas permiten al programador <strong>pintar píxels individuales</strong> en cualquier punto de la pantalla, lo habitual es <strong>trabajar con imágenes</strong> previamente existentes llamadas <strong><em>sprites</em></strong>.</p> <p>Un <em>sprite</em> es una imagen guardada en un archivo que puede ser cargada por el programa y mostrada en cualquier parte de la pantalla gráfica y tantas veces como sea necesario.</p> <p>Por lo tanto, lo primero que necesitas es hacerte con una colección de sprites para tu programa. Si, por ejemplo, suponemos que estamos desarrollando un de ajedrez, necesitaríamos los siguientes:</p> <ul> <li>Una imagen del tablero.</li> <li>Una imagen de cada una de las piezas.</li> <li>Opcionalmente, una imagen de fondo para decorar la pantalla.</li> </ul> <p>Los archivos con las imágenes deben estar en formato BMP. SDL admite otros formatos, pero el BMP es fácil de manipular, así que es buena idea empezar por las imágenes BMP y luego, cuando ya las manejes bien, dar el salto a otros formatos con compresión, como JPG o PNG. Cualquier editor de imágenes te permitirá convertir tus <em>sprites</em> a BMP.</p> <p>Para dibujar una imagen en cualquier punto de la pantalla, hay que hacer dos cosas que pasamos a describir con detalle:</p> <ul> <li>Cargar la imagen en la memoria (procedente de un archivo BMP)</li> <li>Mostrar la imagen en la pantalla</li> </ul> <p><strong>1. Cargar imágenes en la memoria</strong></p> <p>Sólo es necesario cargar las imágenes <strong>una vez</strong>. Normalmente, se hará <strong>al principio del programa</strong>, justo después de la inicialización de SDL.</p> <p>Una vez cargadas en la memoria, podremos utilizarlas tantas veces como las necesitemos, a menos que liberemos el espacio de memoria que ocupan. La liberación de espacio, por tanto, debería hacerse al final del programa, justo antes de terminar.</p> <p>Para cargar una imagen BMP se usa la función <em>SDL_LoadBMP()</em>, de esta forma:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">SDL_Surface</span> <span class="o">*</span><span class="n">tablero</span><span class="p">;</span>

  <span class="n">tablero</span> <span class="o">=</span> <span class="n">SDL_LoadBMP</span><span class="p">(</span><span class="s">"tablero.bmp"</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">tablero</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">"Error al cargar el archivo tablero.bmp"</span><span class="p">);</span>
     <span class="n">SDL_Quit</span><span class="p">();</span>
     <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div></div> <p>Observa que <em>SDL_LoadBMP()</em> devuelve un puntero a <em>SDL_Surface</em>. Este puntero será necesario para luego mostrar la imagen en cualquier lugar de la pantalla. La variable “tablero” debe ser global si se va a usar en más de una función (si es local y la pasamos como parámetro a otra función, SDL fallará).</p> <p>Las imágenes son rectangulares. En muchas ocasiones, necesitamos mostrar una imagen encima de otra. Es el caso de las piezas, que se mostrarán encima del tablero. Cuando esto ocurre, el color de fondo de la pieza (que decidimos que fuera negro) aparecerá encima del tablero como un desagradable recuadro de color negro. En estas situaciones, hay que avisar a SDL de que, para este <em>sprite</em> en concreto, el color negro (o el que decidamos) va a ser transparente, es decir, no debe ser mostrado. Esto se hace así:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">SDL_Surface</span> <span class="o">*</span><span class="n">peon_blanco</span><span class="p">;</span>
  <span class="n">Uint32</span> <span class="n">color</span><span class="p">;</span>	<span class="c1">// Para definir el color de transparencia (donde proceda)</span>

  <span class="c1">// Cargamos la imagen del peón blanco</span>
  <span class="n">peon_blanco</span> <span class="o">=</span> <span class="n">SDL_LoadBMP</span><span class="p">(</span><span class="s">"peon_blanco.bmp"</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">peon_blanco</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">"Error al cargar el archivo peon_blanco.bmp"</span><span class="p">);</span>
     <span class="n">SDL_Quit</span><span class="p">();</span>
     <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
 
  <span class="c1">// Definimos la transparencia (color negro = (0,0,0) )</span>
  <span class="n">color</span> <span class="o">=</span> <span class="n">SDL_MapRGB</span><span class="p">(</span><span class="n">peon_blanco</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">SDL_SetColorKey</span><span class="p">(</span><span class="n">cuadro1</span><span class="p">,</span> <span class="n">SDL_SRCCOLORKEY</span> <span class="o">|</span> <span class="n">SDL_RLEACCEL</span><span class="p">,</span> <span class="n">color</span><span class="p">);</span>
</code></pre></div></div> <p>Las imágenes cargadas en memoria deben ser liberadas antes de finalizar el programa con una llamada a SDL_FreeSurface(). Por ejemplo, para liberar la memoria ocupada por la imagen “tablero.bmp” que hemos cargado antes usaremos el puntero que obtuvimos al cargarla, así:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SDL_FreeSurface</span><span class="p">(</span><span class="n">tablero</span><span class="p">);</span>
</code></pre></div></div> <p><strong>2. Mostrar imágenes en la pantalla</strong></p> <p>Una vez cargada una imagen BMP en la memoria, podemos mostrarla en la pantalla a través del puntero <em>SDL_Surface</em> que obtuvimos al cargarla. Una imagen cargada puede ser mostrada todas las veces que queramos en cualquier posición de la pantalla.</p> <p>Por ejemplo, para mostrar la imagen del tablero (que cargamos en un ejemplo del apartado anterior) haríamos lo siguiente (luego comentamos el código):</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">SDL_Rect</span> <span class="n">rect</span><span class="p">;</span>
  <span class="n">rect</span> <span class="o">=</span> <span class="p">(</span><span class="n">SDL_Rect</span><span class="p">)</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">400</span><span class="p">};</span>
  <span class="n">SDL_BlitSurface</span><span class="p">(</span><span class="n">tablero</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">pantalla</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rect</span><span class="p">);</span>
  <span class="n">SDL_Flip</span><span class="p">(</span><span class="n">pantalla</span><span class="p">);</span>
</code></pre></div></div> <p>La variable <em>rect</em> es de tipo <em>SDL_Rect</em>, y define un área rectangular de la pantalla. El área rectangular empieza en las coordenadas (10, 10) (esquina superior izquierda de la pantalla) y mide 400 píxels de ancho y 400 de alto, es decir, termina en (410, 410).</p> <p><em>SDL_BlitSurface()</em> es la función que se encarga de mostrar en la pantalla un <em>sprite</em>. La variable <em>tablero</em> es de tipo <em>SDL_Surface</em>, y debe ser la que nos devolvió <em>SDL_LoadBMP()</em> al cargar la imagen del tablero. La variable <em>pantalla</em> también es una <em>SDL_Surface</em>, y debe ser la que nos devolvió <em>SDL_SetVideoMode()</em> al inicializar la pantalla gráfica. Ya dijimos que los punteros que nos devuelven estas funciones son imprescidibles y que debíamos definirlos como variables globales. La variable <em>rect</em> es el área rectangular que acabamos de definir.</p> <p>Fíjate que <em>rect</em> es la que indica en qué lugar de la pantalla va a aparecer el <em>sprite</em>. En este ejemplo, aparecerá en (10,10). Se le han reservado 400x400 píxels para dibujarse, es decir, hasta la posición (410, 410). Si el <em>sprite</em> es más pequeño, no pasará nada (ocupará lo que mida realmente). Si es más grande, se truncará.</p> <p>Por último, <em>SDL_Flip()</em> hace que lo que acabamos de dibujar se muestre realmente en la pantalla. Su efecto es parecido al de la función refresh() de ncurses. En realidad, todo lo que dibujamos se escribe en una zona de memoria específica y, al hacer <em>SDL_Flip()</em>, esa zona de memoria se vuelca sobre la memoria de vídeo, apareciendo todo en la pantalla. Esto representa el movimiento de gran cantidad de información entre distintas zonas de memoria, lo cual es un proceso relativamente lento. Por eso, si vamos a dibujar varios sprites consecutivos, es mejor hacer una sola vez <em>SDL_Flip()</em>, al final, cuando los hayamos dibujado todos. Llamar a <em>SDL_Flip()</em> después de dibujar cada sprite ralentizará notablemente el funcionamiento de nuestro programa.</p> <h4 id="control-del-teclado"> <a href="#control-del-teclado" class="anchor-heading" aria-labelledby="control-del-teclado"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Control del teclado </h4> <p>Para leer el teclado en una ventana gráfica creada con SDL <em>no</em> se pueden usar las funciones estándar (como <em>getchar()</em> o <em>gets()</em>), ni mucho menos las de <em>ncurses</em> (como <em>getstr()</em>).</p> <p>SDL solo permite <strong>leer los caracteres de uno en uno</strong>, y <strong>no muestra eco</strong> por la pantalla (si queremos eco, tenemos que mostrar los caracteres nosotros mismos después de leerlos).</p> <p>Por lo demás, la forma de capturar un carácter tecleado es similar a la de <em>ncurses</em>, solo que un poco más complicada. A continuación se muestra un código de ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SDL_Event</span> <span class="n">evento</span><span class="p">;</span>	  	      <span class="c1">// Para leer el teclado</span>

<span class="c1">// Leer teclado</span>
<span class="k">if</span> <span class="p">(</span><span class="n">SDL_PollEvent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">evento</span><span class="p">))</span>            <span class="c1">// Comprobar si se ha pulsado una tecla</span>
<span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">evento</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">SDL_KEYDOWN</span><span class="p">)</span>     <span class="c1">// Efectivamente, se ha pulsado una tecla</span>
   <span class="p">{</span>
       <span class="k">switch</span> <span class="p">(</span><span class="n">evento</span><span class="p">.</span><span class="n">key</span><span class="p">.</span><span class="n">keysym</span><span class="p">.</span><span class="n">sym</span><span class="p">)</span>  <span class="c1">// Vamos a mirar qué ecla es</span>
       <span class="p">{</span>
           <span class="k">case</span> <span class="n">SDLK_UP</span><span class="p">:</span>     <span class="p">...</span><span class="n">acciones</span><span class="p">...;</span> <span class="k">break</span><span class="p">;</span>	<span class="c1">// Flecha arriba</span>
           <span class="k">case</span> <span class="n">SDLK_DOWN</span><span class="p">:</span>   <span class="p">...</span><span class="n">acciones</span><span class="p">...;</span> <span class="k">break</span><span class="p">;</span>	<span class="c1">// Flecha abajo</span>
           <span class="k">case</span> <span class="n">SDLK_LEFT</span><span class="p">:</span>   <span class="p">...</span><span class="n">acciones</span><span class="p">...;</span> <span class="k">break</span><span class="p">;</span>	<span class="c1">// Felcha izquierda</span>
           <span class="k">case</span> <span class="n">SDLK_RIGHT</span><span class="p">:</span>  <span class="p">...</span><span class="n">acciones</span><span class="p">...;</span> <span class="k">break</span><span class="p">;</span>	<span class="c1">// Flecha derecha</span>
           <span class="k">case</span> <span class="n">SDLK_RETURN</span><span class="p">:</span> <span class="p">...</span><span class="n">acciones</span><span class="p">...;</span> <span class="k">break</span><span class="p">;</span>	<span class="c1">// Intro </span>
           <span class="k">case</span> <span class="n">SDLK_ESCAPE</span><span class="p">:</span> <span class="p">...</span><span class="n">acciones</span><span class="p">...;</span> <span class="k">break</span><span class="p">;</span>	<span class="c1">// ESC</span>
           <span class="k">case</span> <span class="n">SDLK_m</span><span class="p">:</span>      <span class="p">...</span><span class="n">acciones</span><span class="p">...;</span> <span class="k">break</span><span class="p">;</span>	<span class="c1">// Tecla "m" (menú)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Existen constantes para cualquiera de las otras teclas del teclado. Todas empiezan por <em>SDLK_</em>. Por ejemplo, la tecla “a” tendrá el código <em>SDLK_a</em>.</p> <h4 id="definición-de-colores"> <a href="#definición-de-colores" class="anchor-heading" aria-labelledby="definición-de-colores"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Definición de colores </h4> <p>Aunque a menudo trabajes con <em>sprites</em> basados en imágenes preexistentes, es posible que también necesites definir algún color para usarlo directamente sobre la pantalla gráfica (por ejemplo, para usar transparencias o para escribir un texto).</p> <p>En SDL no hay colores predefinidos, como en <em>ncurses</em>. Los colores debemos definirlos nosotros mezclando los colores básicos RGB (rojo, verde y azul).</p> <p>Hay dos formas de definir un color: con una variable de tipo <em>SDL_Color</em> o con una variable de tipo <em>Uint32</em>. El uso de una u otra dependerá de para qué queramos usar ese color:</p> <p><strong>a) Con una variable de tipo SDL_Color</strong>:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="n">SDL_Color</span> <span class="n">color</span><span class="p">;</span>
   <span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="n">SDL_Color</span><span class="p">)</span> <span class="p">{</span><span class="mi">50</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">255</span><span class="p">};</span>
</code></pre></div></div> <p>Los cuatro números definen el color. Deben ser números comprendidos entre 0 y 255. El primero es el nivel de rojo (R), el segundo el nivel de verde (G) y el tercero, el nivel de azul (B). El cuarto número es el brillo. El color definido en este ejemplo tiene mucho azul, bastante verde y poco rojo. El resultado debe ser un azul amarillento.</p> <p><strong>b) Con una variable de tipo Uint32</strong>:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="n">Uint32</span> <span class="n">color</span><span class="p">;</span>
   <span class="n">color</span> <span class="o">=</span> <span class="n">SDL_MapRGB</span><span class="p">(</span><span class="n">pantalla</span><span class="o">-&gt;</span><span class="n">format</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">200</span><span class="p">);</span>  
</code></pre></div></div> <p>En esta ocasión, <em>pantalla</em> debe ser un puntero a una imagen <em>SDL_Surface</em> que hayamos cargado previamente. Los tres valores siguientes son los niveles RGB. No hay nivel de brillo, porque éste se toma de la imagen apuntada por <em>pantalla</em>.</p> <p>De las dos maneras se pueden definir colores para usarlos posteriormente. Si el color lo necesitamos para una transparencia, recurriremos al segundo método (de hecho, ya vimos un ejemplo de ello al estudiar cómo se cargaban y mostaban las imágenes en SDL; allí usamos el color negro como transparencia). Si el color lo necesitamos para escribir un texto en la pantalla gráfica, usaremos el primer método (como se podrá ver en el siguiente apartado)</p> <h4 id="mostrar-texto-en-la-pantalla-gráfica-instalación-y-uso-de-la-librería-sdl_ttf"> <a href="#mostrar-texto-en-la-pantalla-gráfica-instalación-y-uso-de-la-librería-sdl_ttf" class="anchor-heading" aria-labelledby="mostrar-texto-en-la-pantalla-gráfica-instalación-y-uso-de-la-librería-sdl_ttf"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Mostrar texto en la pantalla gráfica: instalación y uso de la librería SDL_TTF </h4> <p>La librería SDL no permite directamente la escritura de texto en la pantalla gráfica. Esto se debe a que la pantalla gráfica, por definición, no admite caracteres, sino únicamente imágenes.</p> <p>Por fortuna, a la sombra de SDL se han creado multitud de librerías adicionales que, partiendo de SDL, complementan y mejoran sus prestaciones. Una de ellas es SDL_TTF.</p> <p>La libería SDL_TTF permite cargar fuentes <em>true type</em> que estén guardadas en archivos .ttf y manejarlas como si fueran imágenes BMP en la pantalla gráfica generada por SDL. Necesitamos SDL_TTF, por lo tanto, para escribir los mensajes de usuario y las opciones del menú.</p> <p>La <strong>instalación</strong> de la librería SDL_TTF es similar a la de SDL, tanto en Linux como en Windows, de modo que puedes remitirte al apartado correspondiente para recordar cómo se hacía. Lo mismo puede decirse en cuanto a la compilación y el enlace.</p> <p>Igual que SDL, la librería SDL_TTF necesita ser <strong>inicializada</strong> antes de usarla, y <strong>finalizada</strong> antes de terminar el programa para liberar los recursos adquiridos.</p> <p>Como SDL_TTF corre por debajo de SDL, debe ser inicializada después de SDL, y debe ser terminada antes que SDL. Observa cómo se hace en este ejemplo:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span><span class="p">(</span><span class="n">TTF_Init</span><span class="p">()</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Fallo al inicializar SDL_TTF"</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>  
</code></pre></div></div> <p>Inmediatamente después, ya podemos cargar una fuente true type de un archivo TTF, así:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">TTF_Font</span><span class="o">*</span> <span class="n">fuente</span><span class="p">;</span>
  <span class="p">....</span>
  <span class="n">fuente</span> <span class="o">=</span> <span class="n">TTF_OpenFont</span><span class="p">(</span><span class="s">"arial.ttf"</span><span class="p">,</span> <span class="mi">14</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">fuente</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Fallo al abrir la fuente"</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">TTF_SetFontStyle</span><span class="p">(</span><span class="n">fuente</span><span class="p">,</span> <span class="n">TTF_STYLE_BOLD</span><span class="p">);</span>
</code></pre></div></div> <p>La variable <em>fuente</em> es un puntero a <em>TTF_Font</em>. Debe ser una variable global por el mismo motivo que las variables <em>SDL_Surface</em>. La función <em>TTF_OpenFont()</em> abre el archivo “arial.ttf” y carga el tipo de letra Arial en tamaño 14 para su uso en el programa. Después es conveniente comprobar que el puntero <em>fuente</em> contenga un valor válido y no NULL.</p> <div class="table-wrapper"><table> <tbody> <tr> <td>Por último, la función <em>TTF_SetFontStyle()</em> puede usarse para determinar el estilo de la fuente. Tenemos varias posibilidades: <em>TTF_STYLE_BOLD</em> (negrita), <em>TTF_STYLE_ITALIC</em> (cursiva), <em>TTF_STYLE_UNDERLINE</em> (subrayado) y <em>TTF_STYLE_NORMAL</em>. Si queremos combinar varios estilos, podemos separarlos por el operador “</td> <td>”. Por ejemplo, para poner la fuente en negrita y cursiva escribiríamos esto:</td> </tr> </tbody> </table></div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">TTF_SetFontStyle</span><span class="p">(</span><span class="n">fuente</span><span class="p">,</span> <span class="n">TTF_STYLE_BOLD</span> <span class="o">|</span> <span class="n">TTF_STYLE_ITALIC</span><span class="p">);</span>
</code></pre></div></div> <p>El proceso de <strong>finalización</strong> del SDL_TTF es inverso y complementario al de inicialización. Primero habrá que liberar todas las fuentes cargadas durante la inicialización, y luego hay que terminar el subsistema SDL_TTF:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">TTF_CloseFont</span><span class="p">(</span><span class="n">fuente</span><span class="p">);</span> 
  <span class="n">TTF_Quit</span><span class="p">();</span>
</code></pre></div></div> <p>La variable <em>fuente</em> será de tipo <em>TTF_Font</em>, y debe coincidir con la que nos devolvió la función <em>TTF_OpenFont()</em>. Esta operación la repetiremos con cada una de las fuentes que hayamos cargado.</p> <p>Recuerda que todo esto debe hacerse ANTES de <em>SDL_Quit()</em>, ya que SDL_TTF depende de SDL.</p> <h4 id="escribir-texto-con-sdl_ttf"> <a href="#escribir-texto-con-sdl_ttf" class="anchor-heading" aria-labelledby="escribir-texto-con-sdl_ttf"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Escribir texto con SDL_TTF </h4> <p>Todo esto lo hacemos con un objetivo: poder escribir texto en la pantalla gráfica y sustituir así todas las funciones <em>printw()</em> y similares.</p> <p>Para escribir un texto hay que hacer dos cosas: <strong>primero, convertirlo en una imagen; segundo, mostrar la imagen en la pantalla</strong>.</p> <p>La conversión de un texto en una imagen se hace con la función <em>TTF_Render()</em>:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">SDL_Color</span> <span class="n">color</span><span class="p">;</span>
  <span class="n">SDL_Surface</span><span class="o">*</span> <span class="n">txt_img</span><span class="p">;</span>

  <span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="n">SDL_Color</span><span class="p">)</span> <span class="p">{</span><span class="mi">255</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">255</span><span class="p">};</span>
  <span class="n">txt_img</span> <span class="o">=</span> <span class="n">TTF_RenderText_Blended</span><span class="p">(</span><span class="n">fuente</span><span class="p">,</span> <span class="s">"Hola mundo"</span><span class="p">,</span> <span class="n">color</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">txt_img</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"Fallo al renderizar el texto"</span><span class="p">);</span>
	<span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div></div> <p>Como ves, hay que hacer bastantes cosas para mostrar un texto en la pantalla gráfica, pero todo es acostumbrarse. Primero, hay que definir un color para el texto (cómo se definen los colores es algo que vimos en el epígrafe anterior). En este caso, hemos escogido un rojo brillante.</p> <p>Después se invoca a <em>TTF_RenderText()</em>, pasándole como parámetros el puntero a la fuente que obtuvimos con <em>TTF_OpenFont()</em>, el texto que queremos mostrar y el color. La función nos devuelve un puntero de tipo <em>SDL_Surface</em> que, si recuerdas, es exactamente el mismo que usábamos con las imágenes cargadas desde un archivo BMP.</p> <p>En realidad, la función <em>TTF_RenderText()</em> tiene tres formas:</p> <ul> <li><em>TTF_RenderText_Solid()</em> - realiza una conversión del texto en imagen rápida pero de poca calidad.</li> <li><em>TTF_RenderText_Shaded()</em> - la imagen resultante es de gran calidad pero tiene un recuadro negro alrededor</li> <li><em>TTF_RenderText_Blended()</em> - la imagen resultante es de gran calidad y sin recuadro negro</li> </ul> <p>En general preferiremos el modo <em>Blended</em>, que es el que proporciona mejores resultados. El modo <em>Shaded</em> se puede usar en determinados lugares (si no hay otra imagen debajo del texto). El modo <em>Solid</em> sólo debe usarse si hay que mostrar mucho texto y el modo <em>Blended</em> se revela demasiado lento.</p> <p>Hasta aquí, sólo hemos convertido el texto “Hola mundo” en una imagen, pero aún no la hemos mostrado en la pantalla. Para hacerlo procederemos como con cualquier otra imagen:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// Mostramos el texto como si fuera una imagen</span>
  <span class="n">rect</span> <span class="o">=</span> <span class="p">(</span><span class="n">SDL_Rect</span><span class="p">)</span> <span class="p">{</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">280</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">30</span> <span class="p">};</span>
  <span class="n">SDL_BlitSurface</span><span class="p">(</span><span class="n">txt_img</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">pantalla</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rect</span><span class="p">);</span>	
  <span class="n">SDL_Flip</span><span class="p">(</span><span class="n">scr</span><span class="p">);</span>
</code></pre></div></div> <p>Se supone que <em>rect</em> es de tipo <em>SDL_Rect</em> y que pantalla es el puntero a <em>SDL_Surface</em> que nos devolvió <em>SDL_SetVideoMode()</em> al inicializar SDL. Así, el texto “Hola mundo” se mostrará en la posición (500, 280) de la pantalla gráfica, reservándose para él 100 píxels de ancho y 30 de alto.</p> <h2 id="93-escribiendo-programas-en-c"> <a href="#93-escribiendo-programas-en-c" class="anchor-heading" aria-labelledby="93-escribiendo-programas-en-c"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.3. Escribiendo programas en C </h2> <p>Ya conocemos cómo se manejan los principales elementos de un programa con C: variables, instrucciones de control, asignaciones, funciones, etc.</p> <p>Ahora nos queda saber cómo juntamos todo eso para escribir nuestros programas, ¿no te parece?</p> <h3 id="931-estructura-de-un-programa-en-c"> <a href="#931-estructura-de-un-programa-en-c" class="anchor-heading" aria-labelledby="931-estructura-de-un-programa-en-c"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.3.1. Estructura de un programa en C </h3> <p>Ya estamos en condiciones de echar un vistazo a cual será el aspecto de (casi) todos los programas que escribamos en C.</p> <p>Todo programa C, desde el más pequeño hasta el más complejo, tiene un <strong>programa principal</strong> ubicado en la función <strong><em>main()</em></strong>.</p> <p>Además, por encima de <em>main()</em> deben aparecer los <strong>prototipos de funciones</strong> (y esto implica a los archivos de cabecera, si se utilizan funciones de librería) y las variables y constantes globales, si las hay. Por debajo de <em>main()</em> encontraremos el código de las funciones de usuario.</p> <p>Por lo tanto, la <strong>estructura habitual de nuestros programas en C</strong> debería ser esta:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Comentario inicial: nombre del programa, del programador, fecha, etc */</span>

<span class="cm">/* Archivos de cabecera (prototipos de funciones de librería) */</span>
<span class="cp">#include</span> <span class="cpf">&lt;archivo_cabecera.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;archivo_cabecera.h&gt;</span><span class="cp">
</span>
<span class="cm">/* Prototipos de funciones escritas por nosotros */</span>
<span class="kt">float</span> <span class="n">funci</span><span class="err">ó</span><span class="n">n1</span> <span class="p">(</span><span class="n">argumentos</span><span class="p">);</span>
<span class="kt">float</span> <span class="n">funci</span><span class="err">ó</span><span class="n">n2</span> <span class="p">(</span><span class="n">argumentos</span><span class="p">);</span>

<span class="cm">/* Variables globales */</span>
<span class="kt">int</span> <span class="n">variable_global1</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">variable_global2</span><span class="p">;</span>

<span class="cm">/* Algoritmo principal */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
   <span class="cm">/* Variables locales del algoritmo principal */</span>
   <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
   <span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
   <span class="p">...</span>
   <span class="p">...</span>
   <span class="cm">/* Instrucciones del algoritmo principal */</span>
   <span class="p">...</span>
   <span class="n">funci</span><span class="err">ó</span><span class="n">n1</span><span class="p">(</span><span class="n">argumentos</span><span class="p">);</span>
   <span class="p">...</span>
   <span class="n">funci</span><span class="err">ó</span><span class="n">n2</span><span class="p">(</span><span class="n">argumentos</span><span class="p">);</span>
   <span class="p">...</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Código completo de las funciones escritas por nosotros */</span>
<span class="kt">float</span> <span class="n">funci</span><span class="err">ó</span><span class="n">n1</span> <span class="p">(</span><span class="n">argumentos</span><span class="p">)</span>
<span class="p">{</span>
   <span class="cm">/* Variables locales e instrucciones de este subalgoritmo */</span>
<span class="p">}</span>
<span class="kt">float</span> <span class="n">funci</span><span class="err">ó</span><span class="n">n2</span> <span class="p">(</span><span class="n">argumentos</span><span class="p">)</span>
<span class="p">{</span>
   <span class="cm">/* Variables locales e instrucciones de este subalgoritmo */</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="932-caja-de-herramientas"> <a href="#932-caja-de-herramientas" class="anchor-heading" aria-labelledby="932-caja-de-herramientas"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.3.2. Caja de herramientas </h3> <p>¿Qué necesitamos para comenzar a escribir programas en C? ¿Tendrás que instalar un montón de programas de desarrollo en tu ordenador?</p> <p>La verdad es que no. Para desarrollar con Javascript basta con que tengas instalado:</p> <ul> <li> <p><strong>Un editor de texto</strong>. No te sirve Microsoft Word ni Libreoffice Writer. Tiene que ser un editor de texto <em>plano</em>, es decir, que no introduzca información de formato en el archivo. Solo el texto.</p> <p>Existen muchísimos editores de estas características, porque son programas muy simples y livianos. El <strong>bloc de notas</strong> de Windows o el editor <strong>gedit</strong> de los sistemas Linux con escritorio Gnome (como Educandos) son dos de ellos.</p> <p>Un editor de texto para programación que ha tenido un crecimiento espectacular en los últimos años a nivel aficionado y profesional es <strong><a href="https://code.visualstudio.com/">Visual Studio Code</a></strong>. Es multiplataforma (tiene versiones para Windows, Linux y Mac) y de código abierto. Y es una auténtica maravilla, así que te recomiendo lo instales (¡siempre desde los repositorios de tu distribución Linux o desde la web oficial si trabajas con Windows, por favor!) y lo instales.</p> <p>Para programar en C con Visual Studio Code, tendrás que instalar las extensiones para C/C++, pero no te preocupes porque es muy fácil y no tardarás más de un minuto. En los ejercicios propuestos lo haremos.</p> </li> <li> <p><strong>Un compilador de C/C++</strong>. Todos los sistemas Linux llevan instalador un compilador de C muy popular llamado <strong>gcc</strong>. Si trabajas en Windows, lo más recomendable es que instales <strong>MinGW</strong>, una versión de gcc para Windows. Descárgala de la <a href="https://www.mingw-w64.org/">web del fabricante</a> y sigue las instrucciones de instalación.</p> <p>Nota: en Windows tendrás agregar la ruta hasta el ejecutable de Mingw en el PATH del sistema. La forma exacta de conseguir esto puede diferir según tu versión de Windows, y deberías buscar ayuda si no sabes cómo hacerlo (obviamente, este no es libro sobre Windows). En los sistemas Linux, esto no será necesario.</p> </li> </ul> <h3 id="933-flujo-de-trabajo"> <a href="#933-flujo-de-trabajo" class="anchor-heading" aria-labelledby="933-flujo-de-trabajo"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.3.3. Flujo de trabajo </h3> <p>Cuando se trabaja con C, la implementación de un programa suele dividirse en varias subfases: edición, compilación, enlace y depuración. Te las describo brevemente:</p> <ol> <li><strong>Edición del código fuente</strong>. Editar consiste en escribir el código fuente del programa en el lenguaje seleccionado, en nuestro caso C, con un editor de texto plano como <strong>Visual Studio Code</strong>.</li> <li><strong>Compilación</strong>. Una vez escrito el programa, debe traducirse a binario en un proceso llamado <em>compilación</em>. Esto puede hacerse desde la línea de comandos, aunque algunos editores de texto permiten hacerlo desde el propio editor. Es el caso de <em>Visual Studio Code</em>. Si has instalado las extensiones para C/C++, bastará con que vayas al menú <strong>Run</strong> o que pulses el <strong>botón “Play”</strong> que aparece arriba y a la derecha del editor.</li> <li><strong>Enlace</strong>. Si tu programa es muy complejo, tu código fuente ocupará varios archivos. En tal caso, hay que compilarlos de uno en uno y después <em>enlazarlos</em> entre sí para generar un único programa ejecutable. No te preocupes de momento por esto, porque tus primeros programas estarán en un solo archivo y, además, cuando llegue el momento, <em>Visual Studio Code</em> se encargará de hacer el enlace automáticamente por nosotros.de librerías entre diferentes aplicaciones.</li> <li> <p><strong>Depuración</strong>. Ningún programa está bien escrito a la primera. Nunca. Lo normal es que el compilador te informe de que hay multitud de errores en tu código fuente. Tendrás que leer cuidadosamente los mensajes de error para corregirlos. Por fortuna, el compilador te informará de la línea exacta donde localizó el error, e incluso te dirá de qué tipo de error se trata.</p> <p>Una vez corregidos los errores de escritura, cuando el programa empiece a funcionar, es posible que no haga exactamente lo que tú pretendías que hiciera. También tendrás que corregir estos errores de ejecución.</p> <p>XXX <em>captura de pantalla de extensión C++ y botón “Play”</em> XXX</p> </li> </ol> <h3 id="934-dónde-y-cómo-escribir-el-código-fuente"> <a href="#934-dónde-y-cómo-escribir-el-código-fuente" class="anchor-heading" aria-labelledby="934-dónde-y-cómo-escribir-el-código-fuente"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.3.4. Dónde y cómo escribir el código fuente </h3> <p>Los programas escritos en C suelen guardarse en dos tipos de archivo:</p> <ul> <li><strong>Archivos con extensión .c</strong>. Estos archivos contienen el grueso del código fuente. En particular, la función <em>main()</em>, que es necesaria en cualquier programa en C.</li> <li><strong>Archivos con extensión .h</strong>. Estos archivos contienen los prototipos de funciones y otras definiciones necesarias para que el programa funcione bien. Al principio, no escribirás ningún archivo de este tipo, pero sí que tendrás que incluir (con <em>#include</em>) muchos de ellos.</li> </ul> <h2 id="94-c-avanzado-punteros-y-estructuras-de-datos"> <a href="#94-c-avanzado-punteros-y-estructuras-de-datos" class="anchor-heading" aria-labelledby="94-c-avanzado-punteros-y-estructuras-de-datos"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.4. C avanzado: punteros y estructuras de datos </h2> <p>XXX <em>Texto pendiente de revisar</em> XXX</p> <p>1 Punteros Comprender y usar correctamente los punteros es con seguridad lo más complicado del lenguaje C, pero también se trata de un mecanismo muy poderoso. Tan poderoso que un simple puntero descontrolado (hay quien acertadamente los llama “punteros locos”) puede provocar que el programa se cuelgue irremediablemente o incluso que falle todo el sistema. Todos los programadores con cierta experiencia en C reconocerán que, a veces, programar con punteros es como quedarse atrapado en un ascensor con un montón de serpientes pitón enloquecidas. Pero, cuando se les coge el tranquillo y se les ata en corto, permiten hacer auténticas virguerías. 1.1 Comprendiendo los punteros Dentro de la memoria del ordenador, cada dato almacenado ocupa una o más celdas contiguas de memoria. El número de celdas de memoria requeridas para almacenar un dato depende de su tipo. Por ejemplo, un dato de tipo entero puede ocupar 16 bits (es decir, 2 bytes), mientras que un dato de tipo carácter ocupa 8 bits (es decir, 1 byte). Un puntero no es más que una variable cuyo contenido no es un dato, sino la dirección de memoria donde está almacenado un dato. Veámoslo a través de un ejemplo. Imaginemos que v es una variable de tipo carácter y que, por tanto, necesita 1 byte para ser almacenada. La declaración e inicialización de la variable será como la siguiente: char v; v = ‘A’; Al ejecutar este código, el sistema operativo asigna automáticamente una celda de memoria para el dato. Supongamos que la celda asignada tiene la dirección 1200. Al hacer la asignación v = ‘A’, el sistema almacena en la celda 1200 el valor 65, que es el código ASCII de la letra ‘A’: Dirección de memoria Contenido 1198</p> <p>1199</p> <p>1200 65 1201</p> <p>… … Cuando usamos la variable v a lo largo del programa, el sistema consulta el dato contenido en la celda de memoria asignada a la variable. Esa celda será siempre la misma a lo largo de la ejecución: la 1200. Por ejemplo, al encontrar esta instrucción: printf(“%c”, v); .. el compilador acude a la celda 1200 de la memoria, consulta el dato almacenado en ella en ese momento y sustituye la variable v por ese dato. El programador no tiene modo de saber en qué posición de memoria se almacena cada dato, a menos que utilice punteros. Los punteros sirven, entonces, para conocer la dirección de memoria donde se almacena el dato, y no el dato en sí. La dirección ocupada por una variable v se determina escribiendo &amp;v. Por lo tanto, &amp; es un operador unario, llamado operador dirección, que proporciona la dirección de una variable. La dirección de v se le puede asignar a otra variable mediante esta instrucción: char* p; p = &amp;v; Resultará que esta nueva variable es un puntero a v, es decir, una variable cuyo contenido es la dirección de memoria ocupada por la variable v. Representa la dirección de v y no su valor. Por lo tanto, el contenido de p será 1200, mientras que el contenido de v será 65. El dato almacenado en la celda apuntada por la variable puntero puede ser accedido mediante el operador asterisco aplicado al puntero. Así pues, la expresión <em>p devuelve el valor 65, que es el contenido de la celda apuntada por p. El operador * es un operador unario, llamado operador indirección, que opera sólo sobre una variable puntero. Los operadores monarios &amp; y * son miembros del mismo grupo de precedencia que los otros operadores monarios: -,++,–,!,etc. Hay que recordar que este grupo de operadores tiene mayor precedencia que el de los operadores aritméticos y la asociatividad de los operadores monarios es de derecha a izquierda. Resumiendo: podemos tener variables “normales” y utilizar el operador &amp; para conocer su dirección de memoria. O podemos tener variables puntero, que ya son en sí mismas direcciones de memoria, y utilizar el operador * para acceder al dato que contienen. Así pues: • El operador dirección (&amp;) sólo puede actuar sobre variables que no sean punteros. En el ejemplo anterior, la variable v vale 65 y la expresión &amp;v vale 1200. • El operador indirección (</em>) sólo puede actuar sobre variables que sean punteros. En el ejemplo anterior, la expresión <em>p vale 65 y la variable p vale 1200. Las variables puntero pueden apuntar a direcciones donde se almacene cualquier tipo de dato: enteros, flotantes, caracteres, cadenas, arrays, estructuras, etc. Esto es tremendamente útil y proporciona una enorme potencia al lenguaje C, pero también es una fuente inagotable de errores de programación difíciles de detectar y corregir, como iremos viendo en los siguientes temas<br /> 1.2 Declaración e inicialización de punteros Las variables de tipo puntero, como cualquier otra variable, deben ser declaradas antes de ser usadas. Cuando una variable puntero es definida, el nombre de la variable debe ir precedido por un *. El tipo de dato que aparece en la declaración se refiere al tipo de dato que se almacena en la dirección representada por el puntero, en vez del puntero mismo. Así, una declaración de puntero general es: tipo_dato *puntero; donde puntero es la variable puntero y tipo_dato el tipo de dato apuntado por el puntero. Por ejemplo: int *numero; char *letra; La variable numero no contiene un número entero, sino la dirección de memoria donde se almacenará un número entero. La variable letra tampoco contiene un carácter, sino una dirección de memoria donde se almacenará un carácter. Cuando un puntero ha sido declarado pero no inicializado, apunta a una dirección de memoria indeterminada. Si tratamos de usarlo en esas condiciones obtendremos resultados impredecibles (y casi siempre desagradables). Antes de usar cualquier puntero hay que asegurarse de que está apuntando a una dirección válida, es decir, a la dirección de alguna variable del tipo adecuado. Por ejemplo, así: int *numero; int a; numero = &amp;a; El puntero numero ahora sí está en condiciones de ser usado, porque está apuntado a la dirección de la variable a, que es de tipo int, como el puntero. Otra posibilidad es hacer que un puntero apunte a NULL. El identificador NULL es una constante definida en el lenguaje que indica que un puntero no está apuntando a ninguna dirección válida y que, por lo tanto, no se debe utilizar. 1.3 Asignación de punteros Se puede asignar una variable puntero a otra siempre que ambas apunten al mismo tipo de dato. Al realizar la asignación, ambos punteros quedarán apuntando a la misma dirección de memoria. Observa este ejemplo y trata de determinar qué resultado se obtiene en la pantalla (antes de leer la solución que aparece más abajo): int a, b, c; int *p1, *p2; a = 5; p1 = &amp;a; /</em> p1 apunta a la dirección de memoria de la variable a <em>/ p2 = p1; /</em> a p2 se le asigna la misma dirección que tenga p1 <em>/ b = *p1; c = *p1 + 5; /</em> Suma 5 a lo que contenga la dirección apuntada por p1 <em>/ printf(“%i %i %i %p %p”, a, b, c, p1, p2); En la pantalla se imprimirá “5 5 10”, que es el contenido de las variables a, b y c al terminar la ejecución de este bloque de instrucciones, y la dirección a la que apuntan p1 y p2, que debe ser la misma. Observa que con printf y la cadena de formato “%p” se puede mostrar la dirección de memoria de cualquier variable. 1.4 Aritmética de punteros Con las variables de tipo puntero sólo se pueden hacer dos operaciones aritméticas: sumar o restar a un puntero un número entero, y restar dos punteros. Pero el resultado de esas operaciones no es tan trivial como puede parecer. Por ejemplo, si sumamos un 1 a un puntero cuyo valor sea 1200, el resultado puede ser 1201… ¡pero también puede ser 1202 ó 1204! Esto se debe a que el resultado depende del tipo de dato al que apunte el puntero. Sumar o restar un valor entero a un puntero Al sumar un número entero a un puntero se incrementa la dirección de memoria a la que apunta. Ese incremento depende del tamaño del tipo de dato apuntado. Si tenemos un puntero p y lo incrementamos en una cantidad entera N, la dirección a la que apuntará será: dirección_original + N * tamaño_del_tipo_de_dato Por ejemplo, imaginemos un puntero p a carácter que se incrementa en 5 unidades, así: char</em> p; p = p + 5; Supongamos que p apunta a la dirección de memoria 800. Como cada carácter ocupa 1 byte, al incrementarlo en 5 unidades, p apuntará a la dirección 805. Veamos ahora que pasa si, por ejemplo, el puntero p apunta a un número entero: int* p; p = p + 5; Si la dirección inicial de p es también la 800, al incrementarlo en 5 unidades pasará a apuntar a la dirección 810 (suponiendo que cada entero ocupe 2 bytes). Todo esto también explica qué ocurre cuando se resta un número entero de un puntero, sólo que entonces las direcciones se decrementan en lugar de incrementarse. A los punteros también se les puede aplicar las operaciones de incremento (++) y decremento (–) de C, debiendo tener el programador en cuenta que, según lo dicho hasta ahora, la dirección apuntada por el puntero se incrementará o decrementará más o menos dependiendo del tipo de dato apuntado. Por ejemplo, si los datos de tipo int ocupan 2 bytes y el puntero p apunta a la dirección 800, tras la ejecución de este fragmento de código, el puntero p quedará apuntado a la dirección 802: int <em>p; p++; Resta de dos punteros La resta de punteros se usa para saber cuantos elementos del tipo de dato apuntado caben entre dos direcciones diferentes. Por ejemplo, si tenemos un vector de números reales llamado serie podemos hacer algo así: float serie[15]; int d; float *p1, *p2; p1 = &amp;tabla[4]; p2 = &amp;tabla[12]; d = p1 – p2; El puntero p1 apunta al quinto elemento del vector, y el puntero p2, al decimotercero. La restar los dos punteros obtendremos el valor 8, que es el número de elementos de tipo float que pueden almacenarse entre las direcciones p1 y p2. 1.5 Punteros y arrays Punteros y arrays de una dimensión Los punteros y los arrays tienen una relación muy estrecha, ya que el nombre de un array es en realidad un puntero al primer elemento de ese array. Si x es un array undimensional, la dirección del primer elemento puede ser expresada como &amp;x[0] o simplemente como x. La dirección del elemento i-ésimo se puede expresar como &amp;x[i] o como (x+i). (En este caso, la expresión (x+i) no es una operación aritmética convencional, sino una operación con punteros, de cuyas peculiaridades ya hemos hablado en un epígrafe anterior) Si &amp;x[i] y (x+i) representan la dirección del i-ésimo elemento de x, podemos decir que x[i] y *(x+i) representan el contenido de esa dirección, es decir, el valor del i-ésimo elemento de x. Observa que la forma x[i] es la que hemos estado utilizando hasta ahora para acceder a los elementos de un vector. Los arrays, por lo tanto, pueden utilizarse con índices o con punteros. Al programador suele resultarle mucho más cómodo utilizar la forma x[i] para acceder al elemento i-ésimo de un array. Sin embargo, hay que tener en cuenta que la forma *(x+i) es mucho más eficiente que x[i], por lo que suele preferirse cuando la velocidad del ejecución es un factor determinante. Punteros y arrays multidimensionales Un array multidimensional es en realidad una colección de varios arrays unidimensionales (vectores). Por tanto, se puede definir un array multidimensional como un puntero a un grupo contiguo de arrays unidimensionales. El caso más simple de array de varias dimensiones es el bidimiensional. La declaración de un array bidimensional la hemos escrito hasta ahora como: tipo_dato variable [expresión1][expresión2] Pero también puede expresarse así: tipo_dato (</em>variable) [expresión2] Los paréntesis que rodean al puntero deben estar presentes para que la sintaxis sea correcta. Por ejemplo, supongamos que x es un array bidimensional de enteros con 10 filas y 20 columnas. Podemos declarar x como: int x[10][20]; Y también como: int (<em>x)[20]; En la segunda declaración, x se define como un puntero a un grupo de array unidimensionales de 20 elementos enteros. Así x apunta al primero de los arrays de 20 elementos, que es en realidad la primera fila (fila 0) del array bidimensional original. Del mismo modo (x+1) apunta al segundo array de 20 elementos, y así sucesivamente. Por ejemplo, el elemento de la columna 2 y la fila 5 puede ser accedido así: x[2][5]; Pero también así: *(</em>(x+2)+5); Esta instrucción parece muy complicada pero es fácil de desentrañar: • (x+2) es un puntero a la columna 2 • <em>(x+2) es el objeto de ese puntero y refiere a toda la columna. Como la columna 2 es un array unidimensional, *(x+2) es realmente un puntero al primer elemento de la columna 2. • (</em>(x+2)+5) es un puntero al elemento 5 de la columna 2. • El objeto de este puntero <em>(</em>(x+2)+5) refiere al elemento 5 de la columna 2. 1.6 Arrays de punteros Un array multidimensional puede ser expresado como un array de punteros en vez de como un puntero a un grupo contiguo de arrays. En términos generales un array bidimensional puede ser definido como un array unidimensional de punteros escribiendo tipo_dato *variable[expresión1] …en lugar de la definición habitual, que sería: tipo_dato variable[expresión1][expresión2] Observa que el nombre del array precedido por un asterisco no está cerrado entre paréntesis. Ese asterisco que precede al nombre de la variable establece que el array contendrá punteros. Por ejemplo, supongamos que x es un array bidimensional de 10 columnas y 25 filas. Se puede definir x como un array unidimensional de punteros escribiendo: int *x[25]; Aquí x[0] apunta al primer elemento de la primera columna, x[1] al primer elemento de la segunda columna, y así sucesivamente. Observa que el número de elementos dentro de cada fila no está especificado explícitamente. Un elemento individual del array, tal com x[2][5] puede ser accedido escribiendo: *(x[2]+5) En esta expresión, x[2] es un puntero al primer elemento en la columna 2, de modo que (x[2]+5) apunta al elemento 5 de la columna 2. El objeto de este puntero, *(x[2]+5), refiere, por tanto, a x[2][5]. Los arrays de punteros ofrecen un método conveniente para almacenar cadenas. En esta situación cada elemento del array es un puntero que indica dónde empieza cada cadena. 1.7 Paso de punteros como parámetros A menudo los punteros son pasados a las funciones como argumentos. Esto permite que datos de la porción de programa desde el que se llama a la función sean accedidos por la función, alterados dentro de ella y devueltos de forma alterada. Este uso de los punteros se conoce como paso de parámetros por variable o referencia y lo hemos estado utilizando hasta ahora sin saber muy bien lo que hacíamos. Cuando los punteros son usados como argumento de una función, es necesario tener cuidado con la declaración y uso de los parámetros dentro de la función. Los argumentos formales que sean punteros deben ir precedidos por un asterisco. Observa detenidamente el siguiente ejemplo: #include <stdio.h> void funcion1(int, int); void funcion2(int*, int*);</stdio.h></p> <p>int main(void) { int u, v; u = 1; v = 3; funcion1(u,v); printf(“Después de la llamada a funcion1: u=%d v=%d\n”, u, v); funcion2(&amp;u,&amp;v); printf(“Después de la llamada a funcion2: u=%d v=%d\n”, u, v); }</p> <p>void funcion1(int u, int v) { u=0; v=0; }</p> <p>void funcion2(int <em>pu, int *pv) { *pu=0; *pv=0; } La función de nombre funcion1 utiliza paso de parámetros por valor. Cuando es invocada, los valores de las variables u y v del programa principal son copiados en los parámetros u y v de la función. Al modificar estos parámetros dentro de la función, el valor de u y v en el programa principal no cambia. En cambio, funcion2 utiliza paso de parámetros por variable (también llamado paso de parámetros por referencia o por dirección). Lo que se pasa a la función no es el valor de las variables u y v, sino su dirección de memoria, es decir, un puntero a las celdas de memoria donde u y v están almacenadas. Dentro de la función, se utiliza el operador asterisco para acceder al contenido de pu y pv y, en consecuencia, se altera el contenido de las posiciones de memoria apuntadas por pu y pv. El resultado es que las variables u y v del programa principal quedan modificadas. Por lo tanto, la salida del programa debe ser: Después de la llamada a funcion1: u=1 v=3 Después de la llamada a funcion2: u=0 v=0 Recuerda que la función scanf() requiere que sus argumentos vayan precedidos por &amp;, mientras que printf() no lo necesitaba. Hasta ahora no podíamos comprender por qué, pero ahora podemos dar una razón: scanf() necesita que sus argumentos vayan precedidos del símbolo &amp; porque necesita las direcciones de los datos que van a ser leídos, para poder colocar en esas posiciones de memoria los datos introducidos por teclado. En cambio, printf() no necesita las direcciones, sino únicamente los valores de los datos para poder mostrarlos en la pantalla. Al estudiar los arrays y las estructuras ya vimos en detalle cómo se deben pasar como parámetros a las funciones. Recuerda que los arrays siempre se pasan por variable y no es necesario usar el símbolo &amp; en la llamada, ya que el propio nombre del array se refiere, en realidad, a la dirección del primer elemento. 1.8 Devolución de punteros Una función también puede devolver un puntero. Para hacer esto, la declaración de la función debe indicar que devolverá un puntero. Esto se realiza precediendo el nombre de la función con un asterisco. Por ejemplo: double *funcion(argumentos); Cuando esta función sea invocada, devolverá un puntero a un dato de tipo double, y por lo tanto debe ser asignada a una variable de ese tipo. Por ejemplo, así: double *pf; pf = funcion(argumentos); printf(“%lf”, *pf); 1.9 Punteros a funciones Las funciones de C, como todo el código de todos los programas que se ejecutan en el ordenador, también ocupan unas posiciones concretas de la memoria principal. Por lo tanto, es posible disponer de un puntero a una función, es decir, de una variable que contenga la dirección de memoria en la que comienza el código de una función. Aunque no vamos a usar esta avanzada posibilidad de C, se menciona aquí como información para el lector que desee ampliar sus conocimientos. La declaración de un puntero a función se realiza así: tipo_de_dato (</em>nombre_puntero) (lista_de_parámetros); No debe confundirse con la declaración de una función que devuelve un puntero: tipo_de_dato* nombre_función (lista_de_parámetros); Posteriormente, la dirección de la función puede asignarse al puntero para luego ser invocada a través del puntero, en lugar de usar una llamada convencional: nombre_puntero = nombre_función; /* Asignación al puntero de la dirección de la función <em>/ (</em>nombre_puntero)(lista_de_parámetros); /* Invocación de la función <em>/ 1.10 Punteros a punteros Un último aspecto (a la vez confuso y potente) de los punteros es la posibilidad de definir punteros que, a su vez, apunten a otros punteros. Esto no es un trabalenguas, sino que, técnicamente, se denomina indirección múltiple. La definición de un puntero a puntero se hace así: tipo_de_dato <strong>nombre_puntero; Por ejemplo, el resultado del siguiente fragmento de código en C debe ser que se imprima el número 15 en la pantalla: int n; int* p1; int</strong> p2; p1 = &amp;n; /</em> p1 contiene la dirección de n <em>/ p2 = &amp;p1; /</em> p2 contiene la dirección de p1 <em>/ **p2 = 15; printf(“%i”, n); 2 Gestión dinámica de la memoria Según hemos visto hasta ahora, la memoria reservada para cada variable se define en el momento de escribir el código del programa. Por ejemplo, si declaramos una variable de tipo int, ésta tendrá asignados 2 bytes de memoria (aunque esa cantidad puede variar dependiendo del compilador y del sistema operativo). Entonces, si declaramos un array de 100 números enteros, el array tendrá reservados 200 bytes de memoria. ¿Pero qué ocurre si no sabemos de antemano cuántos elementos puede llegar a tener el array? Por ejemplo, imaginemos un problema consistente en leer por teclado (u otro dispositivo de entrada) una cantidad indefinida de números para almacenarlos en un array y luego hacer ciertas operaciones con ellos. ¿De qué tamaño podemos definir el array? ¿De 100 elementos? ¿Y si el usuario introduce 101 elementos? Podemos pensar, entonces, que será suficiente con definir el array muy grande: de 1000 elementos, o de 5000, o de 10000… pero siempre existe la posibilidad de que el programa no funcione correctamente por desbordamiento del espacio reservado a las variables. Y, por otra parte, si definimos un array de enormes dimensiones y luego la mayoría de sus posiciones no se utilizan, estaremos desperdiciando los recursos de la máquina. Para evitar esto existe la asignación dinámica de memoria, que consiste en reservar memoria para las variables en tiempo de ejecución, es decir, mientras el programa está funcionando. Así, es posible “estirar” o “encoger” sobre la marcha el espacio reservado para el array, dependiendo de las necesidades de cada momento, y no limitarse a los 100, 1000 ó 10000 elementos que definió el programador al escribir el código. Veremos enseguida que, para manejar la memoria dinámicamente, es imprescindible el uso de punteros. De hecho, este es el mejor fruto que vamos a obtener de ellos. 2.1 Reserva dinámica de memoria. Arrays dinámicos. Utilizaremos el ejemplo de los arrays por ser la estructura de datos más simple y fácil de entender, pero lo dicho aquí es extensible a otras estructuras de datos diferentes. De hecho, dedicaremos el resto del tema a estudiar otras estructuras de datos dinámicas más complejas. Ya que un nombre de array es en realidad un puntero a su primer elemento, es posible definir un array como una variable puntero en vez de como un array convencional. Así, estas dos definiciones sirven para un vector de números enteros: int vector1[100]; int</em> vector2; El vector1 se define del modo convencional de un array. Esto produce la reserva de un bloque fijo de memoria al empezar la ejecución del programa lo suficientemente grande como para almacenar 100 números enteros. El vector2 se define como puntero a entero. En este caso, no se reserva ninguna cantidad de memoria para almacenar los números enteros. Si intentamos acceder a los elementos de los vectores obtendremos resultados diferentes: vector1[5] = 83; vector2[5] = 27; /* Esto es un error */ La primera asignación funcionará correctamente, ya que el quinto elemento del vector1 tiene un espacio de memoria asignado. La segunda asignación producirá un efecto impredecible, ya que vector2 no tiene ningún espacio de memoria asignado y, por lo tanto, el dato 27 se escribirá en una posición de memoria correspondiente a otro dato u otro programa. La consecuencia puede llegar a ser bastante desagradable. Se necesita, pues, reservar un fragmento de memoria antes de que los elementos del array sean procesados. Tales tipos de reserva se realizan mediante la función malloc() o alguna de sus variedades. Observa bien su uso en este ejemplo: int *x; x = (int *) malloc (100 * sizeof(int)); La función malloc() reserva un especio de memoria consistente en 100 veces el tamaño de un número entero. Fíjate bien en el uso del sizeof(int): se trata de un operador unario que devuelve el tamaño de un tipo de dato cualquiera, tanto simple como complejo. Suponiendo que sizeof(int) fuera 2 (es decir, que cada número de tipo int ocupase 2 bytes), lo que se le está pidiendo a malloc() es que reserve 100 * 2 bytes, es decir, 200 bytes de memoria. Además, es necesario usar el molde (int *), ya que malloc() devuelve un puntero sin tipo (es decir, un puntero a void), así que hay que convertirlo a puntero a entero antes de asignarlo a la variable x, que efectivamente es un puntero a entero. De esta manera, la variable vector2 pasa a ser lo que podemos denominar un array dinámico, en el sentido de que se comporta como un array y puede usarse como tal, pero su tamaño ha sido definido durante la ejecución del programa (más adelante, en el mismo programa, podemos redefinir el tamaño del array para acortarlo o alargarlo) Si la función malloc() falla devolverá un puntero a NULL. Utilizar un puntero a NULL es la forma más segura de estrellar el programa, así que siempre debemos comprobar que el puntero devuelto es correcto. Una vez hecho esto, podemos utilizar x con toda tranquilidad como si fuera un array de 100 números enteros. Por ejemplo: int *x, i; x = (int *) malloc (100 * sizeof(int)); if (x == NULL) printf(“Error en la asignación de memoria”); else { printf(“Se ha reservado con éxito espacio para 100 números”); for (i=0; i&lt;100; i++) { printf(“Introduzca un número:”); scanf(“%i”, &amp;x[i]); } } 2.2 Liberación de memoria El programador debe tener dos precauciones básicas a la hora de manejar la memoria dinámicamente: • Asignar memoria a un puntero antes de usarlo con malloc() u otra función similar • Liberar la memoria asignada, cuando ya no va a usarse más, con free() u otra función similar. Si no se libera la memoria asignada a un puntero, teóricamente no ocurre nada grave, salvo que podemos terminar por agotar la memoria disponible si reservamos continuamente y nunca liberamos. Es, en cualquier caso, una costumbre muy saludable. Para liberar la memoria reservada previamente con malloc() u otra función de su misma familia, se utiliza la función free(). Observa su uso en este ejemplo: int *x, i; x = (int *) malloc (100 * sizeof(int)); … instrucciones de manipulación de x … free(x); Toda la memoria reservada con malloc() quedará liberada después de hacer free() y se podrá utilizar para guardar otros datos o programas. El puntero x quedará apuntado a NULL y no debe ser utilizado hasta que se le asigne alguna otra dirección válida. 2.3 Funciones básicas para la gestión dinámica de la memoria Además de malloc() y free() existen otras funciones similares pero con pequeñas diferencias. A continuación resumimos las más usuales y mostramos un ejemplo de su uso. Pero antes haremos una advertencia: todas las funciones de reserva de memoria devuelven un puntero a NULL si no tienen éxito. Por lo tanto, deben ir seguidas de un condicional que compruebe si el puntero apunta a NULL antes de utilizarlo: no nos cansaremos de repetir que utilizar un puntero a NULL es una manera segura de estrellar el programa.</p> <p>calloc() Reserva un bloque de memoria para almacenar num elementos de tam bytes y devuelve un puntero void al comienzo del bloque. La sintaxis es: void* calloc(num, tam); El siguiente ejemplo reserva espacio para 35 números enteros: int* p; p = (int<em>) calloc(35, sizeof(int)); free() Libera el bloque de memoria apuntado por un puntero y que previamente había sido reservado. free(puntero); malloc() Reserva un bloque de memoria de tam bytes y devuelve un puntero void al comienzo del mismo, según esta sintaxis: void</em> malloc(tam); Por ejemplo, para reservar espacio para una cadena de 100 caracteres: char* texto; texto = (char<em>) malloc(100 * sizeof(char)); realloc() Cambia el tamaño de un bloque de memoria apuntado por puntero. Dicho bloque ha debido ser previamente asignado con malloc() u otra función similar. El nuevo tamaño será de tam bytes. Devuelve un puntero void al comienzo del bloque, y la sintaxis es: void</em> realloc(puntero, tam); En el siguiente ejemplo, se reserva espacio para 100 caracteres, pero luego se modifica el tamaño del bloque para dar cabida hasta 500 caracteres: char* texto; texto = (char<em>) malloc(100 * sizeof(char)); /</em> Aquí irían las instrucciones que utilicen el puntero texto con un tamaño de 100 caracteres <em>/ texto = (char</em>) realloc(texto, 500 * sizeof(char)); /* A partir de aquí, el mismo puntero texto puede usarse para manejar hasta 500 caracteres */ 3 Introducción a las estructuras dinámicas Las estructuras estáticas tienen una importante limitación: no pueden cambiar de tamaño durante la ejecución. Por ejemplo, los arrays están compuestos por un determinado número de elementos y ese número se decide durante la codificación del programa, no pudiendo cambiarse en tiempo de ejecución. En muchas ocasiones se necesitan estructuras que puedan cambiar de tamaño durante la ejecución del programa. Esas son las estructuras dinámicas. C no dispone de estructuras dinámicas predefinidas, por lo que es tarea del programador construirlas basándose en estructuras estáticas y gestión dinámica de memoria. Además, habrá que programar una colección de funciones que manipulen esas estructuras. Ya que el programador se toma la molestia de implementar las estructuras y sus funciones, lo más habitual es que se asegure de que todo sea reutilizable, de manera que pueda usarlo en otros programas. A lo largo del tema seguiremos este principio. Como veremos, para desarrollar las estructuras dinámicas es imprescindible usar punteros y asignación dinámica de memoria, así que deberías tener bastante claros los dos primeros epígrafes de este tema antes de continuar. Nodos El fundamento de las estructuras de datos dinámicas es una estructura estática a la que llamaremos nodo o elemento. Éste incluye los datos con los que trabajará nuestro programa y uno o más punteros al mismo tipo nodo. Por ejemplo, si la estructura dinámica va a guardar números enteros, el nodo puede tener esta forma: struct s_nodo { int dato; struct nodo *otro_nodo; }; El campo otro_nodo apuntará a otro objeto del tipo nodo. De este modo, cada nodo puede usarse como un ladrillo para construir estructuras más complejas, y cada uno mantendrá una relación con otro u otros nodos (esto dependerá del tipo de estructura dinámica, como veremos). A lo largo del tema usaremos una representación gráfica para mostrar las estructuras de datos dinámicas. El nodo anterior se representará así:</p> <p>En el rectángulo de la izquierda se representa el dato contenido en el nodo (en nuestro ejemplo, un número entero). En el rectángulo de la derecha se representa el puntero, que apuntará a otro nodo. Tipos de estructuras dinámicas Dependiendo del número de punteros que haya en cada nodo y de las relaciones entre ellos, podemos distinguir varios tipos de estructuras dinámicas. A lo largo del tema veremos sólo las estructuras básicas, pero aquí las vamos a enumerar todas: • Listas abiertas: cada elemento sólo dispone de un puntero, que apuntará al siguiente elemento de la lista. • Pilas: son un tipo especial de lista, conocidas como listas LIFO (Last In, First Out: el último en entrar es el primero en salir). Los elementos se “amontonan” o apilan, de modo que sólo el elemento que está encima de la pila puede ser leído, y sólo pueden añadirse elementos encima de la pila. • Colas: otro tipo de listas, conocidas como listas FIFO (First In, First Out: El primero en entrar es el primero en salir). Los elementos se almacenan en una lista, pero sólo pueden añadirse por un extremo y leerse por el otro. • Listas circulares: o listas cerradas, son parecidas a las listas abiertas, pero el último elemento apunta al primero. De hecho, en las listas circulares no puede hablarse de “primero” ni de “último”. • Listas doblemente enlazadas: cada elemento dispone de dos punteros, uno apunta al siguiente elemento y el otro al elemento anterior. Al contrario que las listas abiertas, estas listas pueden recorrerse en los dos sentidos. • Árboles: cada elemento dispone de dos o más punteros, pero las referencias nunca son a elementos anteriores, de modo que la estructura se ramifica y crece de modo jerárquico. • Árboles binarios: son árboles donde cada nodo sólo puede apuntar a dos nodos. • Árboles binarios de búsqueda (ABB): son árboles binarios ordenados, por lo que la búsqueda de información en ellos es menos costosa. Desde cada nodo todos los nodos de una rama serán mayores, según la norma que se haya seguido para ordenar el árbol, y los de la otra rama serán menores. • Árboles AVL: son también árboles de búsqueda, pero su estructura está más optimizada para reducir los tiempos de búsqueda. • Árboles B: son otro tipo de árboles de búsqueda más complejos y optimizados que los anteriores. • Tablas HASH: son estructuras auxiliares para ordenar listas de gran tamaño. • Grafos: son árboles no jerarquizados, es decir, en los que cada nodo puede apuntar a nodos de nivel inferior o de nivel superior. De hecho, no se puede hablar de nivel “superior” e “inferior”. Son las estructuras dinámicas más complejas. Para terminar con esta introducción, señalar que pueden existir estructuras dinámicas en las que haya nodos de distinto tipo, aunque nosotros no las vamos a estudiar.</p> <h2 id="95-un-ejemplo-completo-las-tres-en-raya"> <a href="#95-un-ejemplo-completo-las-tres-en-raya" class="anchor-heading" aria-labelledby="95-un-ejemplo-completo-las-tres-en-raya"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.5. Un ejemplo completo: las tres en raya </h2> <p>Llegó la hora de poner manos a la obra.</p> <p>Si hay una sección de este capítulo que tienes que leer con atención, es esta. Así que es un mal momento para tener prisa.</p> <p>Vamos a escribir un <strong>programa completo en C</strong>. Te puede servir de plantilla para desarrollar tus propios programas a partir de este código fuente.</p> <p>El programa en cuestión será una versión del juego de <strong>las tres en raya</strong> que encontrarás resuelta en pseudocódigo el tema de introducción a la programación. No dudes en repasar aquel ejercicio resuelto para ver el pseudocódigo, puesto que nuestro programa será una traducción literal de ese pseudocódigo a C.</p> <p>Aquí tienes el código fuente completo. Estúdialo con atención y asegúrate de entenderlo todo (o un gran porcentaje) antes de continuar. Ah, y no dejes de compararlo línea a línea con el mismo código en pseudocódigo.</p> <h3 id="951-el-código-fuente"> <a href="#951-el-código-fuente" class="anchor-heading" aria-labelledby="951-el-código-fuente"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.5.1. El código fuente </h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="c1">//-------------------------</span>
<span class="c1">//   ALGORITMO PRINCIPAL</span>
<span class="c1">//-------------------------</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
   <span class="kt">char</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
   <span class="kt">int</span> <span class="n">ganador</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>        <span class="c1">// 0 = ninguno, 1 = humano, 2 = ordenador</span>
   <span class="kt">int</span> <span class="n">tablas</span><span class="p">;</span>             <span class="c1">// 0 = no hay tablas, 1 = sí hay tablas</span>

   <span class="n">inicializar</span><span class="p">(</span><span class="n">tablero</span><span class="p">);</span>   <span class="c1">// Esto es un subalgoritmo. Está escrito más abajo</span>
   <span class="k">do</span> <span class="p">{</span>
      <span class="n">mostrar</span><span class="p">(</span><span class="n">tablero</span><span class="p">);</span>
      <span class="n">colocar_pieza_humano</span><span class="p">(</span><span class="n">tablero</span><span class="p">);</span>
      <span class="n">ganador</span> <span class="o">=</span> <span class="n">comprobar_ganador</span><span class="p">(</span><span class="n">tablero</span><span class="p">);</span>
      <span class="n">tablas</span> <span class="o">=</span> <span class="n">comprobar_tablas</span><span class="p">(</span><span class="n">tablero</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">ganador</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tablas</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
         <span class="n">colocar_pieza_ordenador</span><span class="p">(</span><span class="n">tablero</span><span class="p">);</span>
         <span class="n">ganador</span> <span class="o">=</span> <span class="n">comprobar_ganador</span><span class="p">(</span><span class="n">tablero</span><span class="p">);</span>
         <span class="n">tablas</span> <span class="o">=</span> <span class="n">comprobar_tablas</span><span class="p">(</span><span class="n">tablero</span><span class="p">);</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="k">while</span> <span class="p">((</span><span class="n">ganador</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tablas</span> <span class="o">==</span> <span class="mi">0</span><span class="p">));</span>
	
   <span class="n">mostrar</span><span class="p">(</span><span class="n">tablero</span><span class="p">);</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">ganador</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"EL JUEGO HA TERMINADO EN TABLAS</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
   <span class="p">}</span>
   <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ganador</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"EL JUEGO HA TERMINADO Y HAS GANADO TÚ</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
   <span class="p">}</span>
   <span class="k">else</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"EL JUEGO HA TERMINADO Y HE GANADO YO</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// --------------------------------------------</span>
<span class="c1">// Inicializa el tablero con espacios en blanco</span>
<span class="c1">// --------------------------------------------</span>
<span class="kt">void</span> <span class="nf">inicializar</span><span class="p">(</span><span class="kt">char</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
   <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Como tablero es un array, se pasa por referencia y los cambios que</span>
      <span class="c1">// hagamos aquí se reflejarán en el algoritmo principal</span>
      <span class="n">tablero</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">' '</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// --------------------------------------------</span>
<span class="c1">// Muestra el estado actual del tablero</span>
<span class="c1">// --------------------------------------------</span>
<span class="kt">void</span> <span class="nf">mostrar</span><span class="p">(</span><span class="kt">char</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span> <span class="p">{</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">"ESTADO ACTUAL DEL TABLERO</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">"+-+-+-+</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">"|%c|%c|%c|</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">"+-+-+-+</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">"|%c|%c|%c|</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">"+-+-+-+</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">"|%c|%c|%c|</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">9</span><span class="p">]);</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">"+-+-+-+</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ---------------------------------------------------</span>
<span class="c1">// Coloca una pieza del jugador humano en el tablero</span>
<span class="c1">// ---------------------------------------------------</span>
<span class="kt">void</span> <span class="nf">colocar_pieza_humano</span><span class="p">(</span><span class="kt">char</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">casilla</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">casilla_correcta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="k">do</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"¿En qué casilla quieres poner una pieza? (1-9)"</span><span class="p">);</span>
      <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">casilla</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">tablero</span><span class="p">[</span><span class="n">casilla</span><span class="p">]</span> <span class="o">==</span> <span class="sc">' '</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">tablero</span><span class="p">[</span><span class="n">casilla</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'X'</span><span class="p">;</span>
         <span class="n">casilla_correcta</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
         <span class="n">printf</span><span class="p">(</span><span class="s">"Error: Esa casilla ya está ocupada</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="k">while</span> <span class="p">(</span><span class="n">casilla_correcta</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ---------------------------------------------------</span>
<span class="c1">// Coloca una pieza del ordenador en el tablero</span>
<span class="c1">// ---------------------------------------------------</span>
<span class="kt">void</span> <span class="nf">colocar_pieza_ordenador</span><span class="p">(</span><span class="kt">char</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">casilla</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">casilla_correcta</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="n">srand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>
   <span class="k">do</span> <span class="p">{</span>
      <span class="n">casilla</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"Voy a colocar mi pieza en la casilla "</span><span class="p">,</span> <span class="n">casilla</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">tablero</span><span class="p">[</span><span class="n">casilla</span><span class="p">]</span> <span class="o">==</span> <span class="sc">' '</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">tablero</span><span class="p">[</span><span class="n">casilla</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'O'</span><span class="p">;</span>
         <span class="n">casilla_correcta</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
         <span class="n">printf</span><span class="p">(</span><span class="s">"¡Está ocupada! Voy a elegir otra"</span><span class="p">);</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="k">while</span> <span class="p">(</span><span class="n">casilla_correcta</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ---------------------------------------------------</span>
<span class="c1">// Comprueba si hay un ganador según el estado del </span>
<span class="c1">// tablero. Devuelve "Ninguno", "Humano" u "Ordenador"</span>
<span class="c1">// ---------------------------------------------------</span>
<span class="kt">int</span> <span class="nf">comprobar_ganador</span><span class="p">(</span><span class="kt">char</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">ganador</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="c1">// Comprobamos primera fila</span>
   <span class="k">if</span> <span class="p">((</span><span class="n">tablero</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tablero</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">tablero</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'X'</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">ganador</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">tablero</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'O'</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">ganador</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="c1">// Comprobamos segunda fila</span>
   <span class="k">if</span> <span class="p">((</span><span class="n">tablero</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tablero</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">6</span><span class="p">]))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">tablero</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'X'</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">ganador</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">tablero</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'O'</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">ganador</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="c1">// Comprobamos tercera fila</span>
   <span class="k">if</span> <span class="p">((</span><span class="n">tablero</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">==</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tablero</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">==</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">9</span><span class="p">]))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">tablero</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'X'</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">ganador</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">tablero</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'O'</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">ganador</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="c1">// Comprobamos primera columna</span>
   <span class="k">if</span> <span class="p">((</span><span class="n">tablero</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tablero</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">7</span><span class="p">]))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">tablero</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'X'</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">ganador</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">tablero</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'O'</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">ganador</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="c1">// Comprobamos segunda columna</span>
   <span class="k">if</span> <span class="p">((</span><span class="n">tablero</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tablero</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">8</span><span class="p">]))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">tablero</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'X'</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">ganador</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">tablero</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'O'</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">ganador</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="c1">// Comprobamos tercera columna</span>
   <span class="k">if</span> <span class="p">((</span><span class="n">tablero</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tablero</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">9</span><span class="p">]))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">tablero</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'X'</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">ganador</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">tablero</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'O'</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">ganador</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="c1">// Comprobamos una diagonal</span>
   <span class="k">if</span> <span class="p">((</span><span class="n">tablero</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tablero</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">9</span><span class="p">]))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">tablero</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'X'</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">ganador</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">tablero</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'O'</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">ganador</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="c1">// Comprobamos la otra diagonal</span>
   <span class="k">if</span> <span class="p">((</span><span class="n">tablero</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tablero</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">7</span><span class="p">]))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">tablero</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'X'</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">ganador</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">tablero</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'O'</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">ganador</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="n">ganador</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// -------------------------------------------</span>
<span class="c1">// Comprueba si hay una situación de tablas</span>
<span class="c1">// según el estado actual del tablero. Devuelve</span>
<span class="c1">// verdadero si hay tablas o falso en otro caso.</span>
<span class="c1">// -------------------------------------------</span>
<span class="kt">int</span> <span class="nf">comprobar_tablas</span><span class="p">(</span><span class="kt">char</span> <span class="n">tablero</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">tablas</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">contador</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">tablero</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span>  <span class="sc">' '</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">contador</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>
   <span class="p">}</span>
	
	<span class="c1">// Si todas las casillas están ya ocupadas y no hay ganador,</span>
	<span class="c1">// entonces estamos en tablas.</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">contador</span> <span class="o">==</span> <span class="mi">9</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">tablas</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="k">else</span> <span class="p">{</span>
      <span class="n">tablas</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="n">tablas</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="952-cómo-ejecutar-y-depurar-este-programa"> <a href="#952-cómo-ejecutar-y-depurar-este-programa" class="anchor-heading" aria-labelledby="952-cómo-ejecutar-y-depurar-este-programa"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.5.2. ¿Cómo ejecutar y depurar este programa? </h3> <p>Guarda el programa anterior en un archivo de texto con extensión .c (por ejemplo, <em>3enraya.c</em>).</p> <p>Si estás trabajando con Visual Studio Code con las extensiones recomendadas para C/C++, puedes ejecutar tu programa directamente desde ahí. Basta con que pulses el botón “Play” de la esquina superior derecha. Se abrirá una consola en la parte de abajo donde tu programa se ejecutará.</p> <p>XXX captura imagen Play</p> <p>XXX captura imagen de 3 en raya ejecutándose</p> <h4 id="socorro-el-programa-no-funciona"> <a href="#socorro-el-programa-no-funciona" class="anchor-heading" aria-labelledby="socorro-el-programa-no-funciona"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> ¡Socorro! El programa no funciona </h4> <p>¿El resultado no es el esperado? Es lo habitual. Habrá algún error en el código y te tocará depurarlo.</p> <p>En la ventana inferior de Visual Studio Code verás varias pestañas.</p> <ul> <li>En la pestaña <strong>Terminal</strong> verás el resultado de la ejecución de tu programa.</li> <li>En la pestaña <strong>Problems</strong> verás la lista de errores que el compilador ha encontrado en tu programa. En tal caso, en el <em>Terminal</em> solo verás un lenguaje de tipo “La compilación ha terminado con errores”.</li> </ul> <p>Los mensajes pueden estar en español o en inglés, dependiendo del compilador, pero ¿qué esperabas? Si quieres aprender a programar, tienes que acostumbrarte a manejar el inglés técnico.</p> <p>El mensaje de error te dará información sobre lo que hay de malo en tu código y te dirá en qué línea, aproximadamente, está el error.</p> <p>Cuando lo hayas localizado, <strong>regresa a tu editor de texto, haz los cambios necesarios, guarda las modificaciones y vuelve a compilar y ejecutar el programa</strong> (pulsando de nuevo el botón “Play”).</p> <p>Y así hasta que funcione.</p> <p>¡Mucha paciencia y sangre fría! Recuerda siempre que la mayor parte del tiempo de programación se va en depurar programas, no en escribirlos.</p> <h2 id="96-ejercicios-propuestos"> <a href="#96-ejercicios-propuestos" class="anchor-heading" aria-labelledby="96-ejercicios-propuestos"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.6. Ejercicios propuestos </h2> <h4 id="ejercicio-1-hola-mundo"> <a href="#ejercicio-1-hola-mundo" class="anchor-heading" aria-labelledby="ejercicio-1-hola-mundo"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ejercicio 1. Hola mundo </h4> <p>En este ejercicio, vamos a preparar nuestro entorno de trabajo.</p> <ol> <li> <p>Instala Visual Studio Code. Puedes descargarlo de <a href="https://code.visualstudio.com/download">https://code.visualstudio.com/download</a> o bien instalarlo desde la tienda de aplicaciones de tu sistema operativo.</p> </li> <li> <p>Abre Visual Studio Code y haz clic en el botón de extensiones (en el panel izquierdo). Busca una extensión llamada “C/C++ IntelliSense” e instálala.</p> </li> <li> <p>Escribe un programa que salude con un “Hola, mundo”. Encontrarás el código más abajo. Este programa es un clásico en el mundillo de la programación; siempre se usa para comprobar si un nuevo entorno de desarrollo está funcionando bien.</p> </li> <li> <p>Ejecútalo y asegúrate de que el resultado es el esperado. Si algo falla, llama al profesor y no pases al siguiente ejercicio hasta dejar tu Visual Studio Code en perfecto estado de funcionamiento.</p> </li> </ol> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">"Hola, mundo</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="ejercicio-2-convertir-de-euros-a-dólares"> <a href="#ejercicio-2-convertir-de-euros-a-dólares" class="anchor-heading" aria-labelledby="ejercicio-2-convertir-de-euros-a-dólares"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ejercicio 2. Convertir de euros a dólares </h4> <p>Vamos a empezar por algo sencillito.</p> <p>Escribe un programa en C capaz de leer un número real y un tipo de moneda, que puede ser “euro” o “dólar”, y que convierta al tipo de moneda indicado, suponiendo que está expresada en la otra.</p> <p>Por ejemplo, si la cantidad es 15 y la moneda es “dólar”, se supondrá que se trata de 15 € y que hay que convertirlos a dólares.</p> <p>Utiliza el tipo de cambio que esté vigente el día en el que escribas el programa.&lt;/div&gt;</p> <h4 id="ejercicio-3-tabla-de-multiplicar"> <a href="#ejercicio-3-tabla-de-multiplicar" class="anchor-heading" aria-labelledby="ejercicio-3-tabla-de-multiplicar"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ejercicio 3. Tabla de multiplicar </h4> <p>Escribe un programa en C que pida un número y muestre la tabla de multiplicar de ese número.</p> <p>Por ejemplo, si el usuario del programa escribe el número 3, la salida del programa debe ser:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3 x 1 = 3
3 x 2 = 6
3 x 3 = 9
3 x 4 = 12
3 x 5 = 15
3 x 6 = 18
3 x 7 = 21
3 x 8 = 24
3 x 9 = 27
3 x 10 = 30
</code></pre></div></div> <h4 id="ejercicio-4-juego-del-número-secreto"> <a href="#ejercicio-4-juego-del-número-secreto" class="anchor-heading" aria-labelledby="ejercicio-4-juego-del-número-secreto"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ejercicio 4. Juego del número secreto </h4> <p>Ahora algo solo un poquito más complicado: una versión en C del clásico juego del número secreto.</p> <p>Se trata de un juego en el que el ordenador “piensa” un número al azar entre 1 y 100 y el jugador tiene que adivinarlo.</p> <p>Cada vez que el jugador escribe un número, el programa le dice: “Mi número secreto es mayor” o “Mi número secreto es menor”.</p> <p>Cuando el jugador por fin acierta, el ordenador le dice: “Enhorabuena, has acertado”, y añade el número de intentos que ha necesitado para acertar el número secreto.</p> <h4 id="ejercicio-5-juego-de-memoria"> <a href="#ejercicio-5-juego-de-memoria" class="anchor-heading" aria-labelledby="ejercicio-5-juego-de-memoria"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ejercicio 5. Juego de memoria </h4> <p>Ahora empieza la diversión.</p> <p>Vamos a escribir en C un juego que podemos bautizar como “Juego de memoria”. Será un juego en modo texto (bastante feo, por lo tanto), pero totalmente jugable y que nos servirá para afianzar todos los conocimientos adquiridos hasta ahora.</p> <p>Reglas del juego:</p> <ul> <li>El juego comenzará preguntando el nivel de dificultad, que puede ser fácil, medio o difícil.</li> <li>El ordenador elegirá al azar una serie de números. La serie consistirá al principio en un solo número. Luego serán dos números, luego tres, luego cuatro… y así hasta diez. Los números de la serie solo pueden ser tres: 1, 2 y 3.</li> <li>El ordenador mostrará su serie de números durante un tiempo en la pantalla. Ese tiempo será tanto menor cuanto más alto sea el nivel de dificultad.</li> <li>Después, la serie se borrará y el jugador debe demostrar su memoria y sus reflejos repitiéndola.</li> <li>Si el jugador acierta en todos los números de la serie, el ordenador pasará a su siguiente serie (que tendrá un número más). Si el jugador falla, el juego termina.</li> <li>Si el jugador es capaz de repetir con éxito todas las series (desde la que solo tiene un número hasta la que tiene 10), el jugador gana.</li> </ul> <h4 id="ejercicio-6-pelota-que-rebota"> <a href="#ejercicio-6-pelota-que-rebota" class="anchor-heading" aria-labelledby="ejercicio-6-pelota-que-rebota"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ejercicio 6. Pelota que rebota </h4> <p>Escribe un programa en C que muestre una pelota moviéndose por la pantalla y rebotando en sus bordes. La pelota se puede simular con el carácter “O”, escribiéndolo en diferentes celdas de la pantalla cada vez.</p> <p>(Para este ejercicio necesitarás usar la librería <em>ncurses</em>)</p> <p>Puedes realizar el programa en tres fases sucesivas. Para aprobar la actividad debes completar al menos la primera fase. Para sacar un 10 tienes que terminar la tercera fase.</p> <ul> <li>FASE 1: la “pelota” se mueve y rebota por la pantalla, pero va dejando un “rastro” de Oes.</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>O           O
 O         O O
  O       O   O
   O     O
    O   O
     O O
      O
</code></pre></div></div> <ul> <li>FASE 2: la “pelota” se mueve por la pantalla sin dejar rastro. Es decir, cada vez que se escribe la “O” en una nueva posición, se borra de la posición que ocupaba anteriormente. El resultado debe dar sensación de movimiento sin parpadeos.</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>           O


</code></pre></div></div> <p>FASE 3: la “pelota” se mueve por la pantalla dejando una “estela” de cuatro o cinco “Oes” (u otros caracteres, como en la figura) a su paso.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      .
       .
        o
         o
          O


</code></pre></div></div> <h4 id="ejercicio-7-juego-de-automovilismo"> <a href="#ejercicio-7-juego-de-automovilismo" class="anchor-heading" aria-labelledby="ejercicio-7-juego-de-automovilismo"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ejercicio 7. Juego de automovilismo </h4> <p>Escribe un programa que simule un sencillo juego de automovilismo. La pantalla del juego debe tener un aspecto parecido a este:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                              |         |
                              |         |
                              |         |
                              |         |
                               |         |
                               |         |
                                |         |
                                 |         |
                                 |         |
                                 |         |
                                |         |
                                |    H    |
</code></pre></div></div> <p>El jugador (cuyo vehículo representaremos con una H) puede mover su coche hacia la izquierda y hacia la derecha. Su objetivo es no salirse de la carretera, que tiene los límites marcados por un carácter “|” a cada lado. Si se sale, pierde una vida. Si pierde tres vidas, la partida termina y el programa debe mostrar el tiempo que el conductor ha conseguido aguantar sin perder sus vidas.</p> <p>La carretera se va desplazando de abajo a arriba, aprovechándose del scroll propio de la pantalla de texto. La carretera no debe ser recta, sino que tendrá irregularidades, como las mostradas en la figura, generadas al azar.</p> <h2 id="97-ejercicios-resueltos"> <a href="#97-ejercicios-resueltos" class="anchor-heading" aria-labelledby="97-ejercicios-resueltos"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 9.7. Ejercicios resueltos </h2> <p>Aquí iremos poniendo los ejercicios que resolvamos en clase.</p> <hr> <h2 class="text-delta">Table of contents</h2> <ul> </ul> </div> </div> <div class="search-overlay"></div> </div> </body> </html>
