<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <title>6. Orientación a objetos - PROG Y 3D</title> <link rel="shortcut icon" href="/docs/prog-y-3d/_site/favicon.ico" type="image/x-icon"> <link rel="stylesheet" href="/docs/prog-y-3d/_site/assets/css/just-the-docs-default.css"> <script type="text/javascript" src="/docs/prog-y-3d/_site/assets/js/vendor/lunr.min.js"></script> <script type="text/javascript" src="/docs/prog-y-3d/_site/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.7.1 --> <title>Orientación a objetos | PROG Y 3D</title> <meta name="generator" content="Jekyll v4.2.0" /> <meta property="og:title" content="Orientación a objetos" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Apuntes de la asignatura “Introducción a la programación y al diseño 3D”, optativa de 2º curso de bachillerato ofertada por el IES Celia Viñas de Almería (España)" /> <meta property="og:description" content="Apuntes de la asignatura “Introducción a la programación y al diseño 3D”, optativa de 2º curso de bachillerato ofertada por el IES Celia Viñas de Almería (España)" /> <link rel="canonical" href="/docs/prog-y-3d/_site/orientacion-a-objetos/" /> <meta property="og:url" content="/docs/prog-y-3d/_site/orientacion-a-objetos/" /> <meta property="og:site_name" content="PROG Y 3D" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Orientación a objetos" /> <script type="application/ld+json"> {"@type":"WebPage","url":"/docs/prog-y-3d/_site/orientacion-a-objetos/","headline":"Orientación a objetos","description":"Apuntes de la asignatura “Introducción a la programación y al diseño 3D”, optativa de 2º curso de bachillerato ofertada por el IES Celia Viñas de Almería (España)","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> </head> <body> <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header"> <a href="/docs/prog-y-3d/_site/" class="site-title lh-tight"> PROG Y 3D </a> <a href="#" id="menu-button" class="site-button"> <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg> </a> </div> <nav role="navigation" aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item active"><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/" class="nav-list-link">Introd. a la prog. y al diseño 3D</a><ul class="nav-list "><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/presentacion/" class="nav-list-link">0. Presentación de la asignatura</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/pensamiento-computacional/" class="nav-list-link">1. Pensamiento computacional</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/representacion-de-la-informacion/" class="nav-list-link">2. Representación de la información</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/introduccion-a-la-programacion/" class="nav-list-link">3. Introducción a la programación</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/estructuras-de-datos/" class="nav-list-link">4. Estructuras de datos. Subalgoritmos</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/javascript/" class="nav-list-link">5. Lenguaje Javascript</a><ul class="nav-list"></ul></li><li class="nav-list-item active"><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/orientacion-a-objetos/" class="nav-list-link active">6. Orientación a objetos</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/entornos-integrados-de-desarrollo/" class="nav-list-link">7. Entornos integrados de desarrollo</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/bases-de-datos/" class="nav-list-link">8. Bases de datos</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/lenguaje-sql/" class="nav-list-link">9. El lenguaje SQL</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/seguridad-y-privacidad/" class="nav-list-link">10. Seguridad y privacidad</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/tecnologias-de-impresion-3d/" class="nav-list-link">11. Tecnologías de impresión 3D</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/modelado-e-impresion-3d/" class="nav-list-link">12. Modelado e impresión 3D</a><ul class="nav-list"></ul></li></ul></li><li class="nav-list-item"><a href="/docs/prog-y-3d/_site/about/" class="nav-list-link">About</a></li></ul> </nav> <footer class="site-footer"> This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll. </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search PROG Y 3D" aria-label="Search PROG Y 3D" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> </div> <div id="main-content-wrap" class="main-content-wrap"> <nav aria-label="Breadcrumb" class="breadcrumb-nav"> <ol class="breadcrumb-nav-list"> <li class="breadcrumb-nav-list-item"><a href="/docs/prog-y-3d/_site/">Introd. a la prog. y al diseño 3D</a></li> <li class="breadcrumb-nav-list-item"><span>6. Orientación a objetos</span></li> </ol> </nav> <div id="main-content" class="main-content" role="main"> <h1 class="no_toc" id="6-orientación-a-objetos"> <a href="#6-orientación-a-objetos" class="anchor-heading" aria-labelledby="6-orientación-a-objetos"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 6. Orientación a objetos </h1> <ul id="markdown-toc"> <li><a href="#33--variables-asignación-y-ámbito" id="markdown-toc-33--variables-asignación-y-ámbito">3.3 Variables: asignación y ámbito</a></li> <li><a href="#35--conversiones-de-tipo" id="markdown-toc-35--conversiones-de-tipo">3.5 Conversiones de tipo</a></li> <li><a href="#36--operadores-y-expresiones" id="markdown-toc-36--operadores-y-expresiones">3.6 Operadores y expresiones</a></li> <li><a href="#4-estructuras-de-control-en-javascript" id="markdown-toc-4-estructuras-de-control-en-javascript">4. Estructuras de control en Javascript</a></li> </ul> <p>Orientación a objetos. Clases, objetos y constructores. Herencia. Subclases y superclases. Polimorfismo y sobrecarga. Encapsulamiento y ocultación.</p><hr /> <h3 id="33--variables-asignación-y-ámbito"> <a href="#33--variables-asignación-y-ámbito" class="anchor-heading" aria-labelledby="33--variables-asignación-y-ámbito"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 3.3 Variables: asignación y ámbito </h3> <p>La <strong>asignación</strong> de valores a variables en Javascript es fácil de explicar: se hace con el <strong>símbolo igual (=)</strong>, no con el símbolo &lt;= que usábamos en pseudocódigo:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var a;      // Declaración de la variable a
var b = 1;
a = b + 5;  // Asignación de valor a la variable b
</code></pre></div></div> <p>El problema del <strong>ámbito de las variables</strong> es otra historia.</p> <p>Recuerda que el <strong>ámbito</strong> (o <strong><em>scope</em></strong>, en inglés) de una variable es el lugar del programa donde esa variable está disponible.</p> <p>Por defecto, las <strong>variables en Javascript son locales</strong>. Esta es la versión corta de la historia.</p> <p>La versión larga es que Javascript ofrece una flexibilidad un poco mareante para manejar el ámbito de las variables.</p> <p>Vamos a tratar de poner un poco de orden. Unas líneas más arriba dijimos que Javascript permite declarar las variables con <strong>var</strong> o con <strong>let</strong>, o bien no declararlas, ¿verdad?</p> <p>Pues bien: el ámbito de la variable dependerá de <em>dónde</em> declaremos la variable (si lo hacemos) y de cómo lo hagamos (con var o con let).</p> <h4 id="declarar-variables-con-var"> <a href="#declarar-variables-con-var" class="anchor-heading" aria-labelledby="declarar-variables-con-var"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Declarar variables con var </h4> <p>Las variables declaradas con <strong>var</strong> son <strong>locales a la función</strong> donde se declaran, o <strong>globales</strong> si se declaran en el exterior de cualquier función.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// Variable global</span>

<span class="kd">function</span> <span class="nx">mostrarMensaje</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>    <span class="c1">// Variable local</span>
    <span class="nb">document</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="dl">"</span><span class="s2">La variable a vale </span><span class="dl">"</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="dl">"</span><span class="s2"> y la variable b vale </span><span class="dl">"</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>En este ejemplo, la variable a es <strong>global</strong>, lo que significa que será accesible desde cualquier parte de este programa (incluyendo el interior de la función <em>mostrarMensaje()</em>).</p> <p>La variable b, en cambio, es <strong>local a la función</strong> <em>mostrarMensaje()</em>. Si tratamos de acceder a ella desde el exterior de esa función, se producirá un error de ejecución.</p> <h4 id="declarar-variables-con-let"> <a href="#declarar-variables-con-let" class="anchor-heading" aria-labelledby="declarar-variables-con-let"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Declarar variables con let </h4> <p>Las variables declaradas con <strong>let</strong> son <strong>locales al bloque</strong> donde se declaran, o <strong>globales</strong> si se declaran en el exterior de cualquier bloque.</p> <p>Un <strong>bloque</strong> es cualquier cosa encerrada entre dos llaves ({ y }). Observa el siguiente ejemplo:</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// Variable global</span>

<span class="kd">function</span> <span class="nx">mostrarMensaje</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>    <span class="c1">// Variable local a la función</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>   <span class="c1">// Variable local al bloque if</span>
        <span class="nb">document</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="dl">"</span><span class="s2">La variable a vale </span><span class="dl">"</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="dl">"</span><span class="s2">, la variable b vale </span><span class="dl">"</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="dl">"</span><span class="s2"> y la variable c vale </span><span class="dl">"</span><span class="p">,</span> <span class="nx">c</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>En este ejemplo tenemos 3 variables:</p> <ul> <li>La variable a vuelve a ser <strong>global</strong>, lo que significa que será accesible desde cualquier parte de este programa.</li> <li>La variable b es <strong>local a la función</strong>. Está disponible desde su declaración hasta la llave de cierre de la función.</li> <li>La variable c es <strong>local a su bloque</strong>. Es decir, está disponible desde su declaración hasta la llave de cierre del <em>if</em>.</li> </ul> <h4 id="no-declarar-las-variables"> <a href="#no-declarar-las-variables" class="anchor-heading" aria-labelledby="no-declarar-las-variables"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> No declarar las variables </h4> <p>Con Javascript, como ya hemos dicho, es perfectamente posible no declarar las variables y usarlas sin más.</p> <p>Sin embargo, cuando haces este tipo de cosas, dejas que sea el lenguaje de programación el que tome decisiones por ti. En este caso, que decida sobre el ámbito de la variable. Por eso mi consejo es que <em>siempre</em> declares las variables, aunque no les asignes ningún valor inicial.</p> <p>Si decides usar las variables sin declarar, tienes que saber que Javascript las considerará a todas <strong>globales</strong>, independientemente del punto del programa donde hayas usado la variable por primera vez.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// Variable global</span>

<span class="kd">function</span> <span class="nx">mostrarMensaje</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>    <span class="c1">// Variable global</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>   <span class="c1">// Variable global</span>
        <span class="nb">document</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="dl">"</span><span class="s2">La variable a vale </span><span class="dl">"</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="dl">"</span><span class="s2">, la variable b vale </span><span class="dl">"</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="dl">"</span><span class="s2"> y la variable c vale </span><span class="dl">"</span><span class="p">,</span> <span class="nx">c</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="35--conversiones-de-tipo"> <a href="#35--conversiones-de-tipo" class="anchor-heading" aria-labelledby="35--conversiones-de-tipo"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 3.5 Conversiones de tipo </h3> <p>Javascript es un lenguaje <strong>débilmente tipado</strong>, es decir, no hace comprobaciones estrictas de tipos a la hora de asignar un valor a una variable o de comparar dos expresiones.</p> <p>Por ejemplo, estas instrucciones son correctas:</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="nx">b</span> <span class="o">=</span> <span class="mf">3.8</span><span class="p">;</span>
<span class="nx">c</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
</code></pre></div></div> <p>La variable a es de tipo entero (recuerda que el tipo lo asigna automáticamente Javascript) y la variable b es de tipo real (también llamado <em>float</em> o <em>double</em>, dependiendo del número de decimales que sea capaz de almacenar). Por lo tanto, en la expresión <code class="language-plaintext highlighter-rouge">c = a + b</code> se están mezclando los tipos entero y real, algo que solo es posible en los lenguajes débilmente tipados.</p> <p>La mezcla de tipos puede ser más rocambolesca. Por ejemplo, puedes mezclar enteros y cadenas. ¿Qué resultado obtendrás de una mezcla así? Buena pregunta. ¿Por qué no haces la prueba?</p> <p>Cuando mezclas tipos, estás dejando que el lenguaje de programación decida cuál será el resultado, por lo que puedes obtener resultados imprevisibles. Es mejor que tú controles qué conversiones de tipo se hacen:</p> <ul> <li> <p><strong>typeof</strong>: Nos dice de qué tipo es una variable.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nx">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
 <span class="nb">document</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">a</span><span class="p">);</span>
</code></pre></div> </div> </li> <li> <p><strong>String</strong>: Convierte la variable a un string (cadena de caracteres).</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nx">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>          <span class="c1">// a es el número entero 5 </span>
 <span class="nx">b</span> <span class="o">=</span> <span class="nb">String</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>  <span class="c1">// b es la cadena "5"</span>
</code></pre></div> </div> </li> <li> <p><strong>Number</strong>: Convierte la variable a un string (cadena de caracteres).</p> <p>```javascript a = “5 pollos”; // a es una cadena b = Number(a); // Javascript tratará de convertir la cadena a un número document.write(b); // ¿Qué crees que aparecerá en la pantalla?</p> </li> </ul> <h3 id="36--operadores-y-expresiones"> <a href="#36--operadores-y-expresiones" class="anchor-heading" aria-labelledby="36--operadores-y-expresiones"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 3.6 Operadores y expresiones </h3> <p>Los <strong>operadores y expresiones en Javascript</strong> son iguales que los que hemos empleado en pseudocódigo, con unas pocas excepciones que mencionamos a continuación:</p> <ul> <li> <p>La <strong>asignación</strong>, como ya hemos dicho, se hace con el <strong>símbolo igual (=)</strong>, no con &lt;=.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nx">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>        <span class="c1">// A la variable a se le asigna el valor 5</span>
 <span class="nx">b</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>    <span class="c1">// A la variable b se le asigna el valor a + 1</span>
</code></pre></div> </div> </li> <li> <p>La <strong>comparación de igualdad</strong> se hace con un <strong>doble igual (==)</strong>, no con un solo igual (=). Esto se hace así para distinguir la comparación de la asignación.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">if</span> <span class="p">(</span><span class="nx">a</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// ¿Es a igual a 5?</span>
     <span class="nx">b</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div> </div> </li> <li> <p>Existe el <strong>operador incremento</strong>. Se utiliza para sumar una unidad a una variable.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">while</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
     <span class="nx">i</span><span class="o">++</span><span class="p">;</span>    <span class="c1">// Esto es equivalente a: i = i + 1</span>
 <span class="p">}</span>
</code></pre></div> </div> </li> <li> <p>También existe el <strong>operador decremento</strong>, para restar una unidad a una variable.</p> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">while</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
     <span class="nx">i</span><span class="o">--</span><span class="p">;</span>     <span class="c1">// Equivalente a: i = i - 1</span>
 <span class="p">}</span>
</code></pre></div> </div> </li> <li> <div class="table-wrapper"><table> <tbody> <tr> <td>El <strong>operador lógico Y</strong> se escribe <strong>&amp;&amp;</strong>. El <strong>operador lógico O</strong> se escribe **</td> <td> </td> <td><strong>. El **operador lógico NO</strong> se escribe <em>!</em></td> </tr> </tbody> </table></div> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">if</span> <span class="p">(</span><span class="nx">a</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>   <span class="c1">// Operador Y: tienen que darse las dos condiciones a la vez</span>
     <span class="p">...</span>
 <span class="p">}</span>
</code></pre></div> </div> </li> </ul> <p>Hay algunas otras diferencias, desde luego, pero con esto ya tienes para hacer la mayoría de las cosas.</p> <h2 id="4-estructuras-de-control-en-javascript"> <a href="#4-estructuras-de-control-en-javascript" class="anchor-heading" aria-labelledby="4-estructuras-de-control-en-javascript"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4. Estructuras de control en Javascript </h2> <p>Las <strong>estructuras de control</strong> en Javascript son muy similares a las que hemos utilizado en pseudocódigo, cambiando ligeramente la notación empleada.</p> <p>A continuación te muestro una tabla con las más habituales y su equivalente en pseudocódigo, sin entrar en explicaciones, porque supondremos que ya sabes manejarlas. Si no recuerdas para qué servía alguna de ellas, quizá sería buena idea que le dieras un repaso al capítulo dedicado al pseudocódigo.</p> <div class="table-wrapper"><table> <th> <td>Instrucción</td> <td>Pseudocódigo</td> <td>Javascript</td> </th> <tr> <td>Condicional simple</td> <td> <code> Si condición entonces acciones FinSi </code> </td> <td> <code> if (condicion) { acciones } </code> </td> </tr> <tr> <td>Instrucción</td> <td>Pseudocódigo</td> <td>Javascript</td> </tr> <tr> <td>Instrucción</td> <td>Pseudocódigo</td> <td>Javascript</td> </tr> <tr> <td>Instrucción</td> <td>Pseudocódigo</td> <td>Javascript</td> </tr> <tr> <td>Instrucción</td> <td>Pseudocódigo</td> <td>Javascript</td> </tr> Si condición entonces inicio acciones fin| if (condición) { acciones } #### Condicional doble Pseudocódigo Lenguaje C si condición entonces inicio acciones-1 fin si_no inicio acciones-2 fin if (condición) { acciones-1 } else { acciones-2 } 4.3 Condicional múltiple Pseudocódigo Lenguaje C según expresión hacer inicio valor1: acciones-1 valor2: acciones-2 valor3: acciones-3 ... valorN: acciones-N si_no: acciones-si_no fin switch (expresión) { case valor1: acciones-1; break; case valor2: acciones-2; break; case valor3: acciones-3; break; ... case valorN: acciones-N; break; default: acciones-si_no; } Esta estructura presenta algunas peculiaridades, a saber: • La expresión discriminante debe escribirse entre paréntesis y ser de un tipo ordinal (int, char o similar). No pueden usarse cadenas ni números reales. • Los valores no pueden ser expresiones, sino constantes, es decir, números o caracteres fijos. • ¡Cuidado! Las acciones no son bloques de instrucciones, es decir, no van encerradas entre { y }. Eso quiere decir que, si se ejecutan las acciones-2, después se ejecutarán automáticamente las acciones-3, luego las acciones-4, etc. La forma de evitar esto es insertar la instrucción break al final de cada bloque de instrucciones. 4.4 Bucle mientras Pseudocódigo Lenguaje C mientras condición hacer inicio acciones fin while (condición) { acciones } 4.5 Bucle repetir Pseudocódigo Lenguaje C repetir inicio acciones fin mientras que condición do { acciones } while (condición) 4.6 Bucle para Pseudocódigo Lenguaje C para cont desde valor_inicial hasta valor_final inicio acciones fin for (inicialización; condición; incremento) { acciones } Cuidado con este tipo de bucle porque es algo diferente a como lo hemos visto en pseudocódigo. Ya se ha dicho en varias ocasiones que C es a veces un poco críptico. El bucle para (o bucle for) es un ejemplo típico de ello ya que: • La variable contador debe ser inicializada con una asignación dentro de la instrucción for. • El valor final debe ser expresado en forma de condición, como haríamos en un bucle mientras. • El incremento del contador hay que indicarlo explícitamente. Por ejemplo, el siguiente bucle en pseudocódigo: para cont desde 1 hasta 100 inc 2 hacer inicio acciones fin Tendría esta traducción en C: for (cont = 1; cont &lt;= 100; cont = cont + 2) { acciones } 5 Funciones. La función main() Como se ha dicho anteriormente, C es un lenguaje modular hasta el extremo de que todas las líneas de código deben pertenecer a alguna función, incluyendo las instrucciones del algoritmo principal, que se escriben en una función llamada principal (main en inglés) 5.1 Funciones La declaración de funciones se hace de forma similar a la empleada en pseudocódigo: tipo_devuelto nombre_función (parámetros_formales) { ...instrucciones... return expresión; } Observa que las únicas diferencias con el pseudocódigo son que no se usa la palabra "función", que las llaves { y } sustituyen a inicio y fin, y que se emplea la palabra return en lugar de devolver. 5.2 Procedimientos Si el tipo_devuelto es void, se considera que la función no devuelve ningún valor y que, por lo tanto, es un procedimiento. Entonces, un procedimiento se declara así: void nombre_procedimiento (parámetros_formales) { ...instrucciones... } 5.3 Paso de parámetros Los parámetros formales son, como en pseudocódigo, una lista de tipos e identificadores que se sustituirán por los parámetros actuales y se usarán como variables dentro de la función. Los parámetros se pasan normalmente por valor, pero también se pueden pasar por referencia. El paso de parámetros por referencia admite dos sitaxis ligeramente diferentes en C: anteponiendo el operador * (asterisco) al nombre del parámetro (como hemos hecho en pseudocódigo) o anteponiendo el operador &amp;. Paso de parámetros por valor Por ejemplo, en esta función el paso de parámetros es por valor: int funcion1 (int x, int y) Esto quiere decir que la función1 recibirá únicamente el valor de los dos parámetros, x e y. Podrá utilizar esos valores a lo largo de su código, e incluso podrá cambiarlos. Pero cualquier cambio en x e y no afectará a los parámetros actuales, es decir, a los parámetros del programa que llamó a función1. Paso de parámetros por referencia con el operador * En la siguiente función, el paso del parámetro "x" es por valor y el del parámetro "y", por referencia: int funcion2 (int x, int *y) ¡OJO! Recuerda que cada vez que se vaya a usar el parámetro "y" dentro del código de la función, será necesario acompañarlo del asterisco. Por ejemplo: *y = 5; x = 17 + *y; (Hay algunas excepciones a esta regla, pero ya las veremos cuando surjan más adelante) Por último, también en la llamada a la función hay que indicar explícitamente si alguno de los parámetros se está pasando por referencia, utilizando el operador &amp;, como en pseudocódigo. Por lo tanto, para llamar a la funcion2 del ejemplo anterior con los parámetros A y B habrá que escribir: resultado = funcion2 (A, &amp;B); Observa que el segundo parámetro (el que se pasa por referencia), lleva delante el operador &amp;. Una última observación: en realidad, en C no existe en paso por referencia propiamente dicho, sino que se pasa a la función la dirección de memoria del parámetro actual por valor. Es decir, se pasa un puntero por valor (véanse los punteros más adelante en este mismo texto). Como la función accede directamente a esa posición de memoria, puede cambiar la variable del programa principal. En la práctica, el resultado es el mismo que si se pasase por referencia, y para el programador no apreciará diferencia alguna. Paso de parámetros por referencia con el operador &amp; Otra forma de pasar un argumento por referencia es usar el operador &amp; en los parámetros formales, así: int funcion3 (int x, int &amp;y) En esta función, el parámetro x se pasa por valor y el parámetro “y” se pasa por referencia. Utilizando esta sintaxis no es necesario añadir asteriscos cada vez que se usa la “y” en el cuerpo de la función, ni tampoco usar “&amp;” en la llamada a la función. Esta tercera forma de paso por referencia no es estándar en C, sino que es propia de C++, por lo que evitaremos utilizarla. Juntándolo todo en un ejemplo En el siguiente ejemplo se ilustra los dos tipos de paso de parámetros y, en el paso por referencia, las dos sintaxis alternativas de que dispone C. El ejemplo muestra tres funciones muy similares que reciben dos parámetros, a y b. Las tres intentan intercambiar el valor de a y b mediante una tercera variable, tmp. Sin embargo, en la primera de ellas el intercambio no tiene ningún efecto en el programa main(), ya que los parámetros están pasados por valor. En las otras dos funciones sí que se consigue el intercambio, ya que los parámetros está pasados por referencia. Lo más interesante de este ejemplo es mostrar cuál es la sintaxis correcta en cada tipo de paso de parámetros. #include <stdio.h> // Paso de parámetros por valor. // En este ejemplo, esta función no tendrá el efecto deseado, porque las variables // del programa principal no se verán afectadas. void intercambiar1(int a, int b) { int tmp = a; a = b; b = tmp; } // Paso de parámetros por referencia, sintaxis 1. // Esta función sí que consigue intercambiar los valores de las variables // del programa principal. void intercambiar2(int *a, int *b) { int tmp = *a; *a = *b; *b = tmp; } // Paso de parámetros por referencia, sintaxis 2. // Esta función también consigue su objetivo. A todos los efectos, // es idéntica a la función anterior. void intercambiar3(int &amp;a, int &amp;b) { int tmp = a; a = b; b = tmp; } // Programa principal int main() { int dato1 = 30, dato2 = 90; printf("Antes de la llamada a las funcioens: dato1 = %i, dato2 = %i\n", dato1, dato2); intercambiar1(dato1, dato2); printf("Después de intercambiar1: dato1 = %i, dato2 = %i\n", dato1, dato2); intercambiar2(&amp;dato1, &amp;dato2); printf("Después de intercambiar2: dato1 = %i, dato2 = %i\n", dato1, dato2); intercambiar3(dato1, dato2); printf("Después de intercambiar3: dato1 = %i, dato2 = %i\n", dato1, dato2); return 0; } 5.4 La función main() La función main() contiene el algoritmo o módulo principal del programa. La ejecución de un programa siempre empieza por la primera línea de la función main() La función main(), como todas las funciones de C, puede devolver un valor. El valor devuelto por main() debe ser de tipo entero. Esto se utiliza para pasar algún valor al programa que haya llamado al nuestro, que suele ser el sistema operativo. Si main() no devuelve un número entero al sistema operativo mediante una sentencia return, entonces nuestro programa devolverá un número desconocido. Moraleja: es una buena idea incluir un return al final de la función main(). Generalmente, la devolución de un 0 indica al sistema operativo que el programa a finalizado sin problemas, mientras que cualquier otro valor señala que se ha producido algún error. Por lo tanto, la forma habitual de la función main() será: int main(void) { ...instrucciones del algoritmo principal... return 0; } Observa que main() no tiene argumentos, por lo que aparece el identificador void entre paréntesis en la declaración. También se pueden utilizar argumentos en main(), pero eso es algo que trataremos en otro momento. 5.5 Prototipos de funciones En C no es necesario escribir las funciones (subalgoritmos) antes de su primera invocación. El mecanismo de compilación y enlace de C permite, de hecho, que las funciones puedan estar físicamente en un archivo distinto del lugar desde el que se invocan. En la práctica, esto plantea un problema: C no tiene forma de saber si la llamada a una función se hace correctamente, es decir, si se le pasan los argumentos debidos y con el tipo correcto, ni si el resutado devuelto es asignado a una variable del tipo adecuado. Para conseguir que C realice esas comprobaciones se utilizan los prototipos de función. Un prototipo de función es la declaración de una función. Consiste, simplemente, en la primera línea del código la función. El prototipo debe aparecer antes de que la función se invoque por primera vez, aunque el código completo de la función esté en otra parte. Los prototipos permiten al compilador comprobar que los argumentos de la función coinciden en tipo y número con los de la invocación de la misma, y que el tipo devuelto es el correcto. Los prototipos suelen aparecer al principio del programa, antes de la función main(). Observa, en el siguiente ejemplo, que el prototipo de la función calcular_area() se coloca delante de main(). Sin embargo, el código concreto de esta función no aparece hasta después (incluso podría estar situado en otro archivo diferente): float calcular_area (float base, float altura); // Prototipo de la función int main() // Algoritmo principal { ...instrucciones... area = calcular_area (x,y); ...más instrucciones... return 0; } float calcular_area(float base, float altura) // Código de la función { ... instrucciones... } Cuando se vayan a usar funciones de librería, como fabs() (valor absoluto), sqrt() (raíz cuadrada) o cualquier otra, hay que escribir sus prototipos antes de la función main(). Sin embargo, como estas funciones no las hemos escrito nosotros, desconocemos cuales son sus prototipos. En C se soluciona este problema con los archivos de cabecera, que son archivos proporcionados con el compilador de C que incluyen en su interior los prototipos de las funciones de librería, entre otras cosas. Como funciones de librería hay muchas, también hay muchos archivos de cabecera. Por ejemplo, el archivo math.h tiene los prototipos de todas las funciones matemáticas. Todos los archivos de cabecera tienen la extensión .h en su nombre (h de "header"). Para incluir un archivo de cabecera en nuestro programa se utiliza #include, que no es exactamente una instrucción de C, sino una directiva de compilación. Más adelante veremos qué significa eso. Ya hemos visto otra directiva de compilación: #define, que usábamos para definir constantes. Las directivas de compilación se detallan en uno de los apéndices de este libro, y puedes ir ahora allí si quieres ampliar esta información. Por ejemplo, esta línea de código sirve para incluir todos los prototipos de las funciones de librería matemática en nuestro programa: #include <math.h> Al final del tema, en el apéndice dedicada a las funciones ANSI, encontrarás una lista con las funciones utilizadas más habitualmente y sus correspondientes archivos de cabecera. Cada vez que necesites usar una de esas funciones en un programa, debes escribir al principio del mismo el #include del archivo de cabecera para disponer así del prototipo. 5.6 Estructura general de un programa en C Visto todo esto, ya estamos en condiciones de echar un vistazo a cual será el aspecto de (casi) todos los programas que escribamos en C. Todo programa C, desde el más pequeño hasta el más complejo, tiene un programa principal ubicado en la función main(). Además, por encima de main() deben aparecer los prototipos de funciones (y esto implica a los archivos de cabecera, si se utilizan funciones de librería) y las variables y constantes globales. Por debajo de main() encontraremos el código de las funciones de usuario. Por lo tanto, la estructura habitual de nuestros programas en C debería ser esta: /* Comentario inicial: nombre del programa, del programador, fecha, etc */ /* Archivos de cabecera (prototipos de funciones de librería) */ #include <archivo_cabecera.h> #include <archivo_cabecera.h> /* Prototipos de funciones escritas por nosotros */ float función1 (argumentos); float función2 (argumentos); /* Variables globales */ int variable_global1; char variable_global2; /* Algoritmo principal */ int main(void) { /* Variables locales del algoritmo principal */ int a, b; float x, y; ... ... /* Instrucciones del algoritmo principal */ ... función1(argumentos); ... función2(argumentos); ... return 0; } /* Código completo de las funciones escritas por nosotros */ float función1 (argumentos) { /* Variables locales e instrucciones de este subalgoritmo */ } float función2 (argumentos) { /* Variables locales e instrucciones de este subalgoritmo */ } 6 Entrada y salida estándar La entrada y salida de datos en C, es decir, la traducción de las instrucciones leer() y escribir() de pseudocódigo, es uno de los aspectos más difíciles (y criticables) de C. El estándar ANSI C dispone de muchas funciones para hacer las entradas y salidas de datos. En concreto, dispone de un subconjunto de ellas para hacer la entrada y salida por consola, es decir, por teclado y pantalla. Podemos clasificar estas funciones de E/S en dos grupos: • Funciones de E/S simples: getchar(), putchar(), gets(), puts() • Funciones de E/S con formato: printf(), scanf() Las más utilizadas y versátiles son sin duda las segundas, así que nos detendremos más en ellas. 6.1 E/S con formato Salida de datos: printf() La función printf() (de "print" = imprimir y "f" = formato) sirve para escribir datos en el dispositivo de salida estándar (generalmente la pantalla) con un formato determinado por el programador. La forma general de utilizarla es la siguiente: printf(cadena_de_formato, datos); El prototipo de printf() se encuentra en el archivo de cabecera stdio.h (de "std" = standard e "io" = input/output, es decir, entrada/salida; por lo tanto, "stdio" es un acrónimo de "entrada/salida estándar") El primer argumento, la cadena_de_formato, especifica el modo en el que se deben mostrar los datos que aparecen a continuación. Esta cadena se compone de una serie de códigos de formato que indican a C qué tipo de datos son los que se desean imprimir. Todos los códigos están precedidos del símbolo de porcentaje ("%"). Por ejemplo, el código "%i" indica a la función que se desea escribir un número de tipo int, y el código "%f", que se desea escribir un número real de tipo float. La forma más simple de utilizar printf() es: int a; a = 5; printf("%i", a); Esto escribirá el valor de la variable entera a en la pantalla, es decir, 5. Fíjate que el primer argumento de printf() es una cadena (y, por lo tanto, se escribe entre comillas) cuyo contenido es el código del tipo de dato que se pretende escribir. El segundo argumento es el dato mismo. En una sola instrucción printf() pueden escribirse varios datos. Por ejemplo: int a; float x; a = 5; x = 10.33; printf("%i%f", a, x); Observa detenidamente la cadena de formato: primero aparece "%i" y luego "%f". Esto indica que el primer dato que debe imprimirse es un entero, y el segundo, un real. Después, aparecen esos datos separados por comas y exactamente en el mismo orden que en la cadena de formato: primero a (la variable entera) y luego x (la variable real). El resultado será que en la pantalla se escribirán los números 5 y 10.33. Los códigos de formato que se pueden utilizar en printf() son: Código Tipo del dato que se escribe %c Carácter %d Número entero %i Número entero %e Número real con notación científica %f Número real %g Usar %e o %f, el más corto %o Número octal %s Cadena de caracteres %u Entero sin signo %x Número hexadecimal %p Puntero Algunos de estos códigos sirven para imprimir tipos de datos que aún no conocemos, pero que iremos viendo en las siguientes páginas. Hay códigos que admiten modificadores. Por ejemplo: • Los códigos numéricos "%i", "%d", "%u" (para números enteros) y "%f", "%e" y "%g" (para números reales), permiten insertar modificadores de longitud "l" (longitud doble) y "h" (longitud corta). Así, por ejemplo, "%ld" indica que se va a imprimir un entero de longitud doble (long int); "%hu" sirve para enteros cortos sin signo (unsigned short int); "%lf" indica que se imprimirá un número real de longitud doble (double), etc. • El código "%f" (números reales) se pueden usar con un modificador de posiciones decimales que se desean mostrar. Por ejemplo, con "%10.4f" obligamos a que se impriman diez dígitos a la izquierda de la coma decimal y cuatro a la derecha. La escritura se ajusta a la derecha. Para ajustarla a la izquierda se utiliza el modificador "-", de esta forma: "%-10.4f" • El código "%s" (cadenas de caracteres) se puede combinar con un especificador de longitud máxima y mínima de la cadena. Por ejemplo, "%4.8s" escribe una cadena de al menos cuatro caracteres y no más de ocho. Si la cadena tiene más, se pierden los que excedan de ocho. También se puede utilizar el modificador "-" para alinear el texto a la izquierda. Además de los códigos de formato, en la cadena de formato puede aparecer cualquier texto entremezclado con los códigos. A la hora de escribir en la pantalla, los códigos serán sustituidos por los datos correspondientes. Por ejemplo: int a; float x; a = 5; x = 10.33; printf("El número entero es %i y el real es %f", a, x); Lo que aparecerá en la pantalla al ejecutar este fragmento de código será: El número entero es 5 y el real es 10.33 Una última observación sobre printf(). Hay ciertos caracteres que no son directamente imprimibles desde el teclado. Uno de ellos es el salto de línea. Para poder ordenar a printf() que escriba un salto de línea (o cualquier otro carácter no imprimible) se utilizan los códigos de barra invertida, que con códigos especiales precedidos del carácter "\". En concreto, el carácter "salto de línea" se indica con el código "\n". Observa las diferencias entre estos dos bloques de instrucciones para intentar comprender la importancia del salto de línea: int a; a = 5; printf("La variable a vale %i", a); a = 14; printf("La variable a vale %i", a); El resultado en la pantalla de la ejecución de estas instrucciones es: La variable a vale 5La variable a vale 14 Veamos el mismo ejemplo usando el código del salto de línea (\n): int a; a = 5; printf("La variable a vale %i\n", a); a = 14; printf("La variable a vale %i", a); El resultado en la pantalla será: La variable a vale 5 La variable a vale 14 Entrada de datos: scanf() La función scanf() es, en muchos sentidos, la inversa de printf(). Puede leer desde el dispositivo de entrada estándar (normalmente el teclado) datos de cualquier tipo de los manejados por el compilador, convirtiéndolos al formato interno apropiado. Funciona de manera análoga a printf(), por lo que su sintaxis es: scanf(cadena_de_formato, datos); El prototipo de scanf() se encuentra en el archivo de cabecera stdio.h (de "std" = standard e "io" = input/output, es decir, entrada/salida) La cadena_de_formato tiene la misma composición que la de printf(). Los datos son las variables donde se desea almacenar el dato o datos leidos desde el teclado. ¡Cuidado! Con los tipos simples, es necesario utilizar el operador &amp; delante del nombre de la variable, porque esa variable se pasa por referencia a scanf() para que ésta pueda modificarla. Por ejemplo: int a, b; float x; scanf("%d", &amp;a); scanf("%d%f", &amp;b, &amp;x); La primera llamada a scanf() sirve para leer un número entero desde teclado y almacenarlo en la variable a. La segunda llamada lee dos números: el primero, entero, que se almacena en b; y, el segundo, real, que se almacena en x. La función scanf() tiene alguna otra funcionalidad añadida para el manejo de cadenas de caracteres que ya veremos en su momento. Ejemplo de uso de scanf() y printf() Debido a la relativa complejidad de estas funciones de entrada y salida, vamos a presentar un pequeño ejemplo de traducción de pseudocódigo a C. Se trata de un algoritmo que lee dos números enteros, A y B. Si A es mayor que B los resta, y en otro caso los suma. Observa detenidamente la correspondencia entre cada pareja de instrucciones, especialmente las de entrada y salida. Pseudocódigo Traducción a C algoritmo suma_y_resta variables a y b son enteros inicio escribir ("Introduzca dos números enteros") leer(a, b) si (a &lt; b) entonces escribir("La suma de a y b es:", a+b) si_no escribir("La resta de a menos b es:", a–b) fin /* Programa suma y resta */ #include <stdio.h> int main() { int a, b; printf ("Introduzca dos números enteros\n"); scanf("%d%d", &amp;a, &amp;b); if (a &lt; b) printf("La suma de %d y %d es: %d", a, b, a+b); else printf("La resta de %d menos %d es: %d", a, b, a–b); return 0; } 6.2 E/S simple por consola Técnicamente, con printf() y scanf() es posible escribir y leer cualquier tipo de datos desde cualquier dispositivo de salida o entrada, no solo la pantalla y el teclado, como de hecho comprobaremos cuando estudiemos los ficheros. En la práctica, aunque printf() resulta bastante efectiva y versátil, scanf() puede darte muchos dolores de cabeza. Para hacerte una idea, sólo tienes que probar a hacer un scanf() de un número entero e inmediatamente después otro scanf() de una cadena de caracteres. El segundo scanf() fallará. La razón es bastante rocambolesca: el flujo de entrada no consumirá el carácter de retorno de carro al leer el número entero, por lo que dicho carácter se adjudicará al segundo scanf() automáticamente. Por suerte, existe otro grupo de funciones en ANSI C específicamente diseñadas para hacer la E/S por consola, es decir, por teclado y pantalla, de manera más simple. Las resumimos en el siguiente cuadro. Los prototipos de estas funciones se encuentran en el archivo de cabecera stdio.h (de "std" = standard e "io" = input/output, es decir, "entrada/salida") Función Utilidad Ejemplo getchar() Espera a que se pulse una tecla seguida de INTRO y devuelve su valor. Muestra el eco en la pantalla, es decir, la tecla pulsada aparece en la pantalla. putchar(carácter) Escribe un carácter en la pantalla char car; car = getchar(); printf("Tecla pulsada:\n"); putchar(car); gets(cadena) Lee del teclado una cadena de caracteres seguida de INTRO. puts(cadena) Escribe una cadena de caracteres en la pantalla char cadena[50]; gets(cadena); printf("Cadena tecleada:\n"); puts(cadena); Para evitar los problemas que a menudo causa scanf(), podemos recurrir a gets() para leer las cadenas de caracteres. Si necesitamos leer un número, podemos usar gets() y luego convertir la cadena a un tipo de dato numérico con las funciones de conversión atoi() y atof(), como se muestra en el siguiente ejemplo: char cadena[50]; int a; float x; gets(cadena); // Leemos una cadena de caracteres a = atoi(cadena); // Convertimos la cadena en un número entero x = atof(cadena); // Convertimos la cadena en un número real Las funciones de conversión atoi() y atof() tratarán de convertir la cadena en un número, si ello es posible (es decir, si la cadena realmente contiene números). Estas funciones, junto con muchas otras, se describen en el apéndice I de este capítulo. Usar la combinación de gets() con atoi() o atof() es más costoso que utilizar scanf(). Primero, porque necesitamos una variable auxiliar de tipo cadena. Y, segundo, porque gets() es una función peligrosa: si se teclean más caracteres de los que caben en la cadena, el resultado es imprevisible (a menudo el programa se cuelga). Esto también tiene solución utilizando en su lugar la función fgets(). Tal vez pienses que resulta demasiado complicado hacer algo muy simple como una entrada de datos por teclado. Tienes razón. Pero ten en cuenta dos cosas: las entradas de datos nunca son simples (son el punto donde el usuario interacciona con más libertad con el programa, y los usuarios humanos tendemos a hacer cosas impredecibles y complicadas), y C es un lenguaje de nivel intermedio, por lo que muchas tareas de alto nivel, simplemente, no las resolverá por nosotros. En ese sentido, C requiere del programador prestar atención a ciertos detalles que podría obviar en otros lenguajes. Es por esto, entre otras cosas, por las que C tiene exaltados detractores pero también incondicionales entusiastas. Por último, mencionaremos que los compiladores de Borland tienen dos variaciones muy útiles de la función getchar() llamadas getche() y getch(). Estas funciones, no definidas en el estándar ANSI de C, son como getchar() pero sin necesidad de pulsar INTRO detrás del carácter. La primera muestra el eco, es decir, escribe en la pantalla la tecla pulsada, y la segunda no. Los prototipos de estas funciones se encuentran en conio.h (de "con" = consola e "io" = input/output) 7 Flujo de trabajo programando con lenguaje C Como vimos más arriba, el ciclo de vida de desarrollo del software consta de una serie de etapas. En esta parte del libro nos estamos centrando a la etapa de implementación o codificación del software, ya que estamos aprendiendo un lenguaje de programación concreto. Antes de continuar profundizando en el lenguaje, vamos a hacer un pequeño paréntesis para especificar cuál suele ser el flujo de trabajo en el desarrollo de programas con lenguaje C. Cuando se trabaja con C, la implementación de un programa suele dividirse en varias subfases: edición, compilación, enlace y depuración. Pasamos a describirlas brevemente a continuación. 7.1 Edición del código fuente Editar consiste en escribir el código fuente del programa en el lenguaje seleccionado, en nuestro caso C. Para escribir el código nos puede servir cualquier procesador de textos que permita guardar el documento en forma de texto ASCII plano (sin códigos de control y formato propios de los procesadores avanzados, como MS Word). Existen multitud de procesadores de texto plano para programar en lenguaje C. Solo tienes que hacer una pequeña búsqueda en internet para encontrar una pléyade de candidatos. La ventaja de estos procesadores es que resaltan, en diferentes colores y tipografías, las palabras clave, las funciones, las cadenas, los comentarios, etc, haciendo de este modo mucho más legible el código fuente. Necesitarás probar unos cuantos antes de decidir cuál es el que más te gusta. Además, es habitual que los compiladores de C incluyan también un editor. Por ejemplo, los compiladores de Borland (como Turbo C/C++, Borland C/C++ o C++ Builder) poseen un entorno integrado de desarrollo, que es un programa que une al editor de texto, al compilador y al depurador en una sola aplicación controlada por un único interfaz, lo cual facilita mucho el trabajo. Estos editores con funcionalidades añadidas suelen denominarse IDEs (Integrated Development Environment, entorno integrado de desarrollo), y nos referiremos a ellos con más detalle en los apéndices de este libro. Mi recomendación es que, al menos al principio, intentes usar un editor simple, que no incluya el compilador. Esto te obligará a hacer un trabajo adicional al tener que compilar y enlazar manualmente tu programa, pero es la mejor forma de comprender realmente en qué consiste la compilación y el enlace. En el futuro, esta comprensión te puede ayudar a resolver muchos errores de compilación y enlace. En cualquier caso, las recomendaciones que hemos de seguir durante la edición del código fuente son: • No empezar a teclear código sin haber entendido bien el problema que se nos plantea. Si éste es complejo, es imprescindible plantear antes su descomposición modular en papel, resolviendo los módulos con pseudocódigo. • Recuerda: comenzar a teclear a lo loco y sin pensar antes la solución detenidamente es la manera más segura de tardar el mayor tiempo posible en desarrollar un programa que, además, no funcione bien. • Realizar un diseño modular previo del programa. Recuerda que un módulo de más de 30 ó 40 líneas (aproximadamente) empieza a ser demasiado largo. • Evitar las variables globales. • Elegir bien el nombre de los identificadores (variables, constantes, funciones...). Que sean significativos y no excesivamente largos. • Identar el texto, es decir, dejar las sangrías necesarias para facilitar su comprensión. • Usar espacios y líneas en blanco siempre que se considere que facilita la lectura. • Ser generosos documentando el código fuente. Mejor que sobren comentarios que no que falten. • Guardar el código fuente en archivos de texto cuya extensión sea ".c" (por ejemplo: "ejercicio.c") 7.2 Compilación El proceso de compilación, como sabes, consiste en que un programa, llamado compilador, traduzca el código fuente en lenguaje C a código binario. La compilación, por lo tanto, no es más que una traducción. El resultado de la compilación es el mismo programa traducido a código binario. Como el programa fuente estaba almacenado en un archivo con extensión .C, el compilador suele guardar el programa objeto en otro archivo con el mismo nombre y extensión .OBJ. Los programas cortos se guardan en un único archivo fuente que se traducirá a un único archivo objeto. Pero cuando los programas crecen, es habitual distribuir el código fuente en varios archivos con el objetivo de manipularlo mejor. Los compiladores de C usan compilación separada. Esto significa que, si un programa largo está escrito en varios archivos fuente, no es necesario compilarlos todos cada vez que se modifica algo. Basta con volver a compilar el archivo modificado. Por eso, dividir un programa fuente largo en varios archivos más cortos también sirve para mejorar los tiempos de compilación. Cuando tenemos varios archivos fuente es normal que existan dependencias entre ellos. Por ejemplo, cuando en un archivo A1 se utiliza (con la directiva #include) un archivo de cabecera A2. Si modificamos el archivo A2 es necesario volver a compilar el archivo A1, aunque A1 no haya sido modificado en absoluto. Se dice entonces que existe una dependencia entre los archivos A1 y A2. Controlar las dependencias es un trabajo tedioso y propenso a errores. Por fortuna, los compiladores se encargan de controlarlas por sí mismos. Así que no te extrañes si, al volver a compilar un archivo fuente después de modificarlo, se compilan automáticamente algunos otros archivos, aunque no los hayas tocado. El control de las dependencias lo puede realizar el compilador de manera automática o semiautomática (mediante archivos de dependencias o makefiles escritos por el programador), como veremos en los apéndices. Los compiladores, en fin, son programas muy complejos que, además, tienen multitud de opciones de compilación. Algunas de esas opciones también las veremos en los apéndices del libro. Allí encontrarás información sobre cómo compilar tus programas con Mingw, un compilador de C/C++ para Windows, y con gcc, el compilador nativo de Linux. 7.3 Enlace (link) Cuando existen varios programas objeto es necesario combinarlos todos para dar lugar al programa ejecutable definitivo. Este proceso se denomina enlace. El código objeto de las funciones de librería de C se encuentra almacenado en varios archivos (cuya extensión es .LIB) situados en ubicaciones conocidas por el enlazador. De este modo, el código objeto de las funciones de librería que hayamos utilizado en nuestro programa puede unirse con el código objeto del programa durante en enlace, generándose el programa ejecutable. Por lo tanto, es necesario hacer el enlace cuando el programa se encuentra distribuido en varios archivos, o cuando dentro del programa se utilizan funciones de librería. Esto quiere decir que, en la práctica, el enlace hay que hacerlo siempre. El enlazador o linker, es decir, el programa encargado de hacer el enlace, es en realidad diferente del compilador, que sólo hace la traducción. Sin embargo, la mayoría de los compiladores de C lanzan automáticamente el enlazador al finalizar la compilación para que el programador no tenga que hacerlo. El enlace de nuestro código objeto con las funciones de librería puede hacerse de dos maneras: • Enlace estático. Consiste en unir durante el enlace el código objeto de las librerías con el código del programa, generando así el ejecutable. El programa ejecutable crece notablemente de tamaño respecto de los archivos objeto, ya que incorpora el código de todas las funciones de las librerías. El enlace estático es el que normalmente se utiliza a menos que indiquemos otra cosa. • Enlace dinámico. El código de las librerías no se une al del programa, sino que se busca durante la ejecución, únicamente cuando es requerido. El enlace dinámico produce, por lo tanto, ejecuciones más lentas, ya que cada vez que se use una función de librería dinámica es necesario buscar el archivo en el que se encuentra y ejecutar su código. Además, pueden producirse errores de enlace durante la ejecución del programa. Sin embargo, el enlace dinámico tiene las ventajas de reducir el tamaño del archivo ejecutable y permitir la compartición de librerías entre diferentes aplicaciones. 7.4 Depuración La depuración del programa consiste en localizar y corregir los errores que se hayan podido producir durante el desarrollo. El objetivo es conseguir un programa que funcione lo más correctamente posible, aunque hay que tener presente que ningún programa complejo está libre de errores al 100% Los errores pueden ser de tres tipos: • Errores en tiempo de compilación. Se producen al traducir el código fuente a código objeto. El compilador los detecta y marca en qué línea se han producido, y de qué tipo son, por lo que son relativamente fáciles de corregir. Los errores de compilación más frecuentes son: • Errores sintácticos: escribir mal alguna instrucción o algún identificador, u olvidarnos del punto y coma que debe terminar cada instrucción. • Errores de tipos: intentar asignar a una variable de cierto tipo un valor de otro tipo incompatible, o invocar a una función con argumentos de tipo equivocado. Recuerda que C puede hacer conversiones de tipo automáticas, por lo que estos errores pueden quedar enmascarados. • Errores de identificadores no reconocidos: ocurren cuando se intenta utilizar una variable o una constante que no ha sido declarada, o cuyo ámbito no llega al lugar donde se intenta utilizar. • Avisos. Además de los errores, el compilador puede dar avisos (warnings) en lugares donde potencialmente puede existir un error de compilación. Es conveniente revisar todos los avisos y tratar de corregirlos antes de continuar con la ejecución. • Errores en tiempo de enlace. Cuando el compilador termina la traducción se produce el enlace de todos los archivos objeto. En este momento se resuelven todas las llamadas a funciones, de modo que si alguna función no está presente en el conjunto de archivos objeto, el enlazador fallará y explicará la causa del error. • Errores en tiempo de ejecución. Si la compilación y el enlace terminan sin novedad, se genera un archivo ejecutable (con extensión .EXE en sistemas Windows). Es el momento de comprobar que el programa realmente hace lo que se espera que haga. Para ello hay que probarlo con diversos conjuntos de datos de entrada; la elaboración de estos juegos de pruebas es una técnica que excede nuestras pretensiones. Los errores que surgen en tiempo de ejecución son los más complicados de corregir, ya que muchas veces no está clara la causa del error. En el peor de los casos, puede ser necesario rediseñar la aplicación por completo. Simplificando mucho, podemos encontrarnos con estos errores en tiempo de ejecución: • Errores lógicos. Se producen cuando alguna condición lógica está mal planteada. Entonces, el flujo del programa puede ir por la rama "si_no" cuando debería ir por la rama "si", o puede salirse de un bucle cuando debería repetir una vez más, o entrar en un bucle infinito, etc. • Errores aritméticos. Ocurren cuando una variable se desborda (overflow), o se intenta una operación de división entre cero, o alguna operación aritmética está mal planteada. • Errores de punteros. Los punteros son herramientas muy potentes que permiten la manipulación dinámica de la memoria, pero también conllevan grandes riesgos porque un puntero "descontrolado" puede hacer auténticas locuras en la memoria del ordenador, hasta el punto de colgar sistemas poco fiables (Windows 9x) • Errores de conversión automática de tipos. Se producen cuando C realiza una conversión automática que no teníamos prevista. Entonces el dato puede cambiar y dar al traste con la lógica del programa. • Errores de diseño. Ocurren cuando el programa no está bien diseñado y realiza tareas diferentes de las que se pretendían. Son los peores errores, porque obligarán a modificar una parte (o la totalidad) del trabajo realizado, debiendo, en ocasiones, volver a las primeras fases del ciclo de vida para repetir todo el proceso. Estos y otros errores en tiempo de ejecución pueden manifestarse con distintas frecuencias: • Siempre que se ejecuta el programa: son los más fáciles de localizar y corregir. • Solo cuando se introducen determinados datos de entrada: puede ser complicado dar con la secuencia de datos de entrada que provocan el error, pero una vez que la encontramos, puede localizarse con facilidad. • Al azar: algunas veces, los programas fallan sin motivo aparente, cuando han estado funcionando en el pasado con el mismo conjunto de datos. Son los errores más difíciles de localizar, porque ni siquiera se sabe bajo qué circunstancias ocurren. El depurador El depurador es un programa independiente del editor, el compilador y el enlazador. La mayoría de los compiladores disponen de uno y, además, suele estar integrado con los otros tres, de modo que desde el editor se puede lanzar cualquiera de los otros. El depurador es una herramienta fundamental para localizar y corregir errores en tiempo de ejecución. Para que la depuración sea cómoda, hay que activar una opción específica del compilador que permita hacer la depuración sobre el código fuente. Si no se activa, la depuración se hará sobre el código binario o, como mínimo, será imposible acceder a los identificadores de variables, lo cual complica mucho la depuración. Muchos compiladores tienen esta opción activada por defecto. Cada depurador tiene sus propias opciones y características, pero todos suelen coincidir en varios aspectos: • Permiten ejecutar paso a paso cada instrucción del programa, deteniéndose antes de ejecutar la siguiente para permitirnos ver el estado de las variables o de los dispositivos de E/S. • Permiten ver y manipular el contenido de las variables en cualquier punto del programa. • Permiten ver y manipular la estructura de la memoria asignada al programa y de los registros del microprocesador. • Permiten insertar puntos de ruptura (breakpoints), es decir, puntos donde la ejecución se detendrá momentáneamente para que hagamos alguna comprobación de las anteriormente expuestas. Haciendo correcto uso de estas posibilidades, podemos localizar rápidamente cualquier error en tiempo de ejecución y afrontar la tarea de corregirlo. Si quieres ver ejemplos concretos de depuradores para Windows y para Linux, puedes consultar los apéndices del libro en este momento. </stdio.h></archivo_cabecera.h></archivo_cabecera.h></math.h></stdio.h></table></div> <hr> <h2 class="text-delta">Table of contents</h2> <ul> </ul> </div> </div> <div class="search-overlay"></div> </div> </body> </html>
