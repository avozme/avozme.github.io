<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <title>4. Estructuras de datos - PROG Y 3D</title> <link rel="shortcut icon" href="/docs/prog-y-3d/_site/favicon.ico" type="image/x-icon"> <link rel="stylesheet" href="/docs/prog-y-3d/_site/assets/css/just-the-docs-default.css"> <script type="text/javascript" src="/docs/prog-y-3d/_site/assets/js/vendor/lunr.min.js"></script> <script type="text/javascript" src="/docs/prog-y-3d/_site/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.7.1 --> <title>Estructuras de datos | PROG Y 3D</title> <meta name="generator" content="Jekyll v4.2.0" /> <meta property="og:title" content="Estructuras de datos" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Apuntes de la asignatura “Introducción a la programación y al diseño 3D”, optativa de 2º curso de bachillerato ofertada por el IES Celia Viñas de Almería (España)" /> <meta property="og:description" content="Apuntes de la asignatura “Introducción a la programación y al diseño 3D”, optativa de 2º curso de bachillerato ofertada por el IES Celia Viñas de Almería (España)" /> <link rel="canonical" href="/docs/prog-y-3d/_site/estructuras-de-datos/" /> <meta property="og:url" content="/docs/prog-y-3d/_site/estructuras-de-datos/" /> <meta property="og:site_name" content="PROG Y 3D" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Estructuras de datos" /> <script type="application/ld+json"> {"@type":"WebPage","url":"/docs/prog-y-3d/_site/estructuras-de-datos/","headline":"Estructuras de datos","description":"Apuntes de la asignatura “Introducción a la programación y al diseño 3D”, optativa de 2º curso de bachillerato ofertada por el IES Celia Viñas de Almería (España)","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> </head> <body> <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header"> <a href="/docs/prog-y-3d/_site/" class="site-title lh-tight"> PROG Y 3D </a> <a href="#" id="menu-button" class="site-button"> <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg> </a> </div> <nav role="navigation" aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item active"><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/" class="nav-list-link">Introd. a la prog. y al diseño 3D</a><ul class="nav-list "><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/presentacion/" class="nav-list-link">0. Presentación de la asignatura</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/pensamiento-computacional/" class="nav-list-link">1. Pensamiento computacional</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/representacion-de-la-informacion/" class="nav-list-link">2. Representación de la información</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/introduccion-a-la-programacion/" class="nav-list-link">3. Introducción a la programación</a><ul class="nav-list"></ul></li><li class="nav-list-item active"><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/estructuras-de-datos/" class="nav-list-link active">4. Estructuras de datos</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/lenguaje-php/" class="nav-list-link">5. Lenguaje PHP</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/orientacion-a-objetos/" class="nav-list-link">6. Orientación a objetos</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/entornos-integrados-de-desarrollo/" class="nav-list-link">7. Entornos integrados de desarrollo</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/bases-de-datos/" class="nav-list-link">8. Bases de datos</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/lenguaje-sql/" class="nav-list-link">9. El lenguaje SQL</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/seguridad-y-privacidad/" class="nav-list-link">10. Seguridad y privacidad</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/tecnologias-de-impresion-3d/" class="nav-list-link">11. Tecnologías de impresión 3D</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/modelado-e-impresion-3d/" class="nav-list-link">12. Modelado e impresión 3D</a><ul class="nav-list"></ul></li></ul></li><li class="nav-list-item"><a href="/docs/prog-y-3d/_site/about/" class="nav-list-link">About</a></li></ul> </nav> <footer class="site-footer"> This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll. </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search PROG Y 3D" aria-label="Search PROG Y 3D" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> </div> <div id="main-content-wrap" class="main-content-wrap"> <nav aria-label="Breadcrumb" class="breadcrumb-nav"> <ol class="breadcrumb-nav-list"> <li class="breadcrumb-nav-list-item"><a href="/docs/prog-y-3d/_site/">Introd. a la prog. y al diseño 3D</a></li> <li class="breadcrumb-nav-list-item"><span>4. Estructuras de datos</span></li> </ol> </nav> <div id="main-content" class="main-content" role="main"> <h1 class="no_toc" id="4-estructuras-de-datos"> <a href="#4-estructuras-de-datos" class="anchor-heading" aria-labelledby="4-estructuras-de-datos"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4. Estructuras de datos </h1> <ul id="markdown-toc"> <li><a href="#41-estructuras-de-almacenamiento-de-datos" id="markdown-toc-41-estructuras-de-almacenamiento-de-datos">4.1. Estructuras de almacenamiento de datos</a></li> <li><a href="#42-arrays-unidimensionales-vectores" id="markdown-toc-42-arrays-unidimensionales-vectores">4.2. Arrays unidimensionales (vectores)</a> <ul> <li><a href="#421-declaración-de-vectores" id="markdown-toc-421-declaración-de-vectores">4.2.1. Declaración de vectores</a></li> <li><a href="#422-manipulación-de-elementos-de-un-vector" id="markdown-toc-422-manipulación-de-elementos-de-un-vector">4.2.2. Manipulación de elementos de un vector</a></li> <li><a href="#423-recorrido-de-un-vector" id="markdown-toc-423-recorrido-de-un-vector">4.2.3. Recorrido de un vector</a></li> <li><a href="#424-ordenación-de-vectores" id="markdown-toc-424-ordenación-de-vectores">4.2.4. Ordenación de vectores</a></li> <li><a href="#425-búsqueda-en-vectores" id="markdown-toc-425-búsqueda-en-vectores">4.2.5. Búsqueda en vectores</a></li> </ul> </li> <li><a href="#43-arrays-bidimiensionales-matrices" id="markdown-toc-43-arrays-bidimiensionales-matrices">4.3. Arrays bidimiensionales (matrices)</a></li> <li><a href="#44-arrays-de-múltiples-dimensiones" id="markdown-toc-44-arrays-de-múltiples-dimensiones">4.4. Arrays de múltiples dimensiones</a></li> <li><a href="#45-ejercicios-propuestos" id="markdown-toc-45-ejercicios-propuestos">4.5. Ejercicios propuestos</a></li> <li><a href="#46-ejercicios-resueltos" id="markdown-toc-46-ejercicios-resueltos">4.6. Ejercicios resueltos</a></li> </ul> <p>Hasta ahora, hemos conocido las estructuras de control básicas de cualquier programa estructurado: secuencia, condición e iteración.</p> <p>Pero los programas no se componen solo de <em>instrucciones</em>, sino también de <strong><em>datos</em></strong>.</p> <p>Todos los datos que hemos manejado hasta ahora eran simples, es decir, se almacenaban en variables en las que solo podíamos guardar un valor en cada momento. Las variables simples se nos quedan cortas en muchas ocasiones (repasa el programa de las 3 en raya, sin ir más lejos, para comprobarlo). En esos casos necesitamos una variable de tipo complejo o <strong>estructura de datos</strong>.</p> <p>En este capítulo hablaremos de las estructuras de datos y nos centraremos en la más utilizada con diferencia: el <strong>array</strong>.</p> <p>Después, introduciremos los conceptos de subalgoritmo, función y biblioteca de funciones, para terminar hablando de uno de los principios básicos de la ingeniería del software: la reutilización del código.</p> <h2 id="41-estructuras-de-almacenamiento-de-datos"> <a href="#41-estructuras-de-almacenamiento-de-datos" class="anchor-heading" aria-labelledby="41-estructuras-de-almacenamiento-de-datos"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.1. Estructuras de almacenamiento de datos </h2> <p>Hemos trabajado, por el momento, con los tipos de datos básicos: enteros, reales, caracteres, lógicos… Es el momento de dar el salto a los <strong>tipos de datos complejos</strong>, también llamados <strong>estructuras de datos</strong>.</p> <p>Las estructuras de datos pueden ser de dos tipos:</p> <ul> <li><strong>Estáticas</strong>: son aquellas que ocupan un espacio determinado en la memoria del ordenador. Este espacio es invariable y se especifica durante la escritura del código fuente.</li> <li><strong>Dinámicas</strong>: son aquellas cuyo espacio ocupado en la memoria puede modificarse durante la ejecución del programa.</li> </ul> <p>Existe todo un universo de estructuras de datos: desde los arrays, presentes en casi cualquier programa, hasta estructuras mucho más exóticas como pilas, colas, listas enlazadas, árboles, grafos, etc.</p> <p>Nosotros no pretendemos verlas todas, ni mucho menos, pero sí que conozcas la más importante de todas: el array.</p> <h2 id="42-arrays-unidimensionales-vectores"> <a href="#42-arrays-unidimensionales-vectores" class="anchor-heading" aria-labelledby="42-arrays-unidimensionales-vectores"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.2. Arrays unidimensionales (vectores) </h2> <p>Un <strong>array</strong> (también llamado <strong>arreglo</strong>, sobre todo en América latina) es una <em>agrupación de muchos datos individuales del mismo tipo bajo el mismo nombre</em>. Cada dato individual de un array es accesible mediante un índice.</p> <p>Por ejemplo, un array de números enteros es una colección de muchos números enteros a los que les adjudicamos un único identificador.</p> <p>El caso más simple de array es el <strong>array unidimensional</strong>, también llamado <strong>vector</strong>. Se trata, sin duda, del rey de las estructuras de almacenamiento.</p> <h3 id="421-declaración-de-vectores"> <a href="#421-declaración-de-vectores" class="anchor-heading" aria-labelledby="421-declaración-de-vectores"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.2.1. Declaración de vectores </h3> <p>La <strong>declaración de un vector</strong> en pseudocódigo (seguiremos usando la sintaxis de PSeInt) se hace así:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Definir nombre_variable Como tipo
Dimension nombre_variable[tamaño]
</code></pre></div></div> <p>Por ejemplo:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Definir serie como Entero
Dimension serie[10]
</code></pre></div></div> <p>La variable <em>serie</em> será un vector que contendrá 10 números enteros. Todos los números recibirán el mismo nombre, es decir, <em>serie</em>.</p> <p>Se puede acceder a cada uno de los números que forman el vector escribiendo a continuación del nombre un número entre corchetes. Ese número se denomina <strong>índice</strong>.</p> <p>Observa el siguiente ejemplo:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Definir serie como Entero
Dimension serie[5]
serie[2] &lt;- 20
serie[3] &lt;- 15
serie[4] &lt;- serie[2] + serie[3]
Escribir serie[4]
</code></pre></div></div> <p>El vector <em>serie</em> de este ejemplo puede almacenar hasta 5 números enteros. En su posición 2 se almacena el número 20, y en su posición 3, el 15. Luego se suman ambos valores, y el resultado se almacena en la posición 4. Finalmente, se imprime en la pantalla el resultado de la suma, es decir, 35.</p> <p>Es muy útil representar los vectores de forma gráfica para entenderlos mejor. El vector serie del ejemplo anterior se puede representar así:</p><pre>
            +------------+----+----+----+----+----+
            | Posiciones |  0 |  1 |  2 |  3 |  4 |
    serie = +------------+----+----+----+----+----+
            | Valores    |  ? |  ? | 20 | 15 | 35 |
            +------------+----+----+----+----+----+
</pre><p>Observa algo muy importante: <strong>el primer elemento del vector tiene el índice 0</strong>, es decir, el primer elemento es <strong>serie[0]</strong>.</p> <p>Como este vector tiene 5 elementos, el último será serie[4], no serie[5]. Observa también que los elementos 0 y 1 no han sido utilizados y, por lo tanto, tienen un valor desconocido, exactamente lo mismo que ocurre con cualquier variable de tipo simple que no se inicialice.</p> <p><em>(Nota: PSeInt se puede configurar para que el primer elemento del vector tenga índice 1, no 0, pero, como la mayor parte de los lenguajes de programación reales usan el 0, supondremos que PSeInt también lo está haciendo)</em></p> <p>Como es lógico, se pueden construir vectores cuyos elementos sean de cualquier otro tipo simple, como números reales o caracteres, con la única restricción de que todos los elementos sean del mismo tipo.</p> <p>Y, por supuesto, pueden construirse vectores cuyos elementos sean otros vectores. Obtendremos así un array bidimensional, del que hablaremos un poco más adelante.</p> <h3 id="422-manipulación-de-elementos-de-un-vector"> <a href="#422-manipulación-de-elementos-de-un-vector" class="anchor-heading" aria-labelledby="422-manipulación-de-elementos-de-un-vector"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.2.2. Manipulación de elementos de un vector </h3> <p>Los vectores deben manipularse <strong>elemento a elemento</strong>. <em>No se pueden modificar todos los elementos a la vez.</em></p> <p>Por ejemplo, <strong>para asignar valores a los elementos de un vector</strong>, esta sería la manera:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Definir serie como Entero
Dimension serie[5]
serie[0] &lt;- 5
serie[1] &lt;- 3
serie[2] &lt;- 7
...etc...
</code></pre></div></div> <p>Cada elemento del vector es, a todos los efectos, una variable que puede usarse independientemente de los demás elementos. Así, por ejemplo, un elemento del vector <em>serie</em> puede usarse en una instrucción de salida igual que cualquier variable simple de tipo entero:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Escribir(serie[2])
</code></pre></div></div> <p>Del mismo modo, pueden usarse elementos de un vector en una instrucción de entrada. Por ejemplo:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Escribir "Dime un número entero"
Leer (serie[4])
</code></pre></div></div> <h3 id="423-recorrido-de-un-vector"> <a href="#423-recorrido-de-un-vector" class="anchor-heading" aria-labelledby="423-recorrido-de-un-vector"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.2.3. Recorrido de un vector </h3> <p>La forma habitual de utilizar un vector es <strong>accediendo en secuencia a todos sus elementos</strong>, uno tras otro.</p> <p>Para ello, se utiliza un <strong>bucle con contador</strong>, de modo que la variable contador nos sirve como <strong>índice</strong> para acceder a cada uno de los elementos del vector.</p> <p>Supongamos, por ejemplo, que tenemos un vector de 10 números enteros declarado llamado <em>v</em>, y una variable entera llamada <em>i</em>, que será nuestro índice. Por medio de un bucle, con ligeras modificaciones, podemos realizar todas estas operaciones:</p> <ul> <li> <p><strong>1. Inicializar todos los elementos a un valor cualquiera</strong> (por ejemplo, 0):</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Para i &lt;- 0 hasta 9 hacer
    v[i] &lt;- 0
 FinPara
</code></pre></div> </div> </li> <li> <p><strong>2. Inicializar todos los elementos con valores introducidos por teclado</strong>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Para i &lt;- 0 hasta 9 hacer
    Escribir "Dime el valor del elemento nº ", i
    Leer v[i] 
 FinPara
</code></pre></div> </div> </li> <li> <p><strong>3. Mostrar todos los elementos en la pantalla</strong>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Para i &lt;- 0 hasta 9 hacer
    Escribir "El elemento nº ", i, " vale ", v[i]
 FinPara
</code></pre></div> </div> </li> <li> <p><strong>4. Realizar alguna operación que implique a todos los elementos</strong>. Por ejemplo, sumarlos en un <strong>acumulador</strong>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> suma &lt;- 0
 Para i &lt;- 0 hasta 9 hacer
    suma &lt;- suma + v[i]
 FinPara
 Escribir "La suma de todos los elementos es: ", suma
</code></pre></div> </div> </li> </ul> <h3 id="424-ordenación-de-vectores"> <a href="#424-ordenación-de-vectores" class="anchor-heading" aria-labelledby="424-ordenación-de-vectores"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.2.4. Ordenación de vectores </h3> <p>Otra operación típica que se realiza con vectores es <strong>ordenar sus elementos</strong> mediante algún criterio.</p> <p>Por ejemplo, un vector de números enteros puede ordenarse de menor a mayor (o al revés), mientras que un vector de caracteres puede ordenarse alfabéticamente.</p> <p>Supongamos, por ejemplo, que tenemos un vector de números enteros con estos valores:</p><pre>
+----+----+----+----+----+----+----+----+----+----+
|  0 |  1 |  2 |  3 |  4 |  5 |  3 | 14 |  9 |  8 |
+----+----+----+----+----+----+----+----+----+----+
</pre><p>Después de la ordenación, nos quedará este otro vector:</p><pre>
+----+----+----+----+----+----+----+----+----+----+
|  0 |  1 |  2 |  3 |  3 |  4 |  5 |  8 |  9 | 14 |
+----+----+----+----+----+----+----+----+----+----+
</pre><p>Del mismo modo, se pueden ordenar los elementos con cualquier otro criterio: de mayor a menor, primero los pares y luego los impares, o cualquier otro que nos resulte útil para resolver un problema.</p> <p>Métodos de ordenación de vectores hay muchos, algunos muy simples (e ineficientes) y otros muy elaborados, y constituyen un área de estudio muy interesante dentro de la algorítmica.</p> <p>Aquí vamos a presentar uno de los métodos más sencillos que existen para ordenar un vector, de modo que te resulte fácil entenderlo. Para aprender los métodos más complejos y rápidos ya tendrás tiempo en el futuro, ¿no te parece?</p> <h4 id="ordenación-mediante-selección-directa"> <a href="#ordenación-mediante-selección-directa" class="anchor-heading" aria-labelledby="ordenación-mediante-selección-directa"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ordenación mediante selección directa </h4> <p>La <strong>selección directa</strong> es probablemente el método de ordenación más fácil de entender porque es lo que la mayoría de nosotros haríamos si tuviéramos que ordenar un conjunto de elementos a mano. Esto no quiere decir que sea fácil de programar para un principiante, pero vamos a intentarlo.</p> <p>Vamos a suponer que tratamos de ordenar un vector de números enteros de menor a mayor pero, como hemos dicho, la misma idea podría emplearse para ordenar cualquier otra cosa y mediante cualquier otro criterio.</p> <p>El método de selección directa recorre el vector desde el principio hasta localizar el elemento más pequeño, guardando su posición y su valor en dos variables que llamaremos <em>posicion_minimo</em> y <em>valor_minimo</em>. Al terminar, coloca ese elemento mínimo en la primera posición del vector y lo intercambia con el elemento que antes ocupaba esa primera posición.</p> <p>(Para hacer ese intercambio de valores, es necesario usar una variable auxiliar que llamaremos <em>aux</em>).</p> <p>El proceso se repite, pero ahora desde la <em>segunda</em> posición del vector original. De nuevo volvemos a buscar el elemento más pequeño mirándolos todos de uno en uno. Al terminar, colocamos ese elemento mínimo en la <em>segunda</em> posición del vector, intercambiándola por el número que antes estaba en la segunda posición.</p> <p>Volvemos a hacerlo, ahora desde la <em>tercera</em> posición del vector original, y así sucesivamente hasta terminar de recorrer el vector completo.</p> <p><strong>Observa con detenimiento el código fuente de esta implementación</strong>. No pases por él de puntillas para dedicarte a otra cosa. Dedica unos minutos para tratar de ejecutarlo <em>a mano</em>, es decir, con papel y lápiz, apuntando el valor de las variables para ver cómo actúa el algoritmo y cómo construye, pasada tras pasada, el vector ordenado.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Algoritmo seleccion_directa
	Definir i, j, aux Como Entero
	Definir valor_minimo, posicion_minimo Como Entero
	Definir vector Como Entero
	Dimensión vector[100]
	
	// Primero, vamos a llenar el vector_original con valores al azar entre 1 y 500, por ejemplo
	Para i desde 0 hasta 99 Hacer
		vector[i] &lt;- azar(500)
	FinPara
	
	// Ahora empieza el algoritmo de ordenación por selección directa
	Para i desde 0 hasta 99 Hacer
		valor_minimo &lt;- vector[i]
		posicion_minimo &lt;- i
		Para j desde 0 hasta 99 Hacer
			Si vector[j] &lt; valor_minimo Entonces
				valor_minimo &lt;- vector[j]
				posicion_minimo &lt;- j
			FinSi
		FinPara
		aux &lt;- vector[i]
		vector[i] &lt;- valor_minimo
		vector[posicion_minimo] &lt;- aux
	FinPara
	
	// Por fin, escribimos el vector ordenado para ver que todo ha funcionado bien
	Para i desde 0 hasta 99 Hacer
		Escribir vector[i]
	FinPara
	
FinAlgoritmo
</code></pre></div></div> <h3 id="425-búsqueda-en-vectores"> <a href="#425-búsqueda-en-vectores" class="anchor-heading" aria-labelledby="425-búsqueda-en-vectores"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.2.5. Búsqueda en vectores </h3> <p>En los vectores, como en todas las estructuras de datos que contienen muchos datos en su interior, también es habitual encontrarse con la <strong>operación de búsqueda</strong>.</p> <p>Dado un vector y un dato cualquiera, la búsqueda consiste en determinar si ese dato está en alguna posición del vector y, si es necesario, averiguar cuál es esa posición.</p> <p>La <strong>búsqueda secuencial</strong>, es decir, elemento a elemento, puede llegar a ser muy lenta si el vector es muy grande. Si en un programa tenemos que realizar búsquedas en vectores grandes repetidas veces, debemos pensar el modo de lograr que las búsquedas sean más rápidas.</p> <p>Existe una forma muy simple de hacer una búsqueda en un vector de manera tremendamente rápid: con el método llamado <strong>búsqueda binaria</strong>. Pero la búsqueda binaria tiene un problema: para que funcione, el vector debe estar previamente ordenado. El proceso de ordenación, como acabamos de ver, es lento y costoso, pero, a cambio, obtendremos unos tiempos de búsqueda notablemente mejores.</p> <p>Resumiendo: si necesitamos hacer búsquedas de datos en vectores en algún programa:</p> <ul> <li>Si las búsquedas se realizan pocas veces, o bien los vectores son pequeños, optaremos por la búsqueda secuencial, que no necesita ordenar previamente el vector.</li> <li>Si las busquedas se realizan muchas veces y los vectores son de gran tamaño, optaremos por la búsqueda binaria, pero antes debemos ordenar el vector.</li> </ul> <h4 id="búsqueda-secuencial"> <a href="#búsqueda-secuencial" class="anchor-heading" aria-labelledby="búsqueda-secuencial"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Búsqueda secuencial </h4> <p>Consiste, simplemente, en <strong>recorrer el vector desde el primer elemento hasta el último</strong>.</p> <p>Si encontramos el dato buscado, podemos interrumpir la búsqueda. Si no, continuaremos hasta el final del vector.</p> <p>Esta es una posible implementación en pseudocódigo, suponiendo que el vector tiene 100 elementos. Míralo despacio y ejecuta a mano el algoritmo. ¡Esas ejecuciones con lápiz y papel son un excelente ejercicio para los/las programadores/as principiantes!</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  // Búsqueda secuencial
  // Buscamos el elemento "dato" en el vector "v"
  Definir i, posicion, v como Entero
  Dimension v[100]
  i &lt;- 0
  posicion &lt;- -1
  
  Mientras i &lt; 100 y x = -1 hacer
     Si v[i] = dato  Entonces
        // ¡Lo hemos encontrado!
        x &lt;- i   // Ano
     if (v[i] == dato)	// ¡Lo hemos encontrado!
	  posicion = i       // Anotamos la posición
     i &lt;- i + 1
  FinMientras

  Si x &gt;= 0 Entonces
     Escribir "El dato ", dato, " estaba en la posición ", posicion
  SiNo
     Escribir "No he encontrado el dato ", dato, " en el vector"
  FinSi
</code></pre></div></div> <h4 id="búsqueda-binaria"> <a href="#búsqueda-binaria" class="anchor-heading" aria-labelledby="búsqueda-binaria"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Búsqueda binaria </h4> <p>Para que esta búsqueda funcione, como hemos dicho, <strong>el vector debe estar previamente ordenado</strong>.</p> <p>El <strong>método de búsqueda binaria</strong> consiste en lo siguiente:</p> <ul> <li><strong>Paso 1</strong>. Supongamos que v es el vector y que contiene N elementos. Llamaremos <em>izq</em> a la posición del elemento izquierdo del array (inicialmente, iz = 0). Llamaremos <em>der</em> a la posición del elemento derecho del array (inicialmente, de = N-1)</li> <li><strong>Paso 2</strong>. Tomamos un x igual al punto medio entre izq y der, es decir, x &lt;- (izq/der) / 2</li> <li><strong>Paso 3</strong>. Miramos el elemento v[x]. Si es el dato que buscábamos, ya hemos terminado. Si no, pueden ocurrir dos cosas: <ul> <li><strong>3a</strong>. Que v[x] sea mayor que el dato que buscábamos. En ese caso, y dado que el array está ordenado, continuamos la búsqueda a la izquierda de x, haciendo que der &lt;- x.</li> <li><strong>3b</strong>. Que v[x] sea menor que el dato que buscábamos. En ese caso, continuamos la busqueda a la derecha de x, haciendo izq &lt;- x.</li> </ul> </li> <li><strong>Paso 4</strong>. Repetimos desde el paso 2 hasta que encontremos el elemento buscado o hasta que izq = der (lo que significará que el elemento no está en el vector)</li> </ul> <p>Esta es una posible implementación en pseudocódigo. Recuerda: no mires el código por encima para pasar a otra cosa. Léelo con calma, como si fueran las instrucciones para montar un mueble de Ikea, y ejecútalo con lápiz y papel hasta que te asegures de que entiendes cómo funciona.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Búsqueda binaria.
// Buscamos el elemento "busc" en el vector "v", que debe estar previamente ordenado de menor a mayor.
// Supondremos que "v" es un vector de enteros de 100 elementos, por ejemplo.

   Definir izq, der, mitad, encontrado como Entero

   // Iniciamos una búsqueda binaria
   encontrado &lt;- 0
   izq &lt;- 0    // Primera posición del vector
   der &lt;- 99   // Última posición del vector

   Mientras izq &lt; der-1 y encontrado = 0 Hacer
	   mitad &lt;- izq + ((der - izq) / 2)    // Calculamos la posición "mitad"
      Si v[mitad] = busc Entonces
         // ¡Lo hemos encontrado!
         encontrado &lt;- 1
      FinSi
      Si v[mitad] &gt; busc Entonces
         // Seguiremos buscando por la mitad izquierda
         der &lt;- mitad
      FinSi
      Si v[mitad] &lt; busc Entonces
         // Seguiremos buscando por la mitad derecha
         izq &lt;- mitad
   FinMientras

   Si encontrado = 1 Entonces
      Escribir "El dato ", busc, " está en la posición ", encontrado, " del vector"
   SiNo
      Escribir "El dato ", busc, " no está en el vector"
   FinSi
</code></pre></div></div> <p>Este algoritmo de búsqueda es más complejo que el secuencial, como puede verse, pero los tiempos de búsqueda con el método binario son mucho más pequeños.</p> <p>Para un vector de N elementos, el método secuencial necesita un promedio de N/2 pasos para localizar el elemento buscado, mientras que el método binario tarda una media de log<sub>2</sub>N pasos.</p> <p>¿No te parece una diferencia muy impresionante? Fíjate en estos datos:</p> <ul> <li>Si el vector es pequeño (por ejemplo, N = 10): <ul> <li>a. La búsqueda secuencial necesita una media de 5 pasos.</li> <li>b. La búsqueda binaria necesita una media de 3 pasos.</li> </ul> </li> <li>Si el vector es mediano (por ejemplo, N = 100): <ul> <li>a. La búsqueda secuencial necesita una media de 50 pasos.</li> <li>b. La búsqueda binaria necesita una media de 6 ó 7 pasos.</li> </ul> </li> <li>Si el vector es grande (por ejemplo, N = 1000), la mejora de tiempo empieza a ser notable: <ul> <li>a. La búsqueda secuencial necesita una media de 500 pasos.</li> <li>b. La búsqueda binaria necesita una media de… ¡10 pasos!</li> </ul> </li> <li>Si el vector es muy grande (por ejemplo, N = 100.000), la mejora de tiempo es aún mayor: <ul> <li>a. La búsqueda secuencial necesita una media de 50.000 pasos.</li> <li>b. La búsqueda binaria necesita una media de sólo 16 pasos.</li> </ul> </li> </ul> <p>La mejora en el tiempo de búsqueda es, por lo tanto, mayor cuanto mayor es el vector. Por eso dijimos que la búsqueda binaria se emplea cuando los vectores son muy grandes.</p> <h2 id="43-arrays-bidimiensionales-matrices"> <a href="#43-arrays-bidimiensionales-matrices" class="anchor-heading" aria-labelledby="43-arrays-bidimiensionales-matrices"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.3. Arrays bidimiensionales (matrices) </h2> <p>Una <strong>matriz</strong>, <strong>tabla</strong> o <strong>array bidimiensional</strong>, igual que un vector, es una colección de elementos individuales, todos del mismo tipo, agrupados bajo el mismo identificador.</p> <p>La diferencia con el vector es que, en el momento de declararlo y de acceder a cada elemento individual, debemos utilizar <strong>dos índices</strong> en lugar de uno.</p> <p>Una matriz de, por ejemplo, 4x4 elementos, se declara así:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Definir matriz como Entero
Dimension matriz[4][4]
</code></pre></div></div> <p>La variable <em>matriz</em> no consta de 4 elementos enteros, sino de 16, organizados en 4 filas y 4 columnas. Podemos representar gráficamente la matriz como una tabla:</p><pre>
     Filas
       |
       V
     +----+----+----+----+----+
     |    |  0 |  1 |  2 |  3 |   &lt;-- Columnas
     +----+----+----+----+----+
     |  0 |    |    |    |    |
     +----+----+----+----+----+
     |  1 |    |    |    |    |
     +----+----+----+----+----+
     |  2 |    |    |    |    |
     +----+----+----+----+----+
     |  3 |    |    |    |    |
     +----+----+----+----+----+
</pre><p><strong>Cada casilla de la matriz es identificable mediante una pareja de índices</strong>. Normalmente, el primero de los índices se refiere a la fila y, el segundo, a la columna.</p> <p>Por ejemplo, si hacemos estas asignaciones:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>matriz[0][0] &lt;- 5
matriz[1][0] &lt;- 1
matriz[3][2] &lt;- 13
</code></pre></div></div> <p>…el estado en el que quedará la matriz anterior será este:</p><pre>
     Filas
       |
       V
     +----+----+----+----+----+
     |    |  0 |  1 |  2 |  3 |   &lt;-- Columnas
     +----+----+----+----+----+
     |  0 |  5 |    |    |    |
     +----+----+----+----+----+
     |  1 |  1 |    |    |    |
     +----+----+----+----+----+
     |  2 |    |    |    |    |
     +----+----+----+----+----+
     |  3 |    |    | 13 |    |
     +----+----+----+----+----+
</pre><p>Por descontado, los dos tamaños de la matriz pueden ser diferentes, obteniéndose tablas que son más anchas que altas o más altas que anchas.</p> <p>Por lo demás, <strong>las matrices se utilizan exactamente igual que los vectores</strong>. A modo de ejemplo, este sería el código para inicializar una matriz de 5x10 enteros con todos sus elementos a 0. Observa cómo se usan los dos bucles anidados para acceder a todos los elementos:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Definir i, j como Entero
Definir m como Entero
Dimension m[5][10]

Para i &lt;- 0 hasta 4 hacer
   Para j &lt;- 0 hasta 9 hacer
       m[i][j] &lt;- 0
   FinPara
FinPara
</code></pre></div></div> <h2 id="44-arrays-de-múltiples-dimensiones"> <a href="#44-arrays-de-múltiples-dimensiones" class="anchor-heading" aria-labelledby="44-arrays-de-múltiples-dimensiones"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.4. Arrays de múltiples dimensiones </h2> <p>Del mismo modo que a los arrays unidimensionales (vectores) se les puede añadir un segundo índice, obteniendo las matrices, se puede generalizar esta práctica, dando lugar a <strong>arrays multidimensionales</strong>.</p> <p>Por ejemplo, el siguiente es un array de cinco dimensiones compuesto de números enteros:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Definir ejemplo como Entero
Dimension Ejemplo[10][10][4][5][7];
</code></pre></div></div> <p>Estos arrays no se pueden representar gráficamente (aunque con los de tres dimensiones se puede intentar dibujar un cubo), pero su utilización es idéntica a la de los arrays de una o dos dimensiones.</p> <h2 id="45-ejercicios-propuestos"> <a href="#45-ejercicios-propuestos" class="anchor-heading" aria-labelledby="45-ejercicios-propuestos"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.5. Ejercicios propuestos </h2> <h4 id="ejercicios-de-vectores-arrays-unidimensionales"> <a href="#ejercicios-de-vectores-arrays-unidimensionales" class="anchor-heading" aria-labelledby="ejercicios-de-vectores-arrays-unidimensionales"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ejercicios de vectores (arrays unidimensionales) </h4> <p><strong>Ejercicio 1: Inicializar un vector</strong>. Escribe un programa en pseudocódigo en el que se defina un vector de 100 números enteros, se inicialicen todos los elementos al valor –1 y se impriman por pantalla.</p> <p><strong>Ejercicio 2: Inicializar un vector (más complejo)</strong>. Define dos vectores de 100 números enteros, uno llamado <em>pares</em> y otro <em>impares</em>. Inicializa el primero con los 100 primeros números pares positivos (es decir, pares[0] contendrá el valor 2, pares[1] contendrá el valor 4, pares[2] contendrá el valor 6, y así sucesivamente). Inicializa el segundo con los 100 primeros números impares positivos. Imprímelo por pantalla para comprobar que lo has hecho correctamente.</p> <p><strong>Ejercicio 3: Lotería primitiva</strong>. Escribe un programa que genere al azar una combinación para jugar a la lotería primitiva asegurándote de que ningún número se repite. Pista: puedes utilizar un array de 6 números enteros, asignando a cada posición un número entero aleatorio entre 1 y 49, y comprobando que el número asignado no es igual a ninguno de los asignados anteriormente.</p> <p><strong>Ejercicio 4. Estadística básica</strong>. Escribe un programa que pida al usuario N números enteros (siendo N un valor introducido por teclado) y calcule el valor medio de todos ellos, mostrando luego en la pantalla los números que están por encima de la media y los que están por debajo de ella.</p> <p><strong>Ejercicio 5. Ordenar vector gigante</strong>. Escribe un programa que defina un vector de 1000 elementos y lo inicialice con valores aleatorios entre 0 y 2.000.000. Posteriormente, el programa debe ordenar los elementos del array de menor a mayor. Prueba luego a cambiar el tamaño del vector hasta los 10.000, 100.000 y 1.000.000 de elementos. ¿El tiempo de respuesta del programa crece linealmente con el tamaño del vector?</p> <p><strong>Ejercicio 6. Vector creciente</strong>. Escribe un programa que defina un vector de 10 enteros y lo rellene con números CRECIENTES al azar entre 1 y 100. Es decir, los números serán elegidos aleatoriamente pero siempre tienen que ser mayores que los anteriores: el número que ocupe la posición 1 debe ser mayor que el de la posición 0, el de la posición 2 mayor que el de la 1, y así sucesivamente.</p> <p>Después de eso, se pedirá al usuario un número entre 1 y el número mayor que exista en el vector. El número introducido por el usuario se insertará en la posición del vector adecuada para conservar el orden, desplazando los demás elementos hacia la derecha, de manera que se pierda el último elemento.</p> <p>Después de insertar el número introducido por el usuario, el contenido del vector debe mostrarse por la pantalla. El proceso se repetirá hasta que el usuario introduzca un número negativo.</p> <p>Por ejemplo, supongamos que el array generado al azar por el ordenador, después de ordenarlo, es este:</p><pre>
     4 – 18 – 23 – 25 – 44 - 45 – 51 – 72 – 78 - 85
</pre><p>Como el número más alto es 85, el programa debe pedir al usuario:</p><pre>
     Introduzca un número entre 1 y 85: _
</pre><p>Si el usuario teclea, por ejemplo, el número 67, éste debe ser insertado en la posición adecuada para conservar el orden, es decir, entre los números 51 y 72, desplazando a los demás números hacia la derecha, con lo cual se pierde el mayor de todos ellos (85). El vector quedaría así:</p><pre>
    4 – 18 – 23 – 25 – 44 - 45 – 51 – 67 - 72 – 78
</pre><h4 id="ejercicios-de-matrices-arrays-bidimensionales"> <a href="#ejercicios-de-matrices-arrays-bidimensionales" class="anchor-heading" aria-labelledby="ejercicios-de-matrices-arrays-bidimensionales"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ejercicios de matrices (arrays bidimensionales) </h4> <p><strong>Ejercicio 7. Inicializar matriz simple</strong>. Escribe un programa en el que se defina una matriz de 10x10 números enteros. Inicializa todos los elementos al valor –1.</p> <p><strong>Ejercicio 8. Inicializar matriz complejo</strong>. Repite el ejercicio anterior, inicializando ahora todas las filas pares al valor 0 y todas las filas impares al valor –1.</p> <p><strong>Ejercicio 9. Sumar filas</strong>. Escribe un programa que defina una matriz de 6x3 números enteros y luego pida al usuario que introduzca los valores de cada elemento. Después, el programa debe sumar los tres números de cada fila, mostrando los resultados.</p> <p><strong>Ejercicio 10. Permutar filas</strong>. Escribe un programa que defina una matriz de 3x5 números enteros y luego pida al usuario que introduzca los valores de cada elemento. Después, debe permutar el contenido de la fila 3 por el de la fila 1, y mostrar por último el contenido de la matriz.</p> <p><strong>Ejercicio 11. Sumar matrices</strong>. Escribe un programa que defina dos matrices de 10x5 números enteros y las inicialice con números aleatorios entre 0 y 255. Posteriormente, cada elemento de la primera matriz debe ser sumado con el mismo elemento de la segunda matriz, guardando el resultado en una tercera matriz. Se deben sumar todas las parejas de elementos y mostrar el resultado en la pantalla.</p> <p><strong>Ejercicio 12. Jugueteando con matrices</strong>. Escribe un programa que genere al azar una matriz cuadrada de NxN números enteros (siendo N un valor introducido por el usuario) y que luego haga lo siguiente:</p> <ul> <li> <p><em>Mostrar</em>. Mostrará la matriz tal y como ha sido generada.</p> </li> <li> <p><em>Perímetro</em>. Mostrará los elementos que ocupan el borde de la matriz, partiendo de la esquina superior izquierda y recorriéndola hacia la derecha y luego hacia abajo.</p> </li> <li> <p><em>Centro</em>. Mostrará los elementos que ocupan el centro geométrico de la matriz. Puede ser 1 (si N es impar) o 4 (si N es par).</p> </li> <li> <p><em>Espiral</em>. Hará un recorrido en espiral por la matriz partiendo de la esquina superior izquierda.</p> </li> </ul> <p>Por ejemplo, si la matriz fuera de 4x4 y tuviera este contenido:</p><pre>
    4 6 7 8
    2 4 3 9
    0 1 3 4
    7 3 3 5
</pre><p>…las distintas operaciones deben obtener este resultado:</p> <ul> <li>Perímetro: 4 6 7 8 9 4 5 3 3 7 0 2</li> <li>Centro: 4 3 1 3</li> <li>Espiral: 4 6 7 8 9 4 5 3 3 7 0 2 4 3 3 1</li> </ul> <h2 id="46-ejercicios-resueltos"> <a href="#46-ejercicios-resueltos" class="anchor-heading" aria-labelledby="46-ejercicios-resueltos"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.6. Ejercicios resueltos </h2> <p>(Iremos poniendo aquí los ejercicios resueltos en clase)</p> <hr> <h2 class="text-delta">Table of contents</h2> <ul> </ul> </div> </div> <div class="search-overlay"></div> </div> </body> </html>
