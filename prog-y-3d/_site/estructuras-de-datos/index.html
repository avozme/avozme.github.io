<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <title>4. Estructuras de datos. Subalgoritmos - PROG Y 3D</title> <link rel="shortcut icon" href="/docs/prog-y-3d/_site/favicon.ico" type="image/x-icon"> <link rel="stylesheet" href="/docs/prog-y-3d/_site/assets/css/just-the-docs-default.css"> <script type="text/javascript" src="/docs/prog-y-3d/_site/assets/js/vendor/lunr.min.js"></script> <script type="text/javascript" src="/docs/prog-y-3d/_site/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.7.1 --> <title>Estructuras de datos. Subalgoritmos | PROG Y 3D</title> <meta name="generator" content="Jekyll v4.2.0" /> <meta property="og:title" content="Estructuras de datos. Subalgoritmos" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Apuntes de la asignatura “Introducción a la programación y al diseño 3D”, optativa de 2º curso de bachillerato ofertada por el IES Celia Viñas de Almería (España)" /> <meta property="og:description" content="Apuntes de la asignatura “Introducción a la programación y al diseño 3D”, optativa de 2º curso de bachillerato ofertada por el IES Celia Viñas de Almería (España)" /> <link rel="canonical" href="/docs/prog-y-3d/_site/estructuras-de-datos/" /> <meta property="og:url" content="/docs/prog-y-3d/_site/estructuras-de-datos/" /> <meta property="og:site_name" content="PROG Y 3D" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Estructuras de datos. Subalgoritmos" /> <script type="application/ld+json"> {"@type":"WebPage","url":"/docs/prog-y-3d/_site/estructuras-de-datos/","headline":"Estructuras de datos. Subalgoritmos","description":"Apuntes de la asignatura “Introducción a la programación y al diseño 3D”, optativa de 2º curso de bachillerato ofertada por el IES Celia Viñas de Almería (España)","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> </head> <body> <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header"> <a href="/docs/prog-y-3d/_site/" class="site-title lh-tight"> PROG Y 3D </a> <a href="#" id="menu-button" class="site-button"> <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg> </a> </div> <nav role="navigation" aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item active"><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/" class="nav-list-link">Introd. a la prog. y al diseño 3D</a><ul class="nav-list "><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/presentacion/" class="nav-list-link">0. Presentación de la asignatura</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/pensamiento-computacional/" class="nav-list-link">1. Pensamiento computacional</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/representacion-de-la-informacion/" class="nav-list-link">2. Representación de la información</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/introduccion-a-la-programacion/" class="nav-list-link">3. Introducción a la programación</a><ul class="nav-list"></ul></li><li class="nav-list-item active"><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/estructuras-de-datos/" class="nav-list-link active">4. Estructuras de datos. Subalgoritmos</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/javascript/" class="nav-list-link">5. Lenguaje Javascript</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/orientacion-a-objetos/" class="nav-list-link">6. Orientación a objetos</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/entornos-integrados-de-desarrollo/" class="nav-list-link">7. Entornos integrados de desarrollo</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/bases-de-datos/" class="nav-list-link">8. Bases de datos</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/lenguaje-sql/" class="nav-list-link">9. El lenguaje SQL</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/seguridad-y-privacidad/" class="nav-list-link">10. Seguridad y privacidad</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/tecnologias-de-impresion-3d/" class="nav-list-link">11. Tecnologías de impresión 3D</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/modelado-e-impresion-3d/" class="nav-list-link">12. Modelado e impresión 3D</a><ul class="nav-list"></ul></li></ul></li><li class="nav-list-item"><a href="/docs/prog-y-3d/_site/about/" class="nav-list-link">About</a></li></ul> </nav> <footer class="site-footer"> This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll. </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search PROG Y 3D" aria-label="Search PROG Y 3D" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> </div> <div id="main-content-wrap" class="main-content-wrap"> <nav aria-label="Breadcrumb" class="breadcrumb-nav"> <ol class="breadcrumb-nav-list"> <li class="breadcrumb-nav-list-item"><a href="/docs/prog-y-3d/_site/">Introd. a la prog. y al diseño 3D</a></li> <li class="breadcrumb-nav-list-item"><span>4. Estructuras de datos. Subalgoritmos</span></li> </ol> </nav> <div id="main-content" class="main-content" role="main"> <h1 class="no_toc" id="4-estructuras-de-datos-subalgoritmos"> <a href="#4-estructuras-de-datos-subalgoritmos" class="anchor-heading" aria-labelledby="4-estructuras-de-datos-subalgoritmos"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4. Estructuras de datos. Subalgoritmos </h1> <ul id="markdown-toc"> <li><a href="#41-estructuras-de-almacenamiento-de-datos" id="markdown-toc-41-estructuras-de-almacenamiento-de-datos">4.1. Estructuras de almacenamiento de datos</a></li> <li><a href="#42-arrays-unidimensionales-vectores" id="markdown-toc-42-arrays-unidimensionales-vectores">4.2. Arrays unidimensionales (vectores)</a> <ul> <li><a href="#421-declaración-de-vectores" id="markdown-toc-421-declaración-de-vectores">4.2.1. Declaración de vectores</a></li> <li><a href="#422-manipulación-de-elementos-de-un-vector" id="markdown-toc-422-manipulación-de-elementos-de-un-vector">4.2.2. Manipulación de elementos de un vector</a></li> <li><a href="#423-recorrido-de-un-vector" id="markdown-toc-423-recorrido-de-un-vector">4.2.3. Recorrido de un vector</a></li> <li><a href="#424-ordenación-de-vectores" id="markdown-toc-424-ordenación-de-vectores">4.2.4. Ordenación de vectores</a></li> <li><a href="#425-búsqueda-en-vectores" id="markdown-toc-425-búsqueda-en-vectores">4.2.5. Búsqueda en vectores</a></li> </ul> </li> <li><a href="#43-arrays-bidimiensionales-matrices" id="markdown-toc-43-arrays-bidimiensionales-matrices">4.3. Arrays bidimiensionales (matrices)</a></li> <li><a href="#44-arrays-de-múltiples-dimensiones" id="markdown-toc-44-arrays-de-múltiples-dimensiones">4.4. Arrays de múltiples dimensiones</a></li> <li><a href="#45-programación-modular-subalgoritmos" id="markdown-toc-45-programación-modular-subalgoritmos">4.5. Programación modular: subalgoritmos</a> <ul> <li><a href="#451-algoritmo-principal-y-subalgoritmos" id="markdown-toc-451-algoritmo-principal-y-subalgoritmos">4.5.1. Algoritmo principal y subalgoritmos</a></li> <li><a href="#452-funciones" id="markdown-toc-452-funciones">4.5.2. Funciones</a></li> <li><a href="#453--procedimientos" id="markdown-toc-453--procedimientos">4.5.3. Procedimientos</a></li> <li><a href="#454-invocación-de-subalgoritmos" id="markdown-toc-454-invocación-de-subalgoritmos">4.5.4. Invocación de subalgoritmos</a></li> <li><a href="#455-paso-de-parámetros" id="markdown-toc-455-paso-de-parámetros">4.5.5. Paso de parámetros</a></li> <li><a href="#456-ámbito-de-las-variables" id="markdown-toc-456-ámbito-de-las-variables">4.5.6. Ámbito de las variables</a></li> <li><a href="#457-reutilización-de-código" id="markdown-toc-457-reutilización-de-código">4.5.7. Reutilización de código</a></li> </ul> </li> <li><a href="#46-el-estilo-de-escritura" id="markdown-toc-46-el-estilo-de-escritura">4.6. El estilo de escritura</a> <ul> <li><a href="#461-partes-de-un-algoritmo" id="markdown-toc-461-partes-de-un-algoritmo">4.6.1. Partes de un algoritmo</a></li> <li><a href="#462-documentación" id="markdown-toc-462-documentación">4.6.2. Documentación</a></li> <li><a href="#463-convenciones-de-escritura" id="markdown-toc-463-convenciones-de-escritura">4.6.3. Convenciones de escritura</a></li> </ul> </li> <li><a href="#46-ejercicios-propuestos" id="markdown-toc-46-ejercicios-propuestos">4.6. Ejercicios propuestos</a></li> <li><a href="#47-ejercicios-resueltos" id="markdown-toc-47-ejercicios-resueltos">4.7. Ejercicios resueltos</a></li> </ul> <p>Hasta ahora, hemos conocido las estructuras de control básicas de cualquier programa estructurado: secuencia, condición e iteración.</p> <p>Pero los programas no se componen solo de <em>instrucciones</em>, sino también de <strong><em>datos</em></strong>.</p> <p>Todos los datos que hemos manejado hasta ahora eran simples, es decir, se almacenaban en variables en las que solo podíamos guardar un valor en cada momento. Las variables simples se nos quedan cortas en muchas ocasiones (repasa el programa de las 3 en raya, sin ir más lejos, para comprobarlo). En esos casos necesitamos una variable de tipo complejo o <strong>estructura de datos</strong>.</p> <p>En este capítulo hablaremos de las estructuras de datos y nos centraremos en la más utilizada con diferencia: el <strong>array</strong>.</p> <p>Después, introduciremos los conceptos de <strong>subalgoritmo, función y biblioteca de funciones</strong>, para terminar hablando de uno de los principios básicos de la ingeniería del software: la <strong>reutilización del código</strong>.</p> <h2 id="41-estructuras-de-almacenamiento-de-datos"> <a href="#41-estructuras-de-almacenamiento-de-datos" class="anchor-heading" aria-labelledby="41-estructuras-de-almacenamiento-de-datos"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.1. Estructuras de almacenamiento de datos </h2> <p>Hemos trabajado, por el momento, con los tipos de datos básicos: enteros, reales, caracteres, lógicos… Es el momento de dar el salto a los <strong>tipos de datos complejos</strong>, también llamados <strong>estructuras de datos</strong>.</p> <p>Las estructuras de datos pueden ser de dos tipos:</p> <ul> <li><strong>Estáticas</strong>: son aquellas que ocupan un espacio determinado en la memoria del ordenador. Este espacio es invariable y se especifica durante la escritura del código fuente.</li> <li><strong>Dinámicas</strong>: son aquellas cuyo espacio ocupado en la memoria puede modificarse durante la ejecución del programa.</li> </ul> <p>Existe todo un universo de estructuras de datos: desde los arrays, presentes en casi cualquier programa, hasta estructuras mucho más exóticas como pilas, colas, listas enlazadas, árboles, grafos, etc.</p> <p>Nosotros no pretendemos verlas todas, ni mucho menos, pero sí que conozcas la más importante de todas: el array.</p> <h2 id="42-arrays-unidimensionales-vectores"> <a href="#42-arrays-unidimensionales-vectores" class="anchor-heading" aria-labelledby="42-arrays-unidimensionales-vectores"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.2. Arrays unidimensionales (vectores) </h2> <p>Un <strong>array</strong> (también llamado <strong>arreglo</strong>, sobre todo en América latina) es una <em>agrupación de muchos datos individuales del mismo tipo bajo el mismo nombre</em>. Cada dato individual de un array es accesible mediante un índice.</p> <p>Por ejemplo, un array de números enteros es una colección de muchos números enteros a los que les adjudicamos un único identificador.</p> <p>El caso más simple de array es el <strong>array unidimensional</strong>, también llamado <strong>vector</strong>. Se trata, sin duda, del rey de las estructuras de almacenamiento.</p> <h3 id="421-declaración-de-vectores"> <a href="#421-declaración-de-vectores" class="anchor-heading" aria-labelledby="421-declaración-de-vectores"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.2.1. Declaración de vectores </h3> <p>La <strong>declaración de un vector</strong> en pseudocódigo (seguiremos usando la sintaxis de PSeInt) se hace así:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Definir nombre_variable Como tipo
Dimension nombre_variable[tamaño]
</code></pre></div></div> <p>Por ejemplo:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Definir serie como Entero
Dimension serie[10]
</code></pre></div></div> <p>La variable <em>serie</em> será un vector que contendrá 10 números enteros. Todos los números recibirán el mismo nombre, es decir, <em>serie</em>.</p> <p>Se puede acceder a cada uno de los números que forman el vector escribiendo a continuación del nombre un número entre corchetes. Ese número se denomina <strong>índice</strong>.</p> <p>Observa el siguiente ejemplo:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Definir serie como Entero
Dimension serie[5]
serie[2] &lt;- 20
serie[3] &lt;- 15
serie[4] &lt;- serie[2] + serie[3]
Escribir serie[4]
</code></pre></div></div> <p>El vector <em>serie</em> de este ejemplo puede almacenar hasta 5 números enteros. En su posición 2 se almacena el número 20, y en su posición 3, el 15. Luego se suman ambos valores, y el resultado se almacena en la posición 4. Finalmente, se imprime en la pantalla el resultado de la suma, es decir, 35.</p> <p>Es muy útil representar los vectores de forma gráfica para entenderlos mejor. El vector serie del ejemplo anterior se puede representar así:</p><pre>
            +------------+----+----+----+----+----+
            | Posiciones |  0 |  1 |  2 |  3 |  4 |
    serie = +------------+----+----+----+----+----+
            | Valores    |  ? |  ? | 20 | 15 | 35 |
            +------------+----+----+----+----+----+
</pre><p>Observa algo muy importante: <strong>el primer elemento del vector tiene el índice 0</strong>, es decir, el primer elemento es <strong>serie[0]</strong>.</p> <p>Como este vector tiene 5 elementos, el último será serie[4], no serie[5]. Observa también que los elementos 0 y 1 no han sido utilizados y, por lo tanto, tienen un valor desconocido, exactamente lo mismo que ocurre con cualquier variable de tipo simple que no se inicialice.</p> <p><em>(Nota: PSeInt se puede configurar para que el primer elemento del vector tenga índice 1, no 0, pero, como la mayor parte de los lenguajes de programación reales usan el 0, supondremos que PSeInt también lo está haciendo)</em></p> <p>Como es lógico, se pueden construir vectores cuyos elementos sean de cualquier otro tipo simple, como números reales o caracteres, con la única restricción de que todos los elementos sean del mismo tipo.</p> <p>Y, por supuesto, pueden construirse vectores cuyos elementos sean otros vectores. Obtendremos así un array bidimensional, del que hablaremos un poco más adelante.</p> <h3 id="422-manipulación-de-elementos-de-un-vector"> <a href="#422-manipulación-de-elementos-de-un-vector" class="anchor-heading" aria-labelledby="422-manipulación-de-elementos-de-un-vector"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.2.2. Manipulación de elementos de un vector </h3> <p>Los vectores deben manipularse <strong>elemento a elemento</strong>. <em>No se pueden modificar todos los elementos a la vez.</em></p> <p>Por ejemplo, <strong>para asignar valores a los elementos de un vector</strong>, esta sería la manera:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Definir serie como Entero
Dimension serie[5]
serie[0] &lt;- 5
serie[1] &lt;- 3
serie[2] &lt;- 7
...etc...
</code></pre></div></div> <p>Cada elemento del vector es, a todos los efectos, una variable que puede usarse independientemente de los demás elementos. Así, por ejemplo, un elemento del vector <em>serie</em> puede usarse en una instrucción de salida igual que cualquier variable simple de tipo entero:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Escribir(serie[2])
</code></pre></div></div> <p>Del mismo modo, pueden usarse elementos de un vector en una instrucción de entrada. Por ejemplo:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Escribir "Dime un número entero"
Leer (serie[4])
</code></pre></div></div> <h3 id="423-recorrido-de-un-vector"> <a href="#423-recorrido-de-un-vector" class="anchor-heading" aria-labelledby="423-recorrido-de-un-vector"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.2.3. Recorrido de un vector </h3> <p>La forma habitual de utilizar un vector es <strong>accediendo en secuencia a todos sus elementos</strong>, uno tras otro.</p> <p>Para ello, se utiliza un <strong>bucle con contador</strong>, de modo que la variable contador nos sirve como <strong>índice</strong> para acceder a cada uno de los elementos del vector.</p> <p>Supongamos, por ejemplo, que tenemos un vector de 10 números enteros declarado llamado <em>v</em>, y una variable entera llamada <em>i</em>, que será nuestro índice. Por medio de un bucle, con ligeras modificaciones, podemos realizar todas estas operaciones:</p> <ul> <li> <p><strong>1. Inicializar todos los elementos a un valor cualquiera</strong> (por ejemplo, 0):</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Para i &lt;- 0 hasta 9 hacer
    v[i] &lt;- 0
 FinPara
</code></pre></div> </div> </li> <li> <p><strong>2. Inicializar todos los elementos con valores introducidos por teclado</strong>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Para i &lt;- 0 hasta 9 hacer
    Escribir "Dime el valor del elemento nº ", i
    Leer v[i] 
 FinPara
</code></pre></div> </div> </li> <li> <p><strong>3. Mostrar todos los elementos en la pantalla</strong>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Para i &lt;- 0 hasta 9 hacer
    Escribir "El elemento nº ", i, " vale ", v[i]
 FinPara
</code></pre></div> </div> </li> <li> <p><strong>4. Realizar alguna operación que implique a todos los elementos</strong>. Por ejemplo, sumarlos en un <strong>acumulador</strong>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> suma &lt;- 0
 Para i &lt;- 0 hasta 9 hacer
    suma &lt;- suma + v[i]
 FinPara
 Escribir "La suma de todos los elementos es: ", suma
</code></pre></div> </div> </li> </ul> <h3 id="424-ordenación-de-vectores"> <a href="#424-ordenación-de-vectores" class="anchor-heading" aria-labelledby="424-ordenación-de-vectores"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.2.4. Ordenación de vectores </h3> <p>Otra operación típica que se realiza con vectores es <strong>ordenar sus elementos</strong> mediante algún criterio.</p> <p>Por ejemplo, un vector de números enteros puede ordenarse de menor a mayor (o al revés), mientras que un vector de caracteres puede ordenarse alfabéticamente.</p> <p>Supongamos, por ejemplo, que tenemos un vector de números enteros con estos valores:</p><pre>
+----+----+----+----+----+----+----+----+----+----+
|  0 |  1 |  2 |  3 |  4 |  5 |  3 | 14 |  9 |  8 |
+----+----+----+----+----+----+----+----+----+----+
</pre><p>Después de la ordenación, nos quedará este otro vector:</p><pre>
+----+----+----+----+----+----+----+----+----+----+
|  0 |  1 |  2 |  3 |  3 |  4 |  5 |  8 |  9 | 14 |
+----+----+----+----+----+----+----+----+----+----+
</pre><p>Del mismo modo, se pueden ordenar los elementos con cualquier otro criterio: de mayor a menor, primero los pares y luego los impares, o cualquier otro que nos resulte útil para resolver un problema.</p> <p>Métodos de ordenación de vectores hay muchos, algunos muy simples (e ineficientes) y otros muy elaborados, y constituyen un área de estudio muy interesante dentro de la algorítmica.</p> <p>Aquí vamos a presentar uno de los métodos más sencillos que existen para ordenar un vector, de modo que te resulte fácil entenderlo. Para aprender los métodos más complejos y rápidos ya tendrás tiempo en el futuro, ¿no te parece?</p> <h4 id="ordenación-mediante-selección-directa"> <a href="#ordenación-mediante-selección-directa" class="anchor-heading" aria-labelledby="ordenación-mediante-selección-directa"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ordenación mediante selección directa </h4> <p>La <strong>selección directa</strong> es probablemente el método de ordenación más fácil de entender porque es lo que la mayoría de nosotros haríamos si tuviéramos que ordenar un conjunto de elementos a mano. Esto no quiere decir que sea fácil de programar para un principiante, pero vamos a intentarlo.</p> <p>Vamos a suponer que tratamos de ordenar un vector de números enteros de menor a mayor pero, como hemos dicho, la misma idea podría emplearse para ordenar cualquier otra cosa y mediante cualquier otro criterio.</p> <p>El método de selección directa recorre el vector desde el principio hasta localizar el elemento más pequeño, guardando su posición y su valor en dos variables que llamaremos <em>posicion_minimo</em> y <em>valor_minimo</em>. Al terminar, coloca ese elemento mínimo en la primera posición del vector y lo intercambia con el elemento que antes ocupaba esa primera posición.</p> <p>(Para hacer ese intercambio de valores, es necesario usar una variable auxiliar que llamaremos <em>aux</em>).</p> <p>El proceso se repite, pero ahora desde la <em>segunda</em> posición del vector original. De nuevo volvemos a buscar el elemento más pequeño mirándolos todos de uno en uno. Al terminar, colocamos ese elemento mínimo en la <em>segunda</em> posición del vector, intercambiándola por el número que antes estaba en la segunda posición.</p> <p>Volvemos a hacerlo, ahora desde la <em>tercera</em> posición del vector original, y así sucesivamente hasta terminar de recorrer el vector completo.</p> <p><strong>Observa con detenimiento el código fuente de esta implementación</strong>. No pases por él de puntillas para dedicarte a otra cosa. Dedica unos minutos para tratar de ejecutarlo <em>a mano</em>, es decir, con papel y lápiz, apuntando el valor de las variables para ver cómo actúa el algoritmo y cómo construye, pasada tras pasada, el vector ordenado.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Algoritmo seleccion_directa
	Definir i, j, aux Como Entero
	Definir valor_minimo, posicion_minimo Como Entero
	Definir vector Como Entero
	Dimensión vector[100]
	
	// Primero, vamos a llenar el vector_original con valores al azar entre 1 y 500, por ejemplo
	Para i desde 0 hasta 99 Hacer
		vector[i] &lt;- azar(500)
	FinPara
	
	// Ahora empieza el algoritmo de ordenación por selección directa
	Para i desde 0 hasta 99 Hacer
		valor_minimo &lt;- vector[i]
		posicion_minimo &lt;- i
		Para j desde 0 hasta 99 Hacer
			Si vector[j] &lt; valor_minimo Entonces
				valor_minimo &lt;- vector[j]
				posicion_minimo &lt;- j
			FinSi
		FinPara
		aux &lt;- vector[i]
		vector[i] &lt;- valor_minimo
		vector[posicion_minimo] &lt;- aux
	FinPara
	
	// Por fin, escribimos el vector ordenado para ver que todo ha funcionado bien
	Para i desde 0 hasta 99 Hacer
		Escribir vector[i]
	FinPara
	
FinAlgoritmo
</code></pre></div></div> <h3 id="425-búsqueda-en-vectores"> <a href="#425-búsqueda-en-vectores" class="anchor-heading" aria-labelledby="425-búsqueda-en-vectores"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.2.5. Búsqueda en vectores </h3> <p>En los vectores, como en todas las estructuras de datos que contienen muchos datos en su interior, también es habitual encontrarse con la <strong>operación de búsqueda</strong>.</p> <p>Dado un vector y un dato cualquiera, la búsqueda consiste en determinar si ese dato está en alguna posición del vector y, si es necesario, averiguar cuál es esa posición.</p> <p>La <strong>búsqueda secuencial</strong>, es decir, elemento a elemento, puede llegar a ser muy lenta si el vector es muy grande. Si en un programa tenemos que realizar búsquedas en vectores grandes repetidas veces, debemos pensar el modo de lograr que las búsquedas sean más rápidas.</p> <p>Existe una forma muy simple de hacer una búsqueda en un vector de manera tremendamente rápid: con el método llamado <strong>búsqueda binaria</strong>. Pero la búsqueda binaria tiene un problema: para que funcione, el vector debe estar previamente ordenado. El proceso de ordenación, como acabamos de ver, es lento y costoso, pero, a cambio, obtendremos unos tiempos de búsqueda notablemente mejores.</p> <p>Resumiendo: si necesitamos hacer búsquedas de datos en vectores en algún programa:</p> <ul> <li>Si las búsquedas se realizan pocas veces, o bien los vectores son pequeños, optaremos por la búsqueda secuencial, que no necesita ordenar previamente el vector.</li> <li>Si las busquedas se realizan muchas veces y los vectores son de gran tamaño, optaremos por la búsqueda binaria, pero antes debemos ordenar el vector.</li> </ul> <h4 id="búsqueda-secuencial"> <a href="#búsqueda-secuencial" class="anchor-heading" aria-labelledby="búsqueda-secuencial"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Búsqueda secuencial </h4> <p>Consiste, simplemente, en <strong>recorrer el vector desde el primer elemento hasta el último</strong>.</p> <p>Si encontramos el dato buscado, podemos interrumpir la búsqueda. Si no, continuaremos hasta el final del vector.</p> <p>Esta es una posible implementación en pseudocódigo, suponiendo que el vector tiene 100 elementos. Míralo despacio y ejecuta a mano el algoritmo. ¡Esas ejecuciones con lápiz y papel son un excelente ejercicio para los/las programadores/as principiantes!</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  // Búsqueda secuencial
  // Buscamos el elemento "dato" en el vector "v"
  Definir i, posicion, v como Entero
  Dimension v[100]
  i &lt;- 0
  posicion &lt;- -1               // Si posición vale -1 significa que
                               // aún no hemos encontrado lo que buscamos
  
  Mientras i &lt; 100 y posicion = -1 hacer
     Si v[i] = dato  Entonces  // ¡Lo hemos encontrado!
        posicion &lt;- i         // Anotamos la posición
     FinSi
     i &lt;- i + 1
  FinMientras

  Si posicion &gt;= 0 Entonces
     Escribir "El dato ", dato, " estaba en la posición ", posicion
  SiNo
     Escribir "No he encontrado el dato ", dato, " en el vector"
  FinSi
</code></pre></div></div> <h4 id="búsqueda-binaria"> <a href="#búsqueda-binaria" class="anchor-heading" aria-labelledby="búsqueda-binaria"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Búsqueda binaria </h4> <p>Para que esta búsqueda funcione, como hemos dicho, <strong>el vector debe estar previamente ordenado</strong>.</p> <p>El <strong>método de búsqueda binaria</strong> consiste en lo siguiente:</p> <ul> <li><strong>Paso 1</strong>. Supongamos que v es el vector y que contiene N elementos. Llamaremos <em>izq</em> a la posición del elemento izquierdo del array (inicialmente, izq = 0). Llamaremos <em>der</em> a la posición del elemento derecho del array (inicialmente, der = N-1)</li> <li><strong>Paso 2</strong>. Tomamos un x igual al punto medio entre izq y der, es decir, x &lt;- (izq/der) / 2</li> <li><strong>Paso 3</strong>. Miramos el elemento v[x]. Si es el dato que buscábamos, ya hemos terminado. Si no, pueden ocurrir dos cosas: <ul> <li><strong>3a</strong>. Que v[x] sea mayor que el dato que buscábamos. En ese caso, y dado que el array está ordenado, continuamos la búsqueda a la izquierda de x, haciendo que der &lt;- x.</li> <li><strong>3b</strong>. Que v[x] sea menor que el dato que buscábamos. En ese caso, continuamos la busqueda a la derecha de x, haciendo izq &lt;- x.</li> </ul> </li> <li><strong>Paso 4</strong>. Repetimos desde el paso 2 hasta que encontremos el elemento buscado o hasta que izq = der (lo que significará que el elemento no está en el vector)</li> </ul> <p>Esta es una posible implementación en pseudocódigo. Recuerda: no mires el código por encima para pasar a otra cosa. Léelo con calma, como si fueran las instrucciones para montar un mueble de Ikea, y ejecútalo con lápiz y papel hasta que te asegures de que entiendes cómo funciona.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Búsqueda binaria.
// Buscamos el elemento "busc" en el vector "v", que debe estar previamente ordenado de menor a mayor.
// Supondremos que "v" es un vector de enteros de 100 elementos, por ejemplo.

   Definir izq, der, mitad, encontrado como Entero

   // Iniciamos una búsqueda binaria
   encontrado &lt;- 0
   izq &lt;- 0    // Primera posición del vector
   der &lt;- 99   // Última posición del vector

   Mientras izq &lt; der-1 y encontrado = 0 Hacer
      mitad &lt;- izq + ((der - izq) / 2)    // Calculamos la posición "mitad"
      Si v[mitad] = busc Entonces
         // ¡Lo hemos encontrado!
         encontrado &lt;- 1
      FinSi
      Si v[mitad] &gt; busc Entonces
         // Seguiremos buscando por la mitad izquierda
         der &lt;- mitad
      FinSi
      Si v[mitad] &lt; busc Entonces
         // Seguiremos buscando por la mitad derecha
         izq &lt;- mitad
   FinMientras

   Si encontrado = 1 Entonces
      Escribir "El dato ", busc, " está en la posición ", encontrado, " del vector"
   SiNo
      Escribir "El dato ", busc, " no está en el vector"
   FinSi
</code></pre></div></div> <p>Este algoritmo de búsqueda es más complejo que el secuencial, como puede verse, pero los tiempos de búsqueda con el método binario son mucho más pequeños.</p> <p>Para un vector de N elementos, el método secuencial necesita un promedio de N/2 pasos para localizar el elemento buscado, mientras que el método binario tarda una media de log<sub>2</sub>N pasos.</p> <p>¿No te parece una diferencia muy impresionante? Fíjate en estos datos:</p> <ul> <li>Si el vector es pequeño (por ejemplo, N = 10): <ul> <li>a. La búsqueda secuencial necesita una media de 5 pasos.</li> <li>b. La búsqueda binaria necesita una media de 3 pasos.</li> </ul> </li> <li>Si el vector es mediano (por ejemplo, N = 100): <ul> <li>a. La búsqueda secuencial necesita una media de 50 pasos.</li> <li>b. La búsqueda binaria necesita una media de 6 ó 7 pasos.</li> </ul> </li> <li>Si el vector es grande (por ejemplo, N = 1000), la mejora de tiempo empieza a ser notable: <ul> <li>a. La búsqueda secuencial necesita una media de 500 pasos.</li> <li>b. La búsqueda binaria necesita una media de… ¡10 pasos!</li> </ul> </li> <li>Si el vector es muy grande (por ejemplo, N = 100.000), la mejora de tiempo es aún mayor: <ul> <li>a. La búsqueda secuencial necesita una media de 50.000 pasos.</li> <li>b. La búsqueda binaria necesita una media de sólo 16 pasos.</li> </ul> </li> </ul> <p>La mejora en el tiempo de búsqueda es, por lo tanto, mayor cuanto mayor es el vector. Por eso dijimos que la búsqueda binaria se emplea cuando los vectores son muy grandes.</p> <h2 id="43-arrays-bidimiensionales-matrices"> <a href="#43-arrays-bidimiensionales-matrices" class="anchor-heading" aria-labelledby="43-arrays-bidimiensionales-matrices"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.3. Arrays bidimiensionales (matrices) </h2> <p>Una <strong>matriz</strong>, <strong>tabla</strong> o <strong>array bidimiensional</strong>, igual que un vector, es una colección de elementos individuales, todos del mismo tipo, agrupados bajo el mismo identificador.</p> <p>La diferencia con el vector es que, en el momento de declararlo y de acceder a cada elemento individual, debemos utilizar <strong>dos índices</strong> en lugar de uno.</p> <p>Una matriz de, por ejemplo, 4x4 elementos, se declara así:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Definir matriz como Entero
Dimension matriz[4][4]
</code></pre></div></div> <p>La variable <em>matriz</em> no consta de 4 elementos enteros, sino de 16, organizados en 4 filas y 4 columnas. Podemos representar gráficamente la matriz como una tabla:</p><pre>
     Filas
       |
       V
     +----+----+----+----+----+
     |    |  0 |  1 |  2 |  3 |   &lt;-- Columnas
     +----+----+----+----+----+
     |  0 |    |    |    |    |
     +----+----+----+----+----+
     |  1 |    |    |    |    |
     +----+----+----+----+----+
     |  2 |    |    |    |    |
     +----+----+----+----+----+
     |  3 |    |    |    |    |
     +----+----+----+----+----+
</pre><p><strong>Cada casilla de la matriz es identificable mediante una pareja de índices</strong>. Normalmente, el primero de los índices se refiere a la fila y, el segundo, a la columna.</p> <p>Por ejemplo, si hacemos estas asignaciones:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>matriz[0][0] &lt;- 5
matriz[1][0] &lt;- 1
matriz[3][2] &lt;- 13
</code></pre></div></div> <p>…el estado en el que quedará la matriz anterior será este:</p><pre>
     Filas
       |
       V
     +----+----+----+----+----+
     |    |  0 |  1 |  2 |  3 |   &lt;-- Columnas
     +----+----+----+----+----+
     |  0 |  5 |    |    |    |
     +----+----+----+----+----+
     |  1 |  1 |    |    |    |
     +----+----+----+----+----+
     |  2 |    |    |    |    |
     +----+----+----+----+----+
     |  3 |    |    | 13 |    |
     +----+----+----+----+----+
</pre><p>Por descontado, los dos tamaños de la matriz pueden ser diferentes, obteniéndose tablas que son más anchas que altas o más altas que anchas.</p> <p>Por lo demás, <strong>las matrices se utilizan exactamente igual que los vectores</strong>. A modo de ejemplo, este sería el código para inicializar una matriz de 5x10 enteros con todos sus elementos a 0. Observa cómo se usan los dos bucles anidados para acceder a todos los elementos:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Definir i, j como Entero
Definir m como Entero
Dimension m[5][10]

Para i &lt;- 0 hasta 4 hacer
   Para j &lt;- 0 hasta 9 hacer
       m[i][j] &lt;- 0
   FinPara
FinPara
</code></pre></div></div> <h2 id="44-arrays-de-múltiples-dimensiones"> <a href="#44-arrays-de-múltiples-dimensiones" class="anchor-heading" aria-labelledby="44-arrays-de-múltiples-dimensiones"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.4. Arrays de múltiples dimensiones </h2> <p>Del mismo modo que a los arrays unidimensionales (vectores) se les puede añadir un segundo índice, obteniendo las matrices, se puede generalizar esta práctica, dando lugar a <strong>arrays multidimensionales</strong>.</p> <p>Por ejemplo, el siguiente es un array de cinco dimensiones compuesto de números enteros:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Definir ejemplo como Entero
Dimension ejemplo[10][10][4][5][7];
</code></pre></div></div> <p>Estos arrays no se pueden representar gráficamente (aunque con los de tres dimensiones se puede intentar dibujar un cubo), pero su utilización es idéntica a la de los arrays de una o dos dimensiones.</p> <h2 id="45-programación-modular-subalgoritmos"> <a href="#45-programación-modular-subalgoritmos" class="anchor-heading" aria-labelledby="45-programación-modular-subalgoritmos"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.5. Programación modular: subalgoritmos </h2> <p>Los algoritmos tienden a hacerse muy grandes cuando tratamos de resolver un problema complejo. Esto es lógico, ¿no te parece? Cuanto más complicado sea el problema, más difícil y largo será plantear su solución.</p> <p>Para enfrentar este hecho inevitable existe la <strong>programación modular</strong>. Consiste en algo tan simple como dividir el problema en subproblemas más sencillos, y estos a su vez en otros más sencillos, hasta que tengamos un conjunto de mucho problemas pequeñitos que sí podemos resolver individualmente de forma simple. Después, solo nos queda unir todas las piezas del puzle para obtener nuestra solución compleja.</p> <p>Cada una de esas soluciones a pequeños problemas se denomina <strong>subalgoritmo</strong> (no es un nombre muy original, lo sé). Y esta técnica de descomposición sucesiva en problemas complejos en subproblemas simples se conoce como <strong>divide y vencerás</strong> (<em>divide and conquer</em>, en inglés). Es muy útil no solo en programación, sino en la mayor parte de los problemas del mundo real.</p> <h3 id="451-algoritmo-principal-y-subalgoritmos"> <a href="#451-algoritmo-principal-y-subalgoritmos" class="anchor-heading" aria-labelledby="451-algoritmo-principal-y-subalgoritmos"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.5.1. Algoritmo principal y subalgoritmos </h3> <p>El problema principal siempre se resuelve en un algoritmo que denominaremos <strong>algoritmo principal</strong>. Este es el que hará de “pegamento” del puzle.</p> <p>Los subproblemas más sencillos se resolverán en <strong>subalgoritmos</strong>, también llamados <strong>módulos</strong> a secas. Los subalgoritmos están subordinados al algoritmo principal, de manera que éste es el que decide cuándo debe ejecutarse cada subalgoritmo y con qué conjunto de datos.</p> <p>El algoritmo principal realiza <strong>llamadas</strong> o <strong>invocaciones</strong> a los subalgoritmos, mientras que estos le devuelven resultados. Así, el algoritmo principal va recogiendo todos los resultados y puede generar la solución al problema global.</p> <p>Cuando el algoritmo principal hace una llamada al subalgoritmo (es decir, lo invoca), se empiezan a ejecutar las instrucciones del subalgoritmo. Cuando este termina, la ejecución continúa por la instrucción siguiente a la de invocación. También se dice que el subalgoritmo devuelve el control al algoritmo principal, ya que éste toma de nuevo el control del flujo de instrucciones después de habérselo cedido temporalmente al subalgoritmo.</p> <p>El programa principal puede invocar a cada subalgoritmo el número de veces que sea necesario. A su vez, cada subalgoritmo puede invocar a otros subalgoritmos, y éstos a otros, etc. Cada subalgoritmo devolverá el control al algoritmo que lo invocó.</p> <p>Lógicamente, <strong>los subalgoritmos deben tener asignado un nombre</strong> para que puedan ser invocados desde el algoritmo principal. Ahora bien, la forma de declarar un subalgoritmo varía ligeramente según el tipo de subalgoritmo de que se trate. Porque existen dos tipos de subalgoritmo, llamados <strong>funciones</strong> y <strong>procedimientos</strong>, que vamos a ver enseguida.</p> <h3 id="452-funciones"> <a href="#452-funciones" class="anchor-heading" aria-labelledby="452-funciones"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.5.2. Funciones </h3> <p>Las <strong>funciones</strong> son subalgoritmos que resuelven un problema sencillo y <strong>devuelven un resultado</strong> al algoritmo que las invoca. Esto último es lo que las distingue de los procedimientos.</p> <p>Las funciones pueden tener argumentos, aunque no es obligatorio. Los <strong>argumentos</strong> son los datos que se proporcionan a la función en la invocación, y que la función utilizará para sus cálculos.</p> <p>Las funciones tienen, obligatoriamente, que devolver un resultado. Si no lo hacen, no son funciones. Este resultado suele almacenarse en una variable para usarlo posteriormente.</p> <p>Veamos un ejemplo. Nuevamente, emplearemos la sintaxis del pseudocódigo de PSeInt, pero cualquier otro pseudocódigo o lenguaje de programación real utilizará una sintaxis semejante.</p> <p>Supongamos que tenemos estamos escribiendo un programa para calcular los precios de unos artículos a la venta en una tienda. Vamos a escribir un subalgoritmo que se encargue de calcular el IVA de cada artículo.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Algoritmo precios
	Definir nombre como cadena
	Definir precio como real
	Definir precio_con_iva como real
	
	Repetir
	Escribir "Dime el nombre de otro artículo:"
		Leer nombre
		Escribir "Dime su precio (negativo para terminar):"
		Leer precio
		precio_con_iva &lt;- precio + calcular_iva(precio)
		Escribir "El precio con IVA es ", precio_con_iva
	Hasta Que precio &lt; 0
FinAlgoritmo

SubAlgoritmo iva &lt;- calcular_iva(precio)
	Definir porcentaje como real
	Definir iva como real
	iva &lt;-  precio * 0.21   // Suponemos que el IVA es el 21%
FinSubalgoritmo
</code></pre></div></div> <p>En este ejemplo puedes ver cómo <strong>se declara un subalgoritmo</strong>:</p> <ul> <li>Se utiliza la palabra <strong>SubAlgoritmo</strong></li> <li>Se indica a continuación cuál es el dato que devolverá al algoritmo principal (en este caso, la variable <em>iva</em>)</li> <li>Luego se indica su nombre, <em>calcular_iva</em> y, entre paréntesis, los datos que recibirá del algoritmo principal (en este ejemplo, <em>precio</em>). Esos datos se denominan <em>parámetros</em> del subalgoritmo.</li> <li>Después se escribe el código del subalgoritmo. Fíjate en que es un código completamente normal, como el de cualquier algoritmo.</li> </ul> <p>Los lenguajes de programación, de hecho, poseen un puñado de funciones predefinidas de las que ya hemos usado unas cuántas. ¿Recuerdas cuando usabas las funciones azar(), truncar() o redondear()? No son más que funciones, es decir, subalgoritmos, que ya vienen incorporados al lenguaje de programación.</p> <h3 id="453--procedimientos"> <a href="#453--procedimientos" class="anchor-heading" aria-labelledby="453--procedimientos"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.5.3. Procedimientos </h3> <p>Los <strong>procedimientos</strong> son subalgoritmos que no devuelven ningún valor al algoritmo principal. Es decir, sin como las funciones, pero no devuelven ninguna variable al terminar.</p> <p>La declaración de un procedimiento es similar a la de una función. Lo vemos en este ejemplo, sacado el juego de las 3 en raya del tema anterior. Si repasas aquel ejercicio resuelto, verás que está lleno de procedimientos.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Algoritmo tres_en_raya
	Definir tablero Como Caracter
	Dimension tablero[10]
	
	inicializar(tablero)
	mostrar(tablero)
   // Etc (el juego de las tres en raya continuaba a partir de aquí)
FinAlgoritmo

SubAlgoritmo inicializar(tablero por referencia) 
	Definir i como entero
	Para i &lt;- 1 hasta 9 Hacer
		tablero[i] &lt;- " "
	FinPara
FinSubAlgoritmo

SubAlgoritmo mostrar(tablero)
	Escribir "ESTADO ACTUAL DEL TABLERO"
	Escribir "+---+---+---+"
	Escribir "| ",tablero[1]," | ",tablero[2]," | ",tablero[3]," |"
	Escribir "+---+---+---+"
	Escribir "| ",tablero[4]," | ",tablero[5]," | ",tablero[6]," |"
	Escribir "+---+---+---+"
	Escribir "| ",tablero[7]," | ",tablero[8]," | ",tablero[9]," |"
	Escribir "+---+---+---+"	
FinSubAlgoritmo
</code></pre></div></div> <p>Este algoritmo principal invoca a dos procedimientos: uno, llamado <em>inicializar()</em>, se encarga de poner un espacio en blanco en cada posición del tablero. Otro, llamado <em>mostrar()</em>, se encarga de dibujar el tablero en la pantalla. Como ves, cada subalgoritmo tiene el encargo de resolver una pequeña parte del problema global.</p> <p>Fíjate en que la declaración de los procedimientos es idéntica a la de las funciones, pero sin devolver ninguna variable.</p> <h3 id="454-invocación-de-subalgoritmos"> <a href="#454-invocación-de-subalgoritmos" class="anchor-heading" aria-labelledby="454-invocación-de-subalgoritmos"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.5.4. Invocación de subalgoritmos </h3> <p>Para que las instrucciones escritas en un subalgoritmo sean ejecutadas es necesario, como ya hemos dicho, que el subalgoritmo se <em>llame</em> o <em>invoque</em> desde otro algoritmo.</p> <p>La invocación consiste en una mención al <strong>nombre del subalgoritmo</strong> seguida, entre paréntesis, de los <strong>valores que se desan asignar a los parámetros</strong>. Deben aparecer tantos valores como parámetros tenga el subalgoritmo, y además coincidir en el tipo de datos.</p> <p>Estos parámetros se podrán utilizar, dentro del subalgoritmo, como cualquier otra variable.</p> <p>Como las funciones devuelven valores, la <strong>invocación de una función</strong> debe aparecer a la derecha de una <strong>instrucción de asignación</strong>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>precio_con_iva &lt;- precio + calcular_iva(precio)
</code></pre></div></div> <p>En cambio, como los procedimientos no devuelven ningún valor, la <strong>invocación de un procedimiento</strong> nunca aparece en una instrucción de asignación:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>inicializar(tablero)
mostrar(tablero)
</code></pre></div></div> <h3 id="455-paso-de-parámetros"> <a href="#455-paso-de-parámetros" class="anchor-heading" aria-labelledby="455-paso-de-parámetros"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.5.5. Paso de parámetros </h3> <p>El paso de parámetros, o comunicación de datos del algoritmo invocante al subalgoritmo invocado, puede hacerse mediante, al menos, dos métodos:</p> <ul> <li><strong>Paso de parámetros por valor</strong>, que es la forma más sencilla pero no permite al subalgoritmo devolver resultados en los parámetros.</li> <li><strong>Paso de parámetros por referencia</strong>, que es más complejo pero permite a los subalgoritmos devolver resultados en los parámetros.</li> </ul> <p>Veamos cada método detenidamente.</p> <h4 id="paso-de-parámetros-por-valor"> <a href="#paso-de-parámetros-por-valor" class="anchor-heading" aria-labelledby="paso-de-parámetros-por-valor"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Paso de parámetros por valor </h4> <p>Los subalgoritmos, como hemos visto, pueden tener una serie de parámetros en su declaración. Estos parámetros se denominan <strong>parámetros formales</strong>.</p> <p>Por ejemplo, imaginemos un subalgoritmo llamado <em>potencia()</em> que calcula la potencia de dos números enteros que llamaremos <em>base</em> y <em>exponente</em>. Ese subalgoritmo se declararía así:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SubAlgoritmo potencia(base, exponente)
</code></pre></div></div> <p>En esta declaración, <em>base</em> y <em>exponente</em> son los <strong>parámetros formales</strong>.</p> <p>Cuando el subalgoritmo es invocado, se le pasan entre paréntesis los valores de los parámetros. A éstos se les denomina <strong>parámetros actuales</strong>; por ejemplo:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a &lt;- 5
b &lt;- 3
potencia(a,b)
</code></pre></div></div> <p>En esta invocación de la función potencia(), los <strong>parámetros actuales</strong> son a y b, es decir, 5 y 3.</p> <p>Al invocar un subalgritmo, <em>los parámetros actuales son asignados a los parámetros formales en el mismo orden en el que fueron escritos</em>.</p> <p>Dentro del subalgoritmo, los parámetros se pueden utilizar como si fueran variables. Así, en el ejemplo anterior, dentro de la función <em>potencia()</em>, el parámetro <em>base</em> puede usarse como una variable a la que se hubiera asignado el valor 5, mientras que <em>exponente</em> es como una variable a la que se hubiera asignado el valor 3.</p> <p>Cuando el subalgoritmo termina de ejecutarse, sus parámetros formales base y exponente <strong>dejan de existir</strong>.</p> <h4 id="paso-de-parámetros-por-referencia"> <a href="#paso-de-parámetros-por-referencia" class="anchor-heading" aria-labelledby="paso-de-parámetros-por-referencia"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Paso de parámetros por referencia </h4> <p>En el paso de parámetros por referencia se produce una <strong>ligadura entre el parámetro actual y el parámetro formal</strong>, de modo que si el parámetro formal se modifica dentro del subalgoritmo, <em>el parámetro actual, propio del algoritmo principal, también será modificado</em>.</p> <p>Los argumentos siempre se pasan por valor excepto cuando indiquemos explícitamente que el paso es por referencia colocando el símbolo.</p> <p>Por ejemplo:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SubAlgoritmo potencia(base, exponente, resultado por referencia)
   resultado = base ^ exponente
FinSubAlgoritmo
</code></pre></div></div> <p>Observa cómo el parámetro <em>resultado</em> está pasado por referencia. Ahora veamos cómo se invoca a este subalgoritmo:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a &lt;- 5
b &lt;- 3
c &lt;- 0
potencia(a, b, c)
</code></pre></div></div> <p>En este caso, pasamos tres parámetros actuales, ya que el subalgoritmo tiene tres parámetros formales. El tercero de ellos, llamado c, se pasa por referencia, y por lo tanto queda ligado al parámetro formal <em>resultado</em>.</p> <p>El parámetro formal es modificado en la instrucción <code class="language-plaintext highlighter-rouge">resutado = base ^ exponente</code>, y como está ligado con el parámetro actual c, el valor de la variable c también se modifica. Por lo tanto, c toma el valor 125.</p> <p>Cuando el subalgoritmo termina de ejecutarse, dejan de existir todos sus parámetros formales (base, exponente y resultado), <em>pero la ligadura de resultado con la variable c hace que esta variable conserve el valor 125</em> incluso cuando el parámetro resultado ya no exista.</p> <h3 id="456-ámbito-de-las-variables"> <a href="#456-ámbito-de-las-variables" class="anchor-heading" aria-labelledby="456-ámbito-de-las-variables"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.5.6. Ámbito de las variables </h3> <h4 id="variables-locales"> <a href="#variables-locales" class="anchor-heading" aria-labelledby="variables-locales"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Variables locales </h4> <p>Se llama <strong>ámbito de una variable</strong> a la parte de un programa donde dicha variable puede utilizarse.</p> <p>En la mayoría de los lenguajes, las variables declaradas en un algoritmo son <strong>locales</strong> a ese algoritmo, es decir, no existen fuera del algoritmo y, por tanto, no pueden utilizarse más allá de sus fronteras.</p> <p>Cuando el algoritmo comienza, las variables se crean, reservándose un espacio en la memoria RAM del ordenador para almacenar su valor. Cuando el algoritmo termina, todas sus variables se destruyen, liberándose el espacio en la memoria RAM.</p> <p>Todos los resultados que un algoritmo obtenga durante su ejecución, por lo tanto, se perderán al finalizar, salvo que sean devueltos al algoritmo que lo invocó o sean dirigidos a algún dispositivo de salida (como la pantalla).</p> <h4 id="variables-globales"> <a href="#variables-globales" class="anchor-heading" aria-labelledby="variables-globales"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Variables globales </h4> <p>En ocasiones, es conveniente utilizar variables cuyo ámbito exceda el del algoritmo donde se definen y puedan utilizarse en varios algoritmos y subalgoritmos. Esas variables se denominan <strong>globales</strong>.</p> <p>Las variables globales son bombas de relojería en potencia. Pueden paracer objetos atractivos y útiles a primera vista, pero antes o después te explotarán en la cara. Si alguna vez sientes la tentación de usar variables globales para algo, es mejor que te sientes y esperes a que se te pasen.</p> <p>Si, aún así, estás convencido/a de que necesitas usar alguna variable global, debes saber que todos los lenguajes proporcionan algún mecanismo para crearlas, generalmente indicando durante su declaración que esa variable es de ámbito global.</p> <h3 id="457-reutilización-de-código"> <a href="#457-reutilización-de-código" class="anchor-heading" aria-labelledby="457-reutilización-de-código"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.5.7. Reutilización de código </h3> <p>El diseño de un algoritmo mediante divide y vencerás tiene, además de la ventaja evidente de poder afrontar problemas de gran tamaño, otra ventaja adicional: la posibilidad de <strong>reutilizar subalgoritmos previamente escritos</strong>.</p> <p>Es habitual que, una vez resuelto un problema sencillo mediante una función o un procedimiento, ese mismo problema, o uno muy parecido, se nos presente más adelante, durante la realización de otro programa. Entonces nos bastará con volver a utilizar esa función o procedimiento, sin necesidad de volver a escribirlo.</p> <p>Es por esto, entre otras razones, que <strong>los subalgoritmos deben ser lo más independientes y autónomos posible</strong>.</p> <p>Es habitual agrupar varios subalgoritmos relacionados (por ejemplo: varios algoritmos que realicen diferentes operaciones matemáticas) en un mismo archivo, formando lo que se denomina una <strong>biblioteca</strong> (<em>libraries</em>, en inglés). Cada lenguaje trata las bibliotecas de manera distinta.</p> <p>Por último, señalemos que, para reutilizar con éxito el código, es importante que esté bien documentado. En concreto, en cada algoritmo deberíamos documentar claramente:</p> <ul> <li>La función del algoritmo, es decir, explicar qué hace</li> <li>Los parámetros de entrada, si los hay</li> <li>Los datos de salida, es decir, el resultado que devuelve o la forma de utilizar los parámetros por referencia</li> </ul> <h2 id="46-el-estilo-de-escritura"> <a href="#46-el-estilo-de-escritura" class="anchor-heading" aria-labelledby="46-el-estilo-de-escritura"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.6. El estilo de escritura </h2> <p>No podemos finalizar estos temas de introducción sin referirnos a algunas <strong>reglas de estilo básicas</strong> que deben observarse a la hora de escribir código fuente. Y es que la escritura de un algoritmo debe ser siempre lo más clara posible, ya se esté escribiendo en pseudocódigo o en un lenguaje de programación real.</p> <p>La razón es evidente: los algoritmos pueden llegar a ser muy complejos, y si a su complejidad le añadimos una escritura sucia y desordenada, se volverán ininteligibles.</p> <p>Todos los programadores han experimentado la frustración que se siente al ir a revisar un algoritmo redactado pocos días antes y no entender ni una palabra de lo que uno mismo escribió.</p> <p>Por esta razón, y ya desde el principio, debemos acostumbrarnos a respetar ciertas reglas básicas en cuanto al estilo de escritura. Por supuesto, un programa puede funcionar correctamente sin aplicar ninguna de las cosas que vamos a mencionar aquí, pero no es a la corrección a lo que nos referimos ahora, sino al estilo.</p> <h3 id="461-partes-de-un-algoritmo"> <a href="#461-partes-de-un-algoritmo" class="anchor-heading" aria-labelledby="461-partes-de-un-algoritmo"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.6.1. Partes de un algoritmo </h3> <p>Los algoritmos deberían tener siempre una estructura en tres partes:</p> <ol> <li>Cabecera: contiene el nombre del programa o algoritmo.</li> <li>Declaraciones: contiene la declaración de las variables.</li> <li>Acciones: contiene las instrucciones del algoritmo.</li> </ol> <h3 id="462-documentación"> <a href="#462-documentación" class="anchor-heading" aria-labelledby="462-documentación"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.6.2. Documentación </h3> <p>La expresión “documentación de un programa” se refiere, en realidad, a dos tipos muy distintos de documentación:</p> <ul> <li>La <strong>documentación externa</strong>, formada por todos los documentos ajenos al programa: guías de instalación, guías de usuario, manuales de referencia, manuales técnicos, etc.</li> <li>La <strong>documentación interna</strong> es la que se incluye en el propio código programa. Está formada por los comentarios del código fuente.</li> </ul> <p>Los <strong>comentarios</strong> del código fuente deben ser significativos.</p> <p>Se dice que el código fuente perfecto es aquel que no necesita ningún comentario adicional, porque se explica suficientemente bien a sí mismo y puede leerse sin necesidad de aclaraciones adicionales.</p> <p>Esto es un escenario utópico que nunca se da en la realidad, pero debemos programar con la vista puesta en él. Nuestro código debe ser lo más claro y autoexplicativo posible. Cuando no lo logremos, debemos acompañarlo de comentarios que expliquen lo que el código hace y faciliten su comprensión y mantenimiento posterior.</p> <p>Cada algoritmo, además, debería ir precedido de un comentario que explique lo que ese algoritmo hace. En los subalgoritmos, además, deberían añadirse a ese comentario otros que indiquen cuales son los parámetros de entrada (si existen) y cual es el valor devuelto (si es el caso).</p> <p>En PSeInt, los comentarios se escriben con una doble barra inclinada (//) al comienzo del mismo. Cada lenguaje de programación tiene su propio estilo de comentarios y deberás curiosear un poco en los manuales para averiguarlo cuando vayas a programar en un lenguaje de programación nuevo.</p> <h3 id="463-convenciones-de-escritura"> <a href="#463-convenciones-de-escritura" class="anchor-heading" aria-labelledby="463-convenciones-de-escritura"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.6.3. Convenciones de escritura </h3> <p>Se considera una buena práctica de programación seguir ciertas normas de escritura en el código fuente.</p> <p>Del mismo modo que al escribir en lenguaje natural no solo respetamos la ortografía y la sintaxis (o, al menos, deberíamos hacerlo), sino que también usamos signos de puntuación, dejamos márgenes a ambos lados y procuramos no hacer tachones para que el texto luzca bien y sea cómodo de leer (o, al menos, también deberíamos hacerlo), al escribir en un lenguaje de programación hay ciertas convenciones que no son imprescindibles pero sí muy recomendables.</p> <h4 id="sangrías"> <a href="#sangrías" class="anchor-heading" aria-labelledby="sangrías"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Sangrías </h4> <p>Las instrucciones que aparezcan dentro de un bloque deben tener una sangría mayor que las de apertura y cierre de ese bloque.</p> <p>Por ejemplo, las instrucciones que hay dentro de un bucle <code class="language-plaintext highlighter-rouge">Mientras ... FinMientras</code> deberían estar más sangradas que las propias instrucciones <code class="language-plaintext highlighter-rouge">Mientras</code> y <code class="language-plaintext highlighter-rouge">FinMientras</code>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Mientras condición hacer
   Instrucción 1
   Instrucción 2
   ...
   Instrucción N
FinMientras
</code></pre></div></div> <p>Esto es aplicable a cualquier bloque: <code class="language-plaintext highlighter-rouge">Algoritmo ... FinAlgoritmo</code>, <code class="language-plaintext highlighter-rouge">Para ... FinPara</code>, <code class="language-plaintext highlighter-rouge">Si ... SiNo ... FinSi</code>, etc. En particular, este último caso, que puede llevar un bloque <code class="language-plaintext highlighter-rouge">SiNo</code> de forma optativa, se escribe así (fíjate bien en la sangría izquierda):</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Si condición Entonces
   Instrucciones
SiNo
   Otras Instrucciones
FinSi
</code></pre></div></div> <p>Si hay un bloque anidado dentro de otro, el bloque más interno se sangrará aún más que el bloque precedente. Por ejemplo:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Mientras i &lt; 10 Hacer
   Leer n
   Si n &gt; 0 Entonces
      i &lt;- i + n
   SiNo
      i &lt;- i - n
   FinSi
FinMientras
</code></pre></div></div> <h4 id="espacios"> <a href="#espacios" class="anchor-heading" aria-labelledby="espacios"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Espacios </h4> <p>Algo que aumenta la legibilidad del código es <strong>espaciar suficientemente</strong> (pero no demasiado) los distintos elementos de cada instrucción. Por ejemplo, esta instrucción ya es bastante complicada y difícil de leer:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>si (a &gt; b) y (c &gt; d * raiz(k) ) entonces a &lt;- k + 5.7 * b
</code></pre></div></div> <p>Pero se lee mucho mejor que esta otra, en la que se han suprimido los espacios (excepto los imprescindibles):</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>si (a&gt;b)y(c&gt;d*raiz(k))entonces a&lt;-k+5.7*b
</code></pre></div></div> <p>Al ordenador le dará igual si escribimos <code class="language-plaintext highlighter-rouge">(a &gt; b)</code> o <code class="language-plaintext highlighter-rouge">(a&gt;b)</code>, pero a cualquier programador que deba leer nuestro código le resultará mucho más cómoda la primera forma.</p> <p>Por la misma razón, también es conveniente dejar líneas en blanco entre determinadas instrucciones del algoritmo cuando se considere que mejora la legibilidad.</p> <h4 id="identificadores"> <a href="#identificadores" class="anchor-heading" aria-labelledby="identificadores"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Identificadores </h4> <p>A la hora de elegir identificadores de variables (o de algoritmos y subalgoritmos) es muy importante utilizar <strong>nombres que sean significativos</strong>, es decir, que den una idea de la información que almacena esa variable.</p> <p>Por ejemplo, si en un programa de nóminas vamos a guardar en una variable la edad de los empleados, es una buena ocurrencia llamar a esa variable “edad”, pero no llamarla “x”, “a” o “cosa”.</p> <p>Ahora bien, dentro de esta política de elegir identificadores significativos, es conveniente optar por aquellos que sean lo más cortos posible, siempre que sean descifrables. Un identificador llamado “edad_de_los_empleados” es engorroso de escribir y leer, sobre todo si aparece muchas veces en el algoritmo, cuando probablemente “edad_empl” proporciona la misma información. Sin embargo, si lo acortamos demasiado (por ejemplo “ed_em”) llegará un momento en el no quede claro lo que significa.</p> <p>Toda esta idea de significación de los identificadores es extensible a los nombres de los algoritmos, de las funciones, de los procedimientos, de los archivos y, en general, de todos los objetos relacionados con un programa.</p> <p>Por último, señalar que muchos lenguajes de programación distinguen entre mayúsculas y minúsculas, es decir, que para ellos no es lo mismo el identificador “edad” que “Edad” o “EDAD”. Por convenio, los algoritmos suelen nombrarse con la primera letra en mayúscula y el resto en minúsculas, mientras que las variables y funciones suelen nombrarse con la todas las letras en minúscula.</p> <p>Excepción: si el identificador consta de más de una palabra. En ese caso, ¿cómo es conveniente escribirlo? Existen dos convenciones para eso:</p> <ul> <li><strong>CamelCase</strong>: si el identificador consta de más de una palabra, se escriben todas juntas y la primera letra de cada palabra se escribe en mayúsculas. Por ejemplo: <code class="language-plaintext highlighter-rouge">edadEmpleado</code>.</li> <li><strong>snake_case</strong>: si el identificador consta de más de una palabra, se escriben separadas por el signo de subrayado (_). Por ejemplo: <code class="language-plaintext highlighter-rouge">edad_empleado</code>.</li> </ul> <p>Elegir CamelCase o snake_case es una cuestión de gustos personales. Lo importante es que, optes por el estilo que optes, lo utilices siempre y no mezcles identificadores de un tipo con identificadores de otro.</p> <h2 id="46-ejercicios-propuestos"> <a href="#46-ejercicios-propuestos" class="anchor-heading" aria-labelledby="46-ejercicios-propuestos"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.6. Ejercicios propuestos </h2> <p>Resuelve los siguientes ejercicios utilizando subalgoritmos cuando la complejidad del problema así lo requiera. Puedes hacerlo con todos, excepto los números 1, 2, 7 y 8, que son tan simples que difícilmente podrás sacar un subalgoritmo de ellos.</p> <h4 id="ejercicios-de-vectores-arrays-unidimensionales"> <a href="#ejercicios-de-vectores-arrays-unidimensionales" class="anchor-heading" aria-labelledby="ejercicios-de-vectores-arrays-unidimensionales"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ejercicios de vectores (arrays unidimensionales) </h4> <p><strong>Ejercicio 1: Inicializar un vector</strong>. Escribe un programa en pseudocódigo en el que se defina un vector de 100 números enteros, se inicialicen todos los elementos al valor –1 y se impriman por pantalla.</p> <p><strong>Ejercicio 2: Inicializar un vector (más complejo)</strong>. Define dos vectores de 100 números enteros, uno llamado <em>pares</em> y otro <em>impares</em>. Inicializa el primero con los 100 primeros números pares positivos (es decir, pares[0] contendrá el valor 2, pares[1] contendrá el valor 4, pares[2] contendrá el valor 6, y así sucesivamente). Inicializa el segundo con los 100 primeros números impares positivos. Imprímelo por pantalla para comprobar que lo has hecho correctamente.</p> <p><strong>Ejercicio 3: Lotería primitiva</strong>. Escribe un programa que genere al azar una combinación para jugar a la lotería primitiva asegurándote de que ningún número se repite. Pista: puedes utilizar un array de 6 números enteros, asignando a cada posición un número entero aleatorio entre 1 y 49, y comprobando que el número asignado no es igual a ninguno de los asignados anteriormente.</p> <p><strong>Ejercicio 4. Estadística básica</strong>. Escribe un programa que pida al usuario N números enteros (siendo N un valor introducido por teclado) y calcule el valor medio de todos ellos, mostrando luego en la pantalla los números que están por encima de la media y los que están por debajo de ella.</p> <p><strong>Ejercicio 5. Ordenar vector gigante</strong>. Escribe un programa que defina un vector de 1000 elementos y lo inicialice con valores aleatorios entre 0 y 2.000.000. Posteriormente, el programa debe ordenar los elementos del array de menor a mayor. Prueba luego a cambiar el tamaño del vector hasta los 10.000, 100.000 y 1.000.000 de elementos. ¿El tiempo de respuesta del programa crece linealmente con el tamaño del vector?</p> <p><strong>Ejercicio 6. Vector creciente</strong>.</p> <div style="background: #eee">Escribe un programa que defina un vector de 10 enteros y lo rellene con números CRECIENTES al azar entre 1 y 100. Es decir, los números serán elegidos aleatoriamente pero siempre tienen que ser mayores que los anteriores: el número que ocupe la posición 1 debe ser mayor que el de la posición 0, el de la posición 2 mayor que el de la 1, y así sucesivamente. Después de eso, se pedirá al usuario un número entre 1 y el número mayor que exista en el vector. El número introducido por el usuario se insertará en la posición del vector adecuada para conservar el orden, desplazando los demás elementos hacia la derecha, de manera que se pierda el último elemento. Después de insertar el número introducido por el usuario, el contenido del vector debe mostrarse por la pantalla. El proceso se repetirá hasta que el usuario introduzca un número negativo. Por ejemplo, supongamos que el array generado al azar por el ordenador, después de ordenarlo, es este:<pre>
     4 – 18 – 23 – 25 – 44 - 45 – 51 – 72 – 78 - 85
</pre>Como el número más alto es 85, el programa debe pedir al usuario:<pre>
     Introduzca un número entre 1 y 85: _
</pre>Si el usuario teclea, por ejemplo, el número 67, éste debe ser insertado en la posición adecuada para conservar el orden, es decir, entre los números 51 y 72, desplazando a los demás números hacia la derecha, con lo cual se pierde el mayor de todos ellos (85). El vector quedaría así:<pre>
    4 – 18 – 23 – 25 – 44 - 45 – 51 – 67 - 72 – 78
</pre></div> <h4 id="ejercicios-de-matrices-arrays-bidimensionales"> <a href="#ejercicios-de-matrices-arrays-bidimensionales" class="anchor-heading" aria-labelledby="ejercicios-de-matrices-arrays-bidimensionales"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ejercicios de matrices (arrays bidimensionales) </h4> <p><strong>Ejercicio 7. Inicializar matriz simple</strong>. Escribe un programa en el que se defina una matriz de 10x10 números enteros. Inicializa todos los elementos al valor –1.</p> <p><strong>Ejercicio 8. Inicializar matriz complejo</strong>. Repite el ejercicio anterior, inicializando ahora todas las filas pares al valor 0 y todas las filas impares al valor –1.</p> <p><strong>Ejercicio 9. Sumar filas</strong>. Escribe un programa que defina una matriz de 6x3 números enteros y luego pida al usuario que introduzca los valores de cada elemento. Después, el programa debe sumar los tres números de cada fila, mostrando los resultados.</p> <p><strong>Ejercicio 10. Permutar filas</strong>. Escribe un programa que defina una matriz de 3x5 números enteros y luego pida al usuario que introduzca los valores de cada elemento. Después, debe permutar el contenido de la fila 3 por el de la fila 1, y mostrar por último el contenido de la matriz.</p> <p><strong>Ejercicio 11. Sumar matrices</strong>. Escribe un programa que defina dos matrices de 10x5 números enteros y las inicialice con números aleatorios entre 0 y 255. Posteriormente, cada elemento de la primera matriz debe ser sumado con el mismo elemento de la segunda matriz, guardando el resultado en una tercera matriz. Se deben sumar todas las parejas de elementos y mostrar el resultado en la pantalla.</p> <p><strong>Ejercicio 12. Jugueteando con matrices</strong>. Escribe un programa que genere al azar una matriz cuadrada de NxN números enteros (siendo N un valor introducido por el usuario) y que luego haga lo siguiente:</p> <ul> <li><em>Mostrar</em>. Mostrará la matriz tal y como ha sido generada.</li> <li><em>Perímetro</em>. Mostrará los elementos que ocupan el borde de la matriz, partiendo de la esquina superior izquierda y recorriéndola hacia la derecha y luego hacia abajo.</li> <li><em>Centro</em>. Mostrará los elementos que ocupan el centro geométrico de la matriz. Puede ser 1 (si N es impar) o 4 (si N es par).</li> <li><em>Espiral</em>. Hará un recorrido en espiral por la matriz partiendo de la esquina superior izquierda.</li> </ul> <p>Por ejemplo, si la matriz fuera de 4x4 y tuviera este contenido:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    4 6 7 8
    2 4 3 9
    0 1 3 4
    7 3 3 5
</code></pre></div></div> <p>…las distintas operaciones deben obtener este resultado:</p> <ul> <li>Perímetro: 4 6 7 8 9 4 5 3 3 7 0 2</li> <li>Centro: 4 3 1 3</li> <li>Espiral: 4 6 7 8 9 4 5 3 3 7 0 2 4 3 3 1</li> </ul> <h2 id="47-ejercicios-resueltos"> <a href="#47-ejercicios-resueltos" class="anchor-heading" aria-labelledby="47-ejercicios-resueltos"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.7. Ejercicios resueltos </h2> <p><strong>Ejercicio 1: Inicializar un vector</strong>. Escribe un programa en pseudocódigo en el que se defina un vector de 100 números enteros, se inicialicen todos los elementos al valor –1 y se impriman por pantalla.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Algoritmo InicializarVectorSimple
	Definir i, vector Como Entero
	Dimension vector[100]
	
	// Inicializamos el array
	Para i &lt;- 0 hasta 99 Hacer
		vector[i] &lt;- -1
	FinPara
	
	// Mostramos el array
	Para i &lt;- 0 hasta 99 Hacer
		Escribir "Vector[", i, "] = ", vector[i]
	FinPara
FinAlgoritmo
</code></pre></div></div> <p><strong>Ejercicio 2: Inicializar un vector (más complejo)</strong>. Define dos vectores de 100 números enteros, uno llamado <em>pares</em> y otro <em>impares</em>. Inicializa el primero con los 100 primeros números pares positivos (es decir, pares[0] contendrá el valor 2, pares[1] contendrá el valor 4, pares[2] contendrá el valor 6, y así sucesivamente). Inicializa el segundo con los 100 primeros números impares positivos. Imprímelo por pantalla para comprobar que lo has hecho correctamente.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Algoritmo InicializarVectorComplejo
	Definir i, pares, impares Como Entero
	Dimension pares[100]
	Dimension impares[100]
	
	// Inicializa los arrays
	Para i &lt;- 0 hasta 99 Hacer
		pares[i] &lt;- (i+1)*2
		impares[i] &lt;- (i*2)+1
	FinPara
	
	// Muestra el array de números pares
	Para i &lt;- 0 hasta 99 Hacer
		Escribir "Pares[", i, "] = ", pares[i]
	FinPara
		
	// Muestra el array de números impares
	Para i &lt;- 0 hasta 99 Hacer
		Escribir "Impares[", i, "] = ", impares[i]
	FinPara
FinAlgoritmo
</code></pre></div></div> <p><strong>Ejercicio 3: Lotería primitiva</strong>. Escribe un programa que genere al azar una combinación para jugar a la lotería primitiva asegurándote de que ningún número se repite. Pista: puedes utilizar un array de 6 números enteros, asignando a cada posición un número entero aleatorio entre 1 y 49, y comprobando que el número asignado no es igual a ninguno de los asignados anteriormente.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Algoritmo InicializarVector
	Definir repetido como Lógico
	Definir i, j, apuesta como Entero
	Dimension apuesta[6]
	
	// Genera la combinación al azar (sin números repetidos)
	Para i &lt;- 0 hasta 5 hacer
		Repetir
			apuesta[i] &lt;- azar(49)+1      // Saca un número al azar entre 1 y 49
			repetido &lt;- falso             // Suponemos que NO está repetido...
			Para j &lt;- 0 hasta i-1 con paso 1 hacer      // ...pero vamos a asegurarnos mirando todos los anteriores
				Si apuesta[j] = apuesta[i] entonces   // ¡Sí que estaba repetido!
					repetido &lt;- verdadero              // Ponemos a "verdadero" la variable centinela
				FinSi
			FinPara
		Hasta Que repetido = falso       // Sacaremos otro número al azar hasta que no esté repetido
	FinPara
	
	// Mostramos la combinación
	Escribir "La combinación para la lotería es:"
	Para i &lt;- 0 hasta 5 hacer
		Escribir sin saltar apuesta[i], "   "
	FinPara
FinAlgoritmo
</code></pre></div></div> <p><strong>Ejercicio 4. Estadística básica</strong>. Escribe un programa que pida al usuario N números enteros (siendo N un valor introducido por teclado) y calcule el valor medio de todos ellos, mostrando luego en la pantalla los números que están por encima de la media y los que están por debajo de ella.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Algoritmo estadistica_basica
	Definir n, i, acum como Entero
	Definir vector Como Entero
	Definir media como Real
	
	// Dimensionamos el array
	Escribir "¿Cuántos números vas a escribir?"
	Leer n
	Dimension vector[n]
	
	// Leemos los valores del array
	Escribir "Por favor, teclea los ", n, " valores (pulsa Intro después de cada uno):"
	Para i &lt;- 0 hasta n-1 hacer
		Leer vector[i]
	FinPara
	
	// Calculamos la media
	acum &lt;- vector[0]
	Para i &lt;- 1 hasta n-1 hacer
		acum &lt;- acum + vector[i]
	FinPara
	media &lt;- acum / n
	Escribir "El promedio es: ", media
	
	// Mostramos los valores que están por debajo de la media
	Escribir "Valores por debajo de la media:"
	Para i &lt;- 1 hasta n-1 Hacer
		Si vector[i] &lt; media Entonces
			Escribir vector[i]
		FinSi
	FinPara
	
	// Mostramos los valores que están por encima de la media
	Escribir "Valores por encima de la media:"
	Para i &lt;- 1 hasta n-1 Hacer
		Si vector[i] &gt; media Entonces
			Escribir vector[i]
		FinSi
	FinPara
FinAlgoritmo
</code></pre></div></div> <p><strong>Ejercicio 5. Ordenar vector gigante</strong>. Escribe un programa que defina un vector de 1000 elementos y lo inicialice con valores aleatorios entre 0 y 2.000.000. Posteriormente, el programa debe ordenar los elementos del array de menor a mayor. Prueba luego a cambiar el tamaño del vector hasta los 10.000, 100.000 y 1.000.000 de elementos. ¿El tiempo de respuesta del programa crece linealmente con el tamaño del vector?</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Algoritmo ordenar_array
	Definir n, i como Entero
	Definir vector Como Entero
	
	// Dimensionamos el array
	Escribir "¿De qué tamaño quieres el array?"
	Leer n
	Dimension vector[n]
	
	// Inicializamos el array con valores aleatorios
	Para i &lt;- 0 hasta n-1 hacer
		vector[i] &lt;- azar(n*2)
	FinPara
	
	// Ordenamos el array. Lo mostramos antes y después para comprobar la diferencia
	Escribir "Pulsa una tecla para ver el array desordenado"
	Esperar Tecla
	mostrar(vector, n)
	
	Escribir "Pulsa una tecla para iniciar la ordenación del array"
	Esperar Tecla
	ordenar(vector, n)
	
	Escribir "Ordenación terminada. Pulsa una tecla para ver el array ordenado"
	Esperar Tecla
	mostrar(vector, n)	
FinAlgoritmo

SubAlgoritmo mostrar(vector, n)
	Definir i Como Entero
	para i &lt;- 0 hasta n-1 Hacer
		Escribir vector[i]
	FinPara
FinSubAlgoritmo

SubAlgoritmo ordenar(vector por referencia, n)
	Definir i, j, aux Como Entero
	para i &lt;- 0 hasta n-2 Hacer
		para j &lt;- 0 hasta n-2 Hacer
			si vector[j] &gt; vector[j+1] Entonces
				aux &lt;- vector[j]
				vector[j] &lt;- vector[j+1]
				vector[j+1] &lt;- aux
			FinSi
		FinPara
		Borrar Pantalla
		Escribir "Ordenando el array... ", redon(i*100/(n-2)), "%"
	FinPara
FinSubAlgoritmo
</code></pre></div></div> <p><strong>Ejercicio 6. Vector creciente</strong>. Escribe un programa que defina un vector de 10 enteros y lo rellene con números CRECIENTES al azar entre 1 y 100. Es decir, los números serán elegidos aleatoriamente pero siempre tienen que ser mayores que los anteriores: el número que ocupe la posición 1 debe ser mayor que el de la posición 0, el de la posición 2 mayor que el de la 1, y así sucesivamente. Después de eso, se pedirá al usuario un número entre 1 y el número mayor que exista en el vector. El número introducido por el usuario se insertará en la posición del vector adecuada para conservar el orden, desplazando los demás elementos hacia la derecha, de manera que se pierda el último elemento. Después de insertar el número introducido por el usuario, el contenido del vector debe mostrarse por la pantalla. El proceso se repetirá hasta que el usuario introduzca un número negativo. Por ejemplo, supongamos que el array generado al azar por el ordenador, después de ordenarlo, es este:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 4 – 18 – 23 – 25 – 44 - 45 – 51 – 72 – 78 - 85
</code></pre></div></div> <p>Como el número más alto es 85, el programa debe pedir al usuario:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Introduzca un número entre 1 y 85: _
</code></pre></div></div> <p>Si el usuario teclea, por ejemplo, el número 67, éste debe ser insertado en la posición adecuada para conservar el orden, es decir, entre los números 51 y 72, desplazando a los demás números hacia la derecha, con lo cual se pierde el mayor de todos ellos (85). El vector quedaría así:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>4 – 18 – 23 – 25 – 44 - 45 – 51 – 67 - 72 – 78
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Algoritmo vector_creciente
	Definir i, n, posicion como entero
	Definir v Como Entero
	Dimension v[10]
	
	// Inicializamos el vector con números crecientes, para que ya salga ordenado
	Para i &lt;- 0 hasta 9 Hacer
		v[i] &lt;- i*10 + azar(10)
	FinPara
	
	// Mostramos el vector
	mostrar_vector(v)
	
	// Pedimos al usuario un número
	Repetir
		Escribir "Introduce un número entre 1 y ", v[9]
		Leer n
	Hasta que n &gt;= 1 y n &lt;= v[9]
	
	// Localizamos la posición de inserción
	posicion &lt;- 0
	Mientras n &gt; v[posicion]
		posicion &lt;- posicion + 1
	FinMientras
	
	// Desplazamos el contenido del vector hacia la derecha desde esa posición
	Para i &lt;- 8 hasta posicion con paso -1 hacer
		v[i+1] &lt;- v[i]
	FinPara
	
	// Insertamos por fin el número y volvemos a mostrar el vector
	v[posicion] &lt;- n
	mostrar_vector(v)
FinAlgoritmo

SubAlgoritmo mostrar_vector(v) 
	Definir i como entero
	Para i desde 0 hasta 9 Hacer
		escribir sin saltar v[i], " - "
	FinPara
	Escribir ""	
FinSubAlgoritmo
</code></pre></div></div> <p><strong>Ejercicio 7. Inicializar matriz simple</strong>. Escribe un programa en el que se defina una matriz de 10x10 números enteros. Inicializa todos los elementos al valor –1.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Algoritmo inicializar_matriz_simple
	Definir fila, columna como entero
	Definir matriz como entero
	Dimension matriz(10,10)
	
	// Primero inicializamos la matriz
	Para fila &lt;- 0 hasta 9 Hacer
		Para columna &lt;- 0 hasta 9 Hacer
			matriz[fila, columna] &lt;- -1
		FinPara
	FinPara
	
	// Después mostramos la matriz por pantalla
	Para fila &lt;- 0 hasta 9 Hacer
		Para columna &lt;- 0 hasta 9 Hacer
			Escribir sin saltar matriz[fila, columna], "  "
		FinPara
		Escribir " "  // Hace el salto de línea al final de cada columna
	FinPara
FinAlgoritmo
</code></pre></div></div> <p><strong>Ejercicio 8. Inicializar matriz complejo</strong>. Repite el ejercicio anterior, inicializando ahora todas las filas pares al valor 0 y todas las filas impares al valor –1.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Algoritmo inicializar_matriz_complejo
	Definir fila, columna como entero
	Definir matriz como entero
	Dimension matriz(10,10)
	
	// Primero inicializamos la matriz
	Para fila &lt;- 0 hasta 9 Hacer
		Para columna &lt;- 0 hasta 9 Hacer
			Si fila MOD 2 = 0 Entonces
				matriz[fila, columna] &lt;- 0
			SiNo
				matriz[fila, columna] &lt;- -1
			FinSi
		FinPara
	FinPara
	
	// Después mostramos la matriz por pantalla
	Para fila &lt;- 0 hasta 9 Hacer
		Para columna &lt;- 0 hasta 9 Hacer
			Si fila MOD 2 = 0 Entonces
			    Escribir sin saltar " ", matriz[fila, columna], "  "
			SiNo
				Escribir sin saltar matriz[fila, columna], "  "
			FinSi
		FinPara
		Escribir " "  // Hace el salto de línea al final de cada columna
	FinPara
FinAlgoritmo
</code></pre></div></div> <p><strong>Ejercicio 12. Jugueteando con matrices</strong>.</p> <p>Escribe un programa que genere al azar una matriz cuadrada de NxN números enteros (siendo N un valor introducido por el usuario) y que luego haga lo siguiente:</p> <ul> <li><em>Mostrar</em>. Mostrará la matriz tal y como ha sido generada.</li> <li><em>Perímetro</em>. Mostrará los elementos que ocupan el borde de la matriz, partiendo de la esquina superior izquierda y recorriéndola hacia la derecha y luego hacia abajo.</li> <li><em>Centro</em>. Mostrará los elementos que ocupan el centro geométrico de la matriz. Puede ser 1 (si N es impar) o 4 (si N es par).</li> <li><em>Espiral</em>. Hará un recorrido en espiral por la matriz partiendo de la esquina superior izquierda.</li> </ul> <p>Por ejemplo, si la matriz fuera de 4x4 y tuviera este contenido:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    4 6 7 8
    2 4 3 9
    0 1 3 4
    7 3 3 5
</code></pre></div></div> <p>…las distintas operaciones deben obtener este resultado:</p> <ul> <li>Perímetro: 4 6 7 8 9 4 5 3 3 7 0 2</li> <li>Centro: 4 3 1 3</li> <li>Espiral: 4 6 7 8 9 4 5 3 3 7 0 2 4 3 3 1</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Algoritmo jugando_con_matrices
	// Atención: en esta solución supondremos que los arrays comienzan en el índice 0.
	// Si se configura PseInt para que empiecen en 1, habría que modificar el código, como es lógico.
	Definir matriz, tam Como Entero
	Escribir sin saltar "Elige el tamaño de la matriz cuadrada: "
	Leer tam
	Dimension matriz[tam,tam]
	inicializar_matriz(matriz, tam)
	mostrar_matriz(matriz, tam)
	perimetro(matriz, tam)
	centro(matriz, tam)
	espiral(matriz, tam)
FinAlgoritmo

SubAlgoritmo inicializar_matriz(matriz, tam)
	Definir f, c como entero
	Para f desde 0 hasta tam-1 hacer
		Para c desde 0 hasta tam-1 hacer
			matriz[f,c] &lt;- azar(10)
		FinPara
	FinPara
FinSubAlgoritmo

SubAlgoritmo mostrar_matriz(matriz, tam) 
	Definir f, c como entero
	Escribir "MATRIZ:"
	Para f desde 0 hasta tam-1 hacer
		Para c desde 0 hasta tam-1 hacer
			Escribir sin saltar matriz[f,c], " "
		FinPara
		Escribir ""
	FinPara
FinSubAlgoritmo

SubAlgoritmo perimetro(matriz, tam)
	Definir f, c como entero
	Escribir "PERÍMETRO:"
	Para c &lt;- 0 hasta tam-1 Hacer
		Escribir sin saltar matriz[0, c], " "
	FinPara
	Para f &lt;- 1 hasta tam-1 Hacer
		Escribir sin saltar matriz[f, tam-1], " "
	FinPara
	Para c &lt;- tam-2 hasta 0 con paso -1 Hacer
		Escribir sin saltar matriz[tam-1, c], " "
	FinPara
	Para f &lt;- tam-2 hasta 1 con paso -1 Hacer
		Escribir sin saltar matriz[f, 0], " "
	FinPara
	Escribir ""
FinSubAlgoritmo

SubAlgoritmo centro(matriz, tam)
	Definir c como entero
	Escribir "CENTRO:"
	Si tam % 2 = 0 entonces
		// Matriz de tamaño PAR. El centro consta de cuatro números
		c &lt;- tam / 2
		Escribir sin saltar matriz[c-1, c-1], " "
		Escribir sin saltar matriz[c-1, c], " "
		Escribir sin saltar matriz[c, c-1], " "
		Escribir sin saltar matriz[c, c]
	SiNo
		// Matriz de tamaño IMPAR. El centro es un solo número
		c &lt;- trunc(tam / 2)
		Escribir sin saltar matriz[c, c]
	FinSi
	Escribir ""
FinSubAlgoritmo

SubAlgoritmo espiral(matriz, tam)
	Definir f, c, inicio, final como entero
	Escribir "ESPIRAL:"
	inicio &lt;- 0
	final &lt;- tam-1
	Mientras inicio &lt; final hacer
		Para c &lt;- inicio hasta final Hacer
			Escribir sin saltar matriz[inicio, c], " "
		FinPara
		Para f &lt;- inicio+1 hasta final Hacer
			Escribir sin saltar matriz[f, final], " "
		FinPara
		Para c &lt;- final-1 hasta inicio con paso -1 Hacer
			Escribir sin saltar matriz[final, c], " "
		FinPara
		Para f &lt;- final-1 hasta inicio+1 con paso -1 Hacer
			Escribir sin saltar matriz[f, inicio], " "
		FinPara
		inicio &lt;- inicio + 1
		final &lt;- final - 1
	FinMientras
	Escribir ""
FinSubAlgoritmo
</code></pre></div></div> <hr> <h2 class="text-delta">Table of contents</h2> <ul> </ul> </div> </div> <div class="search-overlay"></div> </div> </body> </html>
