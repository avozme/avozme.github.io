<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <title>4. Estructuras de datos. Subalgoritmos - PROG Y 3D</title> <link rel="shortcut icon" href="/docs/prog-y-3d/_site/favicon.ico" type="image/x-icon"> <link rel="stylesheet" href="/docs/prog-y-3d/_site/assets/css/just-the-docs-default.css"> <script type="text/javascript" src="/docs/prog-y-3d/_site/assets/js/vendor/lunr.min.js"></script> <script type="text/javascript" src="/docs/prog-y-3d/_site/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.7.1 --> <title>Estructuras de datos. Subalgoritmos | PROG Y 3D</title> <meta name="generator" content="Jekyll v4.2.0" /> <meta property="og:title" content="Estructuras de datos. Subalgoritmos" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Apuntes de la asignatura “Introducción a la programación y al diseño 3D”, optativa de 2º curso de bachillerato ofertada por el IES Celia Viñas de Almería (España)" /> <meta property="og:description" content="Apuntes de la asignatura “Introducción a la programación y al diseño 3D”, optativa de 2º curso de bachillerato ofertada por el IES Celia Viñas de Almería (España)" /> <link rel="canonical" href="/docs/prog-y-3d/_site/estructuras-de-datos/" /> <meta property="og:url" content="/docs/prog-y-3d/_site/estructuras-de-datos/" /> <meta property="og:site_name" content="PROG Y 3D" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Estructuras de datos. Subalgoritmos" /> <script type="application/ld+json"> {"@type":"WebPage","url":"/docs/prog-y-3d/_site/estructuras-de-datos/","headline":"Estructuras de datos. Subalgoritmos","description":"Apuntes de la asignatura “Introducción a la programación y al diseño 3D”, optativa de 2º curso de bachillerato ofertada por el IES Celia Viñas de Almería (España)","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> </head> <body> <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header"> <a href="/docs/prog-y-3d/_site/" class="site-title lh-tight"> PROG Y 3D </a> <a href="#" id="menu-button" class="site-button"> <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg> </a> </div> <nav role="navigation" aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item active"><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/" class="nav-list-link">Introd. a la prog. y al diseño 3D</a><ul class="nav-list "><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/presentacion/" class="nav-list-link">0. Presentación de la asignatura</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/pensamiento-computacional/" class="nav-list-link">1. Pensamiento computacional</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/representacion-de-la-informacion/" class="nav-list-link">2. Representación de la información</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/introduccion-a-la-programacion/" class="nav-list-link">3. Introducción a la programación</a><ul class="nav-list"></ul></li><li class="nav-list-item active"><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/estructuras-de-datos/" class="nav-list-link active">4. Estructuras de datos. Subalgoritmos</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/lenguaje-php/" class="nav-list-link">5. Lenguaje PHP</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/orientacion-a-objetos/" class="nav-list-link">6. Orientación a objetos</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/entornos-integrados-de-desarrollo/" class="nav-list-link">7. Entornos integrados de desarrollo</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/bases-de-datos/" class="nav-list-link">8. Bases de datos</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/lenguaje-sql/" class="nav-list-link">9. El lenguaje SQL</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/seguridad-y-privacidad/" class="nav-list-link">10. Seguridad y privacidad</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/tecnologias-de-impresion-3d/" class="nav-list-link">11. Tecnologías de impresión 3D</a><ul class="nav-list"></ul></li><li class="nav-list-item "><a href="#" class="nav-list-expander"><svg viewBox="0 0 24 24"><use xlink:href="#svg-arrow-right"></use></svg></a><a href="/docs/prog-y-3d/_site/modelado-e-impresion-3d/" class="nav-list-link">12. Modelado e impresión 3D</a><ul class="nav-list"></ul></li></ul></li><li class="nav-list-item"><a href="/docs/prog-y-3d/_site/about/" class="nav-list-link">About</a></li></ul> </nav> <footer class="site-footer"> This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll. </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search PROG Y 3D" aria-label="Search PROG Y 3D" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> </div> <div id="main-content-wrap" class="main-content-wrap"> <nav aria-label="Breadcrumb" class="breadcrumb-nav"> <ol class="breadcrumb-nav-list"> <li class="breadcrumb-nav-list-item"><a href="/docs/prog-y-3d/_site/">Introd. a la prog. y al diseño 3D</a></li> <li class="breadcrumb-nav-list-item"><span>4. Estructuras de datos. Subalgoritmos</span></li> </ol> </nav> <div id="main-content" class="main-content" role="main"> <h1 class="no_toc" id="4-estructuras-de-datos-subalgoritmos"> <a href="#4-estructuras-de-datos-subalgoritmos" class="anchor-heading" aria-labelledby="4-estructuras-de-datos-subalgoritmos"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4. Estructuras de datos. Subalgoritmos </h1> <ul id="markdown-toc"> <li><a href="#41-estructuras-de-almacenamiento-de-datos" id="markdown-toc-41-estructuras-de-almacenamiento-de-datos">4.1. Estructuras de almacenamiento de datos</a></li> <li><a href="#42-arrays-unidimensionales-vectores" id="markdown-toc-42-arrays-unidimensionales-vectores">4.2. Arrays unidimensionales (vectores)</a> <ul> <li><a href="#421-declaración-de-vectores" id="markdown-toc-421-declaración-de-vectores">4.2.1. Declaración de vectores</a></li> <li><a href="#422-manipulación-de-elementos-de-un-vector" id="markdown-toc-422-manipulación-de-elementos-de-un-vector">4.2.2. Manipulación de elementos de un vector</a></li> <li><a href="#423-recorrido-de-un-vector" id="markdown-toc-423-recorrido-de-un-vector">4.2.3. Recorrido de un vector</a></li> <li><a href="#424-ordenación-de-vectores" id="markdown-toc-424-ordenación-de-vectores">4.2.4. Ordenación de vectores</a></li> <li><a href="#425-búsqueda-en-vectores" id="markdown-toc-425-búsqueda-en-vectores">4.2.5. Búsqueda en vectores</a></li> </ul> </li> <li><a href="#43-arrays-bidimiensionales-matrices" id="markdown-toc-43-arrays-bidimiensionales-matrices">4.3. Arrays bidimiensionales (matrices)</a></li> <li><a href="#44-arrays-de-múltiples-dimensiones" id="markdown-toc-44-arrays-de-múltiples-dimensiones">4.4. Arrays de múltiples dimensiones</a></li> <li><a href="#45-programación-modular-subalgoritmos" id="markdown-toc-45-programación-modular-subalgoritmos">4.5. Programación modular: subalgoritmos</a> <ul> <li><a href="#451-algoritmo-principal-y-subalgoritmos" id="markdown-toc-451-algoritmo-principal-y-subalgoritmos">4.5.1. Algoritmo principal y subalgoritmos</a></li> <li><a href="#452-funciones" id="markdown-toc-452-funciones">4.5.2. Funciones</a></li> <li><a href="#453--procedimientos" id="markdown-toc-453--procedimientos">4.5.3. Procedimientos</a></li> <li><a href="#454-invocación-de-subalgoritmos" id="markdown-toc-454-invocación-de-subalgoritmos">4.5.4. Invocación de subalgoritmos</a></li> <li><a href="#455-paso-de-parámetros" id="markdown-toc-455-paso-de-parámetros">4.5.5. Paso de parámetros</a></li> </ul> </li> <li><a href="#46-ejercicios-propuestos" id="markdown-toc-46-ejercicios-propuestos">4.6. Ejercicios propuestos</a></li> <li><a href="#47-ejercicios-resueltos" id="markdown-toc-47-ejercicios-resueltos">4.7. Ejercicios resueltos</a></li> </ul> <p>Hasta ahora, hemos conocido las estructuras de control básicas de cualquier programa estructurado: secuencia, condición e iteración.</p> <p>Pero los programas no se componen solo de <em>instrucciones</em>, sino también de <strong><em>datos</em></strong>.</p> <p>Todos los datos que hemos manejado hasta ahora eran simples, es decir, se almacenaban en variables en las que solo podíamos guardar un valor en cada momento. Las variables simples se nos quedan cortas en muchas ocasiones (repasa el programa de las 3 en raya, sin ir más lejos, para comprobarlo). En esos casos necesitamos una variable de tipo complejo o <strong>estructura de datos</strong>.</p> <p>En este capítulo hablaremos de las estructuras de datos y nos centraremos en la más utilizada con diferencia: el <strong>array</strong>.</p> <p>Después, introduciremos los conceptos de <strong>subalgoritmo, función y biblioteca de funciones</strong>, para terminar hablando de uno de los principios básicos de la ingeniería del software: la <strong>reutilización del código</strong>.</p> <h2 id="41-estructuras-de-almacenamiento-de-datos"> <a href="#41-estructuras-de-almacenamiento-de-datos" class="anchor-heading" aria-labelledby="41-estructuras-de-almacenamiento-de-datos"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.1. Estructuras de almacenamiento de datos </h2> <p>Hemos trabajado, por el momento, con los tipos de datos básicos: enteros, reales, caracteres, lógicos… Es el momento de dar el salto a los <strong>tipos de datos complejos</strong>, también llamados <strong>estructuras de datos</strong>.</p> <p>Las estructuras de datos pueden ser de dos tipos:</p> <ul> <li><strong>Estáticas</strong>: son aquellas que ocupan un espacio determinado en la memoria del ordenador. Este espacio es invariable y se especifica durante la escritura del código fuente.</li> <li><strong>Dinámicas</strong>: son aquellas cuyo espacio ocupado en la memoria puede modificarse durante la ejecución del programa.</li> </ul> <p>Existe todo un universo de estructuras de datos: desde los arrays, presentes en casi cualquier programa, hasta estructuras mucho más exóticas como pilas, colas, listas enlazadas, árboles, grafos, etc.</p> <p>Nosotros no pretendemos verlas todas, ni mucho menos, pero sí que conozcas la más importante de todas: el array.</p> <h2 id="42-arrays-unidimensionales-vectores"> <a href="#42-arrays-unidimensionales-vectores" class="anchor-heading" aria-labelledby="42-arrays-unidimensionales-vectores"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.2. Arrays unidimensionales (vectores) </h2> <p>Un <strong>array</strong> (también llamado <strong>arreglo</strong>, sobre todo en América latina) es una <em>agrupación de muchos datos individuales del mismo tipo bajo el mismo nombre</em>. Cada dato individual de un array es accesible mediante un índice.</p> <p>Por ejemplo, un array de números enteros es una colección de muchos números enteros a los que les adjudicamos un único identificador.</p> <p>El caso más simple de array es el <strong>array unidimensional</strong>, también llamado <strong>vector</strong>. Se trata, sin duda, del rey de las estructuras de almacenamiento.</p> <h3 id="421-declaración-de-vectores"> <a href="#421-declaración-de-vectores" class="anchor-heading" aria-labelledby="421-declaración-de-vectores"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.2.1. Declaración de vectores </h3> <p>La <strong>declaración de un vector</strong> en pseudocódigo (seguiremos usando la sintaxis de PSeInt) se hace así:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Definir nombre_variable Como tipo
Dimension nombre_variable[tamaño]
</code></pre></div></div> <p>Por ejemplo:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Definir serie como Entero
Dimension serie[10]
</code></pre></div></div> <p>La variable <em>serie</em> será un vector que contendrá 10 números enteros. Todos los números recibirán el mismo nombre, es decir, <em>serie</em>.</p> <p>Se puede acceder a cada uno de los números que forman el vector escribiendo a continuación del nombre un número entre corchetes. Ese número se denomina <strong>índice</strong>.</p> <p>Observa el siguiente ejemplo:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Definir serie como Entero
Dimension serie[5]
serie[2] &lt;- 20
serie[3] &lt;- 15
serie[4] &lt;- serie[2] + serie[3]
Escribir serie[4]
</code></pre></div></div> <p>El vector <em>serie</em> de este ejemplo puede almacenar hasta 5 números enteros. En su posición 2 se almacena el número 20, y en su posición 3, el 15. Luego se suman ambos valores, y el resultado se almacena en la posición 4. Finalmente, se imprime en la pantalla el resultado de la suma, es decir, 35.</p> <p>Es muy útil representar los vectores de forma gráfica para entenderlos mejor. El vector serie del ejemplo anterior se puede representar así:</p><pre>
            +------------+----+----+----+----+----+
            | Posiciones |  0 |  1 |  2 |  3 |  4 |
    serie = +------------+----+----+----+----+----+
            | Valores    |  ? |  ? | 20 | 15 | 35 |
            +------------+----+----+----+----+----+
</pre><p>Observa algo muy importante: <strong>el primer elemento del vector tiene el índice 0</strong>, es decir, el primer elemento es <strong>serie[0]</strong>.</p> <p>Como este vector tiene 5 elementos, el último será serie[4], no serie[5]. Observa también que los elementos 0 y 1 no han sido utilizados y, por lo tanto, tienen un valor desconocido, exactamente lo mismo que ocurre con cualquier variable de tipo simple que no se inicialice.</p> <p><em>(Nota: PSeInt se puede configurar para que el primer elemento del vector tenga índice 1, no 0, pero, como la mayor parte de los lenguajes de programación reales usan el 0, supondremos que PSeInt también lo está haciendo)</em></p> <p>Como es lógico, se pueden construir vectores cuyos elementos sean de cualquier otro tipo simple, como números reales o caracteres, con la única restricción de que todos los elementos sean del mismo tipo.</p> <p>Y, por supuesto, pueden construirse vectores cuyos elementos sean otros vectores. Obtendremos así un array bidimensional, del que hablaremos un poco más adelante.</p> <h3 id="422-manipulación-de-elementos-de-un-vector"> <a href="#422-manipulación-de-elementos-de-un-vector" class="anchor-heading" aria-labelledby="422-manipulación-de-elementos-de-un-vector"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.2.2. Manipulación de elementos de un vector </h3> <p>Los vectores deben manipularse <strong>elemento a elemento</strong>. <em>No se pueden modificar todos los elementos a la vez.</em></p> <p>Por ejemplo, <strong>para asignar valores a los elementos de un vector</strong>, esta sería la manera:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Definir serie como Entero
Dimension serie[5]
serie[0] &lt;- 5
serie[1] &lt;- 3
serie[2] &lt;- 7
...etc...
</code></pre></div></div> <p>Cada elemento del vector es, a todos los efectos, una variable que puede usarse independientemente de los demás elementos. Así, por ejemplo, un elemento del vector <em>serie</em> puede usarse en una instrucción de salida igual que cualquier variable simple de tipo entero:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Escribir(serie[2])
</code></pre></div></div> <p>Del mismo modo, pueden usarse elementos de un vector en una instrucción de entrada. Por ejemplo:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Escribir "Dime un número entero"
Leer (serie[4])
</code></pre></div></div> <h3 id="423-recorrido-de-un-vector"> <a href="#423-recorrido-de-un-vector" class="anchor-heading" aria-labelledby="423-recorrido-de-un-vector"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.2.3. Recorrido de un vector </h3> <p>La forma habitual de utilizar un vector es <strong>accediendo en secuencia a todos sus elementos</strong>, uno tras otro.</p> <p>Para ello, se utiliza un <strong>bucle con contador</strong>, de modo que la variable contador nos sirve como <strong>índice</strong> para acceder a cada uno de los elementos del vector.</p> <p>Supongamos, por ejemplo, que tenemos un vector de 10 números enteros declarado llamado <em>v</em>, y una variable entera llamada <em>i</em>, que será nuestro índice. Por medio de un bucle, con ligeras modificaciones, podemos realizar todas estas operaciones:</p> <ul> <li> <p><strong>1. Inicializar todos los elementos a un valor cualquiera</strong> (por ejemplo, 0):</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Para i &lt;- 0 hasta 9 hacer
    v[i] &lt;- 0
 FinPara
</code></pre></div> </div> </li> <li> <p><strong>2. Inicializar todos los elementos con valores introducidos por teclado</strong>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Para i &lt;- 0 hasta 9 hacer
    Escribir "Dime el valor del elemento nº ", i
    Leer v[i] 
 FinPara
</code></pre></div> </div> </li> <li> <p><strong>3. Mostrar todos los elementos en la pantalla</strong>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Para i &lt;- 0 hasta 9 hacer
    Escribir "El elemento nº ", i, " vale ", v[i]
 FinPara
</code></pre></div> </div> </li> <li> <p><strong>4. Realizar alguna operación que implique a todos los elementos</strong>. Por ejemplo, sumarlos en un <strong>acumulador</strong>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> suma &lt;- 0
 Para i &lt;- 0 hasta 9 hacer
    suma &lt;- suma + v[i]
 FinPara
 Escribir "La suma de todos los elementos es: ", suma
</code></pre></div> </div> </li> </ul> <h3 id="424-ordenación-de-vectores"> <a href="#424-ordenación-de-vectores" class="anchor-heading" aria-labelledby="424-ordenación-de-vectores"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.2.4. Ordenación de vectores </h3> <p>Otra operación típica que se realiza con vectores es <strong>ordenar sus elementos</strong> mediante algún criterio.</p> <p>Por ejemplo, un vector de números enteros puede ordenarse de menor a mayor (o al revés), mientras que un vector de caracteres puede ordenarse alfabéticamente.</p> <p>Supongamos, por ejemplo, que tenemos un vector de números enteros con estos valores:</p><pre>
+----+----+----+----+----+----+----+----+----+----+
|  0 |  1 |  2 |  3 |  4 |  5 |  3 | 14 |  9 |  8 |
+----+----+----+----+----+----+----+----+----+----+
</pre><p>Después de la ordenación, nos quedará este otro vector:</p><pre>
+----+----+----+----+----+----+----+----+----+----+
|  0 |  1 |  2 |  3 |  3 |  4 |  5 |  8 |  9 | 14 |
+----+----+----+----+----+----+----+----+----+----+
</pre><p>Del mismo modo, se pueden ordenar los elementos con cualquier otro criterio: de mayor a menor, primero los pares y luego los impares, o cualquier otro que nos resulte útil para resolver un problema.</p> <p>Métodos de ordenación de vectores hay muchos, algunos muy simples (e ineficientes) y otros muy elaborados, y constituyen un área de estudio muy interesante dentro de la algorítmica.</p> <p>Aquí vamos a presentar uno de los métodos más sencillos que existen para ordenar un vector, de modo que te resulte fácil entenderlo. Para aprender los métodos más complejos y rápidos ya tendrás tiempo en el futuro, ¿no te parece?</p> <h4 id="ordenación-mediante-selección-directa"> <a href="#ordenación-mediante-selección-directa" class="anchor-heading" aria-labelledby="ordenación-mediante-selección-directa"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ordenación mediante selección directa </h4> <p>La <strong>selección directa</strong> es probablemente el método de ordenación más fácil de entender porque es lo que la mayoría de nosotros haríamos si tuviéramos que ordenar un conjunto de elementos a mano. Esto no quiere decir que sea fácil de programar para un principiante, pero vamos a intentarlo.</p> <p>Vamos a suponer que tratamos de ordenar un vector de números enteros de menor a mayor pero, como hemos dicho, la misma idea podría emplearse para ordenar cualquier otra cosa y mediante cualquier otro criterio.</p> <p>El método de selección directa recorre el vector desde el principio hasta localizar el elemento más pequeño, guardando su posición y su valor en dos variables que llamaremos <em>posicion_minimo</em> y <em>valor_minimo</em>. Al terminar, coloca ese elemento mínimo en la primera posición del vector y lo intercambia con el elemento que antes ocupaba esa primera posición.</p> <p>(Para hacer ese intercambio de valores, es necesario usar una variable auxiliar que llamaremos <em>aux</em>).</p> <p>El proceso se repite, pero ahora desde la <em>segunda</em> posición del vector original. De nuevo volvemos a buscar el elemento más pequeño mirándolos todos de uno en uno. Al terminar, colocamos ese elemento mínimo en la <em>segunda</em> posición del vector, intercambiándola por el número que antes estaba en la segunda posición.</p> <p>Volvemos a hacerlo, ahora desde la <em>tercera</em> posición del vector original, y así sucesivamente hasta terminar de recorrer el vector completo.</p> <p><strong>Observa con detenimiento el código fuente de esta implementación</strong>. No pases por él de puntillas para dedicarte a otra cosa. Dedica unos minutos para tratar de ejecutarlo <em>a mano</em>, es decir, con papel y lápiz, apuntando el valor de las variables para ver cómo actúa el algoritmo y cómo construye, pasada tras pasada, el vector ordenado.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Algoritmo seleccion_directa
	Definir i, j, aux Como Entero
	Definir valor_minimo, posicion_minimo Como Entero
	Definir vector Como Entero
	Dimensión vector[100]
	
	// Primero, vamos a llenar el vector_original con valores al azar entre 1 y 500, por ejemplo
	Para i desde 0 hasta 99 Hacer
		vector[i] &lt;- azar(500)
	FinPara
	
	// Ahora empieza el algoritmo de ordenación por selección directa
	Para i desde 0 hasta 99 Hacer
		valor_minimo &lt;- vector[i]
		posicion_minimo &lt;- i
		Para j desde 0 hasta 99 Hacer
			Si vector[j] &lt; valor_minimo Entonces
				valor_minimo &lt;- vector[j]
				posicion_minimo &lt;- j
			FinSi
		FinPara
		aux &lt;- vector[i]
		vector[i] &lt;- valor_minimo
		vector[posicion_minimo] &lt;- aux
	FinPara
	
	// Por fin, escribimos el vector ordenado para ver que todo ha funcionado bien
	Para i desde 0 hasta 99 Hacer
		Escribir vector[i]
	FinPara
	
FinAlgoritmo
</code></pre></div></div> <h3 id="425-búsqueda-en-vectores"> <a href="#425-búsqueda-en-vectores" class="anchor-heading" aria-labelledby="425-búsqueda-en-vectores"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.2.5. Búsqueda en vectores </h3> <p>En los vectores, como en todas las estructuras de datos que contienen muchos datos en su interior, también es habitual encontrarse con la <strong>operación de búsqueda</strong>.</p> <p>Dado un vector y un dato cualquiera, la búsqueda consiste en determinar si ese dato está en alguna posición del vector y, si es necesario, averiguar cuál es esa posición.</p> <p>La <strong>búsqueda secuencial</strong>, es decir, elemento a elemento, puede llegar a ser muy lenta si el vector es muy grande. Si en un programa tenemos que realizar búsquedas en vectores grandes repetidas veces, debemos pensar el modo de lograr que las búsquedas sean más rápidas.</p> <p>Existe una forma muy simple de hacer una búsqueda en un vector de manera tremendamente rápid: con el método llamado <strong>búsqueda binaria</strong>. Pero la búsqueda binaria tiene un problema: para que funcione, el vector debe estar previamente ordenado. El proceso de ordenación, como acabamos de ver, es lento y costoso, pero, a cambio, obtendremos unos tiempos de búsqueda notablemente mejores.</p> <p>Resumiendo: si necesitamos hacer búsquedas de datos en vectores en algún programa:</p> <ul> <li>Si las búsquedas se realizan pocas veces, o bien los vectores son pequeños, optaremos por la búsqueda secuencial, que no necesita ordenar previamente el vector.</li> <li>Si las busquedas se realizan muchas veces y los vectores son de gran tamaño, optaremos por la búsqueda binaria, pero antes debemos ordenar el vector.</li> </ul> <h4 id="búsqueda-secuencial"> <a href="#búsqueda-secuencial" class="anchor-heading" aria-labelledby="búsqueda-secuencial"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Búsqueda secuencial </h4> <p>Consiste, simplemente, en <strong>recorrer el vector desde el primer elemento hasta el último</strong>.</p> <p>Si encontramos el dato buscado, podemos interrumpir la búsqueda. Si no, continuaremos hasta el final del vector.</p> <p>Esta es una posible implementación en pseudocódigo, suponiendo que el vector tiene 100 elementos. Míralo despacio y ejecuta a mano el algoritmo. ¡Esas ejecuciones con lápiz y papel son un excelente ejercicio para los/las programadores/as principiantes!</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  // Búsqueda secuencial
  // Buscamos el elemento "dato" en el vector "v"
  Definir i, posicion, v como Entero
  Dimension v[100]
  i &lt;- 0
  posicion &lt;- -1               // Si posición vale -1 significa que
                               // aún no hemos encontrado lo que buscamos
  
  Mientras i &lt; 100 y posicion = -1 hacer
     Si v[i] = dato  Entonces  // ¡Lo hemos encontrado!
        posicion &lt;- i         // Anotamos la posición
     FinSi
     i &lt;- i + 1
  FinMientras

  Si posicion &gt;= 0 Entonces
     Escribir "El dato ", dato, " estaba en la posición ", posicion
  SiNo
     Escribir "No he encontrado el dato ", dato, " en el vector"
  FinSi
</code></pre></div></div> <h4 id="búsqueda-binaria"> <a href="#búsqueda-binaria" class="anchor-heading" aria-labelledby="búsqueda-binaria"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Búsqueda binaria </h4> <p>Para que esta búsqueda funcione, como hemos dicho, <strong>el vector debe estar previamente ordenado</strong>.</p> <p>El <strong>método de búsqueda binaria</strong> consiste en lo siguiente:</p> <ul> <li><strong>Paso 1</strong>. Supongamos que v es el vector y que contiene N elementos. Llamaremos <em>izq</em> a la posición del elemento izquierdo del array (inicialmente, izq = 0). Llamaremos <em>der</em> a la posición del elemento derecho del array (inicialmente, der = N-1)</li> <li><strong>Paso 2</strong>. Tomamos un x igual al punto medio entre izq y der, es decir, x &lt;- (izq/der) / 2</li> <li><strong>Paso 3</strong>. Miramos el elemento v[x]. Si es el dato que buscábamos, ya hemos terminado. Si no, pueden ocurrir dos cosas: <ul> <li><strong>3a</strong>. Que v[x] sea mayor que el dato que buscábamos. En ese caso, y dado que el array está ordenado, continuamos la búsqueda a la izquierda de x, haciendo que der &lt;- x.</li> <li><strong>3b</strong>. Que v[x] sea menor que el dato que buscábamos. En ese caso, continuamos la busqueda a la derecha de x, haciendo izq &lt;- x.</li> </ul> </li> <li><strong>Paso 4</strong>. Repetimos desde el paso 2 hasta que encontremos el elemento buscado o hasta que izq = der (lo que significará que el elemento no está en el vector)</li> </ul> <p>Esta es una posible implementación en pseudocódigo. Recuerda: no mires el código por encima para pasar a otra cosa. Léelo con calma, como si fueran las instrucciones para montar un mueble de Ikea, y ejecútalo con lápiz y papel hasta que te asegures de que entiendes cómo funciona.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Búsqueda binaria.
// Buscamos el elemento "busc" en el vector "v", que debe estar previamente ordenado de menor a mayor.
// Supondremos que "v" es un vector de enteros de 100 elementos, por ejemplo.

   Definir izq, der, mitad, encontrado como Entero

   // Iniciamos una búsqueda binaria
   encontrado &lt;- 0
   izq &lt;- 0    // Primera posición del vector
   der &lt;- 99   // Última posición del vector

   Mientras izq &lt; der-1 y encontrado = 0 Hacer
      mitad &lt;- izq + ((der - izq) / 2)    // Calculamos la posición "mitad"
      Si v[mitad] = busc Entonces
         // ¡Lo hemos encontrado!
         encontrado &lt;- 1
      FinSi
      Si v[mitad] &gt; busc Entonces
         // Seguiremos buscando por la mitad izquierda
         der &lt;- mitad
      FinSi
      Si v[mitad] &lt; busc Entonces
         // Seguiremos buscando por la mitad derecha
         izq &lt;- mitad
   FinMientras

   Si encontrado = 1 Entonces
      Escribir "El dato ", busc, " está en la posición ", encontrado, " del vector"
   SiNo
      Escribir "El dato ", busc, " no está en el vector"
   FinSi
</code></pre></div></div> <p>Este algoritmo de búsqueda es más complejo que el secuencial, como puede verse, pero los tiempos de búsqueda con el método binario son mucho más pequeños.</p> <p>Para un vector de N elementos, el método secuencial necesita un promedio de N/2 pasos para localizar el elemento buscado, mientras que el método binario tarda una media de log<sub>2</sub>N pasos.</p> <p>¿No te parece una diferencia muy impresionante? Fíjate en estos datos:</p> <ul> <li>Si el vector es pequeño (por ejemplo, N = 10): <ul> <li>a. La búsqueda secuencial necesita una media de 5 pasos.</li> <li>b. La búsqueda binaria necesita una media de 3 pasos.</li> </ul> </li> <li>Si el vector es mediano (por ejemplo, N = 100): <ul> <li>a. La búsqueda secuencial necesita una media de 50 pasos.</li> <li>b. La búsqueda binaria necesita una media de 6 ó 7 pasos.</li> </ul> </li> <li>Si el vector es grande (por ejemplo, N = 1000), la mejora de tiempo empieza a ser notable: <ul> <li>a. La búsqueda secuencial necesita una media de 500 pasos.</li> <li>b. La búsqueda binaria necesita una media de… ¡10 pasos!</li> </ul> </li> <li>Si el vector es muy grande (por ejemplo, N = 100.000), la mejora de tiempo es aún mayor: <ul> <li>a. La búsqueda secuencial necesita una media de 50.000 pasos.</li> <li>b. La búsqueda binaria necesita una media de sólo 16 pasos.</li> </ul> </li> </ul> <p>La mejora en el tiempo de búsqueda es, por lo tanto, mayor cuanto mayor es el vector. Por eso dijimos que la búsqueda binaria se emplea cuando los vectores son muy grandes.</p> <h2 id="43-arrays-bidimiensionales-matrices"> <a href="#43-arrays-bidimiensionales-matrices" class="anchor-heading" aria-labelledby="43-arrays-bidimiensionales-matrices"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.3. Arrays bidimiensionales (matrices) </h2> <p>Una <strong>matriz</strong>, <strong>tabla</strong> o <strong>array bidimiensional</strong>, igual que un vector, es una colección de elementos individuales, todos del mismo tipo, agrupados bajo el mismo identificador.</p> <p>La diferencia con el vector es que, en el momento de declararlo y de acceder a cada elemento individual, debemos utilizar <strong>dos índices</strong> en lugar de uno.</p> <p>Una matriz de, por ejemplo, 4x4 elementos, se declara así:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Definir matriz como Entero
Dimension matriz[4][4]
</code></pre></div></div> <p>La variable <em>matriz</em> no consta de 4 elementos enteros, sino de 16, organizados en 4 filas y 4 columnas. Podemos representar gráficamente la matriz como una tabla:</p><pre>
     Filas
       |
       V
     +----+----+----+----+----+
     |    |  0 |  1 |  2 |  3 |   &lt;-- Columnas
     +----+----+----+----+----+
     |  0 |    |    |    |    |
     +----+----+----+----+----+
     |  1 |    |    |    |    |
     +----+----+----+----+----+
     |  2 |    |    |    |    |
     +----+----+----+----+----+
     |  3 |    |    |    |    |
     +----+----+----+----+----+
</pre><p><strong>Cada casilla de la matriz es identificable mediante una pareja de índices</strong>. Normalmente, el primero de los índices se refiere a la fila y, el segundo, a la columna.</p> <p>Por ejemplo, si hacemos estas asignaciones:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>matriz[0][0] &lt;- 5
matriz[1][0] &lt;- 1
matriz[3][2] &lt;- 13
</code></pre></div></div> <p>…el estado en el que quedará la matriz anterior será este:</p><pre>
     Filas
       |
       V
     +----+----+----+----+----+
     |    |  0 |  1 |  2 |  3 |   &lt;-- Columnas
     +----+----+----+----+----+
     |  0 |  5 |    |    |    |
     +----+----+----+----+----+
     |  1 |  1 |    |    |    |
     +----+----+----+----+----+
     |  2 |    |    |    |    |
     +----+----+----+----+----+
     |  3 |    |    | 13 |    |
     +----+----+----+----+----+
</pre><p>Por descontado, los dos tamaños de la matriz pueden ser diferentes, obteniéndose tablas que son más anchas que altas o más altas que anchas.</p> <p>Por lo demás, <strong>las matrices se utilizan exactamente igual que los vectores</strong>. A modo de ejemplo, este sería el código para inicializar una matriz de 5x10 enteros con todos sus elementos a 0. Observa cómo se usan los dos bucles anidados para acceder a todos los elementos:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Definir i, j como Entero
Definir m como Entero
Dimension m[5][10]

Para i &lt;- 0 hasta 4 hacer
   Para j &lt;- 0 hasta 9 hacer
       m[i][j] &lt;- 0
   FinPara
FinPara
</code></pre></div></div> <h2 id="44-arrays-de-múltiples-dimensiones"> <a href="#44-arrays-de-múltiples-dimensiones" class="anchor-heading" aria-labelledby="44-arrays-de-múltiples-dimensiones"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.4. Arrays de múltiples dimensiones </h2> <p>Del mismo modo que a los arrays unidimensionales (vectores) se les puede añadir un segundo índice, obteniendo las matrices, se puede generalizar esta práctica, dando lugar a <strong>arrays multidimensionales</strong>.</p> <p>Por ejemplo, el siguiente es un array de cinco dimensiones compuesto de números enteros:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Definir ejemplo como Entero
Dimension ejemplo[10][10][4][5][7];
</code></pre></div></div> <p>Estos arrays no se pueden representar gráficamente (aunque con los de tres dimensiones se puede intentar dibujar un cubo), pero su utilización es idéntica a la de los arrays de una o dos dimensiones.</p> <h2 id="45-programación-modular-subalgoritmos"> <a href="#45-programación-modular-subalgoritmos" class="anchor-heading" aria-labelledby="45-programación-modular-subalgoritmos"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.5. Programación modular: subalgoritmos </h2> <p>Los algoritmos tienden a hacerse muy grandes cuando tratamos de resolver un problema complejo. Esto es lógico, ¿no te parece? Cuanto más complicado sea el problema, más difícil y largo será plantear su solución.</p> <p>Para enfrentar este hecho inevitable existe la <strong>programación modular</strong>. Consiste en algo tan simple como dividir el problema en subproblemas más sencillos, y estos a su vez en otros más sencillos, hasta que tengamos un conjunto de mucho problemas pequeñitos que sí podemos resolver individualmente de forma simple. Después, solo nos queda unir todas las piezas del puzle para obtener nuestra solución compleja.</p> <p>Cada una de esas soluciones a pequeños problemas se denomina <strong>subalgoritmo</strong> (no es un nombre muy original, lo sé). Y esta técnica de descomposición sucesiva en problemas complejos en subproblemas simples se conoce como <strong>divide y vencerás</strong> (<em>divide and conquer</em>, en inglés). Es muy útil no solo en programación, sino en la mayor parte de los problemas del mundo real.</p> <h3 id="451-algoritmo-principal-y-subalgoritmos"> <a href="#451-algoritmo-principal-y-subalgoritmos" class="anchor-heading" aria-labelledby="451-algoritmo-principal-y-subalgoritmos"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.5.1. Algoritmo principal y subalgoritmos </h3> <p>El problema principal siempre se resuelve en un algoritmo que denominaremos <strong>algoritmo principal</strong>. Este es el que hará de “pegamento” del puzle.</p> <p>Los subproblemas más sencillos se resolverán en <strong>subalgoritmos</strong>, también llamados <strong>módulos</strong> a secas. Los subalgoritmos están subordinados al algoritmo principal, de manera que éste es el que decide cuándo debe ejecutarse cada subalgoritmo y con qué conjunto de datos.</p> <p>El algoritmo principal realiza <strong>llamadas</strong> o <strong>invocaciones</strong> a los subalgoritmos, mientras que estos le devuelven resultados. Así, el algoritmo principal va recogiendo todos los resultados y puede generar la solución al problema global.</p> <p>Cuando el algoritmo principal hace una llamada al subalgoritmo (es decir, lo invoca), se empiezan a ejecutar las instrucciones del subalgoritmo. Cuando este termina, la ejecución continúa por la instrucción siguiente a la de invocación. También se dice que el subalgoritmo devuelve el control al algoritmo principal, ya que éste toma de nuevo el control del flujo de instrucciones después de habérselo cedido temporalmente al subalgoritmo.</p> <p>El programa principal puede invocar a cada subalgoritmo el número de veces que sea necesario. A su vez, cada subalgoritmo puede invocar a otros subalgoritmos, y éstos a otros, etc. Cada subalgoritmo devolverá el control al algoritmo que lo invocó.</p> <p>Lógicamente, <strong>los subalgoritmos deben tener asignado un nombre</strong> para que puedan ser invocados desde el algoritmo principal. Ahora bien, la forma de declarar un subalgoritmo varía ligeramente según el tipo de subalgoritmo de que se trate. Porque existen dos tipos de subalgoritmo, llamados <strong>funciones</strong> y <strong>procedimientos</strong>, que vamos a ver enseguida.</p> <h3 id="452-funciones"> <a href="#452-funciones" class="anchor-heading" aria-labelledby="452-funciones"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.5.2. Funciones </h3> <p>Las <strong>funciones</strong> son subalgoritmos que resuelven un problema sencillo y <strong>devuelven un resultado</strong> al algoritmo que las invoca. Esto último es lo que las distingue de los procedimientos.</p> <p>Las funciones pueden tener argumentos, aunque no es obligatorio. Los <strong>argumentos</strong> son los datos que se proporcionan a la función en la invocación, y que la función utilizará para sus cálculos.</p> <p>Las funciones tienen, obligatoriamente, que devolver un resultado. Si no lo hacen, no son funciones. Este resultado suele almacenarse en una variable para usarlo posteriormente.</p> <p>Veamos un ejemplo. Nuevamente, emplearemos la sintaxis del pseudocódigo de PSeInt, pero cualquier otro pseudocódigo o lenguaje de programación real utilizará una sintaxis semejante.</p> <p>Supongamos que tenemos estamos escribiendo un programa para calcular los precios de unos artículos a la venta en una tienda. Vamos a escribir un subalgoritmo que se encargue de calcular el IVA de cada artículo.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Algoritmo precios
	Definir nombre como cadena
	Definir precio como real
	Definir precio_con_iva como real
	
	Repetir
	Escribir "Dime el nombre de otro artículo:"
		Leer nombre
		Escribir "Dime su precio (negativo para terminar):"
		Leer precio
		precio_con_iva &lt;- precio + calcular_iva(precio)
		Escribir "El precio con IVA es ", precio_con_iva
	Hasta Que precio &lt; 0
FinAlgoritmo

SubAlgoritmo iva &lt;- calcular_iva(precio)
	Definir porcentaje como real
	Definir iva como real
	iva &lt;-  precio * 0.21   // Suponemos que el IVA es el 21%
FinSubalgoritmo
</code></pre></div></div> <p>En este ejemplo puedes ver cómo <strong>se declara un subalgoritmo</strong>:</p> <ul> <li>Se utiliza la palabra <strong>SubAlgoritmo</strong></li> <li>Se indica a continuación cuál es el dato que devolverá al algoritmo principal (en este caso, la variable <em>iva</em>)</li> <li>Luego se indica su nombre, <em>calcular_iva</em> y, entre paréntesis, los datos que recibirá del algoritmo principal (en este ejemplo, <em>precio</em>). Esos datos se denominan <em>parámetros</em> del subalgoritmo.</li> <li>Después se escribe el código del subalgoritmo. Fíjate en que es un código completamente normal, como el de cualquier algoritmo.</li> </ul> <p>Los lenguajes de programación, de hecho, poseen un puñado de funciones predefinidas de las que ya hemos usado unas cuántas. ¿Recuerdas cuando usabas las funciones azar(), truncar() o redondear()? No son más que funciones, es decir, subalgoritmos, que ya vienen incorporados al lenguaje de programación.</p> <h3 id="453--procedimientos"> <a href="#453--procedimientos" class="anchor-heading" aria-labelledby="453--procedimientos"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.5.3. Procedimientos </h3> <p>Los <strong>procedimientos</strong> son subalgoritmos que no devuelven ningún valor al algoritmo principal. Es decir, sin como las funciones, pero no devuelven ninguna variable al terminar.</p> <p>La declaración de un procedimiento es similar a la de una función. Lo vemos en este ejemplo, sacado el juego de las 3 en raya del tema anterior. Si repasas aquel ejercicio resuelto, verás que está lleno de procedimientos.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Algoritmo tres_en_raya
	Definir tablero Como Caracter
	Dimension tablero[10]
	
	inicializar(tablero)
	mostrar(tablero)
   // Etc (el juego de las tres en raya continuaba a partir de aquí)
FinAlgoritmo

SubAlgoritmo inicializar(tablero por referencia) 
	Definir i como entero
	Para i &lt;- 1 hasta 9 Hacer
		tablero[i] &lt;- " "
	FinPara
FinSubAlgoritmo

SubAlgoritmo mostrar(tablero)
	Escribir "ESTADO ACTUAL DEL TABLERO"
	Escribir "+---+---+---+"
	Escribir "| ",tablero[1]," | ",tablero[2]," | ",tablero[3]," |"
	Escribir "+---+---+---+"
	Escribir "| ",tablero[4]," | ",tablero[5]," | ",tablero[6]," |"
	Escribir "+---+---+---+"
	Escribir "| ",tablero[7]," | ",tablero[8]," | ",tablero[9]," |"
	Escribir "+---+---+---+"	
FinSubAlgoritmo
</code></pre></div></div> <p>Este algoritmo principal invoca a dos procedimientos: uno, llamado <em>inicializar()</em>, se encarga de poner un espacio en blanco en cada posición del tablero. Otro, llamado <em>mostrar()</em>, se encarga de dibujar el tablero en la pantalla. Como ves, cada subalgoritmo tiene el encargo de resolver una pequeña parte del problema global.</p> <p>Fíjate en que la declaración de los procedimientos es idéntica a la de las funciones, pero sin devolver ninguna variable.</p> <h3 id="454-invocación-de-subalgoritmos"> <a href="#454-invocación-de-subalgoritmos" class="anchor-heading" aria-labelledby="454-invocación-de-subalgoritmos"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.5.4. Invocación de subalgoritmos </h3> <p>Para que las instrucciones escritas en un subalgoritmo sean ejecutadas es necesario, como ya hemos dicho, que el subalgoritmo se <em>llame</em> o <em>invoque</em> desde otro algoritmo.</p> <p>La invocación consiste en una mención al <strong>nombre del subalgoritmo</strong> seguida, entre paréntesis, de los <strong>valores que se desan asignar a los parámetros</strong>. Deben aparecer tantos valores como parámetros tenga el subalgoritmo, y además coincidir en el tipo de datos.</p> <p>Estos parámetros se podrán utilizar, dentro del subalgoritmo, como cualquier otra variable.</p> <p>Como las funciones devuelven valores, la <strong>invocación de una función</strong> debe aparecer a la derecha de una <strong>instrucción de asignación</strong>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>precio_con_iva &lt;- precio + calcular_iva(precio)
</code></pre></div></div> <p>En cambio, como los procedimientos no devuelven ningún valor, la <strong>invocación de un procedimiento</strong> nunca aparece en una instrucción de asignación:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>inicializar(tablero)
mostrar(tablero)
</code></pre></div></div> <h3 id="455-paso-de-parámetros"> <a href="#455-paso-de-parámetros" class="anchor-heading" aria-labelledby="455-paso-de-parámetros"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.5.5. Paso de parámetros </h3> <p>XXXX El paso de parámetros, o comunicación de datos del algoritmo invocante al subalgoritmo invocado, puede hacerse mediante, al menos, dos métodos: • Paso de parámetros por valor, que es la forma más sencilla pero no permite al subalgoritmo devolver resultados en los parámetros. • Paso de parámetros por referencia, que es más complejo pero permite a los subalgoritmos devolver resultados en los parámetros. Veamos cada método detenidamente. Paso de parámetros por valor Los subalgoritmos/subprogramas, como hemos visto, pueden tener una serie de parámetros en su declaración. Estos parámetros se denominan parámetros formales. Ejemplo: Una función que calcula la potencia de un número elevado a otro real función potencia(base es real, exponente es real) inicio devolver (base ^ exponente) fin En esta declaración de función, base y exponente son parámetros formales. Cuando el subalgoritmo es invocado, se le pasan entre paréntesis los valores de los parámetros. A éstos se les denomina parámetros actuales; por ejemplo: A = 5 B = 3 C = potencia(A,B) En esta invocación de la función potencia(), los parámetros actuales son A y B, es decir, 5 y 3. Al invocar un subalgritmo, los parámetros actuales son asignados a los parámetros formales en el mismo orden en el que fueron escritos. Dentro del subalgoritmo, los parámetros se pueden utilizar como si fueran variables. Así, en el ejemplo anterior, dentro de la función potencia(), el parámetro base puede usarse como una variable a la que se hubiera asignado el valor 5, mientras que exponente es como una variable a la que se hubiera asignado el valor 3. Cuando el subalgoritmo termina de ejecutarse, sus parámetros formales base y exponente dejan de existir y se devuelve el resultado (en nuestro ejemoplo, 53), que se asigna a la variable C. Paso de parámetros por referencia En el paso de parámetros por referencia se produce una ligadura entre el parámetro actual y el parámetro formal, de modo que si el parámetro formal se modifica dentro del subalgoritmo, el parámetro actual, propio del algoritmo principal, también será modificado. Los argumentos pasan sus parámetros por valor excepto cuando indiquemos que el paso es por referencia colocando el símbolo * (asterisco) delante del nombre del argumento. Ejemplo: Escribiremos el mismo subalgoritmo de antes, pero utilizando un procedimiento (que, en principio, no devuelve resultados) en lugar de una función. procedimiento potencia(base es real, exponente es real, *resultado es real) inicio resultado = base ^ exponente fin Observa el símbolo * delante del nombre del argumento resultado: esa es la señal de que el paso de parámetros será por referencia para ese argumento. Si no aparece el símbolo *, el paso será por valor, como es el caso de los argumentos base y exponente. La invocación del subalgoritmo se hace del mismo modo que hasta ahora, pero delante del parámetro que se pasa por referencia debe colocarse el símbolo &amp;: A = 5 B = 3 C = 0 potencia(A, B, &amp;C) En este caso, pasamos tres parámetros actuales, ya que el subalgoritmo tiene tres parámetros formales. El tercero de ellos, C, se pasa por referencia (para señalar esta circunstancia, se antepone el símbolo &amp;), y por lo tanto queda ligado al parámetro formal resultado. El parámetro formal es modificado en la instrucción resutado = base ^ exponente, y como está ligado con el parámetro actual C, el valor de la variable C también se modifica. Por lo tanto, C toma el valor 53. Cuando el subalgoritmo termina de ejecutarse, dejan de existir todos sus parámetros formales (base, exponente y resultado), pero la ligadura de resultado con la variable C hace que esta variable conserve el valor 53 incluso cuando el parámetro resultado ya no exista. Diferencias entre los métodos de paso de parámetros La utilidad del método de paso de parámetros por referencia es evidente: un subalgoritmo puede devolver tantos resultados como argumentos tenga, y no tiene que limitarse a un único resultado, como en el caso de las funciones. El paso de parámetros por referencia suele, por lo tanto, usarse en procedimientos que tienen que devolver muchos resultados al algoritmo que los invoca. Cuando el resultado es sólo uno, lo mejor es emplear una función. Esto no quiere decir que las funciones no puedan tener argumentos pasados por referencia: al contrario, a veces es muy útil. Expresado de otro modo: • el paso por valor es unidireccional, es decir, sólo permite transmitir datos del algoritmo al subalgoritmo a través de los argumentos. • el paso por referencia es bidireccional, es decir, permite transmitir datos del algoritmo al subalgoritmo, pero también permite al subalgoritmo transmitir resultados al algoritmo. 7.5 El problema del ámbito Variables locales Se llama ámbito de una variable a la parte de un programa donde dicha variable puede utilizarse. En principio, todas las variables declaradas en un algoritmo son locales a ese algoritmo, es decir, no existen fuera del algoritmo, y, por tanto, no pueden utilizarse más allá de las fronteras marcadas por inicio y fin. El ámbito de una variable es local al algoritmo donde se declara. Cuando el algoritmo comienza, las variables se crean, reservándose un espacio en la memoria RAM del ordenador para almacenar su valor. Cuando el algoritmo termina, todas sus variables se destruyen, liberándose el espacio en la memoria RAM. Todos los resultados que un algoritmo obtenga durante su ejecución, por lo tanto, se perderán al finalizar, salvo que sean devueltos al algoritmo que lo invocó o sean dirigidos a algún dispositivo de salida (como la pantalla). Esta forma de funcionar ayuda a que los algoritmos sean módulos independientes entre sí, que únicamente se comunican los resultados de sus procesos unos a otros. Ejemplo: Calcular el cuadrado de un valor X introducido por teclado utilizando diseño modular. algoritmo cuadrado variables N, result son reales inicio leer(N) calcular_cuadrado() escribir(“El cuadrado es “, result) fin</p> <p>procedimiento cacular_cuadrado () // Calcula el cuadrado de un número inicio result = N ^ 2 fin En este algoritmo hay un grave error, ya que se han intentado utilizar las variables result y N, que son locales al algoritmo principal, en el subalgoritmo cuadrado(), desde donde no son accesibles. Es importante señalar que en algunos lenguajes de programación, y bajo determinadas circunstancias, cuando un algoritmo invoca a un subalgoritmo, puede que todas las variables locales del algoritmo estén disponibles en el subalgoritmo. Así, el ejemplo anterior podría llegar a ser correcto. Esto no ocurre en C, debido a que no se pueden anidar funciones dentro de funciones, pero debe ser tenido en cuenta por el alumno/a si en algún momento debe programar en otro lenguaje. El problema que surge en esas situaciones es similar al de las variables globales que tratamos a continuación. Variables globales En ocasiones es conveniente utilizar variables cuyo ámbito exceda el del algoritmo donde se definen y puedan utilizarse en varios algoritmos y subalgoritmos. Las variables globales implican una serie de riesgos, como veremos más adelante, por lo que no deben utilizarse a menos que sea estrictamente necesario. A pesar de los riesgos, la mayoría de los lenguajes de programación disponen de algún mecanismo para manejar variables globales. Aunque ese mecanismo varía mucho de un lenguaje a otro, diremos como regla general que las variables globales deben declararse en el algoritmo principal, anteponiendo el identificador global al nombre de la variable, siendo entonces accesibles a todos los algoritmos y subalgoritmos que conformen el programa. Ejemplo: Calcular el cuadrado de un valor X introducido por teclado utilizando diseño modular. algoritmo cuadrado variables global N es real global result es reales inicio leer(N) calcular_cuadrado() escribir(“El cuadrado es “, result) fin</p> <p>procedimiento cacular_cuadrado () // Calcula el cuadrado de un número inicio result = N ^ 2 fin El error que existía antes ya no ocurre, porque ahora las variables result y N han sido declaradas como globales en el algoritmo principal, y por lo tanto pueden utilizarse en cualquier subalgoritmo, como cuadrado(). Pudiera ocurrir que una variable global tenga el mismo nombre que una variable local. En ese caso, el comportamiento depende del lenguaje de programación (los hay que ni siquiera lo permiten), pero lo habitual es que la variable local sustituya a la global, haciendo que ésta última sea inaccesible desde el interior del subalgoritmo. Al terminar la ejecución del subalgoritmo y destruirse la variable local, volverá a estar accesible la variable global que, además, habrá conservado su valor, pues no ha podido ser modificada desde el subalgoritmo. De todas formas, y puestos a evitar la utilización de variables globales (a menos que no quede otro remedio), con más razón aún evitaremos usar variables locales que tengan el mismo nombre que las globales. Los efectos laterales Al utilizar variables globales, muchas de las ventajas de la programación modular desaparecen. Efectivamente, la filosofía de la programación modular consiste en diseñar soluciones sencillas e independientes (llamadas módulos) para problemas sencillos, haciendo que los módulos se comuniquen entre sí sólo mediante el paso de parámetros y la devolución de resultados. Cuando empleamos variables globales como en el ejemplo anterior, se crea una comunicación alternativa entre módulos a través de la variable global. Ahora un módulo puede influir por completo en otro modificando el valor de una variable global. Los módulos dejan de ser “compartimentos estanco” y pasan a tener fuertes dependencias mutuas que es necesario controlar. Cuando el programa es complejo y consta de muchos módulos, ese control de las dependencias es cada vez más difícil de hacer. Cualquier comunicación de datos entre un algoritmo y un subalgoritmo al margen de los parámetros y la devolución de resultados se denomina efecto lateral. Los efectos laterales, como el ilustrado en el ejemplo anterior, son peligrosísimos y fuente habitual de malfuncionamiento de los programas. Por esa razón, debemos tomar como norma: • Primero, evitar la utilización de variables globales. • Segundo, si no quedara más remedio que emplear variables globales, no hacer uso de ellas en el interior de los procedimientos y las funciones, siendo preferible pasar el valor de la variable global como un parámetro más al subalgoritmo. • Por último: si, a pesar de todo, decidimos usar variables globales por algún motivo, asegurarnos de que sabemos por qué lo hacemos y de que lo documentamos bien. 7.6 La reutilización de módulos El diseño modular tiene, entre otras ventajas, la posibilidad de reutilizar módulos previamente escritos. Es habitual que, una vez resuelto un problema sencillo mediante una función o un procedimiento, ese mismo problema, o uno muy parecido, se nos presente más adelante, durante la realización de otro programa. Entonces nos bastará con volver a utilizar esa función o procedimiento, sin necesidad de volver a escribirlo. Es por esto, entre otras razones, que los módulos deben ser independientes entre sí, comunicándose con otros módulos únicamente mediante los datos de entrada (paso de parámetros por valor) y los de salida (devolución de resultados – en las funciones – y paso de parámetros por referencia). Los módulos que escribamos de este modo nos servirán probablemente para otros programas, pero no así los módulos que padezcan efectos laterales, pues sus relaciones con el resto del programa del que eran originarios serán diferentes y difíciles de precisar. Es habitual agrupar varios algoritmos relacionados (por ejemplo: varios algoritmos que realicen diferentes operaciones matemáticas) en un mismo archivo, formando lo que se denomina una biblioteca de funciones. Cada lenguaje trata las librerías de manera distinta, de modo que volveremos sobre este asunto al estudiar el lenguaje C. Por último, señalemos que, para reutilizar con éxito el código, es importante que esté bien documentado. En concreto, en cada algoritmo deberíamos documentar claramente: • la función del algoritmo, es decir, explicar qué hace • los parámetros de entrada • los datos de salida, es decir, el resultado que devuelve o la forma de utilizar los parámetros por referencia Ejemplo: Documentaremos la función potencia(), que hemos utilizado como ejemplo en otras partes de este capítulo. Es un caso exagerado, pues la función es muy sencilla y se entiende sin necesidad de tantos comentarios, pero ejemplifica cómo se puede hacer la documentación de una función. { Función: potencia() –&gt; Calcula una potencia de números enteros Entrada: base –&gt; Base de la potencia exponente –&gt; Exponente de la potencia Salida: base elevado a exponente }</p> <p>real función potencia(base es real, exponente es real) inicio devolver (base ^ exponente) fin</p> <p>8 Algunas reglas de estilo No podemos finalizar esta primera parte del libro sin referirnos a algunas reglas de estilo básicas que deben observarse a la hora de escribir código fuente. Y es que la escritura de un algoritmo debe ser siempre lo más clara posible, ya se esté escribiendo en pseudocódigo o en un lenguaje de programación real. La razón es evidente: los algoritmos pueden llegar a ser muy complejos, y si a su complejidad le añadimos una escritura sucia y desordenada, se volverán ininteligibles. Esto es un aviso para navegantes: todos los programadores han experimentado la frustración que se siente al ir a revisar un algoritmo redactado pocos días antes y no entender ni una palabra de lo que uno mismo escribió. Multiplíquese esto por mil en el caso de revisión de algoritmos escritos por otras personas. Por esta razón, y ya desde el principio, debemos acostumbrarnos a respetar ciertas reglas básicas en cuanto al estilo de escritura. Por supuesto, un programa puede funcionar correctamente sin aplicar ninguna de las cosas que vamos a mencionar aquí, pero no es a la corrección a lo que nos referimos ahora, sino al estilo. Por cierto: cada programador desarrollará con el tiempo su estilo de codificación propio, pero debería hacerlo siempre dentro de un marco aceptado por la mayoría, salvo que piense desarrollar su carrera como programador en Saturno. 8.1 Partes de un algoritmo Los algoritmos deberían tener siempre una estructura en tres partes: 1 - Cabecera 2 - Declaraciones 3 - Acciones Algunos lenguajes, C entre ellos, son lo bastante flexibles como para permitir saltarse a la torera esta estructura, pero es una buena costumbre respetarla siempre: • La cabecera: contiene el nombre del programa o algoritmo. • Las declaraciones: contiene las declaraciones de variables y constantes que se usan en el algoritmo • Las acciones: son el cuerpo en sí del algoritmo, es decir, las instrucciones Puedes observar esta estructura en todos los ejemplos que hemos visto hasta ahora. 8.2 Documentación La documentación del programa comprende el conjunto de información interna y externa que facilita su posterior mantenimiento. • La documentación externa la forman todos los documentos ajenos al programa: guías de instalación, guías de usuario, etc. • La documentación interna es la que acompaña al programa. Nosotros sólo nos ocuparemos, por ahora, de esta documentación. La forma más habitual de plasmar la documentación interna es por medio de comentarios significativos que acompañen a las instrucciones del algoritmo o programa. Los comentarios son líneas de texto insertadas entre las instrucciones, o bien al lado, que se ignoran durante la ejecución del programa y aclaran el funcionamiento del algoritmo a cualquier programador que pueda leerlo en el futuro. Para que el ordenador sepa qué debe ignorar y qué debe ejecutar, los comentarios se escriben precedidos de determinados símbolos que la máquina interpreta como “principio de comentario” o “fin de comentario”. Los símbolos que marcan las zonas de comentario dependen del lenguaje de programación, como es lógico. Así, por ejemplo, en Pascal se escriben encerrados entre los símbolos (* y <em>): (</em> Esto es un comentario en Pascal <em>) El lenguaje C, sin embargo, utiliza los símbolos /</em> y <em>/ para marcar los comentarios. Además, C++ permite emplear la doble barra ( / / ) para comentarios que ocupen sólo una línea. Nosotros usaremos indistintamente estos dos métodos: /</em> Esto es un comentario en C <em>/ // Esto es un comentario en C++ Ejemplo: Escribir un algoritmo que sume todos los números naturales de 1 hasta 1000 algoritmo sumar1000 /</em> Función: Sumar los números naturales entre 1 y 1000 Autor: Nombre y apellidos Fecha: 08-11-17 */</p> <p>variables cont es entero /* variable contador <em>/ suma es entero /</em> variable acumulador <em>/ N es entero inicio suma = 0 /</em> se pone el acumulador a 0 <em>/ para cont desde 1 hasta 1000 hacer /</em> repetir 1000 veces <em>/ inicio suma = suma + cont /</em> los números se suman al acumulador <em>/ fin escribir (suma) fin Este es un ejemplo de algoritmo comentado. Observa que los comentarios aparecen a la derecha de las instrucciones, encerrados entre llaves. A efectos de ejecución, se ignora todo lo que haya escrito entre los símbolos /</em> y <em>/, pero a efectos de documentación y mantenimiento, lo que haya escrito en los comentarios puede ser importantísimo. Una buena e interesante costumbre es incluir un comentario al principio de cada algoritmo que explique bien la función del mismo y, si se considera necesario, el autor, la fecha de modificación y cualquier otra información que se considere interesante. Pero ¡cuidado! Comentar un programa en exceso no sólo es tedioso para el programador, sino contraproducente, porque un exceso de documentación lo puede hacer más ilegible. Sólo hay que insertar comentarios en los puntos que se considere que necesitan una explicación. En este sentido, el algoritmo del ejemplo está demasiado comentado. 8.3 Estilo de escritura A lo largo de este capítulo has podido ver diversos ejemplos de algoritmos. Si te fijas en ellos, todos siguen ciertas convenciones en el uso de la tipografía, las sangrías, los espacios, etc. Escribir los algoritmos cumpliendo estas reglas es una sana costumbre. Sangrías Las instrucciones que aparezcan debajo de “inicio” deben tener una sangría mayor que dicha instrucción. Ésta sangría se mantendrá hasta la aparición del “fin” correspondiente. Esto es particularmente importante cumplirlo si existen varios bloques inicio–fin anidados. Asimismo, un algoritmo es más fácil de leer si los comentarios tienen todos la misma sangría. Ejemplo: Escribir un algoritmo que determine, entre dos números A y B, cuál es el mayor o si son iguales. Observa bien las sangrías de cada bloque de instrucciones, así como la posición alineada de los comentarios. algoritmo comparar // Función: Comparar dos números A y B variables A,B son enteros inicio leer (A) // leemos los dos números del teclado leer (B) si (A == B) entonces // los números son iguales inicio escribir (‘Los dos números son iguales’) fin si_no // los números son distintos, así que inicio // vamos a compararlos entre sí si (A &gt; B) entonces inicio // A es mayor escribir (‘A es mayor que B’) fin si_no inicio // B es mayor escribir (‘B es mayor que A’) fin fin fin Cuándo prescindir de “inicio” y “fin” Cuando un bloque de instrucciones sólo contiene una instrucción, podemos escribirla directamente, sin necesidad de encerrarla entre un “inicio” y un “fin”. Esto suele redundar en una mayor facilidad de lectura. Ejemplo: Repetiremos el mismo ejemplo anterior, prescindiendo de los “inicio” y “fin” que no sean necesarios. Fíjate en que el algoritmo es más corto y, por lo tanto, más fácil de leer y entender. algoritmo comparar // Función: Comparar dos números A y B variables A,B son enteros inicio leer (A) // leemos los dos números del teclado leer (B) si (A == B) entonces // los números son iguales escribir (‘Los dos números son iguales’) si_no // los números son distintos, así que inicio // vamos a compararlos entre sí si (A &gt; B) entonces // A es mayor escribir (‘A es mayor que B’) si_no // B es mayor escribir (‘B es mayor que A’) fin fin Tipografía En todos los ejemplos del tema hemos resaltado las palabras del pseudocódigo en negrita, para distinguirlas de identificadores de variable, símbolos, etc. Esto también aumenta la legibilidad del algoritmo, pero, cuando utilicemos un lenguaje de programación real, no será necesario hacerlo, ya que los editores de texto que se usan en programación suelen estar preparados para resaltar las palabras reservadas. Ahora bien, si vas a escribir un algoritmo con un procesador de texto normal o usando pseudocódigo, es conveniente que uses una fuente de tamaño fijo o monoespaciada (el tipo Courier New es el que hemos empleado en la versión impresa de este texto; si lo estás leyendo en un e-reader, el tipo concreto dependerá del dispositivo). A veces se distinguen en negrita las palabras clave del lenguaje para facilitar la lectura de los algoritmos. Los editores de texto orientados a la programación (hablaremos de ellos más adelante) hacen algo parecido: siempre usan un tipo de fuente monoespaciado, y colorean el código para distinguir de un solo vistazo palabras reservadas, números, literales y otros elementos del lenguaje, de modo que facilitan enormemente la legibilidad. Espacios Otro elemento que aumenta la legibilidad es espaciar suficientemente (pero no demasiado) los distintos elementos de cada instrucción. Por ejemplo, esta instrucción ya es bastante complicada y difícil de leer: si (a &gt; b) y (c &gt; d * raiz(k) ) entonces a = k + 5.7 * b Pero se lee mucho mejor que esta otra, en la que se han suprimido los espacios (excepto los imprescindibles): si (a&gt;b)y(c&gt;d</em>raiz(k))entonces a=k+5.7*b Al ordenador le dará igual si escribimos (a &gt; b) o (a&gt;b), pero a cualquier programador que deba leer nuestro código le resultará mucho más cómoda la primera forma. Por la misma razón, también es conveniente dejar líneas en blanco entre determinadas instrucciones del algoritmo cuando se considere que mejora la legibilidad. Identificadores A la hora de elegir identificadores de variables (o de constantes) es muy importante utilizar nombres que sean significativos, es decir, que den una idea de la información que almacena esa variable. Por ejemplo, si en un programa de nóminas vamos a guardar en una variable la edad de los empleados, es una buena ocurrencia llamar a esa variable “edad”, pero no llamarla “X”, “A” o “cosa”. Ahora bien, dentro de esta política de elegir identificadores significativos, es conveniente optar por aquellos que sean lo más cortos posible, siempre que sean descifrables. Así, un identificador llamado “edad_de_los_empleados” es engorroso de escribir y leer, sobre todo si aparece muchas veces en el algoritmo, cuando probablemente “edad_empl” proporciona la misma información. Sin embargo, si lo acortamos demasiado (por ejemplo “ed_em”) llegará un momento en el quede claro lo que significa. Toda esta idea de significación de los identificadores es extensible a los nombres de los algoritmos, de las funciones, de los procedimientos, de los archivos y, en general, de todos los objetos relacionados con un programa. Por último, señalar que muchos lenguajes de programación distinguen entre mayúsculas y minúsculas, es decir, que para ellos no es lo mismo el identificador “edad” que “Edad” o “EDAD”. Es conveniente, por tanto, ir acostumbrándose a esta limitación. Nosotros preferiremos usar identificadores en minúscula, por ser lo más habitual entre los programadores de lenguaje C.</p> <h2 id="46-ejercicios-propuestos"> <a href="#46-ejercicios-propuestos" class="anchor-heading" aria-labelledby="46-ejercicios-propuestos"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.6. Ejercicios propuestos </h2> <h4 id="ejercicios-de-vectores-arrays-unidimensionales"> <a href="#ejercicios-de-vectores-arrays-unidimensionales" class="anchor-heading" aria-labelledby="ejercicios-de-vectores-arrays-unidimensionales"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ejercicios de vectores (arrays unidimensionales) </h4> <p><strong>Ejercicio 1: Inicializar un vector</strong>. Escribe un programa en pseudocódigo en el que se defina un vector de 100 números enteros, se inicialicen todos los elementos al valor –1 y se impriman por pantalla.</p> <p><strong>Ejercicio 2: Inicializar un vector (más complejo)</strong>. Define dos vectores de 100 números enteros, uno llamado <em>pares</em> y otro <em>impares</em>. Inicializa el primero con los 100 primeros números pares positivos (es decir, pares[0] contendrá el valor 2, pares[1] contendrá el valor 4, pares[2] contendrá el valor 6, y así sucesivamente). Inicializa el segundo con los 100 primeros números impares positivos. Imprímelo por pantalla para comprobar que lo has hecho correctamente.</p> <p><strong>Ejercicio 3: Lotería primitiva</strong>. Escribe un programa que genere al azar una combinación para jugar a la lotería primitiva asegurándote de que ningún número se repite. Pista: puedes utilizar un array de 6 números enteros, asignando a cada posición un número entero aleatorio entre 1 y 49, y comprobando que el número asignado no es igual a ninguno de los asignados anteriormente.</p> <p><strong>Ejercicio 4. Estadística básica</strong>. Escribe un programa que pida al usuario N números enteros (siendo N un valor introducido por teclado) y calcule el valor medio de todos ellos, mostrando luego en la pantalla los números que están por encima de la media y los que están por debajo de ella.</p> <p><strong>Ejercicio 5. Ordenar vector gigante</strong>. Escribe un programa que defina un vector de 1000 elementos y lo inicialice con valores aleatorios entre 0 y 2.000.000. Posteriormente, el programa debe ordenar los elementos del array de menor a mayor. Prueba luego a cambiar el tamaño del vector hasta los 10.000, 100.000 y 1.000.000 de elementos. ¿El tiempo de respuesta del programa crece linealmente con el tamaño del vector?</p> <p><strong>Ejercicio 6. Vector creciente</strong>. Escribe un programa que defina un vector de 10 enteros y lo rellene con números CRECIENTES al azar entre 1 y 100. Es decir, los números serán elegidos aleatoriamente pero siempre tienen que ser mayores que los anteriores: el número que ocupe la posición 1 debe ser mayor que el de la posición 0, el de la posición 2 mayor que el de la 1, y así sucesivamente.</p> <p>Después de eso, se pedirá al usuario un número entre 1 y el número mayor que exista en el vector. El número introducido por el usuario se insertará en la posición del vector adecuada para conservar el orden, desplazando los demás elementos hacia la derecha, de manera que se pierda el último elemento.</p> <p>Después de insertar el número introducido por el usuario, el contenido del vector debe mostrarse por la pantalla. El proceso se repetirá hasta que el usuario introduzca un número negativo.</p> <p>Por ejemplo, supongamos que el array generado al azar por el ordenador, después de ordenarlo, es este:</p><pre>
     4 – 18 – 23 – 25 – 44 - 45 – 51 – 72 – 78 - 85
</pre><p>Como el número más alto es 85, el programa debe pedir al usuario:</p><pre>
     Introduzca un número entre 1 y 85: _
</pre><p>Si el usuario teclea, por ejemplo, el número 67, éste debe ser insertado en la posición adecuada para conservar el orden, es decir, entre los números 51 y 72, desplazando a los demás números hacia la derecha, con lo cual se pierde el mayor de todos ellos (85). El vector quedaría así:</p><pre>
    4 – 18 – 23 – 25 – 44 - 45 – 51 – 67 - 72 – 78
</pre><h4 id="ejercicios-de-matrices-arrays-bidimensionales"> <a href="#ejercicios-de-matrices-arrays-bidimensionales" class="anchor-heading" aria-labelledby="ejercicios-de-matrices-arrays-bidimensionales"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Ejercicios de matrices (arrays bidimensionales) </h4> <p><strong>Ejercicio 7. Inicializar matriz simple</strong>. Escribe un programa en el que se defina una matriz de 10x10 números enteros. Inicializa todos los elementos al valor –1.</p> <p><strong>Ejercicio 8. Inicializar matriz complejo</strong>. Repite el ejercicio anterior, inicializando ahora todas las filas pares al valor 0 y todas las filas impares al valor –1.</p> <p><strong>Ejercicio 9. Sumar filas</strong>. Escribe un programa que defina una matriz de 6x3 números enteros y luego pida al usuario que introduzca los valores de cada elemento. Después, el programa debe sumar los tres números de cada fila, mostrando los resultados.</p> <p><strong>Ejercicio 10. Permutar filas</strong>. Escribe un programa que defina una matriz de 3x5 números enteros y luego pida al usuario que introduzca los valores de cada elemento. Después, debe permutar el contenido de la fila 3 por el de la fila 1, y mostrar por último el contenido de la matriz.</p> <p><strong>Ejercicio 11. Sumar matrices</strong>. Escribe un programa que defina dos matrices de 10x5 números enteros y las inicialice con números aleatorios entre 0 y 255. Posteriormente, cada elemento de la primera matriz debe ser sumado con el mismo elemento de la segunda matriz, guardando el resultado en una tercera matriz. Se deben sumar todas las parejas de elementos y mostrar el resultado en la pantalla.</p> <p><strong>Ejercicio 12. Jugueteando con matrices</strong>. Escribe un programa que genere al azar una matriz cuadrada de NxN números enteros (siendo N un valor introducido por el usuario) y que luego haga lo siguiente:</p> <ul> <li> <p><em>Mostrar</em>. Mostrará la matriz tal y como ha sido generada.</p> </li> <li> <p><em>Perímetro</em>. Mostrará los elementos que ocupan el borde de la matriz, partiendo de la esquina superior izquierda y recorriéndola hacia la derecha y luego hacia abajo.</p> </li> <li> <p><em>Centro</em>. Mostrará los elementos que ocupan el centro geométrico de la matriz. Puede ser 1 (si N es impar) o 4 (si N es par).</p> </li> <li> <p><em>Espiral</em>. Hará un recorrido en espiral por la matriz partiendo de la esquina superior izquierda.</p> </li> </ul> <p>Por ejemplo, si la matriz fuera de 4x4 y tuviera este contenido:</p><pre>
    4 6 7 8
    2 4 3 9
    0 1 3 4
    7 3 3 5
</pre><p>…las distintas operaciones deben obtener este resultado:</p> <ul> <li>Perímetro: 4 6 7 8 9 4 5 3 3 7 0 2</li> <li>Centro: 4 3 1 3</li> <li>Espiral: 4 6 7 8 9 4 5 3 3 7 0 2 4 3 3 1</li> </ul> <h2 id="47-ejercicios-resueltos"> <a href="#47-ejercicios-resueltos" class="anchor-heading" aria-labelledby="47-ejercicios-resueltos"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 4.7. Ejercicios resueltos </h2> <p>(Iremos poniendo aquí los ejercicios resueltos en clase)</p> <hr> <h2 class="text-delta">Table of contents</h2> <ul> </ul> </div> </div> <div class="search-overlay"></div> </div> </body> </html>
